<IssueDetails>
  <IssueDetail>
    <IssueLabelID>19814</IssueLabelID>
    <Title>Local test run experience is systematically degrading</Title>
    <Description>Observing recent changes to the test run infrastructure I have been impacted by the following problems:

1. Test run startup is painfully slow
    1. Python script runs very slow and seems to be very inefficient (it may take up to 2 - 3 min before actual tests start
    2. Test discovery after CoreRun is launched takes ad infinitum in comparison to experience from before couple of weeks

2. Test run info:
    1. Std out info is polluted with multiple error messages from python script
    2. There is no summary table after test run if tests fail - it was possible so far to see breakdown of failing tests per XUnit wrapper

</Description>
    <Title_Description>Local test run experience is systematically degrading Observing recent changes to the test run infrastructure I have been impacted by the following problems:

1. Test run startup is painfully slow
    1. Python script runs very slow and seems to be very inefficient (it may take up to 2 - 3 min before actual tests start
    2. Test discovery after CoreRun is launched takes ad infinitum in comparison to experience from before couple of weeks

2. Test run info:
    1. Std out info is polluted with multiple error messages from python script
    2. There is no summary table after test run if tests fail - it was possible so far to see breakdown of failing tests per XUnit wrapper

</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>3/09/2018 10:09:37 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19812</IssueLabelID>
    <Title>Fix ICU load on OpenSUSE Tumbleweed</Title>
    <Description>For some reason OpenSUSE Tumbleweed has decided to prefix the
version number in the SO name of the ICU libraries by "suse".
That prevents our ICU version detection code from working.

This change adds scanning for SO names that contain that prefix too.</Description>
    <Title_Description>Fix ICU load on OpenSUSE Tumbleweed For some reason OpenSUSE Tumbleweed has decided to prefix the
version number in the SO name of the ICU libraries by "suse".
That prevents our ICU version detection code from working.

This change adds scanning for SO names that contain that prefix too.</Title_Description>
    <Label>area-System.Globalization</Label>
    <Assignee>janvorli</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19810</IssueLabelID>
    <Title>Allow StructLayoutAttribute to specify automatic size rounding up to next power of 2 for better perf</Title>
    <Description>One of the uses is - say there is raw buffer allocated for N instances of structure which may contain generic fields say constrained with .

In my somewhat skewed benchmarks manually rounding up structure sizes shows execution time improvement up to x1.5-2.</Description>
    <Title_Description>Allow StructLayoutAttribute to specify automatic size rounding up to next power of 2 for better perf One of the uses is - say there is raw buffer allocated for N instances of structure which may contain generic fields say constrained with .

In my somewhat skewed benchmarks manually rounding up structure sizes shows execution time improvement up to x1.5-2.</Title_Description>
    <Label>area-TypeSystem</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>3/09/2018 6:29:43 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19807</IssueLabelID>
    <Title>Missing IL offset information sometimes causes bad stack traces</Title>
    <Description>The repro is here: [https://github.com/evgrud/dotnet-stack-trace-offsets-issue](https://github.com/evgrud/dotnet-stack-trace-offsets-issue)

When running it on Release (with tiered compilation disabled) you will see that the stack trace of the exception that is thrown points to the beginning of the function while the correct location is at its end.

I tested it on Windows 10 x64.

I ran it with JITDump and it seems that during  some of the statements aren't getting IL offsets which later during the inlining are expanded into new basic blocks without IL offsets which eventually during runtime results in a bad stack trace when an exception is thrown within those basic blocks.

I don't know if this issue should be fixed but I can suggest reporting native offsets in those cases instead of pointing to the top of the function which could be way off.

category:implementation
theme:debug-info
skill-level:intermediate
cost:small</Description>
    <Title_Description>Missing IL offset information sometimes causes bad stack traces The repro is here: [https://github.com/evgrud/dotnet-stack-trace-offsets-issue](https://github.com/evgrud/dotnet-stack-trace-offsets-issue)

When running it on Release (with tiered compilation disabled) you will see that the stack trace of the exception that is thrown points to the beginning of the function while the correct location is at its end.

I tested it on Windows 10 x64.

I ran it with JITDump and it seems that during  some of the statements aren't getting IL offsets which later during the inlining are expanded into new basic blocks without IL offsets which eventually during runtime results in a bad stack trace when an exception is thrown within those basic blocks.

I don't know if this issue should be fixed but I can suggest reporting native offsets in those cases instead of pointing to the top of the function which could be way off.

category:implementation
theme:debug-info
skill-level:intermediate
cost:small</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19806</IssueLabelID>
    <Title>Not consistent integer remainder behavior at the corner case</Title>
    <Description>The remainder operator under consideration is the [% operator](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/expressions#remainder-operator)

The corner case is the following:
- the left operand equals  into zero (against the spec) and .NET doesn't mirror that behavior yet.</Description>
    <Title_Description>Not consistent integer remainder behavior at the corner case The remainder operator under consideration is the [% operator](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/expressions#remainder-operator)

The corner case is the following:
- the left operand equals  into zero (against the spec) and .NET doesn't mirror that behavior yet.</Title_Description>
    <Label>tracking-external-issue</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>2/09/2018 8:36:20 PM +00:00</CreatedAt>
    <ClosedAt>3/09/2018 5:35:16 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19805</IssueLabelID>
    <Title>[arm64|Unix] segmentation fault when running any test</Title>
    <Description>Stack trace below.

</Description>
    <Title_Description>[arm64|Unix] segmentation fault when running any test Stack trace below.

</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>jashook</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19804</IssueLabelID>
    <Title>Clean CodeGen::genEmitCall</Title>
    <Description>This PR cleans ).

Also it refactors their code a bit and extracts common parts into platform independent methods.

Found during my work on #19361.

No diffs on x86/x64.</Description>
    <Title_Description>Clean CodeGen::genEmitCall This PR cleans ).

Also it refactors their code a bit and extracts common parts into platform independent methods.

Found during my work on #19361.

No diffs on x86/x64.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>1/09/2018 7:31:06 PM +00:00</CreatedAt>
    <ClosedAt>6/09/2018 11:03:10 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19778</IssueLabelID>
    <Title>Add 2.2 sdk/runtime to JitBench</Title>
    <Description>
    </Description>
    <Title_Description>Add 2.2 sdk/runtime to JitBench </Title_Description>
    <Label>area-TieredCompilation</Label>
    <Assignee>kouvel</Assignee>
    <CreatedAt>30/08/2018 11:25:10 PM +00:00</CreatedAt>
    <ClosedAt>19/09/2018 10:29:02 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19777</IssueLabelID>
    <Title>[local gc] Enable gc_profiling for local gc</Title>
    <Description>Fix for #11515. It turns out most of the work had been done previously and my recent PR (#19500 ) did the remaining work. So all that was left was to re-enable the definition of  for local gc</Description>
    <Title_Description>[local gc] Enable gc_profiling for local gc Fix for #11515. It turns out most of the work had been done previously and my recent PR (#19500 ) did the remaining work. So all that was left was to re-enable the definition of  for local gc</Title_Description>
    <Label>area-GC</Label>
    <Assignee>davmason</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19776</IssueLabelID>
    <Title>[release/2.2] Change prerelease label to be more accurate</Title>
    <Description>Not critical but better than servicing</Description>
    <Title_Description>[release/2.2] Change prerelease label to be more accurate Not critical but better than servicing</Title_Description>
    <Label>
    </Label>
    <Assignee>weshaggard</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19774</IssueLabelID>
    <Title>[local gc]  move DacNotifyGCMarkEnd and AnalyzeSurvivorsRequested to GCToEEInterface </Title>
    <Description>Fix for #17771</Description>
    <Title_Description>[local gc]  move DacNotifyGCMarkEnd and AnalyzeSurvivorsRequested to GCToEEInterface  Fix for #17771</Title_Description>
    <Label>area-GC</Label>
    <Assignee>davmason</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19773</IssueLabelID>
    <Title>Add short guide for using tiered compilation and how to provide feedback</Title>
    <Description>
    </Description>
    <Title_Description>Add short guide for using tiered compilation and how to provide feedback </Title_Description>
    <Label>area-TieredCompilation</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19770</IssueLabelID>
    <Title>Fix CoreCLR debug launch</Title>
    <Description>
    </Description>
    <Title_Description>Fix CoreCLR debug launch </Title_Description>
    <Label>
    </Label>
    <Assignee>mikem8361</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19769</IssueLabelID>
    <Title>Build error: MSB4018: System.Exception: The package ID 'runtime.gentoo.-x64.Microsoft.NETCore.Runtime.CoreCLR' contains invalid characters. Examples of valid package IDs include 'MyPackage' and 'MyPackage.Sample'. [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Runtime.CoreCLR/Microsoft.NETCore.Runtime.CoreCLR.pkgproj]</Title>
    <Description>I'm trying to build Dotnet from the release/2.2 branch on a Gentoo box but run into issues. I'm not (yet) familiar with your project structure please tell me if I'm doing something wrong or reporting this in the wrong place. For what it's worth I observe nearly identical errors with the 2.1 branch.

To avoid errors caused by stale Nuget files HOME is set to an empty directory. The top-level directory is a clean checkout of the current :
 &lt;https://gist.github.com/eroen/d48f0c139e00198a6cb0ef728d4ac3cb&gt;</Description>
    <Title_Description>Build error: MSB4018: System.Exception: The package ID 'runtime.gentoo.-x64.Microsoft.NETCore.Runtime.CoreCLR' contains invalid characters. Examples of valid package IDs include 'MyPackage' and 'MyPackage.Sample'. [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Runtime.CoreCLR/Microsoft.NETCore.Runtime.CoreCLR.pkgproj] I'm trying to build Dotnet from the release/2.2 branch on a Gentoo box but run into issues. I'm not (yet) familiar with your project structure please tell me if I'm doing something wrong or reporting this in the wrong place. For what it's worth I observe nearly identical errors with the 2.1 branch.

To avoid errors caused by stale Nuget files HOME is set to an empty directory. The top-level directory is a clean checkout of the current :
 &lt;https://gist.github.com/eroen/d48f0c139e00198a6cb0ef728d4ac3cb&gt;</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>30/08/2018 7:11:21 PM +00:00</CreatedAt>
    <ClosedAt>22/06/2019 8:52:49 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19766</IssueLabelID>
    <Title>Enable BSTR Marshaling Support for x-plat PInvoke</Title>
    <Description>Fix https://github.com/dotnet/coreclr/issues/19735

Workitem:
1. [Done]Enable BSTR Marshalling on PInvoke
2. [Done]Add more testing for BSTR PInvoke-- Windows compile/run OK
3. [Exclude] Test BSTR Pinvoke in Linux</Description>
    <Title_Description>Enable BSTR Marshaling Support for x-plat PInvoke Fix https://github.com/dotnet/coreclr/issues/19735

Workitem:
1. [Done]Enable BSTR Marshalling on PInvoke
2. [Done]Add more testing for BSTR PInvoke-- Windows compile/run OK
3. [Exclude] Test BSTR Pinvoke in Linux</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>luqunl</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19764</IssueLabelID>
    <Title>[TieredCompilation] Hot method when inlined never reaches tier 1</Title>
    <Description>The problem arises in application processing data with one very hot method doing 9999% of the work which is inlined into cold method. Hot method never reaches tier1 compilation due to lack of tracking of it's pseudo calls and never gets optimized. The impact on application overall performance is 5 - 7 % performance regression.

Hot method cannot be prevented from inlining as this would cause much higher performance regression.</Description>
    <Title_Description>[TieredCompilation] Hot method when inlined never reaches tier 1 The problem arises in application processing data with one very hot method doing 9999% of the work which is inlined into cold method. Hot method never reaches tier1 compilation due to lack of tracking of it's pseudo calls and never gets optimized. The impact on application overall performance is 5 - 7 % performance regression.

Hot method cannot be prevented from inlining as this would cause much higher performance regression.</Title_Description>
    <Label>area-TieredCompilation</Label>
    <Assignee>4creators</Assignee>
    <CreatedAt>30/08/2018 8:58:05 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19763</IssueLabelID>
    <Title>typo fix</Title>
    <Description>Fixing typo in DAC notes. 
To be specific 
changed .</Description>
    <Title_Description>typo fix Fixing typo in DAC notes. 
To be specific 
changed .</Title_Description>
    <Label>documentation</Label>
    <Assignee>sywhang</Assignee>
    <CreatedAt>30/08/2018 8:45:07 AM +00:00</CreatedAt>
    <ClosedAt>30/08/2018 10:00:03 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19762</IssueLabelID>
    <Title>Fix UNKNOWN in dump generated by createdump</Title>
    <Description>https://github.com/dotnet/coreclr/pull/19761

With the current implementation an LLDB analysis of a dump generated with the -h option leads to UNKNOWN instead of type/method names in dumpheap -stat or dumpstack commands.
This is due to missing assemblies from which the sos/mscordac plugin are extracting metadata.

With this pull request the assemblies are now part of the dump without increasing too much the size: on a dual core machine full=11GB withheap=226MB withheap(+patch)=269MB

It is especially important to decrease the size of a "usable" memory dump in the context of containers for which disk space is restricted and time during which an application does not respond to help check is limited.

Note: does not seem to be fixed on 2.1*</Description>
    <Title_Description>Fix UNKNOWN in dump generated by createdump https://github.com/dotnet/coreclr/pull/19761

With the current implementation an LLDB analysis of a dump generated with the -h option leads to UNKNOWN instead of type/method names in dumpheap -stat or dumpstack commands.
This is due to missing assemblies from which the sos/mscordac plugin are extracting metadata.

With this pull request the assemblies are now part of the dump without increasing too much the size: on a dual core machine full=11GB withheap=226MB withheap(+patch)=269MB

It is especially important to decrease the size of a "usable" memory dump in the context of containers for which disk space is restricted and time during which an application does not respond to help check is limited.

Note: does not seem to be fixed on 2.1*</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>mikem8361</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19760</IssueLabelID>
    <Title>Basic implementation for testing of COM activation of a .NET class</Title>
    <Description>This represents a partial implementation for dotnet/core-setup#4476

It current contains the following:
* minimal SPCL API implementation - only for RegFree COM scenario
* implementation of a host library for testing of activation scenarios
  - Note the  exe and only for testing 
* basic unit test of the SPCL API
* simple e2e test using RegFree COM

cc @jkotas @jeffschwMSFT @luqunl </Description>
    <Title_Description>Basic implementation for testing of COM activation of a .NET class This represents a partial implementation for dotnet/core-setup#4476

It current contains the following:
* minimal SPCL API implementation - only for RegFree COM scenario
* implementation of a host library for testing of activation scenarios
  - Note the  exe and only for testing 
* basic unit test of the SPCL API
* simple e2e test using RegFree COM

cc @jkotas @jeffschwMSFT @luqunl </Title_Description>
    <Label>area-Interop</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>30/08/2018 4:26:58 AM +00:00</CreatedAt>
    <ClosedAt>11/09/2018 12:24:50 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19759</IssueLabelID>
    <Title>[TieredCompilation] Miscellaneous regressions with tiering need investigation</Title>
    <Description>- [x] JitBench Word2Vec benchmark’s "first search" numbers regressed significantly (350%)
  - Perhaps a case of cold method with hot loops (https://github.com/dotnet/coreclr/issues/19751)
  - Duplicate of https://github.com/dotnet/coreclr/issues/19751 until that is fixed tiering should be turned off for this test
- [x] Word2Vec's "training" is also slower but to a much lesser degree perhaps a combination of the above and https://github.com/dotnet/coreclr/issues/19752 until that is fixed tiering should be turned off for this test
  - Duplicate of https://github.com/dotnet/coreclr/issues/19751
- [x] JitBench CscRoslynSource benchark
  - Project compilation completes while there is still tier 0 activity occurring so call counting and tier 1 transitions don't happen
  - There's lots of room for throughput improvement with tier 1 JIT perhaps it needs better heuristics to determine when to transition
  - No regressions in first or subsequent iterations as of https://github.com/dotnet/coreclr/pull/18610
  - Tracking potential improvements separately
- [x] Potential code locality issues - see https://github.com/dotnet/coreclr/pull/19121#issuecomment-408014042 and https://github.com/dotnet/coreclr/pull/19121#issuecomment-409925789
  - Code locality issues are unconfirmed tracking potential improvements separately</Description>
    <Title_Description>[TieredCompilation] Miscellaneous regressions with tiering need investigation - [x] JitBench Word2Vec benchmark’s "first search" numbers regressed significantly (350%)
  - Perhaps a case of cold method with hot loops (https://github.com/dotnet/coreclr/issues/19751)
  - Duplicate of https://github.com/dotnet/coreclr/issues/19751 until that is fixed tiering should be turned off for this test
- [x] Word2Vec's "training" is also slower but to a much lesser degree perhaps a combination of the above and https://github.com/dotnet/coreclr/issues/19752 until that is fixed tiering should be turned off for this test
  - Duplicate of https://github.com/dotnet/coreclr/issues/19751
- [x] JitBench CscRoslynSource benchark
  - Project compilation completes while there is still tier 0 activity occurring so call counting and tier 1 transitions don't happen
  - There's lots of room for throughput improvement with tier 1 JIT perhaps it needs better heuristics to determine when to transition
  - No regressions in first or subsequent iterations as of https://github.com/dotnet/coreclr/pull/18610
  - Tracking potential improvements separately
- [x] Potential code locality issues - see https://github.com/dotnet/coreclr/pull/19121#issuecomment-408014042 and https://github.com/dotnet/coreclr/pull/19121#issuecomment-409925789
  - Code locality issues are unconfirmed tracking potential improvements separately</Title_Description>
    <Label>area-TieredCompilation</Label>
    <Assignee>kouvel</Assignee>
    <CreatedAt>30/08/2018 3:12:54 AM +00:00</CreatedAt>
    <ClosedAt>20/12/2018 6:23:33 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19758</IssueLabelID>
    <Title>API Proposal: Expose TheadPool.UnsafeQueueCustomWorkItem and IThreadPoolWorkItem</Title>
    <Description>When looking at a memory dump it would be great if we could see data about work items in the various queues. Some of the things that would be interesting to see per work item
- A display name (HttpRequest/TaskContinuation) that can be provided by the caller
- An elapsed time to know how long an item was in the queue

This sort of info might help when looking at dumps trying to diagnose issues with the thread pool.

To enable this and other optimized scheduling scenarios we should expose an interface that would allow customization of the underlying work item.

Proposal:

 (I'm not sure how it could anyways)

cc @stephentoub @kouvel @vancem </Description>
    <Title_Description>API Proposal: Expose TheadPool.UnsafeQueueCustomWorkItem and IThreadPoolWorkItem When looking at a memory dump it would be great if we could see data about work items in the various queues. Some of the things that would be interesting to see per work item
- A display name (HttpRequest/TaskContinuation) that can be provided by the caller
- An elapsed time to know how long an item was in the queue

This sort of info might help when looking at dumps trying to diagnose issues with the thread pool.

To enable this and other optimized scheduling scenarios we should expose an interface that would allow customization of the underlying work item.

Proposal:

 (I'm not sure how it could anyways)

cc @stephentoub @kouvel @vancem </Title_Description>
    <Label>area-System.Threading</Label>
    <Assignee>stephentoub</Assignee>
    <CreatedAt>30/08/2018 3:03:00 AM +00:00</CreatedAt>
    <ClosedAt>26/09/2018 3:47:51 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19757</IssueLabelID>
    <Title>[TieredCompilation] Background jitting at tier 1 may cause temporary noticeable slowdown in throughput</Title>
    <Description>Background jitting at tier 1 may cause a substantial slowdown in throughput of other threads despite there being enough CPU power to handle all scheduled parallel work without context-switching due to time slicing though for a relatively short duration.

Don't have a repro at the moment but shouldn't be too difficult to create one. There was a scenario where an ASP.NET server saw ~7x slowdown in 2 consecutive requests (out of over 1000) after about 1.5 minutes of serving requests from startup. That coincided with a significant amount of tier 1 jitting.

Any small amount of tier 0 activity (tier 0 jitting or pregenerated code lookup) is treated as "startup-like work" and tiered compilation delays call counting and tier 1 transitions as long as such work is happening even occasionally. At some point when such startup-like work stops for a sufficiently long duration the now-long list of pending methods to call-count and transition to tier 1 is processed and the overhead of call counting and background tier 1 jitting becomes noticeable in the decrease in throughput. The overhead of call counting is understandable (and by design at the moment) but background tier 1 jitting also contributes significantly to the degradation in throughput though both are temporary. A suspicion was that there are frequently taken locks in the type system that get in the way of each thread making optimal progress.

The issue is much more noticeable by disabling the call counting delay ().</Description>
    <Title_Description>[TieredCompilation] Background jitting at tier 1 may cause temporary noticeable slowdown in throughput Background jitting at tier 1 may cause a substantial slowdown in throughput of other threads despite there being enough CPU power to handle all scheduled parallel work without context-switching due to time slicing though for a relatively short duration.

Don't have a repro at the moment but shouldn't be too difficult to create one. There was a scenario where an ASP.NET server saw ~7x slowdown in 2 consecutive requests (out of over 1000) after about 1.5 minutes of serving requests from startup. That coincided with a significant amount of tier 1 jitting.

Any small amount of tier 0 activity (tier 0 jitting or pregenerated code lookup) is treated as "startup-like work" and tiered compilation delays call counting and tier 1 transitions as long as such work is happening even occasionally. At some point when such startup-like work stops for a sufficiently long duration the now-long list of pending methods to call-count and transition to tier 1 is processed and the overhead of call counting and background tier 1 jitting becomes noticeable in the decrease in throughput. The overhead of call counting is understandable (and by design at the moment) but background tier 1 jitting also contributes significantly to the degradation in throughput though both are temporary. A suspicion was that there are frequently taken locks in the type system that get in the way of each thread making optimal progress.

The issue is much more noticeable by disabling the call counting delay ().</Title_Description>
    <Label>area-TieredCompilation</Label>
    <Assignee>kouvel</Assignee>
    <CreatedAt>30/08/2018 2:54:28 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19756</IssueLabelID>
    <Title>Update existing COM test assets (native/managed) to share CLSIDs with…</Title>
    <Description>… other projects.</Description>
    <Title_Description>Update existing COM test assets (native/managed) to share CLSIDs with… … other projects.</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>30/08/2018 1:29:46 AM +00:00</CreatedAt>
    <ClosedAt>30/08/2018 10:01:13 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19755</IssueLabelID>
    <Title>Unify assembly name creation</Title>
    <Description>
    </Description>
    <Title_Description>Unify assembly name creation </Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>30/08/2018 1:26:08 AM +00:00</CreatedAt>
    <ClosedAt>12/10/2018 5:31:35 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19754</IssueLabelID>
    <Title>Fire a runtime event when ThreadPool is being starved</Title>
    <Description>Thread pool starvation is a pretty common problem when working with code that uses the thread pool extensively. When exhaustion happens the application falls apart at the hinges because the scheduled work items just don't fire:

- Timer callbacks don't run
- Task continuations may not complete

etc.

There are a couple of situations where I think a diagnostic event can help:
- New work items are being enqueued at a rate faster than work items are being completed
- All threads are blocked but there's more work to be done (you've hit the max configured threads)

There's more scenarios but I don't precisely know enough about how the thread pool metrics and thread injection works to articulate it. Any other ideas would be welcome.

cc @brianrob @vancem @stephentoub @kouvel @geoffkizer </Description>
    <Title_Description>Fire a runtime event when ThreadPool is being starved Thread pool starvation is a pretty common problem when working with code that uses the thread pool extensively. When exhaustion happens the application falls apart at the hinges because the scheduled work items just don't fire:

- Timer callbacks don't run
- Task continuations may not complete

etc.

There are a couple of situations where I think a diagnostic event can help:
- New work items are being enqueued at a rate faster than work items are being completed
- All threads are blocked but there's more work to be done (you've hit the max configured threads)

There's more scenarios but I don't precisely know enough about how the thread pool metrics and thread injection works to articulate it. Any other ideas would be welcome.

cc @brianrob @vancem @stephentoub @kouvel @geoffkizer </Title_Description>
    <Label>area-System.Threading</Label>
    <Assignee>stephentoub</Assignee>
    <CreatedAt>30/08/2018 1:02:55 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19752</IssueLabelID>
    <Title>[TieredCompilation] Virtual calls may be slower with tiering</Title>
    <Description>With tiering there is an extra precode that calls would have to go through in some cases. If the processor does not compensate for the extra indirection virtual calls are slower (normal calls are too but that overhead is more easily compensated for with inlining).

See https://github.com/dotnet/coreclr/issues/18361 for an example where virtual call overhead is significant in the measurement.

Considerations:
- For virtual calls I had prototyped using the virtual slot with an indirect call instead of the precode and it eliminated the regression in the test case above. It looks like this would also close most of the steady-state perf gap in JitBench benchmarks between tiering and full-opt JIT alone. The idea seems promising it should be completed.
- For normal calls I had prototyped using an indirect call instead of jumping over a trampoline. There were marginal improvements during startup when with tier 0 JIT there would be more calls than at steady-state but nothing significant since R2R'ed code also does some inlining. Without R2R it may be more interesting.</Description>
    <Title_Description>[TieredCompilation] Virtual calls may be slower with tiering With tiering there is an extra precode that calls would have to go through in some cases. If the processor does not compensate for the extra indirection virtual calls are slower (normal calls are too but that overhead is more easily compensated for with inlining).

See https://github.com/dotnet/coreclr/issues/18361 for an example where virtual call overhead is significant in the measurement.

Considerations:
- For virtual calls I had prototyped using the virtual slot with an indirect call instead of the precode and it eliminated the regression in the test case above. It looks like this would also close most of the steady-state perf gap in JitBench benchmarks between tiering and full-opt JIT alone. The idea seems promising it should be completed.
- For normal calls I had prototyped using an indirect call instead of jumping over a trampoline. There were marginal improvements during startup when with tier 0 JIT there would be more calls than at steady-state but nothing significant since R2R'ed code also does some inlining. Without R2R it may be more interesting.</Title_Description>
    <Label>area-TieredCompilation</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19751</IssueLabelID>
    <Title>[TieredCompilation] Cold methods with hot loops may run slower with tiering</Title>
    <Description>) for such types of benchmarks

Considerations:
- Consider optimizing loops at tier 0 or methods containing loops. Data needs to be collected on how this would affect startup performance.
- Longer-term: A proper fix would probably involve at least some portions of what OSR involves</Description>
    <Title_Description>[TieredCompilation] Cold methods with hot loops may run slower with tiering ) for such types of benchmarks

Considerations:
- Consider optimizing loops at tier 0 or methods containing loops. Data needs to be collected on how this would affect startup performance.
- Longer-term: A proper fix would probably involve at least some portions of what OSR involves</Title_Description>
    <Label>area-TieredCompilation</Label>
    <Assignee>kouvel</Assignee>
    <CreatedAt>29/08/2018 11:57:43 PM +00:00</CreatedAt>
    <ClosedAt>3/04/2019 1:51:45 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19750</IssueLabelID>
    <Title>Enable IJW Native calling managed</Title>
    <Description>Enables filling in the vtable stubs that IJW native code needs to call into managed code. This change restores some of the code that was removed with the  removal. However that code included quite a bit of infrastructure for maintaining vtable thunks that could enter different AppDomains. That's not necessary on core so all of that code isn't coming back. This change only addresses loading an IJW assembly when the runtime has already been loaded. Activating the runtime and fixing vtables at that time will be handled separately.</Description>
    <Title_Description>Enable IJW Native calling managed Enables filling in the vtable stubs that IJW native code needs to call into managed code. This change restores some of the code that was removed with the  removal. However that code included quite a bit of infrastructure for maintaining vtable thunks that could enter different AppDomains. That's not necessary on core so all of that code isn't coming back. This change only addresses loading an IJW assembly when the runtime has already been loaded. Activating the runtime and fixing vtables at that time will be handled separately.</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>morganbr</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19746</IssueLabelID>
    <Title>Update the emitter to support 2-byte VEX prefix</Title>
    <Description>Currently the emitter only supports the 3-byte VEX prefix (outside a few specially handled instructions).
For normal floating-point arithmetic (or most 128-bit hardware intrinsics) this incurs an extra 1-byte per instruction.

It may be beneficial (for codegen size and potentially throughput) to update the emitter to also support the 2-byte VEX prefix.</Description>
    <Title_Description>Update the emitter to support 2-byte VEX prefix Currently the emitter only supports the 3-byte VEX prefix (outside a few specially handled instructions).
For normal floating-point arithmetic (or most 128-bit hardware intrinsics) this incurs an extra 1-byte per instruction.

It may be beneficial (for codegen size and potentially throughput) to update the emitter to also support the 2-byte VEX prefix.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>fiigii</Assignee>
    <CreatedAt>29/08/2018 11:02:22 PM +00:00</CreatedAt>
    <ClosedAt>11/12/2018 1:41:22 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19744</IssueLabelID>
    <Title>fix merge conflict in build-test.sh</Title>
    <Description>This method was renamed in #19430 but  #19213 did not notice this merge conflict.</Description>
    <Title_Description>fix merge conflict in build-test.sh This method was renamed in #19430 but  #19213 did not notice this merge conflict.</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>29/08/2018 10:12:47 PM +00:00</CreatedAt>
    <ClosedAt>30/08/2018 2:54:43 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19741</IssueLabelID>
    <Title>[Arm64] JIT/Regression/JitBlue/GitHub_19397 fails</Title>
    <Description>
    </Description>
    <Title_Description>[Arm64] JIT/Regression/JitBlue/GitHub_19397 fails </Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19739</IssueLabelID>
    <Title>Remove workaround from floatdouble and floatsingle after the /fp:fast bugs are resolved</Title>
    <Description>https://github.com/dotnet/coreclr/pull/19725 added workarounds to  return the appropriate values when compiled with MSVC.

This is tracked internally in the DevDiv bug database as workitem 673062 and 673060.</Description>
    <Title_Description>Remove workaround from floatdouble and floatsingle after the /fp:fast bugs are resolved https://github.com/dotnet/coreclr/pull/19725 added workarounds to  return the appropriate values when compiled with MSVC.

This is tracked internally in the DevDiv bug database as workitem 673062 and 673060.</Title_Description>
    <Label>area-VM</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>29/08/2018 6:07:09 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19735</IssueLabelID>
    <Title>Add support for MarshalAs(UnmanagedType.BSTR) on UNIX systems</Title>
    <Description>Although Marshal.StringToBStr et al. works fine on Mac. The following code

Is failing on Mac:
System.Runtime.InteropServices.MarshalDirectiveException: "Cannot marshal 'parameter #1': Invalid managed/unmanaged type combination (String parameters and return types must be paired with LPStr LPWStr or LPTStr)."
  at TestBSTR.Program.MyTest(String s Callback c)\n   at TestBSTR.Program.Main(String[] args) in /Users/odhanson/Projects/MyGuidTest/TestBSTR/Program.cs:15

Seems like (for looking at the code) this has only been implemented for windows (as part of COM support).

We are currently in the process of porting a FX application to Core that has extensive interop with existing native libraries (that are cross platform). The BSTR is used extensively and we would definitely need support for this type of marshaling.</Description>
    <Title_Description>Add support for MarshalAs(UnmanagedType.BSTR) on UNIX systems Although Marshal.StringToBStr et al. works fine on Mac. The following code

Is failing on Mac:
System.Runtime.InteropServices.MarshalDirectiveException: "Cannot marshal 'parameter #1': Invalid managed/unmanaged type combination (String parameters and return types must be paired with LPStr LPWStr or LPTStr)."
  at TestBSTR.Program.MyTest(String s Callback c)\n   at TestBSTR.Program.Main(String[] args) in /Users/odhanson/Projects/MyGuidTest/TestBSTR/Program.cs:15

Seems like (for looking at the code) this has only been implemented for windows (as part of COM support).

We are currently in the process of porting a FX application to Core that has extensive interop with existing native libraries (that are cross platform). The BSTR is used extensively and we would definitely need support for this type of marshaling.</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>richlander</Assignee>
    <CreatedAt>29/08/2018 2:17:08 PM +00:00</CreatedAt>
    <ClosedAt>6/12/2018 11:29:59 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19734</IssueLabelID>
    <Title>Question hosting a coreclr runtime with unix apis resolving packages from ".deps.json" file?</Title>
    <Description>From my understanding the unix hosting apis of the coreclr are low-level primitives that lack that ability to use the runtimeconfig.json file or the .deps.json file (which core-setup does).

So in order to run an application from the hosting APIs I must have deployed my app in it's entirety to a folder (NuGet packages and all) for the coreclr to find all the assemblies required to run my program. I could use )?</Description>
    <Title_Description>Question, hosting a coreclr runtime with unix apis, resolving packages from ".deps.json" file? From my understanding the unix hosting apis of the coreclr are low-level primitives that lack that ability to use the runtimeconfig.json file or the .deps.json file (which core-setup does).

So in order to run an application from the hosting APIs I must have deployed my app in it's entirety to a folder (NuGet packages and all) for the coreclr to find all the assemblies required to run my program. I could use )?</Title_Description>
    <Label>question</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>29/08/2018 12:54:20 PM +00:00</CreatedAt>
    <ClosedAt>29/08/2018 2:30:55 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19733</IssueLabelID>
    <Title>Strange codegen with struct forwarding implementation to another struct</Title>
    <Description>### Info

Setup: Runtime=.NET Core 2.1.3 (CoreCLR 4.6.26725.06 CoreFX 4.6.26725.05) 64bit RyuJIT
Code for repro is at this commit (I haven't reduced it to a minimal repro yet): https://github.com/Porges/Fastre/commit/3a2f805801556282bb341798edef9206af162256 (the 

You can see more of the disassembly here: https://gist.github.com/Porges/334ca424055be72470a67bc6eefe43a8

category:cq
theme:structs
skill-level:expert
cost:large</Description>
    <Title_Description>Strange codegen with struct forwarding implementation to another struct ### Info

Setup: Runtime=.NET Core 2.1.3 (CoreCLR 4.6.26725.06 CoreFX 4.6.26725.05) 64bit RyuJIT
Code for repro is at this commit (I haven't reduced it to a minimal repro yet): https://github.com/Porges/Fastre/commit/3a2f805801556282bb341798edef9206af162256 (the 

You can see more of the disassembly here: https://gist.github.com/Porges/334ca424055be72470a67bc6eefe43a8

category:cq
theme:structs
skill-level:expert
cost:large</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
    <CreatedAt>29/08/2018 9:45:13 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19731</IssueLabelID>
    <Title>Test failure: Interop_IJW._ManagedCallingNative_ManagedCallingNative_ManagedCallingNative_/_ManagedCallingNative_ManagedCallingNative_ManagedCallingNative_cmd</Title>
    <Description>Opened on behalf of @Sunny-pu

The test  has failed.


    Unhandled Exception: System.DllNotFoundException: Unable to load shared library 'kernel32.dll' or one of its dependencies. In order to help diagnose loading problems consider setting the DYLD_PRINT_LIBRARIES environment variable: dlopen(libkernel32.dll 1): image not found
       at ManagedCallingNative.ManagedCallingNative.LoadLibraryEx(String lpFileName IntPtr hReservedNull Int32 dwFlags)
       at ManagedCallingNative.ManagedCallingNative.Main(String[] args)
    /Users/dotnet-bot/dotnetbuild/work/e617ae5c-d07f-4bdb-bb60-bf8d42adec7c/Work/9bddec5f-6560-458e-8d2f-357577529060/Unzip/ManagedCallingNative/ManagedCallingNative/ManagedCallingNative.sh: line 244: 37549 Abort trap: 6           $_DebuggerFullPath \"$CORE_ROOT/corerun\" $ExePath $CLRTestExecutionArguments
    
    
    Return code:      1
    Raw output file:      /Users/dotnet-bot/dotnetbuild/work/e617ae5c-d07f-4bdb-bb60-bf8d42adec7c/Work/9bddec5f-6560-458e-8d2f-357577529060/Unzip/Reports\\Interop.IJW\\ManagedCallingNative\\ManagedCallingNative\\ManagedCallingNative.output.txt
    Raw output:
    BEGIN EXECUTION
    /Users/dotnet-bot/dotnetbuild/work/e617ae5c-d07f-4bdb-bb60-bf8d42adec7c/Payload/corerun ManagedCallingNative.exe
    Expected: 100
    Actual: 134
    END EXECUTION - FAILED
    Test Harness Exitcode is : 1
    
    To run the test:
    &gt; set CORE_ROOT=/Users/dotnet-bot/dotnetbuild/work/e617ae5c-d07f-4bdb-bb60-bf8d42adec7c/Payload
    &gt; /Users/dotnet-bot/dotnetbuild/work/e617ae5c-d07f-4bdb-bb60-bf8d42adec7c/Work/9bddec5f-6560-458e-8d2f-357577529060/Unzip/ManagedCallingNative/ManagedCallingNative/ManagedCallingNative.sh
    
    Expected: True
    Actual:   False

        Stack Trace:

           at Interop_IJW._ManagedCallingNative_ManagedCallingNative_ManagedCallingNative_._ManagedCallingNative_ManagedCallingNative_ManagedCallingNative_cmd() in E:\A\_work\80\s\bin\tests\Windows_NT.x64.Release\TestWrappers\Interop.IJW\Interop.IJW.XUnitWrapper.cs:line 111
Build : 3.0 - 20180829.01 (Core Tests)
Failing configurations:
- osx.1013.amd64-x64
  - 
- osx.1012.amd64-x64
  - 
- windows.10.arm64-arm
  - 
- Windows.81.Amd64-x64
  - 
- Windows.7.Amd64-x64
  - 
- Windows.10.Amd64.Core-x64
  - 
- Windows.10.Nano.Amd64-x64
  - 
- Windows.10.Amd64-x64
  - 
- Alpine.36.Amd64-x64
  - 
- sles.12.amd64-x64
  - 
- opensuse.423.amd64-x64
  - 
- ubuntu.1804.amd64-x64
  - 
- ubuntu.1604.amd64-x64
  - 
- ubuntu.1404.amd64-x64
  - 
- redhat.73.amd64-x64
  - 
- fedora.28.amd64-x64
  - 
- fedora.27.amd64-x64
  - 
- debian.82.amd64-x64
  - 
- redhat.69.amd64-x64
  - 
Details: https://mc.dot.net/#/product/netcore/30/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fcli~2F/build/20180829.01/workItem/Interop.IJW.XUnitWrapper/analysis/xunit/Interop_IJW._ManagedCallingNative_ManagedCallingNative_ManagedCallingNative_~2F_ManagedCallingNative_ManagedCallingNative_ManagedCallingNative_cmd</Description>
    <Title_Description>Test failure: Interop_IJW._ManagedCallingNative_ManagedCallingNative_ManagedCallingNative_/_ManagedCallingNative_ManagedCallingNative_ManagedCallingNative_cmd Opened on behalf of @Sunny-pu

The test  has failed.


    Unhandled Exception: System.DllNotFoundException: Unable to load shared library 'kernel32.dll' or one of its dependencies. In order to help diagnose loading problems consider setting the DYLD_PRINT_LIBRARIES environment variable: dlopen(libkernel32.dll 1): image not found
       at ManagedCallingNative.ManagedCallingNative.LoadLibraryEx(String lpFileName IntPtr hReservedNull Int32 dwFlags)
       at ManagedCallingNative.ManagedCallingNative.Main(String[] args)
    /Users/dotnet-bot/dotnetbuild/work/e617ae5c-d07f-4bdb-bb60-bf8d42adec7c/Work/9bddec5f-6560-458e-8d2f-357577529060/Unzip/ManagedCallingNative/ManagedCallingNative/ManagedCallingNative.sh: line 244: 37549 Abort trap: 6           $_DebuggerFullPath \"$CORE_ROOT/corerun\" $ExePath $CLRTestExecutionArguments
    
    
    Return code:      1
    Raw output file:      /Users/dotnet-bot/dotnetbuild/work/e617ae5c-d07f-4bdb-bb60-bf8d42adec7c/Work/9bddec5f-6560-458e-8d2f-357577529060/Unzip/Reports\\Interop.IJW\\ManagedCallingNative\\ManagedCallingNative\\ManagedCallingNative.output.txt
    Raw output:
    BEGIN EXECUTION
    /Users/dotnet-bot/dotnetbuild/work/e617ae5c-d07f-4bdb-bb60-bf8d42adec7c/Payload/corerun ManagedCallingNative.exe
    Expected: 100
    Actual: 134
    END EXECUTION - FAILED
    Test Harness Exitcode is : 1
    
    To run the test:
    &gt; set CORE_ROOT=/Users/dotnet-bot/dotnetbuild/work/e617ae5c-d07f-4bdb-bb60-bf8d42adec7c/Payload
    &gt; /Users/dotnet-bot/dotnetbuild/work/e617ae5c-d07f-4bdb-bb60-bf8d42adec7c/Work/9bddec5f-6560-458e-8d2f-357577529060/Unzip/ManagedCallingNative/ManagedCallingNative/ManagedCallingNative.sh
    
    Expected: True
    Actual:   False

        Stack Trace:

           at Interop_IJW._ManagedCallingNative_ManagedCallingNative_ManagedCallingNative_._ManagedCallingNative_ManagedCallingNative_ManagedCallingNative_cmd() in E:\A\_work\80\s\bin\tests\Windows_NT.x64.Release\TestWrappers\Interop.IJW\Interop.IJW.XUnitWrapper.cs:line 111
Build : 3.0 - 20180829.01 (Core Tests)
Failing configurations:
- osx.1013.amd64-x64
  - 
- osx.1012.amd64-x64
  - 
- windows.10.arm64-arm
  - 
- Windows.81.Amd64-x64
  - 
- Windows.7.Amd64-x64
  - 
- Windows.10.Amd64.Core-x64
  - 
- Windows.10.Nano.Amd64-x64
  - 
- Windows.10.Amd64-x64
  - 
- Alpine.36.Amd64-x64
  - 
- sles.12.amd64-x64
  - 
- opensuse.423.amd64-x64
  - 
- ubuntu.1804.amd64-x64
  - 
- ubuntu.1604.amd64-x64
  - 
- ubuntu.1404.amd64-x64
  - 
- redhat.73.amd64-x64
  - 
- fedora.28.amd64-x64
  - 
- fedora.27.amd64-x64
  - 
- debian.82.amd64-x64
  - 
- redhat.69.amd64-x64
  - 
Details: https://mc.dot.net/#/product/netcore/30/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fcli~2F/build/20180829.01/workItem/Interop.IJW.XUnitWrapper/analysis/xunit/Interop_IJW._ManagedCallingNative_ManagedCallingNative_ManagedCallingNative_~2F_ManagedCallingNative_ManagedCallingNative_ManagedCallingNative_cmd</Title_Description>
    <Label>test-run-uwp-coreclr</Label>
    <Assignee>morganbr</Assignee>
    <CreatedAt>29/08/2018 5:59:00 AM +00:00</CreatedAt>
    <ClosedAt>29/08/2018 11:26:34 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19728</IssueLabelID>
    <Title>Update BuildTools CoreClr CoreFx CoreSetup PgoData to preview1-03130-04 preview1-26830-04 preview1-26830-04 preview1-26830-01 master-20180830-0102 respectively (master)</Title>
    <Description>/cc @dotnet/coreclr-auto-update-notify</Description>
    <Title_Description>Update BuildTools, CoreClr, CoreFx, CoreSetup, PgoData to preview1-03130-04, preview1-26830-04, preview1-26830-04, preview1-26830-01, master-20180830-0102, respectively (master) /cc @dotnet/coreclr-auto-update-notify</Title_Description>
    <Label>
    </Label>
    <Assignee>ViktorHofer</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19724</IssueLabelID>
    <Title>R2RDump - Expand diffing functionality</Title>
    <Description>Presently R2RDump's diffing capabilities are limited to some summary statistics.
This issue tracks ensuring we generate rich and meaningful diff information specifically to be used for driving CQ of the cross-platform AOT compiler during bringup
</Description>
    <Title_Description>R2RDump - Expand diffing functionality Presently R2RDump's diffing capabilities are limited to some summary statistics.
This issue tracks ensuring we generate rich and meaningful diff information specifically to be used for driving CQ of the cross-platform AOT compiler during bringup
</Title_Description>
    <Label>area-R2RDump</Label>
    <Assignee>nattress</Assignee>
    <CreatedAt>28/08/2018 11:22:14 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19723</IssueLabelID>
    <Title>WIP NO-MERGE Dummy change to test dev/unix_test_workflow branch</Title>
    <Description>
    </Description>
    <Title_Description>WIP NO-MERGE Dummy change to test dev/unix_test_workflow branch </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>28/08/2018 11:16:32 PM +00:00</CreatedAt>
    <ClosedAt>12/09/2018 7:57:10 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19722</IssueLabelID>
    <Title>Missing includes in coreclr/src/debug/createdump/</Title>
    <Description>Attempting to bootstrap (with buildbootstrapcli.sh) fails with the following:

 fixes this but I'm guessing your preferred style puts that elsewhere seeing as this file doesn't include any of the other headers it obviously requires.</Description>
    <Title_Description>Missing includes in coreclr/src/debug/createdump/ Attempting to bootstrap (with buildbootstrapcli.sh) fails with the following:

 fixes this but I'm guessing your preferred style puts that elsewhere seeing as this file doesn't include any of the other headers it obviously requires.</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>mikem8361</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>26625</IssueLabelID>
    <Title>ReadyToRunCodegenNodeFactory cleanup / refactor</Title>
    <Description>* This class has gotten very big and contains several groups of unrelated functionality;
* Usefulness of deriving from NodeFactory is questionable it seems we're using just a fraction of its functionality and overlaps in the various helper names cause repeated aliasing issues;
* If it turns out to be possible to cleanly separate ReadyToRunCodegenNodeFactory from NodeFactory we should either split it into several classes or at least make it a partial class living in several files:
    * CorInfoImpl utility functions for constructing the various helper cells and signatures;
    * Token collection and lookup engine;
* R2R header table collection management.</Description>
    <Title_Description>ReadyToRunCodegenNodeFactory cleanup / refactor * This class has gotten very big and contains several groups of unrelated functionality;
* Usefulness of deriving from NodeFactory is questionable it seems we're using just a fraction of its functionality and overlaps in the various helper names cause repeated aliasing issues;
* If it turns out to be possible to cleanly separate ReadyToRunCodegenNodeFactory from NodeFactory we should either split it into several classes or at least make it a partial class living in several files:
    * CorInfoImpl utility functions for constructing the various helper cells and signatures;
    * Token collection and lookup engine;
* R2R header table collection management.</Title_Description>
    <Label>area-crossgen2</Label>
    <Assignee>MichalStrehovsky</Assignee>
    <CreatedAt>28/08/2018 11:06:44 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>26624</IssueLabelID>
    <Title>Multi-module compilation</Title>
    <Description>* Command-line specifies a number of "input files" that get all compiled into a single output R2R PE executable;
* Today architecture will need minor tweaks as we won't have a pre-existing MSIL to start off;
* All input files will be part of the CompilationModuleGroup without any singled-out assembly;
* This is expected to require additional CoreCLR runtime changes to work properly end-to-end;
* This will require a 2-level MethodEntrypointTable to cater for method tables for the individual modules and perhaps a new R2R component module table;
* Alternatively we might want to keep the pre-existing functionality untouched and just add a completely new entrypoint table format specific to the multi-module build.</Description>
    <Title_Description>Multi-module compilation * Command-line specifies a number of "input files" that get all compiled into a single output R2R PE executable;
* Today architecture will need minor tweaks as we won't have a pre-existing MSIL to start off;
* All input files will be part of the CompilationModuleGroup without any singled-out assembly;
* This is expected to require additional CoreCLR runtime changes to work properly end-to-end;
* This will require a 2-level MethodEntrypointTable to cater for method tables for the individual modules and perhaps a new R2R component module table;
* Alternatively we might want to keep the pre-existing functionality untouched and just add a completely new entrypoint table format specific to the multi-module build.</Title_Description>
    <Label>area-crossgen2</Label>
    <Assignee>Dotnet-GitSync-Bot</Assignee>
    <CreatedAt>28/08/2018 11:04:09 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>26623</IssueLabelID>
    <Title>Investigate ILCompiler R2R Self-Hosting</Title>
    <Description>* Once CQ allows try building ILCompiler in R2R mode
* This should provide a compilation perf improvement (less jitting) and a sizable CQ indicator local to this repository</Description>
    <Title_Description>Investigate ILCompiler R2R Self-Hosting * Once CQ allows try building ILCompiler in R2R mode
* This should provide a compilation perf improvement (less jitting) and a sizable CQ indicator local to this repository</Title_Description>
    <Label>area-crossgen2</Label>
    <Assignee>nattress</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19721</IssueLabelID>
    <Title>R2RDump - Implement fixup signature parsing</Title>
    <Description>The various fixups supported in the ready-to-run format use signatures to represent types / methods. Parsing the signatures in a ready-to-run image will allow us to add richer symbolic information to the disassembly emitted by r2rdump. This will also make diffing images generated by Crossgen vs ILCompiler easier.</Description>
    <Title_Description>R2RDump - Implement fixup signature parsing The various fixups supported in the ready-to-run format use signatures to represent types / methods. Parsing the signatures in a ready-to-run image will allow us to add richer symbolic information to the disassembly emitted by r2rdump. This will also make diffing images generated by Crossgen vs ILCompiler easier.</Title_Description>
    <Label>area-R2RDump</Label>
    <Assignee>nattress</Assignee>
    <CreatedAt>28/08/2018 9:49:44 PM +00:00</CreatedAt>
    <ClosedAt>14/09/2018 11:27:39 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19717</IssueLabelID>
    <Title>disable NETClientPrimitives test for all platforms.</Title>
    <Description>As it was before.

Fixes R2R jobs like https://ci.dot.net/job/dotnet_coreclr/job/master/job/x86_checked_windows_nt_r2r/.


</Description>
    <Title_Description>disable NETClientPrimitives test for all platforms. As it was before.

Fixes R2R jobs like https://ci.dot.net/job/dotnet_coreclr/job/master/job/x86_checked_windows_nt_r2r/.


</Title_Description>
    <Label>disabled-test</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>28/08/2018 8:00:59 PM +00:00</CreatedAt>
    <ClosedAt>28/08/2018 10:24:10 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19715</IssueLabelID>
    <Title>[Windows/arm64] build break: C4723 potential divide by 0</Title>
    <Description>Apparently this changed with VS 15.8.

</Description>
    <Title_Description>[Windows/arm64] build break: C4723 potential divide by 0 Apparently this changed with VS 15.8.

</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>28/08/2018 7:00:24 PM +00:00</CreatedAt>
    <ClosedAt>28/08/2018 10:39:02 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19710</IssueLabelID>
    <Title>COMPlus_JitStdOutFile on Linux - part of the output still goes to StdOut</Title>
    <Description>**Steps to reproduce:**

Set the following environment variable

</Description>
    <Title_Description>COMPlus_JitStdOutFile on Linux - part of the output still goes to StdOut **Steps to reproduce:**

Set the following environment variable

</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>echesakovMSFT</Assignee>
    <CreatedAt>28/08/2018 4:11:42 PM +00:00</CreatedAt>
    <ClosedAt>19/09/2018 11:37:59 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19706</IssueLabelID>
    <Title>Char.GetUnicodeCategory returns wrong category for certain Latin-1 characters</Title>
    <Description>In a nutshell there are certain characters where  instead. This preserves existing behavior and provides a migration story to get developers on to the APIs which provide correct results.</Description>
    <Title_Description>Char.GetUnicodeCategory returns wrong category for certain Latin-1 characters In a nutshell there are certain characters where  instead. This preserves existing behavior and provides a migration story to get developers on to the APIs which provide correct results.</Title_Description>
    <Label>area-System.Globalization</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>28/08/2018 12:05:24 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19705</IssueLabelID>
    <Title>[Windows|x86|x64] Incorrect comparison of short</Title>
    <Description>Example code:



/cc @BruceForstall </Description>
    <Title_Description>[Windows|x86|x64] Incorrect comparison of short Example code:



/cc @BruceForstall </Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>erozenfeld</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19704</IssueLabelID>
    <Title>CrossGen produces spurious "Error" logging on what it later reports as successful compilation</Title>
    <Description>From this log: https://devdiv.visualstudio.com/0bdbc590-a062-4c3f-b0f6-9383f67865ee/_apis/build/builds/1980843/logs/8


(This was from compiling csc.dll)

Some thoughts here:
- If four errors have been written out to the console succeeding with no special "-force' or other args like this is very confusing
- MSBuild and other systems tend to promote std. out with "error" in the string to actual errors
- E_FAIL is not super useful to anyone reading this log.

@eerhardt FYI
</Description>
    <Title_Description>CrossGen produces spurious "Error" logging on what it later reports as successful compilation From this log: https://devdiv.visualstudio.com/0bdbc590-a062-4c3f-b0f6-9383f67865ee/_apis/build/builds/1980843/logs/8


(This was from compiling csc.dll)

Some thoughts here:
- If four errors have been written out to the console succeeding with no special "-force' or other args like this is very confusing
- MSBuild and other systems tend to promote std. out with "error" in the string to actual errors
- E_FAIL is not super useful to anyone reading this log.

@eerhardt FYI
</Title_Description>
    <Label>area-CrossGen/NGEN</Label>
    <Assignee>zacharycmontoya</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19703</IssueLabelID>
    <Title>Delete code that tracks stack level in morph.</Title>
    <Description>The responsibilities of the old code that tracked stack level were:
1) Set 
Fixes #16411.</Description>
    <Title_Description>Delete code that tracks stack level in morph. The responsibilities of the old code that tracked stack level were:
1) Set 
Fixes #16411.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>27/08/2018 11:47:03 PM +00:00</CreatedAt>
    <ClosedAt>30/08/2018 2:55:25 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19699</IssueLabelID>
    <Title>Implement PCLMULQDQ intrinsic</Title>
    <Description>I will submit a PR to implement all the PCLMULQDQ intrinsic.

cc @CarolEidt @tannergooding @eerhardt </Description>
    <Title_Description>Implement PCLMULQDQ intrinsic I will submit a PR to implement all the PCLMULQDQ intrinsic.

cc @CarolEidt @tannergooding @eerhardt </Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
    <CreatedAt>27/08/2018 10:20:51 PM +00:00</CreatedAt>
    <ClosedAt>10/09/2018 7:55:38 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19698</IssueLabelID>
    <Title>System.AccessViolationException while formatting stacktrace</Title>
    <Description>Reported by @BrennanConroy 

We’re getting this exception in a test occasionally. 

</Description>
    <Title_Description>System.AccessViolationException while formatting stacktrace Reported by @BrennanConroy 

We’re getting this exception in a test occasionally. 

</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>mikem8361</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19696</IssueLabelID>
    <Title>[arm64] Remove interpreter fallback</Title>
    <Description>Remove old code:
</Description>
    <Title_Description>[arm64] Remove interpreter fallback Remove old code:
</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>BruceForstall</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19694</IssueLabelID>
    <Title>Fix JitDump label output to be multi-thread safe</Title>
    <Description>We emit labels using a global static  pointer so it might be a little more work than this.

category:implementation
theme:debug-dumps
skill-level:beginner
cost:small</Description>
    <Title_Description>Fix JitDump label output to be multi-thread safe We emit labels using a global static  pointer so it might be a little more work than this.

category:implementation
theme:debug-dumps
skill-level:beginner
cost:small</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>27/08/2018 8:28:00 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19691</IssueLabelID>
    <Title>Enable tiered compilation</Title>
    <Description>This is a port of several changes that went into master after 2.2 forked including dependencies for and enabling tiered compilation by default in 2.2. Quick summary of commits is below see the commit descriptions and PRs for more info.
- Commit 1 - Fix nested spin locks in thread pool etw firing (#17677)
  - Fixes a lock nesting issue when there is an ETW listener which can occur without tiering but is almost deterministic with tiering enabled because the first event that is fired typically hits this code path
- Commit 2 - Don't close the JIT func info file on shutdown (#18060)
  - Fixes a crash during shutdown that only occurs when JIT logging is enabled (typically in the coreclr tests and CI). More frequent with tiering enabled because of different JIT timing and background jitting.
- Commit 3 - Apply tiering's call counting delay more broadly (#18610)
  - Fixes a perf issue when tiering is enabled in server first-request scenarios where there is a significant gap between process startup and first request
- Commit 4 - Changes only affect debug builds - Eliminate arm64 contract asserts (#19015)
  - Fixes some incorrect asserts that trigger more frequently with tiering
- Commit 5 - Use 16 bytes to spill SIMD12 (#19237)
  - Fixes a crash in corefx System.Numerics.Tests.Vector3Tests.Vector3EqualsTest. Occurs with minopt JIT or with tiering.
- Commit 6 - Fix an apartment state issue (partial port of #19384)
  - This is a partial port of this PR (only the portion that addresses issue #17822)
  - This is a breaking change though a minor one that we have concluded is an acceptable risk to take for 2.2
  - Fixes a behavioral difference that can be seen more easily tiering enabled in APIs on the  class relevant to apartment state. The issue can also be seen in some cases when tiering is disabled.
- Commit 7 - Enable Tiered Compilation by default (#19525)
  - Enables tiering by default can be disabled through environment or through .csproj/.json when using dotnet
  - Removes deprecated config variable (EXPERIMENTAL_TieredCompilation) that was previously exposed in 2.1 along with the current config variable (TieredCompilation) along with miscellaneous test fixes
- Commit 8 - Changes only affect tests - Fix tiered compilation option for case-sensitive systems (#19567)
  - Fixes tiering environment variable casing for non-Windows platforms
- Commit 9 - Disable tiered compilation on arm64
  - There is an open issue that may be partly related to minopts on arm64 (https://github.com/dotnet/coreclr/issues/18895). Disabling tiering by default on arm64 to limit exposing new issues.

This change would be followed up with https://github.com/dotnet/corefx/pull/31822
- Adds tests for Commit 6 - Fix an apartment state issue (partial port of #19384)
  - Changes only affect tests

Closes https://github.com/dotnet/coreclr/issues/18973</Description>
    <Title_Description>Enable tiered compilation This is a port of several changes that went into master after 2.2 forked including dependencies for and enabling tiered compilation by default in 2.2. Quick summary of commits is below see the commit descriptions and PRs for more info.
- Commit 1 - Fix nested spin locks in thread pool etw firing (#17677)
  - Fixes a lock nesting issue when there is an ETW listener which can occur without tiering but is almost deterministic with tiering enabled because the first event that is fired typically hits this code path
- Commit 2 - Don't close the JIT func info file on shutdown (#18060)
  - Fixes a crash during shutdown that only occurs when JIT logging is enabled (typically in the coreclr tests and CI). More frequent with tiering enabled because of different JIT timing and background jitting.
- Commit 3 - Apply tiering's call counting delay more broadly (#18610)
  - Fixes a perf issue when tiering is enabled in server first-request scenarios where there is a significant gap between process startup and first request
- Commit 4 - Changes only affect debug builds - Eliminate arm64 contract asserts (#19015)
  - Fixes some incorrect asserts that trigger more frequently with tiering
- Commit 5 - Use 16 bytes to spill SIMD12 (#19237)
  - Fixes a crash in corefx System.Numerics.Tests.Vector3Tests.Vector3EqualsTest. Occurs with minopt JIT or with tiering.
- Commit 6 - Fix an apartment state issue (partial port of #19384)
  - This is a partial port of this PR (only the portion that addresses issue #17822)
  - This is a breaking change though a minor one that we have concluded is an acceptable risk to take for 2.2
  - Fixes a behavioral difference that can be seen more easily tiering enabled in APIs on the  class relevant to apartment state. The issue can also be seen in some cases when tiering is disabled.
- Commit 7 - Enable Tiered Compilation by default (#19525)
  - Enables tiering by default can be disabled through environment or through .csproj/.json when using dotnet
  - Removes deprecated config variable (EXPERIMENTAL_TieredCompilation) that was previously exposed in 2.1 along with the current config variable (TieredCompilation) along with miscellaneous test fixes
- Commit 8 - Changes only affect tests - Fix tiered compilation option for case-sensitive systems (#19567)
  - Fixes tiering environment variable casing for non-Windows platforms
- Commit 9 - Disable tiered compilation on arm64
  - There is an open issue that may be partly related to minopts on arm64 (https://github.com/dotnet/coreclr/issues/18895). Disabling tiering by default on arm64 to limit exposing new issues.

This change would be followed up with https://github.com/dotnet/corefx/pull/31822
- Adds tests for Commit 6 - Fix an apartment state issue (partial port of #19384)
  - Changes only affect tests

Closes https://github.com/dotnet/coreclr/issues/18973</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19690</IssueLabelID>
    <Title>Automate CoreCLR's CoreFX CI Test Infrastructure</Title>
    <Description># CoreFX Tests in CoreCLR CI

## Current State
A suite of CoreFX tests are executed on top of CI builds of CoreCLR during PRs.  Currently these tests are manually built and uploaded to an Azure Blob Storage container and downloaded during the CI pipeline.  The cadence of building and uploading the binaries is completely manual with almost no visibility as to what commit from dotnet/corefx was used to build the tests.  While this works it is inconvenient for maintenance and unfriendly for developers who may want to pull down the same test binaries that are running in the CI for their PR.

## Goals
* Automate the cataloging (upload and versioning) of CoreFX test binaries.
* Simplify the retrieval of a specific version of the CoreFX test binaries.
* Hook into the automation that already updates the CoreFX version in [coreclr/dependencies.props](https://github.com/dotnet/coreclr/blob/master/dependencies.props) via [maestro-bot](https://github.com/dotnet/versions).

This issue is for unifying discussions as this may require changes in dotnet/coreclr and dotnet/corefx.

CC - @A-And @adityamandaleeka 

[WIP]</Description>
    <Title_Description>Automate CoreCLR's CoreFX CI Test Infrastructure # CoreFX Tests in CoreCLR CI

## Current State
A suite of CoreFX tests are executed on top of CI builds of CoreCLR during PRs.  Currently these tests are manually built and uploaded to an Azure Blob Storage container and downloaded during the CI pipeline.  The cadence of building and uploading the binaries is completely manual with almost no visibility as to what commit from dotnet/corefx was used to build the tests.  While this works it is inconvenient for maintenance and unfriendly for developers who may want to pull down the same test binaries that are running in the CI for their PR.

## Goals
* Automate the cataloging (upload and versioning) of CoreFX test binaries.
* Simplify the retrieval of a specific version of the CoreFX test binaries.
* Hook into the automation that already updates the CoreFX version in [coreclr/dependencies.props](https://github.com/dotnet/coreclr/blob/master/dependencies.props) via [maestro-bot](https://github.com/dotnet/versions).

This issue is for unifying discussions as this may require changes in dotnet/coreclr and dotnet/corefx.

CC - @A-And @adityamandaleeka 

[WIP]</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>davmason</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19689</IssueLabelID>
    <Title>Hardware intrinsic throw ArgumentOutOfRangeException with IMM parameter name</Title>
    <Description>Now some hardware intrinsic can throw 

We may need to bring the IMM parameter name in the exception object.

Logged from the conversation https://github.com/dotnet/coreclr/pull/19392#discussion_r213050260

@tannergooding @CarolEidt 

category:implementation
theme:intrinsics
skill-level:beginner
cost:small</Description>
    <Title_Description>Hardware intrinsic throw ArgumentOutOfRangeException with IMM parameter name Now some hardware intrinsic can throw 

We may need to bring the IMM parameter name in the exception object.

Logged from the conversation https://github.com/dotnet/coreclr/pull/19392#discussion_r213050260

@tannergooding @CarolEidt 

category:implementation
theme:intrinsics
skill-level:beginner
cost:small</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
    <CreatedAt>27/08/2018 5:48:17 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19688</IssueLabelID>
    <Title>Update NetPerf File ThreadID to 64-bits</Title>
    <Description>The current value is 32-bits which will truncate the full value on OSX.</Description>
    <Title_Description>Update NetPerf File ThreadID to 64-bits The current value is 32-bits which will truncate the full value on OSX.</Title_Description>
    <Label>area-Tracing</Label>
    <Assignee>noahfalk</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19684</IssueLabelID>
    <Title>Test failure: JIT_jit64._mcc_interop_mcc_i83_mcc_i83_/_mcc_interop_mcc_i83_mcc_i83_cmd</Title>
    <Description>Opened on behalf of @Sunny-pu

The test  has failed.


    
    Return code:      1
    Raw output file:      C:\\dotnetbuild\\work\\31155d77-0bf1-45a2-a51e-dc457ed07fe5\\Work\\21104909-527d-4766-99e3-8be351afd714\\Unzip\\Reports\\JIT.jit64\\mcc\\interop\\mcc_i83\\mcc_i83.output.txt
    Raw output:
    BEGIN EXECUTION\r
     \"C:\\dotnetbuild\\work\\31155d77-0bf1-45a2-a51e-dc457ed07fe5\\Payload\\corerun.exe\" mcc_i83.exe \r
    Expected: 100\r
    Actual: -1073741819\r
    END EXECUTION - FAILED\r
    FAILED\r
    Test Harness Exitcode is : 1\r
    
    To run the test:
    &gt; set CORE_ROOT=C:\\dotnetbuild\\work\\31155d77-0bf1-45a2-a51e-dc457ed07fe5\\Payload
    &gt; C:\\dotnetbuild\\work\\31155d77-0bf1-45a2-a51e-dc457ed07fe5\\Work\\21104909-527d-4766-99e3-8be351afd714\\Unzip\\mcc\\interop\\mcc_i83\\mcc_i83.cmd
    \r
    Expected: True\r
    Actual:   False

        Stack Trace:

           at JIT_jit64._mcc_interop_mcc_i83_mcc_i83_._mcc_interop_mcc_i83_mcc_i83_cmd() in E:\A\_work\105\s\bin\tests\Windows_NT.arm.Release\TestWrappers\JIT.jit64\JIT.jit64.XUnitWrapper.cs:line 23349
Build : 3.0 - 20180827.01 (Core Tests)
Failing configurations:
- windows.10.arm64-arm
  - 
Details: 
https://mc.dot.net/#/product/netcore/30/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fcli~2F/build/20180827.01/workItem/JIT.jit64.XUnitWrapper/analysis/xunit/JIT_jit64._mcc_interop_mcc_i83_mcc_i83_~2F_mcc_interop_mcc_i83_mcc_i83_cmd</Description>
    <Title_Description>Test failure: JIT_jit64._mcc_interop_mcc_i83_mcc_i83_/_mcc_interop_mcc_i83_mcc_i83_cmd Opened on behalf of @Sunny-pu

The test  has failed.


    
    Return code:      1
    Raw output file:      C:\\dotnetbuild\\work\\31155d77-0bf1-45a2-a51e-dc457ed07fe5\\Work\\21104909-527d-4766-99e3-8be351afd714\\Unzip\\Reports\\JIT.jit64\\mcc\\interop\\mcc_i83\\mcc_i83.output.txt
    Raw output:
    BEGIN EXECUTION\r
     \"C:\\dotnetbuild\\work\\31155d77-0bf1-45a2-a51e-dc457ed07fe5\\Payload\\corerun.exe\" mcc_i83.exe \r
    Expected: 100\r
    Actual: -1073741819\r
    END EXECUTION - FAILED\r
    FAILED\r
    Test Harness Exitcode is : 1\r
    
    To run the test:
    &gt; set CORE_ROOT=C:\\dotnetbuild\\work\\31155d77-0bf1-45a2-a51e-dc457ed07fe5\\Payload
    &gt; C:\\dotnetbuild\\work\\31155d77-0bf1-45a2-a51e-dc457ed07fe5\\Work\\21104909-527d-4766-99e3-8be351afd714\\Unzip\\mcc\\interop\\mcc_i83\\mcc_i83.cmd
    \r
    Expected: True\r
    Actual:   False

        Stack Trace:

           at JIT_jit64._mcc_interop_mcc_i83_mcc_i83_._mcc_interop_mcc_i83_mcc_i83_cmd() in E:\A\_work\105\s\bin\tests\Windows_NT.arm.Release\TestWrappers\JIT.jit64\JIT.jit64.XUnitWrapper.cs:line 23349
Build : 3.0 - 20180827.01 (Core Tests)
Failing configurations:
- windows.10.arm64-arm
  - 
Details: 
https://mc.dot.net/#/product/netcore/30/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fcli~2F/build/20180827.01/workItem/JIT.jit64.XUnitWrapper/analysis/xunit/JIT_jit64._mcc_interop_mcc_i83_mcc_i83_~2F_mcc_interop_mcc_i83_mcc_i83_cmd</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>jashook</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19683</IssueLabelID>
    <Title>Test failure: baseservices_varargs._varargsupport_r_varargsupport_r_/_varargsupport_r_varargsupport_r_cmd</Title>
    <Description>Opened on behalf of @Sunny-pu

The test  has failed.


    
    Return code:      1
    Raw output file:      C:\\dotnetbuild\\work\\31155d77-0bf1-45a2-a51e-dc457ed07fe5\\Work\\00d13fb9-5edc-43da-9ceb-c7260abf98d0\\Unzip\\Reports\\baseservices.varargs\\varargsupport_r\\varargsupport_r.output.txt
    Raw output:
    BEGIN EXECUTION\r
     \"C:\\dotnetbuild\\work\\31155d77-0bf1-45a2-a51e-dc457ed07fe5\\Payload\\corerun.exe\" varargsupport_r.exe \r
    Blah Blah\r
    Test failed as InvalidProgramException was not raised.\r
    Expected: 100\r
    Actual: 0\r
    END EXECUTION - FAILED\r
    FAILED\r
    Test Harness Exitcode is : 1\r
    
    To run the test:
    &gt; set CORE_ROOT=C:\\dotnetbuild\\work\\31155d77-0bf1-45a2-a51e-dc457ed07fe5\\Payload
    &gt; C:\\dotnetbuild\\work\\31155d77-0bf1-45a2-a51e-dc457ed07fe5\\Work\\00d13fb9-5edc-43da-9ceb-c7260abf98d0\\Unzip\\varargsupport_r\\varargsupport_r.cmd
    \r
    Expected: True\r
    Actual:   False

        Stack Trace:

           at baseservices_varargs._varargsupport_r_varargsupport_r_._varargsupport_r_varargsupport_r_cmd() in E:\A\_work\105\s\bin\tests\Windows_NT.arm.Release\TestWrappers\baseservices.varargs\baseservices.varargs.XUnitWrapper.cs:line 179
Build : 3.0 - 20180827.01 (Core Tests)
Failing configurations:
- windows.10.arm64-arm
  - 
Details: https://mc.dot.net/#/product/netcore/30/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fcli~2F/build/20180827.01/workItem/baseservices.varargs.XUnitWrapper/analysis/xunit/baseservices_varargs._varargsupport_r_varargsupport_r_~2F_varargsupport_r_varargsupport_r_cmd</Description>
    <Title_Description>Test failure: baseservices_varargs._varargsupport_r_varargsupport_r_/_varargsupport_r_varargsupport_r_cmd Opened on behalf of @Sunny-pu

The test  has failed.


    
    Return code:      1
    Raw output file:      C:\\dotnetbuild\\work\\31155d77-0bf1-45a2-a51e-dc457ed07fe5\\Work\\00d13fb9-5edc-43da-9ceb-c7260abf98d0\\Unzip\\Reports\\baseservices.varargs\\varargsupport_r\\varargsupport_r.output.txt
    Raw output:
    BEGIN EXECUTION\r
     \"C:\\dotnetbuild\\work\\31155d77-0bf1-45a2-a51e-dc457ed07fe5\\Payload\\corerun.exe\" varargsupport_r.exe \r
    Blah Blah\r
    Test failed as InvalidProgramException was not raised.\r
    Expected: 100\r
    Actual: 0\r
    END EXECUTION - FAILED\r
    FAILED\r
    Test Harness Exitcode is : 1\r
    
    To run the test:
    &gt; set CORE_ROOT=C:\\dotnetbuild\\work\\31155d77-0bf1-45a2-a51e-dc457ed07fe5\\Payload
    &gt; C:\\dotnetbuild\\work\\31155d77-0bf1-45a2-a51e-dc457ed07fe5\\Work\\00d13fb9-5edc-43da-9ceb-c7260abf98d0\\Unzip\\varargsupport_r\\varargsupport_r.cmd
    \r
    Expected: True\r
    Actual:   False

        Stack Trace:

           at baseservices_varargs._varargsupport_r_varargsupport_r_._varargsupport_r_varargsupport_r_cmd() in E:\A\_work\105\s\bin\tests\Windows_NT.arm.Release\TestWrappers\baseservices.varargs\baseservices.varargs.XUnitWrapper.cs:line 179
Build : 3.0 - 20180827.01 (Core Tests)
Failing configurations:
- windows.10.arm64-arm
  - 
Details: https://mc.dot.net/#/product/netcore/30/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fcli~2F/build/20180827.01/workItem/baseservices.varargs.XUnitWrapper/analysis/xunit/baseservices_varargs._varargsupport_r_varargsupport_r_~2F_varargsupport_r_varargsupport_r_cmd</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>jashook</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19682</IssueLabelID>
    <Title>Hang when running with pseudo.</Title>
    <Description>https://www.yoctoproject.org/software-item/pseudo/

This tool allows users to to act as root.

I am using official binaries of v2.1.401 SDK.

Simple running 

This tool is vital for Yocto since it ensures a clean operating system with no host contamination.</Description>
    <Title_Description>Hang when running with pseudo. https://www.yoctoproject.org/software-item/pseudo/

This tool allows users to to act as root.

I am using official binaries of v2.1.401 SDK.

Simple running 

This tool is vital for Yocto since it ensures a clean operating system with no host contamination.</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>mikem8361</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19681</IssueLabelID>
    <Title>re-enable com for local gc</Title>
    <Description>This codepath is only used when a profiler or ETW walks the heap so an interface call for every COM object:
1. Should only affect COM objects which is usually a very small portion of overall objects
2. Shouldn't be a hot path item
3. Even if it was walking the heap is very slow already and only done for diagnostics so not performance critical

So I think an interface call is fine here.</Description>
    <Title_Description>re-enable com for local gc This codepath is only used when a profiler or ETW walks the heap so an interface call for every COM object:
1. Should only affect COM objects which is usually a very small portion of overall objects
2. Shouldn't be a hot path item
3. Even if it was walking the heap is very slow already and only done for diagnostics so not performance critical

So I think an interface call is fine here.</Title_Description>
    <Label>area-GC</Label>
    <Assignee>davmason</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19680</IssueLabelID>
    <Title>Segfault in ECall::GetQCallImpl on local build.</Title>
    <Description> but I am confident I have deployed both.

Any guidance would be greatly appreciated.</Description>
    <Title_Description>Segfault in ECall::GetQCallImpl on local build.  but I am confident I have deployed both.

Any guidance would be greatly appreciated.</Title_Description>
    <Label>area-Tracing</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>26/08/2018 11:55:59 PM +00:00</CreatedAt>
    <ClosedAt>26/02/2019 10:39:33 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19679</IssueLabelID>
    <Title>System.Runtime.TieredCompilation configuration knob does not work to turn off tiered compilation</Title>
    <Description>I can't seem to get this configuration knob working. I am using my issue reported in #19599 as a test for whether tiered compilation is enabled or not. The following PowerShell session illustrates my confusion:

The CoreRun used here is compiled from current master (5d2ae2f) and the dotnet CLI is 2.1.400.

Is this a bug or is there some other way to turn off tiered compilation for an app without requiring the COMPlus_TieredCompilation environment variable to be set correctly before running the app?</Description>
    <Title_Description>System.Runtime.TieredCompilation configuration knob does not work to turn off tiered compilation I can't seem to get this configuration knob working. I am using my issue reported in #19599 as a test for whether tiered compilation is enabled or not. The following PowerShell session illustrates my confusion:

The CoreRun used here is compiled from current master (5d2ae2f) and the dotnet CLI is 2.1.400.

Is this a bug or is there some other way to turn off tiered compilation for an app without requiring the COMPlus_TieredCompilation environment variable to be set correctly before running the app?</Title_Description>
    <Label>area-TieredCompilation</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>26/08/2018 8:09:45 PM +00:00</CreatedAt>
    <ClosedAt>27/08/2018 6:56:21 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19676</IssueLabelID>
    <Title>PInvoke function that returns a struct</Title>
    <Description>One of my customers encountered a problem today that doesn't appear with .NET Framework/Mono.

For some reason in this function (ENet.cs line 747):
 (ENet.cs line 515).

The runtime throws this exception:
&gt; Unhandled Exception: System.Runtime.InteropServices.MarshalDirectiveException: Method's type signature is not PInvoke compatible.
   at ENet.Native.enet_peer_get_address(IntPtr peer)
   at ENet.Peer.get_Address() in E:\TestENetServer\ENet.cs:line 517
   at TestENetServer.Program.Main(String[] args) in E:\TestENetServer\Program.cs:line 25

Here's an example of projects - [ENetCSharpTest.zip](https://github.com/dotnet/coreclr/files/2321643/ENetCSharpTest.zip)
Simple run the server and then the client and you will catch an exception.

Here's repository with a complete source code including the native library - https://github.com/nxrighthere/ENet-CSharp</Description>
    <Title_Description>PInvoke function that returns a struct One of my customers encountered a problem today that doesn't appear with .NET Framework/Mono.

For some reason in this function (ENet.cs line 747):
 (ENet.cs line 515).

The runtime throws this exception:
&gt; Unhandled Exception: System.Runtime.InteropServices.MarshalDirectiveException: Method's type signature is not PInvoke compatible.
   at ENet.Native.enet_peer_get_address(IntPtr peer)
   at ENet.Peer.get_Address() in E:\TestENetServer\ENet.cs:line 517
   at TestENetServer.Program.Main(String[] args) in E:\TestENetServer\Program.cs:line 25

Here's an example of projects - [ENetCSharpTest.zip](https://github.com/dotnet/coreclr/files/2321643/ENetCSharpTest.zip)
Simple run the server and then the client and you will catch an exception.

Here's repository with a complete source code including the native library - https://github.com/nxrighthere/ENet-CSharp</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jkoritzinsky</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19674</IssueLabelID>
    <Title>Memory Corruption using System.Numerics.Vector3</Title>
    <Description>I've discovered a memory corruption bug which seems to affect 

As indicated some degree of control is possible so this may have security implications in some regard.  It also only appears to occur when the Vector3 is passed to another function; if you perform the same operations inside a given function everything works as expected.  Also this only seems to occur when you *assign* one of the vector components; accessing components is fine as is assigning whole vectors.</Description>
    <Title_Description>Memory Corruption using System.Numerics.Vector3 I've discovered a memory corruption bug which seems to affect 

As indicated some degree of control is possible so this may have security implications in some regard.  It also only appears to occur when the Vector3 is passed to another function; if you perform the same operations inside a given function everything works as expected.  Also this only seems to occur when you *assign* one of the vector components; accessing components is fine as is assigning whole vectors.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19672</IssueLabelID>
    <Title>StringComparison.Ordinal same as not specified calls?</Title>
    <Description>Should ?</Description>
    <Title_Description>StringComparison.Ordinal same as not specified calls? Should ?</Title_Description>
    <Label>area-System.Runtime</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>25/08/2018 12:42:17 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19668</IssueLabelID>
    <Title>Consistency check failed: File has not had execution verified</Title>
    <Description>The three following assemblies when PMI-d on Linux/arm hit the same assertion

**System.Security.Cryptography.Encoding.dll** 



**Updated:** Also reproduces on Linux/arm64</Description>
    <Title_Description>Consistency check failed: File has not had execution verified The three following assemblies when PMI-d on Linux/arm hit the same assertion

**System.Security.Cryptography.Encoding.dll** 



**Updated:** Also reproduces on Linux/arm64</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>AndyAyersMS</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19667</IssueLabelID>
    <Title>[WIP] Enable tiered compilation</Title>
    <Description>
    </Description>
    <Title_Description>[WIP] Enable tiered compilation </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19666</IssueLabelID>
    <Title>[WIP] Test CI</Title>
    <Description>
    </Description>
    <Title_Description>[WIP] Test CI </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19661</IssueLabelID>
    <Title>R2RDump ARM and ARM64 UnwindCodes</Title>
    <Description>R2RDump can parse UnwindInfo headers for ARM and ARM64 but not UnwindCodes yet. 

This can be implemented based on https://github.com/dotnet/coreclr/blob/master/src/jit/unwindarm.cpp and https://github.com/dotnet/coreclr/blob/master/src/jit/unwindarm64.cpp</Description>
    <Title_Description>R2RDump ARM and ARM64 UnwindCodes R2RDump can parse UnwindInfo headers for ARM and ARM64 but not UnwindCodes yet. 

This can be implemented based on https://github.com/dotnet/coreclr/blob/master/src/jit/unwindarm.cpp and https://github.com/dotnet/coreclr/blob/master/src/jit/unwindarm64.cpp</Title_Description>
    <Label>area-R2RDump</Label>
    <Assignee>nattress</Assignee>
    <CreatedAt>24/08/2018 8:28:44 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19659</IssueLabelID>
    <Title>Fix FileStream in WinRT build</Title>
    <Description>
    </Description>
    <Title_Description>Fix FileStream in WinRT build </Title_Description>
    <Label>area-System.IO</Label>
    <Assignee>JeremyKuhne</Assignee>
    <CreatedAt>24/08/2018 6:50:33 PM +00:00</CreatedAt>
    <ClosedAt>25/08/2018 12:25:55 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19657</IssueLabelID>
    <Title>Unify the Interop xplatform.h file with the common coreclr test platformdefines.h </Title>
    <Description>@luqunl 

See #19576</Description>
    <Title_Description>Unify the Interop xplatform.h file with the common coreclr test platformdefines.h  @luqunl 

See #19576</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>24/08/2018 6:23:20 PM +00:00</CreatedAt>
    <ClosedAt>18/01/2019 12:58:35 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19655</IssueLabelID>
    <Title>Zeroing stack by rep stosb instead of rep stosd</Title>
    <Description>Intel improved the performance of  and even faster on some platforms.

related to https://github.com/dotnet/coreclr/issues/19076
</Description>
    <Title_Description>Zeroing stack by rep stosb instead of rep stosd Intel improved the performance of  and even faster on some platforms.

related to https://github.com/dotnet/coreclr/issues/19076
</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>tannergooding</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19654</IssueLabelID>
    <Title>P/Invoke custom marshaler sometimes fails type cast</Title>
    <Description>I'm trying to track down why [my upgrade](https://github.com/AArnott/Nerdbank.GitVersioning/pull/210) of libgit2sharp to 0.25.2 led to nerdbank.gitversioning to fail (reliably) on a seemingly random set of projects across multiple repos.

In [the failure](https://github.com/AArnott/Nerdbank.GitVersioning/issues/215) [a type check](https://github.com/libgit2/libgit2sharp/blob/5199c83d37f7baf5a775eacaffd66322b1d90ef1/LibGit2Sharp/Core/FilePathMarshaler.cs#L67) fails after passing through [a very clearly type constraining method](https://github.com/libgit2/libgit2sharp/blob/5199c83d37f7baf5a775eacaffd66322b1d90ef1/LibGit2Sharp/Core/NativeMethods.cs#L1395-L1398). Considering that perhaps it's a matter of assembly double-loading I checked. The managed debugger reports the assembly is loaded once and that the AssemblyLoadContext is the same at both points of the callstack leading up to the failure. 

This repros only on .NET Core (2.1) and does so on Windows and Linux (I didn't test Mac). This same code works fine within MSBuild running on the .NET Framework.

[The repro](https://github.com/AArnott/Nerdbank.GitVersioning/issues/215#issuecomment-415785686) is super reliable and relatively simple. @rainersigwald also has [a great repro](https://github.com/AArnott/Nerdbank.GitVersioning/issues/215#issuecomment-415774717).</Description>
    <Title_Description>P/Invoke custom marshaler sometimes fails type cast I'm trying to track down why [my upgrade](https://github.com/AArnott/Nerdbank.GitVersioning/pull/210) of libgit2sharp to 0.25.2 led to nerdbank.gitversioning to fail (reliably) on a seemingly random set of projects across multiple repos.

In [the failure](https://github.com/AArnott/Nerdbank.GitVersioning/issues/215) [a type check](https://github.com/libgit2/libgit2sharp/blob/5199c83d37f7baf5a775eacaffd66322b1d90ef1/LibGit2Sharp/Core/FilePathMarshaler.cs#L67) fails after passing through [a very clearly type constraining method](https://github.com/libgit2/libgit2sharp/blob/5199c83d37f7baf5a775eacaffd66322b1d90ef1/LibGit2Sharp/Core/NativeMethods.cs#L1395-L1398). Considering that perhaps it's a matter of assembly double-loading I checked. The managed debugger reports the assembly is loaded once and that the AssemblyLoadContext is the same at both points of the callstack leading up to the failure. 

This repros only on .NET Core (2.1) and does so on Windows and Linux (I didn't test Mac). This same code works fine within MSBuild running on the .NET Framework.

[The repro](https://github.com/AArnott/Nerdbank.GitVersioning/issues/215#issuecomment-415785686) is super reliable and relatively simple. @rainersigwald also has [a great repro](https://github.com/AArnott/Nerdbank.GitVersioning/issues/215#issuecomment-415774717).</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>24/08/2018 6:05:02 PM +00:00</CreatedAt>
    <ClosedAt>15/01/2019 3:47:19 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19652</IssueLabelID>
    <Title>[release/2.1] Arm stepping fix</Title>
    <Description>#### Description

A bit ago @chsienki and @davidwrighton made some fixes to debugging that ended up in master after the release/2.2 branch was created. In particular the castings from  were not preserving the thumb bit causing stepping in ARM debugging to break. Issue #19255 is requesting to port these fixes to 2.1 for servicing.

This PR ports the following PR's from master to 2.1 as requested:
- #17617
- #17879
- #17990
- #18129
- #18247
#### Customer Impact

Currently our debugging experience in ARM is not working as expected. In some scenarios stepping will fall into incorrect locations sometimes during testing we find breakpoints that will fire up twice. Some customers have asked us to address this (issue #19255).
#### Regression?

Not a regression.		 
#### Risk

The risk taken from this change should be fairly low. Mostly castings were fixed that were fixed which only turn the thumb bit for ARM (while having no change in other architectures) appropriately on code paths used by the debugger in the VM. </Description>
    <Title_Description>[release/2.1] Arm stepping fix #### Description

A bit ago @chsienki and @davidwrighton made some fixes to debugging that ended up in master after the release/2.2 branch was created. In particular the castings from  were not preserving the thumb bit causing stepping in ARM debugging to break. Issue #19255 is requesting to port these fixes to 2.1 for servicing.

This PR ports the following PR's from master to 2.1 as requested:
- #17617
- #17879
- #17990
- #18129
- #18247
#### Customer Impact

Currently our debugging experience in ARM is not working as expected. In some scenarios stepping will fall into incorrect locations sometimes during testing we find breakpoints that will fire up twice. Some customers have asked us to address this (issue #19255).
#### Regression?

Not a regression.		 
#### Risk

The risk taken from this change should be fairly low. Mostly castings were fixed that were fixed which only turn the thumb bit for ARM (while having no change in other architectures) appropriately on code paths used by the debugger in the VM. </Title_Description>
    <Label>Servicing-approved</Label>
    <Assignee>hoyosjs</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19651</IssueLabelID>
    <Title>x64 JIT stack-spilled call parameter lifetime bug</Title>
    <Description>In the x64 JIT (FileVer output for clrjit.dll:  will be passed an invalid object address for parameter 4.</Description>
    <Title_Description>x64 JIT stack-spilled call parameter lifetime bug In the x64 JIT (FileVer output for clrjit.dll:  will be passed an invalid object address for parameter 4.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>briansull</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19650</IssueLabelID>
    <Title>[release/2.1] Determine memory load based on cgroup usage.</Title>
    <Description>Port #19518 to 2.1

CC @janvorli </Description>
    <Title_Description>[release/2.1] Determine memory load based on cgroup usage. Port #19518 to 2.1

CC @janvorli </Title_Description>
    <Label>Servicing-approved</Label>
    <Assignee>janvorli</Assignee>
    <CreatedAt>24/08/2018 7:22:09 AM +00:00</CreatedAt>
    <ClosedAt>31/08/2018 4:51:25 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19649</IssueLabelID>
    <Title>Test failure: baseservices_threading._generics_WaitCallback_thread07_thread07_/_generics_WaitCallback_thread07_thread07_cmd</Title>
    <Description>Opened on behalf of @Sunny-pu

The test  has failed.


    Unhandled Exception: System.IO.FileNotFoundException: Could not load file or assembly 'System.Console Version=4.1.1.0 Culture=neutral PublicKeyToken=b03f5f7f11d50a3a'. The system cannot find the file specified.
    
    /home/helixbot/dotnetbuild/work/f079d896-e097-4e55-a032-9f5058b6d014/Work/4c4b8101-cb8e-49f3-8b01-707b8eaa4799/Unzip/generics/WaitCallback/thread07/thread07.sh: line 244: 98133 Aborted                 (core dumped) $_DebuggerFullPath \"$CORE_ROOT/corerun\" $ExePath $CLRTestExecutionArguments
    
    
    Return code:      1
    Raw output file:      /home/helixbot/dotnetbuild/work/f079d896-e097-4e55-a032-9f5058b6d014/Work/4c4b8101-cb8e-49f3-8b01-707b8eaa4799/Unzip/Reports\\baseservices.threading\\generics\\WaitCallback\\thread07\\thread07.output.txt
    Raw output:
    BEGIN EXECUTION
    /home/helixbot/dotnetbuild/work/f079d896-e097-4e55-a032-9f5058b6d014/Payload/corerun thread07.exe
    Expected: 100
    Actual: 134
    END EXECUTION - FAILED
    Test Harness Exitcode is : 1
    
    To run the test:
    &gt; set CORE_ROOT=/home/helixbot/dotnetbuild/work/f079d896-e097-4e55-a032-9f5058b6d014/Payload
    &gt; /home/helixbot/dotnetbuild/work/f079d896-e097-4e55-a032-9f5058b6d014/Work/4c4b8101-cb8e-49f3-8b01-707b8eaa4799/Unzip/generics/WaitCallback/thread07/thread07.sh
    
    Expected: True
    Actual:   False

        Stack Trace:

           at baseservices_threading._generics_WaitCallback_thread07_thread07_._generics_WaitCallback_thread07_thread07_cmd() in E:\A\_work\3\s\bin\tests\Windows_NT.x64.Release\TestWrappers\baseservices.threading\baseservices.threading.XUnitWrapper.cs:line 10191
Build : 3.0 - 20180824.01 (Ready-To-Run Tests)
Failing configurations:
- opensuse.423.amd64
  - x64

Details: https://mc.dot.net/#/product/netcore/30/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fr2r~2Fcli~2F/build/20180824.01/workItem/baseservices.threading.XUnitWrapper/analysis/xunit/baseservices_threading._generics_WaitCallback_thread07_thread07_~2F_generics_WaitCallback_thread07_thread07_cmd</Description>
    <Title_Description>Test failure: baseservices_threading._generics_WaitCallback_thread07_thread07_/_generics_WaitCallback_thread07_thread07_cmd Opened on behalf of @Sunny-pu

The test  has failed.


    Unhandled Exception: System.IO.FileNotFoundException: Could not load file or assembly 'System.Console Version=4.1.1.0 Culture=neutral PublicKeyToken=b03f5f7f11d50a3a'. The system cannot find the file specified.
    
    /home/helixbot/dotnetbuild/work/f079d896-e097-4e55-a032-9f5058b6d014/Work/4c4b8101-cb8e-49f3-8b01-707b8eaa4799/Unzip/generics/WaitCallback/thread07/thread07.sh: line 244: 98133 Aborted                 (core dumped) $_DebuggerFullPath \"$CORE_ROOT/corerun\" $ExePath $CLRTestExecutionArguments
    
    
    Return code:      1
    Raw output file:      /home/helixbot/dotnetbuild/work/f079d896-e097-4e55-a032-9f5058b6d014/Work/4c4b8101-cb8e-49f3-8b01-707b8eaa4799/Unzip/Reports\\baseservices.threading\\generics\\WaitCallback\\thread07\\thread07.output.txt
    Raw output:
    BEGIN EXECUTION
    /home/helixbot/dotnetbuild/work/f079d896-e097-4e55-a032-9f5058b6d014/Payload/corerun thread07.exe
    Expected: 100
    Actual: 134
    END EXECUTION - FAILED
    Test Harness Exitcode is : 1
    
    To run the test:
    &gt; set CORE_ROOT=/home/helixbot/dotnetbuild/work/f079d896-e097-4e55-a032-9f5058b6d014/Payload
    &gt; /home/helixbot/dotnetbuild/work/f079d896-e097-4e55-a032-9f5058b6d014/Work/4c4b8101-cb8e-49f3-8b01-707b8eaa4799/Unzip/generics/WaitCallback/thread07/thread07.sh
    
    Expected: True
    Actual:   False

        Stack Trace:

           at baseservices_threading._generics_WaitCallback_thread07_thread07_._generics_WaitCallback_thread07_thread07_cmd() in E:\A\_work\3\s\bin\tests\Windows_NT.x64.Release\TestWrappers\baseservices.threading\baseservices.threading.XUnitWrapper.cs:line 10191
Build : 3.0 - 20180824.01 (Ready-To-Run Tests)
Failing configurations:
- opensuse.423.amd64
  - x64

Details: https://mc.dot.net/#/product/netcore/30/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fr2r~2Fcli~2F/build/20180824.01/workItem/baseservices.threading.XUnitWrapper/analysis/xunit/baseservices_threading._generics_WaitCallback_thread07_thread07_~2F_generics_WaitCallback_thread07_thread07_cmd</Title_Description>
    <Label>test-run-uwp-coreclr</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>24/08/2018 6:33:34 AM +00:00</CreatedAt>
    <ClosedAt>11/01/2019 10:14:59 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19648</IssueLabelID>
    <Title>arm Ubuntu machines not processing jobs correctly</Title>
    <Description>Looks like all arm32 Ubuntu jobs are failing with something like:

https://ci.dot.net/job/dotnet_coreclr/job/master/job/arm_cross_checked_ubuntu_innerloop_tst_prtest/3721/consoleFull

root job: https://ci.dot.net/job/dotnet_coreclr/job/master/job/arm_cross_checked_ubuntu_innerloop_flow_prtest/

@dotnet/dnceng @mmitche @jashook @RussKeldorph @MattGal </Description>
    <Title_Description>arm Ubuntu machines not processing jobs correctly Looks like all arm32 Ubuntu jobs are failing with something like:

https://ci.dot.net/job/dotnet_coreclr/job/master/job/arm_cross_checked_ubuntu_innerloop_tst_prtest/3721/consoleFull

root job: https://ci.dot.net/job/dotnet_coreclr/job/master/job/arm_cross_checked_ubuntu_innerloop_flow_prtest/

@dotnet/dnceng @mmitche @jashook @RussKeldorph @MattGal </Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>24/08/2018 4:34:51 AM +00:00</CreatedAt>
    <ClosedAt>24/08/2018 5:35:42 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19646</IssueLabelID>
    <Title>[NO MERGE] Add assert ImmedValNeedsReloc in optCreateAssertion</Title>
    <Description>**NO MERGE** This is for testing ONLY</Description>
    <Title_Description>[NO MERGE] Add assert ImmedValNeedsReloc in optCreateAssertion **NO MERGE** This is for testing ONLY</Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>echesakovMSFT</Assignee>
    <CreatedAt>24/08/2018 2:10:05 AM +00:00</CreatedAt>
    <ClosedAt>29/08/2018 1:26:45 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19643</IssueLabelID>
    <Title>[WIP]In Win X64 Return value calling convention diffs between member function and static function…</Title>
    <Description>Partial fix : https://github.com/dotnet/coreclr/issues/19474
</Description>
    <Title_Description>[WIP]In Win X64, Return value calling convention diffs between member function and static function… Partial fix : https://github.com/dotnet/coreclr/issues/19474
</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>luqunl</Assignee>
    <CreatedAt>24/08/2018 12:19:22 AM +00:00</CreatedAt>
    <ClosedAt>9/03/2019 3:52:06 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19642</IssueLabelID>
    <Title>R2RDump - List of bugs when running R2RDump on CoreFX binaries</Title>
    <Description>There's an IndexOutOfRangeException when dumping an ARM ReadyToRun System.Private.Corelib.
It happens in R2RDump.NibbleReader.ReadNibble() when decoding fixups.
It also happens in GcTransitions.cs where the slotId is greater than the number of untracked slots</Description>
    <Title_Description>R2RDump - List of bugs when running R2RDump on CoreFX binaries There's an IndexOutOfRangeException when dumping an ARM ReadyToRun System.Private.Corelib.
It happens in R2RDump.NibbleReader.ReadNibble() when decoding fixups.
It also happens in GcTransitions.cs where the slotId is greater than the number of untracked slots</Title_Description>
    <Label>area-R2RDump</Label>
    <Assignee>acmyu</Assignee>
    <CreatedAt>23/08/2018 11:34:25 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19641</IssueLabelID>
    <Title>AppVerifier reports CoInitialize leak in coreclr</Title>
    <Description>Sometimes we get </Description>
    <Title_Description>AppVerifier reports CoInitialize leak in coreclr Sometimes we get </Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>23/08/2018 10:44:50 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19640</IssueLabelID>
    <Title>Workaround to remove unnecessary bounds checks when using {ReadOnly}Span.IsEmpty</Title>
    <Description>Workaround for https://github.com/dotnet/coreclr/issues/19620



Disassembly for before/after:
![image](https://user-images.githubusercontent.com/6527137/44555124-90fe2b80-a6e8-11e8-882a-c2504ed34924.png)


cc @AndyAyersMS @benaadams @GrabYourPitchforks @mikedn  
</Description>
    <Title_Description>Workaround to remove unnecessary bounds checks when using {ReadOnly}Span.IsEmpty Workaround for https://github.com/dotnet/coreclr/issues/19620



Disassembly for before/after:
![image](https://user-images.githubusercontent.com/6527137/44555124-90fe2b80-a6e8-11e8-882a-c2504ed34924.png)


cc @AndyAyersMS @benaadams @GrabYourPitchforks @mikedn  
</Title_Description>
    <Label>area-System.Memory</Label>
    <Assignee>ahsonkhan</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19637</IssueLabelID>
    <Title>R2RDump CoreDisTools fails to decode on ARM</Title>
    <Description>Right now disasm works on all architectures except Arm. The TargetArch used by CoreDisTools is Target_Thumb but it reads an invalid assembly code and fails to decode it.

This does not happen in all cases. CoreDisTools worked for an Arm image generated for https://github.com/dotnet/coreclr/blob/master/tests/src/readytorun/r2rdump/files/GcInfoTransitions.cs but not for the other tests in https://github.com/dotnet/coreclr/tree/master/tests/src/readytorun/r2rdump/files</Description>
    <Title_Description>R2RDump CoreDisTools fails to decode on ARM Right now disasm works on all architectures except Arm. The TargetArch used by CoreDisTools is Target_Thumb but it reads an invalid assembly code and fails to decode it.

This does not happen in all cases. CoreDisTools worked for an Arm image generated for https://github.com/dotnet/coreclr/blob/master/tests/src/readytorun/r2rdump/files/GcInfoTransitions.cs but not for the other tests in https://github.com/dotnet/coreclr/tree/master/tests/src/readytorun/r2rdump/files</Title_Description>
    <Label>area-R2RDump</Label>
    <Assignee>acmyu</Assignee>
    <CreatedAt>23/08/2018 9:48:22 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19632</IssueLabelID>
    <Title>How do we debug this MissingMethodException ?</Title>
    <Description>Hello 
We are trying to update Sql Ops Studio to use a new set of SMO binaries (NetStandard) but one of our services crashes on startup with a MissingMethodException:


I tried setting a breakpoint on MemberLoader:ThrowMissingMethodException but the optimized native code doesn't lend itself to debugging. I didn't find anything more useful than what is already in the message.
</Description>
    <Title_Description>How do we debug this MissingMethodException ? Hello 
We are trying to update Sql Ops Studio to use a new set of SMO binaries (NetStandard) but one of our services crashes on startup with a MissingMethodException:


I tried setting a breakpoint on MemberLoader:ThrowMissingMethodException but the optimized native code doesn't lend itself to debugging. I didn't find anything more useful than what is already in the message.
</Title_Description>
    <Label>area-AssemblyLoader</Label>
    <Assignee>vitek-karas</Assignee>
    <CreatedAt>23/08/2018 5:27:26 PM +00:00</CreatedAt>
    <ClosedAt>21/09/2018 8:38:14 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19630</IssueLabelID>
    <Title>WIP NO-MERGE dummy change to test dev/unix_test_workflow</Title>
    <Description>
    </Description>
    <Title_Description>WIP NO-MERGE dummy change to test dev/unix_test_workflow </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>23/08/2018 4:38:49 PM +00:00</CreatedAt>
    <ClosedAt>28/08/2018 10:54:29 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19628</IssueLabelID>
    <Title>Sub-optimal code when the operation "% 1" on integers is met</Title>
    <Description>Currently the CLR gives result "0" (which seems correct) for "remainder of 1" operation on integers.

&gt; The formula 

category:cq
theme:optimization
skill-level:beginner
cost:small</Description>
    <Title_Description>Sub-optimal code when the operation "% 1" on integers is met Currently the CLR gives result "0" (which seems correct) for "remainder of 1" operation on integers.

&gt; The formula 

category:cq
theme:optimization
skill-level:beginner
cost:small</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>23/08/2018 2:47:10 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19624</IssueLabelID>
    <Title>Rewrite deleted tests when corefx Avx.PermuteVar signature changes are absorbed</Title>
    <Description>This issue tracks reenabling and adding missing  intrinsics. Relevant changes are in:

1. Coreclr - #19582 
2. Corefx - https://github.com/dotnet/corefx/pull/31864</Description>
    <Title_Description>Rewrite deleted tests when corefx Avx.PermuteVar signature changes are absorbed This issue tracks reenabling and adding missing  intrinsics. Relevant changes are in:

1. Coreclr - #19582 
2. Corefx - https://github.com/dotnet/corefx/pull/31864</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>4creators</Assignee>
    <CreatedAt>23/08/2018 10:59:23 AM +00:00</CreatedAt>
    <ClosedAt>17/01/2019 7:10:52 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19623</IssueLabelID>
    <Title>Fix FreeBSD build</Title>
    <Description>
    </Description>
    <Title_Description>Fix FreeBSD build </Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>wfurt</Assignee>
    <CreatedAt>23/08/2018 9:20:55 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19622</IssueLabelID>
    <Title>GetFunctionEnter3Info does not return correct argument address on Unix</Title>
    <Description>This is an issue I found while investigating an issue reported in this thread: https://github.com/dotnet/coreclr/issues/18977

See also: https://github.com/dotnet/docs/issues/6728

On Linux GetFunctionEnter3Info does not return the correct argument addresses (It returns correct numRanges and totalArgumentSize). I've successfully verified this issue on x64 (Ubuntu) but I have yet tried to repro this on other architectures (arm). 

The sample profilee is a very simple program with one function call. 


As shown above the argument address (0x00007fffffffbf50) is does not contain the function arguments (0xaa 0xbb 0xcc "bar")

</Description>
    <Title_Description>GetFunctionEnter3Info does not return correct argument address on Unix This is an issue I found while investigating an issue reported in this thread: https://github.com/dotnet/coreclr/issues/18977

See also: https://github.com/dotnet/docs/issues/6728

On Linux GetFunctionEnter3Info does not return the correct argument addresses (It returns correct numRanges and totalArgumentSize). I've successfully verified this issue on x64 (Ubuntu) but I have yet tried to repro this on other architectures (arm). 

The sample profilee is a very simple program with one function call. 


As shown above the argument address (0x00007fffffffbf50) is does not contain the function arguments (0xaa 0xbb 0xcc "bar")

</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>davmason</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19620</IssueLabelID>
    <Title>Extra bounds checks are being generated in common span usage pattern</Title>
    <Description>I would expect the following code to have no bounds checks within the disassembly beyond the explicit length check when accessing the data via the indexer:



[SharpLab Link](https://sharplab.io/#v2:C4LghgzgtgPgAgBgARwIwG4CwAoOBmFAJiQGEkBvHJalAtANiQCMB7FgGyQEkIAxASwBOEYAGUADmADGAUwAUAJRlgAJgHkAduwCeEsBoA8TbcBkA+ZgFcAZtZmCAlBSo1X/a0jlMbdwQDoAGRkNAHNgAAskAyRUJBgYK1t7AG0EAF0kAEIAXiQAcnyHF1cSlAB2JGswdggZLGxS6jgK4EFLOuKkAF8cLqA=)

Version: Microsoft.NETCore.App 3.0.0-preview1-26809-04

cc @AndyAyersMS @benaadams @GrabYourPitchforks 

category:cq
theme:range-check
skill-level:expert
cost:large</Description>
    <Title_Description>Extra bounds checks are being generated in common span usage pattern I would expect the following code to have no bounds checks within the disassembly beyond the explicit length check when accessing the data via the indexer:



[SharpLab Link](https://sharplab.io/#v2:C4LghgzgtgPgAgBgARwIwG4CwAoOBmFAJiQGEkBvHJalAtANiQCMB7FgGyQEkIAxASwBOEYAGUADmADGAUwAUAJRlgAJgHkAduwCeEsBoA8TbcBkA+ZgFcAZtZmCAlBSo1X/a0jlMbdwQDoAGRkNAHNgAAskAyRUJBgYK1t7AG0EAF0kAEIAXiQAcnyHF1cSlAB2JGswdggZLGxS6jgK4EFLOuKkAF8cLqA=)

Version: Microsoft.NETCore.App 3.0.0-preview1-26809-04

cc @AndyAyersMS @benaadams @GrabYourPitchforks 

category:cq
theme:range-check
skill-level:expert
cost:large</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>ahsonkhan</Assignee>
    <CreatedAt>23/08/2018 3:36:40 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19616</IssueLabelID>
    <Title>R2RDump - List of sections not yet parsed</Title>
    <Description>- [ ]  is not yet parsed correctly</Description>
    <Title_Description>R2RDump - List of sections not yet parsed - [ ]  is not yet parsed correctly</Title_Description>
    <Label>area-R2RDump</Label>
    <Assignee>nattress</Assignee>
    <CreatedAt>22/08/2018 10:41:16 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19615</IssueLabelID>
    <Title>Enable cron jobs Linux/arm64</Title>
    <Description>
    </Description>
    <Title_Description>Enable cron jobs Linux/arm64 </Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>BruceForstall</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19614</IssueLabelID>
    <Title>[Windows|Arm64] init-tools.cmd supports native dotnet cli</Title>
    <Description>https://github.com/dotnet/coreclr/pull/19213 Adds support for init-tools.cmd for arm64 using the x86 toolset. Once packages are produced for windows arm64 use the native dotnetcli.</Description>
    <Title_Description>[Windows|Arm64] init-tools.cmd supports native dotnet cli https://github.com/dotnet/coreclr/pull/19213 Adds support for init-tools.cmd for arm64 using the x86 toolset. Once packages are produced for windows arm64 use the native dotnetcli.</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>jashook</Assignee>
    <CreatedAt>22/08/2018 9:41:26 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19613</IssueLabelID>
    <Title>[WIP] add test for #18988</Title>
    <Description>This PR is for test purpose only.</Description>
    <Title_Description>[WIP] add test for #18988 This PR is for test purpose only.</Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>22/08/2018 9:24:51 PM +00:00</CreatedAt>
    <ClosedAt>18/09/2018 5:38:57 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19611</IssueLabelID>
    <Title>Documentation for EventPipe</Title>
    <Description>We should have a walk through and some documentation on how to use EventPipe.</Description>
    <Title_Description>Documentation for EventPipe We should have a walk through and some documentation on how to use EventPipe.</Title_Description>
    <Label>EventPipe</Label>
    <Assignee>brianrob</Assignee>
    <CreatedAt>22/08/2018 8:52:23 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19608</IssueLabelID>
    <Title>Fix terminology in netci file</Title>
    <Description>
    </Description>
    <Title_Description>Fix terminology in netci file </Title_Description>
    <Label>area-Meta</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19607</IssueLabelID>
    <Title>Fix AsyncLocal&lt;class&gt; changed event to not be raised multiple times for one change in value (#17767)</Title>
    <Description>Port of https://github.com/dotnet/coreclr/pull/17767 to 2.2

- Functional fix for https://github.com/dotnet/coreclr/issues/17758
- This was a regression in 2.1 fixing for 2.2</Description>
    <Title_Description>Fix AsyncLocal&lt;class&gt; changed event to not be raised multiple times for one change in value (#17767) Port of https://github.com/dotnet/coreclr/pull/17767 to 2.2

- Functional fix for https://github.com/dotnet/coreclr/issues/17758
- This was a regression in 2.1 fixing for 2.2</Title_Description>
    <Label>area-System.Threading</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19606</IssueLabelID>
    <Title>Fix a PAL spin lock issue</Title>
    <Description>Fixes https://github.com/dotnet/coreclr/issues/18486
- Lock release needs to be at least volatile

master PR: https://github.com/dotnet/coreclr/pull/19604</Description>
    <Title_Description>Fix a PAL spin lock issue Fixes https://github.com/dotnet/coreclr/issues/18486
- Lock release needs to be at least volatile

master PR: https://github.com/dotnet/coreclr/pull/19604</Title_Description>
    <Label>Servicing-approved</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19605</IssueLabelID>
    <Title>Fix a PAL spin lock issue</Title>
    <Description>Fix for https://github.com/dotnet/coreclr/issues/18486
- Lock release needs to be at least volatile

master PR: https://github.com/dotnet/coreclr/pull/19604</Description>
    <Title_Description>Fix a PAL spin lock issue Fix for https://github.com/dotnet/coreclr/issues/18486
- Lock release needs to be at least volatile

master PR: https://github.com/dotnet/coreclr/pull/19604</Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19604</IssueLabelID>
    <Title>Fix a PAL spin lock issue</Title>
    <Description>Fix for https://github.com/dotnet/coreclr/issues/18486
- Lock release needs to be at least volatile</Description>
    <Title_Description>Fix a PAL spin lock issue Fix for https://github.com/dotnet/coreclr/issues/18486
- Lock release needs to be at least volatile</Title_Description>
    <Label>area-PAL</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19603</IssueLabelID>
    <Title>[WIP] Enable tiered compilation</Title>
    <Description>
    </Description>
    <Title_Description>[WIP] Enable tiered compilation </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19602</IssueLabelID>
    <Title>[WIP] Test CI</Title>
    <Description>
    </Description>
    <Title_Description>[WIP] Test CI </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19601</IssueLabelID>
    <Title>RyuJIT: Incorrect 4-byte immediate emitted for shift causes access violation</Title>
    <Description>In debug RyuJIT seems to try to emit a 4-byte immediate on a .</Description>
    <Title_Description>RyuJIT: Incorrect 4-byte immediate emitted for shift causes access violation In debug RyuJIT seems to try to emit a 4-byte immediate on a .</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>22/08/2018 2:07:26 PM +00:00</CreatedAt>
    <ClosedAt>24/08/2018 3:04:42 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19599</IssueLabelID>
    <Title>RyuJIT: Missing zeroing of upper bits for small struct used in Volatile.Read</Title>
    <Description>The example is:
</Description>
    <Title_Description>RyuJIT: Missing zeroing of upper bits for small struct used in Volatile.Read The example is:
</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>22/08/2018 12:16:41 PM +00:00</CreatedAt>
    <ClosedAt>21/12/2018 12:10:28 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19597</IssueLabelID>
    <Title>Enable eventpipe without restart dotnet process</Title>
    <Description>Is it any way to enable eventpipe diagnostics without restart dotnet process?
Performance problems with   my application do not start immediately but in around several days after launch.

Now for starting EventPipe diagnostics I need to enter next commands
export COMPlus_EnableEventPipe=1
export COMPlus_EventPipeConfig=Microsoft-DotNETCore-SampleProfiler:1:5

and restart dotnet process.

dotnet --info
Host (useful for support):
  Version: 2.1.2
  Commit:  811c3ce6c0
.NET Core SDKs installed:
  No SDKs were found.
.NET Core runtimes installed:
  Microsoft.NETCore.App 2.1.2 [/usr/share/dotnet/shared/Microsoft.NETCore.App]
To install additional .NET Core runtimes or SDKs:
  https://aka.ms/dotnet-download

</Description>
    <Title_Description>Enable eventpipe without restart dotnet process Is it any way to enable eventpipe diagnostics without restart dotnet process?
Performance problems with   my application do not start immediately but in around several days after launch.

Now for starting EventPipe diagnostics I need to enter next commands
export COMPlus_EnableEventPipe=1
export COMPlus_EventPipeConfig=Microsoft-DotNETCore-SampleProfiler:1:5

and restart dotnet process.

dotnet --info
Host (useful for support):
  Version: 2.1.2
  Commit:  811c3ce6c0
.NET Core SDKs installed:
  No SDKs were found.
.NET Core runtimes installed:
  Microsoft.NETCore.App 2.1.2 [/usr/share/dotnet/shared/Microsoft.NETCore.App]
To install additional .NET Core runtimes or SDKs:
  https://aka.ms/dotnet-download

</Title_Description>
    <Label>EventPipe</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>22/08/2018 10:34:20 AM +00:00</CreatedAt>
    <ClosedAt>15/04/2019 5:47:21 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19596</IssueLabelID>
    <Title>Consider implementing Ryu algorithm for double.ToString() </Title>
    <Description>***Introduction***
A few months ago a new string formatting algorithm for floating point numbers was presented It is called 
Ryu and the benchmarks show it to be roughly ~3 times faster than the previously fastest algorithm Grisu3 (which was implemented in #14478 for 2.1).

The float version uses mainly ulong arithmetics + table lookups the double version uses mainly uint128 arithmetics + table lookups. 
The double version might be an interesting use case for the intrinsic code as e.g. 128bit shifts are SSE2.

As far as I see the fallback to the Dragon4 algorithm should not be necessary anymore with that algorithm and they claim it to be output-identical to grisu3 otherwise.

***References***
https://dl.acm.org/citation.cfm?id=3192369
https://pldi18.sigplan.org/event/pldi-2018-papers-ry-fast-float-to-string-conversion
https://github.com/ulfjack/ryu

Tags:
@mazong1123 Might be of interest for you as you did the Grisu3 implementation
@tannergooding I think you were looking for algorithms which might be worthwhile for intrinsic implementations
@danmosemsft For reference of https://github.com/dotnet/corefx/issues/31847

***Performance***

I did an experimental port of the current c implementation for the float datatype (https://github.com/ulfjack/ryu/blob/master/ryu/f2s.c)  to c# (purely mechanical just to get it working) and ran a few benchmarks myself and that naive conversion in C# was **~50%** faster than the current grisu3 algorithm. Assuming I didn't make any bad shortcuts in my benchmark I'd say a closer look might be worth it.


My naive conversion is below:

&lt;details&gt;


&lt;/details&gt;
</Description>
    <Title_Description>Consider implementing Ryu algorithm for double.ToString()  ***Introduction***
A few months ago a new string formatting algorithm for floating point numbers was presented It is called 
Ryu and the benchmarks show it to be roughly ~3 times faster than the previously fastest algorithm Grisu3 (which was implemented in #14478 for 2.1).

The float version uses mainly ulong arithmetics + table lookups the double version uses mainly uint128 arithmetics + table lookups. 
The double version might be an interesting use case for the intrinsic code as e.g. 128bit shifts are SSE2.

As far as I see the fallback to the Dragon4 algorithm should not be necessary anymore with that algorithm and they claim it to be output-identical to grisu3 otherwise.

***References***
https://dl.acm.org/citation.cfm?id=3192369
https://pldi18.sigplan.org/event/pldi-2018-papers-ry-fast-float-to-string-conversion
https://github.com/ulfjack/ryu

Tags:
@mazong1123 Might be of interest for you as you did the Grisu3 implementation
@tannergooding I think you were looking for algorithms which might be worthwhile for intrinsic implementations
@danmosemsft For reference of https://github.com/dotnet/corefx/issues/31847

***Performance***

I did an experimental port of the current c implementation for the float datatype (https://github.com/ulfjack/ryu/blob/master/ryu/f2s.c)  to c# (purely mechanical just to get it working) and ran a few benchmarks myself and that naive conversion in C# was **~50%** faster than the current grisu3 algorithm. Assuming I didn't make any bad shortcuts in my benchmark I'd say a closer look might be worth it.


My naive conversion is below:

&lt;details&gt;


&lt;/details&gt;
</Title_Description>
    <Label>area-System.Runtime</Label>
    <Assignee>mazong1123</Assignee>
    <CreatedAt>22/08/2018 7:45:31 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19595</IssueLabelID>
    <Title>[WIP] Enable tiering</Title>
    <Description>
    </Description>
    <Title_Description>[WIP] Enable tiering </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19594</IssueLabelID>
    <Title>Newly implementd partial loop-unrolling support for RyuJIT </Title>
    <Description>This will replace PR : https://github.com/dotnet/coreclr/pull/18016</Description>
    <Title_Description>Newly implementd partial loop-unrolling support for RyuJIT  This will replace PR : https://github.com/dotnet/coreclr/pull/18016</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
    <CreatedAt>22/08/2018 4:40:28 AM +00:00</CreatedAt>
    <ClosedAt>7/11/2019 1:20:52 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19592</IssueLabelID>
    <Title>R2RDump - Invalid Machine type in the COFF header for Linux images</Title>
    <Description>Right now for ReadyToRun images created on Linux R2RDump isn't able to read the Machine type (Amd64 arm etc.). When I use dumpbin /HEADERS for Linux native images the machine type is also unknown

It tries to read the machine type from the CoffHeader using the PEReader but gets a large number instead of a valid machine type. The R2RReader currently writes a warning and sets the machine to Amd64
</Description>
    <Title_Description>R2RDump - Invalid Machine type in the COFF header for Linux images Right now for ReadyToRun images created on Linux R2RDump isn't able to read the Machine type (Amd64 arm etc.). When I use dumpbin /HEADERS for Linux native images the machine type is also unknown

It tries to read the machine type from the CoffHeader using the PEReader but gets a large number instead of a valid machine type. The R2RReader currently writes a warning and sets the machine to Amd64
</Title_Description>
    <Label>area-ReadyToRun</Label>
    <Assignee>acmyu</Assignee>
    <CreatedAt>22/08/2018 1:07:39 AM +00:00</CreatedAt>
    <ClosedAt>23/08/2018 10:02:04 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19591</IssueLabelID>
    <Title>Update RyuJIT overview and LSRA doc</Title>
    <Description>A number of changes have been made to the register allocator in particular #16517 and the documentation needs to be updated accordingly.

category:documentation
theme:ir
skill-level:expert
cost:medium</Description>
    <Title_Description>Update RyuJIT overview and LSRA doc A number of changes have been made to the register allocator in particular #16517 and the documentation needs to be updated accordingly.

category:documentation
theme:ir
skill-level:expert
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19587</IssueLabelID>
    <Title>[Win/x64] Visual Studio 2017 15.9.0 prerelease 1 fails to build coreclr repo</Title>
    <Description>Hitting reproducible build errors which indicate wrong environment for ml64.exe invocations - tool seems of the path at the moment of invocation or in general path is set for tools in build environment is wrong:

</Description>
    <Title_Description>[Win/x64] Visual Studio 2017 15.9.0 prerelease 1 fails to build coreclr repo Hitting reproducible build errors which indicate wrong environment for ml64.exe invocations - tool seems of the path at the moment of invocation or in general path is set for tools in build environment is wrong:

</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>21/08/2018 8:57:00 PM +00:00</CreatedAt>
    <ClosedAt>25/08/2018 8:57:49 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19584</IssueLabelID>
    <Title>Fix JitBench</Title>
    <Description>Fixes https://github.com/dotnet/coreclr/issues/19569
- I believe the issue was that JitBench (which was a netstandard1.6 project) was running against a netcoreapp3.0 layout with corerun (layout built using build + recent packages by runtests.cmd) and XmlDocument is in a different place now
- Copied the unofficial project and replaced the official one
- Switched to netcoreapp3.0 along with other miscellaneous fixes to get it working
- I haven't figured out yet how to get one project that builds with the test build and works with dotnet. TargetFramework would have to be different anyway if running with dotnet runtime 2.1. So the unofficial project is still there for use with dotnet.</Description>
    <Title_Description>Fix JitBench Fixes https://github.com/dotnet/coreclr/issues/19569
- I believe the issue was that JitBench (which was a netstandard1.6 project) was running against a netcoreapp3.0 layout with corerun (layout built using build + recent packages by runtests.cmd) and XmlDocument is in a different place now
- Copied the unofficial project and replaced the official one
- Switched to netcoreapp3.0 along with other miscellaneous fixes to get it working
- I haven't figured out yet how to get one project that builds with the test build and works with dotnet. TargetFramework would have to be different anyway if running with dotnet runtime 2.1. So the unofficial project is still there for use with dotnet.</Title_Description>
    <Label>area-Meta</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19583</IssueLabelID>
    <Title>RyuJIT: Incorrect ordering around Interlocked.Exchange and Interlocked.CompareExchange</Title>
    <Description>Example:
</Description>
    <Title_Description>RyuJIT: Incorrect ordering around Interlocked.Exchange and Interlocked.CompareExchange Example:
</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>21/08/2018 10:50:22 AM +00:00</CreatedAt>
    <ClosedAt>24/01/2019 7:59:48 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19578</IssueLabelID>
    <Title>csc.dll code 139 error when building project on .NET Core 2.1.302 Ubuntu 16.04 ARM64</Title>
    <Description>I have downloaded .NET Core SDK for linux ARM64 on my Jetson TX2 running ubuntu 16.04.




I wish to build iotedge for Jetson TX2 and dotnet Core 2.1 is a dependency for the same.

This is my binary log file. I had to rename it with a .zip extension to upload here.
just rename the file from msbuild.binlog.zip to msbuild.binlog

[msbuild.binlog.zip](https://github.com/dotnet/roslyn/files/2296720/msbuild.binlog.zip)


https://github.com/dotnet/roslyn/issues/29194</Description>
    <Title_Description>csc.dll code 139 error when building project on .NET Core 2.1.302 Ubuntu 16.04 ARM64 I have downloaded .NET Core SDK for linux ARM64 on my Jetson TX2 running ubuntu 16.04.




I wish to build iotedge for Jetson TX2 and dotnet Core 2.1 is a dependency for the same.

This is my binary log file. I had to rename it with a .zip extension to upload here.
just rename the file from msbuild.binlog.zip to msbuild.binlog

[msbuild.binlog.zip](https://github.com/dotnet/roslyn/files/2296720/msbuild.binlog.zip)


https://github.com/dotnet/roslyn/issues/29194</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>jashook</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19574</IssueLabelID>
    <Title>IBC Optimization changes broke some CoreCLR official builds</Title>
    <Description>Appears to be a side-effect of https://github.com/dotnet/coreclr/pull/19046  
@adiaaida please see me if I am mistaken or you need any assistance investigating.

Opened on behalf of @MattGal



Warnings: 1
Status Message: failed

Build : 3.0 - 20180821.01 (Product Build)
Failing configurations:
- Windows
  - PortableBuild-Checked-arm
  - PortableBuild-Checked-arm64
  - PortableBuild-Checked-x64
  - PortableBuild-Debug-arm
  - PortableBuild-Debug-arm64
  - PortableBuild-Debug-x64
  - PortableBuild-Release-arm
  - PortableBuild-Release-arm64
[Mission Control Build Info](https://mc.dot.net/#/product/netcore/30/source/official~2Fcoreclr~2Fmaster~2F/type/build~2Fproduct~2F/build/20180821.01/workItem/Orchestration/analysis/external/Link)</Description>
    <Title_Description>IBC Optimization changes broke some CoreCLR official builds Appears to be a side-effect of https://github.com/dotnet/coreclr/pull/19046  
@adiaaida please see me if I am mistaken or you need any assistance investigating.

Opened on behalf of @MattGal



Warnings: 1
Status Message: failed

Build : 3.0 - 20180821.01 (Product Build)
Failing configurations:
- Windows
  - PortableBuild-Checked-arm
  - PortableBuild-Checked-arm64
  - PortableBuild-Checked-x64
  - PortableBuild-Debug-arm
  - PortableBuild-Debug-arm64
  - PortableBuild-Debug-x64
  - PortableBuild-Release-arm
  - PortableBuild-Release-arm64
[Mission Control Build Info](https://mc.dot.net/#/product/netcore/30/source/official~2Fcoreclr~2Fmaster~2F/type/build~2Fproduct~2F/build/20180821.01/workItem/Orchestration/analysis/external/Link)</Title_Description>
    <Label>blocking-official-build</Label>
    <Assignee>MattGal</Assignee>
    <CreatedAt>21/08/2018 12:49:39 AM +00:00</CreatedAt>
    <ClosedAt>21/08/2018 5:30:29 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19573</IssueLabelID>
    <Title>roundUp roundDn cleanup</Title>
    <Description>This PR overloads  at all? Its "refCount" is zero right now.</Description>
    <Title_Description>roundUp roundDn cleanup This PR overloads  at all? Its "refCount" is zero right now.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>echesakovMSFT</Assignee>
    <CreatedAt>21/08/2018 12:48:57 AM +00:00</CreatedAt>
    <ClosedAt>21/08/2018 5:56:37 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19570</IssueLabelID>
    <Title>Fix dbgshim's &gt; 1000 module bug (issue #19538) (#19553)</Title>
    <Description>Fix dbgshim's &gt; 1000 module bug (issue #19538)

Cap cbNeeded on second EnumProcessModules call. Change the allocations
to HMODULE to make sure they are aligned properly.</Description>
    <Title_Description>Fix dbgshim's &gt; 1000 module bug (issue #19538) (#19553) Fix dbgshim's &gt; 1000 module bug (issue #19538)

Cap cbNeeded on second EnumProcessModules call. Change the allocations
to HMODULE to make sure they are aligned properly.</Title_Description>
    <Label>
    </Label>
    <Assignee>mikem8361</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19569</IssueLabelID>
    <Title>CoreClr Performance Scenarios broke after PR #19479</Title>
    <Description>After https://github.com/dotnet/coreclr/pull/19479 the performance scenarios started failing with the following error:


/cc @noahfalk @AndyAyersMS </Description>
    <Title_Description>CoreClr Performance Scenarios broke after PR #19479 After https://github.com/dotnet/coreclr/pull/19479 the performance scenarios started failing with the following error:


/cc @noahfalk @AndyAyersMS </Title_Description>
    <Label>tenet-performance</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19568</IssueLabelID>
    <Title>[Ubuntu 16.04] PR #19525 might have introduced a regression on the CQ benchmarks</Title>
    <Description>The range of changes that are captured for the run that started showing the regression are these: https://github.com/dotnet/coreclr/compare/a81d9103d23f714a0bd3efb900321b0b9f383311...dotnet:0fc981abe7b9ca6898f157bc247edad265d4088b

This is an example of a single regression of ~24%
![capture](https://user-images.githubusercontent.com/12551699/44367867-d7a01b80-a485-11e8-90ef-76fa39ade628.PNG)

/cc @AndyAyersMS @noahfalk @kouvel </Description>
    <Title_Description>[Ubuntu 16.04] PR #19525 might have introduced a regression on the CQ benchmarks The range of changes that are captured for the run that started showing the regression are these: https://github.com/dotnet/coreclr/compare/a81d9103d23f714a0bd3efb900321b0b9f383311...dotnet:0fc981abe7b9ca6898f157bc247edad265d4088b

This is an example of a single regression of ~24%
![capture](https://user-images.githubusercontent.com/12551699/44367867-d7a01b80-a485-11e8-90ef-76fa39ade628.PNG)

/cc @AndyAyersMS @noahfalk @kouvel </Title_Description>
    <Label>tenet-performance</Label>
    <Assignee>jorive</Assignee>
    <CreatedAt>20/08/2018 9:41:25 PM +00:00</CreatedAt>
    <ClosedAt>22/08/2018 5:30:43 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19567</IssueLabelID>
    <Title>Fix tiered compilation option for case-sensitive systems</Title>
    <Description>
    </Description>
    <Title_Description>Fix tiered compilation option for case-sensitive systems </Title_Description>
    <Label>area-TieredCompilation</Label>
    <Assignee>jorive</Assignee>
    <CreatedAt>20/08/2018 9:32:39 PM +00:00</CreatedAt>
    <ClosedAt>21/08/2018 1:38:31 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19566</IssueLabelID>
    <Title>Interop request: Support exported symbols</Title>
    <Description>_From @MV10 on August 19 2018 17:5_

Request: Define a new attribute which maps a managed variable to an exported symbol exactly as we get today using  blocks based on Runtime Identifier build constants once I figure out how it works on the other platforms.

(On a related note I noticed in #24444 the OP asks about _data_ and interfaces but it seems the data portion of the question was overlooked.)

_Copied from original issue: dotnet/corefx#31836_</Description>
    <Title_Description>Interop request: Support exported symbols _From @MV10 on August 19 2018 17:5_

Request: Define a new attribute which maps a managed variable to an exported symbol exactly as we get today using  blocks based on Runtime Identifier build constants once I figure out how it works on the other platforms.

(On a related note I noticed in #24444 the OP asks about _data_ and interfaces but it seems the data portion of the question was overlooked.)

_Copied from original issue: dotnet/corefx#31836_</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>20/08/2018 7:29:46 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19565</IssueLabelID>
    <Title>Add no-tiering CI jobs for testing with tiering enabled</Title>
    <Description>This ports the following PRs to 2.2:
- https://github.com/dotnet/coreclr/pull/18828
- https://github.com/dotnet/coreclr/pull/18864
- https://github.com/dotnet/coreclr/pull/18953
- https://github.com/dotnet/coreclr/pull/19123

See the individual commit descriptions for more info. It looks like the changes need to be merged before the CI jobs can be kicked off for testing them with tiering enabled.</Description>
    <Title_Description>Add no-tiering CI jobs for testing with tiering enabled This ports the following PRs to 2.2:
- https://github.com/dotnet/coreclr/pull/18828
- https://github.com/dotnet/coreclr/pull/18864
- https://github.com/dotnet/coreclr/pull/18953
- https://github.com/dotnet/coreclr/pull/19123

See the individual commit descriptions for more info. It looks like the changes need to be merged before the CI jobs can be kicked off for testing them with tiering enabled.</Title_Description>
    <Label>area-Meta</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19564</IssueLabelID>
    <Title>R2RDump with x86 disassembler architecture fails to disassemble R2R images</Title>
    <Description>On my x64 machine I generated a R2R image with crossgen then tried to disassemble with two different R2RDump builds. The x64 version of the tools will disassemble correctly but the x86 version of the tools will fail with an AV. This has been replaced with an exception for the time being but the behavior needs to be fixed

## x64 CoreDisTools disassembling an x64 R2R image
1. dotnet build --runtime win-x64
2. E:\git\dotnet\coreclr\bin\Product\Windows_NT.x64.Debug\netcoreapp2.0\win-x64\R2RDump.exe --in MultipleRuntimeFunctions.ni.dll --disasm


</Description>
    <Title_Description>R2RDump with x86 disassembler architecture fails to disassemble R2R images On my x64 machine I generated a R2R image with crossgen then tried to disassemble with two different R2RDump builds. The x64 version of the tools will disassemble correctly but the x86 version of the tools will fail with an AV. This has been replaced with an exception for the time being but the behavior needs to be fixed

## x64 CoreDisTools disassembling an x64 R2R image
1. dotnet build --runtime win-x64
2. E:\git\dotnet\coreclr\bin\Product\Windows_NT.x64.Debug\netcoreapp2.0\win-x64\R2RDump.exe --in MultipleRuntimeFunctions.ni.dll --disasm


</Title_Description>
    <Label>area-R2RDump</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>20/08/2018 4:51:40 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19560</IssueLabelID>
    <Title>Clean up register preservation requirements for Enter callback</Title>
    <Description>#19023 


I'm still testing this so adding NO_MERGE tag even if CI suggests it is good.

@BruceForstall - PTAL
cc @sergign60 </Description>
    <Title_Description>Clean up register preservation requirements for Enter callback #19023 


I'm still testing this so adding NO_MERGE tag even if CI suggests it is good.

@BruceForstall - PTAL
cc @sergign60 </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>echesakovMSFT</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19558</IssueLabelID>
    <Title>RyuJIT: Mishandling of subrange assertion for rewritten call parameter</Title>
    <Description>The example is:
 to 0 in release) (edit: updated example).

@mikedn has analyzed it here: https://github.com/dotnet/coreclr/issues/18867#issuecomment-413246494</Description>
    <Title_Description>RyuJIT: Mishandling of subrange assertion for rewritten call parameter The example is:
 to 0 in release) (edit: updated example).

@mikedn has analyzed it here: https://github.com/dotnet/coreclr/issues/18867#issuecomment-413246494</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>mikedn</Assignee>
    <CreatedAt>19/08/2018 9:13:13 PM +00:00</CreatedAt>
    <ClosedAt>5/12/2018 10:26:56 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19555</IssueLabelID>
    <Title>lzcnt tzcnt popcnt false dependency not handled in CoreCLR</Title>
    <Description>Hi
Following my successful foray into the brave world of CoreCLR architecture specific intrinsics I think I stumbled upon a relatively known bug/deficiency in most intel CPUs (I have no knowledge on how this affects AMD CPUs if at all) that is now affecting perf on CoreCLR.

It appears that when I write a tight / unrolled loop with any of the intrinsics mentioned in the issue name:
* 

Would this be something that CoreCLR JIT could dynamically detect (according to CPU model/family) and insert into the instruction stream?
</Description>
    <Title_Description>lzcnt, tzcnt, popcnt false dependency not handled in CoreCLR Hi
Following my successful foray into the brave world of CoreCLR architecture specific intrinsics I think I stumbled upon a relatively known bug/deficiency in most intel CPUs (I have no knowledge on how this affects AMD CPUs if at all) that is now affecting perf on CoreCLR.

It appears that when I write a tight / unrolled loop with any of the intrinsics mentioned in the issue name:
* 

Would this be something that CoreCLR JIT could dynamically detect (according to CPU model/family) and insert into the instruction stream?
</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>fiigii</Assignee>
    <CreatedAt>19/08/2018 7:02:59 AM +00:00</CreatedAt>
    <ClosedAt>31/08/2018 5:21:37 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19553</IssueLabelID>
    <Title>Fix dbgshim's &gt; 1000 module bug (issue #19538)</Title>
    <Description>
    </Description>
    <Title_Description>Fix dbgshim's &gt; 1000 module bug (issue #19538) </Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>mikem8361</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19550</IssueLabelID>
    <Title>Codegen for Hardware Intrinsics arithmetic operations memory operands is poor</Title>
    <Description>Majority of hardware intrinsics arithmetic operations support using memory address as one of it's operands. It allows to write more efficient code which would bypass memory bottlenecks. Unfortunately jit does not fold memory loads into one of arithmetic operation operands and generates code for separate loads or stores.

The following example illustrates the problem (expression was specifically written to hint jit that second subtraction operand should not be loaded but folded into memory operand):

 reads into memory operands. Unfortunately the burden to write more code would make use of intrinsics even more harder and some developers would not even know how to use that support without digging into docs. 

IMHO the best solution would be to expand API surface as this would be self documenting enhancement. Furthermore from my experience managing data flow through memory avoiding memory wall while using HW intrinsics is one of the most difficult parts of the coding with them.

cc @AndyAyersMS  @CarolEidt @eerhardt @fiigii @tannergooding </Description>
    <Title_Description>Codegen for Hardware Intrinsics arithmetic operations memory operands is poor Majority of hardware intrinsics arithmetic operations support using memory address as one of it's operands. It allows to write more efficient code which would bypass memory bottlenecks. Unfortunately jit does not fold memory loads into one of arithmetic operation operands and generates code for separate loads or stores.

The following example illustrates the problem (expression was specifically written to hint jit that second subtraction operand should not be loaded but folded into memory operand):

 reads into memory operands. Unfortunately the burden to write more code would make use of intrinsics even more harder and some developers would not even know how to use that support without digging into docs. 

IMHO the best solution would be to expand API surface as this would be self documenting enhancement. Furthermore from my experience managing data flow through memory avoiding memory wall while using HW intrinsics is one of the most difficult parts of the coding with them.

cc @AndyAyersMS  @CarolEidt @eerhardt @fiigii @tannergooding </Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19549</IssueLabelID>
    <Title>Set BUILDTOOLS_SOURCE to local buildtools package dir results in build error</Title>
    <Description>It seems building coreclr with using locally built buildtools packages fail. I spent couple of hours trying to find the cause I thought it was related with changes I made in buildtools but that also happens when building buildtools from master. I wonder that nobody else hit this therefore I'm not entirely sure if I'm the only one hitting this?

Repro:

</Description>
    <Title_Description>Set BUILDTOOLS_SOURCE to local buildtools package dir results in build error It seems building coreclr with using locally built buildtools packages fail. I spent couple of hours trying to find the cause I thought it was related with changes I made in buildtools but that also happens when building buildtools from master. I wonder that nobody else hit this therefore I'm not entirely sure if I'm the only one hitting this?

Repro:

</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>ViktorHofer</Assignee>
    <CreatedAt>18/08/2018 12:17:36 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19548</IssueLabelID>
    <Title>Fix issues with calling convention in tests.</Title>
    <Description>Fixes #19540 

cc @BruceForstall </Description>
    <Title_Description>Fix issues with calling convention in tests. Fixes #19540 

cc @BruceForstall </Title_Description>
    <Label>test bug</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>18/08/2018 7:20:54 AM +00:00</CreatedAt>
    <ClosedAt>20/08/2018 7:00:56 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19545</IssueLabelID>
    <Title>[WIP] Use target_ssize_t for Lowering::CastInfo::typeMin typeMax typeMask</Title>
    <Description>
    </Description>
    <Title_Description>[WIP] Use target_ssize_t for Lowering::CastInfo::typeMin typeMax typeMask </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>echesakovMSFT</Assignee>
    <CreatedAt>18/08/2018 1:22:55 AM +00:00</CreatedAt>
    <ClosedAt>7/09/2018 4:16:44 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19544</IssueLabelID>
    <Title>Use target_ssize_t imm in CodeGen CodeGenInterface</Title>
    <Description>In order to get rid off compilation warnings in cross-bitness compilation scenario  for immediate value argument.</Description>
    <Title_Description>Use target_ssize_t imm in CodeGen CodeGenInterface In order to get rid off compilation warnings in cross-bitness compilation scenario  for immediate value argument.</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>echesakovMSFT</Assignee>
    <CreatedAt>18/08/2018 1:15:41 AM +00:00</CreatedAt>
    <ClosedAt>21/08/2018 3:19:09 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19542</IssueLabelID>
    <Title>Enable mixed mode assembly loading</Title>
    <Description>Selectively brings back the deleted code to support mixed mode assembly loading a managed-&gt;native calls. Code for native-&gt;managed and activation will be in future changes. Also includes a simple test case.

Contributes to https://github.com/dotnet/coreclr/issues/18013</Description>
    <Title_Description>Enable mixed mode assembly loading Selectively brings back the deleted code to support mixed mode assembly loading a managed-&gt;native calls. Code for native-&gt;managed and activation will be in future changes. Also includes a simple test case.

Contributes to https://github.com/dotnet/coreclr/issues/18013</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>morganbr</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19540</IssueLabelID>
    <Title>Windows x86 tests failing due to missing native dll entrypoints</Title>
    <Description>Windows test runs are failing due to native components having missing entrypoints. There are 4 test failures. E.g.

https://ci.dot.net/job/dotnet_coreclr/job/master/view/x86/job/x86_checked_windows_nt/5151/



This appears to be due to the build changes in https://github.com/dotnet/coreclr/pull/19430.

</Description>
    <Title_Description>Windows x86 tests failing due to missing native dll entrypoints Windows test runs are failing due to native components having missing entrypoints. There are 4 test failures. E.g.

https://ci.dot.net/job/dotnet_coreclr/job/master/view/x86/job/x86_checked_windows_nt/5151/



This appears to be due to the build changes in https://github.com/dotnet/coreclr/pull/19430.

</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19539</IssueLabelID>
    <Title> Free the alternate signal stack if this PAL's thread allocated it.</Title>
    <Description>Pass the CPalThread instance through to EnsureSignalAlternateStack and save the altstack pointer allocated.   And in FreeSignalAlternateStack use this pointer to ensure that only the proper PAL frees the stack.</Description>
    <Title_Description> Free the alternate signal stack if this PAL's thread allocated it. Pass the CPalThread instance through to EnsureSignalAlternateStack and save the altstack pointer allocated.   And in FreeSignalAlternateStack use this pointer to ensure that only the proper PAL frees the stack.</Title_Description>
    <Label>
    </Label>
    <Assignee>mikem8361</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19538</IssueLabelID>
    <Title>dbgshim.dll!EnumerateCLRs may crash with &gt;1000 modules</Title>
    <Description>[EnumerateCLRs](https://github.com/dotnet/coreclr/blob/0f0320e58fd006a02cdecf7ae45426f54da333e5/src/dlls/dbgshim/dbgshim.cpp#L1095) may crash when inspecting a process with &gt;1000 modules. The issue is that the behavior of [EnumProcessModules](https://docs.microsoft.com/en-us/windows/desktop/api/psapi/nf-psapi-enumprocessmodules#remarks) in the case that more modules are loaded than there is space in the provided buffer is to return TRUE and set cbNeeded to the size to allocate. But this code assumes that cbNeeded will always be &lt;= the size of </Description>
    <Title_Description>dbgshim.dll!EnumerateCLRs may crash with &gt;1000 modules [EnumerateCLRs](https://github.com/dotnet/coreclr/blob/0f0320e58fd006a02cdecf7ae45426f54da333e5/src/dlls/dbgshim/dbgshim.cpp#L1095) may crash when inspecting a process with &gt;1000 modules. The issue is that the behavior of [EnumProcessModules](https://docs.microsoft.com/en-us/windows/desktop/api/psapi/nf-psapi-enumprocessmodules#remarks) in the case that more modules are loaded than there is space in the provided buffer is to return TRUE and set cbNeeded to the size to allocate. But this code assumes that cbNeeded will always be &lt;= the size of </Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>mikem8361</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19537</IssueLabelID>
    <Title>[Ubuntu/arm32] Assertion failed '(regSet.rsMaskResvd &amp; RBM_OPT_RSVD) != 0'</Title>
    <Description>In corefx testing System.Numerics.Vectors.Tests:



Happens for various JitStressRegs stress modes (list may not be exhaustive):

https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstressregs3_tst/20/
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstressregs4_flow/20/
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_tieredcompilation_flow/8/
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstressregs1_flow/21/
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_flow/22/

This is a recent regression.

@dotnet/arm32-contrib @CarolEidt </Description>
    <Title_Description>[Ubuntu/arm32] Assertion failed '(regSet.rsMaskResvd &amp; RBM_OPT_RSVD) != 0' In corefx testing System.Numerics.Vectors.Tests:



Happens for various JitStressRegs stress modes (list may not be exhaustive):

https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstressregs3_tst/20/
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstressregs4_flow/20/
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_tieredcompilation_flow/8/
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstressregs1_flow/21/
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_flow/22/

This is a recent regression.

@dotnet/arm32-contrib @CarolEidt </Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>BruceForstall</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19536</IssueLabelID>
    <Title>Fix wrong sprinf_s format string in gtGetArgMsg getGetLateArgMsg on ARM32</Title>
    <Description>One liner that fixes typo in  for arguments passed on stack</Description>
    <Title_Description>Fix wrong sprinf_s format string in gtGetArgMsg getGetLateArgMsg on ARM32 One liner that fixes typo in  for arguments passed on stack</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>echesakovMSFT</Assignee>
    <CreatedAt>17/08/2018 10:13:10 PM +00:00</CreatedAt>
    <ClosedAt>19/08/2018 1:03:07 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19535</IssueLabelID>
    <Title>[NO MERGE] Test Linux Binaries</Title>
    <Description>The updated binaries were a commit behind. Connected to https://github.com/dotnet/coreclr/pull/19393 </Description>
    <Title_Description>[NO MERGE] Test Linux Binaries The updated binaries were a commit behind. Connected to https://github.com/dotnet/coreclr/pull/19393 </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>A-And</Assignee>
    <CreatedAt>17/08/2018 9:25:50 PM +00:00</CreatedAt>
    <ClosedAt>23/08/2018 8:48:13 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19529</IssueLabelID>
    <Title>Create New Minimal Start From Scratch CoreClr</Title>
    <Description>How to create new minimal start from scratch CoreClr?</Description>
    <Title_Description>Create New Minimal Start From Scratch CoreClr How to create new minimal start from scratch CoreClr?</Title_Description>
    <Label>question</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>17/08/2018 5:30:50 AM +00:00</CreatedAt>
    <ClosedAt>21/08/2018 4:02:34 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19527</IssueLabelID>
    <Title>Remove tests previously ported to CoreFX repo</Title>
    <Description>Ported tests in dotnet/corefx#30690

cc @luqunl </Description>
    <Title_Description>Remove tests previously ported to CoreFX repo Ported tests in dotnet/corefx#30690

cc @luqunl </Title_Description>
    <Label>area-Interop</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>17/08/2018 1:04:09 AM +00:00</CreatedAt>
    <ClosedAt>17/08/2018 6:09:32 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19526</IssueLabelID>
    <Title>Only register signals and create alt exception stack in coreclr</Title>
    <Description>Only register signals and create alt exception stack in coreclr. (#19309)

There was a couple of places where the DAC (IsValidObject GetAppDomainForObject)
assumed that a NULL target/debuggee address would throw an exception that would
be caught by try/catch. Any other invalid address is handled with a software
exception throwed by the read memory functions. In general it is a better overall
design not to have any of the DBI/DAC etc. code depend on hardware exceptions
being caught. On Linux the C++ runtime sometimes can't handle it. There is a
slight risk that there are other places in the DAC that make the NULL address
assumption but testing so far has found any.

Added PAL_SetInitializeDLLFlags as a fallback to allow the PAL_InitializeDLL flags
to be set for a PAL instance for the DAC where we could still register h/w signals
but not the altstack switching to reduce this risk. The flags can't be build time
conditional because we only build one coreclrpal.a library that all the modules
used. Having a PAL_InitializeWithFlags function doesn't really help either because of
the PAL_RegisterModule call to PAL_IntializeDLL and the LoadLibrary dance/protocol
that uses it to call the loading module's DLLMain.

Add PAL_SetInitializeFlags; remove flags from PAL_INITIALIZE and PAL_INITIALIZE_DLL
default. Add PAL_InitializeWithFlags() to allowing the default to be overriden.</Description>
    <Title_Description>Only register signals and create alt exception stack in coreclr Only register signals and create alt exception stack in coreclr. (#19309)

There was a couple of places where the DAC (IsValidObject GetAppDomainForObject)
assumed that a NULL target/debuggee address would throw an exception that would
be caught by try/catch. Any other invalid address is handled with a software
exception throwed by the read memory functions. In general it is a better overall
design not to have any of the DBI/DAC etc. code depend on hardware exceptions
being caught. On Linux the C++ runtime sometimes can't handle it. There is a
slight risk that there are other places in the DAC that make the NULL address
assumption but testing so far has found any.

Added PAL_SetInitializeDLLFlags as a fallback to allow the PAL_InitializeDLL flags
to be set for a PAL instance for the DAC where we could still register h/w signals
but not the altstack switching to reduce this risk. The flags can't be build time
conditional because we only build one coreclrpal.a library that all the modules
used. Having a PAL_InitializeWithFlags function doesn't really help either because of
the PAL_RegisterModule call to PAL_IntializeDLL and the LoadLibrary dance/protocol
that uses it to call the loading module's DLLMain.

Add PAL_SetInitializeFlags; remove flags from PAL_INITIALIZE and PAL_INITIALIZE_DLL
default. Add PAL_InitializeWithFlags() to allowing the default to be overriden.</Title_Description>
    <Label>
    </Label>
    <Assignee>mikem8361</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19525</IssueLabelID>
    <Title>Enable Tiered Compilation by default</Title>
    <Description>1) Changes the default state of the tiered compilation feature check to be ON BY DEFAULT
2) Removed comments about the source about this being a work in progress. Although it will surely continue to evolve and improve remaining issues would be better tracked in our issue tracking system with the same default presumption as other runtime features - assume it works unless noted otherwise.
3) Adjusts a number of tests and automated scripts that made assumptions that the default setting of this feature is off.
4) Stop accepting the deprecated env var COMPLUS_EXPERIMENTAL_TieredCompilation. I'm not aware it has any remaining usage but if so we're going to find out.
5) Adjust config names for JitBench</Description>
    <Title_Description>Enable Tiered Compilation by default 1) Changes the default state of the tiered compilation feature check to be ON BY DEFAULT
2) Removed comments about the source about this being a work in progress. Although it will surely continue to evolve and improve remaining issues would be better tracked in our issue tracking system with the same default presumption as other runtime features - assume it works unless noted otherwise.
3) Adjusts a number of tests and automated scripts that made assumptions that the default setting of this feature is off.
4) Stop accepting the deprecated env var COMPLUS_EXPERIMENTAL_TieredCompilation. I'm not aware it has any remaining usage but if so we're going to find out.
5) Adjust config names for JitBench</Title_Description>
    <Label>area-VM</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19523</IssueLabelID>
    <Title>[WIP] Test with tiering</Title>
    <Description>
    </Description>
    <Title_Description>[WIP] Test with tiering </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19522</IssueLabelID>
    <Title>Codegen for `StoreVector128` followed by return is "poor"</Title>
    <Description>As per the comment here: https://github.com/dotnet/corefx/pull/31779/files#r210759586

The 

category:cq
theme:vector-codegen
skill-level:intermediate
cost:medium</Description>
    <Title_Description>Codegen for 

category:cq
theme:vector-codegen
skill-level:intermediate
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>fiigii</Assignee>
    <CreatedAt>16/08/2018 10:41:09 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19521</IssueLabelID>
    <Title>Codegen for `LoadVector128` for a field of a struct is "poor"</Title>
    <Description>As per the comment here: https://github.com/dotnet/corefx/pull/31779/files#r210758497

The </Description>
    <Title_Description>Codegen for </Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19519</IssueLabelID>
    <Title>Add a flag to enable/disable hw intrinsics</Title>
    <Description>This could potentially be a a  as the JIT relies on that flag for much of the code that supports the vector types.</Description>
    <Title_Description>Add a flag to enable/disable hw intrinsics This could potentially be a a  as the JIT relies on that flag for much of the code that supports the vector types.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
    <CreatedAt>16/08/2018 5:13:26 PM +00:00</CreatedAt>
    <ClosedAt>31/10/2018 3:46:41 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19517</IssueLabelID>
    <Title>C# Wpf Image Memory with High Resolution images(7680 X 2180) </Title>
    <Description>Problem:- WPF image holds memory. when I select an image from the directory and displayed to the image after click on destroy-image-button image is destroyed but memory is still on hold as per TaskManager and after done the same operation many times application will crash outof memory exception.. this issue is with High Resolution images(7680 X 2180)

An unhandled exception of type 'System.OutOfMemoryException' occurred in PresentationCore.dll

{The function evaluation was disabled because of an out of memory exception.}

Code &amp; Steps:-

I just simply select the image from the directory and displayed to the WPF image

    private void ImgDisplay_Click(object sender RoutedEventArgs e)
    {
        image.Source = new BitmapImage(new Uri(filePath));
    }

    private void ImgDistry_Click(object sender RoutedEventArgs e)
    {
        image.Source = null;
    }

    private void ImgSelect_Click(object sender RoutedEventArgs e)
    {
        OpenFileDialog openFileDialog1 = new OpenFileDialog();
        openFileDialog1.ShowDialog();
        filePath = openFileDialog1.FileName;
    }

&lt;Window x:Class="WpfApplication4.MainWindow"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" 
    Title="MainWindow" Background="Transparent" MaxHeight="1080" MaxWidth="1920"&gt;
&lt;Grid&gt;
    &lt;Grid.RowDefinitions&gt;
        &lt;RowDefinition Height="Auto"&gt;&lt;/RowDefinition&gt;
        &lt;RowDefinition Height="*"&gt;&lt;/RowDefinition&gt;
        &lt;RowDefinition Height="Auto"&gt;&lt;/RowDefinition&gt;
    &lt;/Grid.RowDefinitions&gt;
    &lt;Grid Margin="5"&gt;
        &lt;Grid.ColumnDefinitions&gt;
            &lt;ColumnDefinition Width="Auto"&gt;&lt;/ColumnDefinition&gt;
            &lt;ColumnDefinition Width="Auto"&gt;&lt;/ColumnDefinition&gt;
            &lt;ColumnDefinition Width="Auto"&gt;&lt;/ColumnDefinition&gt;
        &lt;/Grid.ColumnDefinitions&gt;
        &lt;Button Height="40" Width="120" Background="Green" Name="ImgDisplay" Foreground="White" Content="Display Image" Click="ImgDisplay_Click" /&gt;
        &lt;Button Margin="100100" Grid.Column="1" Height="40" Width="120" Name="ImgDistry" Content="Distroy Image" Background="Red" Foreground="White" Click="ImgDistry_Click" /&gt;
        &lt;Button Grid.Column="2" Height="40" Width="120" x:Name="ImgDistry_Copy" Content="Select Image" Background="Yellow" Foreground="Black" Click="ImgSelect_Click" /&gt;
    &lt;/Grid&gt;
    &lt;ScrollViewer Grid.Row="1"&gt;
        &lt;Image Name="image"/&gt;
    &lt;/ScrollViewer&gt;
&lt;/Grid&gt;
After select image from the directory

![6](https://user-images.githubusercontent.com/3060341/44206873-d6ff4080-a178-11e8-97b7-1f53f56c1007.png)
![7](https://user-images.githubusercontent.com/3060341/44206874-d6ff4080-a178-11e8-83af-cf1bb1d0f417.png)
![8](https://user-images.githubusercontent.com/3060341/44206875-d797d700-a178-11e8-899b-cafec48707df.png)


After doing 2-3 time same operation select image then destroy.. memory is increasing after each operation

Memory 
High Resolution images that i used you can download from here https://www.dropbox.com/s/fiodfaedwabtkgg/1.png?dl=0 https://www.dropbox.com/s/2bk0qm1clx4bgq1/2.png?dl=0 https://www.dropbox.com/s/6evtsqmqthu60mu/3.png?dl=0 https://www.dropbox.com/s/6p3o36wcires2jn/4.png?dl=0 https://www.dropbox.com/s/k5t1y9apcj4oee4/5.png?dl=0</Description>
    <Title_Description>C# Wpf Image Memory with High Resolution images(7680 X 2180)  Problem:- WPF image holds memory. when I select an image from the directory and displayed to the image after click on destroy-image-button image is destroyed but memory is still on hold as per TaskManager and after done the same operation many times application will crash outof memory exception.. this issue is with High Resolution images(7680 X 2180)

An unhandled exception of type 'System.OutOfMemoryException' occurred in PresentationCore.dll

{The function evaluation was disabled because of an out of memory exception.}

Code &amp; Steps:-

I just simply select the image from the directory and displayed to the WPF image

    private void ImgDisplay_Click(object sender RoutedEventArgs e)
    {
        image.Source = new BitmapImage(new Uri(filePath));
    }

    private void ImgDistry_Click(object sender RoutedEventArgs e)
    {
        image.Source = null;
    }

    private void ImgSelect_Click(object sender RoutedEventArgs e)
    {
        OpenFileDialog openFileDialog1 = new OpenFileDialog();
        openFileDialog1.ShowDialog();
        filePath = openFileDialog1.FileName;
    }

&lt;Window x:Class="WpfApplication4.MainWindow"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" 
    Title="MainWindow" Background="Transparent" MaxHeight="1080" MaxWidth="1920"&gt;
&lt;Grid&gt;
    &lt;Grid.RowDefinitions&gt;
        &lt;RowDefinition Height="Auto"&gt;&lt;/RowDefinition&gt;
        &lt;RowDefinition Height="*"&gt;&lt;/RowDefinition&gt;
        &lt;RowDefinition Height="Auto"&gt;&lt;/RowDefinition&gt;
    &lt;/Grid.RowDefinitions&gt;
    &lt;Grid Margin="5"&gt;
        &lt;Grid.ColumnDefinitions&gt;
            &lt;ColumnDefinition Width="Auto"&gt;&lt;/ColumnDefinition&gt;
            &lt;ColumnDefinition Width="Auto"&gt;&lt;/ColumnDefinition&gt;
            &lt;ColumnDefinition Width="Auto"&gt;&lt;/ColumnDefinition&gt;
        &lt;/Grid.ColumnDefinitions&gt;
        &lt;Button Height="40" Width="120" Background="Green" Name="ImgDisplay" Foreground="White" Content="Display Image" Click="ImgDisplay_Click" /&gt;
        &lt;Button Margin="100100" Grid.Column="1" Height="40" Width="120" Name="ImgDistry" Content="Distroy Image" Background="Red" Foreground="White" Click="ImgDistry_Click" /&gt;
        &lt;Button Grid.Column="2" Height="40" Width="120" x:Name="ImgDistry_Copy" Content="Select Image" Background="Yellow" Foreground="Black" Click="ImgSelect_Click" /&gt;
    &lt;/Grid&gt;
    &lt;ScrollViewer Grid.Row="1"&gt;
        &lt;Image Name="image"/&gt;
    &lt;/ScrollViewer&gt;
&lt;/Grid&gt;
After select image from the directory

![6](https://user-images.githubusercontent.com/3060341/44206873-d6ff4080-a178-11e8-97b7-1f53f56c1007.png)
![7](https://user-images.githubusercontent.com/3060341/44206874-d6ff4080-a178-11e8-83af-cf1bb1d0f417.png)
![8](https://user-images.githubusercontent.com/3060341/44206875-d797d700-a178-11e8-899b-cafec48707df.png)


After doing 2-3 time same operation select image then destroy.. memory is increasing after each operation

Memory 
High Resolution images that i used you can download from here https://www.dropbox.com/s/fiodfaedwabtkgg/1.png?dl=0 https://www.dropbox.com/s/2bk0qm1clx4bgq1/2.png?dl=0 https://www.dropbox.com/s/6evtsqmqthu60mu/3.png?dl=0 https://www.dropbox.com/s/6p3o36wcires2jn/4.png?dl=0 https://www.dropbox.com/s/k5t1y9apcj4oee4/5.png?dl=0</Title_Description>
    <Label>question</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>16/08/2018 11:52:02 AM +00:00</CreatedAt>
    <ClosedAt>17/08/2018 2:33:32 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19515</IssueLabelID>
    <Title>Test failure: baseservices_threading._waithandle_waitany_waitanyex2_waitanyex2_/_waithandle_waitany_waitanyex2_waitanyex2_cmd</Title>
    <Description>Opened on behalf of @Sunny-pu

The test  has failed.


    
    Return code:      1
    Raw output file:      C:\\dotnetbuild\\work\\524acbd1-5cfb-4adc-80ec-d2cfa306e357\\Work\\457012a7-5afe-4a4f-9d87-581100372ea8\\Unzip\\Reports\\baseservices.threading\\waithandle\\waitany\\waitanyex2\\waitanyex2.output.txt
    Raw output:
    BEGIN EXECUTION\r
            1 file(s) copied.\r
    \" C:\\dotnetbuild\\work\\524acbd1-5cfb-4adc-80ec-d2cfa306e357\\Payload\\crossgen.exe\" /Platform_Assemblies_Paths C:\\dotnetbuild\\work\\524acbd1-5cfb-4adc-80ec-d2cfa306e357\\Payload;C:\\dotnetbuild\\work\\524acbd1-5cfb-4adc-80ec-d2cfa306e357\\Work\\457012a7-5afe-4a4f-9d87-581100372ea8\\Unzip\\waithandle\\waitany\\waitanyex2\\IL;C:\\dotnetbuild\\work\\524acbd1-5cfb-4adc-80ec-d2cfa306e357\\Work\\457012a7-5afe-4a4f-9d87-581100372ea8\\Unzip\\waithandle\\waitany\\waitanyex2 /in waitanyex2.org /out waitanyex2.exe\r
    Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0\r
    Copyright (c) Microsoft Corporation.  All rights reserved.\r
    \r
    Native image waitanyex2.exe generated successfully.\r
     \"C:\\dotnetbuild\\work\\524acbd1-5cfb-4adc-80ec-d2cfa306e357\\Payload\\corerun.exe\" waitanyex2.exe \r
    Name created: 7e4acc81-1909-4e61-bdea-8c2706c913fd\r
    Testing Mutex and non-Mutex and signaling the other element\r
    Acquire the Mutex\r
    Holding the Mutex\r
    Waiting...\r
    WaitAny did not throw AbandonedMutexException. Result: 1\r
    Test Failed\r
    Expected: 100\r
    Actual: -1\r
    END EXECUTION - FAILED\r
    FAILED\r
    Test Harness Exitcode is : 1\r
    
    To run the test:
    &gt; set CORE_ROOT=C:\\dotnetbuild\\work\\524acbd1-5cfb-4adc-80ec-d2cfa306e357\\Payload
    &gt; C:\\dotnetbuild\\work\\524acbd1-5cfb-4adc-80ec-d2cfa306e357\\Work\\457012a7-5afe-4a4f-9d87-581100372ea8\\Unzip\\waithandle\\waitany\\waitanyex2\\waitanyex2.cmd
    \r
    Expected: True\r
    Actual:   False

        Stack Trace:

           at baseservices_threading._waithandle_waitany_waitanyex2_waitanyex2_._waithandle_waitany_waitanyex2_waitanyex2_cmd() in E:\A\_work\4\s\bin\tests\Windows_NT.arm.Release\TestWrappers\baseservices.threading\baseservices.threading.XUnitWrapper.cs:line 28809
Build : 3.0 - 20180816.01 (Ready-To-Run Tests)
Failing configurations:
- windows.10.arm64
  - arm

Details: https://mc.dot.net/#/product/netcore/30/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fr2r~2Fcli~2F/build/20180816.01/workItem/baseservices.threading.XUnitWrapper/analysis/xunit/baseservices_threading._waithandle_waitany_waitanyex2_waitanyex2_~2F_waithandle_waitany_waitanyex2_waitanyex2_cmd</Description>
    <Title_Description>Test failure: baseservices_threading._waithandle_waitany_waitanyex2_waitanyex2_/_waithandle_waitany_waitanyex2_waitanyex2_cmd Opened on behalf of @Sunny-pu

The test  has failed.


    
    Return code:      1
    Raw output file:      C:\\dotnetbuild\\work\\524acbd1-5cfb-4adc-80ec-d2cfa306e357\\Work\\457012a7-5afe-4a4f-9d87-581100372ea8\\Unzip\\Reports\\baseservices.threading\\waithandle\\waitany\\waitanyex2\\waitanyex2.output.txt
    Raw output:
    BEGIN EXECUTION\r
            1 file(s) copied.\r
    \" C:\\dotnetbuild\\work\\524acbd1-5cfb-4adc-80ec-d2cfa306e357\\Payload\\crossgen.exe\" /Platform_Assemblies_Paths C:\\dotnetbuild\\work\\524acbd1-5cfb-4adc-80ec-d2cfa306e357\\Payload;C:\\dotnetbuild\\work\\524acbd1-5cfb-4adc-80ec-d2cfa306e357\\Work\\457012a7-5afe-4a4f-9d87-581100372ea8\\Unzip\\waithandle\\waitany\\waitanyex2\\IL;C:\\dotnetbuild\\work\\524acbd1-5cfb-4adc-80ec-d2cfa306e357\\Work\\457012a7-5afe-4a4f-9d87-581100372ea8\\Unzip\\waithandle\\waitany\\waitanyex2 /in waitanyex2.org /out waitanyex2.exe\r
    Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0\r
    Copyright (c) Microsoft Corporation.  All rights reserved.\r
    \r
    Native image waitanyex2.exe generated successfully.\r
     \"C:\\dotnetbuild\\work\\524acbd1-5cfb-4adc-80ec-d2cfa306e357\\Payload\\corerun.exe\" waitanyex2.exe \r
    Name created: 7e4acc81-1909-4e61-bdea-8c2706c913fd\r
    Testing Mutex and non-Mutex and signaling the other element\r
    Acquire the Mutex\r
    Holding the Mutex\r
    Waiting...\r
    WaitAny did not throw AbandonedMutexException. Result: 1\r
    Test Failed\r
    Expected: 100\r
    Actual: -1\r
    END EXECUTION - FAILED\r
    FAILED\r
    Test Harness Exitcode is : 1\r
    
    To run the test:
    &gt; set CORE_ROOT=C:\\dotnetbuild\\work\\524acbd1-5cfb-4adc-80ec-d2cfa306e357\\Payload
    &gt; C:\\dotnetbuild\\work\\524acbd1-5cfb-4adc-80ec-d2cfa306e357\\Work\\457012a7-5afe-4a4f-9d87-581100372ea8\\Unzip\\waithandle\\waitany\\waitanyex2\\waitanyex2.cmd
    \r
    Expected: True\r
    Actual:   False

        Stack Trace:

           at baseservices_threading._waithandle_waitany_waitanyex2_waitanyex2_._waithandle_waitany_waitanyex2_waitanyex2_cmd() in E:\A\_work\4\s\bin\tests\Windows_NT.arm.Release\TestWrappers\baseservices.threading\baseservices.threading.XUnitWrapper.cs:line 28809
Build : 3.0 - 20180816.01 (Ready-To-Run Tests)
Failing configurations:
- windows.10.arm64
  - arm

Details: https://mc.dot.net/#/product/netcore/30/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fr2r~2Fcli~2F/build/20180816.01/workItem/baseservices.threading.XUnitWrapper/analysis/xunit/baseservices_threading._waithandle_waitany_waitanyex2_waitanyex2_~2F_waithandle_waitany_waitanyex2_waitanyex2_cmd</Title_Description>
    <Label>area-System.Threading</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>16/08/2018 3:46:06 AM +00:00</CreatedAt>
    <ClosedAt>26/07/2019 1:05:00 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19509</IssueLabelID>
    <Title>[WIP] Test with tiering enabled</Title>
    <Description>
    </Description>
    <Title_Description>[WIP] Test with tiering enabled </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19508</IssueLabelID>
    <Title>Make file handle checks accurate on Windows</Title>
    <Description>We can actually check the async state of a handle on Windows so check directly when we have the API available. It is faster and more reliable as the state is literally a flag on the handle.

Also allow all filetypes through when explicitly using extended syntax  . This unblocks a number of advanced customer scenarios.

Fixes https://github.com/dotnet/corefx/issues/187.
</Description>
    <Title_Description>Make file handle checks accurate on Windows We can actually check the async state of a handle on Windows so check directly when we have the API available. It is faster and more reliable as the state is literally a flag on the handle.

Also allow all filetypes through when explicitly using extended syntax  . This unblocks a number of advanced customer scenarios.

Fixes https://github.com/dotnet/corefx/issues/187.
</Title_Description>
    <Label>area-System.IO</Label>
    <Assignee>JeremyKuhne</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19507</IssueLabelID>
    <Title>Add Public API Marshal.IsTypeVisibleFromCom and Marshal.GetEndComSlot</Title>
    <Description>Fix https://github.com/dotnet/corefx/issues/30393 and https://github.com/dotnet/corefx/issues/30849

There is another corefx PR</Description>
    <Title_Description>Add Public API Marshal.IsTypeVisibleFromCom and Marshal.GetEndComSlot Fix https://github.com/dotnet/corefx/issues/30393 and https://github.com/dotnet/corefx/issues/30849

There is another corefx PR</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>luqunl</Assignee>
    <CreatedAt>15/08/2018 8:48:49 PM +00:00</CreatedAt>
    <ClosedAt>15/08/2018 10:52:29 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19505</IssueLabelID>
    <Title>Revert "Temporarily flag a SIMD test as optimization-sensitive (#19163)"</Title>
    <Description>This reverts commit 855ddf52c7b05994cf6728b9169fa6cdc694a537 (PR https://github.com/dotnet/coreclr/pull/19163). Issue https://github.com/dotnet/coreclr/issues/19124 was fixed by PR https://github.com/dotnet/coreclr/pull/19234 so re-enabling the test in minopts and with tiering.</Description>
    <Title_Description>Revert "Temporarily flag a SIMD test as optimization-sensitive (#19163)" This reverts commit 855ddf52c7b05994cf6728b9169fa6cdc694a537 (PR https://github.com/dotnet/coreclr/pull/19163). Issue https://github.com/dotnet/coreclr/issues/19124 was fixed by PR https://github.com/dotnet/coreclr/pull/19234 so re-enabling the test in minopts and with tiering.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19503</IssueLabelID>
    <Title>[automated] Merge branch 'release/2.1' =&gt; 'release/2.2'</Title>
    <Description>I detected changes in the release/2.1 branch which have not been merged yet to release/2.2.
I'm a robot and am configured to help you automatically keep release/2.2 up to date so
I've opened this PR.

This PR merges commits made on release/2.1 by the following committers:

* @wtgodbe
* @dotnet-maestro-bot
* @mmitche

## Instructions for merging

This PR will not be auto-merged. When pull request checks pass please complete this PR
by creating a merge commit *not* a squash or rebase commit.

&lt;img alt="merge button instructions" src="https://i.imgur.com/GepcNJV.png" width="300" /&gt;

You can also do this on command line:


## Instructions for resolving conflicts

:warning: If there are merge conflicts you will need to resolve them manually before merging.
You can do this [using GitHub](https://help.github.com/articles/resolving-a-merge-conflict-on-github/)
or using the [command line](https://help.github.com/articles/resolving-a-merge-conflict-using-the-command-line/).

Maintainers of this repo have permission to the branch 'merge/release/2.1-to-release/2.2' on https://github.com/dotnet-maestro-bot/coreclr.
You can push changes to this branch to resolve conflicts or other issues in this pull request. The bot will attempt
to update this branch as more changes are discovered on release/2.1.

Please contact ASP.NET Core Engineering if you have questions or issues.
Also if this PR was generated incorrectly help us fix it. See https://github.com/aspnet/BuildTools/blob/master/scripts/GitHubMergeBranches.ps1.</Description>
    <Title_Description>[automated] Merge branch 'release/2.1' =&gt; 'release/2.2' I detected changes in the release/2.1 branch which have not been merged yet to release/2.2.
I'm a robot and am configured to help you automatically keep release/2.2 up to date so
I've opened this PR.

This PR merges commits made on release/2.1 by the following committers:

* @wtgodbe
* @dotnet-maestro-bot
* @mmitche

## Instructions for merging

This PR will not be auto-merged. When pull request checks pass please complete this PR
by creating a merge commit *not* a squash or rebase commit.

&lt;img alt="merge button instructions" src="https://i.imgur.com/GepcNJV.png" width="300" /&gt;

You can also do this on command line:


## Instructions for resolving conflicts

:warning: If there are merge conflicts you will need to resolve them manually before merging.
You can do this [using GitHub](https://help.github.com/articles/resolving-a-merge-conflict-on-github/)
or using the [command line](https://help.github.com/articles/resolving-a-merge-conflict-using-the-command-line/).

Maintainers of this repo have permission to the branch 'merge/release/2.1-to-release/2.2' on https://github.com/dotnet-maestro-bot/coreclr.
You can push changes to this branch to resolve conflicts or other issues in this pull request. The bot will attempt
to update this branch as more changes are discovered on release/2.1.

Please contact ASP.NET Core Engineering if you have questions or issues.
Also if this PR was generated incorrectly help us fix it. See https://github.com/aspnet/BuildTools/blob/master/scripts/GitHubMergeBranches.ps1.</Title_Description>
    <Label>
    </Label>
    <Assignee>wtgodbe</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19502</IssueLabelID>
    <Title>Switch CoreLib to R2R on all platforms</Title>
    <Description>
    </Description>
    <Title_Description>Switch CoreLib to R2R on all platforms </Title_Description>
    <Label>area-ReadyToRun</Label>
    <Assignee>fadimounir</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19500</IssueLabelID>
    <Title>Remove NumaNodeInfo CPUGroupInfo AppDomain SystemDomain and EEConfig stubs from local gc</Title>
    <Description>Everything except EEConfig is moved to the interface. EEConfig is only used for STRESS_HEAP which is disabled for local gc so my plan is to delete EEConfig for now and fix it at the same time as STRESS_HEAP.</Description>
    <Title_Description>Remove NumaNodeInfo, CPUGroupInfo, AppDomain, SystemDomain, and EEConfig stubs from local gc Everything except EEConfig is moved to the interface. EEConfig is only used for STRESS_HEAP which is disabled for local gc so my plan is to delete EEConfig for now and fix it at the same time as STRESS_HEAP.</Title_Description>
    <Label>area-GC</Label>
    <Assignee>davmason</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19499</IssueLabelID>
    <Title>Consider reordering the instrsxarch.h encodings to save space</Title>
    <Description>The  a large number of INST3 encodings were added and often only one or two of the encodings are used.

It may be beneficial to consider reordering these encodings in order to save additional space. Looking briefly at the encodings I see the following:

encoding | # entries | # bad_code
-- | -- | --
R/M[reg] | 527 | 366
R/Micon | 444 | 390
regR/M | 421 | 56
eaxi32 | 21 | 10
register | 9 | 1


category:implementation
theme:emitter
skill-level:beginner
cost:medium</Description>
    <Title_Description>Consider reordering the instrsxarch.h encodings to save space The  a large number of INST3 encodings were added and often only one or two of the encodings are used.

It may be beneficial to consider reordering these encodings in order to save additional space. Looking briefly at the encodings I see the following:

encoding | # entries | # bad_code
-- | -- | --
R/M[reg] | 527 | 366
R/Micon | 444 | 390
regR/M | 421 | 56
eaxi32 | 21 | 10
register | 9 | 1


category:implementation
theme:emitter
skill-level:beginner
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
    <CreatedAt>15/08/2018 2:23:31 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19498</IssueLabelID>
    <Title>Refactor instrsxarch.h to contain a `flags` field</Title>
    <Description>Currently the </Description>
    <Title_Description>Refactor instrsxarch.h to contain a </Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
    <CreatedAt>15/08/2018 1:56:51 AM +00:00</CreatedAt>
    <ClosedAt>28/08/2018 2:53:54 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19495</IssueLabelID>
    <Title>Update debugging and createdump docs</Title>
    <Description>
    </Description>
    <Title_Description>Update debugging and createdump docs </Title_Description>
    <Label>
    </Label>
    <Assignee>mikem8361</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19492</IssueLabelID>
    <Title>Unsafe.Unbox is not available inside mscorlib</Title>
    <Description>I am wondering why  instead of unboxing and wondering if it makes sense or not e.g. https://github.com/dotnet/coreclr/blob/master/src/System.Private.CoreLib/shared/System/Guid.cs#L1048
![image](https://user-images.githubusercontent.com/523221/44123805-a870ef4e-a032-11e8-93a7-47f98ef7dd89.png)

</Description>
    <Title_Description>Unsafe.Unbox is not available inside mscorlib I am wondering why  instead of unboxing and wondering if it makes sense or not e.g. https://github.com/dotnet/coreclr/blob/master/src/System.Private.CoreLib/shared/System/Guid.cs#L1048
![image](https://user-images.githubusercontent.com/523221/44123805-a870ef4e-a032-11e8-93a7-47f98ef7dd89.png)

</Title_Description>
    <Label>area-Meta</Label>
    <Assignee>benaadams</Assignee>
    <CreatedAt>14/08/2018 10:02:32 PM +00:00</CreatedAt>
    <ClosedAt>15/08/2018 1:37:15 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19490</IssueLabelID>
    <Title>Add an empty console application to measure startup of the runtime.</Title>
    <Description>
    </Description>
    <Title_Description>Add an empty console application to measure startup of the runtime. </Title_Description>
    <Label>tenet-performance-benchmarks</Label>
    <Assignee>jorive</Assignee>
    <CreatedAt>14/08/2018 9:01:44 PM +00:00</CreatedAt>
    <ClosedAt>16/08/2018 6:25:32 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19488</IssueLabelID>
    <Title>Disable a regex test that is failing with minopts</Title>
    <Description>See dotnet/coreclr#18912. This test would always fail once tiered compilation is enabled by default in CoreFX test runs in the CoreCLR repo.</Description>
    <Title_Description>Disable a regex test that is failing with minopts See dotnet/coreclr#18912. This test would always fail once tiered compilation is enabled by default in CoreFX test runs in the CoreCLR repo.</Title_Description>
    <Label>disabled-test</Label>
    <Assignee>kouvel</Assignee>
    <CreatedAt>14/08/2018 8:25:33 PM +00:00</CreatedAt>
    <ClosedAt>16/08/2018 6:23:48 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19483</IssueLabelID>
    <Title>Disable constant folding in JIT resulting in NaN infinities etc</Title>
    <Description>As it was discussed and agreed in #19395 JIT should not statically evaluate expressions resulting in NaNs infinities or any cases left implementation-defined by IEEE754. 

category:correctness
theme:optimization
skill-level:beginner
cost:small</Description>
    <Title_Description>Disable constant folding in JIT resulting in NaN, infinities etc As it was discussed and agreed in #19395 JIT should not statically evaluate expressions resulting in NaNs infinities or any cases left implementation-defined by IEEE754. 

category:correctness
theme:optimization
skill-level:beginner
cost:small</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>echesakovMSFT</Assignee>
    <CreatedAt>14/08/2018 6:04:06 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19481</IssueLabelID>
    <Title>Build CoreCLR on FreeBSD11</Title>
    <Description>Hi
I am trying to use the instructions for FreeBSD to build CoreCLR on FreeBSD11 with llvm3.8
During Build the runtime step (build.sh) I got this error:


![image](https://user-images.githubusercontent.com/24319588/44094619-f82549e2-9fd6-11e8-88ec-e5e6f40395a9.png)
</Description>
    <Title_Description>Build CoreCLR on FreeBSD11 Hi
I am trying to use the instructions for FreeBSD to build CoreCLR on FreeBSD11 with llvm3.8
During Build the runtime step (build.sh) I got this error:


![image](https://user-images.githubusercontent.com/24319588/44094619-f82549e2-9fd6-11e8-88ec-e5e6f40395a9.png)
</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>14/08/2018 1:26:41 PM +00:00</CreatedAt>
    <ClosedAt>1/12/2018 1:18:39 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19480</IssueLabelID>
    <Title>Chinese Lunisolar Calendar conversion table discrepancy for the years 2057 2089 and 2097</Title>
    <Description>The [Chinese Lunisolar Calendar](https://github.com/dotnet/coreclr/blob/master/src/System.Private.CoreLib/shared/System/Globalization/ChineseLunisolarCalendar.cs) uses a table of data for conversion between Chinese lunisolar dates and Gregorian dates. There appears to be a discrepancy for the table entry for the _days in months_ for the lunar years which started in the Gregorian years 2057 2089 and 2097 when compared with other sources. These are:

- output from Calendrical Calculations (4th edition section 19) which implements the Chinese lunisolar calendar rules used by the [Purple Mountain Observatory](http://english.pmo.cas.cn/) as also detailed [here](http://aa.usno.navy.mil/publications/docs/c15_usb_online.pdf)
- footnote on [tables](http://www.hko.gov.hk/gts/time/conversion.htm) published by the Hong Kong Observatory which state their tables are out by one day for the new moons on 28 September 2057 4 September 2089 and 7 August 2097 (which matches exactly with the same discrepancy between the .NET tables and output from Calendrical Calculations)

Year | Days in month | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13
-- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | --
2057 | .NET | 29 | 30 | 30 | 29 | 30 | 29 | 30 | **30** | **29** | 29 | 30 | 29 | 0
2057 | CC    | 29 | 30 | 30 | 29 | 30 | 29 | 30 | **29** | **30** | 29 | 30 | 29 | 0
2089 | .NET | 30 | 30 | 29 | 30 | 29 | 29 | **30** | **29** | 29 | 30 | 30 | 29 | 0
2089 | CC    | 30 | 30 | 29 | 30 | 29 | 29 | **29** | **30** | 29 | 30 | 30 | 29 | 0
2097 | .NET | 30 | 29 | 30 | 29 | 29 | **30** | **29** | 29 | 30 | 30 | 29 | 30 | 0
2097 | CC    | 30 | 29 | 30 | 29 | 29 | **29** | **30** | 29 | 30 | 30 | 29 | 30 | 0

Existing table entries:



</Description>
    <Title_Description>Chinese Lunisolar Calendar conversion table discrepancy for the years 2057, 2089, and 2097 The [Chinese Lunisolar Calendar](https://github.com/dotnet/coreclr/blob/master/src/System.Private.CoreLib/shared/System/Globalization/ChineseLunisolarCalendar.cs) uses a table of data for conversion between Chinese lunisolar dates and Gregorian dates. There appears to be a discrepancy for the table entry for the _days in months_ for the lunar years which started in the Gregorian years 2057 2089 and 2097 when compared with other sources. These are:

- output from Calendrical Calculations (4th edition section 19) which implements the Chinese lunisolar calendar rules used by the [Purple Mountain Observatory](http://english.pmo.cas.cn/) as also detailed [here](http://aa.usno.navy.mil/publications/docs/c15_usb_online.pdf)
- footnote on [tables](http://www.hko.gov.hk/gts/time/conversion.htm) published by the Hong Kong Observatory which state their tables are out by one day for the new moons on 28 September 2057 4 September 2089 and 7 August 2097 (which matches exactly with the same discrepancy between the .NET tables and output from Calendrical Calculations)

Year | Days in month | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13
-- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | --
2057 | .NET | 29 | 30 | 30 | 29 | 30 | 29 | 30 | **30** | **29** | 29 | 30 | 29 | 0
2057 | CC    | 29 | 30 | 30 | 29 | 30 | 29 | 30 | **29** | **30** | 29 | 30 | 29 | 0
2089 | .NET | 30 | 30 | 29 | 30 | 29 | 29 | **30** | **29** | 29 | 30 | 30 | 29 | 0
2089 | CC    | 30 | 30 | 29 | 30 | 29 | 29 | **29** | **30** | 29 | 30 | 30 | 29 | 0
2097 | .NET | 30 | 29 | 30 | 29 | 29 | **30** | **29** | 29 | 30 | 30 | 29 | 30 | 0
2097 | CC    | 30 | 29 | 30 | 29 | 29 | **29** | **30** | 29 | 30 | 30 | 29 | 30 | 0

Existing table entries:



</Title_Description>
    <Label>area-System.Globalization</Label>
    <Assignee>elyoh</Assignee>
    <CreatedAt>14/08/2018 9:19:35 AM +00:00</CreatedAt>
    <ClosedAt>13/09/2018 9:58:28 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19479</IssueLabelID>
    <Title>Some JitBench fixes</Title>
    <Description>- Fixed  config</Description>
    <Title_Description>Some JitBench fixes - Fixed  config</Title_Description>
    <Label>area-Meta</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19478</IssueLabelID>
    <Title> [Test Failure] ApartmentState_NoAttributePresent_STA_Windows_Core</Title>
    <Description>From the new binary test run
</Description>
    <Title_Description> [Test Failure] ApartmentState_NoAttributePresent_STA_Windows_Core From the new binary test run
</Title_Description>
    <Label>arch-x64</Label>
    <Assignee>A-And</Assignee>
    <CreatedAt>14/08/2018 3:42:21 AM +00:00</CreatedAt>
    <ClosedAt>14/08/2018 4:19:27 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19476</IssueLabelID>
    <Title>Code review feedback for the alternate stack changes (PR #19309).</Title>
    <Description>Renamed PAL_InitializeFlags to PAL_InitializeWithFlags. Combined PAL_INITIALIZE_ENSURE_ALT_SIGNAL_STACK and PAL_INITIALIZE_REGISTER_SIGNALS flags.

Also fixed SOS plugin for core dumps.</Description>
    <Title_Description>Code review feedback for the alternate stack changes (PR #19309). Renamed PAL_InitializeFlags to PAL_InitializeWithFlags. Combined PAL_INITIALIZE_ENSURE_ALT_SIGNAL_STACK and PAL_INITIALIZE_REGISTER_SIGNALS flags.

Also fixed SOS plugin for core dumps.</Title_Description>
    <Label>
    </Label>
    <Assignee>mikem8361</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19474</IssueLabelID>
    <Title>Unexpected results returning struct with floats in RCW</Title>
    <Description>In trying to wrap [ that exercises it. One can also look at this by tweaking the Direct2dDemo project (i.e. call the method) which runs on .NET Core and sets up a render target that you can use.

As stated I'll try and get a smaller COM repro together for this.

</Description>
    <Title_Description>Unexpected results returning struct with floats in RCW In trying to wrap [ that exercises it. One can also look at this by tweaking the Direct2dDemo project (i.e. call the method) which runs on .NET Core and sets up a render target that you can use.

As stated I'll try and get a smaller COM repro together for this.

</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>davidwrighton</Assignee>
    <CreatedAt>14/08/2018 12:27:01 AM +00:00</CreatedAt>
    <ClosedAt>29/03/2019 4:49:56 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19467</IssueLabelID>
    <Title>Use 64bit Upper/Lower casing in TextInfo</Title>
    <Description>Tracking issue for https://github.com/dotnet/coreclr/pull/19436#discussion_r209666239</Description>
    <Title_Description>Use 64bit Upper/Lower casing in TextInfo Tracking issue for https://github.com/dotnet/coreclr/pull/19436#discussion_r209666239</Title_Description>
    <Label>area-System.Runtime</Label>
    <Assignee>vancem</Assignee>
    <CreatedAt>13/08/2018 10:12:35 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19465</IssueLabelID>
    <Title>disable tests\src\JIT\Methodical\fp\exgen\10w5d_cs_do</Title>
    <Description>in stress modes. The issue is #18988</Description>
    <Title_Description>disable tests\src\JIT\Methodical\fp\exgen\10w5d_cs_do in stress modes. The issue is #18988</Title_Description>
    <Label>disabled-test</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>13/08/2018 10:00:33 PM +00:00</CreatedAt>
    <ClosedAt>13/08/2018 11:16:50 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19464</IssueLabelID>
    <Title>[Windows/arm64] GCStress=c assert: Consistency check failed</Title>
    <Description>Windows arm64 GCStress=c failure in b163200

In the CI I only saw it with JitStress=1 (https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm64/job/jitstress/job/arm64_cross_checked_windows_nt_gcstress0xc_jitstress1_tst/32/) because of other failures and the CI deleting logs quickly. But I can repro with just GCStress=c locally.

I had to set 
</Description>
    <Title_Description>[Windows/arm64] GCStress=c assert: Consistency check failed Windows arm64 GCStress=c failure in b163200

In the CI I only saw it with JitStress=1 (https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm64/job/jitstress/job/arm64_cross_checked_windows_nt_gcstress0xc_jitstress1_tst/32/) because of other failures and the CI deleting logs quickly. But I can repro with just GCStress=c locally.

I had to set 
</Title_Description>
    <Label>GCStress</Label>
    <Assignee>AndyAyersMS</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19462</IssueLabelID>
    <Title>[Windows/arm32] Failures in HeapVerify job</Title>
    <Description>https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_heapverify1_flow/



Failures are all timeouts (&gt;600s)
</Description>
    <Title_Description>[Windows/arm32] Failures in HeapVerify job https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_heapverify1_flow/



Failures are all timeouts (&gt;600s)
</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>13/08/2018 9:05:44 PM +00:00</CreatedAt>
    <ClosedAt>13/08/2018 11:53:23 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19460</IssueLabelID>
    <Title>[Windows/arm32] corefx TieredCompilation failure in System.Threading.Threads.Tests</Title>
    <Description>https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_corefx_tieredcompilation_flow/



@kouvel @noahfalk </Description>
    <Title_Description>[Windows/arm32] corefx TieredCompilation failure in System.Threading.Threads.Tests https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_corefx_tieredcompilation_flow/



@kouvel @noahfalk </Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>13/08/2018 8:02:35 PM +00:00</CreatedAt>
    <ClosedAt>13/08/2018 8:15:43 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19457</IssueLabelID>
    <Title>[Windows/arm32] corefx System.Linq.Expressions.Tests failures</Title>
    <Description>https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_corefx_jitstress1_tst/30/consoleFull


</Description>
    <Title_Description>[Windows/arm32] corefx System.Linq.Expressions.Tests failures https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_corefx_jitstress1_tst/30/consoleFull


</Title_Description>
    <Label>JitStress</Label>
    <Assignee>sandreenko</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19455</IssueLabelID>
    <Title>[dev/unix_test_workflow][NO MERGE] Dummy change</Title>
    <Description>
    </Description>
    <Title_Description>[dev/unix_test_workflow][NO MERGE] Dummy change </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>echesakovMSFT</Assignee>
    <CreatedAt>13/08/2018 6:26:08 PM +00:00</CreatedAt>
    <ClosedAt>17/08/2018 4:58:17 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19454</IssueLabelID>
    <Title>System.AccessViolationException with Span</Title>
    <Description>Following code crashes with System.AccessViolationException when compiled in Release mode with "Optimize code". I tried that on Windows 64bit with .NET Core 2.1.302. Older version of .NET Core and Debug does not cause this exception.

Note that this code alone does not make any sense. It was isolated from larger code base. It might be an issue with JIT since the code in for cycle does not even execute it is called with 0.
</Description>
    <Title_Description>System.AccessViolationException with Span Following code crashes with System.AccessViolationException when compiled in Release mode with "Optimize code". I tried that on Windows 64bit with .NET Core 2.1.302. Older version of .NET Core and Debug does not cause this exception.

Note that this code alone does not make any sense. It was isolated from larger code base. It might be an issue with JIT since the code in for cycle does not even execute it is called with 0.
</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19453</IssueLabelID>
    <Title>[NO MERGE] Dummy PR</Title>
    <Description>**NO MERGE** **NO MERGE** **NO MERGE** </Description>
    <Title_Description>[NO MERGE] Dummy PR **NO MERGE** **NO MERGE** **NO MERGE** </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>echesakovMSFT</Assignee>
    <CreatedAt>13/08/2018 6:22:03 PM +00:00</CreatedAt>
    <ClosedAt>13/08/2018 8:49:57 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19451</IssueLabelID>
    <Title>[release/2.1] Sign api-ms-win-core-xstate-l2-1-0.dll</Title>
    <Description>This file is only catalog signed in RS4.  Sign during the build. To achieve this copy the CRT binaries locally rather than referencing from the UCRT location directly.</Description>
    <Title_Description>[release/2.1] Sign api-ms-win-core-xstate-l2-1-0.dll This file is only catalog signed in RS4.  Sign during the build. To achieve this copy the CRT binaries locally rather than referencing from the UCRT location directly.</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>mmitche</Assignee>
    <CreatedAt>13/08/2018 6:19:16 PM +00:00</CreatedAt>
    <ClosedAt>13/08/2018 8:58:43 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19450</IssueLabelID>
    <Title>Japanese Lunisolar Calendar conversion table discrepancy for the year 1962</Title>
    <Description>The [Japanese Lunisolar Calendar](https://github.com/dotnet/coreclr/blob/master/src/System.Private.CoreLib/shared/System/Globalization/JapaneseLunisolarCalendar.cs) uses a table of data for conversion between Japanese lunisolar dates and Gregorian dates.  There appears* to be a discrepancy for the table entry for the _days in months_ for lunar months 6 and 7 of the lunar year which started in the Gregorian year 1962 when compared with two other sources.  These are:
- output from Calendrical Calculations (4th edition section 19.9) which provides algorithms for accurate dates for the period 1860 to at least 2100
- [Rekijitsu taikan : Meiji kaireki 1873-nen--2100-nen shinkyūreki kanshi kyūsei rokuyō taishō](http://www.worldcat.org/title/rekijitsu-taikan/oclc/675252389?referer=di&amp;ht=edition ()) which provides accurate tables of dates in this calendar over the period years 1873 to 2100 (with the exception of 1947)

*there isn't a source given for the existing table data - is it still known / available for cross check?

**Comparison of table data**

Days in month for 1962  | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13
-- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | --
.NET | 29 | 30 | 29 | 29 | 30 | **30** | **29** | 30 | 29 | 30 | 30 | 29 | 0
Calendrical Calculations / Rekijitsu taikan | 29 | 30 | 29 | 29 | 30 | **29** | **30** | 30 | 29 | 30 | 30 | 29 | 0

Assuming the output of Calendrical Calculations algorithms is correct then the current table entry for 1962:


At the same time it would also be a _trivial_ matter to extend the table to support dates for all the Japanese calendar eras currently supported by .NET (Meiji Taisho Showa and Heisei).  Given the recent updates to the Japanese and Japanese Lunisolar calendars relating to the new Japanese calendar era this might be an appropriate time to do that.

I would be happy to submit PR to address these.

</Description>
    <Title_Description>Japanese Lunisolar Calendar conversion table discrepancy for the year 1962 The [Japanese Lunisolar Calendar](https://github.com/dotnet/coreclr/blob/master/src/System.Private.CoreLib/shared/System/Globalization/JapaneseLunisolarCalendar.cs) uses a table of data for conversion between Japanese lunisolar dates and Gregorian dates.  There appears* to be a discrepancy for the table entry for the _days in months_ for lunar months 6 and 7 of the lunar year which started in the Gregorian year 1962 when compared with two other sources.  These are:
- output from Calendrical Calculations (4th edition section 19.9) which provides algorithms for accurate dates for the period 1860 to at least 2100
- [Rekijitsu taikan : Meiji kaireki 1873-nen--2100-nen shinkyūreki kanshi kyūsei rokuyō taishō](http://www.worldcat.org/title/rekijitsu-taikan/oclc/675252389?referer=di&amp;ht=edition ()) which provides accurate tables of dates in this calendar over the period years 1873 to 2100 (with the exception of 1947)

*there isn't a source given for the existing table data - is it still known / available for cross check?

**Comparison of table data**

Days in month for 1962  | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13
-- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | --
.NET | 29 | 30 | 29 | 29 | 30 | **30** | **29** | 30 | 29 | 30 | 30 | 29 | 0
Calendrical Calculations / Rekijitsu taikan | 29 | 30 | 29 | 29 | 30 | **29** | **30** | 30 | 29 | 30 | 30 | 29 | 0

Assuming the output of Calendrical Calculations algorithms is correct then the current table entry for 1962:


At the same time it would also be a _trivial_ matter to extend the table to support dates for all the Japanese calendar eras currently supported by .NET (Meiji Taisho Showa and Heisei).  Given the recent updates to the Japanese and Japanese Lunisolar calendars relating to the new Japanese calendar era this might be an appropriate time to do that.

I would be happy to submit PR to address these.

</Title_Description>
    <Label>area-System.Globalization</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>13/08/2018 5:47:23 PM +00:00</CreatedAt>
    <ClosedAt>16/08/2018 1:28:14 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19448</IssueLabelID>
    <Title>[Ubuntu/arm32] JitStressRegs=8 CoreFX test failures</Title>
    <Description>https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstressregs8_tst/17/consoleFull

Many or every test fails with:


Related to https://github.com/dotnet/coreclr/issues/19029?

Even if fixed the job will probably fail with https://github.com/dotnet/coreclr/issues/19447.

@dotnet/arm32-contrib @CarolEidt </Description>
    <Title_Description>[Ubuntu/arm32] JitStressRegs=8 CoreFX test failures https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstressregs8_tst/17/consoleFull

Many or every test fails with:


Related to https://github.com/dotnet/coreclr/issues/19029?

Even if fixed the job will probably fail with https://github.com/dotnet/coreclr/issues/19447.

@dotnet/arm32-contrib @CarolEidt </Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19447</IssueLabelID>
    <Title>Ubuntu/arm32 corefx test infrastructure failures: "The plugin hasn't been performed correctly"</Title>
    <Description>All the Ubuntu/arm32 corefx tests are failing -- after all the tests actually pass -- with an infrastructure failure message e.g.:

https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_baseline_tst/17/consoleFull



Others:

https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstress1_tst/22/consoleFull
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstress2_tst/22/consoleFull
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstressregs0x1000_tst/19/consoleFull
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_tst/20/consoleFull
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstressregs0x80_tst/20/consoleFull
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstressregs1_tst/19/consoleFull
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstressregs2_tst/18/consoleFull
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstressregs3_tst/19/consoleFull
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstressregs4_tst/18/consoleFull
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_minopts_tst/21/consoleFull
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_tieredcompilation_tst/7/consoleFull

@dotnet/arm32-contrib @jashook @mmitche </Description>
    <Title_Description>Ubuntu/arm32 corefx test infrastructure failures: "The plugin hasn't been performed correctly" All the Ubuntu/arm32 corefx tests are failing -- after all the tests actually pass -- with an infrastructure failure message e.g.:

https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_baseline_tst/17/consoleFull



Others:

https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstress1_tst/22/consoleFull
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstress2_tst/22/consoleFull
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstressregs0x1000_tst/19/consoleFull
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_tst/20/consoleFull
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstressregs0x80_tst/20/consoleFull
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstressregs1_tst/19/consoleFull
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstressregs2_tst/18/consoleFull
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstressregs3_tst/19/consoleFull
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstressregs4_tst/18/consoleFull
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_minopts_tst/21/consoleFull
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_tieredcompilation_tst/7/consoleFull

@dotnet/arm32-contrib @jashook @mmitche </Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>13/08/2018 4:36:00 PM +00:00</CreatedAt>
    <ClosedAt>17/08/2018 10:22:19 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19444</IssueLabelID>
    <Title>RyuJIT: By-ref assignment with null leads to runtime crash</Title>
    <Description>The following example crashes the runtime when compiled and run in either debug or release:
?</Description>
    <Title_Description>RyuJIT: By-ref assignment with null leads to runtime crash The following example crashes the runtime when compiled and run in either debug or release:
?</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19441</IssueLabelID>
    <Title>R2RDumpTest debug failure</Title>
    <Description>This test appears to have started failing in Debug runs with https://github.com/dotnet/coreclr/pull/19419

https://ci.dot.net/job/dotnet_coreclr/job/master/view/x86/job/x86_debug_windows_nt/5075/
https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64/job/debug_windows_nt/5358/

@nattress @acmyu </Description>
    <Title_Description>R2RDumpTest debug failure This test appears to have started failing in Debug runs with https://github.com/dotnet/coreclr/pull/19419

https://ci.dot.net/job/dotnet_coreclr/job/master/view/x86/job/x86_debug_windows_nt/5075/
https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64/job/debug_windows_nt/5358/

@nattress @acmyu </Title_Description>
    <Label>area-ReadyToRun</Label>
    <Assignee>acmyu</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19440</IssueLabelID>
    <Title>Assert failure: obj != NULL</Title>
    <Description>x86 Checked Windows GCStress=c

https://ci.dot.net/job/dotnet_coreclr/job/master/view/x86/job/jitstress/job/x86_checked_windows_nt_gcstress0xc/96/consoleText



</Description>
    <Title_Description>Assert failure: obj != NULL x86 Checked Windows GCStress=c

https://ci.dot.net/job/dotnet_coreclr/job/master/view/x86/job/jitstress/job/x86_checked_windows_nt_gcstress0xc/96/consoleText



</Title_Description>
    <Label>GCStress</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>12/08/2018 4:09:36 PM +00:00</CreatedAt>
    <ClosedAt>14/06/2019 8:30:36 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19439</IssueLabelID>
    <Title>Assertion failed 'varDsc-&gt;lvRefCnt() == 0 &amp;&amp; !varDsc-&gt;lvRegister &amp;&amp; !varDsc-&gt;lvOnFrame'</Title>
    <Description>From x86 Checked Windows R2R with JITMinOpts=1

https://ci.dot.net/job/dotnet_coreclr/job/master/view/x86/job/jitstress/job/x86_checked_windows_nt_r2r_jitminopts/135/consoleFull


</Description>
    <Title_Description>Assertion failed 'varDsc-&gt;lvRefCnt() == 0 &amp;&amp; !varDsc-&gt;lvRegister &amp;&amp; !varDsc-&gt;lvOnFrame' From x86 Checked Windows R2R with JITMinOpts=1

https://ci.dot.net/job/dotnet_coreclr/job/master/view/x86/job/jitstress/job/x86_checked_windows_nt_r2r_jitminopts/135/consoleFull


</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19438</IssueLabelID>
    <Title>Regression: Wrapped System.Numerics types are not generating SIMD code</Title>
    <Description>Greetings

I'm running Visual Studio 2017 v15.7.6 with .Net Core 2.1.400-preview-009171. I've noticed that SIMD types from System.Numerics that are wrapped within structs are not generating optimal code. I've tried running from vanilla JIT as well as AOT (both RyuJIT and CPP CodeGen) to no avail.

I've attached a simple project that demonstrates this along with the disassembly.

Furthermore it appears that this might be a regression given it seems to have been resolved in https://github.com/dotnet/coreclr/issues/7508 for a prior version.

It would be awesome if this issue can be addressed ASAP.

[SimdCodeGen.zip](https://github.com/dotnet/coreclr/files/2280547/SimdCodeGen.zip)
[NativeVector_Disassembly.txt](https://github.com/dotnet/coreclr/files/2280548/NativeVector_Disassembly.txt)
[WrappedVector_Disassembly.txt](https://github.com/dotnet/coreclr/files/2280549/WrappedVector_Disassembly.txt)

Thanks.

@CarolEidt @sivarv </Description>
    <Title_Description>Regression: Wrapped System.Numerics types are not generating SIMD code Greetings

I'm running Visual Studio 2017 v15.7.6 with .Net Core 2.1.400-preview-009171. I've noticed that SIMD types from System.Numerics that are wrapped within structs are not generating optimal code. I've tried running from vanilla JIT as well as AOT (both RyuJIT and CPP CodeGen) to no avail.

I've attached a simple project that demonstrates this along with the disassembly.

Furthermore it appears that this might be a regression given it seems to have been resolved in https://github.com/dotnet/coreclr/issues/7508 for a prior version.

It would be awesome if this issue can be addressed ASAP.

[SimdCodeGen.zip](https://github.com/dotnet/coreclr/files/2280547/SimdCodeGen.zip)
[NativeVector_Disassembly.txt](https://github.com/dotnet/coreclr/files/2280548/NativeVector_Disassembly.txt)
[WrappedVector_Disassembly.txt](https://github.com/dotnet/coreclr/files/2280549/WrappedVector_Disassembly.txt)

Thanks.

@CarolEidt @sivarv </Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19437</IssueLabelID>
    <Title>[Linux/ARM] SIGILL during stepping under managed debugger</Title>
    <Description>Sometimes during stepping through method that could be called from different threads SIGILL occurs (https://github.com/dotnet/coreclr/pull/19409 does right things but doesn't solve this problem):
 function to do atomic write. What do you think?

Thank you!</Description>
    <Title_Description>[Linux/ARM] SIGILL during stepping under managed debugger Sometimes during stepping through method that could be called from different threads SIGILL occurs (https://github.com/dotnet/coreclr/pull/19409 does right things but doesn't solve this problem):
 function to do atomic write. What do you think?

Thank you!</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>hoyosjs</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19435</IssueLabelID>
    <Title>StructLayout(LayoutKind.Sequential) is not respected in some cases</Title>
    <Description>Consider the following repro code.
Here structs </Description>
    <Title_Description>StructLayout(LayoutKind.Sequential) is not respected in some cases Consider the following repro code.
Here structs </Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>11/08/2018 9:13:53 AM +00:00</CreatedAt>
    <ClosedAt>11/08/2018 7:16:08 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19432</IssueLabelID>
    <Title>IL round-trip test failing</Title>
    <Description>For Windows x64 Release the 

Related: https://github.com/dotnet/coreclr/issues/16540

Seems like the superpmicollect test should be excluded from ILRT testing.</Description>
    <Title_Description>IL round-trip test failing For Windows x64 Release the 

Related: https://github.com/dotnet/coreclr/issues/16540

Seems like the superpmicollect test should be excluded from ILRT testing.</Title_Description>
    <Label>area-ILTools</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>11/08/2018 12:15:55 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19430</IssueLabelID>
    <Title>Build-test.sh handles native test assets</Title>
    <Description>See #19416


cc @janvorli @jashook @RussKeldorph </Description>
    <Title_Description>Build-test.sh handles native test assets See #19416


cc @janvorli @jashook @RussKeldorph </Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>jashook</Assignee>
    <CreatedAt>11/08/2018 12:05:53 AM +00:00</CreatedAt>
    <ClosedAt>16/08/2018 6:21:52 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19428</IssueLabelID>
    <Title>Speculate future methods that will need to be jitted via IL analysis of currently jitting methods</Title>
    <Description>Multicore Jit has been able to provide 20+% startup wins after it is trained but in many scenarios generating and persisting the training data is problematic. We could instead analyze the IL of methods as they were being generated to infer the additional methods they are likely to call in the near future. As a simple case if we were jitting a method:



We have a pretty strong expectation that Bar() and Baz() will be needed in the near future. Lets naively assume that each of Foo Bar and Baz take 500us to compile Foo takes 1us to run once jitted and at the 100us mark of compiling Foo the JIT will call back to the runtime alerting it that Bar and Baz are good speculative compilation candidates. In the current runtime Foo would complete after 1501us whereas in a perfectly parallelized world with no other overhead it would complete in 601us. In practice the wins would probably be less than what we see from trained Multicore Jit but we'd need further investigation to determine how much less. We might still be able to capture a significant fraction. The advantage is that it doesn't create any dependencies that the application needs to account for which gives it broader scenario reach.

category:throughput
theme:runtime
skill-level:expert
cost:extra-large</Description>
    <Title_Description>Speculate future methods that will need to be jitted via IL analysis of currently jitting methods Multicore Jit has been able to provide 20+% startup wins after it is trained but in many scenarios generating and persisting the training data is problematic. We could instead analyze the IL of methods as they were being generated to infer the additional methods they are likely to call in the near future. As a simple case if we were jitting a method:



We have a pretty strong expectation that Bar() and Baz() will be needed in the near future. Lets naively assume that each of Foo Bar and Baz take 500us to compile Foo takes 1us to run once jitted and at the 100us mark of compiling Foo the JIT will call back to the runtime alerting it that Bar and Baz are good speculative compilation candidates. In the current runtime Foo would complete after 1501us whereas in a perfectly parallelized world with no other overhead it would complete in 601us. In practice the wins would probably be less than what we see from trained Multicore Jit but we'd need further investigation to determine how much less. We might still be able to capture a significant fraction. The advantage is that it doesn't create any dependencies that the application needs to account for which gives it broader scenario reach.

category:throughput
theme:runtime
skill-level:expert
cost:extra-large</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>noahfalk</Assignee>
    <CreatedAt>10/08/2018 11:56:54 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19426</IssueLabelID>
    <Title>Generate JIT GC encoding asynchronously to improve JIT throughput</Title>
    <Description>Currently this is an unvalidated suggestion. Additional investigation would be required to confirm the win exists and that the tradeoff in perf/complexity elsewhere are acceptable.

In the past I think Peter did some JIT investigation and determined that encoding GC data was about 8% of JIT time. This data isn't needed until a GC occurs and the method is on the stack. It is possible that by doing the work on a parallel background thread the user perceivable delay between invoking the PreStub and having code available to run would improve by 8% with a tradeoff that datastructures used by the JIT might need to persist in memory longer and that some of the overhead might resurface as GC delay.


category:throughput
theme:gc-info
skill-level:expert
cost:extra-large</Description>
    <Title_Description>Generate JIT GC encoding asynchronously to improve JIT throughput Currently this is an unvalidated suggestion. Additional investigation would be required to confirm the win exists and that the tradeoff in perf/complexity elsewhere are acceptable.

In the past I think Peter did some JIT investigation and determined that encoding GC data was about 8% of JIT time. This data isn't needed until a GC occurs and the method is on the stack. It is possible that by doing the work on a parallel background thread the user perceivable delay between invoking the PreStub and having code available to run would improve by 8% with a tradeoff that datastructures used by the JIT might need to persist in memory longer and that some of the overhead might resurface as GC delay.


category:throughput
theme:gc-info
skill-level:expert
cost:extra-large</Title_Description>
    <Label>JitThroughput</Label>
    <Assignee>noahfalk</Assignee>
    <CreatedAt>10/08/2018 11:18:42 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19425</IssueLabelID>
    <Title>Unix: Unnecessary struct copy while passsing struct of size &lt;=16</Title>
    <Description>This is a copy of #6264. For some reason it wasn't possible to update the description of that issue.

Struct arguments whose size is &lt;= 16 bytes generate unnecessary copies. @sivarv  categorized the cases below:

The following are the struct passing cases on Amd64 Unix that are of interest:

struct of size 124 or 8 in memory/register is getting passed in an arg reg or on stack
struct of size 3567 in memory/register is getting passed in an arg reg or on stack
struct of size 9-16 bytes in memory is getting passed in two arg registers
struct of size 9-16 bytes (e.g. SIMD structs Vector3 and Vector4) in a register is getting passed in two arg registers
struct of size 9-16 bytes in memory/register is getting passed on stack.
In fgMorphArgs eeGetSystemVAmd64PassStructInRegisterDescriptor classifies the cases above as register argument except simd from vector&lt;t&gt; and sets structDesc.passedInRegisters to true this always calls fgMakeOutgoingStructArgCopy() and generates copies.

category:cq
theme:calling-convention
skill-level:intermediate
cost:medium</Description>
    <Title_Description>Unix: Unnecessary struct copy while passsing struct of size &lt;=16 This is a copy of #6264. For some reason it wasn't possible to update the description of that issue.

Struct arguments whose size is &lt;= 16 bytes generate unnecessary copies. @sivarv  categorized the cases below:

The following are the struct passing cases on Amd64 Unix that are of interest:

struct of size 124 or 8 in memory/register is getting passed in an arg reg or on stack
struct of size 3567 in memory/register is getting passed in an arg reg or on stack
struct of size 9-16 bytes in memory is getting passed in two arg registers
struct of size 9-16 bytes (e.g. SIMD structs Vector3 and Vector4) in a register is getting passed in two arg registers
struct of size 9-16 bytes in memory/register is getting passed on stack.
In fgMorphArgs eeGetSystemVAmd64PassStructInRegisterDescriptor classifies the cases above as register argument except simd from vector&lt;t&gt; and sets structDesc.passedInRegisters to true this always calls fgMakeOutgoingStructArgCopy() and generates copies.

category:cq
theme:calling-convention
skill-level:intermediate
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>erozenfeld</Assignee>
    <CreatedAt>10/08/2018 11:18:32 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19424</IssueLabelID>
    <Title>Clean up genClearStackVec3ArgUpperBits</Title>
    <Description>This is a copy of #5113. For some reason it wasn't possible to update the description of that issue.

genClearStackVec3ArgUpperBits can be split and implemented in genFnPrologCalleeRegArgs() for argument registers and genEnregisterIncomingStackArgs() for stack arguments.

Related PR: #4963

category:cq
theme:vector-codegen
skill-level:intermediate
cost:small
</Description>
    <Title_Description>Clean up genClearStackVec3ArgUpperBits This is a copy of #5113. For some reason it wasn't possible to update the description of that issue.

genClearStackVec3ArgUpperBits can be split and implemented in genFnPrologCalleeRegArgs() for argument registers and genEnregisterIncomingStackArgs() for stack arguments.

Related PR: #4963

category:cq
theme:vector-codegen
skill-level:intermediate
cost:small
</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>erozenfeld</Assignee>
    <CreatedAt>10/08/2018 11:17:06 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19418</IssueLabelID>
    <Title>[NO MERGE] Dummy PR</Title>
    <Description>**NO MERGE** **NO MERGE** **NO MERGE**</Description>
    <Title_Description>[NO MERGE] Dummy PR **NO MERGE** **NO MERGE** **NO MERGE**</Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>echesakovMSFT</Assignee>
    <CreatedAt>10/08/2018 10:12:56 PM +00:00</CreatedAt>
    <ClosedAt>13/08/2018 4:45:59 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19417</IssueLabelID>
    <Title>[local gc] Enable numa-awareness </Title>
    <Description>Right now local gc is not aware of numa (e.g. virtual_alloc_commit_for_heap)</Description>
    <Title_Description>[local gc] Enable numa-awareness  Right now local gc is not aware of numa (e.g. virtual_alloc_commit_for_heap)</Title_Description>
    <Label>area-GC</Label>
    <Assignee>davmason</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19416</IssueLabelID>
    <Title>Make test building scripts consistent across Windows and non-Windows builds</Title>
    <Description>The  file.

cc: @RussKeldorph @janvorli @BruceForstall </Description>
    <Title_Description>Make test building scripts consistent across Windows and non-Windows builds The  file.

cc: @RussKeldorph @janvorli @BruceForstall </Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>10/08/2018 8:15:26 PM +00:00</CreatedAt>
    <ClosedAt>16/08/2018 6:22:34 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19415</IssueLabelID>
    <Title>R2RDump test fails with JITMinOpts</Title>
    <Description>https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/x86_checked_windows_nt_minopts/
https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/x64_checked_windows_nt_minopts/


https://github.com/dotnet/coreclr/pull/19155 removed:


so the test now runs with JIT optimization modes. It fails under JITMinOpts. (I haven't checked other optimization cases.)
</Description>
    <Title_Description>R2RDump test fails with JITMinOpts https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/x86_checked_windows_nt_minopts/
https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/x64_checked_windows_nt_minopts/


https://github.com/dotnet/coreclr/pull/19155 removed:


so the test now runs with JIT optimization modes. It fails under JITMinOpts. (I haven't checked other optimization cases.)
</Title_Description>
    <Label>area-ReadyToRun</Label>
    <Assignee>acmyu</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19413</IssueLabelID>
    <Title>JIT: jitstress2 failure in JIT\Methodical\fp\exgen\10w5d_cs_ro after switch to R2R codegen for corelib</Title>
    <Description>Fails after #19359 running with x64 checked. Method prints same output stream but return code is now 108 instead of 100.

Fair number of diffs in jitted code before/after this change. Haven't tried pinning it down yet.

cc @dotnet/jit-contrib </Description>
    <Title_Description>JIT: jitstress2 failure in JIT\Methodical\fp\exgen\10w5d_cs_ro after switch to R2R codegen for corelib Fails after #19359 running with x64 checked. Method prints same output stream but return code is now 108 instead of 100.

Fair number of diffs in jitted code before/after this change. Haven't tried pinning it down yet.

cc @dotnet/jit-contrib </Title_Description>
    <Label>JitStress</Label>
    <Assignee>sandreenko</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19412</IssueLabelID>
    <Title>Remove GT_ASG nodes</Title>
    <Description>This came up occasionally in discussions but AFAIK there's no issue associated with it and IMO there should be due to the significant (negative) impact  but its IR was very different looking more like assembly. I know next to nothing about LLVM but I don't think it has assignment.

category:implementation
theme:ir
skill-level:expert
cost:extra-large</Description>
    <Title_Description>Remove GT_ASG nodes This came up occasionally in discussions but AFAIK there's no issue associated with it and IMO there should be due to the significant (negative) impact  but its IR was very different looking more like assembly. I know next to nothing about LLVM but I don't think it has assignment.

category:implementation
theme:ir
skill-level:expert
cost:extra-large</Title_Description>
    <Label>Design Discussion</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>10/08/2018 4:52:10 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19411</IssueLabelID>
    <Title>Add gcstress smoketest to CI</Title>
    <Description>gcstress is somewhat fragile as requires an additional package install and exercises paths in the runtime that aren't normally hit. We should consider adding a gcstress smoketest to the CI that just stresses a few tests to make sure it remains healthy.

cc @BruceForstall </Description>
    <Title_Description>Add gcstress smoketest to CI gcstress is somewhat fragile as requires an additional package install and exercises paths in the runtime that aren't normally hit. We should consider adding a gcstress smoketest to the CI that just stresses a few tests to make sure it remains healthy.

cc @BruceForstall </Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>AndyAyersMS</Assignee>
    <CreatedAt>10/08/2018 4:15:47 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19408</IssueLabelID>
    <Title>Profiling API: Inconsistent stack unwinding after exception in filter handler</Title>
    <Description>The short example of abnormal Profiling API behavior (.NET Core v2.1 / .NET Framework v4.7.2):
 is absent. The diagram from https://docs.microsoft.com/en-us/previous-versions/dotnet/netframework-4.0/bb384687(v=vs.100) says that it's impossible.

Could you please comment this behavior?</Description>
    <Title_Description>Profiling API: Inconsistent stack unwinding after exception in filter handler The short example of abnormal Profiling API behavior (.NET Core v2.1 / .NET Framework v4.7.2):
 is absent. The diagram from https://docs.microsoft.com/en-us/previous-versions/dotnet/netframework-4.0/bb384687(v=vs.100) says that it's impossible.

Could you please comment this behavior?</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>10/08/2018 2:57:53 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19407</IssueLabelID>
    <Title>Generic interface method not being called</Title>
    <Description>Tested sample code on .NET 2/3/4/4.5/4.6.1 &amp; .Net Core 2.1 behavior is the same for all why is this handled like this? 

Clearly the call to 
</Description>
    <Title_Description>Generic interface method not being called Tested sample code on .NET 2/3/4/4.5/4.6.1 &amp; .Net Core 2.1 behavior is the same for all why is this handled like this? 

Clearly the call to 
</Title_Description>
    <Label>question</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>10/08/2018 9:19:27 AM +00:00</CreatedAt>
    <ClosedAt>10/08/2018 2:24:54 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19406</IssueLabelID>
    <Title>Test failure: baseservices_threading._waithandle_waitany_waitanyex2a_waitanyex2a_/_waithandle_waitany_waitanyex2a_waitanyex2a_cmd</Title>
    <Description>Opened on behalf of @Sunny-pu

The test  has failed.


    
    Return code:      1
    Raw output file:      /home/helixbot/dotnetbuild/work/64020330-e696-44f2-9aa4-7a362aff9f95/Work/78d4e7b9-e498-41b3-b8c1-8cc91a8385b3/Unzip/Reports\\baseservices.threading\\waithandle\\waitany\\waitanyex2a\\waitanyex2a.output.txt
    Raw output:
    BEGIN EXECUTION
    in takeLock
    /home/helixbot/dotnetbuild/work/64020330-e696-44f2-9aa4-7a362aff9f95/Payload/crossgen /Platform_Assemblies_Paths /home/helixbot/dotnetbuild/work/64020330-e696-44f2-9aa4-7a362aff9f95/Payload:/home/helixbot/dotnetbuild/work/64020330-e696-44f2-9aa4-7a362aff9f95/Work/78d4e7b9-e498-41b3-b8c1-8cc91a8385b3/Unzip/waithandle/waitany/waitanyex2a/IL:/home/helixbot/dotnetbuild/work/64020330-e696-44f2-9aa4-7a362aff9f95/Work/78d4e7b9-e498-41b3-b8c1-8cc91a8385b3/Unzip/waithandle/waitany/waitanyex2a /in waitanyex2a.org /out waitanyex2a.exe
    Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0
    Copyright (c) Microsoft Corporation.  All rights reserved.
    
    Native image waitanyex2a.exe generated successfully.
    in ReleaseLock
    in takeLock
    /home/helixbot/dotnetbuild/work/64020330-e696-44f2-9aa4-7a362aff9f95/Payload/corerun waitanyex2a.exe
    Testing Mutex and non-Mutex and signaling the other element
    Acquire the Mutex
    Holding the Mutex
    Waiting...
    WaitAny did not throw AbandonedMutexException. Result: 1
    Test Failed
    in ReleaseLock
    Expected: 100
    Actual: 255
    END EXECUTION - FAILED
    Test Harness Exitcode is : 1
    
    To run the test:
    &gt; set CORE_ROOT=/home/helixbot/dotnetbuild/work/64020330-e696-44f2-9aa4-7a362aff9f95/Payload
    &gt; /home/helixbot/dotnetbuild/work/64020330-e696-44f2-9aa4-7a362aff9f95/Work/78d4e7b9-e498-41b3-b8c1-8cc91a8385b3/Unzip/waithandle/waitany/waitanyex2a/waitanyex2a.sh
    
    Expected: True
    Actual:   False

        Stack Trace:

        
Build : 3.0 - 20180810.01 (Ready-To-Run Tests)
Failing configurations:
- ubuntu.1404.amd64
  - x64

Details: https://mc.dot.net/#/product/netcore/30/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fr2r~2Fcli~2F/build/20180810.01/workItem/baseservices.threading.XUnitWrapper/analysis/xunit/baseservices_threading._waithandle_waitany_waitanyex2a_waitanyex2a_~2F_waithandle_waitany_waitanyex2a_waitanyex2a_cmd</Description>
    <Title_Description>Test failure: baseservices_threading._waithandle_waitany_waitanyex2a_waitanyex2a_/_waithandle_waitany_waitanyex2a_waitanyex2a_cmd Opened on behalf of @Sunny-pu

The test  has failed.


    
    Return code:      1
    Raw output file:      /home/helixbot/dotnetbuild/work/64020330-e696-44f2-9aa4-7a362aff9f95/Work/78d4e7b9-e498-41b3-b8c1-8cc91a8385b3/Unzip/Reports\\baseservices.threading\\waithandle\\waitany\\waitanyex2a\\waitanyex2a.output.txt
    Raw output:
    BEGIN EXECUTION
    in takeLock
    /home/helixbot/dotnetbuild/work/64020330-e696-44f2-9aa4-7a362aff9f95/Payload/crossgen /Platform_Assemblies_Paths /home/helixbot/dotnetbuild/work/64020330-e696-44f2-9aa4-7a362aff9f95/Payload:/home/helixbot/dotnetbuild/work/64020330-e696-44f2-9aa4-7a362aff9f95/Work/78d4e7b9-e498-41b3-b8c1-8cc91a8385b3/Unzip/waithandle/waitany/waitanyex2a/IL:/home/helixbot/dotnetbuild/work/64020330-e696-44f2-9aa4-7a362aff9f95/Work/78d4e7b9-e498-41b3-b8c1-8cc91a8385b3/Unzip/waithandle/waitany/waitanyex2a /in waitanyex2a.org /out waitanyex2a.exe
    Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0
    Copyright (c) Microsoft Corporation.  All rights reserved.
    
    Native image waitanyex2a.exe generated successfully.
    in ReleaseLock
    in takeLock
    /home/helixbot/dotnetbuild/work/64020330-e696-44f2-9aa4-7a362aff9f95/Payload/corerun waitanyex2a.exe
    Testing Mutex and non-Mutex and signaling the other element
    Acquire the Mutex
    Holding the Mutex
    Waiting...
    WaitAny did not throw AbandonedMutexException. Result: 1
    Test Failed
    in ReleaseLock
    Expected: 100
    Actual: 255
    END EXECUTION - FAILED
    Test Harness Exitcode is : 1
    
    To run the test:
    &gt; set CORE_ROOT=/home/helixbot/dotnetbuild/work/64020330-e696-44f2-9aa4-7a362aff9f95/Payload
    &gt; /home/helixbot/dotnetbuild/work/64020330-e696-44f2-9aa4-7a362aff9f95/Work/78d4e7b9-e498-41b3-b8c1-8cc91a8385b3/Unzip/waithandle/waitany/waitanyex2a/waitanyex2a.sh
    
    Expected: True
    Actual:   False

        Stack Trace:

        
Build : 3.0 - 20180810.01 (Ready-To-Run Tests)
Failing configurations:
- ubuntu.1404.amd64
  - x64

Details: https://mc.dot.net/#/product/netcore/30/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fr2r~2Fcli~2F/build/20180810.01/workItem/baseservices.threading.XUnitWrapper/analysis/xunit/baseservices_threading._waithandle_waitany_waitanyex2a_waitanyex2a_~2F_waithandle_waitany_waitanyex2a_waitanyex2a_cmd</Title_Description>
    <Label>area-System.Threading</Label>
    <Assignee>kouvel</Assignee>
    <CreatedAt>10/08/2018 9:13:50 AM +00:00</CreatedAt>
    <ClosedAt>26/07/2019 1:03:14 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19405</IssueLabelID>
    <Title>Test failure: CoreMangLib_cti._system_collections_generic_dictionary_DictionaryAdd_DictionaryAdd_/_system_collections_generic_dictionary_DictionaryAdd_DictionaryAdd_cmd</Title>
    <Description>Opened on behalf of @Sunny-pu

The test  has failed.

coreclr_initialize failed - status: 0x80004005
    
    
    Return code:      1
    Raw output file:      /home/helixbot/dotnetbuild/work/44e226a1-fc4e-4168-97d8-c8030a8ad273/Work/075808ac-aef4-4559-9400-c36cfddf85ed/Unzip/Reports\\CoreMangLib.cti\\system\\collections\\generic\\dictionary\\DictionaryAdd\\DictionaryAdd.output.txt
    Raw output:
    BEGIN EXECUTION
    /home/helixbot/dotnetbuild/work/44e226a1-fc4e-4168-97d8-c8030a8ad273/Payload/corerun DictionaryAdd.exe
    Expected: 100
    Actual: 255
    END EXECUTION - FAILED
    Test Harness Exitcode is : 1
    
    To run the test:
    &gt; set CORE_ROOT=/home/helixbot/dotnetbuild/work/44e226a1-fc4e-4168-97d8-c8030a8ad273/Payload
    &gt; /home/helixbot/dotnetbuild/work/44e226a1-fc4e-4168-97d8-c8030a8ad273/Work/075808ac-aef4-4559-9400-c36cfddf85ed/Unzip/system/collections/generic/dictionary/DictionaryAdd/DictionaryAdd.sh
    
    Expected: True
    Actual:   False

        Stack Trace:

        
Build : 3.0 - 20180810.01 (Core Tests)
Failing configurations:
- opensuse.423.amd64-x64
  - 

Details:
https://mc.dot.net/#/product/netcore/30/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fcli~2F/build/20180810.01/workItem/CoreMangLib.cti.XUnitWrapper/analysis/xunit/CoreMangLib_cti._system_collections_generic_dictionary_DictionaryAdd_DictionaryAdd_~2F_system_collections_generic_dictionary_DictionaryAdd_DictionaryAdd_cmd</Description>
    <Title_Description>Test failure: CoreMangLib_cti._system_collections_generic_dictionary_DictionaryAdd_DictionaryAdd_/_system_collections_generic_dictionary_DictionaryAdd_DictionaryAdd_cmd Opened on behalf of @Sunny-pu

The test  has failed.

coreclr_initialize failed - status: 0x80004005
    
    
    Return code:      1
    Raw output file:      /home/helixbot/dotnetbuild/work/44e226a1-fc4e-4168-97d8-c8030a8ad273/Work/075808ac-aef4-4559-9400-c36cfddf85ed/Unzip/Reports\\CoreMangLib.cti\\system\\collections\\generic\\dictionary\\DictionaryAdd\\DictionaryAdd.output.txt
    Raw output:
    BEGIN EXECUTION
    /home/helixbot/dotnetbuild/work/44e226a1-fc4e-4168-97d8-c8030a8ad273/Payload/corerun DictionaryAdd.exe
    Expected: 100
    Actual: 255
    END EXECUTION - FAILED
    Test Harness Exitcode is : 1
    
    To run the test:
    &gt; set CORE_ROOT=/home/helixbot/dotnetbuild/work/44e226a1-fc4e-4168-97d8-c8030a8ad273/Payload
    &gt; /home/helixbot/dotnetbuild/work/44e226a1-fc4e-4168-97d8-c8030a8ad273/Work/075808ac-aef4-4559-9400-c36cfddf85ed/Unzip/system/collections/generic/dictionary/DictionaryAdd/DictionaryAdd.sh
    
    Expected: True
    Actual:   False

        Stack Trace:

        
Build : 3.0 - 20180810.01 (Core Tests)
Failing configurations:
- opensuse.423.amd64-x64
  - 

Details:
https://mc.dot.net/#/product/netcore/30/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fcli~2F/build/20180810.01/workItem/CoreMangLib.cti.XUnitWrapper/analysis/xunit/CoreMangLib_cti._system_collections_generic_dictionary_DictionaryAdd_DictionaryAdd_~2F_system_collections_generic_dictionary_DictionaryAdd_DictionaryAdd_cmd</Title_Description>
    <Label>test-run-uwp-coreclr</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>10/08/2018 9:06:53 AM +00:00</CreatedAt>
    <ClosedAt>10/08/2018 2:54:45 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19404</IssueLabelID>
    <Title>Test failure: reflection_regression._dev10bugs_Dev10_629953_Dev10_629953_/_dev10bugs_Dev10_629953_Dev10_629953_cmd</Title>
    <Description>Opened on behalf of @Sunny-pu

The test  has failed.

Test Infrastructure Failure: System.TypeInitializationException: The type initializer for 'System.Diagnostics.Process' threw an exception. ---&gt; System.IO.FileNotFoundException: Could not load file or assembly 'System.Text.Encoding.Extensions Version=4.1.1.0 Culture=neutral PublicKeyToken=b03f5f7f11d50a3a'. The system cannot find the file specified.
    
       at System.Diagnostics.Process..cctor()
       --- End of inner exception stack trace ---
       at System.Diagnostics.Process.EnsureSigChildHandler()
       at System.Diagnostics.Process.StartCore(ProcessStartInfo startInfo)
       at System.Diagnostics.Process.Start()
       at CoreclrTestLib.CoreclrTestWrapperLib.RunTest(String executable String outputFile String errorFile)
       at reflection_regression._dev10bugs_Dev10_630880_Dev10_630880_._dev10bugs_Dev10_630880_Dev10_630880_cmd()
    Expected: True
    Actual:   False

        Stack Trace:

        
Build : 3.0 - 20180810.01 (Core Tests)
Failing configurations:
- opensuse.423.amd64-x64
  - 

Details:
https://mc.dot.net/#/product/netcore/30/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fcli~2F/build/20180810.01/workItem/reflection.regression.XUnitWrapper/analysis/xunit/reflection_regression._dev10bugs_Dev10_629953_Dev10_629953_~2F_dev10bugs_Dev10_629953_Dev10_629953_cmd</Description>
    <Title_Description>Test failure: reflection_regression._dev10bugs_Dev10_629953_Dev10_629953_/_dev10bugs_Dev10_629953_Dev10_629953_cmd Opened on behalf of @Sunny-pu

The test  has failed.

Test Infrastructure Failure: System.TypeInitializationException: The type initializer for 'System.Diagnostics.Process' threw an exception. ---&gt; System.IO.FileNotFoundException: Could not load file or assembly 'System.Text.Encoding.Extensions Version=4.1.1.0 Culture=neutral PublicKeyToken=b03f5f7f11d50a3a'. The system cannot find the file specified.
    
       at System.Diagnostics.Process..cctor()
       --- End of inner exception stack trace ---
       at System.Diagnostics.Process.EnsureSigChildHandler()
       at System.Diagnostics.Process.StartCore(ProcessStartInfo startInfo)
       at System.Diagnostics.Process.Start()
       at CoreclrTestLib.CoreclrTestWrapperLib.RunTest(String executable String outputFile String errorFile)
       at reflection_regression._dev10bugs_Dev10_630880_Dev10_630880_._dev10bugs_Dev10_630880_Dev10_630880_cmd()
    Expected: True
    Actual:   False

        Stack Trace:

        
Build : 3.0 - 20180810.01 (Core Tests)
Failing configurations:
- opensuse.423.amd64-x64
  - 

Details:
https://mc.dot.net/#/product/netcore/30/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fcli~2F/build/20180810.01/workItem/reflection.regression.XUnitWrapper/analysis/xunit/reflection_regression._dev10bugs_Dev10_629953_Dev10_629953_~2F_dev10bugs_Dev10_629953_Dev10_629953_cmd</Title_Description>
    <Label>test-run-uwp-coreclr</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>10/08/2018 8:34:11 AM +00:00</CreatedAt>
    <ClosedAt>10/08/2018 3:00:32 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19403</IssueLabelID>
    <Title>OSX CoreFX CI Leg is Consistently Failing</Title>
    <Description>It appears that all runs of this CI leg are failing due to tests timing out: https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_debug_osx10.12_corefx_innerloop_prtest/</Description>
    <Title_Description>OSX CoreFX CI Leg is Consistently Failing It appears that all runs of this CI leg are failing due to tests timing out: https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_debug_osx10.12_corefx_innerloop_prtest/</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>10/08/2018 4:23:05 AM +00:00</CreatedAt>
    <ClosedAt>16/08/2018 11:40:10 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19402</IssueLabelID>
    <Title>Run DotNet Core App on X86 Without OS</Title>
    <Description>How to run DotNet Core app on X86 without OS?</Description>
    <Title_Description>Run DotNet Core App on X86 Without OS How to run DotNet Core app on X86 without OS?</Title_Description>
    <Label>question</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>10/08/2018 3:34:18 AM +00:00</CreatedAt>
    <ClosedAt>15/08/2018 1:43:28 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19401</IssueLabelID>
    <Title>update order of locks so gcstress is unblocked</Title>
    <Description>
    </Description>
    <Title_Description>update order of locks so gcstress is unblocked </Title_Description>
    <Label>
    </Label>
    <Assignee>davmason</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19400</IssueLabelID>
    <Title>Track conversion of Intel Hardware Intrinsics tests to generated format</Title>
    <Description>This is an umbrella issue to track progress of conversion of all tests as detailed in #19245 and #19246


### Avx
 [ ]  Blend
 [ ]  BroadcastScalarToVector128
 [ ]  BroadcastScalarToVector256
 [ ]  BroadcastVector128ToVector256
 [ ]  CompareScalar
 [ ]  Compare
 [ ]  ConvertToSingle
 [ ]  ConvertToVector
 [ ]  DotProduct
 [ ]  HorizontalAdd
 [ ]  HorizontalSubtract
 [ ]  InsertExtractVector128
 [ ]  LoadAlignedVector256
 [ ]  LoadDquVector256
 [ ]  LoadVector256
 [ ]  MaskLoad
 [ ]  MoveMask
 [ ]  Permute2x128.Avx
 [ ]  SetAllVector256
 [ ]  SetVector256
 [ ]  SetZeroVector256
 [ ]  Sqrt
 [ ]  StaticCast
 [ ]  StoreAlignedNonTemporal
 [ ]  StoreAligned
 [ ]  Store
 [ ]  UnpackHigh
 [ ]  UnpackLow

### Avx2
 [ ]  AddSaturate
 [ ]  BroadcastVector128ToVector256
 [ ]  ConvertToVector256
 [ ]  HorizontalAdd
 [ ]  HorizontalSubtract
 [ ]  LoadAlignedVector256NonTemporal
 [ ]  MoveMask
 [ ]  Multiply
 [ ]  ShiftLeftLogicalVariable
 [ ]  ShiftRightLogicalVariable
 [ ]  SubtractSaturate
 [ ]  UnpackHigh
 [ ]  UnpackLow

### Sse
 [ ]  ConvertScalarToVector128Single
 [ ]  ConvertToInt32WithTruncation #19998
 [ ]  ConvertToInt32 #19998
 [ ]  ConvertToInt64WithTruncation #19998
 [ ]  ConvertToInt64 #19998
 [ ]  ConvertToSingle #19998
 [ ]  LoadAlignedVector128
 [ ]  LoadHigh
 [ ]  LoadLow
 [ ]  LoadScalarVector128
 [ ]  LoadVector128
 [ ]  MoveHighToLow
 [ ]  MoveLowToHigh
 [ ]  MoveMask
 [ ]  MoveScalar
 [ ]  Prefetch
 [ ]  ReciprocalScalar
 [ ]  ReciprocalSqrtScalar
 [ ]  ReciprocalSqrt
 [ ]  Reciprocal
 [ ]  SetAllVector128
 [ ]  SetScalarVector128
 [ ]  SetVector128
 [ ]  SetZeroVector128
 [ ]  Shuffle
 [ ]  SqrtScalar
 [ ]  Sqrt
 [ ]  StaticCast
 [ ]  StoreAlignedNonTemporal
 [ ]  StoreAligned
 [ ]  StoreFence
 [ ]  StoreHigh
 [ ]  StoreLow
 [ ]  StoreScalar
 [ ]  Store
 [ ]  UnpackHigh
 [ ]  UnpackLow

### Sse2
 [x]  CompareEqualOrderedScalar #19673
 [x]  CompareEqualScalar #19673
 [x]  CompareEqualUnorderedScalar #19673
 [x]  CompareGreaterThanOrderedScalar #19673
 [x]  CompareGreaterThanOrEqualOrderedScalar #19673
 [x]  CompareGreaterThanOrEqualScalar #19673
 [x]  CompareGreaterThanOrEqualUnorderedScalar #19673
 [x]  CompareGreaterThanScalar #19673
 [x]  CompareGreaterThanUnorderedScalar #19673
 [x]  CompareLessThanOrderedScalar #19673
 [x]  CompareLessThanOrEqualOrderedScalar #19673
 [x]  CompareLessThanOrEqualScalar #19673
 [x]  CompareLessThanOrEqualUnorderedScalar #19673
 [x]  CompareLessThanScalar #19673
 [x]  CompareLessThanUnorderedScalar #19673
 [x]  CompareNotEqualOrderedScalar #19673
 [x]  CompareNotEqualScalar #19673
 [x]  CompareNotEqualUnorderedScalar #19673
 [x]  CompareNotGreaterThanOrEqualScalar #19673
 [x]  CompareNotGreaterThanScalar #19673
 [x]  CompareNotLessThanOrEqualScalar #19673
 [x]  CompareNotLessThanScalar #19673
 [x]  CompareOrderedScalar #19673
 [x]  CompareUnorderedScalar #19673
 [ ]  ConvertScalarToVector128Double
 [ ]  ConvertScalarToVector128Int32 #19998
 [ ]  ConvertScalarToVector128Int64 #19998
 [ ]  ConvertScalarToVector128Single
 [ ]  ConvertScalarToVector128UInt32 #19998
 [ ]  ConvertScalarToVector128UInt64 #19998
 [x]  ConvertToDouble #19677 
 [x]  ConvertToInt32WithTruncation #19677
 [x]  ConvertToInt32 #19677
 [x]  ConvertToInt64WithTruncation #19677
 [x]  ConvertToInt64 #19677
 [x]  ConvertToUInt32 #19677
 [x]  ConvertToUInt64 #19677
 [x]  ConvertToVector128Double #19677
 [x]  ConvertToVector128Int32WithTruncation #19677
 [x]  ConvertToVector128Int32 #19677
 [x]  ConvertToVector128Single #19677
 [ ]  LoadAlignedVector128
 [ ]  LoadFence
 [ ]  LoadHigh
 [ ]  LoadLow
 [ ]  LoadScalarVector128
 [ ]  LoadVector128
 [ ]  MaskMove
 [ ]  MemoryFence
 [ ]  MoveMask
 [ ]  MoveScalar.Int64
 [ ]  MoveScalar.UInt64
 [ ]  MoveScalar
 [ ]  MultiplyHigh
 [ ]  MultiplyHorizontalAdd
 [ ]  MultiplyLow
 [ ]  Multiply
 [ ]  PackSignedSaturate #19670
 [ ]  PackUnsignedSaturate #19670
 [ ]  SetScalarVector128
 [ ]  SetVector128
 [ ]  SetZeroVector128
 [ ]  ShuffleHigh
 [ ]  ShuffleLow
 [ ]  Shuffle
 [ ]  SqrtScalar
 [ ]  Sqrt
 [ ]  StoreAlignedNonTemporal
 [ ]  StoreAligned
 [ ]  StoreHigh
 [ ]  StoreLow
 [ ]  StoreNonTemporal
 [ ]  StoreScalar
 [ ]  Store
 [ ]  SumAbsoluteDifferences
 [ ]  UnpackHigh #19670
 [ ]  UnpackLow #19670

### Sse3
 [ ]  LoadAndDuplicateToVector128
 [ ]  LoadDquVector128
 [ ]  MoveAndDuplicate
 [ ]  MoveHighAndDuplicate
 [ ]  MoveLowAndDuplicate

### Sse41
 [ ]  Blend
 [ ]  ConvertToVector128
 [ ]  DotProduct
 [ ]  LoadAlignedVector128NonTemporal
 [ ]  MinHorizontal
 [ ]  MultipleSumAbsoluteDifferences
 [ ]  Multiply

### Sse42
 [ ]  Crc32

### Ssse3
 [ ]  AlignRight
</Description>
    <Title_Description>Track conversion of Intel Hardware Intrinsics tests to generated format This is an umbrella issue to track progress of conversion of all tests as detailed in #19245 and #19246


### Avx
 [ ]  Blend
 [ ]  BroadcastScalarToVector128
 [ ]  BroadcastScalarToVector256
 [ ]  BroadcastVector128ToVector256
 [ ]  CompareScalar
 [ ]  Compare
 [ ]  ConvertToSingle
 [ ]  ConvertToVector
 [ ]  DotProduct
 [ ]  HorizontalAdd
 [ ]  HorizontalSubtract
 [ ]  InsertExtractVector128
 [ ]  LoadAlignedVector256
 [ ]  LoadDquVector256
 [ ]  LoadVector256
 [ ]  MaskLoad
 [ ]  MoveMask
 [ ]  Permute2x128.Avx
 [ ]  SetAllVector256
 [ ]  SetVector256
 [ ]  SetZeroVector256
 [ ]  Sqrt
 [ ]  StaticCast
 [ ]  StoreAlignedNonTemporal
 [ ]  StoreAligned
 [ ]  Store
 [ ]  UnpackHigh
 [ ]  UnpackLow

### Avx2
 [ ]  AddSaturate
 [ ]  BroadcastVector128ToVector256
 [ ]  ConvertToVector256
 [ ]  HorizontalAdd
 [ ]  HorizontalSubtract
 [ ]  LoadAlignedVector256NonTemporal
 [ ]  MoveMask
 [ ]  Multiply
 [ ]  ShiftLeftLogicalVariable
 [ ]  ShiftRightLogicalVariable
 [ ]  SubtractSaturate
 [ ]  UnpackHigh
 [ ]  UnpackLow

### Sse
 [ ]  ConvertScalarToVector128Single
 [ ]  ConvertToInt32WithTruncation #19998
 [ ]  ConvertToInt32 #19998
 [ ]  ConvertToInt64WithTruncation #19998
 [ ]  ConvertToInt64 #19998
 [ ]  ConvertToSingle #19998
 [ ]  LoadAlignedVector128
 [ ]  LoadHigh
 [ ]  LoadLow
 [ ]  LoadScalarVector128
 [ ]  LoadVector128
 [ ]  MoveHighToLow
 [ ]  MoveLowToHigh
 [ ]  MoveMask
 [ ]  MoveScalar
 [ ]  Prefetch
 [ ]  ReciprocalScalar
 [ ]  ReciprocalSqrtScalar
 [ ]  ReciprocalSqrt
 [ ]  Reciprocal
 [ ]  SetAllVector128
 [ ]  SetScalarVector128
 [ ]  SetVector128
 [ ]  SetZeroVector128
 [ ]  Shuffle
 [ ]  SqrtScalar
 [ ]  Sqrt
 [ ]  StaticCast
 [ ]  StoreAlignedNonTemporal
 [ ]  StoreAligned
 [ ]  StoreFence
 [ ]  StoreHigh
 [ ]  StoreLow
 [ ]  StoreScalar
 [ ]  Store
 [ ]  UnpackHigh
 [ ]  UnpackLow

### Sse2
 [x]  CompareEqualOrderedScalar #19673
 [x]  CompareEqualScalar #19673
 [x]  CompareEqualUnorderedScalar #19673
 [x]  CompareGreaterThanOrderedScalar #19673
 [x]  CompareGreaterThanOrEqualOrderedScalar #19673
 [x]  CompareGreaterThanOrEqualScalar #19673
 [x]  CompareGreaterThanOrEqualUnorderedScalar #19673
 [x]  CompareGreaterThanScalar #19673
 [x]  CompareGreaterThanUnorderedScalar #19673
 [x]  CompareLessThanOrderedScalar #19673
 [x]  CompareLessThanOrEqualOrderedScalar #19673
 [x]  CompareLessThanOrEqualScalar #19673
 [x]  CompareLessThanOrEqualUnorderedScalar #19673
 [x]  CompareLessThanScalar #19673
 [x]  CompareLessThanUnorderedScalar #19673
 [x]  CompareNotEqualOrderedScalar #19673
 [x]  CompareNotEqualScalar #19673
 [x]  CompareNotEqualUnorderedScalar #19673
 [x]  CompareNotGreaterThanOrEqualScalar #19673
 [x]  CompareNotGreaterThanScalar #19673
 [x]  CompareNotLessThanOrEqualScalar #19673
 [x]  CompareNotLessThanScalar #19673
 [x]  CompareOrderedScalar #19673
 [x]  CompareUnorderedScalar #19673
 [ ]  ConvertScalarToVector128Double
 [ ]  ConvertScalarToVector128Int32 #19998
 [ ]  ConvertScalarToVector128Int64 #19998
 [ ]  ConvertScalarToVector128Single
 [ ]  ConvertScalarToVector128UInt32 #19998
 [ ]  ConvertScalarToVector128UInt64 #19998
 [x]  ConvertToDouble #19677 
 [x]  ConvertToInt32WithTruncation #19677
 [x]  ConvertToInt32 #19677
 [x]  ConvertToInt64WithTruncation #19677
 [x]  ConvertToInt64 #19677
 [x]  ConvertToUInt32 #19677
 [x]  ConvertToUInt64 #19677
 [x]  ConvertToVector128Double #19677
 [x]  ConvertToVector128Int32WithTruncation #19677
 [x]  ConvertToVector128Int32 #19677
 [x]  ConvertToVector128Single #19677
 [ ]  LoadAlignedVector128
 [ ]  LoadFence
 [ ]  LoadHigh
 [ ]  LoadLow
 [ ]  LoadScalarVector128
 [ ]  LoadVector128
 [ ]  MaskMove
 [ ]  MemoryFence
 [ ]  MoveMask
 [ ]  MoveScalar.Int64
 [ ]  MoveScalar.UInt64
 [ ]  MoveScalar
 [ ]  MultiplyHigh
 [ ]  MultiplyHorizontalAdd
 [ ]  MultiplyLow
 [ ]  Multiply
 [ ]  PackSignedSaturate #19670
 [ ]  PackUnsignedSaturate #19670
 [ ]  SetScalarVector128
 [ ]  SetVector128
 [ ]  SetZeroVector128
 [ ]  ShuffleHigh
 [ ]  ShuffleLow
 [ ]  Shuffle
 [ ]  SqrtScalar
 [ ]  Sqrt
 [ ]  StoreAlignedNonTemporal
 [ ]  StoreAligned
 [ ]  StoreHigh
 [ ]  StoreLow
 [ ]  StoreNonTemporal
 [ ]  StoreScalar
 [ ]  Store
 [ ]  SumAbsoluteDifferences
 [ ]  UnpackHigh #19670
 [ ]  UnpackLow #19670

### Sse3
 [ ]  LoadAndDuplicateToVector128
 [ ]  LoadDquVector128
 [ ]  MoveAndDuplicate
 [ ]  MoveHighAndDuplicate
 [ ]  MoveLowAndDuplicate

### Sse41
 [ ]  Blend
 [ ]  ConvertToVector128
 [ ]  DotProduct
 [ ]  LoadAlignedVector128NonTemporal
 [ ]  MinHorizontal
 [ ]  MultipleSumAbsoluteDifferences
 [ ]  Multiply

### Sse42
 [ ]  Crc32

### Ssse3
 [ ]  AlignRight
</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>fiigii</Assignee>
    <CreatedAt>10/08/2018 1:46:20 AM +00:00</CreatedAt>
    <ClosedAt>20/09/2019 10:47:02 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19398</IssueLabelID>
    <Title>[dev/unix_test_workflow] Add crossgen_comparison job</Title>
    <Description>
    </Description>
    <Title_Description>[dev/unix_test_workflow] Add crossgen_comparison job </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>echesakovMSFT</Assignee>
    <CreatedAt>10/08/2018 12:43:54 AM +00:00</CreatedAt>
    <ClosedAt>10/08/2018 10:05:43 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19397</IssueLabelID>
    <Title>Assertion failed 'op1-&gt;OperGet() == GT_LONG || op1-&gt;OperGet() == GT_MUL_LONG'</Title>
    <Description>x86 Checked Windows CoreFX JitStressRegs=8

https://ci.dot.net/job/dotnet_coreclr/job/master/view/x86/job/jitstress/job/x86_checked_windows_nt_corefx_jitstressregs8/554/consoleText

hundreds of instances of:


This has been failing for a while.

@dotnet/jit-contrib </Description>
    <Title_Description>Assertion failed 'op1-&gt;OperGet() == GT_LONG || op1-&gt;OperGet() == GT_MUL_LONG' x86 Checked Windows CoreFX JitStressRegs=8

https://ci.dot.net/job/dotnet_coreclr/job/master/view/x86/job/jitstress/job/x86_checked_windows_nt_corefx_jitstressregs8/554/consoleText

hundreds of instances of:


This has been failing for a while.

@dotnet/jit-contrib </Title_Description>
    <Label>arch-x86</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19388</IssueLabelID>
    <Title>WIP NO-MERGE Dummy test for dev/unix_test_workflow change of build VMs</Title>
    <Description>
    </Description>
    <Title_Description>WIP NO-MERGE Dummy test for dev/unix_test_workflow change of build VMs </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>9/08/2018 7:27:05 PM +00:00</CreatedAt>
    <ClosedAt>13/08/2018 10:28:46 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19386</IssueLabelID>
    <Title>[Win/Infrastructure] Regression introduced by #19324 - removed parallel msbuild for tests</Title>
    <Description>PR #19324 lost default MSBuild argument  /maxcpucount which enabled parallel MSBuild test build. Build time on my laptop increased 2x.

cc @AaronRobinsonMSFT </Description>
    <Title_Description>[Win/Infrastructure] Regression introduced by #19324 - removed parallel msbuild for tests PR #19324 lost default MSBuild argument  /maxcpucount which enabled parallel MSBuild test build. Build time on my laptop increased 2x.

cc @AaronRobinsonMSFT </Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>9/08/2018 7:06:27 PM +00:00</CreatedAt>
    <ClosedAt>10/08/2018 6:10:22 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19384</IssueLabelID>
    <Title>Fix a couple of apartment state issues</Title>
    <Description>Fix for https://github.com/dotnet/coreclr/issues/17822
- The apartment state now defaults to MTA for the main thread along with a CoInitialize
- Calling  as expected (different behavior from previous netcore same behavior as netfx)

Fix for https://github.com/dotnet/coreclr/issues/19225</Description>
    <Title_Description>Fix a couple of apartment state issues Fix for https://github.com/dotnet/coreclr/issues/17822
- The apartment state now defaults to MTA for the main thread along with a CoInitialize
- Calling  as expected (different behavior from previous netcore same behavior as netfx)

Fix for https://github.com/dotnet/coreclr/issues/19225</Title_Description>
    <Label>area-System.Threading</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19381</IssueLabelID>
    <Title>Introduce reinterpret in Span&lt;T&gt;</Title>
    <Description>Hello

I know that there are discussions around Span&lt;T&gt; and having a reinterpret. I'm not quite sure though if this means if there is an explicit method for this or if it will be implicit. So maybe you can point me in some direction with the code below and if Span&lt;T&gt; will support it:

I have a filestream where I read my data. Unfortunately there is no ReadArray&lt;T&gt; but only a ReadBytes().
For that reason I have currently following code.



Are there any plans or suggestions?</Description>
    <Title_Description>Introduce reinterpret in Span&lt;T&gt; Hello

I know that there are discussions around Span&lt;T&gt; and having a reinterpret. I'm not quite sure though if this means if there is an explicit method for this or if it will be implicit. So maybe you can point me in some direction with the code below and if Span&lt;T&gt; will support it:

I have a filestream where I read my data. Unfortunately there is no ReadArray&lt;T&gt; but only a ReadBytes().
For that reason I have currently following code.



Are there any plans or suggestions?</Title_Description>
    <Label>area-System.Memory</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>9/08/2018 3:53:00 PM +00:00</CreatedAt>
    <ClosedAt>9/08/2018 5:33:23 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19376</IssueLabelID>
    <Title>CoreClr failed to build on Windows due to MSBUILD ERROR : error MSB1001: Unknown switch. Switch: --</Title>
    <Description>Hello
I am testing CoreCLR on Windows with VS 2017 15.7.2. It failed due to the "error MSB1001: Unknown switch. Switch: --". It casued by commit:https://github.com/dotnet/coreclr/commit/b37c6d8ee5b4ad9833f21cfc30582b56797e37b4.
I noticed you removed '--' on purpose I am surprised why does not support '--' to add  extra MSBUILD options? Is there other way that we can add extra MSBUILD flags when building source!

You can repro the issue as the steps below:
1. git clone https://github.com/dotnet/coreclr D:\CoreCLR\src
2. Open a clean x86 prompt (C:\windows\syswow64\cmd.exe) and browse to D:\CoreCLR\src
3. build x86 release -- /clp:ShowCommandLine

Could you please give me a workaround for this or consider rollback this to use '--' when building?
Thank you!</Description>
    <Title_Description>CoreClr failed to build on Windows due to MSBUILD ERROR : error MSB1001: Unknown switch. Switch: -- Hello
I am testing CoreCLR on Windows with VS 2017 15.7.2. It failed due to the "error MSB1001: Unknown switch. Switch: --". It casued by commit:https://github.com/dotnet/coreclr/commit/b37c6d8ee5b4ad9833f21cfc30582b56797e37b4.
I noticed you removed '--' on purpose I am surprised why does not support '--' to add  extra MSBUILD options? Is there other way that we can add extra MSBUILD flags when building source!

You can repro the issue as the steps below:
1. git clone https://github.com/dotnet/coreclr D:\CoreCLR\src
2. Open a clean x86 prompt (C:\windows\syswow64\cmd.exe) and browse to D:\CoreCLR\src
3. build x86 release -- /clp:ShowCommandLine

Could you please give me a workaround for this or consider rollback this to use '--' when building?
Thank you!</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>BruceForstall</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19374</IssueLabelID>
    <Title>[Question] Strange behavior when loading assemblies and its dependencies programatically</Title>
    <Description>Not sure if it's a bug I asked on SO but it seems no one has idea on it. [Question](https://stackoverflow.com/questions/51738633/strange-behavior-when-loading-assemblies-and-its-dependencies-programatically)</Description>
    <Title_Description>[Question] Strange behavior when loading assemblies and its dependencies programatically Not sure if it's a bug I asked on SO but it seems no one has idea on it. [Question](https://stackoverflow.com/questions/51738633/strange-behavior-when-loading-assemblies-and-its-dependencies-programatically)</Title_Description>
    <Label>area-AssemblyLoader</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>9/08/2018 3:50:23 AM +00:00</CreatedAt>
    <ClosedAt>10/08/2018 10:25:24 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19370</IssueLabelID>
    <Title>JIT generates binary different code in x86_arm and arm_arm due to host NaN representation</Title>
    <Description>It seems that assumption that two crossgens (x86_arm and arm_arm) generate binary identical code is not 100% true. 
I encountered this for 

@dotnet/jit-contrib Is there any better idea how to approach this issue?</Description>
    <Title_Description>JIT generates binary different code in x86_arm and arm_arm due to host NaN representation It seems that assumption that two crossgens (x86_arm and arm_arm) generate binary identical code is not 100% true. 
I encountered this for 

@dotnet/jit-contrib Is there any better idea how to approach this issue?</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>echesakovMSFT</Assignee>
    <CreatedAt>8/08/2018 10:21:54 PM +00:00</CreatedAt>
    <ClosedAt>20/08/2018 5:18:18 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19368</IssueLabelID>
    <Title>[RyuJIT/arm64] Implement ELT hooks</Title>
    <Description>It looks like genProfilingEnterCallback and genProfilingLeaveCallback will NYI on arm64.
</Description>
    <Title_Description>[RyuJIT/arm64] Implement ELT hooks It looks like genProfilingEnterCallback and genProfilingLeaveCallback will NYI on arm64.
</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>echesakovMSFT</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19361</IssueLabelID>
    <Title>Segfault in libcoreclr.so</Title>
    <Description>I'm experiencing a segmentation fault on .NET Core 2 on Linux/docker under versions 2.1.2 and 2.0.9 when my process is under heavy load and using a lot of memory. 

I haven't tried to reproduce outside of Linux/docker but I have reproduced on both AWS Kubernetes and my local Docker for Windows with identical stack traces.

Here are some details from capturing the segfault under the debugger:



I don't have the coredump from this particular crash (because it got OOM killed after calling VerifyHeap!) but most times it crashes the top of the stack is identical to this (see attached file 4 for one of the times it didn't look like this). 

Unfortunately I can't post the code because it's proprietary. We're working on trying to produce a minimal test case but that's a lot easier said than done. However if you have somewhere secure and private to upload core dumps to I could do that.

I have also attached information from the debugger from other crashes (the one above is file 3):

[dumpinfo1.txt](https://github.com/dotnet/coreclr/files/2271414/dumpinfo1.txt)
[dumpinfo2.txt](https://github.com/dotnet/coreclr/files/2271413/dumpinfo2.txt)
[dumpinfo3.txt](https://github.com/dotnet/coreclr/files/2271412/dumpinfo3.txt)
[dumpinfo4.txt](https://github.com/dotnet/coreclr/files/2271415/dumpinfo4.txt)


The environment I set up to reproduce the issue is here: https://github.com/ist-ltd/dotnet-core-debug-helper-tools - but it relies on a private docker image.</Description>
    <Title_Description>Segfault in libcoreclr.so I'm experiencing a segmentation fault on .NET Core 2 on Linux/docker under versions 2.1.2 and 2.0.9 when my process is under heavy load and using a lot of memory. 

I haven't tried to reproduce outside of Linux/docker but I have reproduced on both AWS Kubernetes and my local Docker for Windows with identical stack traces.

Here are some details from capturing the segfault under the debugger:



I don't have the coredump from this particular crash (because it got OOM killed after calling VerifyHeap!) but most times it crashes the top of the stack is identical to this (see attached file 4 for one of the times it didn't look like this). 

Unfortunately I can't post the code because it's proprietary. We're working on trying to produce a minimal test case but that's a lot easier said than done. However if you have somewhere secure and private to upload core dumps to I could do that.

I have also attached information from the debugger from other crashes (the one above is file 3):

[dumpinfo1.txt](https://github.com/dotnet/coreclr/files/2271414/dumpinfo1.txt)
[dumpinfo2.txt](https://github.com/dotnet/coreclr/files/2271413/dumpinfo2.txt)
[dumpinfo3.txt](https://github.com/dotnet/coreclr/files/2271412/dumpinfo3.txt)
[dumpinfo4.txt](https://github.com/dotnet/coreclr/files/2271415/dumpinfo4.txt)


The environment I set up to reproduce the issue is here: https://github.com/ist-ltd/dotnet-core-debug-helper-tools - but it relies on a private docker image.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>sandreenko</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19360</IssueLabelID>
    <Title>Invalid flag causing test build failures in master</Title>
    <Description>Opened on behalf of @MattGal

Maybe something to do with escaping quote characters?



Warnings: 1
Status Message: failed

Build : 3.0 - 20180808.04 (Product Build)
Failing configurations:
- Alpine3.6
  - Build-Tests-R2R-Release
  - Build-Tests-Release
- RedHat6
  - Build-Tests-R2R-Release
  - Build-Tests-Release
- RedHat 7
  - Build-Tests-R2R-Release
  - Build-Tests-Release
- OSX
  - Build-Tests-R2R-Release
  - Build-Tests-Release
- Windows
  - Build-Tests-R2R-Release-arm64
  - Build-Tests-Release-arm64
  - Build-Tests-R2R-Release
  - Build-Tests-Release
[Mission Control Build Info](https://mc.dot.net/#/product/netcore/30/source/official~2Fcoreclr~2Fmaster~2F/type/build~2Fproduct~2F/build/20180808.04/workItem/Orchestration/analysis/external/Link)</Description>
    <Title_Description>Invalid flag causing test build failures in master Opened on behalf of @MattGal

Maybe something to do with escaping quote characters?



Warnings: 1
Status Message: failed

Build : 3.0 - 20180808.04 (Product Build)
Failing configurations:
- Alpine3.6
  - Build-Tests-R2R-Release
  - Build-Tests-Release
- RedHat6
  - Build-Tests-R2R-Release
  - Build-Tests-Release
- RedHat 7
  - Build-Tests-R2R-Release
  - Build-Tests-Release
- OSX
  - Build-Tests-R2R-Release
  - Build-Tests-Release
- Windows
  - Build-Tests-R2R-Release-arm64
  - Build-Tests-Release-arm64
  - Build-Tests-R2R-Release
  - Build-Tests-Release
[Mission Control Build Info](https://mc.dot.net/#/product/netcore/30/source/official~2Fcoreclr~2Fmaster~2F/type/build~2Fproduct~2F/build/20180808.04/workItem/Orchestration/analysis/external/Link)</Title_Description>
    <Label>
    </Label>
    <Assignee>BruceForstall</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19358</IssueLabelID>
    <Title>MS build failure compling test sources</Title>
    <Description>Opened on behalf of @spshant
@russkeldorph Can you please take a look:
2018-08-08T12:59:47.9671610Z E:\A\_work\99\s\tests\publishdependency.targets(915): warning : Your project is not referencing the ".NETCoreAppVersion=v3.0" framework. Add a reference to ".NETCoreAppVersion=v3.0" in the "frameworks" section of your project.json and then re-run NuGet restore. [E:\A\_work\99\s\tests\runtest.proj]
2018-08-08T12:59:47.9672360Z E:\A\_work\99\s\tests\publishdependency.targets(915): warning : Your project is not referencing the ".NETCoreAppVersion=v3.0" framework. Add a reference to ".NETCoreAppVersion=v3.0" in the "frameworks" section of your project.json and then re-run NuGet restore. [E:\A\_work\99\s\tests\runtest.proj]
2018-08-08T12:59:47.9673128Z E:\A\_work\99\s\tests\publishdependency.targets(915): warning : Your project is not referencing the ".NETCoreAppVersion=v3.0" framework. Add a reference to ".NETCoreAppVersion=v3.0" in the "frameworks" section of your project.json and then re-run NuGet restore. [E:\A\_work\99\s\tests\runtest.proj]
2018-08-08T12:59:47.9673619Z     7 Warning(s)
2018-08-08T12:59:47.9673822Z     0 Error(s)
2018-08-08T12:59:47.9674005Z 
2018-08-08T12:59:47.9674211Z Time Elapsed 00:00:00.29
2018-08-08T12:59:47.9854416Z Command execution succeeded.
2018-08-08T12:59:47.9934777Z BUILDTEST: Starting the Managed Tests Build
2018-08-08T12:59:47.9970898Z BUILDTEST: Building tests group 2 with 16 subgroups
2018-08-08T12:59:48.0716070Z MSBUILD : error MSB1001: Unknown switch.
2018-08-08T12:59:48.0716402Z Switch: --
2018-08-08T12:59:48.0716528Z 

Warnings: 1
Status Message: failed

Build : 3.0 - 20180808.04 (Product Build)
Failing configurations:
- Alpine3.6
  - Build-Tests-R2R-Release
- RedHat6
  - Build-Tests-R2R-Release
- RedHat 7
  - Build-Tests-R2R-Release
- OSX
  - Build-Tests-R2R-Release
- Windows
  - Build-Tests-R2R-Release-arm64
  - Build-Tests-R2R-Release
[Mission Control Build Info](https://mc.dot.net/#/product/netcore/30/source/official~2Fcoreclr~2Fmaster~2F/type/build~2Fproduct~2F/build/20180808.04/workItem/Orchestration/analysis/external/Link)</Description>
    <Title_Description>MS build failure compling test sources Opened on behalf of @spshant
@russkeldorph Can you please take a look:
2018-08-08T12:59:47.9671610Z E:\A\_work\99\s\tests\publishdependency.targets(915): warning : Your project is not referencing the ".NETCoreAppVersion=v3.0" framework. Add a reference to ".NETCoreAppVersion=v3.0" in the "frameworks" section of your project.json and then re-run NuGet restore. [E:\A\_work\99\s\tests\runtest.proj]
2018-08-08T12:59:47.9672360Z E:\A\_work\99\s\tests\publishdependency.targets(915): warning : Your project is not referencing the ".NETCoreAppVersion=v3.0" framework. Add a reference to ".NETCoreAppVersion=v3.0" in the "frameworks" section of your project.json and then re-run NuGet restore. [E:\A\_work\99\s\tests\runtest.proj]
2018-08-08T12:59:47.9673128Z E:\A\_work\99\s\tests\publishdependency.targets(915): warning : Your project is not referencing the ".NETCoreAppVersion=v3.0" framework. Add a reference to ".NETCoreAppVersion=v3.0" in the "frameworks" section of your project.json and then re-run NuGet restore. [E:\A\_work\99\s\tests\runtest.proj]
2018-08-08T12:59:47.9673619Z     7 Warning(s)
2018-08-08T12:59:47.9673822Z     0 Error(s)
2018-08-08T12:59:47.9674005Z 
2018-08-08T12:59:47.9674211Z Time Elapsed 00:00:00.29
2018-08-08T12:59:47.9854416Z Command execution succeeded.
2018-08-08T12:59:47.9934777Z BUILDTEST: Starting the Managed Tests Build
2018-08-08T12:59:47.9970898Z BUILDTEST: Building tests group 2 with 16 subgroups
2018-08-08T12:59:48.0716070Z MSBUILD : error MSB1001: Unknown switch.
2018-08-08T12:59:48.0716402Z Switch: --
2018-08-08T12:59:48.0716528Z 

Warnings: 1
Status Message: failed

Build : 3.0 - 20180808.04 (Product Build)
Failing configurations:
- Alpine3.6
  - Build-Tests-R2R-Release
- RedHat6
  - Build-Tests-R2R-Release
- RedHat 7
  - Build-Tests-R2R-Release
- OSX
  - Build-Tests-R2R-Release
- Windows
  - Build-Tests-R2R-Release-arm64
  - Build-Tests-R2R-Release
[Mission Control Build Info](https://mc.dot.net/#/product/netcore/30/source/official~2Fcoreclr~2Fmaster~2F/type/build~2Fproduct~2F/build/20180808.04/workItem/Orchestration/analysis/external/Link)</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19357</IssueLabelID>
    <Title>Report a better error message when assembly version conflict is encountered</Title>
    <Description>I’m seeing very odd intermittent failures on .NET Core 2.1.400-preview-009088 when loading a dependency from a build task.

An example of such failure is https://devdiv.visualstudio.com/DevDiv/_build/results?buildId=1916424&amp;_a=summary&amp;view=logs 

E:\A\_work\154\s\.packages\microsoft.dotnet.arcade.sdk\1.0.0-prerelease-63202-02\tools\Sign.proj(395): error MSB4018: System.IO.FileLoadException: Could not load file or assembly 'System.IO.Packaging Version=4.0.3.0 Culture=neutral PublicKeyToken=b03f5f7f11d50a3a'. Could not find or load a specific file. (Exception from HRESULT: 0x80131621)
E:\A\_work\154\s\.packages\microsoft.dotnet.arcade.sdk\1.0.0-prerelease-63202-02\tools\Sign.proj(395): error MSB4018: File name: 'System.IO.Packaging Version=4.0.3.0 Culture=neutral PublicKeyToken=b03f5f7f11d50a3a'

The file being loaded (System.IO.Packaging) is located in the same directory as the build task assembly.

Memory dump: %internal_share%\tomat\Bugs\CoreLoaderBug

Turns out we have two tasks that depend on a different version of System.IO.Packaging - 4.0.2.0 and 4.0.3.0. The load error is intermittent since it depends on the order in which these two versions are loaded. The solution to this problem would be to load tasks to separate Assembly Load Contexts: https://github.com/Microsoft/msbuild/issues/1754.

However the assembly loader should report an error that indicates the version mismatch instead of the above error.</Description>
    <Title_Description>Report a better error message when assembly version conflict is encountered I’m seeing very odd intermittent failures on .NET Core 2.1.400-preview-009088 when loading a dependency from a build task.

An example of such failure is https://devdiv.visualstudio.com/DevDiv/_build/results?buildId=1916424&amp;_a=summary&amp;view=logs 

E:\A\_work\154\s\.packages\microsoft.dotnet.arcade.sdk\1.0.0-prerelease-63202-02\tools\Sign.proj(395): error MSB4018: System.IO.FileLoadException: Could not load file or assembly 'System.IO.Packaging Version=4.0.3.0 Culture=neutral PublicKeyToken=b03f5f7f11d50a3a'. Could not find or load a specific file. (Exception from HRESULT: 0x80131621)
E:\A\_work\154\s\.packages\microsoft.dotnet.arcade.sdk\1.0.0-prerelease-63202-02\tools\Sign.proj(395): error MSB4018: File name: 'System.IO.Packaging Version=4.0.3.0 Culture=neutral PublicKeyToken=b03f5f7f11d50a3a'

The file being loaded (System.IO.Packaging) is located in the same directory as the build task assembly.

Memory dump: %internal_share%\tomat\Bugs\CoreLoaderBug

Turns out we have two tasks that depend on a different version of System.IO.Packaging - 4.0.2.0 and 4.0.3.0. The load error is intermittent since it depends on the order in which these two versions are loaded. The solution to this problem would be to load tasks to separate Assembly Load Contexts: https://github.com/Microsoft/msbuild/issues/1754.

However the assembly loader should report an error that indicates the version mismatch instead of the above error.</Title_Description>
    <Label>area-AssemblyLoader</Label>
    <Assignee>tmat</Assignee>
    <CreatedAt>8/08/2018 4:42:53 PM +00:00</CreatedAt>
    <ClosedAt>10/08/2018 10:16:03 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19355</IssueLabelID>
    <Title>Slowdown of code when doing subtraction of ints.</Title>
    <Description>[Reproduction repo](https://github.com/aensidhe/dotnet-core-minus-regression)

**Problem**

Code with writing  class but it's of much smaller magnitude.

If we choose smaller ints (like 200 not 1&lt;&lt;30) it will not change anything.</Description>
    <Title_Description>Slowdown of code when doing subtraction of ints. [Reproduction repo](https://github.com/aensidhe/dotnet-core-minus-regression)

**Problem**

Code with writing  class but it's of much smaller magnitude.

If we choose smaller ints (like 200 not 1&lt;&lt;30) it will not change anything.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>mikedn</Assignee>
    <CreatedAt>8/08/2018 1:59:12 PM +00:00</CreatedAt>
    <ClosedAt>25/01/2019 9:37:14 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19352</IssueLabelID>
    <Title>Add PInvoke/Structures tests</Title>
    <Description>
    </Description>
    <Title_Description>Add PInvoke/Structures tests </Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jkoritzinsky</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19348</IssueLabelID>
    <Title>Add PInvoke/SizeParamIndex tests</Title>
    <Description>
    </Description>
    <Title_Description>Add PInvoke/SizeParamIndex tests </Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jkoritzinsky</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19347</IssueLabelID>
    <Title>Assert failure: !IsAfContentType_WindowsRuntime(pModule-&gt;GetAssemblyRefFlags(tkType))</Title>
    <Description>Seen in Ubuntu arm32 Checked R2R testing:

https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/arm_cross_checked_ubuntu_r2r_flow/20/

Also e.g. Ubuntu x64 Checked R2R:

https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64/job/x64_checked_ubuntu_r2r_flow/2364/

</Description>
    <Title_Description>Assert failure: !IsAfContentType_WindowsRuntime(pModule-&gt;GetAssemblyRefFlags(tkType)) Seen in Ubuntu arm32 Checked R2R testing:

https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/arm_cross_checked_ubuntu_r2r_flow/20/

Also e.g. Ubuntu x64 Checked R2R:

https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64/job/x64_checked_ubuntu_r2r_flow/2364/

</Title_Description>
    <Label>area-ReadyToRun</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>8/08/2018 5:25:08 AM +00:00</CreatedAt>
    <ClosedAt>13/08/2018 12:09:56 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19346</IssueLabelID>
    <Title>Assertion failed 'varDsc-&gt;lvImplicitlyReferenced'</Title>
    <Description>Looks like a regression due to https://github.com/dotnet/coreclr/pull/19325

https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64/job/checked_windows_nt/10114/consoleText

3 failures e.g.


@AndyAyersMS 
cc @dotnet/jit-contrib </Description>
    <Title_Description>Assertion failed 'varDsc-&gt;lvImplicitlyReferenced' Looks like a regression due to https://github.com/dotnet/coreclr/pull/19325

https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64/job/checked_windows_nt/10114/consoleText

3 failures e.g.


@AndyAyersMS 
cc @dotnet/jit-contrib </Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19341</IssueLabelID>
    <Title>WIP NO-MERGE Dummy change</Title>
    <Description>
    </Description>
    <Title_Description>WIP NO-MERGE Dummy change </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>7/08/2018 10:23:39 PM +00:00</CreatedAt>
    <ClosedAt>9/08/2018 3:13:43 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19340</IssueLabelID>
    <Title>Test failure in tracing\runtimeeventsource\runtimeeventsource\runtimeeventsource.cmd</Title>
    <Description>There is a recent regression in tracing\runtimeeventsource\runtimeeventsource\runtimeeventsource.cmd in (at least?) the Window x64 zapdisable test leg run with:


</Description>
    <Title_Description>Test failure in tracing\runtimeeventsource\runtimeeventsource\runtimeeventsource.cmd There is a recent regression in tracing\runtimeeventsource\runtimeeventsource\runtimeeventsource.cmd in (at least?) the Window x64 zapdisable test leg run with:


</Title_Description>
    <Label>area-Tracing</Label>
    <Assignee>jorive</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19339</IssueLabelID>
    <Title>GThread inconsistent test failures</Title>
    <Description>I see inconsistent failures in baseservices\threading\generics\threadstart\GThread23\GThread23.cmd as well as GThread22 GThread24 for Windows x64 Checked test jobs in the CI. Looks like timeouts:



Overall: https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64/job/checked_windows_nt/

Also saw one timeout in Regressions\coreclr\1514\InterlockExchange\InterlockExchange.cmd
</Description>
    <Title_Description>GThread inconsistent test failures I see inconsistent failures in baseservices\threading\generics\threadstart\GThread23\GThread23.cmd as well as GThread22 GThread24 for Windows x64 Checked test jobs in the CI. Looks like timeouts:



Overall: https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64/job/checked_windows_nt/

Also saw one timeout in Regressions\coreclr\1514\InterlockExchange\InterlockExchange.cmd
</Title_Description>
    <Label>area-System.Threading</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>7/08/2018 9:31:22 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19337</IssueLabelID>
    <Title>PDBs for crossgenned binaries on Linux/macOS?</Title>
    <Description>I've been working on https://github.com/PowerShell/PowerShell/issues/7348 trying to get symbols available for PowerShell releases.

It looks like PDB generation for crossgen builds is:
 - possible on Windows with https://github.com/dotnet/coreclr/pull/4572
 - but not possible on Linux/macOS with DiaSymReader not open source (based on https://github.com/dotnet/coreclr/issues/8175)

Is that still correct?

Just want to register that PowerShell would get use out of PDBs for crossgen builds on Linux/macOS.</Description>
    <Title_Description>PDBs for crossgenned binaries on Linux/macOS? I've been working on https://github.com/PowerShell/PowerShell/issues/7348 trying to get symbols available for PowerShell releases.

It looks like PDB generation for crossgen builds is:
 - possible on Windows with https://github.com/dotnet/coreclr/pull/4572
 - but not possible on Linux/macOS with DiaSymReader not open source (based on https://github.com/dotnet/coreclr/issues/8175)

Is that still correct?

Just want to register that PowerShell would get use out of PDBs for crossgen builds on Linux/macOS.</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>7/08/2018 8:27:21 PM +00:00</CreatedAt>
    <ClosedAt>7/08/2018 8:59:32 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19333</IssueLabelID>
    <Title>[automated] Merge branch 'release/2.1' =&gt; 'release/2.2'</Title>
    <Description>I detected changes in the release/2.1 branch which have not been merged yet to release/2.2.
I'm a robot and am configured to help you automatically keep release/2.2 up to date so
I've opened this PR.

This PR merges commits made on release/2.1 by the following committers:

* @joshfree

## Instructions for merging

This PR will not be auto-merged. When pull request checks pass please complete this PR
by creating a merge commit *not* a squash or rebase commit.

&lt;img alt="merge button instructions" src="https://i.imgur.com/GepcNJV.png" width="300" /&gt;

You can also do this on command line:


:warning: If there are merge conflicts you will need to resolve them manually before merging.

Please contact ASP.NET Core Engineering if you have questions or issues.
Also if this PR was generated incorrectly help us fix it. See https://github.com/aspnet/BuildTools/blob/master/scripts/GitHubMergeBranches.ps1.</Description>
    <Title_Description>[automated] Merge branch 'release/2.1' =&gt; 'release/2.2' I detected changes in the release/2.1 branch which have not been merged yet to release/2.2.
I'm a robot and am configured to help you automatically keep release/2.2 up to date so
I've opened this PR.

This PR merges commits made on release/2.1 by the following committers:

* @joshfree

## Instructions for merging

This PR will not be auto-merged. When pull request checks pass please complete this PR
by creating a merge commit *not* a squash or rebase commit.

&lt;img alt="merge button instructions" src="https://i.imgur.com/GepcNJV.png" width="300" /&gt;

You can also do this on command line:


:warning: If there are merge conflicts you will need to resolve them manually before merging.

Please contact ASP.NET Core Engineering if you have questions or issues.
Also if this PR was generated incorrectly help us fix it. See https://github.com/aspnet/BuildTools/blob/master/scripts/GitHubMergeBranches.ps1.</Title_Description>
    <Label>os-tizen</Label>
    <Assignee>wtgodbe</Assignee>
    <CreatedAt>7/08/2018 5:23:14 PM +00:00</CreatedAt>
    <ClosedAt>8/08/2018 6:03:05 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19330</IssueLabelID>
    <Title>Add PInvoke/SafeHandles tests</Title>
    <Description>
    </Description>
    <Title_Description>Add PInvoke/SafeHandles tests </Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jkoritzinsky</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19328</IssueLabelID>
    <Title>Add PInvoke/NativeCallManagedComVisible tests</Title>
    <Description>
    </Description>
    <Title_Description>Add PInvoke/NativeCallManagedComVisible tests </Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jkoritzinsky</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19327</IssueLabelID>
    <Title>Bad check test count</Title>
    <Description>
    </Description>
    <Title_Description>Bad check test count </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>7/08/2018 6:19:13 AM +00:00</CreatedAt>
    <ClosedAt>7/08/2018 9:58:27 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19326</IssueLabelID>
    <Title>Add PInvoke/Miscellaneous tests</Title>
    <Description>
    </Description>
    <Title_Description>Add PInvoke/Miscellaneous tests </Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jkoritzinsky</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19324</IssueLabelID>
    <Title>Use dotnet MSBuild for tests</Title>
    <Description>Revert the revert of #19254

cc @BruceForstall @chsienki </Description>
    <Title_Description>Use dotnet MSBuild for tests Revert the revert of #19254

cc @BruceForstall @chsienki </Title_Description>
    <Label>test enhancement</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>7/08/2018 2:56:10 AM +00:00</CreatedAt>
    <ClosedAt>8/08/2018 12:42:16 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19323</IssueLabelID>
    <Title>Add PInvoke/Delegate tests</Title>
    <Description>
    </Description>
    <Title_Description>Add PInvoke/Delegate tests </Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jkoritzinsky</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19322</IssueLabelID>
    <Title>some methods unexpectedly bypass tier0 jitting and go straight to tier1</Title>
    <Description>Noticed this while messing about with the interpreter. A few methods from corelib unexpectedly end up getting jitted initially at tier1 and bypass tier0. 

@kouvel compiled this list for MusicStore:

These all seem to be methods that use Vector or HW intrinsics. So perhaps when they bail out from crossgen something important gets bypassed and as a result tiering thinks that they're not tiering-eligible.

cc @noahfalk </Description>
    <Title_Description>some methods unexpectedly bypass tier0 jitting and go straight to tier1 Noticed this while messing about with the interpreter. A few methods from corelib unexpectedly end up getting jitted initially at tier1 and bypass tier0. 

@kouvel compiled this list for MusicStore:

These all seem to be methods that use Vector or HW intrinsics. So perhaps when they bail out from crossgen something important gets bypassed and as a result tiering thinks that they're not tiering-eligible.

cc @noahfalk </Title_Description>
    <Label>area-TieredCompilation</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19317</IssueLabelID>
    <Title>spmi shim counter accesses mcs before it is initialized</Title>
    <Description>To repro: build then set up environment:




</Description>
    <Title_Description>spmi shim counter accesses mcs before it is initialized To repro: build then set up environment:




</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>sandreenko</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19309</IssueLabelID>
    <Title>Only register signals and create alt exception stack in coreclr.</Title>
    <Description>There was a couple of places where the DAC (IsValidObject GetAppDomainForObject)
assumed that a NULL target/debuggee address would throw an exception that would
be caught by try/catch. Any other invalid address is handled with a software
exception throwed by the read memory functions. In general it is a better overall
design not to have any of the DBI/DAC etc. code depend on hardware exceptions
being caught. On Linux the C++ runtime sometimes can't handle it. There is a
slight risk that there are other places in the DAC that make the NULL address
assumption but testing so far has found any.

Added PAL_SetInitializeDLLFlags as a fallback to allow the PAL_InitializeDLL flags
to be set for a PAL instance for the DAC where we could still register h/w signals
but not the altstack switching to reduce this risk. The flags can't be build time
conditional because we only build one coreclrpal.a library that all the modules
used. Having a PAL_InitializeFlags function doesn't really help either because of
the PAL_RegisterModule call to PAL_IntializeDLL and the LoadLibrary dance/protocol
that uses it to call the loading module's DLLMain.

Remove flags from PAL_INITIALIZE and PAL_INITIALIZE_DLL default. Add PAL_InitializeFlags()
to allow the default to be overridden.</Description>
    <Title_Description>Only register signals and create alt exception stack in coreclr. There was a couple of places where the DAC (IsValidObject GetAppDomainForObject)
assumed that a NULL target/debuggee address would throw an exception that would
be caught by try/catch. Any other invalid address is handled with a software
exception throwed by the read memory functions. In general it is a better overall
design not to have any of the DBI/DAC etc. code depend on hardware exceptions
being caught. On Linux the C++ runtime sometimes can't handle it. There is a
slight risk that there are other places in the DAC that make the NULL address
assumption but testing so far has found any.

Added PAL_SetInitializeDLLFlags as a fallback to allow the PAL_InitializeDLL flags
to be set for a PAL instance for the DAC where we could still register h/w signals
but not the altstack switching to reduce this risk. The flags can't be build time
conditional because we only build one coreclrpal.a library that all the modules
used. Having a PAL_InitializeFlags function doesn't really help either because of
the PAL_RegisterModule call to PAL_IntializeDLL and the LoadLibrary dance/protocol
that uses it to call the loading module's DLLMain.

Remove flags from PAL_INITIALIZE and PAL_INITIALIZE_DLL default. Add PAL_InitializeFlags()
to allow the default to be overridden.</Title_Description>
    <Label>
    </Label>
    <Assignee>mikem8361</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19308</IssueLabelID>
    <Title>Fix type of cast node generated by box import</Title>
    <Description>Importing box to primitive type may produce a cast node that has "incorrect" type:
https://github.com/dotnet/coreclr/blob/ac8f8e52c49b0ffa712d68730a41883d281bea01/src/jit/importer.cpp#L5681
Normally the type of the cast node is </Description>
    <Title_Description>Fix type of cast node generated by box import Importing box to primitive type may produce a cast node that has "incorrect" type:
https://github.com/dotnet/coreclr/blob/ac8f8e52c49b0ffa712d68730a41883d281bea01/src/jit/importer.cpp#L5681
Normally the type of the cast node is </Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>6/08/2018 4:51:47 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19307</IssueLabelID>
    <Title>Support for reflection-invoking methods that take pointers by reference</Title>
    <Description>dotnet/coreclr#17732 added support for reflection-invoking methods that return unmanaged pointers by reference (so e.g. .

(Note this behavior is on parity with the desktop CLR so it has quite likely been this broken for 17 years.)</Description>
    <Title_Description>Support for reflection-invoking methods that take pointers by reference dotnet/coreclr#17732 added support for reflection-invoking methods that return unmanaged pointers by reference (so e.g. .

(Note this behavior is on parity with the desktop CLR so it has quite likely been this broken for 17 years.)</Title_Description>
    <Label>area-System.Reflection</Label>
    <Assignee>MichalStrehovsky</Assignee>
    <CreatedAt>6/08/2018 4:07:30 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19304</IssueLabelID>
    <Title>Add PInvoke/Primitives/Int tests</Title>
    <Description>
    </Description>
    <Title_Description>Add PInvoke/Primitives/Int tests </Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jkoritzinsky</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19303</IssueLabelID>
    <Title>Add PInvoke/ExactSpelling tests</Title>
    <Description>
    </Description>
    <Title_Description>Add PInvoke/ExactSpelling tests </Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jkoritzinsky</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19302</IssueLabelID>
    <Title>Test failure: tracing_eventsource._eventpipeandetw_eventpipeandetw_eventpipeandetw_/_eventpipeandetw_eventpipeandetw_eventpipeandetw_cmd</Title>
    <Description>Opened on behalf of @Sunny-pu

The test  has failed.


    Unhandled Exception: System.InvalidOperationException: TdhEnumerateProviders failed.\r
       at Microsoft.Diagnostics.Tracing.Session.TraceEventSession.get_ProviderNameToGuid()\r
       at Microsoft.Diagnostics.Tracing.Session.TraceEventProviders.GetProviderGuidByName(String name)\r
       at Microsoft.Diagnostics.Tracing.Session.TraceEventSession.EnableProvider(String providerName TraceEventLevel providerLevel UInt64 matchAnyKeywords TraceEventProviderOptions options)\r
       at Tracing.Tests.EventPipeAndEtw.EnableETW(EventSource eventSource EventKeywords keywords String outputFile) in E:\\A\\_work\\138\\s\\tests\\src\\tracing\\eventsource\\eventpipeandetw\\EventPipeAndEtw.cs:line 113\r
       at Tracing.Tests.EventPipeAndEtw.RoundOne(String[] args) in E:\\A\\_work\\138\\s\\tests\\src\\tracing\\eventsource\\eventpipeandetw\\EventPipeAndEtw.cs:line 144\r
       at Tracing.Tests.EventPipeAndEtw.Main(String[] args) in E:\\A\\_work\\138\\s\\tests\\src\\tracing\\eventsource\\eventpipeandetw\\EventPipeAndEtw.cs:line 287
    
    
    Return code:      1
    Raw output file:      C:\\work\\f2125dcf-0985-4d70-b7d0-00824a6edc84\\Work\\c8415983-ece0-46e7-b42d-256fbc794b63\\Unzip\\Reports\\tracing.eventsource\\eventpipeandetw\\eventpipeandetw\\eventpipeandetw.output.txt
    Raw output:
    BEGIN EXECUTION\r
            1 file(s) copied.\r
    \" C:\\work\\f2125dcf-0985-4d70-b7d0-00824a6edc84\\Payload\\crossgen.exe\" /Platform_Assemblies_Paths C:\\work\\f2125dcf-0985-4d70-b7d0-00824a6edc84\\Payload;C:\\work\\f2125dcf-0985-4d70-b7d0-00824a6edc84\\Work\\c8415983-ece0-46e7-b42d-256fbc794b63\\Unzip\\eventpipeandetw\\eventpipeandetw\\IL;C:\\work\\f2125dcf-0985-4d70-b7d0-00824a6edc84\\Work\\c8415983-ece0-46e7-b42d-256fbc794b63\\Unzip\\eventpipeandetw\\eventpipeandetw /in eventpipeandetw.org /out eventpipeandetw.exe\r
    Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0\r
    Copyright (c) Microsoft Corporation.  All rights reserved.\r
    \r
    Native image eventpipeandetw.exe generated successfully.\r
     \"C:\\work\\f2125dcf-0985-4d70-b7d0-00824a6edc84\\Payload\\corerun.exe\" eventpipeandetw.exe \r
    \tStart: Enable EventPipe.\r
    \tEnd: Enable EventPipe.
    \r
    \tStart: Enable ETW.\r
    Expected: 100\r
    Actual: -532462766\r
    END EXECUTION - FAILED\r
    FAILED\r
    Test Harness Exitcode is : 1\r
    
    To run the test:
    &gt; set CORE_ROOT=C:\\work\\f2125dcf-0985-4d70-b7d0-00824a6edc84\\Payload
    &gt; C:\\work\\f2125dcf-0985-4d70-b7d0-00824a6edc84\\Work\\c8415983-ece0-46e7-b42d-256fbc794b63\\Unzip\\eventpipeandetw\\eventpipeandetw\\eventpipeandetw.cmd
    \r
    Expected: True\r
    Actual:   False

        Stack Trace:

        
Build : 3.0 - 20180806.01 (Ready-To-Run Tests)
Failing configurations:
- Windows.10.Nano.Amd64
  - x64

Details: https://mc.dot.net/#/product/netcore/30/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fr2r~2Fcli~2F/build/20180806.01/workItem/tracing.eventsource.XUnitWrapper/analysis/xunit/tracing_eventsource._eventpipeandetw_eventpipeandetw_eventpipeandetw_~2F_eventpipeandetw_eventpipeandetw_eventpipeandetw_cmd</Description>
    <Title_Description>Test failure: tracing_eventsource._eventpipeandetw_eventpipeandetw_eventpipeandetw_/_eventpipeandetw_eventpipeandetw_eventpipeandetw_cmd Opened on behalf of @Sunny-pu

The test  has failed.


    Unhandled Exception: System.InvalidOperationException: TdhEnumerateProviders failed.\r
       at Microsoft.Diagnostics.Tracing.Session.TraceEventSession.get_ProviderNameToGuid()\r
       at Microsoft.Diagnostics.Tracing.Session.TraceEventProviders.GetProviderGuidByName(String name)\r
       at Microsoft.Diagnostics.Tracing.Session.TraceEventSession.EnableProvider(String providerName TraceEventLevel providerLevel UInt64 matchAnyKeywords TraceEventProviderOptions options)\r
       at Tracing.Tests.EventPipeAndEtw.EnableETW(EventSource eventSource EventKeywords keywords String outputFile) in E:\\A\\_work\\138\\s\\tests\\src\\tracing\\eventsource\\eventpipeandetw\\EventPipeAndEtw.cs:line 113\r
       at Tracing.Tests.EventPipeAndEtw.RoundOne(String[] args) in E:\\A\\_work\\138\\s\\tests\\src\\tracing\\eventsource\\eventpipeandetw\\EventPipeAndEtw.cs:line 144\r
       at Tracing.Tests.EventPipeAndEtw.Main(String[] args) in E:\\A\\_work\\138\\s\\tests\\src\\tracing\\eventsource\\eventpipeandetw\\EventPipeAndEtw.cs:line 287
    
    
    Return code:      1
    Raw output file:      C:\\work\\f2125dcf-0985-4d70-b7d0-00824a6edc84\\Work\\c8415983-ece0-46e7-b42d-256fbc794b63\\Unzip\\Reports\\tracing.eventsource\\eventpipeandetw\\eventpipeandetw\\eventpipeandetw.output.txt
    Raw output:
    BEGIN EXECUTION\r
            1 file(s) copied.\r
    \" C:\\work\\f2125dcf-0985-4d70-b7d0-00824a6edc84\\Payload\\crossgen.exe\" /Platform_Assemblies_Paths C:\\work\\f2125dcf-0985-4d70-b7d0-00824a6edc84\\Payload;C:\\work\\f2125dcf-0985-4d70-b7d0-00824a6edc84\\Work\\c8415983-ece0-46e7-b42d-256fbc794b63\\Unzip\\eventpipeandetw\\eventpipeandetw\\IL;C:\\work\\f2125dcf-0985-4d70-b7d0-00824a6edc84\\Work\\c8415983-ece0-46e7-b42d-256fbc794b63\\Unzip\\eventpipeandetw\\eventpipeandetw /in eventpipeandetw.org /out eventpipeandetw.exe\r
    Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0\r
    Copyright (c) Microsoft Corporation.  All rights reserved.\r
    \r
    Native image eventpipeandetw.exe generated successfully.\r
     \"C:\\work\\f2125dcf-0985-4d70-b7d0-00824a6edc84\\Payload\\corerun.exe\" eventpipeandetw.exe \r
    \tStart: Enable EventPipe.\r
    \tEnd: Enable EventPipe.
    \r
    \tStart: Enable ETW.\r
    Expected: 100\r
    Actual: -532462766\r
    END EXECUTION - FAILED\r
    FAILED\r
    Test Harness Exitcode is : 1\r
    
    To run the test:
    &gt; set CORE_ROOT=C:\\work\\f2125dcf-0985-4d70-b7d0-00824a6edc84\\Payload
    &gt; C:\\work\\f2125dcf-0985-4d70-b7d0-00824a6edc84\\Work\\c8415983-ece0-46e7-b42d-256fbc794b63\\Unzip\\eventpipeandetw\\eventpipeandetw\\eventpipeandetw.cmd
    \r
    Expected: True\r
    Actual:   False

        Stack Trace:

        
Build : 3.0 - 20180806.01 (Ready-To-Run Tests)
Failing configurations:
- Windows.10.Nano.Amd64
  - x64

Details: https://mc.dot.net/#/product/netcore/30/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fr2r~2Fcli~2F/build/20180806.01/workItem/tracing.eventsource.XUnitWrapper/analysis/xunit/tracing_eventsource._eventpipeandetw_eventpipeandetw_eventpipeandetw_~2F_eventpipeandetw_eventpipeandetw_eventpipeandetw_cmd</Title_Description>
    <Label>area-Tracing</Label>
    <Assignee>jorive</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19301</IssueLabelID>
    <Title>Add PInvoke/Decimal tests</Title>
    <Description>Fixes #18908</Description>
    <Title_Description>Add PInvoke/Decimal tests Fixes #18908</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jkoritzinsky</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19300</IssueLabelID>
    <Title>Cannot run linux-arm64 published binary on CentOS 7 ARM64: GLIBCXX_3.4.21 not found</Title>
    <Description>The nuget packages built for linux-arm64 uses higher GLIBCXX versions than that on CentOS 7.

Steps to reproduce:
On a x86_64 machine with latest .NET Core SDK installed:
</Description>
    <Title_Description>Cannot run linux-arm64 published binary on CentOS 7 ARM64: GLIBCXX_3.4.21 not found The nuget packages built for linux-arm64 uses higher GLIBCXX versions than that on CentOS 7.

Steps to reproduce:
On a x86_64 machine with latest .NET Core SDK installed:
</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>6/08/2018 7:45:03 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19299</IssueLabelID>
    <Title>Test failure: JIT_HardwareIntrinsics._X86_Avx_Avx_ro_Avx_ro_/_X86_Avx_Avx_ro_Avx_ro_cmd</Title>
    <Description>Opened on behalf of @Sunny-pu

The test  has failed.

/Users/dotnet-bot/dotnetbuild/work/94bf0b1f-9c0f-4b51-8b45-bc2c3b20cff7/Work/acf3d313-bf55-4ff6-952f-68bfbb7b9dbf/Unzip/X86/Avx/Avx_ro/Avx_ro.sh: line 244: 76085 Abort trap: 6           $_DebuggerFullPath \"$CORE_ROOT/corerun\" $ExePath $CLRTestExecutionArguments
    
    
    Return code:      1
    Raw output file:      /Users/dotnet-bot/dotnetbuild/work/94bf0b1f-9c0f-4b51-8b45-bc2c3b20cff7/Work/acf3d313-bf55-4ff6-952f-68bfbb7b9dbf/Unzip/Reports\\JIT.HardwareIntrinsics\\X86\\Avx\\Avx_ro\\Avx_ro.output.txt
    Raw output:
    BEGIN EXECUTION
    /Users/dotnet-bot/dotnetbuild/work/94bf0b1f-9c0f-4b51-8b45-bc2c3b20cff7/Payload/corerun Avx_ro.exe
    Supported ISAs:
      AES:       False
      AVX:       True
      AVX2:      False
      BMI1:      False
      BMI2:      False
      FMA:       False
      LZCNT:     False
      PCLMULQDQ: False
      POPCNT:    True
      SSE:       True
      SSE2:      True
      SSE3:      True
      SSE4.1:    True
      SSE4.2:    True
      SSSE3:     True
    
    Beginning test case Add.Double at 08/05/2018 19:26:15
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case Add.Single at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case AddSubtract.Double at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case AddSubtract.Single at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case And.Double at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case And.Single at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case AndNot.Double at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case AndNot.Single at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case BlendVariable.Double at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case BlendVariable.Single at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case Ceiling.Double at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case Ceiling.Single at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case Divide.Double at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case Divide.Single at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case DuplicateEvenIndexed.Double at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case DuplicateEvenIndexed.Single at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case DuplicateOddIndexed.Single at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case Extract.Byte.1 at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    Expected: 100
    Actual: 134
    END EXECUTION - FAILED
    Test Harness Exitcode is : 1
    
    To run the test:
    &gt; set CORE_ROOT=/Users/dotnet-bot/dotnetbuild/work/94bf0b1f-9c0f-4b51-8b45-bc2c3b20cff7/Payload
    &gt; /Users/dotnet-bot/dotnetbuild/work/94bf0b1f-9c0f-4b51-8b45-bc2c3b20cff7/Work/acf3d313-bf55-4ff6-952f-68bfbb7b9dbf/Unzip/X86/Avx/Avx_ro/Avx_ro.sh
    
    Expected: True
    Actual:   False

        Stack Trace:

        
Build : 3.0 - 20180806.01 (Core Tests)
Failing configurations:
- osx.1013.amd64-x64
  - 
- osx.1012.amd64-x64
  - 

Details: https://mc.dot.net/#/product/netcore/30/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fcli~2F/build/20180806.01/workItem/JIT.HardwareIntrinsics.XUnitWrapper/analysis/xunit/JIT_HardwareIntrinsics._X86_Avx_Avx_ro_Avx_ro_~2F_X86_Avx_Avx_ro_Avx_ro_cmd</Description>
    <Title_Description>Test failure: JIT_HardwareIntrinsics._X86_Avx_Avx_ro_Avx_ro_/_X86_Avx_Avx_ro_Avx_ro_cmd Opened on behalf of @Sunny-pu

The test  has failed.

/Users/dotnet-bot/dotnetbuild/work/94bf0b1f-9c0f-4b51-8b45-bc2c3b20cff7/Work/acf3d313-bf55-4ff6-952f-68bfbb7b9dbf/Unzip/X86/Avx/Avx_ro/Avx_ro.sh: line 244: 76085 Abort trap: 6           $_DebuggerFullPath \"$CORE_ROOT/corerun\" $ExePath $CLRTestExecutionArguments
    
    
    Return code:      1
    Raw output file:      /Users/dotnet-bot/dotnetbuild/work/94bf0b1f-9c0f-4b51-8b45-bc2c3b20cff7/Work/acf3d313-bf55-4ff6-952f-68bfbb7b9dbf/Unzip/Reports\\JIT.HardwareIntrinsics\\X86\\Avx\\Avx_ro\\Avx_ro.output.txt
    Raw output:
    BEGIN EXECUTION
    /Users/dotnet-bot/dotnetbuild/work/94bf0b1f-9c0f-4b51-8b45-bc2c3b20cff7/Payload/corerun Avx_ro.exe
    Supported ISAs:
      AES:       False
      AVX:       True
      AVX2:      False
      BMI1:      False
      BMI2:      False
      FMA:       False
      LZCNT:     False
      PCLMULQDQ: False
      POPCNT:    True
      SSE:       True
      SSE2:      True
      SSE3:      True
      SSE4.1:    True
      SSE4.2:    True
      SSSE3:     True
    
    Beginning test case Add.Double at 08/05/2018 19:26:15
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case Add.Single at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case AddSubtract.Double at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case AddSubtract.Single at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case And.Double at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case And.Single at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case AndNot.Double at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case AndNot.Single at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case BlendVariable.Double at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case BlendVariable.Single at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case Ceiling.Double at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case Ceiling.Single at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case Divide.Double at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case Divide.Single at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case DuplicateEvenIndexed.Double at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case DuplicateEvenIndexed.Single at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case DuplicateOddIndexed.Single at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case Extract.Byte.1 at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    Expected: 100
    Actual: 134
    END EXECUTION - FAILED
    Test Harness Exitcode is : 1
    
    To run the test:
    &gt; set CORE_ROOT=/Users/dotnet-bot/dotnetbuild/work/94bf0b1f-9c0f-4b51-8b45-bc2c3b20cff7/Payload
    &gt; /Users/dotnet-bot/dotnetbuild/work/94bf0b1f-9c0f-4b51-8b45-bc2c3b20cff7/Work/acf3d313-bf55-4ff6-952f-68bfbb7b9dbf/Unzip/X86/Avx/Avx_ro/Avx_ro.sh
    
    Expected: True
    Actual:   False

        Stack Trace:

        
Build : 3.0 - 20180806.01 (Core Tests)
Failing configurations:
- osx.1013.amd64-x64
  - 
- osx.1012.amd64-x64
  - 

Details: https://mc.dot.net/#/product/netcore/30/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fcli~2F/build/20180806.01/workItem/JIT.HardwareIntrinsics.XUnitWrapper/analysis/xunit/JIT_HardwareIntrinsics._X86_Avx_Avx_ro_Avx_ro_~2F_X86_Avx_Avx_ro_Avx_ro_cmd</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19298</IssueLabelID>
    <Title>Add PInvoke/DateTime tests</Title>
    <Description>
    </Description>
    <Title_Description>Add PInvoke/DateTime tests </Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jkoritzinsky</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19297</IssueLabelID>
    <Title>Add PInvoke/CriticalHandles tests</Title>
    <Description>
    </Description>
    <Title_Description>Add PInvoke/CriticalHandles tests </Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jkoritzinsky</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19295</IssueLabelID>
    <Title>Frequent failure in CoreFX ReadAsyncCompletesIfFlushAsyncCanceledMidFlush test</Title>
    <Description>This fails in Jenkins frequently though not always e.g.:

Windows x86:

https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/x86_checked_windows_nt_corefx_baseline/562/
https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/x86_checked_windows_nt_corefx_baseline/560/
https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/x86_checked_windows_nt_corefx_baseline/558/
https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/x86_checked_windows_nt_corefx_baseline/557/
https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/x86_checked_windows_nt_corefx_baseline/554/

Windows x64:

https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/x64_checked_windows_nt_corefx_baseline/590/


</Description>
    <Title_Description>Frequent failure in CoreFX ReadAsyncCompletesIfFlushAsyncCanceledMidFlush test This fails in Jenkins frequently though not always e.g.:

Windows x86:

https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/x86_checked_windows_nt_corefx_baseline/562/
https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/x86_checked_windows_nt_corefx_baseline/560/
https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/x86_checked_windows_nt_corefx_baseline/558/
https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/x86_checked_windows_nt_corefx_baseline/557/
https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/x86_checked_windows_nt_corefx_baseline/554/

Windows x64:

https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/x64_checked_windows_nt_corefx_baseline/590/


</Title_Description>
    <Label>
    </Label>
    <Assignee>pakrym</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19293</IssueLabelID>
    <Title>Array -&gt; Memory -&gt; Span overly defensive?</Title>
    <Description>Creating a {ReadOnly}Memory from an array does lots of checks; which is correct
https://github.com/dotnet/coreclr/blob/9d1e7dd8eb744b14eb4a90b401e854d7a5f79fff/src/System.Private.CoreLib/shared/System/Memory.cs#L96-L113

Slicing a {ReadOnly}Memory also performs bounds checks based on the confirmed offset and lengths

However creating a Span from and array backed {ReadOnly}Memory uses the regular array constructor
https://github.com/dotnet/coreclr/blob/9d1e7dd8eb744b14eb4a90b401e854d7a5f79fff/src/System.Private.CoreLib/shared/System/Memory.cs#L286-L289

Which then rechecks all the parameters again 
https://github.com/dotnet/coreclr/blob/9d1e7dd8eb744b14eb4a90b401e854d7a5f79fff/src/System.Private.CoreLib/shared/System/Span.Fast.cs#L73-L89

This makes an array backed Memory the most expensive kind of Span creator.

Does it need to recheck everything or can it use an internal Span .ctor that bypasses the additional checks?

/cc @jkotas @stephentoub @GrabYourPitchforks @davidfowl @ahsonkhan </Description>
    <Title_Description>Array -&gt; Memory -&gt; Span overly defensive? Creating a {ReadOnly}Memory from an array does lots of checks; which is correct
https://github.com/dotnet/coreclr/blob/9d1e7dd8eb744b14eb4a90b401e854d7a5f79fff/src/System.Private.CoreLib/shared/System/Memory.cs#L96-L113

Slicing a {ReadOnly}Memory also performs bounds checks based on the confirmed offset and lengths

However creating a Span from and array backed {ReadOnly}Memory uses the regular array constructor
https://github.com/dotnet/coreclr/blob/9d1e7dd8eb744b14eb4a90b401e854d7a5f79fff/src/System.Private.CoreLib/shared/System/Memory.cs#L286-L289

Which then rechecks all the parameters again 
https://github.com/dotnet/coreclr/blob/9d1e7dd8eb744b14eb4a90b401e854d7a5f79fff/src/System.Private.CoreLib/shared/System/Span.Fast.cs#L73-L89

This makes an array backed Memory the most expensive kind of Span creator.

Does it need to recheck everything or can it use an internal Span .ctor that bypasses the additional checks?

/cc @jkotas @stephentoub @GrabYourPitchforks @davidfowl @ahsonkhan </Title_Description>
    <Label>area-System.Memory</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>5/08/2018 8:36:45 AM +00:00</CreatedAt>
    <ClosedAt>17/11/2018 12:42:32 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19292</IssueLabelID>
    <Title>.NET Core 2.1: Non-GAC DLLs Not Found</Title>
    <Description>See https://github.com/PowerShell/PowerShell/issues/7326 and https://github.com/PowerShell/PowerShell/issues/7076 for further details. Thank you!</Description>
    <Title_Description>.NET Core 2.1: Non-GAC DLLs Not Found See https://github.com/PowerShell/PowerShell/issues/7326 and https://github.com/PowerShell/PowerShell/issues/7076 for further details. Thank you!</Title_Description>
    <Label>area-AssemblyLoader</Label>
    <Assignee>vitek-karas</Assignee>
    <CreatedAt>5/08/2018 2:37:38 AM +00:00</CreatedAt>
    <ClosedAt>7/08/2018 8:46:23 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19289</IssueLabelID>
    <Title>AggressiveInlining flaw?</Title>
    <Description>I can understand why a method with MethodImplOptions.AggressiveInlining attribute passed as Action cannot be in-lined when called. However I don't see any reason why such method couldn't be in-lined in case it is passed to a constructor and stored in a readonly field. See the following code fragment.
I believe the call to </Description>
    <Title_Description>AggressiveInlining flaw? I can understand why a method with MethodImplOptions.AggressiveInlining attribute passed as Action cannot be in-lined when called. However I don't see any reason why such method couldn't be in-lined in case it is passed to a constructor and stored in a readonly field. See the following code fragment.
I believe the call to </Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>4/08/2018 8:32:48 AM +00:00</CreatedAt>
    <ClosedAt>4/08/2018 1:19:08 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19288</IssueLabelID>
    <Title>Incorrect up-sizing for non-power-of-2 structs that are not LclVars</Title>
    <Description>When loading a struct from an arbitrary location it is not safe to load any more bytes than the specified size of the struct. For instance in the case where you're loading a 3-byte struct that's in the last three bytes of a page the next byte following the struct may be on a page that is unmapped or not readable.

A JIT dump showed this transformation during the morph process (note the 

This branch was modified a couple of months ago in https://github.com/dotnet/coreclr/pull/18358 to remove an additional check in there that was also checking if the source was a LclVar before adjusting the size.

@CarolEidt Can you please take a look and determine whether we need to reintroduce that check or make a better fix?</Description>
    <Title_Description>Incorrect up-sizing for non-power-of-2 structs that are not LclVars When loading a struct from an arbitrary location it is not safe to load any more bytes than the specified size of the struct. For instance in the case where you're loading a 3-byte struct that's in the last three bytes of a page the next byte following the struct may be on a page that is unmapped or not readable.

A JIT dump showed this transformation during the morph process (note the 

This branch was modified a couple of months ago in https://github.com/dotnet/coreclr/pull/18358 to remove an additional check in there that was also checking if the source was a LclVar before adjusting the size.

@CarolEidt Can you please take a look and determine whether we need to reintroduce that check or make a better fix?</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19285</IssueLabelID>
    <Title>r2rdump test failure: FileNotFoundException HelloWorld.xml</Title>
    <Description>Looks like the x64 release build has been failing with this problem for a while.

https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64/job/release_windows_nt/



@acmyu @nattress </Description>
    <Title_Description>r2rdump test failure: FileNotFoundException HelloWorld.xml Looks like the x64 release build has been failing with this problem for a while.

https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64/job/release_windows_nt/



@acmyu @nattress </Title_Description>
    <Label>
    </Label>
    <Assignee>acmyu</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19283</IssueLabelID>
    <Title>[RyuJIT] switch statement can be further optimized when using bitmasks</Title>
    <Description>RyuJIT has room for optimization in switch statements like the case below.

 logic and I'm seeing patterns very similar to this in the optimized code.

category:cq
theme:optimization
skill-level:intermediate
cost:large</Description>
    <Title_Description>[RyuJIT] switch statement can be further optimized when using bitmasks RyuJIT has room for optimization in switch statements like the case below.

 logic and I'm seeing patterns very similar to this in the optimized code.

category:cq
theme:optimization
skill-level:intermediate
cost:large</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>3/08/2018 11:16:49 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19282</IssueLabelID>
    <Title>WIP Update base services tests to SDK style projects</Title>
    <Description>Update all the tests in baseservices to be SDK style projects</Description>
    <Title_Description>WIP Update base services tests to SDK style projects Update all the tests in baseservices to be SDK style projects</Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>chsienki</Assignee>
    <CreatedAt>3/08/2018 10:56:13 PM +00:00</CreatedAt>
    <ClosedAt>24/05/2019 2:38:01 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19279</IssueLabelID>
    <Title>[Feature] Have optimizer aggressively fold branches</Title>
    <Description>I'd like the JIT to detect when one branch leads to another branch and fold them into a single branch.

I'm sure this optimization has a specific name in compiler theory but I don't know it. If you'll excuse a dumb example:

 manually inlined. Having the compiler optimize away these tests would make a huge difference to me.

category:cq
theme:optimization
skill-level:expert
cost:large</Description>
    <Title_Description>[Feature] Have optimizer aggressively fold branches I'd like the JIT to detect when one branch leads to another branch and fold them into a single branch.

I'm sure this optimization has a specific name in compiler theory but I don't know it. If you'll excuse a dumb example:

 manually inlined. Having the compiler optimize away these tests would make a huge difference to me.

category:cq
theme:optimization
skill-level:expert
cost:large</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>3/08/2018 9:08:04 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19277</IssueLabelID>
    <Title>Test failure: readytorun_r2rdump._R2RDumpTest_R2RDumpTest_/_R2RDumpTest_R2RDumpTest_cmd</Title>
    <Description>Opened on behalf of @RussKeldorph

The test  has failed.

The system cannot find the path specified.\r
    The system cannot find the path specified.\r
    The system cannot find the path specified.\r
    The system cannot find the path specified.\r
    
    
    Return code:      1
    Raw output file:      C:\\dotnetbuild\\work\\83984791-e58e-4726-a52b-550c3a40b9d5\\Work\\9abd53db-5b26-435c-b386-5cb7c26699a8\\Unzip\\Reports\\readytorun.r2rdump\\R2RDumpTest\\R2RDumpTest.output.txt
    Raw output:
    BEGIN EXECUTION\r
    The system cannot find the path specified.\r
    Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0\r
    Copyright (c) Microsoft Corporation.  All rights reserved.\r
    \r
    Native image HelloWorld.ni.dll generated successfully.\r
    Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0\r
    Copyright (c) Microsoft Corporation.  All rights reserved.\r
    \r
    Native image GcInfoTransitions.ni.dll generated successfully.\r
    Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0\r
    Copyright (c) Microsoft Corporation.  All rights reserved.\r
    \r
    Native image GenericFunctions.ni.dll generated successfully.\r
    Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0\r
    Copyright (c) Microsoft Corporation.  All rights reserved.\r
    \r
    Native image MultipleRuntimeFunctions.ni.dll generated successfully.\r
     \"C:\\dotnetbuild\\work\\83984791-e58e-4726-a52b-550c3a40b9d5\\Payload\\corerun.exe\" R2RDumpTest.exe \r
    Starting the test\r
    Expected: 100\r
    Actual: -532462766\r
    END EXECUTION - FAILED\r
    FAILED\r
    Test Harness Exitcode is : 1\r
    
    To run the test:
    &gt; set CORE_ROOT=C:\\dotnetbuild\\work\\83984791-e58e-4726-a52b-550c3a40b9d5\\Payload
    &gt; C:\\dotnetbuild\\work\\83984791-e58e-4726-a52b-550c3a40b9d5\\Work\\9abd53db-5b26-435c-b386-5cb7c26699a8\\Unzip\\R2RDumpTest\\R2RDumpTest.cmd
    \r
    Expected: True\r
    Actual:   False

        Stack Trace:

           at readytorun_r2rdump._R2RDumpTest_R2RDumpTest_._R2RDumpTest_R2RDumpTest_cmd() in E:\A\_work\105\s\bin\tests\Windows_NT.arm.Release\TestWrappers\readytorun.r2rdump\readytorun.r2rdump.XUnitWrapper.cs:line 109
Build : 3.0 - 20180803.04 (Core Tests)
Failing configurations:
- windows.10.arm64-arm
  - 
- osx.1013.amd64-x64
  - 
- osx.1012.amd64-x64
  - 
- sles.12.amd64-x64
  - 
- opensuse.423.amd64-x64
  - 
- ubuntu.1804.amd64-x64
  - 
- ubuntu.1710.amd64-x64
  - 
- ubuntu.1604.amd64-x64
  - 
- ubuntu.1404.amd64-x64
  - 
- redhat.73.amd64-x64
  - 
- fedora.27.amd64-x64
  - 
- fedora.26.amd64-x64
  - 
- debian.82.amd64-x64
  - 
- redhat.69.amd64-x64
  - 
- Alpine.36.Amd64-x64
  - 
- Windows.81.Amd64-x64
  - 
- Windows.7.Amd64-x64
  - 
- Windows.10.Amd64.Core-x64
  - 
- Windows.10.Nano.Amd64-x64
  - 
- Windows.10.Amd64-x64
  - 
</Description>
    <Title_Description>Test failure: readytorun_r2rdump._R2RDumpTest_R2RDumpTest_/_R2RDumpTest_R2RDumpTest_cmd Opened on behalf of @RussKeldorph

The test  has failed.

The system cannot find the path specified.\r
    The system cannot find the path specified.\r
    The system cannot find the path specified.\r
    The system cannot find the path specified.\r
    
    
    Return code:      1
    Raw output file:      C:\\dotnetbuild\\work\\83984791-e58e-4726-a52b-550c3a40b9d5\\Work\\9abd53db-5b26-435c-b386-5cb7c26699a8\\Unzip\\Reports\\readytorun.r2rdump\\R2RDumpTest\\R2RDumpTest.output.txt
    Raw output:
    BEGIN EXECUTION\r
    The system cannot find the path specified.\r
    Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0\r
    Copyright (c) Microsoft Corporation.  All rights reserved.\r
    \r
    Native image HelloWorld.ni.dll generated successfully.\r
    Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0\r
    Copyright (c) Microsoft Corporation.  All rights reserved.\r
    \r
    Native image GcInfoTransitions.ni.dll generated successfully.\r
    Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0\r
    Copyright (c) Microsoft Corporation.  All rights reserved.\r
    \r
    Native image GenericFunctions.ni.dll generated successfully.\r
    Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0\r
    Copyright (c) Microsoft Corporation.  All rights reserved.\r
    \r
    Native image MultipleRuntimeFunctions.ni.dll generated successfully.\r
     \"C:\\dotnetbuild\\work\\83984791-e58e-4726-a52b-550c3a40b9d5\\Payload\\corerun.exe\" R2RDumpTest.exe \r
    Starting the test\r
    Expected: 100\r
    Actual: -532462766\r
    END EXECUTION - FAILED\r
    FAILED\r
    Test Harness Exitcode is : 1\r
    
    To run the test:
    &gt; set CORE_ROOT=C:\\dotnetbuild\\work\\83984791-e58e-4726-a52b-550c3a40b9d5\\Payload
    &gt; C:\\dotnetbuild\\work\\83984791-e58e-4726-a52b-550c3a40b9d5\\Work\\9abd53db-5b26-435c-b386-5cb7c26699a8\\Unzip\\R2RDumpTest\\R2RDumpTest.cmd
    \r
    Expected: True\r
    Actual:   False

        Stack Trace:

           at readytorun_r2rdump._R2RDumpTest_R2RDumpTest_._R2RDumpTest_R2RDumpTest_cmd() in E:\A\_work\105\s\bin\tests\Windows_NT.arm.Release\TestWrappers\readytorun.r2rdump\readytorun.r2rdump.XUnitWrapper.cs:line 109
Build : 3.0 - 20180803.04 (Core Tests)
Failing configurations:
- windows.10.arm64-arm
  - 
- osx.1013.amd64-x64
  - 
- osx.1012.amd64-x64
  - 
- sles.12.amd64-x64
  - 
- opensuse.423.amd64-x64
  - 
- ubuntu.1804.amd64-x64
  - 
- ubuntu.1710.amd64-x64
  - 
- ubuntu.1604.amd64-x64
  - 
- ubuntu.1404.amd64-x64
  - 
- redhat.73.amd64-x64
  - 
- fedora.27.amd64-x64
  - 
- fedora.26.amd64-x64
  - 
- debian.82.amd64-x64
  - 
- redhat.69.amd64-x64
  - 
- Alpine.36.Amd64-x64
  - 
- Windows.81.Amd64-x64
  - 
- Windows.7.Amd64-x64
  - 
- Windows.10.Amd64.Core-x64
  - 
- Windows.10.Nano.Amd64-x64
  - 
- Windows.10.Amd64-x64
  - 
</Title_Description>
    <Label>area-ReadyToRun</Label>
    <Assignee>acmyu</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19273</IssueLabelID>
    <Title>[Linux/ARM] SIGSEGV during GC under managed debugger</Title>
    <Description>In some cases SIGSEGV occurs during gc:
 is always not NULL in this case for ARM?

Thank you!</Description>
    <Title_Description>[Linux/ARM] SIGSEGV during GC under managed debugger In some cases SIGSEGV occurs during gc:
 is always not NULL in this case for ARM?

Thank you!</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>alpencolt</Assignee>
    <CreatedAt>3/08/2018 3:58:38 PM +00:00</CreatedAt>
    <ClosedAt>10/01/2019 5:34:44 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19272</IssueLabelID>
    <Title>RyuJIT: Morph forgets about side effects when optimizing casted shift</Title>
    <Description>The following example does not print anything in release:
</Description>
    <Title_Description>RyuJIT: Morph forgets about side effects when optimizing casted shift The following example does not print anything in release:
</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>sandreenko</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19271</IssueLabelID>
    <Title>HW intrinsics: Expose REP MOVSB/D in API to allow conscious use of ERMSB feature</Title>
    <Description>Please expose REP MOVSB/D in HW intrinsics API to allow use of ERMSB feature to copy memory blocks without use of SSE and later. obvious use case is - transfer of large memory areas like set of VM pages (typically N x 4Kb for Windows).

Example of numbers obtained by benchmarking and some descriptive text can be found here:
https://stackoverflow.com/a/43574756

category:proposal
theme:intrinsics
skill-level:intermediate
cost:medium</Description>
    <Title_Description>HW intrinsics: Expose REP MOVSB/D in API to allow conscious use of ERMSB feature Please expose REP MOVSB/D in HW intrinsics API to allow use of ERMSB feature to copy memory blocks without use of SSE and later. obvious use case is - transfer of large memory areas like set of VM pages (typically N x 4Kb for Windows).

Example of numbers obtained by benchmarking and some descriptive text can be found here:
https://stackoverflow.com/a/43574756

category:proposal
theme:intrinsics
skill-level:intermediate
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>3/08/2018 10:53:52 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19270</IssueLabelID>
    <Title>Add PInvoke/DllImportpath tests</Title>
    <Description>
    </Description>
    <Title_Description>Add PInvoke/DllImportpath tests </Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jkoritzinsky</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19269</IssueLabelID>
    <Title>Add PInvoke/BestFitMapping tests</Title>
    <Description>
    </Description>
    <Title_Description>Add PInvoke/BestFitMapping tests </Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jkoritzinsky</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19268</IssueLabelID>
    <Title>Test failure: tracing_runtimeeventsource._runtimeeventsource_runtimeeventsource_/_runtimeeventsource_runtimeeventsource_cmd</Title>
    <Description>Opened on behalf of @Sunny-pu

The test  has failed.


    Unhandled Exception: System.Exception: Condition 'listener.EventCount &gt; 0' is not true\r
       at Tracing.Tests.Common.Assert.True(String name Boolean condition)\r
       at Tracing.Tests.RuntimeEventSourceTest.Main(String[] args)
    
    
    Return code:      1
    Raw output file:      C:\\dotnetbuild\\work\\e7ea211b-8ea4-4f83-8f9c-587faa935083\\Work\\40455e47-1819-41ce-8ba1-d1c1be28e5bf\\Unzip\\Reports\\tracing.runtimeeventsource\\runtimeeventsource\\runtimeeventsource.output.txt
    Raw output:
    BEGIN EXECUTION\r
            1 file(s) copied.\r
    \" C:\\dotnetbuild\\work\\e7ea211b-8ea4-4f83-8f9c-587faa935083\\Payload\\crossgen.exe\" /Platform_Assemblies_Paths C:\\dotnetbuild\\work\\e7ea211b-8ea4-4f83-8f9c-587faa935083\\Payload;C:\\dotnetbuild\\work\\e7ea211b-8ea4-4f83-8f9c-587faa935083\\Work\\40455e47-1819-41ce-8ba1-d1c1be28e5bf\\Unzip\\runtimeeventsource\\IL;C:\\dotnetbuild\\work\\e7ea211b-8ea4-4f83-8f9c-587faa935083\\Work\\40455e47-1819-41ce-8ba1-d1c1be28e5bf\\Unzip\\runtimeeventsource /in runtimeeventsource.org /out runtimeeventsource.exe\r
    Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0\r
    Copyright (c) Microsoft Corporation.  All rights reserved.\r
    \r
    Native image runtimeeventsource.exe generated successfully.\r
     \"C:\\dotnetbuild\\work\\e7ea211b-8ea4-4f83-8f9c-587faa935083\\Payload\\corerun.exe\" runtimeeventsource.exe \r
    [Simple] ThreadID = 2768 ID = 200 Name = IncreaseMemoryPressure\r
    TimeStamp: 8/3/2018 2:33:49 AM\r
    LocalTime: 8/3/2018 2:33:49 AM\r
    Difference: -00:00:00.0000304\r
    [Simple] ThreadID = 632 ID = 0 Name = EventSourceMessage\r
    TimeStamp: 8/3/2018 2:33:49 AM\r
    LocalTime: 8/3/2018 2:33:49 AM\r
    Difference: 00:00:00\r
    [NoEvents] ThreadID = 632 ID = 0 Name = EventSourceMessage\r
    TimeStamp: 8/3/2018 2:33:49 AM\r
    LocalTime: 8/3/2018 2:33:49 AM\r
    Difference: 00:00:00\r
    Expected: 100\r
    Actual: -532462766\r
    END EXECUTION - FAILED\r
    FAILED\r
    Test Harness Exitcode is : 1\r
    
    To run the test:
    &gt; set CORE_ROOT=C:\\dotnetbuild\\work\\e7ea211b-8ea4-4f83-8f9c-587faa935083\\Payload
    &gt; C:\\dotnetbuild\\work\\e7ea211b-8ea4-4f83-8f9c-587faa935083\\Work\\40455e47-1819-41ce-8ba1-d1c1be28e5bf\\Unzip\\runtimeeventsource\\runtimeeventsource.cmd
    \r
    Expected: True\r
    Actual:   False

        Stack Trace:

        
Build : 3.0 - 20180803.01 (Ready-To-Run Tests)
Failing configurations:
- Windows.7.Amd64
  - x64

Details: https://mc.dot.net/#/product/netcore/30/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fr2r~2Fcli~2F/build/20180803.01/workItem/tracing.runtimeeventsource.XUnitWrapper/analysis/xunit/tracing_runtimeeventsource._runtimeeventsource_runtimeeventsource_~2F_runtimeeventsource_runtimeeventsource_cmd</Description>
    <Title_Description>Test failure: tracing_runtimeeventsource._runtimeeventsource_runtimeeventsource_/_runtimeeventsource_runtimeeventsource_cmd Opened on behalf of @Sunny-pu

The test  has failed.


    Unhandled Exception: System.Exception: Condition 'listener.EventCount &gt; 0' is not true\r
       at Tracing.Tests.Common.Assert.True(String name Boolean condition)\r
       at Tracing.Tests.RuntimeEventSourceTest.Main(String[] args)
    
    
    Return code:      1
    Raw output file:      C:\\dotnetbuild\\work\\e7ea211b-8ea4-4f83-8f9c-587faa935083\\Work\\40455e47-1819-41ce-8ba1-d1c1be28e5bf\\Unzip\\Reports\\tracing.runtimeeventsource\\runtimeeventsource\\runtimeeventsource.output.txt
    Raw output:
    BEGIN EXECUTION\r
            1 file(s) copied.\r
    \" C:\\dotnetbuild\\work\\e7ea211b-8ea4-4f83-8f9c-587faa935083\\Payload\\crossgen.exe\" /Platform_Assemblies_Paths C:\\dotnetbuild\\work\\e7ea211b-8ea4-4f83-8f9c-587faa935083\\Payload;C:\\dotnetbuild\\work\\e7ea211b-8ea4-4f83-8f9c-587faa935083\\Work\\40455e47-1819-41ce-8ba1-d1c1be28e5bf\\Unzip\\runtimeeventsource\\IL;C:\\dotnetbuild\\work\\e7ea211b-8ea4-4f83-8f9c-587faa935083\\Work\\40455e47-1819-41ce-8ba1-d1c1be28e5bf\\Unzip\\runtimeeventsource /in runtimeeventsource.org /out runtimeeventsource.exe\r
    Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0\r
    Copyright (c) Microsoft Corporation.  All rights reserved.\r
    \r
    Native image runtimeeventsource.exe generated successfully.\r
     \"C:\\dotnetbuild\\work\\e7ea211b-8ea4-4f83-8f9c-587faa935083\\Payload\\corerun.exe\" runtimeeventsource.exe \r
    [Simple] ThreadID = 2768 ID = 200 Name = IncreaseMemoryPressure\r
    TimeStamp: 8/3/2018 2:33:49 AM\r
    LocalTime: 8/3/2018 2:33:49 AM\r
    Difference: -00:00:00.0000304\r
    [Simple] ThreadID = 632 ID = 0 Name = EventSourceMessage\r
    TimeStamp: 8/3/2018 2:33:49 AM\r
    LocalTime: 8/3/2018 2:33:49 AM\r
    Difference: 00:00:00\r
    [NoEvents] ThreadID = 632 ID = 0 Name = EventSourceMessage\r
    TimeStamp: 8/3/2018 2:33:49 AM\r
    LocalTime: 8/3/2018 2:33:49 AM\r
    Difference: 00:00:00\r
    Expected: 100\r
    Actual: -532462766\r
    END EXECUTION - FAILED\r
    FAILED\r
    Test Harness Exitcode is : 1\r
    
    To run the test:
    &gt; set CORE_ROOT=C:\\dotnetbuild\\work\\e7ea211b-8ea4-4f83-8f9c-587faa935083\\Payload
    &gt; C:\\dotnetbuild\\work\\e7ea211b-8ea4-4f83-8f9c-587faa935083\\Work\\40455e47-1819-41ce-8ba1-d1c1be28e5bf\\Unzip\\runtimeeventsource\\runtimeeventsource.cmd
    \r
    Expected: True\r
    Actual:   False

        Stack Trace:

        
Build : 3.0 - 20180803.01 (Ready-To-Run Tests)
Failing configurations:
- Windows.7.Amd64
  - x64

Details: https://mc.dot.net/#/product/netcore/30/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fr2r~2Fcli~2F/build/20180803.01/workItem/tracing.runtimeeventsource.XUnitWrapper/analysis/xunit/tracing_runtimeeventsource._runtimeeventsource_runtimeeventsource_~2F_runtimeeventsource_runtimeeventsource_cmd</Title_Description>
    <Label>area-Tracing</Label>
    <Assignee>brianrob</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19267</IssueLabelID>
    <Title>Test failure: JIT_CodeGenBringUpTests._DblRoots_r_DblRoots_r_/_DblRoots_r_DblRoots_r_cmd</Title>
    <Description>Opened on behalf of @Sunny-pu

The test  has failed.

The system cannot find the file specified.\r
    Error compiling DblRoots_r.org: The system cannot find the file specified. (Exception from HRESULT: 0x80070002)\r
    Error: file \"DblRoots_r.org\" or one of its dependencies was not found\r
    
    
    Return code:      1
    Raw output file:      C:\\work\\02b4a928-9662-4407-b289-c7f586bb1e7b\\Work\\942af0b4-095f-4dd4-b8b3-f240d618c442\\Unzip\\Reports\\JIT.CodeGenBringUpTests\\DblRoots_r\\DblRoots_r.output.txt
    Raw output:
    BEGIN EXECUTION\r
    The system cannot find the file specified.\r
    \" C:\\work\\02b4a928-9662-4407-b289-c7f586bb1e7b\\Payload\\crossgen.exe\" /Platform_Assemblies_Paths C:\\work\\02b4a928-9662-4407-b289-c7f586bb1e7b\\Payload;C:\\work\\02b4a928-9662-4407-b289-c7f586bb1e7b\\Work\\942af0b4-095f-4dd4-b8b3-f240d618c442\\Unzip\\DblRoots_r\\IL;C:\\work\\02b4a928-9662-4407-b289-c7f586bb1e7b\\Work\\942af0b4-095f-4dd4-b8b3-f240d618c442\\Unzip\\DblRoots_r /in DblRoots_r.org /out DblRoots_r.exe\r
    Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0\r
    Copyright (c) Microsoft Corporation.  All rights reserved.\r
    \r
    Crossgen failed with exitcode - -3\r
    Test Harness Exitcode is : 1\r
    
    To run the test:
    &gt; set CORE_ROOT=C:\\work\\02b4a928-9662-4407-b289-c7f586bb1e7b\\Payload
    &gt; C:\\work\\02b4a928-9662-4407-b289-c7f586bb1e7b\\Work\\942af0b4-095f-4dd4-b8b3-f240d618c442\\Unzip\\DblRoots_r\\DblRoots_r.cmd
    \r
    Expected: True\r
    Actual:   False

        Stack Trace:

        
Build : 3.0 - 20180803.01 (Ready-To-Run Tests)
Failing configurations:
- Windows.10.Nano.Amd64
  - x64

Details: https://mc.dot.net/#/product/netcore/30/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fr2r~2Fcli~2F/build/20180803.01/workItem/JIT.CodeGenBringUpTests.XUnitWrapper</Description>
    <Title_Description>Test failure: JIT_CodeGenBringUpTests._DblRoots_r_DblRoots_r_/_DblRoots_r_DblRoots_r_cmd Opened on behalf of @Sunny-pu

The test  has failed.

The system cannot find the file specified.\r
    Error compiling DblRoots_r.org: The system cannot find the file specified. (Exception from HRESULT: 0x80070002)\r
    Error: file \"DblRoots_r.org\" or one of its dependencies was not found\r
    
    
    Return code:      1
    Raw output file:      C:\\work\\02b4a928-9662-4407-b289-c7f586bb1e7b\\Work\\942af0b4-095f-4dd4-b8b3-f240d618c442\\Unzip\\Reports\\JIT.CodeGenBringUpTests\\DblRoots_r\\DblRoots_r.output.txt
    Raw output:
    BEGIN EXECUTION\r
    The system cannot find the file specified.\r
    \" C:\\work\\02b4a928-9662-4407-b289-c7f586bb1e7b\\Payload\\crossgen.exe\" /Platform_Assemblies_Paths C:\\work\\02b4a928-9662-4407-b289-c7f586bb1e7b\\Payload;C:\\work\\02b4a928-9662-4407-b289-c7f586bb1e7b\\Work\\942af0b4-095f-4dd4-b8b3-f240d618c442\\Unzip\\DblRoots_r\\IL;C:\\work\\02b4a928-9662-4407-b289-c7f586bb1e7b\\Work\\942af0b4-095f-4dd4-b8b3-f240d618c442\\Unzip\\DblRoots_r /in DblRoots_r.org /out DblRoots_r.exe\r
    Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0\r
    Copyright (c) Microsoft Corporation.  All rights reserved.\r
    \r
    Crossgen failed with exitcode - -3\r
    Test Harness Exitcode is : 1\r
    
    To run the test:
    &gt; set CORE_ROOT=C:\\work\\02b4a928-9662-4407-b289-c7f586bb1e7b\\Payload
    &gt; C:\\work\\02b4a928-9662-4407-b289-c7f586bb1e7b\\Work\\942af0b4-095f-4dd4-b8b3-f240d618c442\\Unzip\\DblRoots_r\\DblRoots_r.cmd
    \r
    Expected: True\r
    Actual:   False

        Stack Trace:

        
Build : 3.0 - 20180803.01 (Ready-To-Run Tests)
Failing configurations:
- Windows.10.Nano.Amd64
  - x64

Details: https://mc.dot.net/#/product/netcore/30/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fr2r~2Fcli~2F/build/20180803.01/workItem/JIT.CodeGenBringUpTests.XUnitWrapper</Title_Description>
    <Label>test-run-uwp-coreclr</Label>
    <Assignee>sandreenko</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19266</IssueLabelID>
    <Title>Add PInvoke/Array tests</Title>
    <Description>
    </Description>
    <Title_Description>Add PInvoke/Array tests </Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jkoritzinsky</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19262</IssueLabelID>
    <Title>Update debugging doc with symbol downloader instructions.</Title>
    <Description>
    </Description>
    <Title_Description>Update debugging doc with symbol downloader instructions. </Title_Description>
    <Label>
    </Label>
    <Assignee>mikem8361</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19257</IssueLabelID>
    <Title>JIT: emitter assert running PMI</Title>
    <Description>Compile attached test case (from #9066 requires 

category:correctness
theme:ir
skill-level:expert
cost:large</Description>
    <Title_Description>JIT: emitter assert running PMI Compile attached test case (from #9066 requires 

category:correctness
theme:ir
skill-level:expert
cost:large</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19256</IssueLabelID>
    <Title>RyuJIT: Argument written to stack too early on Linux</Title>
    <Description>On Linux x64 the following program prints 

This does not repro on Windows which is likely related to the fact that both args are passed by reference there.</Description>
    <Title_Description>RyuJIT: Argument written to stack too early on Linux On Linux x64 the following program prints 

This does not repro on Windows which is likely related to the fact that both args are passed by reference there.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19255</IssueLabelID>
    <Title>[armel][2.1.1] Incorrect stepping in debugger</Title>
    <Description>After setting break point we try to make step but CoreCLR crash with abort.
If we attach with gdb we'll see several .

We've checked latest master and it works. There are several PRs which fix stepping after 2.1 release:
https://github.com/dotnet/coreclr/pull/17617
https://github.com/dotnet/coreclr/pull/17879
https://github.com/dotnet/coreclr/pull/17990
https://github.com/dotnet/coreclr/pull/18129
https://github.com/dotnet/coreclr/pull/18247
They help but not at all - application crashed but little bit later with the same abort.
Are there any others fixes which we've missed?

cc @jkotas @BruceForstall @kbaladurin @BredPet </Description>
    <Title_Description>[armel][2.1.1] Incorrect stepping in debugger After setting break point we try to make step but CoreCLR crash with abort.
If we attach with gdb we'll see several .

We've checked latest master and it works. There are several PRs which fix stepping after 2.1 release:
https://github.com/dotnet/coreclr/pull/17617
https://github.com/dotnet/coreclr/pull/17879
https://github.com/dotnet/coreclr/pull/17990
https://github.com/dotnet/coreclr/pull/18129
https://github.com/dotnet/coreclr/pull/18247
They help but not at all - application crashed but little bit later with the same abort.
Are there any others fixes which we've missed?

cc @jkotas @BruceForstall @kbaladurin @BredPet </Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>hoyosjs</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19248</IssueLabelID>
    <Title>[arm32] Test failures in finalizearraysleep finalizearray</Title>
    <Description>With JitStress=1

https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_jitstress1_tst/36/artifact/bin/tests/Windows_NT.arm.Checked/Smarty.run.0/Smarty.0.fail.smrt/*view*/



@dotnet/arm32-contrib </Description>
    <Title_Description>[arm32] Test failures in finalizearraysleep, finalizearray With JitStress=1

https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_jitstress1_tst/36/artifact/bin/tests/Windows_NT.arm.Checked/Smarty.run.0/Smarty.0.fail.smrt/*view*/



@dotnet/arm32-contrib </Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>2/08/2018 3:52:11 PM +00:00</CreatedAt>
    <ClosedAt>17/10/2018 12:10:11 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19246</IssueLabelID>
    <Title>Remaining non-generated HWIntrinsic tests should be moved to be generated</Title>
    <Description>Currently there are a number of HWIntrinsic tests that are hand written which leads to maintainability issues and gaps in coverage as compared to the other HWIntrinsic tests (templates have been updated a few times in order to fix bugs or add new scenarios which impacts the vast majority of other HWIntrinsic tests).

It would be beneficial to move them to the same code generation templates as the other HWIntrinsic tests. 

category:testing
theme:vector-codegen
skill-level:intermediate
cost:medium</Description>
    <Title_Description>Remaining non-generated HWIntrinsic tests should be moved to be generated Currently there are a number of HWIntrinsic tests that are hand written which leads to maintainability issues and gaps in coverage as compared to the other HWIntrinsic tests (templates have been updated a few times in order to fix bugs or add new scenarios which impacts the vast majority of other HWIntrinsic tests).

It would be beneficial to move them to the same code generation templates as the other HWIntrinsic tests. 

category:testing
theme:vector-codegen
skill-level:intermediate
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>4creators</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19245</IssueLabelID>
    <Title>SSE2 HWIntrinsics tests should be moved to use the code templates</Title>
    <Description>Currently the majority of the SSE2 HWIntrinsic tests are hand written which leads to maintainability issues and gaps in coverage as compared to the other HWIntrinsic tests (templates have been updated a few times in order to fix bugs or add new scenarios which impacts the vast majority of other HWIntrinsic tests).

It would be beneficial to move them to the same code generation templates as the other HWIntrinsic tests. Additionally if the SSE2 tests were covering relevant code patterns not covered by the existing templates it should be reviewed whether or not adding those scenarios to the templates would be generally beneficial.</Description>
    <Title_Description>SSE2 HWIntrinsics tests should be moved to use the code templates Currently the majority of the SSE2 HWIntrinsic tests are hand written which leads to maintainability issues and gaps in coverage as compared to the other HWIntrinsic tests (templates have been updated a few times in order to fix bugs or add new scenarios which impacts the vast majority of other HWIntrinsic tests).

It would be beneficial to move them to the same code generation templates as the other HWIntrinsic tests. Additionally if the SSE2 tests were covering relevant code patterns not covered by the existing templates it should be reviewed whether or not adding those scenarios to the templates would be generally beneficial.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>tannergooding</Assignee>
    <CreatedAt>2/08/2018 2:21:52 PM +00:00</CreatedAt>
    <ClosedAt>24/01/2019 6:31:04 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19243</IssueLabelID>
    <Title>RyuJIT: Invalid ordering when assigning ref-return</Title>
    <Description>The following example gives different results in debug and release:
</Description>
    <Title_Description>RyuJIT: Invalid ordering when assigning ref-return The following example gives different results in debug and release:
</Title_Description>
    <Label>
    </Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19242</IssueLabelID>
    <Title>[WIP] dummy change to test dev/unix_test_workflow</Title>
    <Description>
    </Description>
    <Title_Description>[WIP] dummy change to test dev/unix_test_workflow </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>2/08/2018 5:44:52 AM +00:00</CreatedAt>
    <ClosedAt>7/08/2018 12:10:32 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19238</IssueLabelID>
    <Title>Fix interop test targets</Title>
    <Description>Remove TargetFramework from Interop.settings.targets since it already gets handled by the build environment and 2.0 doesn't work.</Description>
    <Title_Description>Fix interop test targets Remove TargetFramework from Interop.settings.targets since it already gets handled by the build environment and 2.0 doesn't work.</Title_Description>
    <Label>test bug</Label>
    <Assignee>morganbr</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19236</IssueLabelID>
    <Title>[WIP] dummy change to test dev/unix_test_workflow branch</Title>
    <Description>
    </Description>
    <Title_Description>[WIP] dummy change to test dev/unix_test_workflow branch </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>dotnet-bot</Assignee>
    <CreatedAt>2/08/2018 1:17:01 AM +00:00</CreatedAt>
    <ClosedAt>2/08/2018 5:45:31 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19235</IssueLabelID>
    <Title>Improve StreamWriter format perf</Title>
    <Description>Override the format overloads for TextWriter and skip the extra string allocation for the formatted string by using StringBuilder directly copying straight to the output buffer.

Improves performance roughtly 10% and cuts allocations by 10x and up (formatting a string into a string goes to *zero* allocations).</Description>
    <Title_Description>Improve StreamWriter format perf Override the format overloads for TextWriter and skip the extra string allocation for the formatted string by using StringBuilder directly copying straight to the output buffer.

Improves performance roughtly 10% and cuts allocations by 10x and up (formatting a string into a string goes to *zero* allocations).</Title_Description>
    <Label>area-System.IO</Label>
    <Assignee>JeremyKuhne</Assignee>
    <CreatedAt>2/08/2018 12:56:21 AM +00:00</CreatedAt>
    <ClosedAt>6/08/2018 6:22:58 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19232</IssueLabelID>
    <Title>Support O_DIRECT file open option handling for FileStream.Unix</Title>
    <Description>As discussed in #19229 changes are very small. The value 0x4000 is [from Mono](https://github.com/mono/mono/blob/78eb8324b20b29544233c3fe42f6c12e78041ba7/mcs/class/Mono.Posix/Mono.Unix.Native/Syscall.cs#L150) and cross-checked with some Google search.

</Description>
    <Title_Description>Support O_DIRECT file open option handling for FileStream.Unix As discussed in #19229 changes are very small. The value 0x4000 is [from Mono](https://github.com/mono/mono/blob/78eb8324b20b29544233c3fe42f6c12e78041ba7/mcs/class/Mono.Posix/Mono.Unix.Native/Syscall.cs#L150) and cross-checked with some Google search.

</Title_Description>
    <Label>area-System.IO</Label>
    <Assignee>JeremyKuhne</Assignee>
    <CreatedAt>1/08/2018 9:31:08 PM +00:00</CreatedAt>
    <ClosedAt>16/09/2018 4:24:00 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19231</IssueLabelID>
    <Title>Better diagnostics for fail-fast conditions</Title>
    <Description>Given the simulation process used for rich debugging purposes it may happen that bugs could lead the runtime to an unsafe state. 

When CoreCLR crashes the runtime because of fail-fast conditions it should give (if possible) information about the underlying fail-fast trigger that causes the crash.  It doesn't have to be perfect but it could use something better than COR_E_EXECUTIONENGINE(0x80131506). For the impact of not having the information readily available take a look at #19220 

cc @AndyAyersMS </Description>
    <Title_Description>Better diagnostics for fail-fast conditions Given the simulation process used for rich debugging purposes it may happen that bugs could lead the runtime to an unsafe state. 

When CoreCLR crashes the runtime because of fail-fast conditions it should give (if possible) information about the underlying fail-fast trigger that causes the crash.  It doesn't have to be perfect but it could use something better than COR_E_EXECUTIONENGINE(0x80131506). For the impact of not having the information readily available take a look at #19220 

cc @AndyAyersMS </Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>AndyAyersMS</Assignee>
    <CreatedAt>1/08/2018 6:42:08 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19229</IssueLabelID>
    <Title>Add O_DIRECT file open option handling for FileStream.Unix</Title>
    <Description>[Here](https://github.com/dotnet/coreclr/blob/75e62c545ac5c7195bf846b47e28c4f27736d64c/src/System.Private.CoreLib/shared/System/IO/FileStream.cs#L204) </Description>
    <Title_Description>Add O_DIRECT file open option handling for FileStream.Unix [Here](https://github.com/dotnet/coreclr/blob/75e62c545ac5c7195bf846b47e28c4f27736d64c/src/System.Private.CoreLib/shared/System/IO/FileStream.cs#L204) </Title_Description>
    <Label>area-System.IO</Label>
    <Assignee>JeremyKuhne</Assignee>
    <CreatedAt>1/08/2018 12:43:41 PM +00:00</CreatedAt>
    <ClosedAt>2/08/2018 12:20:10 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19204</IssueLabelID>
    <Title>WIndows does not decode EventSource events if they use enums that not based on int or long.</Title>
    <Description>@brianrob 

See the VS bug https://microsoft.visualstudio.com/OS/_workitems/edit/18408493 which is where this issue arose.  I have copied the important part in the next comment in case the link break. </Description>
    <Title_Description>WIndows does not decode EventSource events if they use enums that not based on int or long. @brianrob 

See the VS bug https://microsoft.visualstudio.com/OS/_workitems/edit/18408493 which is where this issue arose.  I have copied the important part in the next comment in case the link break. </Title_Description>
    <Label>area-Tracing</Label>
    <Assignee>vancem</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19203</IssueLabelID>
    <Title>CRT Pow function has bad performance on Windows</Title>
    <Description>During benchmarking AoS/SoA ray-tracer https://github.com/dotnet/coreclr/pull/18839 we found that the  on Linux.

The data is collected on Core i9 + VS2017 but Core i7+ VS2015 has the same performance gap.</Description>
    <Title_Description>CRT Pow function has bad performance on Windows During benchmarking AoS/SoA ray-tracer https://github.com/dotnet/coreclr/pull/18839 we found that the  on Linux.

The data is collected on Core i9 + VS2017 but Core i7+ VS2015 has the same performance gap.</Title_Description>
    <Label>area-System.Runtime</Label>
    <Assignee>fiigii</Assignee>
    <CreatedAt>30/07/2018 8:34:38 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19201</IssueLabelID>
    <Title>Enable Tiered Compilation by default</Title>
    <Description>1) Changes the default state of the tiered compilation feature check to be ON BY DEFAULT
2) Removed comments about the source about this being a work in progress. Although it will surely continue to evolve and improve remaining issues would be better tracked in our issue tracking system with the same default presumption as other runtime features - assume it works unless noted otherwise.
3) Adjusts a number of tests and automated scripts that made assumptions that the default setting of this feature is off.
4) Stop accepting the deprecated env var COMPLUS_EXPERIMENTAL_TieredCompilation. I'm not aware it has any remaining usage but if so we're going to find out.</Description>
    <Title_Description>Enable Tiered Compilation by default 1) Changes the default state of the tiered compilation feature check to be ON BY DEFAULT
2) Removed comments about the source about this being a work in progress. Although it will surely continue to evolve and improve remaining issues would be better tracked in our issue tracking system with the same default presumption as other runtime features - assume it works unless noted otherwise.
3) Adjusts a number of tests and automated scripts that made assumptions that the default setting of this feature is off.
4) Stop accepting the deprecated env var COMPLUS_EXPERIMENTAL_TieredCompilation. I'm not aware it has any remaining usage but if so we're going to find out.</Title_Description>
    <Label>area-VM</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19199</IssueLabelID>
    <Title>Why doesn't the EE save volatile registers for profiler function callbacks?</Title>
    <Description>Apologies in advance if this question is particularly ignorant or does not belong here. I browsed the repo for things tagged ):

&gt; It is VERY IMPORTANT to note that these function implementations must be
&gt; __declspec(naked) since the EE is not saving any registers before calling
&gt; any of them.  YOU MUST SAVE ALL REGISTERS YOU USE INCLUDING FPU REGISTERS
&gt; IF THE FPU STACK IS NOT EMPTY AND YOU INTEND TO USE IT.

Alright so... *why* does the EE not save any registers (as opposed to following the platform ABI rules for volatiles)? This mostly leads to profilers doing a predictable [register saving dance](https://github.com/Microsoft/clr-samples/blob/master/ProfilingAPI/ELTProfiler/CorProfiler.cpp#L27) before invoking another function the regular way. This is nasty since it requires some platform-specific assembler that's not covered by intrinsics (the alternative being [IL rewriting](https://github.com/Microsoft/clr-samples/blob/master/ProfilingAPI/ReJITEnterLeaveHooks/CorProfiler.cpp) of any and all methods you want to instrument which has its own issues).

What's the design or implementation rationale behind this? Speed? But if every profiler has to save registers anyway (practically speaking assuming not too many are written in raw asm) where would those savings come in? If no hook is set surely the EE could just invoke a stub that literally does nothing (as I believe it already does) while if a hook *is* set it can call a stub to save the volatiles before the profiler proper removing this burden from profilers?

This requirement gets onerous as you're going cross-platform as #18977 illustrates but I'm just interested in why this is (or was deemed) necessary/expedient in the first place.</Description>
    <Title_Description>Why doesn't the EE save volatile registers for profiler function callbacks? Apologies in advance if this question is particularly ignorant or does not belong here. I browsed the repo for things tagged ):

&gt; It is VERY IMPORTANT to note that these function implementations must be
&gt; __declspec(naked) since the EE is not saving any registers before calling
&gt; any of them.  YOU MUST SAVE ALL REGISTERS YOU USE INCLUDING FPU REGISTERS
&gt; IF THE FPU STACK IS NOT EMPTY AND YOU INTEND TO USE IT.

Alright so... *why* does the EE not save any registers (as opposed to following the platform ABI rules for volatiles)? This mostly leads to profilers doing a predictable [register saving dance](https://github.com/Microsoft/clr-samples/blob/master/ProfilingAPI/ELTProfiler/CorProfiler.cpp#L27) before invoking another function the regular way. This is nasty since it requires some platform-specific assembler that's not covered by intrinsics (the alternative being [IL rewriting](https://github.com/Microsoft/clr-samples/blob/master/ProfilingAPI/ReJITEnterLeaveHooks/CorProfiler.cpp) of any and all methods you want to instrument which has its own issues).

What's the design or implementation rationale behind this? Speed? But if every profiler has to save registers anyway (practically speaking assuming not too many are written in raw asm) where would those savings come in? If no hook is set surely the EE could just invoke a stub that literally does nothing (as I believe it already does) while if a hook *is* set it can call a stub to save the volatiles before the profiler proper removing this burden from profilers?

This requirement gets onerous as you're going cross-platform as #18977 illustrates but I'm just interested in why this is (or was deemed) necessary/expedient in the first place.</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>30/07/2018 7:02:27 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19198</IssueLabelID>
    <Title>Add prefix to DAC's PAL exports for alpine</Title>
    <Description>Added some cmake logic to create assembly include mapping files. One that maps the
prefixed name (DAC_foo) to the actual name (foo) which is included in the DAC module
and another that maps the actual name to the prefixed name that is included in the SOS
DBI and createdump modules.

The data exports like IID_IUnknown are not prefixed and don't need to be (immutable static data).

There were some C++ exports functions exported with their decorated names in
the CatchHardwareExceptionHolder and NativeExceptionHolderBase classes. Created
PAL_* style export functions that implements the code.

Fix lldb plugin cmake file to use LLDB_H/LLDB_LIB env vars to build it.</Description>
    <Title_Description>Add prefix to DAC's PAL exports for alpine Added some cmake logic to create assembly include mapping files. One that maps the
prefixed name (DAC_foo) to the actual name (foo) which is included in the DAC module
and another that maps the actual name to the prefixed name that is included in the SOS
DBI and createdump modules.

The data exports like IID_IUnknown are not prefixed and don't need to be (immutable static data).

There were some C++ exports functions exported with their decorated names in
the CatchHardwareExceptionHolder and NativeExceptionHolderBase classes. Created
PAL_* style export functions that implements the code.

Fix lldb plugin cmake file to use LLDB_H/LLDB_LIB env vars to build it.</Title_Description>
    <Label>
    </Label>
    <Assignee>mikem8361</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19197</IssueLabelID>
    <Title>[JITMinOpts=1] CoreFX System.Numerics.Vectors.Tests (Vector3EqualsTest) crashes under minopts</Title>
    <Description>The test crashes on Windows and Unix under JITMinOpts=1 or TieredCompilation=1. Stack:

</Description>
    <Title_Description>[JITMinOpts=1] CoreFX System.Numerics.Vectors.Tests (Vector3EqualsTest) crashes under minopts The test crashes on Windows and Unix under JITMinOpts=1 or TieredCompilation=1. Stack:

</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19196</IssueLabelID>
    <Title>Fix mscordbi metadata reader alignment bug on Linux.</Title>
    <Description>Works fine on Windows minidumps but on Linux (via OpenVirtualProcess
for production breakpoints and future core dumps) the compiler's struct
alignment rules are different. On Windows classes/structs are aligned
based on the largest field. On Linux they are 4 byte aligned regardless
of the field sizes.

https://github.com/dotnet/coreclr/issues/17692</Description>
    <Title_Description>Fix mscordbi metadata reader alignment bug on Linux. Works fine on Windows minidumps but on Linux (via OpenVirtualProcess
for production breakpoints and future core dumps) the compiler's struct
alignment rules are different. On Windows classes/structs are aligned
based on the largest field. On Linux they are 4 byte aligned regardless
of the field sizes.

https://github.com/dotnet/coreclr/issues/17692</Title_Description>
    <Label>
    </Label>
    <Assignee>mikem8361</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19195</IssueLabelID>
    <Title>Add ICustomMarshaler tests</Title>
    <Description>Finally got round to getting https://github.com/dotnet/corefx/pull/17804 into coreclr

@AaronRobinsonMSFT @yizhang82 @tijoytom</Description>
    <Title_Description>Add ICustomMarshaler tests Finally got round to getting https://github.com/dotnet/corefx/pull/17804 into coreclr

@AaronRobinsonMSFT @yizhang82 @tijoytom</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>30/07/2018 1:48:43 PM +00:00</CreatedAt>
    <ClosedAt>18/11/2018 6:31:29 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19194</IssueLabelID>
    <Title>Dataflow cancellation crashes console app when debugger is attached</Title>
    <Description>Platform: Windows
Debugger: Visual Studio 2017
Version: 2.1.2

After pressing Ctrl+C The following program will hang before the 2nd beakpoint is hit but only when debugger is attached:

</Description>
    <Title_Description>Dataflow cancellation crashes console app when debugger is attached Platform: Windows
Debugger: Visual Studio 2017
Version: 2.1.2

After pressing Ctrl+C The following program will hang before the 2nd beakpoint is hit but only when debugger is attached:

</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>30/07/2018 12:48:15 PM +00:00</CreatedAt>
    <ClosedAt>25/02/2019 7:07:15 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19192</IssueLabelID>
    <Title>Unable to catch in managed code any user exception thrown from native Linux code</Title>
    <Description>Basically I have a solution that contains one project of managed C# .NET Core and another native linux C++ project. The managed code project uses the native one. In the native code I throw various C++ exceptions (such as  (again - although I thought I'm not dealing with corrupted-state exceptions).

All to no avail.

I've set-up [this Minimal Complete and Verifiable example](https://github.com/yaireclipse/CatchNativeExceptions) that demonstrates what I currently fail to achieve and the different attempts to solve it.

Tested with .NET Core 2.0 on Ubuntu 16.04.2 LTS (via Bash on Ubuntu on Windows) and CentOS Linux release 7.5.1804 (via Docker for Windows).

This was actually [asked in the past on Stackoverflow](https://stackoverflow.com/questions/50851329/catch-native-exception-in-dotnet-core) by @levhaikin a colleage of mine with no answers so we turn to you :) :

1.  Is my expectation correct? Meaning is there a way in .NET Core to catch an exception thrown from native code in managed code?
2.  If so what am I doing wrong? How should it be done?

Thanks
Yair</Description>
    <Title_Description>Unable to catch in managed code any user exception thrown from native Linux code Basically I have a solution that contains one project of managed C# .NET Core and another native linux C++ project. The managed code project uses the native one. In the native code I throw various C++ exceptions (such as  (again - although I thought I'm not dealing with corrupted-state exceptions).

All to no avail.

I've set-up [this Minimal Complete and Verifiable example](https://github.com/yaireclipse/CatchNativeExceptions) that demonstrates what I currently fail to achieve and the different attempts to solve it.

Tested with .NET Core 2.0 on Ubuntu 16.04.2 LTS (via Bash on Ubuntu on Windows) and CentOS Linux release 7.5.1804 (via Docker for Windows).

This was actually [asked in the past on Stackoverflow](https://stackoverflow.com/questions/50851329/catch-native-exception-in-dotnet-core) by @levhaikin a colleage of mine with no answers so we turn to you :) :

1.  Is my expectation correct? Meaning is there a way in .NET Core to catch an exception thrown from native code in managed code?
2.  If so what am I doing wrong? How should it be done?

Thanks
Yair</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>30/07/2018 12:41:32 AM +00:00</CreatedAt>
    <ClosedAt>30/07/2018 1:20:06 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19190</IssueLabelID>
    <Title>[x64/OSX] JitStress=2 JitStressregs=3 Hardware Intrinsics AVX AVX2 test failures</Title>
    <Description>Recent OSX PR test failed due to several Hardware Intrinsics failures on:

1.  OSX x64 JitStress=2 JitStressregs=3 
2. OSX x64 JitStress=2

https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/x64_checked_osx10.12_jitstress2_jitstressregs3_tst_prtest/2/
https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/x64_checked_osx10.12_jitstress2_flow_prtest/9/

The failures are as follows:



@tannergooding @fiigii @CarolEidt </Description>
    <Title_Description>[x64/OSX] JitStress=2 JitStressregs=3 Hardware Intrinsics AVX, AVX2 test failures Recent OSX PR test failed due to several Hardware Intrinsics failures on:

1.  OSX x64 JitStress=2 JitStressregs=3 
2. OSX x64 JitStress=2

https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/x64_checked_osx10.12_jitstress2_jitstressregs3_tst_prtest/2/
https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/x64_checked_osx10.12_jitstress2_flow_prtest/9/

The failures are as follows:



@tannergooding @fiigii @CarolEidt </Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>tannergooding</Assignee>
    <CreatedAt>29/07/2018 1:16:59 PM +00:00</CreatedAt>
    <ClosedAt>10/12/2018 8:59:30 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19185</IssueLabelID>
    <Title>JIT: Unnecessary field load for promoted struct</Title>
    <Description>&lt;sub&gt;tl;dr: tried to go plaid got polka dots&lt;/sub&gt;
C# code:
 is completely pointless since it's immediately overwritten.</Description>
    <Title_Description>JIT: Unnecessary field load for promoted struct &lt;sub&gt;tl;dr: tried to go plaid got polka dots&lt;/sub&gt;
C# code:
 is completely pointless since it's immediately overwritten.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>28/07/2018 1:55:24 AM +00:00</CreatedAt>
    <ClosedAt>7/02/2019 1:41:03 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19183</IssueLabelID>
    <Title>Create CI jobs for long running tests</Title>
    <Description>In https://github.com/dotnet/coreclr/pull/15388 a number of tests were disabled as "long running" since they exceed normal job timeouts. This means they are currently never running in some scenarios.

Create a new job or set of jobs or other mechanism to run them sometimes.
</Description>
    <Title_Description>Create CI jobs for long running tests In https://github.com/dotnet/coreclr/pull/15388 a number of tests were disabled as "long running" since they exceed normal job timeouts. This means they are currently never running in some scenarios.

Create a new job or set of jobs or other mechanism to run them sometimes.
</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>28/07/2018 12:34:11 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19182</IssueLabelID>
    <Title>[arm32] CQ: improved call sequence for JIT code</Title>
    <Description>JIT'ed code (but not crossgen/ngen code) always generates direct calls using a 10-byte movw/movt/blx sequence e.g.:
 whether it is ok. For ARM32 this function always says no. (For NGEN it says yes but then if we overflow the required relocs by generating a too-large ngen image it restarts the ngen process and disallows direct branches.)

It might be worth doing some investigation to see how many of these calls are likely to be possible to be made direct. Most seem to be to JIT helpers so it would require the generated code buffer to be relatively close to coreclr.dll.


category:cq
theme:optimization
skill-level:expert
cost:large</Description>
    <Title_Description>[arm32] CQ: improved call sequence for JIT code JIT'ed code (but not crossgen/ngen code) always generates direct calls using a 10-byte movw/movt/blx sequence e.g.:
 whether it is ok. For ARM32 this function always says no. (For NGEN it says yes but then if we overflow the required relocs by generating a too-large ngen image it restarts the ngen process and disallows direct branches.)

It might be worth doing some investigation to see how many of these calls are likely to be possible to be made direct. Most seem to be to JIT helpers so it would require the generated code buffer to be relatively close to coreclr.dll.


category:cq
theme:optimization
skill-level:expert
cost:large</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>28/07/2018 12:19:36 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19180</IssueLabelID>
    <Title>build-test - fix TestWrapper CS warnings</Title>
    <Description>@BruceForstall I have splitted my PR #19109 and here is fix for test wrappers only. You can cp or cherry-pick my commit</Description>
    <Title_Description>build-test - fix TestWrapper CS warnings @BruceForstall I have splitted my PR #19109 and here is fix for test wrappers only. You can cp or cherry-pick my commit</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>27/07/2018 11:51:44 PM +00:00</CreatedAt>
    <ClosedAt>28/07/2018 3:50:56 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19179</IssueLabelID>
    <Title>Alpine tests are all broken </Title>
    <Description>https://mc.dot.net/#/product/netcore/30/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fcli~2F/build/20180727.01

It seems some script issue:


Looking back they have been broken for at least a month so we may not be getting any Alpine coverage for that time at least in official runs.

@RussKeldorph </Description>
    <Title_Description>Alpine tests are all broken  https://mc.dot.net/#/product/netcore/30/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fcli~2F/build/20180727.01

It seems some script issue:


Looking back they have been broken for at least a month so we may not be getting any Alpine coverage for that time at least in official runs.

@RussKeldorph </Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>27/07/2018 10:31:56 PM +00:00</CreatedAt>
    <ClosedAt>2/08/2018 6:27:43 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19178</IssueLabelID>
    <Title>[Windows/arm64] Update runtime used to run tests</Title>
    <Description>As part of https://github.com/dotnet/coreclr/issues/18048 (building Windows ARM using public tools) we should also update the snapshot of VC CRT used on the test machines.

netci.groovy currently copies a specific cached copy of part of the CRT when running a Windows arm64 job:

</Description>
    <Title_Description>[Windows/arm64] Update runtime used to run tests As part of https://github.com/dotnet/coreclr/issues/18048 (building Windows ARM using public tools) we should also update the snapshot of VC CRT used on the test machines.

netci.groovy currently copies a specific cached copy of part of the CRT when running a Windows arm64 job:

</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>BruceForstall</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19176</IssueLabelID>
    <Title>Add comment explaining the return value of ToUpper/ToLower</Title>
    <Description>Fixes https://github.com/dotnet/corefx/issues/31340

cc @Tornhoof @JarLob</Description>
    <Title_Description>Add comment explaining the return value of ToUpper/ToLower Fixes https://github.com/dotnet/corefx/issues/31340

cc @Tornhoof @JarLob</Title_Description>
    <Label>area-System.Memory</Label>
    <Assignee>ahsonkhan</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19175</IssueLabelID>
    <Title>Reduce the scope of the CCW cache or consider lock free</Title>
    <Description>In processes that heavy use of COM can have considerable contention on the CCW cache lock.  Currently the lock is for the whole process (eg. per-appdomain).</Description>
    <Title_Description>Reduce the scope of the CCW cache or consider lock free In processes that heavy use of COM can have considerable contention on the CCW cache lock.  Currently the lock is for the whole process (eg. per-appdomain).</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jeffschwMSFT</Assignee>
    <CreatedAt>27/07/2018 8:22:08 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19174</IssueLabelID>
    <Title>Make compiler warnings as errors for test projects to enforce explicit handling of warnings during tests build</Title>
    <Description>Over last couple of months coreclr tests accumulated increasing number of compiler warnings (C# IL C++) which create a lot of noise. According to my checks there were couple of thousands of them for inner loop tests only.

There are increasing number of msbuild warnings as well however they should be fixed after projects are converted to SDK style.

One of actions which would prevent accumulation of warnings would be treating them as errors by compilers what would force everyone to handle them explicitly. Elimination of current warnings may take more than PR and it would be good to avoid them in future.

cc @BruceForstall @jkotas @AaronRobinsonMSFT @jashook @tannergooding @AndyAyersMS 
</Description>
    <Title_Description>Make compiler warnings as errors for test projects to enforce explicit handling of warnings during tests build Over last couple of months coreclr tests accumulated increasing number of compiler warnings (C# IL C++) which create a lot of noise. According to my checks there were couple of thousands of them for inner loop tests only.

There are increasing number of msbuild warnings as well however they should be fixed after projects are converted to SDK style.

One of actions which would prevent accumulation of warnings would be treating them as errors by compilers what would force everyone to handle them explicitly. Elimination of current warnings may take more than PR and it would be good to avoid them in future.

cc @BruceForstall @jkotas @AaronRobinsonMSFT @jashook @tannergooding @AndyAyersMS 
</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>27/07/2018 8:18:50 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19171</IssueLabelID>
    <Title>Lowering: Atomic ops can produce a value</Title>
    <Description>This code:
) for the case where the result of an atomic op is passed to a call.</Description>
    <Title_Description>Lowering: Atomic ops can produce a value This code:
) for the case where the result of an atomic op is passed to a call.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19168</IssueLabelID>
    <Title>WIP Update baseservices tests to SDK style csprojs</Title>
    <Description>Update the base services test projects to SDK style projects</Description>
    <Title_Description>WIP Update baseservices tests to SDK style csprojs Update the base services test projects to SDK style projects</Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>chsienki</Assignee>
    <CreatedAt>27/07/2018 6:31:05 PM +00:00</CreatedAt>
    <ClosedAt>1/08/2018 5:24:45 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19167</IssueLabelID>
    <Title>BuildTest fails in CI for 2.0.0</Title>
    <Description>&gt; 11:07:05 Locating coredistools.dll
11:07:05 File Not Found
11:07:05 CoreDisTools library path: 
11:07:05 Failed to locate the downloaded library: 
11:07:05 BUILDTEST: Commencing build of native test components for arm/Debug
11:07:05 BUILDTEST: Using environment: "C:\Program Files (x86)\Microsoft Visual Studio\2017\Enterprise\Common7\Tools\\..\..\VC\Auxiliary\Build\vcvarsall.bat" x86_arm
11:07:06 **********************************************************************
11:07:06 ** Visual Studio 2017 Developer Command Prompt v15.0.26730.16
11:07:06 ** Copyright (c) 2017 Microsoft Corporation
11:07:06 **********************************************************************
11:07:06 The input line is too long.
11:07:06 :export_x86
11:07:06  was unexpected at this time.
11:07:06 

https://ci.dot.net/job/dotnet_coreclr/job/release_2.0.0/job/arm_cross_release_windows_nt_prtest/

CC @joshfree </Description>
    <Title_Description>BuildTest fails in CI for 2.0.0 &gt; 11:07:05 Locating coredistools.dll
11:07:05 File Not Found
11:07:05 CoreDisTools library path: 
11:07:05 Failed to locate the downloaded library: 
11:07:05 BUILDTEST: Commencing build of native test components for arm/Debug
11:07:05 BUILDTEST: Using environment: "C:\Program Files (x86)\Microsoft Visual Studio\2017\Enterprise\Common7\Tools\\..\..\VC\Auxiliary\Build\vcvarsall.bat" x86_arm
11:07:06 **********************************************************************
11:07:06 ** Visual Studio 2017 Developer Command Prompt v15.0.26730.16
11:07:06 ** Copyright (c) 2017 Microsoft Corporation
11:07:06 **********************************************************************
11:07:06 The input line is too long.
11:07:06 :export_x86
11:07:06  was unexpected at this time.
11:07:06 

https://ci.dot.net/job/dotnet_coreclr/job/release_2.0.0/job/arm_cross_release_windows_nt_prtest/

CC @joshfree </Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>wtgodbe</Assignee>
    <CreatedAt>27/07/2018 6:29:00 PM +00:00</CreatedAt>
    <ClosedAt>3/12/2018 9:41:51 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19166</IssueLabelID>
    <Title>Suggested enhancements to CheckProjects</Title>
    <Description>The CheckProjects jit test is intended to verify that all the jit test project files meet our expectations:

* test suffix convention (_d _do etc) matches projects settings
* the IL generated for the test does not depend on the ambient build environment

#19132 points out some example where the optimization settings were not checked
#19131 some examples where the suffix convention was misused

We should enhance CheckProjects to catch those cases.

#19165 is removing check exclusions for the codegen bring up tests so all jit tests (modulo the bugs above) should now conform.

In addition because it can rewrite project files we might want to enhance it so that all projects have a unique GUID.

If / when we convert tests over to using SDK style projects we should make corresponding updates to the tool.

category:testing
theme:testing
skill-level:beginner
cost:small</Description>
    <Title_Description>Suggested enhancements to CheckProjects The CheckProjects jit test is intended to verify that all the jit test project files meet our expectations:

* test suffix convention (_d _do etc) matches projects settings
* the IL generated for the test does not depend on the ambient build environment

#19132 points out some example where the optimization settings were not checked
#19131 some examples where the suffix convention was misused

We should enhance CheckProjects to catch those cases.

#19165 is removing check exclusions for the codegen bring up tests so all jit tests (modulo the bugs above) should now conform.

In addition because it can rewrite project files we might want to enhance it so that all projects have a unique GUID.

If / when we convert tests over to using SDK style projects we should make corresponding updates to the tool.

category:testing
theme:testing
skill-level:beginner
cost:small</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
    <CreatedAt>27/07/2018 6:07:26 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19164</IssueLabelID>
    <Title>Interop\COM\NETClients\Primitives\NETClientPrimitives fails on r2r and some jitstress jobs</Title>
    <Description>- See PR https://github.com/dotnet/coreclr/pull/19122
- Example: https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_checked_windows_nt_r2r_prtest/70/



@AaronRobinsonMSFT this test did not seem to get disabled in these jobs by https://github.com/dotnet/coreclr/pull/19047 though I'm not sure if it's related.

@BruceForstall is there something special about the r2r and jitstress jobs do they run in a particular mode? Is there a way to disable a test from those jobs?</Description>
    <Title_Description>Interop\COM\NETClients\Primitives\NETClientPrimitives fails on r2r and some jitstress jobs - See PR https://github.com/dotnet/coreclr/pull/19122
- Example: https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_checked_windows_nt_r2r_prtest/70/



@AaronRobinsonMSFT this test did not seem to get disabled in these jobs by https://github.com/dotnet/coreclr/pull/19047 though I'm not sure if it's related.

@BruceForstall is there something special about the r2r and jitstress jobs do they run in a particular mode? Is there a way to disable a test from those jobs?</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19163</IssueLabelID>
    <Title>Temporarily flag a SIMD test as optimization-sensitive</Title>
    <Description>The test runs in several PR-triggered jobs. It fails with minopts and once tiering is enabled it would fail in every PR. See https://github.com/dotnet/coreclr/issues/19124.

CC @dotnet/jit-contrib </Description>
    <Title_Description>Temporarily flag a SIMD test as optimization-sensitive The test runs in several PR-triggered jobs. It fails with minopts and once tiering is enabled it would fail in every PR. See https://github.com/dotnet/coreclr/issues/19124.

CC @dotnet/jit-contrib </Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19161</IssueLabelID>
    <Title>Finalizer is called on live object</Title>
    <Description>[This test](https://github.com/Spreads/Spreads/blob/d5a9239cbea0df292c14abaac783ecd63efed9d7/tests/Spreads.Core.Tests/Cursors/AsyncCursorTests.cs#L452-L530) fails not always but reliably when [run multiple times in a loop](https://github.com/Spreads/Spreads/blob/d5a9239cbea0df292c14abaac783ecd63efed9d7/tests/Spreads.Core.Run/Program.cs#L10-L17).

The [problem I observe](https://github.com/Spreads/Spreads/blob/d5a9239cbea0df292c14abaac783ecd63efed9d7/tests/Spreads.Core.Tests/Cursors/AsyncCursorTests.cs#L499) is that an object is finalized (and GCed if I comment the finalizer away) when there are strong references to it from within async task that is being awaited later. [Here](https://github.com/Spreads/Spreads/blob/d5a9239cbea0df292c14abaac783ecd63efed9d7/tests/Spreads.Core.Tests/Cursors/AsyncCursorTests.cs#L512) and [here](https://github.com/Spreads/Spreads/blob/d5a9239cbea0df292c14abaac783ecd63efed9d7/tests/Spreads.Core.Tests/Cursors/AsyncCursorTests.cs#L514) there are references that cause side effects (
</Description>
    <Title_Description>Finalizer is called on live object [This test](https://github.com/Spreads/Spreads/blob/d5a9239cbea0df292c14abaac783ecd63efed9d7/tests/Spreads.Core.Tests/Cursors/AsyncCursorTests.cs#L452-L530) fails not always but reliably when [run multiple times in a loop](https://github.com/Spreads/Spreads/blob/d5a9239cbea0df292c14abaac783ecd63efed9d7/tests/Spreads.Core.Run/Program.cs#L10-L17).

The [problem I observe](https://github.com/Spreads/Spreads/blob/d5a9239cbea0df292c14abaac783ecd63efed9d7/tests/Spreads.Core.Tests/Cursors/AsyncCursorTests.cs#L499) is that an object is finalized (and GCed if I comment the finalizer away) when there are strong references to it from within async task that is being awaited later. [Here](https://github.com/Spreads/Spreads/blob/d5a9239cbea0df292c14abaac783ecd63efed9d7/tests/Spreads.Core.Tests/Cursors/AsyncCursorTests.cs#L512) and [here](https://github.com/Spreads/Spreads/blob/d5a9239cbea0df292c14abaac783ecd63efed9d7/tests/Spreads.Core.Tests/Cursors/AsyncCursorTests.cs#L514) there are references that cause side effects (
</Title_Description>
    <Label>area-GC</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>27/07/2018 11:35:32 AM +00:00</CreatedAt>
    <ClosedAt>3/08/2018 2:39:15 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19159</IssueLabelID>
    <Title>Temporary path being defined as C:\Windows.</Title>
    <Description>Oddly today while working me and a co-worker experienced a strange encounter where our lockfile was attempting to be created in C:\Windows while running the application as the current logged on user.

We expected this to be a problem with my environment variables however they appear to be set properly.

![image](https://user-images.githubusercontent.com/33913289/43299462-537f9544-9128-11e8-89e6-a534ccea902a.png)


This is the logs from our ASP.NET Core Application.

---

Environment Information:
Windows 10 (10.0.17134 Build 17134)
Dotnet Core/ASP Version: 2.1.2

---

If there's any more information @Wintereise or I can provide we would be glad to help out in solving this issue.</Description>
    <Title_Description>Temporary path being defined as C:\Windows. Oddly today while working me and a co-worker experienced a strange encounter where our lockfile was attempting to be created in C:\Windows while running the application as the current logged on user.

We expected this to be a problem with my environment variables however they appear to be set properly.

![image](https://user-images.githubusercontent.com/33913289/43299462-537f9544-9128-11e8-89e6-a534ccea902a.png)


This is the logs from our ASP.NET Core Application.

---

Environment Information:
Windows 10 (10.0.17134 Build 17134)
Dotnet Core/ASP Version: 2.1.2

---

If there's any more information @Wintereise or I can provide we would be glad to help out in solving this issue.</Title_Description>
    <Label>os-windows</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>27/07/2018 3:12:57 AM +00:00</CreatedAt>
    <ClosedAt>27/07/2018 4:29:30 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19157</IssueLabelID>
    <Title>Add support for writing EventPipeEvents to ProfAPI</Title>
    <Description>This augments the EventPipe framework to send data to the Profiler APIs in addition to any other receivers that may be configured.

This change does not add or remove any requirement on how the eventing system is initialized. Although it does provide a provision to the Profiler APIs that despite whatever the eventing system may be initialized to it can eject itself when it needs to.</Description>
    <Title_Description>Add support for writing EventPipeEvents to ProfAPI This augments the EventPipe framework to send data to the Profiler APIs in addition to any other receivers that may be configured.

This change does not add or remove any requirement on how the eventing system is initialized. Although it does provide a provision to the Profiler APIs that despite whatever the eventing system may be initialized to it can eject itself when it needs to.</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>brianrob</Assignee>
    <CreatedAt>27/07/2018 12:39:04 AM +00:00</CreatedAt>
    <ClosedAt>5/11/2019 6:26:33 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19152</IssueLabelID>
    <Title>Enable Tiered Compilation by default</Title>
    <Description>1) Changes the default state of the tiered compilation feature check to be ON BY DEFAULT
2) Removed comments about the source about this being a work in progress. Although it will surely continue to evolve and improve remaining issues would be better tracked in our issue tracking system with the same default presumption as other runtime features - assume it works unless noted otherwise.
3) Adjusts a number of tests and automated scripts that made assumptions that the default setting of this feature is off.
4) Stop accepting the deprecated env var COMPLUS_EXPERIMENTAL_TieredCompilation. I'm not aware it has any remaining usage but if so we're going to find out.</Description>
    <Title_Description>Enable Tiered Compilation by default 1) Changes the default state of the tiered compilation feature check to be ON BY DEFAULT
2) Removed comments about the source about this being a work in progress. Although it will surely continue to evolve and improve remaining issues would be better tracked in our issue tracking system with the same default presumption as other runtime features - assume it works unless noted otherwise.
3) Adjusts a number of tests and automated scripts that made assumptions that the default setting of this feature is off.
4) Stop accepting the deprecated env var COMPLUS_EXPERIMENTAL_TieredCompilation. I'm not aware it has any remaining usage but if so we're going to find out.</Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19150</IssueLabelID>
    <Title>Enable Tiered Compilation by default</Title>
    <Description>1) Changes the default state of the tiered compilation feature check to be ON BY DEFAULT
2) Removed comments about the source about this being a work in progress. Although it will surely continue to evolve and improve remaining issues would be better tracked in our issue tracking system with the same default presumption as other runtime features - assume it works unless noted otherwise.
3) Adjusts a number of tests and automated scripts that made assumptions that the default setting of this feature is off.
4) Stop accepting the deprecated env var COMPLUS_EXPERIMENTAL_TieredCompilation. I'm not aware it has any remaining usage but if so we're going to find out.</Description>
    <Title_Description>Enable Tiered Compilation by default 1) Changes the default state of the tiered compilation feature check to be ON BY DEFAULT
2) Removed comments about the source about this being a work in progress. Although it will surely continue to evolve and improve remaining issues would be better tracked in our issue tracking system with the same default presumption as other runtime features - assume it works unless noted otherwise.
3) Adjusts a number of tests and automated scripts that made assumptions that the default setting of this feature is off.
4) Stop accepting the deprecated env var COMPLUS_EXPERIMENTAL_TieredCompilation. I'm not aware it has any remaining usage but if so we're going to find out.</Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19149</IssueLabelID>
    <Title>Breaking change in netcoreapp2.1 (possibly JIT bug?) re fixed buffers</Title>
    <Description>New in netcoreapp2.1 (doesn't impact netcoreapp2.0 or net47)

Full repro below; synopsis: fixed buffers go pretty wild when used on a field in a key in a  for both; the first item doesn't have data corruption (but fails anyway) - the second item (longer hits 2 elements) has become corrupted.</Description>
    <Title_Description>Breaking change in netcoreapp2.1 (possibly JIT bug?) re fixed buffers New in netcoreapp2.1 (doesn't impact netcoreapp2.0 or net47)

Full repro below; synopsis: fixed buffers go pretty wild when used on a field in a key in a  for both; the first item doesn't have data corruption (but fails anyway) - the second item (longer hits 2 elements) has become corrupted.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19148</IssueLabelID>
    <Title>COM object lifetime is subject to Windows rundown policy (6 minute idle)</Title>
    <Description>Call CoMarshalInterface with MSHLFLAGS_TABLESTRONG (as opposed to MSHLFLAGS_NORMAL) to avoid COM rundown timeouts.

https://github.com/dotnet/coreclr/blob/8e48db2c113052ef18cdafb43e114a8633864ec0/src/vm/comcache.cpp#L178

The lifetime issue tends to hit very large applications.  Viable workarounds are: 1) use the COM objects regularly or 2) avoid the .NET COM cache and get the raw IntPtr then call GetUniqueObjectForIUnknown.</Description>
    <Title_Description>COM object lifetime is subject to Windows rundown policy (6 minute idle) Call CoMarshalInterface with MSHLFLAGS_TABLESTRONG (as opposed to MSHLFLAGS_NORMAL) to avoid COM rundown timeouts.

https://github.com/dotnet/coreclr/blob/8e48db2c113052ef18cdafb43e114a8633864ec0/src/vm/comcache.cpp#L178

The lifetime issue tends to hit very large applications.  Viable workarounds are: 1) use the COM objects regularly or 2) avoid the .NET COM cache and get the raw IntPtr then call GetUniqueObjectForIUnknown.</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jeffschwMSFT</Assignee>
    <CreatedAt>26/07/2018 9:45:40 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19147</IssueLabelID>
    <Title>Cannot find libSystem.dylib</Title>
    <Description>Our .net core 2.1.201 app uses native interop on Mac and has methods attributed with  some customers report that it fails to find libSystem.dylib or one of its dependencies:
</Description>
    <Title_Description>Cannot find libSystem.dylib Our .net core 2.1.201 app uses native interop on Mac and has methods attributed with  some customers report that it fails to find libSystem.dylib or one of its dependencies:
</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>26/07/2018 9:12:56 PM +00:00</CreatedAt>
    <ClosedAt>26/10/2018 7:08:54 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19140</IssueLabelID>
    <Title>JIT: assert compiling System.Runtime.Intrinsics.X86.Avx:TestC via PMI</Title>
    <Description>I made a couple of improvements to the generic expansions in PMI and am now seeing an assert when running PMI on system.private.corelib:


To repro build x64 checked sync to latest jitutils and build then run the above.</Description>
    <Title_Description>JIT: assert compiling System.Runtime.Intrinsics.X86.Avx:TestC via PMI I made a couple of improvements to the generic expansions in PMI and am now seeing an assert when running PMI on system.private.corelib:


To repro build x64 checked sync to latest jitutils and build then run the above.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
    <CreatedAt>26/07/2018 4:10:22 PM +00:00</CreatedAt>
    <ClosedAt>27/07/2018 2:07:51 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19139</IssueLabelID>
    <Title>Unnecessary code in System.Numerics.ConstantHelper ?</Title>
    <Description>most of the methods in [System.Private.CoreLib/shared/System/Numerics/ConstantHelper.cs](https://github.com/dotnet/coreclr/blob/1456a38ed9ee3eda8022b9f162a45334723a0d7a/src/System.Private.CoreLib/shared/System/Numerics/ConstantHelper.cs#L12) are using unsafe/unchecked blocks unnecessarly
shouldn't a simple method like 
</Description>
    <Title_Description>Unnecessary code in System.Numerics.ConstantHelper ? most of the methods in [System.Private.CoreLib/shared/System/Numerics/ConstantHelper.cs](https://github.com/dotnet/coreclr/blob/1456a38ed9ee3eda8022b9f162a45334723a0d7a/src/System.Private.CoreLib/shared/System/Numerics/ConstantHelper.cs#L12) are using unsafe/unchecked blocks unnecessarly
shouldn't a simple method like 
</Title_Description>
    <Label>area-Meta-corelib</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>26/07/2018 2:56:46 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19138</IssueLabelID>
    <Title>Build failure: error CS1503: Argument 1: cannot convert from 'System.Runtime.Intrinsics.Vector256&lt;sbyte&gt;' to 'System.Runtime.Intrinsics.Vector256&lt;byte&gt;'</Title>
    <Description>Opened on behalf of @RussKeldorph

Warnings: 1
Status Message: failed

Build : 2.1 - 20180726.01 (Product Build)
Failing configurations:
- Alpine3.6
  - Build-Tests-R2R-Release
  - Build-Tests-Release
- RedHat6
  - Build-Tests-R2R-Release
  - Build-Tests-Release
- RedHat 7
  - Build-Tests-R2R-Release
  - Build-Tests-Release
- OSX
  - Build-Tests-R2R-Release
  - Build-Tests-Release
- Windows
  - Build-Tests-R2R-Release-arm64
  - Build-Tests-Release-arm64
  - Build-Tests-R2R-Release
  - Build-Tests-Release
[Mission Control Build Info](https://mc.dot.net/#/product/netcore/21/source/prodcon~2Fcoreclr~2Frelease~2F2.1~2F/type/build~2Fproduct~2F/build/20180726.01/workItem/Orchestration/analysis/external/Link)
</Description>
    <Title_Description>Build failure: error CS1503: Argument 1: cannot convert from 'System.Runtime.Intrinsics.Vector256&lt;sbyte&gt;' to 'System.Runtime.Intrinsics.Vector256&lt;byte&gt;' Opened on behalf of @RussKeldorph

Warnings: 1
Status Message: failed

Build : 2.1 - 20180726.01 (Product Build)
Failing configurations:
- Alpine3.6
  - Build-Tests-R2R-Release
  - Build-Tests-Release
- RedHat6
  - Build-Tests-R2R-Release
  - Build-Tests-Release
- RedHat 7
  - Build-Tests-R2R-Release
  - Build-Tests-Release
- OSX
  - Build-Tests-R2R-Release
  - Build-Tests-Release
- Windows
  - Build-Tests-R2R-Release-arm64
  - Build-Tests-Release-arm64
  - Build-Tests-R2R-Release
  - Build-Tests-Release
[Mission Control Build Info](https://mc.dot.net/#/product/netcore/21/source/prodcon~2Fcoreclr~2Frelease~2F2.1~2F/type/build~2Fproduct~2F/build/20180726.01/workItem/Orchestration/analysis/external/Link)
</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>26/07/2018 2:52:54 PM +00:00</CreatedAt>
    <ClosedAt>9/08/2018 8:37:01 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19135</IssueLabelID>
    <Title>[automated] Merge branch 'release/2.1' =&gt; 'release/2.2'</Title>
    <Description>I detected changes in the release/2.1 branch which have not been merged yet to release/2.2.
I'm a robot and am configured to help you automatically keep release/2.2 up to date so
I've opened this PR.

This PR merges commits made on release/2.1 by the following committers:

* @weshaggard
* @dotnet-maestro-bot

## Instructions for merging

This PR will not be auto-merged. When pull request checks pass please complete this PR
by creating a merge commit *not* a squash or rebase commit.

&lt;img alt="merge button instructions" src="https://i.imgur.com/GepcNJV.png" width="300" /&gt;

You can also do this on command line:


:warning: If there are merge conflicts you will need to resolve them manually before merging.

Please contact ASP.NET Core Engineering if you have questions or issues.
Also if this PR was generated incorrectly help us fix it. See https://github.com/aspnet/BuildTools/blob/master/scripts/GitHubMergeBranches.ps1.</Description>
    <Title_Description>[automated] Merge branch 'release/2.1' =&gt; 'release/2.2' I detected changes in the release/2.1 branch which have not been merged yet to release/2.2.
I'm a robot and am configured to help you automatically keep release/2.2 up to date so
I've opened this PR.

This PR merges commits made on release/2.1 by the following committers:

* @weshaggard
* @dotnet-maestro-bot

## Instructions for merging

This PR will not be auto-merged. When pull request checks pass please complete this PR
by creating a merge commit *not* a squash or rebase commit.

&lt;img alt="merge button instructions" src="https://i.imgur.com/GepcNJV.png" width="300" /&gt;

You can also do this on command line:


:warning: If there are merge conflicts you will need to resolve them manually before merging.

Please contact ASP.NET Core Engineering if you have questions or issues.
Also if this PR was generated incorrectly help us fix it. See https://github.com/aspnet/BuildTools/blob/master/scripts/GitHubMergeBranches.ps1.</Title_Description>
    <Label>
    </Label>
    <Assignee>wtgodbe</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19134</IssueLabelID>
    <Title>Enable optimizations for interoputil.cpp@SafeRelease</Title>
    <Description>https://github.com/dotnet/coreclr/blob/master/src/vm/interoputil.cpp#L1510

Optimizations were disabled years ago due to a likely now fixed native toolset bug.</Description>
    <Title_Description>Enable optimizations for interoputil.cpp@SafeRelease https://github.com/dotnet/coreclr/blob/master/src/vm/interoputil.cpp#L1510

Optimizations were disabled years ago due to a likely now fixed native toolset bug.</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19133</IssueLabelID>
    <Title>Tiered Compilation: Need an ETW event that explicitly indicates tiering is enabled or disabled</Title>
    <Description>Right now PerfView assumes that the lack of a jit compilation tier1 event means tiering was disabled but this is error prone in at least two situations:
a) Short running apps may never have time to tier any methods but the feature was enabled
b) Apps that generate large amounts of ETW events may drop events or exhaust the circular buffer causing all tier1 jit events to be lost (this is exacerbated by PerfView's misleading UI that shows you have enough buffer even when events are being dropped)</Description>
    <Title_Description>Tiered Compilation: Need an ETW event that explicitly indicates tiering is enabled or disabled Right now PerfView assumes that the lack of a jit compilation tier1 event means tiering was disabled but this is error prone in at least two situations:
a) Short running apps may never have time to tier any methods but the feature was enabled
b) Apps that generate large amounts of ETW events may drop events or exhaust the circular buffer causing all tier1 jit events to be lost (this is exacerbated by PerfView's misleading UI that shows you have enough buffer even when events are being dropped)</Title_Description>
    <Label>area-TieredCompilation</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19132</IssueLabelID>
    <Title>Incorrect Optimization setting for tests</Title>
    <Description>The naming convention is that 

(related: https://github.com/dotnet/coreclr/pull/19083)</Description>
    <Title_Description>Incorrect Optimization setting for tests The naming convention is that 

(related: https://github.com/dotnet/coreclr/pull/19083)</Title_Description>
    <Label>
    </Label>
    <Assignee>4creators</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19131</IssueLabelID>
    <Title>Incorrect naming for JIT\HardwareIntrinsics\X86\Sse2 test projects</Title>
    <Description>The naming of the following doesn't follow the correct naming scheme:

</Description>
    <Title_Description>Incorrect naming for JIT\HardwareIntrinsics\X86\Sse2 test projects The naming of the following doesn't follow the correct naming scheme:

</Title_Description>
    <Label>
    </Label>
    <Assignee>4creators</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19129</IssueLabelID>
    <Title>[RyuJIT] lack of escape analysis makes redundant memory-access of Vector128/256&lt;T&gt; fields</Title>
    <Description>Related to https://github.com/dotnet/coreclr/issues/19116

The C# source code below is from https://github.com/dotnet/coreclr/pull/18839


category:cq
theme:optimization
skill-level:expert
cost:large</Description>
    <Title_Description>[RyuJIT] lack of escape analysis makes redundant memory-access of Vector128/256&lt;T&gt; fields Related to https://github.com/dotnet/coreclr/issues/19116

The C# source code below is from https://github.com/dotnet/coreclr/pull/18839


category:cq
theme:optimization
skill-level:expert
cost:large</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
    <CreatedAt>25/07/2018 8:18:28 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19128</IssueLabelID>
    <Title>reenable corefx System.Runtime.Tests  on arm32</Title>
    <Description>the issue #17585 was fixed long time ago but this exclusion was forgotten.</Description>
    <Title_Description>reenable corefx System.Runtime.Tests  on arm32 the issue #17585 was fixed long time ago but this exclusion was forgotten.</Title_Description>
    <Label>disabled-test</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>25/07/2018 7:24:14 PM +00:00</CreatedAt>
    <ClosedAt>26/07/2018 10:46:54 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19127</IssueLabelID>
    <Title>JIT: gcstress failure in BMI1 test x64 minopts</Title>
    <Description>Suspect this is likely a test bug as the test is new....

To repro: build x64 checked build tests\src\jit\HardwareIntrinsics\X86\bmi1\Bmi1_r.csproj


cc @dotnet/jit-contrib @tannergooding </Description>
    <Title_Description>JIT: gcstress failure in BMI1 test x64 minopts Suspect this is likely a test bug as the test is new....

To repro: build x64 checked build tests\src\jit\HardwareIntrinsics\X86\bmi1\Bmi1_r.csproj


cc @dotnet/jit-contrib @tannergooding </Title_Description>
    <Label>GCStress</Label>
    <Assignee>tannergooding</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19124</IssueLabelID>
    <Title>JIT: SysV minopts simd assert in fgMorphMultiregStructArg</Title>
    <Description>To repro on windows: build x64 checked build the jit\SIMD\VectorExp_ro test.


Assert is that morph sees an unexpected GT_COMMA.

You can also repro via PMI if you pick up dotnet/jitutils#159.

cc @dotnet/jit-contrib </Description>
    <Title_Description>JIT: SysV minopts simd assert in fgMorphMultiregStructArg To repro on windows: build x64 checked build the jit\SIMD\VectorExp_ro test.


Assert is that morph sees an unexpected GT_COMMA.

You can also repro via PMI if you pick up dotnet/jitutils#159.

cc @dotnet/jit-contrib </Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19123</IssueLabelID>
    <Title>Add CI PR-triggered Ubuntu x64 innerloop no-tiering job</Title>
    <Description>
    </Description>
    <Title_Description>Add CI PR-triggered Ubuntu x64 innerloop no-tiering job </Title_Description>
    <Label>area-TieredCompilation</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19122</IssueLabelID>
    <Title>[WIP] Test new CI jobs for enabling Tiered Compilation by default</Title>
    <Description>For https://github.com/dotnet/coreclr/pull/19121</Description>
    <Title_Description>[WIP] Test new CI jobs for enabling Tiered Compilation by default For https://github.com/dotnet/coreclr/pull/19121</Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19121</IssueLabelID>
    <Title>Enable Tiered Compilation by default</Title>
    <Description>1) Changes the default state of the tiered compilation feature check to be ON BY DEFAULT
2) Removed comments about the source about this being a work in progress. Although it will surely continue to evolve and improve remaining issues would be better tracked in our issue tracking system with the same default presumption as other runtime features - assume it works unless noted otherwise.
3) Adjusts a number of tests and automated scripts that made assumptions that the default setting of this feature is off.
4) Stop accepting the deprecated env var COMPLUS_EXPERIMENTAL_TieredCompilation. I'm not aware it has any remaining usage but if so we're going to find out.</Description>
    <Title_Description>Enable Tiered Compilation by default 1) Changes the default state of the tiered compilation feature check to be ON BY DEFAULT
2) Removed comments about the source about this being a work in progress. Although it will surely continue to evolve and improve remaining issues would be better tracked in our issue tracking system with the same default presumption as other runtime features - assume it works unless noted otherwise.
3) Adjusts a number of tests and automated scripts that made assumptions that the default setting of this feature is off.
4) Stop accepting the deprecated env var COMPLUS_EXPERIMENTAL_TieredCompilation. I'm not aware it has any remaining usage but if so we're going to find out.</Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19120</IssueLabelID>
    <Title>Support .Net Core in RegAsm and TlbExp</Title>
    <Description>Currently you can create .net core application with COM object:


How can I register COM objects from .net core and then use it in CPP (existing) application?

I was trying publish application with --self-contained. It doesn't work too.</Description>
    <Title_Description>Support .Net Core in RegAsm and TlbExp Currently you can create .net core application with COM object:


How can I register COM objects from .net core and then use it in CPP (existing) application?

I was trying publish application with --self-contained. It doesn't work too.</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19119</IssueLabelID>
    <Title>Where is source code for .NET Native toolchain?</Title>
    <Description>Hello

I'm trying to find the source code for the .NET Native toolchain.  Is this in some dotnet repo?  Specifically ilc.exe nutc_driver.exe etc.

Thanks so much</Description>
    <Title_Description>Where is source code for .NET Native toolchain? Hello

I'm trying to find the source code for the .NET Native toolchain.  Is this in some dotnet repo?  Specifically ilc.exe nutc_driver.exe etc.

Thanks so much</Title_Description>
    <Label>question</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>24/07/2018 11:40:30 PM +00:00</CreatedAt>
    <ClosedAt>26/07/2018 9:04:28 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19118</IssueLabelID>
    <Title>IMetaDataImport::GetFieldProps reporting size of field name wrong</Title>
    <Description>Working with this API and in this method:


reports as a size of 8.

Any idea why this is?</Description>
    <Title_Description>IMetaDataImport::GetFieldProps reporting size of field name wrong Working with this API and in this method:


reports as a size of 8.

Any idea why this is?</Title_Description>
    <Label>question</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>24/07/2018 11:02:53 PM +00:00</CreatedAt>
    <ClosedAt>25/07/2018 7:05:47 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19116</IssueLabelID>
    <Title>[RyuJIT] lack of escape analysis makes high GC overhead in SoA SIMD programs</Title>
    <Description>According to the VTune characterization https://github.com/dotnet/coreclr/pull/18839#issue-200232155 SoA SIMD programs have higher GC overhead than AoS and scalar programs because of temp object allocation.

SoA SIMD programs use  that will generate so much memory copies and get worse performance.


category:cq
theme:optimization
skill-level:expert
cost:large</Description>
    <Title_Description>[RyuJIT] lack of escape analysis makes high GC overhead in SoA SIMD programs According to the VTune characterization https://github.com/dotnet/coreclr/pull/18839#issue-200232155 SoA SIMD programs have higher GC overhead than AoS and scalar programs because of temp object allocation.

SoA SIMD programs use  that will generate so much memory copies and get worse performance.


category:cq
theme:optimization
skill-level:expert
cost:large</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
    <CreatedAt>24/07/2018 8:56:48 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19114</IssueLabelID>
    <Title>[WIP] Dummy change PR to dev/unix_test_workflow</Title>
    <Description>
    </Description>
    <Title_Description>[WIP] Dummy change PR to dev/unix_test_workflow </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>dotnet-bot</Assignee>
    <CreatedAt>24/07/2018 8:12:41 PM +00:00</CreatedAt>
    <ClosedAt>2/08/2018 1:10:59 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19113</IssueLabelID>
    <Title>[WIP] Dummy change PR to dev/unix_test_workflow</Title>
    <Description>
    </Description>
    <Title_Description>[WIP] Dummy change PR to dev/unix_test_workflow </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>24/07/2018 6:38:39 PM +00:00</CreatedAt>
    <ClosedAt>24/07/2018 8:13:10 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19112</IssueLabelID>
    <Title>Lightweight and dynamic driving of P/Invoke</Title>
    <Description>While Mono has 


</Description>
    <Title_Description>Lightweight and dynamic driving of P/Invoke While Mono has 


</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>24/07/2018 2:22:42 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19108</IssueLabelID>
    <Title>CoreCLR failed to run test in VS2017 Update 7</Title>
    <Description>CoreCLR failed to run test on Windows with VS2017 Update7. Could you please help take a look at this? Thank you!

**You can repro this issue as the steps below:**
1. git clone https://github.com/dotnet/coreclr D:\CoreCLR\src
2. Open a clean x86 prompt (C:\windows\syswow64\cmd.exe) and browse to D:\CoreCLR\src
3. build x86 release -Rebuild -- /clp:ShowCommandLine
4. build-test.cmd x86 release -- /clp:ShowCommandLine
5. tests\runtest.cmd x86 release

**Error info:**
The whole log file please see attachment.
[log_x86_test.log](https://github.com/dotnet/coreclr/files/2223051/log_x86_test.log)
</Description>
    <Title_Description>CoreCLR failed to run test in VS2017 Update 7 CoreCLR failed to run test on Windows with VS2017 Update7. Could you please help take a look at this? Thank you!

**You can repro this issue as the steps below:**
1. git clone https://github.com/dotnet/coreclr D:\CoreCLR\src
2. Open a clean x86 prompt (C:\windows\syswow64\cmd.exe) and browse to D:\CoreCLR\src
3. build x86 release -Rebuild -- /clp:ShowCommandLine
4. build-test.cmd x86 release -- /clp:ShowCommandLine
5. tests\runtest.cmd x86 release

**Error info:**
The whole log file please see attachment.
[log_x86_test.log](https://github.com/dotnet/coreclr/files/2223051/log_x86_test.log)
</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>sandreenko</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19107</IssueLabelID>
    <Title>Add Interop/PInvoke/Attributes tests</Title>
    <Description>
    </Description>
    <Title_Description>Add Interop/PInvoke/Attributes tests </Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jkoritzinsky</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19093</IssueLabelID>
    <Title>Leaked ICorProfilerCallback9 in vm/eetoprofinterfaceimpl.cpp</Title>
    <Description>Hi guys!

Looks like we forgot to Release  in [EEToProfInterfaceImpl::~EEToProfInterfaceImpl()](https://github.com/dotnet/coreclr/blob/67a66156d0307b49522a13618522d289268bc1f9/src/vm/eetoprofinterfaceimpl.cpp#L964). Can anyone check and fix it? 

cc: @mjsabby 

P.S. I can prepare a pull request for this issue.</Description>
    <Title_Description>Leaked ICorProfilerCallback9 in vm/eetoprofinterfaceimpl.cpp Hi guys!

Looks like we forgot to Release  in [EEToProfInterfaceImpl::~EEToProfInterfaceImpl()](https://github.com/dotnet/coreclr/blob/67a66156d0307b49522a13618522d289268bc1f9/src/vm/eetoprofinterfaceimpl.cpp#L964). Can anyone check and fix it? 

cc: @mjsabby 

P.S. I can prepare a pull request for this issue.</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>mjsabby</Assignee>
    <CreatedAt>23/07/2018 7:15:43 PM +00:00</CreatedAt>
    <ClosedAt>24/07/2018 4:49:25 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19091</IssueLabelID>
    <Title>[ARM32] Split CodeGen::instGen_Set_Reg_To_Imm into relocatable immediate/non-relocatable immediate cases</Title>
    <Description>As suggested in https://github.com/dotnet/coreclr/pull/19013#discussion_r204171338 the next step complement to #19013 should be splitting ). 

@BruceForstall Please feel free to add if I missed anything

category:implementation
theme:emitter
skill-level:beginner
cost:small</Description>
    <Title_Description>[ARM32] Split CodeGen::instGen_Set_Reg_To_Imm into relocatable immediate/non-relocatable immediate cases As suggested in https://github.com/dotnet/coreclr/pull/19013#discussion_r204171338 the next step complement to #19013 should be splitting ). 

@BruceForstall Please feel free to add if I missed anything

category:implementation
theme:emitter
skill-level:beginner
cost:small</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>23/07/2018 6:06:52 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19090</IssueLabelID>
    <Title>Properly document memory semantics for marshalling x-plat</Title>
    <Description>One of the base assumptions on Windows was that  were the canonical memory management mechanism when performing an interop. These function do not exist on x-plat scenarios so we need some explicit documentation or example where this is demonstrated.

See https://github.com/dotnet/coreclr/issues/19082</Description>
    <Title_Description>Properly document memory semantics for marshalling x-plat One of the base assumptions on Windows was that  were the canonical memory management mechanism when performing an interop. These function do not exist on x-plat scenarios so we need some explicit documentation or example where this is demonstrated.

See https://github.com/dotnet/coreclr/issues/19082</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>23/07/2018 6:00:33 PM +00:00</CreatedAt>
    <ClosedAt>23/07/2018 9:25:59 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19089</IssueLabelID>
    <Title>Support R2RDump on non-Windows and ARM machines</Title>
    <Description>Right now R2RDump is only supported on Windows x64 and x86. It works on Linux but the R2RDumpTests for that OS are disabled because of errors. It hasn't been tested on OSX or ARM.</Description>
    <Title_Description>Support R2RDump on non-Windows and ARM machines Right now R2RDump is only supported on Windows x64 and x86. It works on Linux but the R2RDumpTests for that OS are disabled because of errors. It hasn't been tested on OSX or ARM.</Title_Description>
    <Label>area-R2RDump</Label>
    <Assignee>nattress</Assignee>
    <CreatedAt>23/07/2018 5:39:53 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19088</IssueLabelID>
    <Title>Reduce time in .NET Threadpool's WorkStealingQueue.TrySteal method and ThredPoolWorkQueue.Dequeue methods.  </Title>
    <Description>A number of different users have noted a large amount of time in the .NET ThreadPool WorkStealingQueue.TrySteal method (Being called from [ThredPoolWorkQueue.Dequeue](https://github.com/dotnet/coreclr/blob/master/src/System.Private.CoreLib/src/System/Threading/ThreadPool.cs#L465)  method).    

From what we can tell the scenario that causes is bursty workloads.   For bursty workloads our guidance is to set a MinWorkerThreads high enough so that there are threads available to handle the burst.   For high scale machines (e.g. 16 Proc) it is not uncommon then to set this minimum in the 160-320 thread range.   

When a burst  (lets say it needs 100 threads to do the work) then those 100 threads do the work then calle Dequeue to get the next work.   However the burst is over and thus they all don't find any work left and go through a loop lin the [ThredPoolWorkQueue.Dequeue](https://github.com/dotnet/coreclr/blob/master/src/System.Private.CoreLib/src/System/Threading/ThreadPool.cs#L465)  method to find work to steal from other threads.  (which will fail).

Thus you have 100 threads spinning through 160-320 worker threads looking for more work thus requring 16K to 32K checks.   These threads 'fight' over the memory to check that the queues are empty and thus even though the check is short it consumes a non-trivial amount of CPU time.    If these bursts come frequently (e.g. every 10-100 msec) then the CPU adds up.   

Here is where we see the CPU time spent (This is on Desktop framework but the code is very similar  for .NET core).  Here is the code in Dequeue. 


In .NET Core the code is a bit different because we have created a helper called 'CanSteal' that does m_headIndex &gt;= m_tailIndex and we call this helper in Dequeue before calling TrySteal.  This helps cut the cost per iteration but does not mitigate the fact that we are doing an O(n) operation and we have to 'fight' over the memory representing m_headIndex and m_tailIndex variables)   Thus on .NET Core the problem will not show up in TrySteal and should be less severe but probably still problematic.  

To really fix the problem we need to be less aggressive about checking for stealing.   Ideally want to do some checking but we want to be much less aggressive if we know that other threads will shortly come along and do a more aggressive check.   This avoids O(N) behavior which is the fundamental problem.  

The solutions probably looks like only looking for work to steal for a subset unless we have been asked to be 'aggressive'.   We are aggressive only after a certain amount of time. 

@kouvel @stephentoub 
</Description>
    <Title_Description>Reduce time in .NET Threadpool's WorkStealingQueue.TrySteal method and ThredPoolWorkQueue.Dequeue methods.   A number of different users have noted a large amount of time in the .NET ThreadPool WorkStealingQueue.TrySteal method (Being called from [ThredPoolWorkQueue.Dequeue](https://github.com/dotnet/coreclr/blob/master/src/System.Private.CoreLib/src/System/Threading/ThreadPool.cs#L465)  method).    

From what we can tell the scenario that causes is bursty workloads.   For bursty workloads our guidance is to set a MinWorkerThreads high enough so that there are threads available to handle the burst.   For high scale machines (e.g. 16 Proc) it is not uncommon then to set this minimum in the 160-320 thread range.   

When a burst  (lets say it needs 100 threads to do the work) then those 100 threads do the work then calle Dequeue to get the next work.   However the burst is over and thus they all don't find any work left and go through a loop lin the [ThredPoolWorkQueue.Dequeue](https://github.com/dotnet/coreclr/blob/master/src/System.Private.CoreLib/src/System/Threading/ThreadPool.cs#L465)  method to find work to steal from other threads.  (which will fail).

Thus you have 100 threads spinning through 160-320 worker threads looking for more work thus requring 16K to 32K checks.   These threads 'fight' over the memory to check that the queues are empty and thus even though the check is short it consumes a non-trivial amount of CPU time.    If these bursts come frequently (e.g. every 10-100 msec) then the CPU adds up.   

Here is where we see the CPU time spent (This is on Desktop framework but the code is very similar  for .NET core).  Here is the code in Dequeue. 


In .NET Core the code is a bit different because we have created a helper called 'CanSteal' that does m_headIndex &gt;= m_tailIndex and we call this helper in Dequeue before calling TrySteal.  This helps cut the cost per iteration but does not mitigate the fact that we are doing an O(n) operation and we have to 'fight' over the memory representing m_headIndex and m_tailIndex variables)   Thus on .NET Core the problem will not show up in TrySteal and should be less severe but probably still problematic.  

To really fix the problem we need to be less aggressive about checking for stealing.   Ideally want to do some checking but we want to be much less aggressive if we know that other threads will shortly come along and do a more aggressive check.   This avoids O(N) behavior which is the fundamental problem.  

The solutions probably looks like only looking for work to steal for a subset unless we have been asked to be 'aggressive'.   We are aggressive only after a certain amount of time. 

@kouvel @stephentoub 
</Title_Description>
    <Label>area-System.Threading</Label>
    <Assignee>kouvel</Assignee>
    <CreatedAt>23/07/2018 4:56:12 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19086</IssueLabelID>
    <Title>[Ubuntu/arm][GCStress=0xC][ZapDisable] Regressions/coreclr/GitHub_12224/Test12224</Title>
    <Description>This failed twice while testing PR #18784 in 
[Ubuntu arm Cross Checked gcstress0xc_zapdisable Build and Test](https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_ubuntu_gcstress0xc_zapdisable_tst_prtest/5/consoleText)
[Ubuntu arm Cross Checked gcstress0xc_zapdisable_heapverify1 Build and Test](https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_ubuntu_gcstress0xc_zapdisable_heapverify1_tst_prtest/4/consoleText)


**Note:** when the issue is resolved remove the corresponding line in tests/testsFailing.arm.txt (https://github.com/dotnet/coreclr/pull/19087)</Description>
    <Title_Description>[Ubuntu/arm][GCStress=0xC][ZapDisable] Regressions/coreclr/GitHub_12224/Test12224 This failed twice while testing PR #18784 in 
[Ubuntu arm Cross Checked gcstress0xc_zapdisable Build and Test](https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_ubuntu_gcstress0xc_zapdisable_tst_prtest/5/consoleText)
[Ubuntu arm Cross Checked gcstress0xc_zapdisable_heapverify1 Build and Test](https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_ubuntu_gcstress0xc_zapdisable_heapverify1_tst_prtest/4/consoleText)


**Note:** when the issue is resolved remove the corresponding line in tests/testsFailing.arm.txt (https://github.com/dotnet/coreclr/pull/19087)</Title_Description>
    <Label>GCStress</Label>
    <Assignee>AndyAyersMS</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19085</IssueLabelID>
    <Title>[Ubuntu/arm][GCStress=0xC][JitStress] GC/API/WeakReference/Finalize2</Title>
    <Description>This has failed three times while testing PR #18784 in

[Ubuntu arm Cross Checked gcstress0xc_jitstress1 Build and Test](https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_ubuntu_gcstress0xc_jitstress1_tst_prtest/8/consoleText)
[Ubuntu arm Cross Checked gcstress0xc_jitstress2 Build and Test](https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_ubuntu_gcstress0xc_jitstress2_tst_prtest/9/consoleText)


**Note:** when the issue is resolved remove the corresponding line in tests/testsFailing.arm.txt (https://github.com/dotnet/coreclr/pull/19087)</Description>
    <Title_Description>[Ubuntu/arm][GCStress=0xC][JitStress] GC/API/WeakReference/Finalize2 This has failed three times while testing PR #18784 in

[Ubuntu arm Cross Checked gcstress0xc_jitstress1 Build and Test](https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_ubuntu_gcstress0xc_jitstress1_tst_prtest/8/consoleText)
[Ubuntu arm Cross Checked gcstress0xc_jitstress2 Build and Test](https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_ubuntu_gcstress0xc_jitstress2_tst_prtest/9/consoleText)


**Note:** when the issue is resolved remove the corresponding line in tests/testsFailing.arm.txt (https://github.com/dotnet/coreclr/pull/19087)</Title_Description>
    <Label>GCStress</Label>
    <Assignee>AndyAyersMS</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19084</IssueLabelID>
    <Title>Build failure: ARM64 build of Interop\COM\NativeServer\COMNativeServer</Title>
    <Description>Opened on behalf of @RussKeldorph

Warnings: 1
Status Message: failed

Build : Master - 20180723.04 (Product Build)
Failing configurations:
- Windows
  - Build-Tests-R2R-Release-arm64
  - Build-Tests-Release-arm64
[Mission Control Build Info](https://mc.dot.net/#/product/netcore/master/source/official~2Fcoreclr~2Fmaster~2F/type/build~2Fproduct~2F/build/20180723.04/workItem/Orchestration/analysis/external/Link)
</Description>
    <Title_Description>Build failure: ARM64 build of Interop\COM\NativeServer\COMNativeServer Opened on behalf of @RussKeldorph

Warnings: 1
Status Message: failed

Build : Master - 20180723.04 (Product Build)
Failing configurations:
- Windows
  - Build-Tests-R2R-Release-arm64
  - Build-Tests-Release-arm64
[Mission Control Build Info](https://mc.dot.net/#/product/netcore/master/source/official~2Fcoreclr~2Fmaster~2F/type/build~2Fproduct~2F/build/20180723.04/workItem/Orchestration/analysis/external/Link)
</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19082</IssueLabelID>
    <Title>Cross platform PInvoke - returning strings to .NET core 2.0</Title>
    <Description>I need to have my C++ dll return a string to .NET core 2.0 wrapper.   I want .NET to free up string when appropriate and not have to make explicit call back to C++ to deallocate string.  I've been able to do this successfully if I use CoTaskMemAlloc() (in Windows) to allocate the memory for string on C++ side but CoTaskMemAlloc is not supported in Linux.  Windows C++ solution with CoTaskMemAlloc:

**[.NET code]**
        [DllImport(EngineDllFullPath CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.LPStr)]
        public static extern string getText();

        public static string GetValue()
        {
            string s = getText();  // No need to free; .NET will take care of it
            return s;
        }

**[Unmanaged C++ code]**
       char* getText()
       {
          ...
          char* s = (char*)::CoTaskMemAlloc(size);
          ...
          return s;
       }


Is there a cross platform solution to this that doesn't use CoTaskMemAlloc that can compile/run on windows and linux?

Thanks</Description>
    <Title_Description>Cross platform PInvoke - returning strings to .NET core 2.0 I need to have my C++ dll return a string to .NET core 2.0 wrapper.   I want .NET to free up string when appropriate and not have to make explicit call back to C++ to deallocate string.  I've been able to do this successfully if I use CoTaskMemAlloc() (in Windows) to allocate the memory for string on C++ side but CoTaskMemAlloc is not supported in Linux.  Windows C++ solution with CoTaskMemAlloc:

**[.NET code]**
        [DllImport(EngineDllFullPath CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.LPStr)]
        public static extern string getText();

        public static string GetValue()
        {
            string s = getText();  // No need to free; .NET will take care of it
            return s;
        }

**[Unmanaged C++ code]**
       char* getText()
       {
          ...
          char* s = (char*)::CoTaskMemAlloc(size);
          ...
          return s;
       }


Is there a cross platform solution to this that doesn't use CoTaskMemAlloc that can compile/run on windows and linux?

Thanks</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>23/07/2018 11:23:30 AM +00:00</CreatedAt>
    <ClosedAt>23/07/2018 6:02:06 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19081</IssueLabelID>
    <Title>[x86/Windows] Assertion failed 'shiftNode-&gt;OperIsShiftOrRotate()' in lrsabuild.cpp L782 introduced by PR #18941</Title>
    <Description>x86 Windows JitStress=2 JitStressRegs=3 Assertion failed 'shiftNode-&gt;OperIsShiftOrRotate()' in lrsabuild.cpp L782 - 177 failures for outer loop tests 64 failures for inner loop tests when run with JitStress=2 JitStressRegs=3.

https://ci.dot.net/job/dotnet_coreclr/job/master/view/x86/job/jitstress/job/x86_checked_windows_nt_jitstress2_jitstressregs3/556/

Failing tests:



Output dump:

[GitHub-18941-test-output.txt](https://github.com/dotnet/coreclr/files/2219026/GitHub-18941-test-output.txt)

cc @CarolEidt @tannergooding @fiigii </Description>
    <Title_Description>[x86/Windows] Assertion failed 'shiftNode-&gt;OperIsShiftOrRotate()' in lrsabuild.cpp L782 introduced by PR #18941 x86 Windows JitStress=2 JitStressRegs=3 Assertion failed 'shiftNode-&gt;OperIsShiftOrRotate()' in lrsabuild.cpp L782 - 177 failures for outer loop tests 64 failures for inner loop tests when run with JitStress=2 JitStressRegs=3.

https://ci.dot.net/job/dotnet_coreclr/job/master/view/x86/job/jitstress/job/x86_checked_windows_nt_jitstress2_jitstressregs3/556/

Failing tests:



Output dump:

[GitHub-18941-test-output.txt](https://github.com/dotnet/coreclr/files/2219026/GitHub-18941-test-output.txt)

cc @CarolEidt @tannergooding @fiigii </Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19079</IssueLabelID>
    <Title>Remove hosthook api</Title>
    <Description>cc @luqunl @jkotas </Description>
    <Title_Description>Remove hosthook api cc @luqunl @jkotas </Title_Description>
    <Label>area-Interop</Label>
    <Assignee>luqunl</Assignee>
    <CreatedAt>23/07/2018 4:50:13 AM +00:00</CreatedAt>
    <ClosedAt>23/07/2018 10:30:58 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19078</IssueLabelID>
    <Title>JIT: multiply &amp; add not optimized to LEA when destination is a different register</Title>
    <Description> isn't getting used in the scenario where it could also cut out an additional instruction.

category:cq
theme:optimization
skill-level:beginner
cost:small</Description>
    <Title_Description>JIT: multiply &amp; add not optimized to LEA when destination is a different register  isn't getting used in the scenario where it could also cut out an additional instruction.

category:cq
theme:optimization
skill-level:beginner
cost:small</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>23/07/2018 3:48:18 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19076</IssueLabelID>
    <Title>JIT: Stack zeroed with rep stosd</Title>
    <Description>C# source in this gist: https://gist.github.com/Zhentar/4ffb0a5d597c4c1e788d6007f1602b21

According to vTune 5% of my execution time is in my function's prologue. This was unexpected because it hadn't been in previous iterations (and my function body had unfortunately not improved at all).
Looking at the the disassembly I see:
 shouldn't ever be getting emitted.

category:cq
theme:optimization
skill-level:intermediate
cost:medium</Description>
    <Title_Description>JIT: Stack zeroed with rep stosd C# source in this gist: https://gist.github.com/Zhentar/4ffb0a5d597c4c1e788d6007f1602b21

According to vTune 5% of my execution time is in my function's prologue. This was unexpected because it hadn't been in previous iterations (and my function body had unfortunately not improved at all).
Looking at the the disassembly I see:
 shouldn't ever be getting emitted.

category:cq
theme:optimization
skill-level:intermediate
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>erozenfeld</Assignee>
    <CreatedAt>22/07/2018 5:05:57 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19075</IssueLabelID>
    <Title>Pri-1 tests broken as of #18695</Title>
    <Description>All pri-1 JitStress jobs started failing after https://github.com/dotnet/coreclr/pull/18695 was merged.

I have validated locally that reverting f5f9a3456abcfdea5d886fededaa0265c80281ed fixes the issue.</Description>
    <Title_Description>Pri-1 tests broken as of #18695 All pri-1 JitStress jobs started failing after https://github.com/dotnet/coreclr/pull/18695 was merged.

I have validated locally that reverting f5f9a3456abcfdea5d886fededaa0265c80281ed fixes the issue.</Title_Description>
    <Label>
    </Label>
    <Assignee>sbomer</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19074</IssueLabelID>
    <Title>JIT can generate redundant TEST operations</Title>
    <Description>The following C# code generates assembly which has what I understand to be a redundant 

category:cq
theme:optimization
skill-level:beginner
cost:small</Description>
    <Title_Description>JIT can generate redundant TEST operations The following C# code generates assembly which has what I understand to be a redundant 

category:cq
theme:optimization
skill-level:beginner
cost:small</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>21/07/2018 6:40:15 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19071</IssueLabelID>
    <Title>HW Intrinsics: Add BSR BSF and BSWAP intrinsics</Title>
    <Description>BSR &amp; BSF are functionally equivalent to LZCNT &amp; TZCNT for non-zero values - except that instead of needing Haswell/Piledriver plus the minimum requirement is 80386. Would be nice for things like Span&lt;byte&gt;.IndexOf where it's only applied to non-zero values.

BSWAP is an 80486 instruction that reverses the order of bytes. It's supposed to be good for endian-ness conversions but I care because word on the street is that it's better than rotates for entropy diffusion in hash functions leading to some of the trendy new fast hash functions (such as FarmHash and t1ha) using it.

category:proposal
theme:intrinsics
skill-level:intermediate
cost:medium</Description>
    <Title_Description>HW Intrinsics: Add BSR, BSF, and BSWAP intrinsics BSR &amp; BSF are functionally equivalent to LZCNT &amp; TZCNT for non-zero values - except that instead of needing Haswell/Piledriver plus the minimum requirement is 80386. Would be nice for things like Span&lt;byte&gt;.IndexOf where it's only applied to non-zero values.

BSWAP is an 80486 instruction that reverses the order of bytes. It's supposed to be good for endian-ness conversions but I care because word on the street is that it's better than rotates for entropy diffusion in hash functions leading to some of the trendy new fast hash functions (such as FarmHash and t1ha) using it.

category:proposal
theme:intrinsics
skill-level:intermediate
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>21/07/2018 3:19:42 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19070</IssueLabelID>
    <Title>Fix mscordbi metadata reader alignment bug on Linux.</Title>
    <Description>Works fine on Windows minidumps but on Linux (via OpenVirtualProcess
for production breakpoints and future core dumps) the compiler's struct
alignment rules are different. On Windows classes/structs are aligned
based on the largest field. On Linux they are 4 byte aligned regardless
of the field sizes.

https://github.com/dotnet/coreclr/issues/17692</Description>
    <Title_Description>Fix mscordbi metadata reader alignment bug on Linux. Works fine on Windows minidumps but on Linux (via OpenVirtualProcess
for production breakpoints and future core dumps) the compiler's struct
alignment rules are different. On Windows classes/structs are aligned
based on the largest field. On Linux they are 4 byte aligned regardless
of the field sizes.

https://github.com/dotnet/coreclr/issues/17692</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>mikem8361</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19069</IssueLabelID>
    <Title>Prep for ported PInvoke tests from .NET Framework</Title>
    <Description>Add root MSBuild targets for Interop managed test assets
Add root CMake file for Interop native test assets</Description>
    <Title_Description>Prep for ported PInvoke tests from .NET Framework Add root MSBuild targets for Interop managed test assets
Add root CMake file for Interop native test assets</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>20/07/2018 10:49:33 PM +00:00</CreatedAt>
    <ClosedAt>24/07/2018 1:40:17 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19063</IssueLabelID>
    <Title>Update documentation for testing</Title>
    <Description>
    </Description>
    <Title_Description>Update documentation for testing </Title_Description>
    <Label>documentation</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>20/07/2018 6:43:14 PM +00:00</CreatedAt>
    <ClosedAt>20/07/2018 10:27:29 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19061</IssueLabelID>
    <Title>JIT: review costing logic in gtIsLikelyRegVar and gtSetEvalOrder</Title>
    <Description>There are a number of things here that seem questionable or holdovers from when floating point used x87.

Floats can be enregistered now:

https://github.com/dotnet/coreclr/blob/b896dd14830b600043a99c2626ea848ad679fb4f/src/jit/gentree.cpp#L2991-L2996

We don't use these instructions for float literals anymore:

https://github.com/dotnet/coreclr/blob/b896dd14830b600043a99c2626ea848ad679fb4f/src/jit/gentree.cpp#L3238-L3253

Why would enregistered variables incur sign or zero extend costs?

https://github.com/dotnet/coreclr/blob/b896dd14830b600043a99c2626ea848ad679fb4f/src/jit/gentree.cpp#L3257-L3266

Extra size cost (if legit; probably is but we should verify) should also apply to x86:

https://github.com/dotnet/coreclr/blob/b896dd14830b600043a99c2626ea848ad679fb4f/src/jit/gentree.cpp#L3279-L3289

There is probably more.

category:implementation
theme:ir
skill-level:beginner
cost:small</Description>
    <Title_Description>JIT: review costing logic in gtIsLikelyRegVar and gtSetEvalOrder There are a number of things here that seem questionable or holdovers from when floating point used x87.

Floats can be enregistered now:

https://github.com/dotnet/coreclr/blob/b896dd14830b600043a99c2626ea848ad679fb4f/src/jit/gentree.cpp#L2991-L2996

We don't use these instructions for float literals anymore:

https://github.com/dotnet/coreclr/blob/b896dd14830b600043a99c2626ea848ad679fb4f/src/jit/gentree.cpp#L3238-L3253

Why would enregistered variables incur sign or zero extend costs?

https://github.com/dotnet/coreclr/blob/b896dd14830b600043a99c2626ea848ad679fb4f/src/jit/gentree.cpp#L3257-L3266

Extra size cost (if legit; probably is but we should verify) should also apply to x86:

https://github.com/dotnet/coreclr/blob/b896dd14830b600043a99c2626ea848ad679fb4f/src/jit/gentree.cpp#L3279-L3289

There is probably more.

category:implementation
theme:ir
skill-level:beginner
cost:small</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
    <CreatedAt>20/07/2018 5:38:56 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19060</IssueLabelID>
    <Title>.NET Core applications get oom killed on Kubernetes/OpenShift</Title>
    <Description>We have been investigating why .net core applications are killed by OpenShift because they exceed their assigned memory.

OpenShift/Kubernetes informs the app via the sysfs  to measure the memory load of the system.

CC @janvorli </Description>
    <Title_Description>.NET Core applications get oom killed on Kubernetes/OpenShift We have been investigating why .net core applications are killed by OpenShift because they exceed their assigned memory.

OpenShift/Kubernetes informs the app via the sysfs  to measure the memory load of the system.

CC @janvorli </Title_Description>
    <Label>area-GC</Label>
    <Assignee>tmds</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19056</IssueLabelID>
    <Title>.Net Core and IoThread</Title>
    <Description>In the [document](https://github.com/dotnet/coreclr/blob/master/Documentation/project-docs/clr-configuration-knobs.md)  I not found any about IoThread message .NET Core has no IoThread?</Description>
    <Title_Description>.Net Core and IoThread In the [document](https://github.com/dotnet/coreclr/blob/master/Documentation/project-docs/clr-configuration-knobs.md)  I not found any about IoThread message .NET Core has no IoThread?</Title_Description>
    <Label>question</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>20/07/2018 9:39:29 AM +00:00</CreatedAt>
    <ClosedAt>21/07/2018 6:12:04 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19054</IssueLabelID>
    <Title>Allow rejit on attach</Title>
    <Description>
    </Description>
    <Title_Description>Allow rejit on attach </Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>davmason</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19053</IssueLabelID>
    <Title>Set function size to -1 if sizing info unavailable</Title>
    <Description>If GCInfo and RVA information is unavailable Size needs to be set to .</Description>
    <Title_Description>Set function size to -1 if sizing info unavailable If GCInfo and RVA information is unavailable Size needs to be set to .</Title_Description>
    <Label>area-R2RDump</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>20/07/2018 5:52:31 AM +00:00</CreatedAt>
    <ClosedAt>29/08/2018 1:09:05 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19050</IssueLabelID>
    <Title>DO NOT MERGE to master - dummy change for testing CI</Title>
    <Description>
    </Description>
    <Title_Description>DO NOT MERGE to master - dummy change for testing CI </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>noahfalk</Assignee>
    <CreatedAt>20/07/2018 12:24:15 AM +00:00</CreatedAt>
    <ClosedAt>5/09/2018 9:36:15 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19048</IssueLabelID>
    <Title>NETClientPrimitives test fails on Windows.Nano</Title>
    <Description>Remove the global disabling of NETClientPrimitives test done in #19047 by investigating why RegFree COM is failing on Windows.Nano. This is only occurring in helix builds - the test still runs properly in Jenkins CI.</Description>
    <Title_Description>NETClientPrimitives test fails on Windows.Nano Remove the global disabling of NETClientPrimitives test done in #19047 by investigating why RegFree COM is failing on Windows.Nano. This is only occurring in helix builds - the test still runs properly in Jenkins CI.</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>19/07/2018 11:22:14 PM +00:00</CreatedAt>
    <ClosedAt>26/10/2018 10:29:30 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19047</IssueLabelID>
    <Title>Address issues with COM tests in the helix build.</Title>
    <Description>Presently COM tests does not appear to run properly on Windows.Nano but
there is no way to special case that OS so disabling them on all builds.

see #19017</Description>
    <Title_Description>Address issues with COM tests in the helix build. Presently COM tests does not appear to run properly on Windows.Nano but
there is no way to special case that OS so disabling them on all builds.

see #19017</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>19/07/2018 10:57:41 PM +00:00</CreatedAt>
    <ClosedAt>20/07/2018 2:42:48 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19042</IssueLabelID>
    <Title>Disable manual COM registration logic on ARM32</Title>
    <Description>see #19020

cc @jkotas @BruceForstall </Description>
    <Title_Description>Disable manual COM registration logic on ARM32 see #19020

cc @jkotas @BruceForstall </Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>19/07/2018 7:18:36 PM +00:00</CreatedAt>
    <ClosedAt>20/07/2018 8:07:26 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19038</IssueLabelID>
    <Title>Assembly analysis without reflection</Title>
    <Description>There is sometimes a need to examine the internals of assemblies for various things like does the assembly contain class X or does it have some attribute Y etc. Using reflection and the various load options is fine for many cases but not all.

For example it's not easy to load an assembly by some tool if the app that uses it uses version overrides in its config file this is because to load the assembly requires its referenced assemblies to also be loaded and this only works under specific circumstances the app can load a different version to the one in the parent manifest because it "knows about" the overrides but a tool or utility has no idea about these overrides and may fail to load assembly A1 if the version of a referenced assembly file A2 differs from the version defined in the A1 manifest.

If we just want to open some DLL file and examine it for _certain_ things then it must be possible to do this without using reflection because the file format is well defined (as an [ECMA standard](https://www.ecma-international.org/publications/standards/Ecma-335.htm)).

Does anyone know if anything exists to let me analyze assembly files in some way without relying on reflection loading and so on?
</Description>
    <Title_Description>Assembly analysis without reflection There is sometimes a need to examine the internals of assemblies for various things like does the assembly contain class X or does it have some attribute Y etc. Using reflection and the various load options is fine for many cases but not all.

For example it's not easy to load an assembly by some tool if the app that uses it uses version overrides in its config file this is because to load the assembly requires its referenced assemblies to also be loaded and this only works under specific circumstances the app can load a different version to the one in the parent manifest because it "knows about" the overrides but a tool or utility has no idea about these overrides and may fail to load assembly A1 if the version of a referenced assembly file A2 differs from the version defined in the A1 manifest.

If we just want to open some DLL file and examine it for _certain_ things then it must be possible to do this without using reflection because the file format is well defined (as an [ECMA standard](https://www.ecma-international.org/publications/standards/Ecma-335.htm)).

Does anyone know if anything exists to let me analyze assembly files in some way without relying on reflection loading and so on?
</Title_Description>
    <Label>area-System.Reflection</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>19/07/2018 6:47:41 PM +00:00</CreatedAt>
    <ClosedAt>19/07/2018 8:44:12 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19037</IssueLabelID>
    <Title>CI: convert all builds to new Helix machines</Title>
    <Description>After https://github.com/dotnet/coreclr/issues/18048 we will use new Helix-provided machines for building ARM32/ARM64.

Convert the rest of the Jenkins CI build pool to use the same machines so all builds use the same toolset.

Currently they use the "latest-or-auto" tag (see netci.groovy ).
</Description>
    <Title_Description>CI: convert all builds to new Helix machines After https://github.com/dotnet/coreclr/issues/18048 we will use new Helix-provided machines for building ARM32/ARM64.

Convert the rest of the Jenkins CI build pool to use the same machines so all builds use the same toolset.

Currently they use the "latest-or-auto" tag (see netci.groovy ).
</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>BruceForstall</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19036</IssueLabelID>
    <Title>CI: Convert arm32/arm64 build to not require whitelist</Title>
    <Description>Currently the Windows arm32 and arm64 builds use a "whitelist" of allowed users to access a set of private build machines. After the arm64 builds change to use public tools remove the whitelist restriction for the builds. (The whitelist restriction will remain for the Windows arm64 test machines which are also used for Windows arm32 test runs.)

Add build-only arm32/arm64 PR-triggered "innerloop" jobs to every PR to protect against arm32/arm64 build failures.

Depends on https://github.com/dotnet/coreclr/issues/18048</Description>
    <Title_Description>CI: Convert arm32/arm64 build to not require whitelist Currently the Windows arm32 and arm64 builds use a "whitelist" of allowed users to access a set of private build machines. After the arm64 builds change to use public tools remove the whitelist restriction for the builds. (The whitelist restriction will remain for the Windows arm64 test machines which are also used for Windows arm32 test runs.)

Add build-only arm32/arm64 PR-triggered "innerloop" jobs to every PR to protect against arm32/arm64 build failures.

Depends on https://github.com/dotnet/coreclr/issues/18048</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>BruceForstall</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19034</IssueLabelID>
    <Title>Arm64: Verify that IP0/IP1 are reserved as needed for jumps</Title>
    <Description>IP0/IP1 are reserved in the ABI for linking stubs. Any branch with target out of range is free to contaminate these.
The register allocator needs to ensure that either 1) no lclVar is allocated to those registers at block end or 2) they are being reserved (elsewhere) if a branch may be out of range.</Description>
    <Title_Description>Arm64: Verify that IP0/IP1 are reserved as needed for jumps IP0/IP1 are reserved in the ABI for linking stubs. Any branch with target out of range is free to contaminate these.
The register allocator needs to ensure that either 1) no lclVar is allocated to those registers at block end or 2) they are being reserved (elsewhere) if a branch may be out of range.</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19031</IssueLabelID>
    <Title>Update PreReleaseLabel</Title>
    <Description>to "alphautf8string" so it sorts before "preview1" and so it's under the nuget 20 character limit</Description>
    <Title_Description>Update PreReleaseLabel to "alphautf8string" so it sorts before "preview1" and so it's under the nuget 20 character limit</Title_Description>
    <Label>
    </Label>
    <Assignee>joshfree</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19030</IssueLabelID>
    <Title>R2R build failures - Error: compilation failed for Core_Root/netcoreapp2.0/R2RDump.dll</Title>
    <Description>This fails in master for Linux r2r test legs https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_release_ubuntu_r2r_tst/1812/consoleText
https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_checked_ubuntu_r2r_tst/1852/consoleText


On Ubuntu arm as well (failed while testing PR #19013 https://ci.dot.net/job/dotnet_coreclr/job/master/job/arm_cross_checked_ubuntu_r2r_tst_prtest/8/consoleText)</Description>
    <Title_Description>R2R build failures - Error: compilation failed for Core_Root/netcoreapp2.0/R2RDump.dll This fails in master for Linux r2r test legs https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_release_ubuntu_r2r_tst/1812/consoleText
https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_checked_ubuntu_r2r_tst/1852/consoleText


On Ubuntu arm as well (failed while testing PR #19013 https://ci.dot.net/job/dotnet_coreclr/job/master/job/arm_cross_checked_ubuntu_r2r_tst_prtest/8/consoleText)</Title_Description>
    <Label>
    </Label>
    <Assignee>acmyu</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19029</IssueLabelID>
    <Title>JitStressRegs=0x8 regressions</Title>
    <Description>The 512 tests started failing recently in JitStress=0x8 mode

Typical failure looks like
</Description>
    <Title_Description>JitStressRegs=0x8 regressions The 512 tests started failing recently in JitStress=0x8 mode

Typical failure looks like
</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19026</IssueLabelID>
    <Title>hi i use .net core 2.1in raspberry pi os raspbian 8 wil let CPU100%bug .net core 2.0 will not</Title>
    <Description>this is the arm linux 32 corclr tracing
https://github.com/AirleaderChina/Airleader-Open/blob/master/sampleTrace.trace.zip
bug i can't found any useful information.
the tracing display coreclr use many cpu times </Description>
    <Title_Description>hi i use .net core 2.1in raspberry pi os raspbian 8 wil let CPU100%,bug .net core 2.0 will not this is the arm linux 32 corclr tracing
https://github.com/AirleaderChina/Airleader-Open/blob/master/sampleTrace.trace.zip
bug i can't found any useful information.
the tracing display coreclr use many cpu times </Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>19/07/2018 2:40:59 PM +00:00</CreatedAt>
    <ClosedAt>16/08/2018 3:59:05 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19025</IssueLabelID>
    <Title>CoreCLR doesn't boot on a "modern" Linux/ARM image</Title>
    <Description>I'm able to compile .NET Core 2.1 for my Linux distribution based on Yocto for ARM. If I'm doing this for the "pyro" release from spring 2017 I can run the simple Hello World both when using the dotnet executable I've compiled with the just the dll as well as a self-contained publish for  coming from Windows.

With Yocto's "sumo" release from spring 2018 both methods of running the application hang indefinitely and don't printing anything. CTRL+C doesn't do anything and I have to kill -KILL from another shell.

As can be expected there are a couple of updates to the libraries included in the distribution. I'm listing the direct dependencies I've declared for my build in the following table

Library | pyro | sumo
------- | ---- | ----
clang | 4.0.1 | 6.0.1
cmake | 3.7.2 | 3.10.3
glibc | 2.25 | 2.27
libunwind | 1.1 | 1.2.1
icu | 58.2 | 60.2
openssl | 1.0.2n | 1.0.2o
util-linux | 2.29.1 | 2.31
lttng-ust | 2.9.0 | 2.10.1
krb5 | 1.15.1 | 1.16
curl | 7.53.1 | 7.58.0

I'm currently creating a Debug build and try to work with (against?) lldb to get some insight. Running with gdb also hangs and cannot be interrupted for a stack trace or the likes.

Any ideas?</Description>
    <Title_Description>CoreCLR doesn't boot on a "modern" Linux/ARM image I'm able to compile .NET Core 2.1 for my Linux distribution based on Yocto for ARM. If I'm doing this for the "pyro" release from spring 2017 I can run the simple Hello World both when using the dotnet executable I've compiled with the just the dll as well as a self-contained publish for  coming from Windows.

With Yocto's "sumo" release from spring 2018 both methods of running the application hang indefinitely and don't printing anything. CTRL+C doesn't do anything and I have to kill -KILL from another shell.

As can be expected there are a couple of updates to the libraries included in the distribution. I'm listing the direct dependencies I've declared for my build in the following table

Library | pyro | sumo
------- | ---- | ----
clang | 4.0.1 | 6.0.1
cmake | 3.7.2 | 3.10.3
glibc | 2.25 | 2.27
libunwind | 1.1 | 1.2.1
icu | 58.2 | 60.2
openssl | 1.0.2n | 1.0.2o
util-linux | 2.29.1 | 2.31
lttng-ust | 2.9.0 | 2.10.1
krb5 | 1.15.1 | 1.16
curl | 7.53.1 | 7.58.0

I'm currently creating a Debug build and try to work with (against?) lldb to get some insight. Running with gdb also hangs and cannot be interrupted for a stack trace or the likes.

Any ideas?</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>19/07/2018 2:32:50 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19023</IssueLabelID>
    <Title>Clarify calling conventions for profiler Enter callback</Title>
    <Description>@dotnet/jit-contrib @sywhang 

While investigating #18977 I'm seeing a number of things that look inconsistent and probably need to be fixed or better documented. Jit folks can you let me know what you think?

1) The [FunctionEnter3](https://docs.microsoft.com/en-us/dotnet/framework/unmanaged-api/profiling/functionenter3-function)/[FunctionLeave3](https://docs.microsoft.com/en-us/dotnet/framework/unmanaged-api/profiling/functionleave3-function)/[FunctionTailcall3](https://docs.microsoft.com/en-us/dotnet/framework/unmanaged-api/profiling/functiontailcall3-function) methods are a publicly exposed and have a documented ABI. On Linux x64 we pass FunctionIDOrClientID in R14 MSDN documentation doesn't mention a custom calling convention so developers would expect RDI. I believe we picked R14 for good reason so I propose we change MSDN to match.
2) The runtime sometimes provides the implementation of the ProfileEnter call as an intermediary between the jitted code and other forms of the profiler callback. On Linux x64 that gives us 4 non-agreeing definitions of the register preservation requirements:
  - The MSDN docs claim the caller must preserve all registers
  - The code comments above the runtime ProfileEnterNaked implementation suggest a number of registers are not preserved:
https://github.com/dotnet/coreclr/blob/master/src/vm/amd64/asmhelpers.S#L59
   (Incidentally the comments aren't self-consistent either xmm1 and rdx are both preserved and not preserved ; )
   - The implementation of the JIT has different expectations about what would be preserved (for example is it really safe to trash the argument registers in the prologue of the caller?)
   - The implementation of the assembly routine preserves all the integer argument registers
https://github.com/dotnet/coreclr/blob/master/src/vm/amd64/asmhelpers.S#L135

I don't have a good sense of exactly what the JIT expects to be preserved across this call for the code to run correctly but whatever it is I'd like to bring our own comments implementation and MSDN docs into alignment with it. I suspect there may be discrepancies for the register preservation requirements on other architectures but I'm happy to start with Linux x64.

Thanks!
 -Noah
</Description>
    <Title_Description>Clarify calling conventions for profiler Enter callback @dotnet/jit-contrib @sywhang 

While investigating #18977 I'm seeing a number of things that look inconsistent and probably need to be fixed or better documented. Jit folks can you let me know what you think?

1) The [FunctionEnter3](https://docs.microsoft.com/en-us/dotnet/framework/unmanaged-api/profiling/functionenter3-function)/[FunctionLeave3](https://docs.microsoft.com/en-us/dotnet/framework/unmanaged-api/profiling/functionleave3-function)/[FunctionTailcall3](https://docs.microsoft.com/en-us/dotnet/framework/unmanaged-api/profiling/functiontailcall3-function) methods are a publicly exposed and have a documented ABI. On Linux x64 we pass FunctionIDOrClientID in R14 MSDN documentation doesn't mention a custom calling convention so developers would expect RDI. I believe we picked R14 for good reason so I propose we change MSDN to match.
2) The runtime sometimes provides the implementation of the ProfileEnter call as an intermediary between the jitted code and other forms of the profiler callback. On Linux x64 that gives us 4 non-agreeing definitions of the register preservation requirements:
  - The MSDN docs claim the caller must preserve all registers
  - The code comments above the runtime ProfileEnterNaked implementation suggest a number of registers are not preserved:
https://github.com/dotnet/coreclr/blob/master/src/vm/amd64/asmhelpers.S#L59
   (Incidentally the comments aren't self-consistent either xmm1 and rdx are both preserved and not preserved ; )
   - The implementation of the JIT has different expectations about what would be preserved (for example is it really safe to trash the argument registers in the prologue of the caller?)
   - The implementation of the assembly routine preserves all the integer argument registers
https://github.com/dotnet/coreclr/blob/master/src/vm/amd64/asmhelpers.S#L135

I don't have a good sense of exactly what the JIT expects to be preserved across this call for the code to run correctly but whatever it is I'd like to bring our own comments implementation and MSDN docs into alignment with it. I suspect there may be discrepancies for the register preservation requirements on other architectures but I'm happy to start with Linux x64.

Thanks!
 -Noah
</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>sywhang</Assignee>
    <CreatedAt>19/07/2018 12:16:36 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19022</IssueLabelID>
    <Title>Access Violation Exception in clrjit.dll - lclvars.cpp - lvaMarkLocalVars </Title>
    <Description>Here's the callstack dump:



Other relevant info:

- Using Latest version of VS2017 community on a x64bit machine.
- The project is a classic Desktop Application
- It was using Net452 by default but it also crashes with Net471.
- Release mode crashes Debug mode works.
- It crashes with target platform x64
- It works well with target platform x86 for now we're going to force x86 as a temporary solution.

I'll post any other info I can get.</Description>
    <Title_Description>Access Violation Exception in clrjit.dll - lclvars.cpp - lvaMarkLocalVars  Here's the callstack dump:



Other relevant info:

- Using Latest version of VS2017 community on a x64bit machine.
- The project is a classic Desktop Application
- It was using Net452 by default but it also crashes with Net471.
- Release mode crashes Debug mode works.
- It crashes with target platform x64
- It works well with target platform x86 for now we're going to force x86 as a temporary solution.

I'll post any other info I can get.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>briansull</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19020</IssueLabelID>
    <Title>Build failure: ARM64 build of Interop\COM\NativeServer\COMNativeServer</Title>
    <Description>Opened on behalf of @RussKeldorph

Warnings: 1
Status Message: failed

Build : Master - 20180719.01 (Product Build)
Failing configurations:
- Windows
  - Build-Tests-R2R-Release-arm64
  - Build-Tests-Release-arm64
[Mission Control Build Info](https://mc.dot.net/#/product/netcore/master/source/official~2Fcoreclr~2Fmaster~2F/type/build~2Fproduct~2F/build/20180719.01/workItem/Orchestration/analysis/external/Link)
</Description>
    <Title_Description>Build failure: ARM64 build of Interop\COM\NativeServer\COMNativeServer Opened on behalf of @RussKeldorph

Warnings: 1
Status Message: failed

Build : Master - 20180719.01 (Product Build)
Failing configurations:
- Windows
  - Build-Tests-R2R-Release-arm64
  - Build-Tests-Release-arm64
[Mission Control Build Info](https://mc.dot.net/#/product/netcore/master/source/official~2Fcoreclr~2Fmaster~2F/type/build~2Fproduct~2F/build/20180719.01/workItem/Orchestration/analysis/external/Link)
</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19018</IssueLabelID>
    <Title>Test failure: Exceptions_Finalization._Finalizer_Finalizer_/_Finalizer_Finalizer_cmd</Title>
    <Description>Opened on behalf of @Sunny-pu

The test  has failed.

Test Infrastructure Failure: Could not load file or assembly 'System.Diagnostics.Process Version=4.2.1.0 Culture=neutral PublicKeyToken=b03f5f7f11d50a3a'. The system cannot find the file specified.
    
    Expected: True
    Actual:   False

        Stack Trace:

        
Build : Master - 20180719.01 (Ready-To-Run Tests)
Failing configurations:
- opensuse.423.amd64
  - x64

Details: https://mc.dot.net/#/product/netcore/master/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fr2r~2Fcli~2F/build/20180719.01/workItem/Exceptions.Finalization.XUnitWrapper/analysis/xunit/Exceptions_Finalization._Finalizer_Finalizer_~2F_Finalizer_Finalizer_cmd</Description>
    <Title_Description>Test failure: Exceptions_Finalization._Finalizer_Finalizer_/_Finalizer_Finalizer_cmd Opened on behalf of @Sunny-pu

The test  has failed.

Test Infrastructure Failure: Could not load file or assembly 'System.Diagnostics.Process Version=4.2.1.0 Culture=neutral PublicKeyToken=b03f5f7f11d50a3a'. The system cannot find the file specified.
    
    Expected: True
    Actual:   False

        Stack Trace:

        
Build : Master - 20180719.01 (Ready-To-Run Tests)
Failing configurations:
- opensuse.423.amd64
  - x64

Details: https://mc.dot.net/#/product/netcore/master/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fr2r~2Fcli~2F/build/20180719.01/workItem/Exceptions.Finalization.XUnitWrapper/analysis/xunit/Exceptions_Finalization._Finalizer_Finalizer_~2F_Finalizer_Finalizer_cmd</Title_Description>
    <Label>GCStress</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>19/07/2018 7:19:09 AM +00:00</CreatedAt>
    <ClosedAt>21/06/2019 11:05:53 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19017</IssueLabelID>
    <Title>Test failure: Interop_COM._NETClients_Primitives_NETClientPrimitives_NETClientPrimitives_/_NETClients_Primitives_NETClientPrimitives_NETClientPrimitives_cmd</Title>
    <Description>Opened on behalf of @Sunny-pu

The test  has failed.


    
    Return code:      1
    Raw output file:      C:\\work\\3400b627-09fb-4f1a-bd33-2f4c2d5e051f\\Work\\c699e3df-3136-4654-9043-92d2f057c2b0\\Unzip\\Reports\\Interop.COM\\NETClients\\Primitives\\NETClientPrimitives\\NETClientPrimitives.output.txt
    Raw output:
    BEGIN EXECUTION\r
     \"C:\\work\\3400b627-09fb-4f1a-bd33-2f4c2d5e051f\\Payload\\corerun.exe\" NETClientPrimitives.exe \r
    Numeric RNG seed: 37\r
    Test Failure: Retrieving the COM class factory for component with CLSID {53169A33-E85D-4E3C-B668-24E438D0929B} failed due to the following error: 80040154 Class not registered (Exception from HRESULT: 0x80040154 (REGDB_E_CLASSNOTREG)).
       at NetClient.NumericTests..ctor(Int32 seed) in E:\\A\\_work\\124\\s\\tests\\src\\Interop\\COM\\NETClients\\Primitives\\NumericTests.cs:line 22\r
       at NetClient.Program.Main(String[] doNotUse) in E:\\A\\_work\\124\\s\\tests\\src\\Interop\\COM\\NETClients\\Primitives\\Program.cs:line 15\r
    Expected: 100\r
    Actual: 101\r
    END EXECUTION - FAILED\r
    FAILED\r
    Test Harness Exitcode is : 1\r
    
    To run the test:
    &gt; set CORE_ROOT=C:\\work\\3400b627-09fb-4f1a-bd33-2f4c2d5e051f\\Payload
    &gt; C:\\work\\3400b627-09fb-4f1a-bd33-2f4c2d5e051f\\Work\\c699e3df-3136-4654-9043-92d2f057c2b0\\Unzip\\NETClients\\Primitives\\NETClientPrimitives\\NETClientPrimitives.cmd
    \r
    Expected: True\r
    Actual:   False

        Stack Trace:

        
Build : Master - 20180719.01 (Core Tests)
Failing configurations:
- Windows.10.Nano.Amd64-x64
  - 
- sles.12.amd64-x64
  - 
- opensuse.423.amd64-x64
  - 
- ubuntu.1804.amd64-x64
  - 
- ubuntu.1710.amd64-x64
  - 
- ubuntu.1604.amd64-x64
  - 
- ubuntu.1404.amd64-x64
  - 
- redhat.73.amd64-x64
  - 
- fedora.27.amd64-x64
  - 
- fedora.26.amd64-x64
  - 
- debian.82.amd64-x64
  - 
- osx.1013.amd64-x64
  - 
- osx.1012.amd64-x64
  - 

Details: https://mc.dot.net/#/product/netcore/master/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fcli~2F/build/20180719.01/workItem/Interop.COM.XUnitWrapper/analysis/xunit/Interop_COM._NETClients_Primitives_NETClientPrimitives_NETClientPrimitives_~2F_NETClients_Primitives_NETClientPrimitives_NETClientPrimitives_cmd</Description>
    <Title_Description>Test failure: Interop_COM._NETClients_Primitives_NETClientPrimitives_NETClientPrimitives_/_NETClients_Primitives_NETClientPrimitives_NETClientPrimitives_cmd Opened on behalf of @Sunny-pu

The test  has failed.


    
    Return code:      1
    Raw output file:      C:\\work\\3400b627-09fb-4f1a-bd33-2f4c2d5e051f\\Work\\c699e3df-3136-4654-9043-92d2f057c2b0\\Unzip\\Reports\\Interop.COM\\NETClients\\Primitives\\NETClientPrimitives\\NETClientPrimitives.output.txt
    Raw output:
    BEGIN EXECUTION\r
     \"C:\\work\\3400b627-09fb-4f1a-bd33-2f4c2d5e051f\\Payload\\corerun.exe\" NETClientPrimitives.exe \r
    Numeric RNG seed: 37\r
    Test Failure: Retrieving the COM class factory for component with CLSID {53169A33-E85D-4E3C-B668-24E438D0929B} failed due to the following error: 80040154 Class not registered (Exception from HRESULT: 0x80040154 (REGDB_E_CLASSNOTREG)).
       at NetClient.NumericTests..ctor(Int32 seed) in E:\\A\\_work\\124\\s\\tests\\src\\Interop\\COM\\NETClients\\Primitives\\NumericTests.cs:line 22\r
       at NetClient.Program.Main(String[] doNotUse) in E:\\A\\_work\\124\\s\\tests\\src\\Interop\\COM\\NETClients\\Primitives\\Program.cs:line 15\r
    Expected: 100\r
    Actual: 101\r
    END EXECUTION - FAILED\r
    FAILED\r
    Test Harness Exitcode is : 1\r
    
    To run the test:
    &gt; set CORE_ROOT=C:\\work\\3400b627-09fb-4f1a-bd33-2f4c2d5e051f\\Payload
    &gt; C:\\work\\3400b627-09fb-4f1a-bd33-2f4c2d5e051f\\Work\\c699e3df-3136-4654-9043-92d2f057c2b0\\Unzip\\NETClients\\Primitives\\NETClientPrimitives\\NETClientPrimitives.cmd
    \r
    Expected: True\r
    Actual:   False

        Stack Trace:

        
Build : Master - 20180719.01 (Core Tests)
Failing configurations:
- Windows.10.Nano.Amd64-x64
  - 
- sles.12.amd64-x64
  - 
- opensuse.423.amd64-x64
  - 
- ubuntu.1804.amd64-x64
  - 
- ubuntu.1710.amd64-x64
  - 
- ubuntu.1604.amd64-x64
  - 
- ubuntu.1404.amd64-x64
  - 
- redhat.73.amd64-x64
  - 
- fedora.27.amd64-x64
  - 
- fedora.26.amd64-x64
  - 
- debian.82.amd64-x64
  - 
- osx.1013.amd64-x64
  - 
- osx.1012.amd64-x64
  - 

Details: https://mc.dot.net/#/product/netcore/master/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fcli~2F/build/20180719.01/workItem/Interop.COM.XUnitWrapper/analysis/xunit/Interop_COM._NETClients_Primitives_NETClientPrimitives_NETClientPrimitives_~2F_NETClients_Primitives_NETClientPrimitives_NETClientPrimitives_cmd</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19013</IssueLabelID>
    <Title>[ARM32] Handle MovRelocatableImmediate as a special case (IF_T2_N3)</Title>
    <Description>

Running *jit-diff --pmi --altjit* and *jit-diff --crossgen x86_arm/crossgen.exe* shows no diffs for framework assemblies. 

Ubuntu arm pri1 and corefx tests have passed for these changes.
</Description>
    <Title_Description>[ARM32] Handle MovRelocatableImmediate as a special case (IF_T2_N3) 

Running *jit-diff --pmi --altjit* and *jit-diff --crossgen x86_arm/crossgen.exe* shows no diffs for framework assemblies. 

Ubuntu arm pri1 and corefx tests have passed for these changes.
</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>dotnet-bot</Assignee>
    <CreatedAt>19/07/2018 1:29:43 AM +00:00</CreatedAt>
    <ClosedAt>3/08/2018 7:35:34 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19011</IssueLabelID>
    <Title>Test failure in r2rdump test</Title>
    <Description>Test failure in x64 Checked Windows with 
</Description>
    <Title_Description>Test failure in r2rdump test Test failure in x64 Checked Windows with 
</Title_Description>
    <Label>arch-x64</Label>
    <Assignee>acmyu</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19010</IssueLabelID>
    <Title>Script warning in init-tools.sh</Title>
    <Description>

Perhaps setup-stress-dependencies.sh should also invoke it using "source"?</Description>
    <Title_Description>Script warning in init-tools.sh 

Perhaps setup-stress-dependencies.sh should also invoke it using "source"?</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>19/07/2018 12:40:39 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19009</IssueLabelID>
    <Title>Syntax error in build-test.sh script</Title>
    <Description>
    </Description>
    <Title_Description>Syntax error in build-test.sh script </Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>19/07/2018 12:25:03 AM +00:00</CreatedAt>
    <ClosedAt>21/03/2019 5:12:59 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19008</IssueLabelID>
    <Title>Many x64 checked Ubuntu GCStress=0xC test failures</Title>
    <Description>https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64/job/jitstress/job/x64_checked_ubuntu_gcstress0xc_flow/91/


</Description>
    <Title_Description>Many x64 checked Ubuntu GCStress=0xC test failures https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64/job/jitstress/job/x64_checked_ubuntu_gcstress0xc_flow/91/


</Title_Description>
    <Label>GCStress</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>19/07/2018 12:20:04 AM +00:00</CreatedAt>
    <ClosedAt>12/01/2019 12:59:41 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19007</IssueLabelID>
    <Title>Ubuntu IL linker test failures in CI</Title>
    <Description>This job is failing every test:

https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64/job/illink/job/x64_checked_ubuntu_illink_flow/

e.g.:


Note that there is also a non-flow Ubuntu x64 IL linker test job:

https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64/job/illink/job/x64_checked_ubuntu_illink/

This one passes but it doesn't look like it's actually doing any interesting testing. I'm not sure this is a related issue or not. If not create a new issue to address removing one of them (if necessary).</Description>
    <Title_Description>Ubuntu IL linker test failures in CI This job is failing every test:

https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64/job/illink/job/x64_checked_ubuntu_illink_flow/

e.g.:


Note that there is also a non-flow Ubuntu x64 IL linker test job:

https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64/job/illink/job/x64_checked_ubuntu_illink/

This one passes but it doesn't look like it's actually doing any interesting testing. I'm not sure this is a related issue or not. If not create a new issue to address removing one of them (if necessary).</Title_Description>
    <Label>arch-x64</Label>
    <Assignee>sbomer</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19005</IssueLabelID>
    <Title>Minor interop code changes</Title>
    <Description>
    </Description>
    <Title_Description>Minor interop code changes </Title_Description>
    <Label>area-Interop</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>18/07/2018 11:57:19 PM +00:00</CreatedAt>
    <ClosedAt>20/07/2018 7:48:07 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19003</IssueLabelID>
    <Title>x86 Ubuntu CI jobs are failing</Title>
    <Description>Namely

https://ci.dot.net/job/dotnet_coreclr/job/master/job/x86_debug_ubuntu_flow/
https://ci.dot.net/job/dotnet_coreclr/job/master/job/x86_checked_ubuntu_flow/
https://ci.dot.net/job/dotnet_coreclr/job/master/job/x86_release_ubuntu_flow/

There are several problems:
1. A missing "mkdir" leads to:

2. It appears these jobs have (inadvertently?) been partially updated to the "new" way of running which uses "build-test.sh x86 Checked generatelayoutonly" to generate a Core_Root and download packages. But apparently there are no x86 Linux packages in the official build to pull down. Perhaps the "tst" job needs to revert to the previous method of invoking runtest.sh? Or we need to get the correct packages built and published?
</Description>
    <Title_Description>x86 Ubuntu CI jobs are failing Namely

https://ci.dot.net/job/dotnet_coreclr/job/master/job/x86_debug_ubuntu_flow/
https://ci.dot.net/job/dotnet_coreclr/job/master/job/x86_checked_ubuntu_flow/
https://ci.dot.net/job/dotnet_coreclr/job/master/job/x86_release_ubuntu_flow/

There are several problems:
1. A missing "mkdir" leads to:

2. It appears these jobs have (inadvertently?) been partially updated to the "new" way of running which uses "build-test.sh x86 Checked generatelayoutonly" to generate a Core_Root and download packages. But apparently there are no x86 Linux packages in the official build to pull down. Perhaps the "tst" job needs to revert to the previous method of invoking runtest.sh? Or we need to get the correct packages built and published?
</Title_Description>
    <Label>arch-x86</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>18/07/2018 11:29:45 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19001</IssueLabelID>
    <Title>JIT.HardwareIntrinsics.X86.Avx.Avx_ro.Avx_ro failed in CI on macOS</Title>
    <Description>https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_checked_osx10.12_innerloop_tst_prtest/4234/
</Description>
    <Title_Description>JIT.HardwareIntrinsics.X86.Avx.Avx_ro.Avx_ro failed in CI on macOS https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_checked_osx10.12_innerloop_tst_prtest/4234/
</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>18/07/2018 9:18:55 PM +00:00</CreatedAt>
    <ClosedAt>6/12/2018 7:50:19 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19000</IssueLabelID>
    <Title>[x86/Windows] Failure in JIT\HardwareIntrinsics\X86\Sse2\MaskMove_r\MaskMove_r.cmd</Title>
    <Description>x86 Windows JitStress=2 JitStressRegs=3 failure

https://ci.dot.net/job/dotnet_coreclr/job/master/view/x86/job/jitstress/job/x86_checked_windows_nt_jitstress2_jitstressregs3/555/consoleText



Same test failure previously: https://github.com/dotnet/coreclr/issues/17634
</Description>
    <Title_Description>[x86/Windows] Failure in JIT\HardwareIntrinsics\X86\Sse2\MaskMove_r\MaskMove_r.cmd x86 Windows JitStress=2 JitStressRegs=3 failure

https://ci.dot.net/job/dotnet_coreclr/job/master/view/x86/job/jitstress/job/x86_checked_windows_nt_jitstress2_jitstressregs3/555/consoleText



Same test failure previously: https://github.com/dotnet/coreclr/issues/17634
</Title_Description>
    <Label>arch-x86</Label>
    <Assignee>4creators</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18997</IssueLabelID>
    <Title>GCStress test failure in JIT\HardwareIntrinsics\X86\Bmi1\Bmi1_r\Bmi1_r.cmd</Title>
    <Description>x86 Checked Windows GCStress=0xc failure

https://ci.dot.net/job/dotnet_coreclr/job/master/view/x86/job/jitstress/job/x86_checked_windows_nt_gcstress0xc/91/consoleText



</Description>
    <Title_Description>GCStress test failure in JIT\HardwareIntrinsics\X86\Bmi1\Bmi1_r\Bmi1_r.cmd x86 Checked Windows GCStress=0xc failure

https://ci.dot.net/job/dotnet_coreclr/job/master/view/x86/job/jitstress/job/x86_checked_windows_nt_gcstress0xc/91/consoleText



</Title_Description>
    <Label>GCStress</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>18/07/2018 8:30:07 PM +00:00</CreatedAt>
    <ClosedAt>27/07/2018 10:01:15 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18991</IssueLabelID>
    <Title>[arm64][R2R] Test failure: VectorDot_ro.cmd_9267</Title>
    <Description>In R2R tests with JitStress=1 or JitStress=2 there is a failure in:

</Description>
    <Title_Description>[arm64][R2R] Test failure: VectorDot_ro.cmd_9267 In R2R tests with JitStress=1 or JitStress=2 there is a failure in:

</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>AndyAyersMS</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18989</IssueLabelID>
    <Title>[arm64] Assertion failed '(sizeDif == 4) || (sizeDif == 8)' in 'floatMDArrTest:Main():int'</Title>
    <Description>Failure in

</Description>
    <Title_Description>[arm64] Assertion failed '(sizeDif == 4) || (sizeDif == 8)' in 'floatMDArrTest:Main():int' Failure in

</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>briansull</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18988</IssueLabelID>
    <Title>[Windows/arm32] Test failure: 10w5d_cs_do.cmd </Title>
    <Description>With JitStress=1

https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_jitstress1_tst/33/


</Description>
    <Title_Description>[Windows/arm32] Test failure: 10w5d_cs_do.cmd  With JitStress=1

https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_jitstress1_tst/33/


</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>sandreenko</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18987</IssueLabelID>
    <Title>Infrastructure failure in ubuntu arm32 corefx Jenkins jobs</Title>
    <Description>It looks like all the ubuntu arm32 corefx jobs I kicked off yesterday passed all tests but failed at the end with what looks like an infrastructure failure e.g.:



example jobs:

https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstress2_tst/17/consoleText
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstressregs2_tst/12/consoleText

Other (non-corefx) jobs I kicked off did not have this issue.

Ideas? Is there a reason it might be transient and I should just try again?

@mmitche 
cc @jashook @RussKeldorph </Description>
    <Title_Description>Infrastructure failure in ubuntu arm32 corefx Jenkins jobs It looks like all the ubuntu arm32 corefx jobs I kicked off yesterday passed all tests but failed at the end with what looks like an infrastructure failure e.g.:



example jobs:

https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstress2_tst/17/consoleText
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstressregs2_tst/12/consoleText

Other (non-corefx) jobs I kicked off did not have this issue.

Ideas? Is there a reason it might be transient and I should just try again?

@mmitche 
cc @jashook @RussKeldorph </Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>mmitche</Assignee>
    <CreatedAt>18/07/2018 4:06:32 PM +00:00</CreatedAt>
    <ClosedAt>2/01/2019 7:44:12 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18986</IssueLabelID>
    <Title>Assertion failed 'rhs-&gt;OperGet() == GT_LONG'</Title>
    <Description>This is a recent regression.

Every Ubuntu arm32 JitStress=2 with JitStressRegs failed with:


e.g. https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_jitstress2_jitstressregs1_tst/15/consoleText.

There is currently no recent run without JitStressRegs to see if it fails with just JitStress=2 (https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_jitstress2_flow/)

@dotnet/arm32-contrib @dotnet/jit-contrib </Description>
    <Title_Description>Assertion failed 'rhs-&gt;OperGet() == GT_LONG' This is a recent regression.

Every Ubuntu arm32 JitStress=2 with JitStressRegs failed with:


e.g. https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_jitstress2_jitstressregs1_tst/15/consoleText.

There is currently no recent run without JitStressRegs to see if it fails with just JitStress=2 (https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_jitstress2_flow/)

@dotnet/arm32-contrib @dotnet/jit-contrib </Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>sandreenko</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18984</IssueLabelID>
    <Title>FriendAccessAllowedAttribute public?</Title>
    <Description>Would it be possible to make the System.Runtime.CompilerServices.FriendAccessAllowedAttribute public to be more explicit and clearly state intent of what exactly should be visible to a friend assembly?</Description>
    <Title_Description>FriendAccessAllowedAttribute public? Would it be possible to make the System.Runtime.CompilerServices.FriendAccessAllowedAttribute public to be more explicit and clearly state intent of what exactly should be visible to a friend assembly?</Title_Description>
    <Label>area-TypeSystem</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>18/07/2018 7:44:20 AM +00:00</CreatedAt>
    <ClosedAt>24/05/2019 4:37:55 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18977</IssueLabelID>
    <Title>ELT call stub issues on Linux</Title>
    <Description>Hi @noahfalk  - this is to continue the discussion from a closed issue prior.

I'm (slowly) porting our windows CLR profiler to linux. Everything was going spectacularly well until I tried to use the ICorProfilerInfo3::GetFunctionEnter3Info method. Calling this immediately results in a segmentation fault:


It seems to me like the frame isn't being set up right but I just have no idea where to begin. Help? Thanks in advance for any insight.



</Description>
    <Title_Description>ELT call stub issues on Linux Hi @noahfalk  - this is to continue the discussion from a closed issue prior.

I'm (slowly) porting our windows CLR profiler to linux. Everything was going spectacularly well until I tried to use the ICorProfilerInfo3::GetFunctionEnter3Info method. Calling this immediately results in a segmentation fault:


It seems to me like the frame isn't being set up right but I just have no idea where to begin. Help? Thanks in advance for any insight.



</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>sywhang</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18973</IssueLabelID>
    <Title>Enable tiered compilation by default</Title>
    <Description># Enable tiered compilation by default

Tiered compilation was added as an optional feature in .NET Core 2.1. It has been demonstrated that the [feature has a lot of value](https://github.com/dotnet/coreclr/issues/18361#issuecomment-396402549). We have done additional test runs that show similar gains.

There have been some reports of [degradation due to tiered compilation](https://github.com/dotnet/coreclr/issues/18361). We believe that these cases are in the narrow minority.

We would like to do the following:

- Enable tiered compilation by default in the first .NET Core 2.2 preview.
- Enable an opt-out of the feature. It is opt-in right now.
- Collect user feedback on the feature to make a decision if the feature works well enough to ship in 2.2 enabled.

We would make the same changes in master (AKA .NET Core 3.0) at the same time.

If that doesn't work out we could keep the feature as opt-in and enable it in some set of templates. This option isn't a proposal and would be dissapointing

Relevant links:

* https://github.com/dotnet/coreclr/issues/4331
* https://github.com/dotnet/coreclr/pull/17840
* https://github.com/dotnet/sdk/pull/2201
* https://github.com/dotnet/coreclr/issues/18361
</Description>
    <Title_Description>Enable tiered compilation by default # Enable tiered compilation by default

Tiered compilation was added as an optional feature in .NET Core 2.1. It has been demonstrated that the [feature has a lot of value](https://github.com/dotnet/coreclr/issues/18361#issuecomment-396402549). We have done additional test runs that show similar gains.

There have been some reports of [degradation due to tiered compilation](https://github.com/dotnet/coreclr/issues/18361). We believe that these cases are in the narrow minority.

We would like to do the following:

- Enable tiered compilation by default in the first .NET Core 2.2 preview.
- Enable an opt-out of the feature. It is opt-in right now.
- Collect user feedback on the feature to make a decision if the feature works well enough to ship in 2.2 enabled.

We would make the same changes in master (AKA .NET Core 3.0) at the same time.

If that doesn't work out we could keep the feature as opt-in and enable it in some set of templates. This option isn't a proposal and would be dissapointing

Relevant links:

* https://github.com/dotnet/coreclr/issues/4331
* https://github.com/dotnet/coreclr/pull/17840
* https://github.com/dotnet/sdk/pull/2201
* https://github.com/dotnet/coreclr/issues/18361
</Title_Description>
    <Label>area-TieredCompilation</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18971</IssueLabelID>
    <Title>Ensure .NET Core respects and plays nicely with Docker limits</Title>
    <Description>Docker enables you to [limit a container's resources](https://docs.docker.com/config/containers/resource_constraints/). This control is great for high-density hosting and other low-resource scenarios. Developers have the expectation that the application platform respects these limits and does its best to work within them.

I wrote a [crude test framework](https://github.com/richlander/dotnet-docker-limits) to determine how .NET Core behaves when various resource limits are set. You can see the [test results](https://gist.github.com/richlander/48bb0ad51a2406937b61bea01de7cf87).

The results I saw made some sense -- workstation performed better than server gc in this environment -- however some other characteristics were surprising. It could be that my tests were flawed.

Our first goal is to provide developers with guidance. For example if there a minimum memory limit that is required to run an app in production? Is server gc currently safe to run with docker limits?

Our next goal is to update the product as appropriate to ensure that it works well with Docker limits and then to update guidance appropriately.

Once we are done I'd like to re-run this test suite following the guidance. I/we should be able to pick a lower bound number (this app is very simple) and expect it to run w/o memory exhaustion.

[My app](https://github.com/richlander/dotnet-docker-limits/tree/master/src/aspnetapi) is very simple. There will be apps run in containers that require running on multiple cores and take advantage of server GC. Is that appropriate for docker limits or is there a minimum memory level of 250mb for example for that scenario? We should probably find a different test app that better exhibits the behavior of this type of app.
</Description>
    <Title_Description>Ensure .NET Core respects and plays nicely with Docker limits Docker enables you to [limit a container's resources](https://docs.docker.com/config/containers/resource_constraints/). This control is great for high-density hosting and other low-resource scenarios. Developers have the expectation that the application platform respects these limits and does its best to work within them.

I wrote a [crude test framework](https://github.com/richlander/dotnet-docker-limits) to determine how .NET Core behaves when various resource limits are set. You can see the [test results](https://gist.github.com/richlander/48bb0ad51a2406937b61bea01de7cf87).

The results I saw made some sense -- workstation performed better than server gc in this environment -- however some other characteristics were surprising. It could be that my tests were flawed.

Our first goal is to provide developers with guidance. For example if there a minimum memory limit that is required to run an app in production? Is server gc currently safe to run with docker limits?

Our next goal is to update the product as appropriate to ensure that it works well with Docker limits and then to update guidance appropriately.

Once we are done I'd like to re-run this test suite following the guidance. I/we should be able to pick a lower bound number (this app is very simple) and expect it to run w/o memory exhaustion.

[My app](https://github.com/richlander/dotnet-docker-limits/tree/master/src/aspnetapi) is very simple. There will be apps run in containers that require running on multiple cores and take advantage of server GC. Is that appropriate for docker limits or is there a minimum memory level of 250mb for example for that scenario? We should probably find a different test app that better exhibits the behavior of this type of app.
</Title_Description>
    <Label>area-VM</Label>
    <Assignee>sergiy-k</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18969</IssueLabelID>
    <Title>JIT: overview of proposed local var reference count changes</Title>
    <Description>This issue proposes a series of changes to reduce the overhead and increase the fidelity of local variable reference counts in the jit. The main idea is to get rid of the current costly and buggy incremental count maintenance in favor of batch updates that are done just before accurate ref counts are needed.

See discussion in #13280 for background.

Expected impact is:
* 4-5% improvement in tier0 / minopts / debug throughput
* minimal impact to optimized jit throughput
* smaller frame sizes in some cases where reference counts are currently inflated
* removal of workarounds to artificially inflate reference counts to avoid asserts

The more accurate reference counts and weighted counts are likely to cause widespread codegen diffs. Hopefully these will mostly be improvements but some regressions are certainly possible.

Proposed steps are:
- [x] encapsulate accesses to  to split out ref counting from other activities

cc @dotnet/jit-contrib 


category:implementation
theme:ir
skill-level:expert
cost:large</Description>
    <Title_Description>JIT: overview of proposed local var reference count changes This issue proposes a series of changes to reduce the overhead and increase the fidelity of local variable reference counts in the jit. The main idea is to get rid of the current costly and buggy incremental count maintenance in favor of batch updates that are done just before accurate ref counts are needed.

See discussion in #13280 for background.

Expected impact is:
* 4-5% improvement in tier0 / minopts / debug throughput
* minimal impact to optimized jit throughput
* smaller frame sizes in some cases where reference counts are currently inflated
* removal of workarounds to artificially inflate reference counts to avoid asserts

The more accurate reference counts and weighted counts are likely to cause widespread codegen diffs. Hopefully these will mostly be improvements but some regressions are certainly possible.

Proposed steps are:
- [x] encapsulate accesses to  to split out ref counting from other activities

cc @dotnet/jit-contrib 


category:implementation
theme:ir
skill-level:expert
cost:large</Title_Description>
    <Label>JitThroughput</Label>
    <Assignee>AndyAyersMS</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18968</IssueLabelID>
    <Title>EventWaitHandle.OpenExisting("".PadLeft(512)) is throwing ArgumentException instead of </Title>
    <Description>The following test outputted "Pass" in .NET Core 2.1 and is now outputting "Fail" with the latest CoreCLR in the master branch.


4. Run the build executable it should output "Pass".
5. Build the latest master CoreCLR and copy the new binaries on top of the published ones.
6. Run the build executable it should output "Fail".</Description>
    <Title_Description>EventWaitHandle.OpenExisting("".PadLeft(512)) is throwing ArgumentException instead of  The following test outputted "Pass" in .NET Core 2.1 and is now outputting "Fail" with the latest CoreCLR in the master branch.


4. Run the build executable it should output "Pass".
5. Build the latest master CoreCLR and copy the new binaries on top of the published ones.
6. Run the build executable it should output "Fail".</Title_Description>
    <Label>area-System.Threading</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18966</IssueLabelID>
    <Title>[x64] Assertion failed '!s_pagePool.isPoolPage(page)'</Title>
    <Description>From x64 corefx JitStressRegs=0x1000 run: https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64/job/jitstress/job/x64_checked_windows_nt_corefx_jitstressregs0x1000/462/consoleText



</Description>
    <Title_Description>[x64] Assertion failed '!s_pagePool.isPoolPage(page)' From x64 corefx JitStressRegs=0x1000 run: https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64/job/jitstress/job/x64_checked_windows_nt_corefx_jitstressregs0x1000/462/consoleText



</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>17/07/2018 6:57:44 PM +00:00</CreatedAt>
    <ClosedAt>17/07/2018 7:12:20 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18965</IssueLabelID>
    <Title>[NO MERGE] Dummy PR for testing IncreaseTimeOutInRegexMatchTestsMatch_ExcessPrefixTest</Title>
    <Description>**NO MERGE**</Description>
    <Title_Description>[NO MERGE] Dummy PR for testing IncreaseTimeOutInRegexMatchTestsMatch_ExcessPrefixTest **NO MERGE**</Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>echesakovMSFT</Assignee>
    <CreatedAt>17/07/2018 6:49:01 PM +00:00</CreatedAt>
    <ClosedAt>20/07/2018 5:55:14 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18963</IssueLabelID>
    <Title>[x64] Assertion failed '!BitVecOps::IsMember(&amp;nodesVecTraits uniqueNodes gtTreeID)'</Title>
    <Description>Failure in CI in x64 corefx minopts tests. E.g. https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64/job/jitstress/job/x64_checked_windows_nt_corefx_minopts/581/consoleText

There are 60 occurrences of this assert in this run.


</Description>
    <Title_Description>[x64] Assertion failed '!BitVecOps::IsMember(&amp;nodesVecTraits, uniqueNodes, gtTreeID)' Failure in CI in x64 corefx minopts tests. E.g. https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64/job/jitstress/job/x64_checked_windows_nt_corefx_minopts/581/consoleText

There are 60 occurrences of this assert in this run.


</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>17/07/2018 6:41:29 PM +00:00</CreatedAt>
    <ClosedAt>20/07/2018 10:37:26 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18960</IssueLabelID>
    <Title>Test failure: CoreMangLib_system._span_SlowTailCallArgs_SlowTailCallArgs_/_span_SlowTailCallArgs_SlowTailCallArgs_cmd</Title>
    <Description>Opened on behalf of @Sunny-pu

The test  has failed.


    Unhandled Exception: System.IO.FileNotFoundException: Could not load file or assembly 'System.Reflection.Emit.ILGeneration Version=4.0.3.0 Culture=neutral PublicKeyToken=b03f5f7f11d50a3a'. The system cannot find the file specified.
    
       at SpanTest.Run()
       at Program.Main()
    /home/helixbot/dotnetbuild/work/829eb0a1-744b-4dd3-8627-616125703d53/Work/3938d767-5cf7-42d2-8619-5e5ef7623a10/Unzip/span/SlowTailCallArgs/SlowTailCallArgs.sh: line 251: 48570 Aborted                 (core dumped) $_DebuggerFullPath \"$CORE_ROOT/corerun\" $ExePath $CLRTestExecutionArguments
    
    
    Return code:      1
    Raw output file:      /home/helixbot/dotnetbuild/work/829eb0a1-744b-4dd3-8627-616125703d53/Work/3938d767-5cf7-42d2-8619-5e5ef7623a10/Unzip/Reports\\CoreMangLib.system\\span\\SlowTailCallArgs\\SlowTailCallArgs.output.txt
    Raw output:
    BEGIN EXECUTION
    /home/helixbot/dotnetbuild/work/829eb0a1-744b-4dd3-8627-616125703d53/Payload/corerun SlowTailCallArgs.exe
        SpanTest: Expected: 100
    Actual: 134
    END EXECUTION - FAILED
    Test Harness Exitcode is : 1
    
    To run the test:
    &gt; set CORE_ROOT=/home/helixbot/dotnetbuild/work/829eb0a1-744b-4dd3-8627-616125703d53/Payload
    &gt; /home/helixbot/dotnetbuild/work/829eb0a1-744b-4dd3-8627-616125703d53/Work/3938d767-5cf7-42d2-8619-5e5ef7623a10/Unzip/span/SlowTailCallArgs/SlowTailCallArgs.sh
    
    Expected: True
    Actual:   False

        Stack Trace:

        
Build : Master - 20180716.04 (Ready-To-Run Tests)
Failing configurations:
- opensuse.423.amd64
  - x64

Details: https://mc.dot.net/#/product/netcore/master/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fr2r~2Fcli~2F/build/20180716.04/workItem/CoreMangLib.system.XUnitWrapper/analysis/xunit/CoreMangLib_system._span_SlowTailCallArgs_SlowTailCallArgs_~2F_span_SlowTailCallArgs_SlowTailCallArgs_cmd</Description>
    <Title_Description>Test failure: CoreMangLib_system._span_SlowTailCallArgs_SlowTailCallArgs_/_span_SlowTailCallArgs_SlowTailCallArgs_cmd Opened on behalf of @Sunny-pu

The test  has failed.


    Unhandled Exception: System.IO.FileNotFoundException: Could not load file or assembly 'System.Reflection.Emit.ILGeneration Version=4.0.3.0 Culture=neutral PublicKeyToken=b03f5f7f11d50a3a'. The system cannot find the file specified.
    
       at SpanTest.Run()
       at Program.Main()
    /home/helixbot/dotnetbuild/work/829eb0a1-744b-4dd3-8627-616125703d53/Work/3938d767-5cf7-42d2-8619-5e5ef7623a10/Unzip/span/SlowTailCallArgs/SlowTailCallArgs.sh: line 251: 48570 Aborted                 (core dumped) $_DebuggerFullPath \"$CORE_ROOT/corerun\" $ExePath $CLRTestExecutionArguments
    
    
    Return code:      1
    Raw output file:      /home/helixbot/dotnetbuild/work/829eb0a1-744b-4dd3-8627-616125703d53/Work/3938d767-5cf7-42d2-8619-5e5ef7623a10/Unzip/Reports\\CoreMangLib.system\\span\\SlowTailCallArgs\\SlowTailCallArgs.output.txt
    Raw output:
    BEGIN EXECUTION
    /home/helixbot/dotnetbuild/work/829eb0a1-744b-4dd3-8627-616125703d53/Payload/corerun SlowTailCallArgs.exe
        SpanTest: Expected: 100
    Actual: 134
    END EXECUTION - FAILED
    Test Harness Exitcode is : 1
    
    To run the test:
    &gt; set CORE_ROOT=/home/helixbot/dotnetbuild/work/829eb0a1-744b-4dd3-8627-616125703d53/Payload
    &gt; /home/helixbot/dotnetbuild/work/829eb0a1-744b-4dd3-8627-616125703d53/Work/3938d767-5cf7-42d2-8619-5e5ef7623a10/Unzip/span/SlowTailCallArgs/SlowTailCallArgs.sh
    
    Expected: True
    Actual:   False

        Stack Trace:

        
Build : Master - 20180716.04 (Ready-To-Run Tests)
Failing configurations:
- opensuse.423.amd64
  - x64

Details: https://mc.dot.net/#/product/netcore/master/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fr2r~2Fcli~2F/build/20180716.04/workItem/CoreMangLib.system.XUnitWrapper/analysis/xunit/CoreMangLib_system._span_SlowTailCallArgs_SlowTailCallArgs_~2F_span_SlowTailCallArgs_SlowTailCallArgs_cmd</Title_Description>
    <Label>area-ReadyToRun</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>17/07/2018 8:44:49 AM +00:00</CreatedAt>
    <ClosedAt>20/06/2019 12:24:03 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18959</IssueLabelID>
    <Title>Test failure: baseservices_regression._v1_threads_functional_threadpool_cs_threadpoolnullchecks_CS_ThreadPoolNullChecks_CS_ThreadPoolNullChecks_/_v1_threads_functional_threadpool_cs_threadpoolnullchecks_CS_ThreadPoolNullChecks_CS_ThreadPoolNullChecks_cmd</Title>
    <Description>Opened on behalf of @Sunny-pu

The test  has failed.

Error: Could not load file or assembly 'System.Threading.ThreadPool Version=4.1.1.0 Culture=neutral PublicKeyToken=b03f5f7f11d50a3a'. The system cannot find the file specified.
     (Exception from HRESULT: 0x80070002)
    Error compiling CS_ThreadPoolNullChecks.org: Could not find or load a specific file. (Exception from HRESULT: 0x80131621)
    Error: compilation failed for \"CS_ThreadPoolNullChecks.org\" (0x80131621)
    
    
    Return code:      1
    Raw output file:      /home/helixbot/dotnetbuild/work/829eb0a1-744b-4dd3-8627-616125703d53/Work/b03a8239-5170-4a4b-a231-f0b855577e56/Unzip/Reports\\baseservices.regression\\v1\\threads\\functional\\threadpool\\cs_threadpoolnullchecks\\CS_ThreadPoolNullChecks\\CS_ThreadPoolNullChecks.output.txt
    Raw output:
    BEGIN EXECUTION
    in takeLock
    /home/helixbot/dotnetbuild/work/829eb0a1-744b-4dd3-8627-616125703d53/Payload/crossgen /Platform_Assemblies_Paths /home/helixbot/dotnetbuild/work/829eb0a1-744b-4dd3-8627-616125703d53/Payload:/home/helixbot/dotnetbuild/work/829eb0a1-744b-4dd3-8627-616125703d53/Work/b03a8239-5170-4a4b-a231-f0b855577e56/Unzip/v1/threads/functional/threadpool/cs_threadpoolnullchecks/CS_ThreadPoolNullChecks/IL:/home/helixbot/dotnetbuild/work/829eb0a1-744b-4dd3-8627-616125703d53/Work/b03a8239-5170-4a4b-a231-f0b855577e56/Unzip/v1/threads/functional/threadpool/cs_threadpoolnullchecks/CS_ThreadPoolNullChecks /in CS_ThreadPoolNullChecks.org /out CS_ThreadPoolNullChecks.exe
    Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0
    Copyright (c) Microsoft Corporation.  All rights reserved.
    
    Crossgen failed with exitcode: 33
    in ReleaseLock
    Test Harness Exitcode is : 1
    
    To run the test:
    &gt; set CORE_ROOT=/home/helixbot/dotnetbuild/work/829eb0a1-744b-4dd3-8627-616125703d53/Payload
    &gt; /home/helixbot/dotnetbuild/work/829eb0a1-744b-4dd3-8627-616125703d53/Work/b03a8239-5170-4a4b-a231-f0b855577e56/Unzip/v1/threads/functional/threadpool/cs_threadpoolnullchecks/CS_ThreadPoolNullChecks/CS_ThreadPoolNullChecks.sh
    
    Expected: True
    Actual:   False

        Stack Trace:

        
Build : Master - 20180716.04 (Ready-To-Run Tests)
Failing configurations:
- opensuse.423.amd64
  - x64

Details: https://mc.dot.net/#/product/netcore/master/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fr2r~2Fcli~2F/build/20180716.04/workItem/baseservices.regression.XUnitWrapper/analysis/xunit/baseservices_regression._v1_threads_functional_threadpool_cs_threadpoolnullchecks_CS_ThreadPoolNullChecks_CS_ThreadPoolNullChecks_~2F_v1_threads_functional_threadpool_cs_threadpoolnullchecks_CS_ThreadPoolNullChecks_CS_ThreadPoolNullChecks_cmd</Description>
    <Title_Description>Test failure: baseservices_regression._v1_threads_functional_threadpool_cs_threadpoolnullchecks_CS_ThreadPoolNullChecks_CS_ThreadPoolNullChecks_/_v1_threads_functional_threadpool_cs_threadpoolnullchecks_CS_ThreadPoolNullChecks_CS_ThreadPoolNullChecks_cmd Opened on behalf of @Sunny-pu

The test  has failed.

Error: Could not load file or assembly 'System.Threading.ThreadPool Version=4.1.1.0 Culture=neutral PublicKeyToken=b03f5f7f11d50a3a'. The system cannot find the file specified.
     (Exception from HRESULT: 0x80070002)
    Error compiling CS_ThreadPoolNullChecks.org: Could not find or load a specific file. (Exception from HRESULT: 0x80131621)
    Error: compilation failed for \"CS_ThreadPoolNullChecks.org\" (0x80131621)
    
    
    Return code:      1
    Raw output file:      /home/helixbot/dotnetbuild/work/829eb0a1-744b-4dd3-8627-616125703d53/Work/b03a8239-5170-4a4b-a231-f0b855577e56/Unzip/Reports\\baseservices.regression\\v1\\threads\\functional\\threadpool\\cs_threadpoolnullchecks\\CS_ThreadPoolNullChecks\\CS_ThreadPoolNullChecks.output.txt
    Raw output:
    BEGIN EXECUTION
    in takeLock
    /home/helixbot/dotnetbuild/work/829eb0a1-744b-4dd3-8627-616125703d53/Payload/crossgen /Platform_Assemblies_Paths /home/helixbot/dotnetbuild/work/829eb0a1-744b-4dd3-8627-616125703d53/Payload:/home/helixbot/dotnetbuild/work/829eb0a1-744b-4dd3-8627-616125703d53/Work/b03a8239-5170-4a4b-a231-f0b855577e56/Unzip/v1/threads/functional/threadpool/cs_threadpoolnullchecks/CS_ThreadPoolNullChecks/IL:/home/helixbot/dotnetbuild/work/829eb0a1-744b-4dd3-8627-616125703d53/Work/b03a8239-5170-4a4b-a231-f0b855577e56/Unzip/v1/threads/functional/threadpool/cs_threadpoolnullchecks/CS_ThreadPoolNullChecks /in CS_ThreadPoolNullChecks.org /out CS_ThreadPoolNullChecks.exe
    Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0
    Copyright (c) Microsoft Corporation.  All rights reserved.
    
    Crossgen failed with exitcode: 33
    in ReleaseLock
    Test Harness Exitcode is : 1
    
    To run the test:
    &gt; set CORE_ROOT=/home/helixbot/dotnetbuild/work/829eb0a1-744b-4dd3-8627-616125703d53/Payload
    &gt; /home/helixbot/dotnetbuild/work/829eb0a1-744b-4dd3-8627-616125703d53/Work/b03a8239-5170-4a4b-a231-f0b855577e56/Unzip/v1/threads/functional/threadpool/cs_threadpoolnullchecks/CS_ThreadPoolNullChecks/CS_ThreadPoolNullChecks.sh
    
    Expected: True
    Actual:   False

        Stack Trace:

        
Build : Master - 20180716.04 (Ready-To-Run Tests)
Failing configurations:
- opensuse.423.amd64
  - x64

Details: https://mc.dot.net/#/product/netcore/master/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fr2r~2Fcli~2F/build/20180716.04/workItem/baseservices.regression.XUnitWrapper/analysis/xunit/baseservices_regression._v1_threads_functional_threadpool_cs_threadpoolnullchecks_CS_ThreadPoolNullChecks_CS_ThreadPoolNullChecks_~2F_v1_threads_functional_threadpool_cs_threadpoolnullchecks_CS_ThreadPoolNullChecks_CS_ThreadPoolNullChecks_cmd</Title_Description>
    <Label>area-ReadyToRun</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>17/07/2018 8:17:23 AM +00:00</CreatedAt>
    <ClosedAt>20/06/2019 12:26:10 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18958</IssueLabelID>
    <Title>.NET CORE console appliation crashes randomly on RaspberryPi (mode: 3B+ Linux ARM32)</Title>
    <Description># Issue Title

My .NET CORE (runtime version 2.1.1) console application crashes randomly on RaspberryPi (mode: 3B+ Linux ARM32 Debian 9)

# General
I have an application that just open 8 tcp connections for read and write the data rate for each connection is about 200Byte/second in most case the application can runs well but sometime later like 7 or 8 hours it randomly crashes I have attached the  with logging but in these cases it never get called and I have seem some extra info shown in console before application crashes and quit they are:

&gt; ./myApp: relocation error: /pathToMyApp/libclrjit.so: symbol pthread_ version GLIBC_2.4 not defined in file libpthread.so.0 with link time reference

and

&gt;Bus error

and

&gt;Aborted

Later I've add my app to daemon mode and this time I can see sth in syslog:

&gt; Jul 17 08:30:51 raspberrypi systemd[1]: myApp.service: Main process exited code=killed status=6/ABRT
&gt; Jul 17 08:30:51 raspberrypi systemd[1]: myApp.service: Unit entered failed state.
&gt; Jul 17 08:30:51 raspberrypi systemd[1]: myApp.service: Failed with result 'signal'.
&gt; Jul 17 08:31:01 raspberrypi systemd[1]: myApp.service: Service hold-off time over scheduling restart.

I've logged the performance counters all the way can see the CPU and memory are all stable.
I've tried followed the [enable core dump on linux](http://blogs.microsoft.co.il/sasha/2017/02/26/analyzing-a-net-core-core-dump-on-linux/) but could never see any dump files generated please help.</Description>
    <Title_Description>.NET CORE console appliation crashes randomly on RaspberryPi (mode: 3B+, Linux ARM32) # Issue Title

My .NET CORE (runtime version 2.1.1) console application crashes randomly on RaspberryPi (mode: 3B+ Linux ARM32 Debian 9)

# General
I have an application that just open 8 tcp connections for read and write the data rate for each connection is about 200Byte/second in most case the application can runs well but sometime later like 7 or 8 hours it randomly crashes I have attached the  with logging but in these cases it never get called and I have seem some extra info shown in console before application crashes and quit they are:

&gt; ./myApp: relocation error: /pathToMyApp/libclrjit.so: symbol pthread_ version GLIBC_2.4 not defined in file libpthread.so.0 with link time reference

and

&gt;Bus error

and

&gt;Aborted

Later I've add my app to daemon mode and this time I can see sth in syslog:

&gt; Jul 17 08:30:51 raspberrypi systemd[1]: myApp.service: Main process exited code=killed status=6/ABRT
&gt; Jul 17 08:30:51 raspberrypi systemd[1]: myApp.service: Unit entered failed state.
&gt; Jul 17 08:30:51 raspberrypi systemd[1]: myApp.service: Failed with result 'signal'.
&gt; Jul 17 08:31:01 raspberrypi systemd[1]: myApp.service: Service hold-off time over scheduling restart.

I've logged the performance counters all the way can see the CPU and memory are all stable.
I've tried followed the [enable core dump on linux](http://blogs.microsoft.co.il/sasha/2017/02/26/analyzing-a-net-core-core-dump-on-linux/) but could never see any dump files generated please help.</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>17/07/2018 7:27:12 AM +00:00</CreatedAt>
    <ClosedAt>14/01/2019 5:56:57 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18953</IssueLabelID>
    <Title>Enable the no tiered compilation innerloop PR legs</Title>
    <Description>Also using this PR to manually trigger test jobs. Marking no merge until manual testing is complete.</Description>
    <Title_Description>Enable the no tiered compilation innerloop PR legs Also using this PR to manually trigger test jobs. Marking no merge until manual testing is complete.</Title_Description>
    <Label>area-TieredCompilation</Label>
    <Assignee>noahfalk</Assignee>
    <CreatedAt>17/07/2018 2:09:11 AM +00:00</CreatedAt>
    <ClosedAt>19/07/2018 11:36:35 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18951</IssueLabelID>
    <Title>[WIP] dummy change in dev/unix_test_workflow</Title>
    <Description>
    </Description>
    <Title_Description>[WIP] dummy change in dev/unix_test_workflow </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>16/07/2018 11:23:00 PM +00:00</CreatedAt>
    <ClosedAt>24/07/2018 6:39:19 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18946</IssueLabelID>
    <Title>Update NativeCallable attribute tests</Title>
    <Description>Fix tests for the NativeCallableAttribute. #18906 

cc @jkotas @luqunl </Description>
    <Title_Description>Update NativeCallable attribute tests Fix tests for the NativeCallableAttribute. #18906 

cc @jkotas @luqunl </Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>16/07/2018 9:32:46 PM +00:00</CreatedAt>
    <ClosedAt>17/07/2018 6:12:03 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18945</IssueLabelID>
    <Title>Assertion failure on Unixes in JIT/SIMD/VectorExp_ro with tiering enabled</Title>
    <Description>.</Description>
    <Title_Description>Assertion failure on Unixes in JIT/SIMD/VectorExp_ro with tiering enabled .</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>kouvel</Assignee>
    <CreatedAt>16/07/2018 7:38:47 PM +00:00</CreatedAt>
    <ClosedAt>26/07/2018 10:39:43 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18944</IssueLabelID>
    <Title>LSRA: Consider a stress mode that trashes registers</Title>
    <Description>The issue https://github.com/dotnet/coreclr/issues/18943 is a case where it appears a register is being incorrectly copied to the wrong register before its intended use. If we had a  mode that would write some trash value to each register when it goes dead a case like this might have been caught.

category:implementation
theme:register-allocator
skill-level:beginner
cost:small</Description>
    <Title_Description>LSRA: Consider a stress mode that trashes registers The issue https://github.com/dotnet/coreclr/issues/18943 is a case where it appears a register is being incorrectly copied to the wrong register before its intended use. If we had a  mode that would write some trash value to each register when it goes dead a case like this might have been caught.

category:implementation
theme:register-allocator
skill-level:beginner
cost:small</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
    <CreatedAt>16/07/2018 7:37:05 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18943</IssueLabelID>
    <Title>Inconsistent reg assignment for tailcall Stub Addr Arg</Title>
    <Description> is apparently unnecessary.</Description>
    <Title_Description>Inconsistent reg assignment for tailcall Stub Addr Arg  is apparently unnecessary.</Title_Description>
    <Label>arch-x64</Label>
    <Assignee>AndyAyersMS</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18937</IssueLabelID>
    <Title>Assert failure in JIT.Methodical.xxobj.ldobj._il_relldobj_V._il_relldobj_V 'arg0VN == VNNormVal(arg0VN)'</Title>
    <Description>Found this regression introduced between [Build #9949 (Jul 13 2018 11:03:21 AM)](https://ci.dot.net/job/dotnet_coreclr/job/master/view/Windows_NT/job/checked_windows_nt/9949/) and [Build #9950 (Jul 13 2018 1:21:43 PM)](https://ci.dot.net/job/dotnet_coreclr/job/master/view/Windows_NT/job/checked_windows_nt/9950/) which corresponds to 

Changes: 
1. JIT: optimize some cases of unused structs (#18819) (commit: dc7492e)

Reproduced on Windows and Linux x64 and arm</Description>
    <Title_Description>Assert failure in JIT.Methodical.xxobj.ldobj._il_relldobj_V._il_relldobj_V 'arg0VN == VNNormVal(arg0VN)' Found this regression introduced between [Build #9949 (Jul 13 2018 11:03:21 AM)](https://ci.dot.net/job/dotnet_coreclr/job/master/view/Windows_NT/job/checked_windows_nt/9949/) and [Build #9950 (Jul 13 2018 1:21:43 PM)](https://ci.dot.net/job/dotnet_coreclr/job/master/view/Windows_NT/job/checked_windows_nt/9950/) which corresponds to 

Changes: 
1. JIT: optimize some cases of unused structs (#18819) (commit: dc7492e)

Reproduced on Windows and Linux x64 and arm</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>pgavlin</Assignee>
    <CreatedAt>16/07/2018 4:35:56 PM +00:00</CreatedAt>
    <ClosedAt>17/07/2018 1:48:25 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18934</IssueLabelID>
    <Title>[JIT] Emitted bounds check comparing a constant index against a constant length</Title>
    <Description>From #18926 the JIT mostly does an impressively good job of optimizing this code:


That... seems like a rather easy bounds check to cut out.

category:cq
theme:bounds-checks
skill-level:intermediate
cost:small</Description>
    <Title_Description>[JIT] Emitted bounds check comparing a constant index against a constant length From #18926 the JIT mostly does an impressively good job of optimizing this code:


That... seems like a rather easy bounds check to cut out.

category:cq
theme:bounds-checks
skill-level:intermediate
cost:small</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
    <CreatedAt>16/07/2018 4:07:29 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18926</IssueLabelID>
    <Title>Hardware Intrinsics: Reading out SSE vector values without unsafe or Sse4.1?</Title>
    <Description>Loading values into a Vector128&lt;&gt; is easy enough lots of safe options there. But my options seem rather limited when it comes to reading them back out again... the only choices I've found are  pointer parameter. Is there any safe option that doesn't affect minimum hardware requirements?</Description>
    <Title_Description>Hardware Intrinsics: Reading out SSE vector values without unsafe or Sse4.1? Loading values into a Vector128&lt;&gt; is easy enough lots of safe options there. But my options seem rather limited when it comes to reading them back out again... the only choices I've found are  pointer parameter. Is there any safe option that doesn't affect minimum hardware requirements?</Title_Description>
    <Label>area-System.Runtime</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>15/07/2018 7:36:05 PM +00:00</CreatedAt>
    <ClosedAt>9/12/2018 7:42:39 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18925</IssueLabelID>
    <Title>Hardware Intrinsics:  Non-volatile xmm regs unnecessarily spilled to stack</Title>
    <Description>Even though my code only actually needs a total of 4 SSE registers in some cases the JIT is deciding to use 
Full code: [SpanXxHash32.cs.txt](https://github.com/dotnet/coreclr/files/2195999/SpanXxHash32.cs.txt)

</Description>
    <Title_Description>Hardware Intrinsics:  Non-volatile xmm regs unnecessarily spilled to stack Even though my code only actually needs a total of 4 SSE registers in some cases the JIT is deciding to use 
Full code: [SpanXxHash32.cs.txt](https://github.com/dotnet/coreclr/files/2195999/SpanXxHash32.cs.txt)

</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
    <CreatedAt>15/07/2018 6:54:18 PM +00:00</CreatedAt>
    <ClosedAt>16/07/2018 5:17:46 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18920</IssueLabelID>
    <Title>Clean coreclr build incurs ~100 warnings from R2RDump.csproj</Title>
    <Description>
    </Description>
    <Title_Description>Clean coreclr build incurs ~100 warnings from R2RDump.csproj </Title_Description>
    <Label>area-ReadyToRun</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>15/07/2018 3:05:02 AM +00:00</CreatedAt>
    <ClosedAt>26/07/2018 6:19:22 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18914</IssueLabelID>
    <Title>[Windows/arm64] corefx System.Runtime.Tests test failure</Title>
    <Description>Happens in baseline and all JIT stress runs.



e.g. https://ci.dot.net/job/dotnet_coreclr/job/dev_unix_test_workflow/job/jitstress/job/arm64_cross_checked_windows_nt_corefx_baseline_tst_prtest/3/consoleText
</Description>
    <Title_Description>[Windows/arm64] corefx System.Runtime.Tests test failure Happens in baseline and all JIT stress runs.



e.g. https://ci.dot.net/job/dotnet_coreclr/job/dev_unix_test_workflow/job/jitstress/job/arm64_cross_checked_windows_nt_corefx_baseline_tst_prtest/3/consoleText
</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>sandreenko</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18913</IssueLabelID>
    <Title>[arm64] corefx System.ComponentModel.Composition.Tests failure</Title>
    <Description>While scouting Windows arm64 corefx testing: https://ci.dot.net/job/dotnet_coreclr/job/dev_unix_test_workflow/job/jitstress/job/arm64_cross_checked_windows_nt_corefx_baseline_tst_prtest/3/consoleText




Remove exclusion from arm64\corefx_test_exclusions.txt when fixed.
</Description>
    <Title_Description>[arm64] corefx System.ComponentModel.Composition.Tests failure While scouting Windows arm64 corefx testing: https://ci.dot.net/job/dotnet_coreclr/job/dev_unix_test_workflow/job/jitstress/job/arm64_cross_checked_windows_nt_corefx_baseline_tst_prtest/3/consoleText




Remove exclusion from arm64\corefx_test_exclusions.txt when fixed.
</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>sandreenko</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18912</IssueLabelID>
    <Title>System.Text.RegularExpressions.Tests JitMinOpts only timeout</Title>
    <Description>

Related: https://github.com/dotnet/coreclr/issues/17754

category:testing
theme:minopts
skill-level:intermediate
cost:medium</Description>
    <Title_Description>System.Text.RegularExpressions.Tests JitMinOpts only timeout 

Related: https://github.com/dotnet/coreclr/issues/17754

category:testing
theme:minopts
skill-level:intermediate
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>13/07/2018 10:33:22 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18910</IssueLabelID>
    <Title>Add all integer overloads for Avx2.BlendVariable</Title>
    <Description>Now we only have the ) will significantly improve the user experience.

cc @tannergooding @CarolEidt @eerhardt </Description>
    <Title_Description>Add all integer overloads for Avx2.BlendVariable Now we only have the ) will significantly improve the user experience.

cc @tannergooding @CarolEidt @eerhardt </Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>tannergooding</Assignee>
    <CreatedAt>13/07/2018 9:43:20 PM +00:00</CreatedAt>
    <ClosedAt>20/09/2018 8:42:35 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18908</IssueLabelID>
    <Title>Add tests for DECIMAL PInvoke marshaling</Title>
    <Description>https://github.com/dotnet/coreclr/pull/18868#discussion_r202166213
https://github.com/dotnet/corert/issues/4994</Description>
    <Title_Description>Add tests for DECIMAL PInvoke marshaling https://github.com/dotnet/coreclr/pull/18868#discussion_r202166213
https://github.com/dotnet/corert/issues/4994</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>13/07/2018 6:57:54 PM +00:00</CreatedAt>
    <ClosedAt>17/11/2018 12:25:43 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18907</IssueLabelID>
    <Title>[Linux/arm32][GCStress=0xc] RuntimeEventSourceTest 'listener.EventCount &gt; 0' Assertion Failure</Title>
    <Description>All the recent Ubuntu arm32 GCStress=0xc runs failed the same way in recently added RuntimeEventSourceTest in #18649 

 added in #18911</Description>
    <Title_Description>[Linux/arm32][GCStress=0xc] RuntimeEventSourceTest 'listener.EventCount &gt; 0' Assertion Failure All the recent Ubuntu arm32 GCStress=0xc runs failed the same way in recently added RuntimeEventSourceTest in #18649 

 added in #18911</Title_Description>
    <Label>GCStress</Label>
    <Assignee>echesakovMSFT</Assignee>
    <CreatedAt>13/07/2018 6:35:09 PM +00:00</CreatedAt>
    <ClosedAt>27/02/2019 9:43:08 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18906</IssueLabelID>
    <Title>Improve NativeCallable tests</Title>
    <Description>Some of the cases in the [ should be covered.

cc @jaredpar @jeffschwMSFT @luqunl </Description>
    <Title_Description>Improve NativeCallable tests Some of the cases in the [ should be covered.

cc @jaredpar @jeffschwMSFT @luqunl </Title_Description>
    <Label>area-Interop</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18904</IssueLabelID>
    <Title>Add prefix to DAC's PAL exports for alpine</Title>
    <Description>Added some cmake logic to create assembly include mapping files. One that maps the
prefixed name (DAC_foo) to the actual name (foo) which is included in the DAC module
and another that maps the actual name to the prefixed name that is included in the SOS
DBI and createdump modules.

The data exports like IID_IUnknown are not prefixed and don't need to be (immutable static data).

There were some C++ exports functions exported with their decorated names in
the CatchHardwareExceptionHolder and NativeExceptionHolderBase classes. Created
PAL_* style export functions that implements the code.

Fix lldb plugin cmake file to use LLDB_H/LLDB_LIB env vars to build it.</Description>
    <Title_Description>Add prefix to DAC's PAL exports for alpine Added some cmake logic to create assembly include mapping files. One that maps the
prefixed name (DAC_foo) to the actual name (foo) which is included in the DAC module
and another that maps the actual name to the prefixed name that is included in the SOS
DBI and createdump modules.

The data exports like IID_IUnknown are not prefixed and don't need to be (immutable static data).

There were some C++ exports functions exported with their decorated names in
the CatchHardwareExceptionHolder and NativeExceptionHolderBase classes. Created
PAL_* style export functions that implements the code.

Fix lldb plugin cmake file to use LLDB_H/LLDB_LIB env vars to build it.</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>mikem8361</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18903</IssueLabelID>
    <Title>Assembly.LoadFrom("System.Threading.Tasks.Extensions.dll") fails with FileLoadException</Title>
    <Description>We (PostSharp) noticed a weird behavior of .NET Core CLR and are asking for clarifications so we can implement a proper solution.

Consider the following program:

 file and include any assembly that we need to load at runtime but that are not a build-time dependency.

Could you please spread some light on this situation?

Thank you.

-gael
</Description>
    <Title_Description>Assembly.LoadFrom("System.Threading.Tasks.Extensions.dll") fails with FileLoadException We (PostSharp) noticed a weird behavior of .NET Core CLR and are asking for clarifications so we can implement a proper solution.

Consider the following program:

 file and include any assembly that we need to load at runtime but that are not a build-time dependency.

Could you please spread some light on this situation?

Thank you.

-gael
</Title_Description>
    <Label>area-AssemblyLoader</Label>
    <Assignee>jeffschwMSFT</Assignee>
    <CreatedAt>13/07/2018 4:03:23 PM +00:00</CreatedAt>
    <ClosedAt>16/07/2018 4:52:52 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18901</IssueLabelID>
    <Title>WIP Fix bit-rot when '#define MEASURE_CLRAPI_CALLS' is used</Title>
    <Description>When I was writing [.NET JIT and CLR - Joined at the Hip](http://mattwarren.org/2018/07/05/.NET-JIT-and-CLR-Joined-at-the-Hip/) I noticed that the JIT wrapper apis had got out of sync although it's only noticeable with  I just wanted to make sure all the builds passed first (hence WIP).</Description>
    <Title_Description>WIP Fix bit-rot when '#define MEASURE_CLRAPI_CALLS' is used When I was writing [.NET JIT and CLR - Joined at the Hip](http://mattwarren.org/2018/07/05/.NET-JIT-and-CLR-Joined-at-the-Hip/) I noticed that the JIT wrapper apis had got out of sync although it's only noticeable with  I just wanted to make sure all the builds passed first (hence WIP).</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>pkukol</Assignee>
    <CreatedAt>13/07/2018 2:10:58 PM +00:00</CreatedAt>
    <ClosedAt>4/10/2019 11:16:27 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18900</IssueLabelID>
    <Title>Implement GetComObjectData and SetComObjectData</Title>
    <Description>Contributes to https://github.com/dotnet/corefx/issues/31015</Description>
    <Title_Description>Implement GetComObjectData and SetComObjectData Contributes to https://github.com/dotnet/corefx/issues/31015</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>13/07/2018 10:43:28 AM +00:00</CreatedAt>
    <ClosedAt>19/07/2018 3:29:31 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18898</IssueLabelID>
    <Title>Test failure: CoreMangLib_cti._system_guid_GuidEquals2_GuidEquals2_/_system_guid_GuidEquals2_GuidEquals2_cmd</Title>
    <Description>Opened on behalf of @Sunny-pu

The test  has failed.

mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    
    cmdLine:/home/helixbot/dotnetbuild/work/c0463900-787c-47e6-bdc5-f2cc35669145/Work/0316fdb5-17c7-4801-9101-89b220f9360a/Unzip/system/guid/GuidEquals2/GuidEquals2.sh Timed Out
    
    
    Return code:      -100
    Raw output file:      /home/helixbot/dotnetbuild/work/c0463900-787c-47e6-bdc5-f2cc35669145/Work/0316fdb5-17c7-4801-9101-89b220f9360a/Unzip/Reports\\CoreMangLib.cti\\system\\guid\\GuidEquals2\\GuidEquals2.output.txt
    Raw output:
    BEGIN EXECUTION
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    
    cmdLine:/home/helixbot/dotnetbuild/work/c0463900-787c-47e6-bdc5-f2cc35669145/Work/0316fdb5-17c7-4801-9101-89b220f9360a/Unzip/system/guid/GuidEquals2/GuidEquals2.sh Timed Out
    Test Harness Exitcode is : -100
    
    To run the test:
    &gt; set CORE_ROOT=/home/helixbot/dotnetbuild/work/c0463900-787c-47e6-bdc5-f2cc35669145/Payload
    &gt; /home/helixbot/dotnetbuild/work/c0463900-787c-47e6-bdc5-f2cc35669145/Work/0316fdb5-17c7-4801-9101-89b220f9360a/Unzip/system/guid/GuidEquals2/GuidEquals2.sh
    
    Expected: True
    Actual:   False

        Stack Trace:

        
Build : Master - 20180712.06 (Ready-To-Run Tests)
Failing configurations:
- ubuntu.1710.amd64
  - x64

Details: https://mc.dot.net/#/product/netcore/master/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fr2r~2Fcli~2F/build/20180712.06/workItem/CoreMangLib.cti.XUnitWrapper/analysis/xunit/CoreMangLib_cti._system_guid_GuidEquals2_GuidEquals2_~2F_system_guid_GuidEquals2_GuidEquals2_cmd</Description>
    <Title_Description>Test failure: CoreMangLib_cti._system_guid_GuidEquals2_GuidEquals2_/_system_guid_GuidEquals2_GuidEquals2_cmd Opened on behalf of @Sunny-pu

The test  has failed.

mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    
    cmdLine:/home/helixbot/dotnetbuild/work/c0463900-787c-47e6-bdc5-f2cc35669145/Work/0316fdb5-17c7-4801-9101-89b220f9360a/Unzip/system/guid/GuidEquals2/GuidEquals2.sh Timed Out
    
    
    Return code:      -100
    Raw output file:      /home/helixbot/dotnetbuild/work/c0463900-787c-47e6-bdc5-f2cc35669145/Work/0316fdb5-17c7-4801-9101-89b220f9360a/Unzip/Reports\\CoreMangLib.cti\\system\\guid\\GuidEquals2\\GuidEquals2.output.txt
    Raw output:
    BEGIN EXECUTION
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    
    cmdLine:/home/helixbot/dotnetbuild/work/c0463900-787c-47e6-bdc5-f2cc35669145/Work/0316fdb5-17c7-4801-9101-89b220f9360a/Unzip/system/guid/GuidEquals2/GuidEquals2.sh Timed Out
    Test Harness Exitcode is : -100
    
    To run the test:
    &gt; set CORE_ROOT=/home/helixbot/dotnetbuild/work/c0463900-787c-47e6-bdc5-f2cc35669145/Payload
    &gt; /home/helixbot/dotnetbuild/work/c0463900-787c-47e6-bdc5-f2cc35669145/Work/0316fdb5-17c7-4801-9101-89b220f9360a/Unzip/system/guid/GuidEquals2/GuidEquals2.sh
    
    Expected: True
    Actual:   False

        Stack Trace:

        
Build : Master - 20180712.06 (Ready-To-Run Tests)
Failing configurations:
- ubuntu.1710.amd64
  - x64

Details: https://mc.dot.net/#/product/netcore/master/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fr2r~2Fcli~2F/build/20180712.06/workItem/CoreMangLib.cti.XUnitWrapper/analysis/xunit/CoreMangLib_cti._system_guid_GuidEquals2_GuidEquals2_~2F_system_guid_GuidEquals2_GuidEquals2_cmd</Title_Description>
    <Label>area-ReadyToRun</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>13/07/2018 7:16:05 AM +00:00</CreatedAt>
    <ClosedAt>23/05/2019 9:35:23 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18895</IssueLabelID>
    <Title>[arm64] Assertion failed '(allRegs(theInterval-&gt;registerType) &amp; mask) != 0'</Title>
    <Description>Running JIT\HardwareIntrinsics\Arm64\Simd\Simd.cmd test:



e.g. https://ci.dot.net/job/dotnet_coreclr/job/master/job/arm64_cross_debug_windows_nt_tst/566
</Description>
    <Title_Description>[arm64] Assertion failed '(allRegs(theInterval-&gt;registerType) &amp; mask) != 0' Running JIT\HardwareIntrinsics\Arm64\Simd\Simd.cmd test:



e.g. https://ci.dot.net/job/dotnet_coreclr/job/master/job/arm64_cross_debug_windows_nt_tst/566
</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>sandreenko</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18894</IssueLabelID>
    <Title>Investigate: can we improve docs or diagnostics when 64 bit .NET Core app fails on Azure App Service</Title>
    <Description>@noahfalk commented on [Thu Jun 07 2018](https://github.com/dotnet/core/issues/1670)

This issue is forked from #1622 where @joseclament reported that he was getting an unexplained BadImageFormatException. The limitation from Azure App Service is by design but perhaps we could offer better guidance in docs or diagnostic error messages so that developers will more quickly discover the right path forward. Thanks @joseclament for raising the issue!

&gt; @noahfalk  and @nil4  I got the bottom of the problem. It took couple of days to get the bottom of the issue and made me bit nut. I was able to dig and find this link: https://tutel.me/c/programming/questions/42726350/how+to+change+azure+app+service+to+64bit
&gt; 
&gt; Your core should be built on x86 version even if the deploying server(Azure) is based on 64 bit architecture. Because the 64 bit .NET core processes using the .NET core runtime (as opposed to the .NET Framework runtime) are not yet supported on Azure but is planned to be coming in the future. You can verify this by go to the kudu and type  dotnet --info. You can see something like this below:
&gt; 
&gt; .NET Core SDK (reflecting any global.json):
&gt;  Version:   2.1.300
&gt;  Commit:    32f29b6eb9
&gt; 
&gt; Runtime Environment:
&gt;  OS Name:     Windows
&gt;  OS Version:  10.0.14393
&gt;  OS Platform: Windows
&gt;  RID:         win10-x86
&gt;  _Base Path:   D:\Program Files (x86)\dotnet\sdk\2.1.300\_ [**You  can see only the x86 version here**]
&gt; 
&gt; Host (useful for support):
&gt;   Version: 2.1.0
&gt;   Commit:  caa7b7e2ba
&gt; 
&gt; .NET Core SDKs installed:
&gt;   1.1.8 [D:\Program Files (x86)\dotnet\sdk]
&gt;   2.1.101 [D:\Program Files (x86)\dotnet\sdk]
&gt;   2.1.300 [D:\Program Files (x86)\dotnet\sdk]
&gt; 
&gt; You may be able to debug this locally "Any CPU" option as you might have x86 and x64 based libraries installed on your machine. I could not find any documentation on MSDN about this. I was assumed it would have been automatically support x64 version. Also make sure that the application setting is enabled for the "32" bit.
&gt; 


---

@bcisnero commented on [Fri Jun 08 2018](https://github.com/dotnet/core/issues/1670#issuecomment-395922622)

Probably a fast solution to this will be to add a note in the document explaining just what are the Azure limitations and the the workaround at this point because and this is going to change at some point in the future.

</Description>
    <Title_Description>Investigate: can we improve docs or diagnostics when 64 bit .NET Core app fails on Azure App Service @noahfalk commented on [Thu Jun 07 2018](https://github.com/dotnet/core/issues/1670)

This issue is forked from #1622 where @joseclament reported that he was getting an unexplained BadImageFormatException. The limitation from Azure App Service is by design but perhaps we could offer better guidance in docs or diagnostic error messages so that developers will more quickly discover the right path forward. Thanks @joseclament for raising the issue!

&gt; @noahfalk  and @nil4  I got the bottom of the problem. It took couple of days to get the bottom of the issue and made me bit nut. I was able to dig and find this link: https://tutel.me/c/programming/questions/42726350/how+to+change+azure+app+service+to+64bit
&gt; 
&gt; Your core should be built on x86 version even if the deploying server(Azure) is based on 64 bit architecture. Because the 64 bit .NET core processes using the .NET core runtime (as opposed to the .NET Framework runtime) are not yet supported on Azure but is planned to be coming in the future. You can verify this by go to the kudu and type  dotnet --info. You can see something like this below:
&gt; 
&gt; .NET Core SDK (reflecting any global.json):
&gt;  Version:   2.1.300
&gt;  Commit:    32f29b6eb9
&gt; 
&gt; Runtime Environment:
&gt;  OS Name:     Windows
&gt;  OS Version:  10.0.14393
&gt;  OS Platform: Windows
&gt;  RID:         win10-x86
&gt;  _Base Path:   D:\Program Files (x86)\dotnet\sdk\2.1.300\_ [**You  can see only the x86 version here**]
&gt; 
&gt; Host (useful for support):
&gt;   Version: 2.1.0
&gt;   Commit:  caa7b7e2ba
&gt; 
&gt; .NET Core SDKs installed:
&gt;   1.1.8 [D:\Program Files (x86)\dotnet\sdk]
&gt;   2.1.101 [D:\Program Files (x86)\dotnet\sdk]
&gt;   2.1.300 [D:\Program Files (x86)\dotnet\sdk]
&gt; 
&gt; You may be able to debug this locally "Any CPU" option as you might have x86 and x64 based libraries installed on your machine. I could not find any documentation on MSDN about this. I was assumed it would have been automatically support x64 version. Also make sure that the application setting is enabled for the "32" bit.
&gt; 


---

@bcisnero commented on [Fri Jun 08 2018](https://github.com/dotnet/core/issues/1670#issuecomment-395922622)

Probably a fast solution to this will be to add a note in the document explaining just what are the Azure limitations and the the workaround at this point because and this is going to change at some point in the future.

</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>noahfalk</Assignee>
    <CreatedAt>12/07/2018 9:48:21 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18893</IssueLabelID>
    <Title>createdump is missing on ARM and ARM64</Title>
    <Description>X86 runtime has utility 
</Description>
    <Title_Description>createdump is missing on ARM and ARM64 X86 runtime has utility 
</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>hoyosjs</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18889</IssueLabelID>
    <Title>sosplugin is not working on ARM</Title>
    <Description>
I tested this in my RP3 as well as Ubuntu on Qemu. I'm not even  able to get list of commands. 


</Description>
    <Title_Description>sosplugin is not working on ARM 
I tested this in my RP3 as well as Ubuntu on Qemu. I'm not even  able to get list of commands. 


</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>mikem8361</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18886</IssueLabelID>
    <Title>ARM64 corefx test failures</Title>
    <Description>The following tests fail in corefx CI runs and have been disabled. There are some similar failures for ARM in #16001.

E.g. https://ci.dot.net/job/dotnet_coreclr/job/dev_unix_test_workflow/job/jitstress/job/arm64_cross_checked_windows_nt_corefx_baseline_tst_prtest/2/consoleText

</Description>
    <Title_Description>ARM64 corefx test failures The following tests fail in corefx CI runs and have been disabled. There are some similar failures for ARM in #16001.

E.g. https://ci.dot.net/job/dotnet_coreclr/job/dev_unix_test_workflow/job/jitstress/job/arm64_cross_checked_windows_nt_corefx_baseline_tst_prtest/2/consoleText

</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>sandreenko</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18885</IssueLabelID>
    <Title>ILDASM - Wrong exit code</Title>
    <Description>I'm using ILDASM to inspect all files in a folder (project build output) and in somes cases i have configuration/text files. In those edge cases i caught a bug although i received an exit code 0 the process output was "Image is either too small or contains an invalid byte offset or count.\n". According to the process output i was expecting to receive an exit 1.

I'm migrating to this version of ILDASM (before i was using https://docs.microsoft.com/en-us/dotnet/framework/tools/ildasm-exe-il-disassembler) because i couldn't run in Docker container with mono.</Description>
    <Title_Description>ILDASM - Wrong exit code I'm using ILDASM to inspect all files in a folder (project build output) and in somes cases i have configuration/text files. In those edge cases i caught a bug although i received an exit code 0 the process output was "Image is either too small or contains an invalid byte offset or count.\n". According to the process output i was expecting to receive an exit 1.

I'm migrating to this version of ILDASM (before i was using https://docs.microsoft.com/en-us/dotnet/framework/tools/ildasm-exe-il-disassembler) because i couldn't run in Docker container with mono.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18884</IssueLabelID>
    <Title>RyuJIT fails to preserve variable allocated to RCX around shift on x64 in release</Title>
    <Description>On Linux the following example prints a weird result:


It repros on Windows as well (see next comment).</Description>
    <Title_Description>RyuJIT fails to preserve variable allocated to RCX around shift on x64 in release On Linux the following example prints a weird result:


It repros on Windows as well (see next comment).</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18877</IssueLabelID>
    <Title>[RyuJIT] Ensure all the VEX.vvvv instructions in IsDstDstSrc/DstSrcSrcAVXInstruction</Title>
    <Description>Logging the conversation https://github.com/dotnet/coreclr/pull/18876#pullrequestreview-136452081

We should double check that all the instructions that use .</Description>
    <Title_Description>[RyuJIT] Ensure all the VEX.vvvv instructions in IsDstDstSrc/DstSrcSrcAVXInstruction Logging the conversation https://github.com/dotnet/coreclr/pull/18876#pullrequestreview-136452081

We should double check that all the instructions that use .</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18873</IssueLabelID>
    <Title>Add prefix to DAC's PAL exports for alpine</Title>
    <Description>Added some cmake logic to create assembly include mapping files. One that maps the
prefixed name (DAC_foo) to the actual name (foo) which is included in the DAC module
and another that maps the actual name to the prefixed name that is included in the SOS
DBI and createdump modules.

The data exports like IID_IUnknown are not prefixed and don't need to be (immutable static data).

There were some C++ exports functions exported with their decorated names in
the CatchHardwareExceptionHolder and NativeExceptionHolderBase classes. Created
PAL_* style export functions that implements the code.

Fix lldb plugin cmake file to use LLDB_H/LLDB_LIB env vars to build it.</Description>
    <Title_Description>Add prefix to DAC's PAL exports for alpine Added some cmake logic to create assembly include mapping files. One that maps the
prefixed name (DAC_foo) to the actual name (foo) which is included in the DAC module
and another that maps the actual name to the prefixed name that is included in the SOS
DBI and createdump modules.

The data exports like IID_IUnknown are not prefixed and don't need to be (immutable static data).

There were some C++ exports functions exported with their decorated names in
the CatchHardwareExceptionHolder and NativeExceptionHolderBase classes. Created
PAL_* style export functions that implements the code.

Fix lldb plugin cmake file to use LLDB_H/LLDB_LIB env vars to build it.</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>mikem8361</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18872</IssueLabelID>
    <Title>Suspicious move possible use after move?</Title>
    <Description>I think there might be a use after move in  might have been moved just before its use.

category:implementation
theme:jit-coding-style
skill-level:beginner
cost:small</Description>
    <Title_Description>Suspicious move, possible use after move? I think there might be a use after move in  might have been moved just before its use.

category:implementation
theme:jit-coding-style
skill-level:beginner
cost:small</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>11/07/2018 8:37:33 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18869</IssueLabelID>
    <Title>LclVar sorting throughput improvements</Title>
    <Description>Follow-up from #18504 discussion. There are a few inefficiencies around lclvar sorting ( lclvars need be. A partial sort algorithm could be beneficial in those cases where the JIT internally generates large number of lclvars (I think there was an issue with like 10000 lclvars). But such cases seem to be rare in corelib there are only a couple of methods with ~600 lclvars and the rest are below 512.
* Do we actually need to sort the lclvars? Or is it enough to just take the top 512 lclvars in no particular order? It's obvious that as far as liveness is concerned the order of the tracked variables is irrelevant. So far I only found a case (CSE heuristic) that appears to depend on the order.
</Description>
    <Title_Description>LclVar sorting throughput improvements Follow-up from #18504 discussion. There are a few inefficiencies around lclvar sorting ( lclvars need be. A partial sort algorithm could be beneficial in those cases where the JIT internally generates large number of lclvars (I think there was an issue with like 10000 lclvars). But such cases seem to be rare in corelib there are only a couple of methods with ~600 lclvars and the rest are below 512.
* Do we actually need to sort the lclvars? Or is it enough to just take the top 512 lclvars in no particular order? It's obvious that as far as liveness is concerned the order of the tracked variables is irrelevant. So far I only found a case (CSE heuristic) that appears to depend on the order.
</Title_Description>
    <Label>JitThroughput</Label>
    <Assignee>AndyAyersMS</Assignee>
    <CreatedAt>11/07/2018 6:03:25 PM +00:00</CreatedAt>
    <ClosedAt>13/09/2019 2:45:05 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18867</IssueLabelID>
    <Title>RyuJIT spills 16 bit value but reloads as 32 bits in ARM32/x86 in release</Title>
    <Description>For ARM32 the example is:
</Description>
    <Title_Description>RyuJIT spills 16 bit value but reloads as 32 bits in ARM32/x86 in release For ARM32 the example is:
</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>11/07/2018 11:51:18 AM +00:00</CreatedAt>
    <ClosedAt>27/11/2018 12:31:38 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18865</IssueLabelID>
    <Title>"SIGSEGV: address access protected" on Debian 9</Title>
    <Description>Unfortunately I don't have a consistent repro of this problem and only have had this happen very rarely where the app aborted with no info. Last night I started it in lldb and left it running over night and it crashed with "address access protected".



Unfortunately it seems there's no debug symbols loaded so the stacktrace seems rather unhelpful. What would be my next step here?</Description>
    <Title_Description>"SIGSEGV: address access protected" on Debian 9 Unfortunately I don't have a consistent repro of this problem and only have had this happen very rarely where the app aborted with no info. Last night I started it in lldb and left it running over night and it crashed with "address access protected".



Unfortunately it seems there's no debug symbols loaded so the stacktrace seems rather unhelpful. What would be my next step here?</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18864</IssueLabelID>
    <Title>Add no tiered compilation test jobs</Title>
    <Description>With the upcoming switch to make tiered compilation on by default we want to preserve some JIT testing that will not enable tiered compilation.
1) Add 'no_tiered_compilation_pri0' jit stress job logically the non-tiered variant of current 'Innerloop' jobs
   - This job runs on all PRs for Checked x (Windows x86 Windows x64 Ubuntu arm)
2) Add 'no_tiered_compilation' jit stress job logically the non-tiered variant of the current 'normal' job
   - This job has the same periodic schedule as other jit stress jobs
3) Add 'r2r_no_tiered_compilation' r2r stress job logically the non-tiered variant of the current 'r2r' job
   - This job has the same periodic schedule as other r2r stress jobs

Misc adjustments:
a) Added isPri0TestScenario because 'innerloop' is no longer the only scenario name which has this property + eliminated various comments that implied 'innerloop' IFF pri0
b) updated the contxtString generation for arm jobs to make it more consistent with the naming computed for other architectures

This is a continuation of the work that started in #18828</Description>
    <Title_Description>Add no tiered compilation test jobs With the upcoming switch to make tiered compilation on by default we want to preserve some JIT testing that will not enable tiered compilation.
1) Add 'no_tiered_compilation_pri0' jit stress job logically the non-tiered variant of current 'Innerloop' jobs
   - This job runs on all PRs for Checked x (Windows x86 Windows x64 Ubuntu arm)
2) Add 'no_tiered_compilation' jit stress job logically the non-tiered variant of the current 'normal' job
   - This job has the same periodic schedule as other jit stress jobs
3) Add 'r2r_no_tiered_compilation' r2r stress job logically the non-tiered variant of the current 'r2r' job
   - This job has the same periodic schedule as other r2r stress jobs

Misc adjustments:
a) Added isPri0TestScenario because 'innerloop' is no longer the only scenario name which has this property + eliminated various comments that implied 'innerloop' IFF pri0
b) updated the contxtString generation for arm jobs to make it more consistent with the naming computed for other architectures

This is a continuation of the work that started in #18828</Title_Description>
    <Label>area-TieredCompilation</Label>
    <Assignee>kouvel</Assignee>
    <CreatedAt>11/07/2018 4:31:44 AM +00:00</CreatedAt>
    <ClosedAt>16/07/2018 8:48:38 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18863</IssueLabelID>
    <Title>JIT Hints- Parameter conditional inlining directives or improve call-site inlining of funcs with constant args feeding structs</Title>
    <Description>In dotnet/corefx#30934 we have this code:

 to give more nuance to the JIT hints.

category:cq
theme:inlining
skill-level:expert
cost:extra-large</Description>
    <Title_Description>JIT Hints- Parameter conditional inlining directives, or, improve call-site inlining of funcs with constant args feeding structs In dotnet/corefx#30934 we have this code:

 to give more nuance to the JIT hints.

category:cq
theme:inlining
skill-level:expert
cost:extra-large</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
    <CreatedAt>11/07/2018 4:24:06 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18859</IssueLabelID>
    <Title>GS cookie check fix for debugger stackwalks port</Title>
    <Description>This bug fix is a port from the equivalent fix in framework. The debugger tried performing a stackwalk in the epilog due to the JIT incorrectly reporting epilogue information. This caused an invalid GS cookie to be checked and caused the debugger to crash. A flag was added to allow debug stackwalks to skip the cookie check.

@noahfalk @sbomer</Description>
    <Title_Description>GS cookie check fix for debugger stackwalks port This bug fix is a port from the equivalent fix in framework. The debugger tried performing a stackwalk in the epilog due to the JIT incorrectly reporting epilogue information. This caused an invalid GS cookie to be checked and caused the debugger to crash. A flag was added to allow debug stackwalks to skip the cookie check.

@noahfalk @sbomer</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>hoyosjs</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18858</IssueLabelID>
    <Title>[OSX] JIT/HardwareIntrinsics/X86/Avx/Avx_ro Intermittent failures</Title>
    <Description>The following test failure

happened in different PRs over the last couple days
https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_checked_osx10.12_innerloop_tst_prtest/4002/
https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_checked_osx10.12_innerloop_tst_prtest/4019/
https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_checked_osx10.12_innerloop_tst_prtest/4020/
https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_checked_osx10.12_innerloop_tst_prtest/4021/
https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_checked_osx10.12_innerloop_tst_prtest/4025/

The earlies I could track it was [Build #4002 (Jul 9 2018 8:10:43 PM)](https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_checked_osx10.12_innerloop_tst_prtest/4002/)


Seems that problem always occurs right after *Running Extract.Byte.1 test...* message</Description>
    <Title_Description>[OSX] JIT/HardwareIntrinsics/X86/Avx/Avx_ro Intermittent failures The following test failure

happened in different PRs over the last couple days
https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_checked_osx10.12_innerloop_tst_prtest/4002/
https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_checked_osx10.12_innerloop_tst_prtest/4019/
https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_checked_osx10.12_innerloop_tst_prtest/4020/
https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_checked_osx10.12_innerloop_tst_prtest/4021/
https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_checked_osx10.12_innerloop_tst_prtest/4025/

The earlies I could track it was [Build #4002 (Jul 9 2018 8:10:43 PM)](https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_checked_osx10.12_innerloop_tst_prtest/4002/)


Seems that problem always occurs right after *Running Extract.Byte.1 test...* message</Title_Description>
    <Label>arch-x64</Label>
    <Assignee>echesakovMSFT</Assignee>
    <CreatedAt>10/07/2018 9:26:24 PM +00:00</CreatedAt>
    <ClosedAt>20/07/2018 6:40:30 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18855</IssueLabelID>
    <Title>The `perf.groovy` script is not escaping the PR title properly when it contains double-quotes</Title>
    <Description>This issue was causing failures in https://github.com/dotnet/coreclr/pull/18849

For example: https://ci2.dot.net/job/dotnet_coreclr/job/perf/job/master/job/perf_perflab_Windows_NT_x64_min_opt_ryujit_smoketest_prtest/2556/</Description>
    <Title_Description>The  script is not escaping the PR title properly when it contains double-quotes This issue was causing failures in https://github.com/dotnet/coreclr/pull/18849

For example: https://ci2.dot.net/job/dotnet_coreclr/job/perf/job/master/job/perf_perflab_Windows_NT_x64_min_opt_ryujit_smoketest_prtest/2556/</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>jorive</Assignee>
    <CreatedAt>10/07/2018 7:52:34 PM +00:00</CreatedAt>
    <ClosedAt>23/05/2019 9:36:22 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18852</IssueLabelID>
    <Title>coreclr Windows build broken in master branch with several compiler errors and MASM warnings</Title>
    <Description>Build of coreclr master branch dab0d7108e8b0091e1d7f526cab7dc9bcb71710a on Windows 10 x64 for Windows_NT x64 Checked target fails with the following errors:


Windows 10 Pro x64 PL with EN lang pack active version 1803</Description>
    <Title_Description>coreclr Windows build broken in master branch with several compiler errors and MASM warnings Build of coreclr master branch dab0d7108e8b0091e1d7f526cab7dc9bcb71710a on Windows 10 x64 for Windows_NT x64 Checked target fails with the following errors:


Windows 10 Pro x64 PL with EN lang pack active version 1803</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>10/07/2018 4:29:29 PM +00:00</CreatedAt>
    <ClosedAt>10/07/2018 9:16:31 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18850</IssueLabelID>
    <Title>Invalid value numbering when morphing casts that change signedness after global morph</Title>
    <Description>The example is


Details here: https://github.com/dotnet/coreclr/pull/18816#issuecomment-403649790</Description>
    <Title_Description>Invalid value numbering when morphing casts that change signedness after global morph The example is


Details here: https://github.com/dotnet/coreclr/pull/18816#issuecomment-403649790</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>erozenfeld</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18847</IssueLabelID>
    <Title>Failed to initialize CoreCLR HRESULT: 0x80131500 (Ubuntu 18.04)</Title>
    <Description>Error: 
[logfile.txt](https://github.com/dotnet/coreclr/files/2178758/logfile.txt)

Thanks.

# OS
No LSB modules are available.
Distributor ID:	Ubuntu
Description:	Ubuntu 18.04 LTS
Release:	18.04
Codename:	bionic
</Description>
    <Title_Description>Failed to initialize CoreCLR, HRESULT: 0x80131500 (Ubuntu 18.04) Error: 
[logfile.txt](https://github.com/dotnet/coreclr/files/2178758/logfile.txt)

Thanks.

# OS
No LSB modules are available.
Distributor ID:	Ubuntu
Description:	Ubuntu 18.04 LTS
Release:	18.04
Codename:	bionic
</Title_Description>
    <Label>os-linux</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>10/07/2018 3:49:31 AM +00:00</CreatedAt>
    <ClosedAt>12/07/2018 4:16:01 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18846</IssueLabelID>
    <Title>An assembly specified in the application dependencies manifest (Example.deps.json) was not found</Title>
    <Description>I am developing a web application using Asp.NET Core 2.1 on Visual Studio 17.7 the problem is when I publish the web app as a Framework-Dependent and I try to run the app on production machine I get this error message:



and I have also tried solutions in this github issue with no success:

https://github.com/dotnet/coreclr/issues/13542</Description>
    <Title_Description>An assembly specified in the application dependencies manifest (Example.deps.json) was not found I am developing a web application using Asp.NET Core 2.1 on Visual Studio 17.7 the problem is when I publish the web app as a Framework-Dependent and I try to run the app on production machine I get this error message:



and I have also tried solutions in this github issue with no success:

https://github.com/dotnet/coreclr/issues/13542</Title_Description>
    <Label>area-AssemblyLoader</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>10/07/2018 3:47:55 AM +00:00</CreatedAt>
    <ClosedAt>11/07/2018 4:40:08 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18843</IssueLabelID>
    <Title>Basic .NET client tests</Title>
    <Description>Adding basic testing for .NET client testing. see #18673. 

Removes some placeholder activation tests that will be added back in another PR.
Creates new native COM server - contract generated manually via TlbExp. See accompanying readme.md.
Creates a .NET client that tests marshaling of primitives (i.e. byte int array strings etc.)

Tests are only for Windows.
</Description>
    <Title_Description>Basic .NET client tests Adding basic testing for .NET client testing. see #18673. 

Removes some placeholder activation tests that will be added back in another PR.
Creates new native COM server - contract generated manually via TlbExp. See accompanying readme.md.
Creates a .NET client that tests marshaling of primitives (i.e. byte int array strings etc.)

Tests are only for Windows.
</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18842</IssueLabelID>
    <Title>Array bounds check is not eliminated if index passed by reference</Title>
    <Description>The x64 code generated for FastJsonParser.ReadNull using .NET Core v2.1.301 SDK generate following assembly instruction which include two almost identical array bound checks. If I modify program to pass offset parameter by value (not functionally correct) it will eliminate one of array bound checks correctly.



category:cq
theme:range-check
skill-level:expert
cost:medium</Description>
    <Title_Description>Array bounds check is not eliminated if index passed by reference The x64 code generated for FastJsonParser.ReadNull using .NET Core v2.1.301 SDK generate following assembly instruction which include two almost identical array bound checks. If I modify program to pass offset parameter by value (not functionally correct) it will eliminate one of array bound checks correctly.



category:cq
theme:range-check
skill-level:expert
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>9/07/2018 11:21:18 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18841</IssueLabelID>
    <Title>Add Utf8String class</Title>
    <Description>
    </Description>
    <Title_Description>Add Utf8String class </Title_Description>
    <Label>area-System.Runtime</Label>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18842</IssueLabelID>
    <Title>Array bounds check is not eliminated if index passed by reference</Title>
    <Description>The x64 code generated for FastJsonParser.ReadNull using .NET Core v2.1.301 SDK generate following assembly instruction which include two almost identical array bound checks. If I modify program to pass offset parameter by value (not functionally correct) it will eliminate one of array bound checks correctly.



category:cq
theme:range-check
skill-level:expert
cost:medium</Description>
    <Title_Description>Array bounds check is not eliminated if index passed by reference The x64 code generated for FastJsonParser.ReadNull using .NET Core v2.1.301 SDK generate following assembly instruction which include two almost identical array bound checks. If I modify program to pass offset parameter by value (not functionally correct) it will eliminate one of array bound checks correctly.



category:cq
theme:range-check
skill-level:expert
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>9/07/2018 11:21:18 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18841</IssueLabelID>
    <Title>Add Utf8String class</Title>
    <Description>
    </Description>
    <Title_Description>Add Utf8String class </Title_Description>
    <Label>area-System.Runtime</Label>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18842</IssueLabelID>
    <Title>Array bounds check is not eliminated if index passed by reference</Title>
    <Description>The x64 code generated for FastJsonParser.ReadNull using .NET Core v2.1.301 SDK generate following assembly instruction which include two almost identical array bound checks. If I modify program to pass offset parameter by value (not functionally correct) it will eliminate one of array bound checks correctly.



category:cq
theme:range-check
skill-level:expert
cost:medium</Description>
    <Title_Description>Array bounds check is not eliminated if index passed by reference The x64 code generated for FastJsonParser.ReadNull using .NET Core v2.1.301 SDK generate following assembly instruction which include two almost identical array bound checks. If I modify program to pass offset parameter by value (not functionally correct) it will eliminate one of array bound checks correctly.



category:cq
theme:range-check
skill-level:expert
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>9/07/2018 11:21:18 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18841</IssueLabelID>
    <Title>Add Utf8String class</Title>
    <Description>
    </Description>
    <Title_Description>Add Utf8String class </Title_Description>
    <Label>area-System.Runtime</Label>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18836</IssueLabelID>
    <Title>Consider adding a stress mode which prefers registers with different encoding characteristics</Title>
    <Description>On various architecturesthere exist registers that require different encoding characteristics. For example on x64 there are additional registers available () which require the use of the REX prefix (or a VEX-encoded instruction).

Given that these change how the instruction is encoded it would be beneficial if there was a stress-mode that would prefer these registers in order to help validate that the emitter has them properly handled.

category:testing
theme:emitter
skill-level:beginner
cost:small</Description>
    <Title_Description>Consider adding a stress mode which prefers registers with different encoding characteristics On various architecturesthere exist registers that require different encoding characteristics. For example on x64 there are additional registers available () which require the use of the REX prefix (or a VEX-encoded instruction).

Given that these change how the instruction is encoded it would be beneficial if there was a stress-mode that would prefer these registers in order to help validate that the emitter has them properly handled.

category:testing
theme:emitter
skill-level:beginner
cost:small</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
    <CreatedAt>9/07/2018 7:38:20 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18834</IssueLabelID>
    <Title>[WIP] Test build tools used in master</Title>
    <Description>
    </Description>
    <Title_Description>[WIP] Test build tools used in master </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>9/07/2018 6:09:38 PM +00:00</CreatedAt>
    <ClosedAt>7/08/2018 12:10:19 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18833</IssueLabelID>
    <Title>Fix serialization type in NotFiniteNumberException</Title>
    <Description>Good news: This is the only serializable type that passes a different type than the value's type in.
Bad news: No bad news today :)</Description>
    <Title_Description>Fix serialization type in NotFiniteNumberException Good news: This is the only serializable type that passes a different type than the value's type in.
Bad news: No bad news today :)</Title_Description>
    <Label>area-System.Runtime</Label>
    <Assignee>ViktorHofer</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18831</IssueLabelID>
    <Title>HW intrinsics - PopCount() returns int/long while Leading/TrailingZeroCount() returns uint/ulong</Title>
    <Description>Is this difference in return type by design?
Also  when one has to shift the result obtained from 256-bit vector right for some reason</Description>
    <Title_Description>HW intrinsics - PopCount() returns int/long, while Leading/TrailingZeroCount() returns uint/ulong Is this difference in return type by design?
Also  when one has to shift the result obtained from 256-bit vector right for some reason</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>9/07/2018 8:21:28 AM +00:00</CreatedAt>
    <ClosedAt>17/09/2018 8:54:42 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18829</IssueLabelID>
    <Title>[JIT] Redundant Span&lt;&gt; bounds check not elided for fields in ref structs</Title>
    <Description>From my review of various issues around bounds checks the length check here should be sufficient to elide the span's bounds check:


category:cq
theme:bounds-checks
skill-level:expert
cost:medium</Description>
    <Title_Description>[JIT] Redundant Span&lt;&gt; bounds check not elided for fields in ref structs From my review of various issues around bounds checks the length check here should be sufficient to elide the span's bounds check:


category:cq
theme:bounds-checks
skill-level:expert
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>9/07/2018 1:17:08 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18827</IssueLabelID>
    <Title>Debugging Linux Apps - Dump Analysis Clarification</Title>
    <Description>I have hanging app on linux and was attempting to get take a memory dump... upon reading the docs for memory dump analysis I found nothing talking about mention **hung** **deadlocks** or **memory leaks**: they are mostly geared to crash analysis.

the way i see it there are 2 types of dumps: 
1. Crash (created by operating system/debugger event) for crash analysis
2. Live / On Demand (created by user) for memory lock hang analysis

I think this link needs to be updated to at least mention the second category of memory dump analysis is also possible  (and any deviation in steps required)

https://github.com/dotnet/coreclr/blob/master/Documentation/building/debugging-instructions.md

Example text from above link that should be modified:

 ?

The current wording seems to imply a 'separate utility' - but I can't find it in the (linux/arm) sdk

According to the following links it seems that it might be a seprate util or part of sos?

(Command Line Options)?
https://github.com/dotnet/coreclr/blob/master/Documentation/botr/xplat-minidump-generation.md

(SOS Plugin Command?)
https://github.com/dotnet/coreclr/blob/master/Documentation/building/debugging-instructions.md

Please Clarify the following:

1. Are dumps only able to be analyzed if they are created via lldb + sos ? 
2. What is 'create dump' utility and where is it?  (contradictory docs)
3. Update the above linked docs since they seem have no mention that memory dumps from 'live' processes are supported.
4. a quick how to guide for creating a dump of a live process would be nice if the steps vastly are different from crash dump analysis.

regarding item 1 - I attempted to create memory dumps using 'gcore' and load them in lldb but this just caused lldb to crash so i posted a bug with lldb and sought guidance on coreclr glitter for more input  

@karelz - also sent me the links above but I if you read my above notes: I think more clarity is needed to deal with the second class of dumps that I want to analyze on linux/arm hardware.



</Description>
    <Title_Description>Debugging Linux Apps - Dump Analysis Clarification I have hanging app on linux and was attempting to get take a memory dump... upon reading the docs for memory dump analysis I found nothing talking about mention **hung** **deadlocks** or **memory leaks**: they are mostly geared to crash analysis.

the way i see it there are 2 types of dumps: 
1. Crash (created by operating system/debugger event) for crash analysis
2. Live / On Demand (created by user) for memory lock hang analysis

I think this link needs to be updated to at least mention the second category of memory dump analysis is also possible  (and any deviation in steps required)

https://github.com/dotnet/coreclr/blob/master/Documentation/building/debugging-instructions.md

Example text from above link that should be modified:

 ?

The current wording seems to imply a 'separate utility' - but I can't find it in the (linux/arm) sdk

According to the following links it seems that it might be a seprate util or part of sos?

(Command Line Options)?
https://github.com/dotnet/coreclr/blob/master/Documentation/botr/xplat-minidump-generation.md

(SOS Plugin Command?)
https://github.com/dotnet/coreclr/blob/master/Documentation/building/debugging-instructions.md

Please Clarify the following:

1. Are dumps only able to be analyzed if they are created via lldb + sos ? 
2. What is 'create dump' utility and where is it?  (contradictory docs)
3. Update the above linked docs since they seem have no mention that memory dumps from 'live' processes are supported.
4. a quick how to guide for creating a dump of a live process would be nice if the steps vastly are different from crash dump analysis.

regarding item 1 - I attempted to create memory dumps using 'gcore' and load them in lldb but this just caused lldb to crash so i posted a bug with lldb and sought guidance on coreclr glitter for more input  

@karelz - also sent me the links above but I if you read my above notes: I think more clarity is needed to deal with the second class of dumps that I want to analyze on linux/arm hardware.



</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>karelz</Assignee>
    <CreatedAt>8/07/2018 8:46:06 PM +00:00</CreatedAt>
    <ClosedAt>22/02/2019 10:48:46 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18826</IssueLabelID>
    <Title>LastIndexOf corner case fix when span is empty</Title>
    <Description>Fixes https://github.com/dotnet/corefx/pull/30896#discussion_r200843575

Thanks for spotting! I shouldn't have rushed fixing the initial issue.</Description>
    <Title_Description>LastIndexOf corner case fix when span is empty Fixes https://github.com/dotnet/corefx/pull/30896#discussion_r200843575

Thanks for spotting! I shouldn't have rushed fixing the initial issue.</Title_Description>
    <Label>area-System.Memory</Label>
    <Assignee>ViktorHofer</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18824</IssueLabelID>
    <Title>BinaryReader should also accept String as path filename for contructor</Title>
    <Description>Hello

following same comparison of 

Kind regards



https://github.com/dotnet/coreclr/blob/0fbd855e38bc3ec269479b5f6bf561dcfd67cbb6/src/System.Private.CoreLib/shared/System/IO/StreamReader.cs#L170

https://github.com/dotnet/coreclr/blob/26d4004e90f47036d6393222522cf529aa41c6bb/src/mscorlib/src/System/IO/BinaryReader.cs#L49

same for writer

https://github.com/dotnet/coreclr/blob/0fbd855e38bc3ec269479b5f6bf561dcfd67cbb6/src/System.Private.CoreLib/shared/System/IO/StreamWriter.cs#L132

https://github.com/dotnet/coreclr/blob/0fbd855e38bc3ec269479b5f6bf561dcfd67cbb6/src/System.Private.CoreLib/shared/System/IO/BinaryWriter.cs#L50</Description>
    <Title_Description>BinaryReader should also accept String as path filename for contructor Hello

following same comparison of 

Kind regards



https://github.com/dotnet/coreclr/blob/0fbd855e38bc3ec269479b5f6bf561dcfd67cbb6/src/System.Private.CoreLib/shared/System/IO/StreamReader.cs#L170

https://github.com/dotnet/coreclr/blob/26d4004e90f47036d6393222522cf529aa41c6bb/src/mscorlib/src/System/IO/BinaryReader.cs#L49

same for writer

https://github.com/dotnet/coreclr/blob/0fbd855e38bc3ec269479b5f6bf561dcfd67cbb6/src/System.Private.CoreLib/shared/System/IO/StreamWriter.cs#L132

https://github.com/dotnet/coreclr/blob/0fbd855e38bc3ec269479b5f6bf561dcfd67cbb6/src/System.Private.CoreLib/shared/System/IO/BinaryWriter.cs#L50</Title_Description>
    <Label>area-System.IO</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>7/07/2018 7:25:12 PM +00:00</CreatedAt>
    <ClosedAt>10/07/2018 8:36:03 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18823</IssueLabelID>
    <Title>Add EndOfStream property to BinaryReader</Title>
    <Description>Hello

I'm comparing saving/reading data using either 

Kind regards</Description>
    <Title_Description>Add EndOfStream property to BinaryReader Hello

I'm comparing saving/reading data using either 

Kind regards</Title_Description>
    <Label>area-System.IO</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>7/07/2018 7:23:11 PM +00:00</CreatedAt>
    <ClosedAt>10/07/2018 8:57:21 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18822</IssueLabelID>
    <Title>[RyuJIT] Seeing suboptimal codegen for various AVX HWIntrinsics</Title>
    <Description>The Windows calling convention marks the upper 128-bits of YMM6 through YMM15 as volatile/caller preserved. This can cause codegen issues when using 256-bit HWIntrinsics that are interspersed with other calls as the JIT must currently insert code to save/restore the upper bits.

It may be possible for the JIT to do something "smart" here to allow eliding the save/restore when the target call would not touch the registers.
* An example would be a general flag that indicates whether the method being called uses any XMM register which would allow the JIT to elide the save/restore entirely in some cases.
* A more complex example would be tracking individual XMM registers used.

However the JIT doing something "smart" may be expensive. This is also a case where simply refactoring the code may vastly improve codegen (if the calls can be made to no longer be interspersed). As such an analyzer may be able to help catch these cases as would profiling.

An example of this problem is the following code snippet:
* NOTE: This probably doesn't represent real world code where you would likely be operating on an entire array. A real world example of interspersed calls would likely involve helper methods that abstracts away the ARM vs x86 differences and which themselves use other hardware intrinsics


&lt;/details&gt;

category:cq
theme:vector-codegen
skill-level:expert
cost:large</Description>
    <Title_Description>[RyuJIT] Seeing suboptimal codegen for various AVX HWIntrinsics The Windows calling convention marks the upper 128-bits of YMM6 through YMM15 as volatile/caller preserved. This can cause codegen issues when using 256-bit HWIntrinsics that are interspersed with other calls as the JIT must currently insert code to save/restore the upper bits.

It may be possible for the JIT to do something "smart" here to allow eliding the save/restore when the target call would not touch the registers.
* An example would be a general flag that indicates whether the method being called uses any XMM register which would allow the JIT to elide the save/restore entirely in some cases.
* A more complex example would be tracking individual XMM registers used.

However the JIT doing something "smart" may be expensive. This is also a case where simply refactoring the code may vastly improve codegen (if the calls can be made to no longer be interspersed). As such an analyzer may be able to help catch these cases as would profiling.

An example of this problem is the following code snippet:
* NOTE: This probably doesn't represent real world code where you would likely be operating on an entire array. A real world example of interspersed calls would likely involve helper methods that abstracts away the ARM vs x86 differences and which themselves use other hardware intrinsics


&lt;/details&gt;

category:cq
theme:vector-codegen
skill-level:expert
cost:large</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
    <CreatedAt>7/07/2018 6:58:44 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18815</IssueLabelID>
    <Title>[RyuJIT] Assert failure "unexpected operand size" when folding LCL_FLD into Avx.BlendVariable </Title>
    <Description>The assert failture happens


This bug is detected in the work of https://github.com/dotnet/coreclr/issues/17798 and .NET Core 2.1 works fine so it seems introduced by the recent containment change.

@tannergooding @CarolEidt </Description>
    <Title_Description>[RyuJIT] Assert failure "unexpected operand size" when folding LCL_FLD into Avx.BlendVariable  The assert failture happens


This bug is detected in the work of https://github.com/dotnet/coreclr/issues/17798 and .NET Core 2.1 works fine so it seems introduced by the recent containment change.

@tannergooding @CarolEidt </Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>tannergooding</Assignee>
    <CreatedAt>6/07/2018 11:45:37 PM +00:00</CreatedAt>
    <ClosedAt>10/07/2018 9:34:13 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18810</IssueLabelID>
    <Title>Allow test projects to be SDK style</Title>
    <Description>This change updates the associated targets and props files in the test directory to allow the test csproj's to be built as SDK style projects alongside traditional style projects.

It does not yet upgrade any of the projects I'll submit a seperate batch of PRs for that so that these changes aren't lost in a ton of mechanical refactoring.

While these changes allow the csproj's to be upgraded there is still work to be done to allow depproj and ilproj's to be converted over to the new style. By allowing a mix of projects styles this change allows us to upgrade piece-meal rather than in a single big bang hopefully allowing us to easier figure out bugs if they arise. 

- Remove CodeTaskFactory:
  - Allows the projects to be built using the core version of msbuild/dotnet build
  - Converted to using msbuild property expansion instead
- Add directory.build.{propstargets}:
  - Currently we just import the dirs.props and targets but means SDK style projects don't need to explicitly include these files
   - We probably want to move all projects over to using these in the future but this keeps the changes smaller for now
- Specific code for SDK projects:
  - There are a several changes required to build an SDK project. This change guards them behind conditionals so that only the new style projects see them. When we get to the point that there are only new projects we can remove the guards (probably at the same time as ditching the dir.props)
- Reordered build targets:
  - Because SDK projects implicitly import the build targets we can no longer re-define the build targets unconditionally knowing they will likely be overwritten. 
  - Instead we move the overwritten targets to seperate files and include these conditionally based on properties. In this way there is always a build defined for SDK projects which can then be overwritten to do nothing as needed.</Description>
    <Title_Description>Allow test projects to be SDK style This change updates the associated targets and props files in the test directory to allow the test csproj's to be built as SDK style projects alongside traditional style projects.

It does not yet upgrade any of the projects I'll submit a seperate batch of PRs for that so that these changes aren't lost in a ton of mechanical refactoring.

While these changes allow the csproj's to be upgraded there is still work to be done to allow depproj and ilproj's to be converted over to the new style. By allowing a mix of projects styles this change allows us to upgrade piece-meal rather than in a single big bang hopefully allowing us to easier figure out bugs if they arise. 

- Remove CodeTaskFactory:
  - Allows the projects to be built using the core version of msbuild/dotnet build
  - Converted to using msbuild property expansion instead
- Add directory.build.{propstargets}:
  - Currently we just import the dirs.props and targets but means SDK style projects don't need to explicitly include these files
   - We probably want to move all projects over to using these in the future but this keeps the changes smaller for now
- Specific code for SDK projects:
  - There are a several changes required to build an SDK project. This change guards them behind conditionals so that only the new style projects see them. When we get to the point that there are only new projects we can remove the guards (probably at the same time as ditching the dir.props)
- Reordered build targets:
  - Because SDK projects implicitly import the build targets we can no longer re-define the build targets unconditionally knowing they will likely be overwritten. 
  - Instead we move the overwritten targets to seperate files and include these conditionally based on properties. In this way there is always a build defined for SDK projects which can then be overwritten to do nothing as needed.</Title_Description>
    <Label>test enhancement</Label>
    <Assignee>chsienki</Assignee>
    <CreatedAt>6/07/2018 7:11:35 PM +00:00</CreatedAt>
    <ClosedAt>19/07/2018 9:35:04 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18809</IssueLabelID>
    <Title>Correct AssemblyLoadContext comment</Title>
    <Description>- This existing comment appears to be incorrectly narrow.
- My testing validates this.</Description>
    <Title_Description>Correct AssemblyLoadContext comment - This existing comment appears to be incorrectly narrow.
- My testing validates this.</Title_Description>
    <Label>area-AssemblyLoader</Label>
    <Assignee>jeffschwMSFT</Assignee>
    <CreatedAt>6/07/2018 6:56:04 PM +00:00</CreatedAt>
    <ClosedAt>8/07/2018 9:56:42 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18807</IssueLabelID>
    <Title>Remove System.Security.Cryptography.X509Certificates.Tests from exclusion list</Title>
    <Description>The troublesome machine  from Windows/arm tests exclusion list.

Closes #17801</Description>
    <Title_Description>Remove System.Security.Cryptography.X509Certificates.Tests from exclusion list The troublesome machine  from Windows/arm tests exclusion list.

Closes #17801</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>echesakovMSFT</Assignee>
    <CreatedAt>6/07/2018 4:30:26 PM +00:00</CreatedAt>
    <ClosedAt>13/07/2018 4:10:26 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18791</IssueLabelID>
    <Title>Update certain Marshal APIs to match exception thrown on .NET Framework</Title>
    <Description>See [corefx#30830](https://github.com/dotnet/corefx/issues/30830)</Description>
    <Title_Description>Update certain Marshal APIs to match exception thrown on .NET Framework See [corefx#30830](https://github.com/dotnet/corefx/issues/30830)</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>5/07/2018 5:30:03 PM +00:00</CreatedAt>
    <ClosedAt>5/07/2018 9:29:28 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18790</IssueLabelID>
    <Title>Enable COMPlus_GCHighMemPercent ENV</Title>
    <Description>.NET Framework exposes COMPlus_GCHighMemPercent. This enables configuration of the GC for testing and other things. It is not enabled in Core but should be. Please expose it.

I was doing testing of Docker resource limits. This ENV could be used to determine if the current GC policy for Docker resource limits could be improved. The data suggests that this is the case.

Results of Docker resource limits experiment: https://gist.github.com/richlander/48bb0ad51a2406937b61bea01de7cf87

Please enable this in both 2.2 and 3.0 branches.</Description>
    <Title_Description>Enable COMPlus_GCHighMemPercent ENV .NET Framework exposes COMPlus_GCHighMemPercent. This enables configuration of the GC for testing and other things. It is not enabled in Core but should be. Please expose it.

I was doing testing of Docker resource limits. This ENV could be used to determine if the current GC policy for Docker resource limits could be improved. The data suggests that this is the case.

Results of Docker resource limits experiment: https://gist.github.com/richlander/48bb0ad51a2406937b61bea01de7cf87

Please enable this in both 2.2 and 3.0 branches.</Title_Description>
    <Label>area-GC</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>5/07/2018 5:13:58 PM +00:00</CreatedAt>
    <ClosedAt>17/07/2018 10:13:29 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18789</IssueLabelID>
    <Title>[Arm64/Linux] runtimeeventsource fails gcStress=0x2</Title>
    <Description>@brianrob The new test runtimeeventsource introduced recently is failing gcStress=0x2 consistently.  It also fails gcStress=0x1 occasionally.

Typical failure looks like this


</Description>
    <Title_Description>[Arm64/Linux] runtimeeventsource fails gcStress=0x2 @brianrob The new test runtimeeventsource introduced recently is failing gcStress=0x2 consistently.  It also fails gcStress=0x1 occasionally.

Typical failure looks like this


</Title_Description>
    <Label>area-Tracing</Label>
    <Assignee>brianrob</Assignee>
    <CreatedAt>5/07/2018 4:51:55 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18788</IssueLabelID>
    <Title>Core CLR Build-Tests definition is ignoring build failures</Title>
    <Description>There's a couple things going on here @RussKeldorph  @jashook FYI.

- ILAsm commands are (seemingly randomly) failing in the build
- Build-test.cmd does not successfully fail the VSTS Task phase it's in if it throws errors.

Build : Master - 20180705.05 (Product Build)
Failing configurations:
- Windows
  - Build-Tests-R2R-Release
[Mission Control Build Info](https://mc.dot.net/#/product/netcore/master/source/official~2Fcoreclr~2Fmaster~2F/type/build~2Fproduct~2F/build/20180705.05/workItem/Orchestration/analysis/external/Link)</Description>
    <Title_Description>Core CLR Build-Tests definition is ignoring build failures There's a couple things going on here @RussKeldorph  @jashook FYI.

- ILAsm commands are (seemingly randomly) failing in the build
- Build-test.cmd does not successfully fail the VSTS Task phase it's in if it throws errors.

Build : Master - 20180705.05 (Product Build)
Failing configurations:
- Windows
  - Build-Tests-R2R-Release
[Mission Control Build Info](https://mc.dot.net/#/product/netcore/master/source/official~2Fcoreclr~2Fmaster~2F/type/build~2Fproduct~2F/build/20180705.05/workItem/Orchestration/analysis/external/Link)</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>MattGal</Assignee>
    <CreatedAt>5/07/2018 4:42:27 PM +00:00</CreatedAt>
    <ClosedAt>6/12/2018 7:08:17 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18786</IssueLabelID>
    <Title>Sub-optimal codegen with C# `switch` statement handling for some simple cases</Title>
    <Description>The check for 


category:cq
theme:inlining
skill-level:intermediate
cost:medium</Description>
    <Title_Description>Sub-optimal codegen with C# 


category:cq
theme:inlining
skill-level:intermediate
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>5/07/2018 11:05:36 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18784</IssueLabelID>
    <Title>Add missing FlushInstructionCache to CommitGCStressInstructionUpdate</Title>
    <Description>It's my understanding that missing  and the issue is not reproducible anymore.

Fixes #17570</Description>
    <Title_Description>Add missing FlushInstructionCache to CommitGCStressInstructionUpdate It's my understanding that missing  and the issue is not reproducible anymore.

Fixes #17570</Title_Description>
    <Label>GCStress</Label>
    <Assignee>echesakovMSFT</Assignee>
    <CreatedAt>5/07/2018 3:48:42 AM +00:00</CreatedAt>
    <ClosedAt>23/07/2018 9:15:08 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18780</IssueLabelID>
    <Title>RyuJIT incorrectly narrows value on ARM32/x86 in release</Title>
    <Description>On ARM32 and x86 with .NET core 2.1 the following program prints  fixes it.</Description>
    <Title_Description>RyuJIT incorrectly narrows value on ARM32/x86 in release On ARM32 and x86 with .NET core 2.1 the following program prints  fixes it.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>jakobbotsch</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18779</IssueLabelID>
    <Title>General protection fault on Linux</Title>
    <Description>I'm running a pretty standard ASP.NET Core application in Kubernetes on the Google Cloud.  
I'm using self-contained deployment with the 

Which is expected under our current stress test but this should not cause the process to crash right?

How could I investigate what is causing this issue?</Description>
    <Title_Description>General protection fault on Linux I'm running a pretty standard ASP.NET Core application in Kubernetes on the Google Cloud.  
I'm using self-contained deployment with the 

Which is expected under our current stress test but this should not cause the process to crash right?

How could I investigate what is causing this issue?</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>mikem8361</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18777</IssueLabelID>
    <Title>JIT alloc assert "!s_pagePool.isPoolPage(page)" running corefx tests in CI</Title>
    <Description>https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_checked_windows_nt_corefx_innerloop_prtest/388/consoleText
</Description>
    <Title_Description>JIT alloc assert "!s_pagePool.isPoolPage(page)" running corefx tests in CI https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_checked_windows_nt_corefx_innerloop_prtest/388/consoleText
</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>mikedn</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18772</IssueLabelID>
    <Title>Set ActivityId and RelatedActivityId on EventWrittenEventArgs for Native Events</Title>
    <Description>
    </Description>
    <Title_Description>Set ActivityId and RelatedActivityId on EventWrittenEventArgs for Native Events </Title_Description>
    <Label>area-Tracing</Label>
    <Assignee>brianrob</Assignee>
    <CreatedAt>3/07/2018 11:04:20 PM +00:00</CreatedAt>
    <ClosedAt>1/08/2018 6:41:34 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18771</IssueLabelID>
    <Title>Improve DateTime{Offset}.ParseExact{Multiple} performance for RFC1123 ("r")</Title>
    <Description>Significantly improves the performance of 

cc: @ahsonkhan @jkotas @pjanotti @joperezr 
Contributes to https://github.com/dotnet/corefx/issues/30612</Description>
    <Title_Description>Improve DateTime{Offset}.ParseExact{Multiple} performance for RFC1123 ("r") Significantly improves the performance of 

cc: @ahsonkhan @jkotas @pjanotti @joperezr 
Contributes to https://github.com/dotnet/corefx/issues/30612</Title_Description>
    <Label>area-System.Runtime</Label>
    <Assignee>ahsonkhan</Assignee>
    <CreatedAt>3/07/2018 8:08:29 PM +00:00</CreatedAt>
    <ClosedAt>5/07/2018 1:38:06 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18770</IssueLabelID>
    <Title>RyuJIT incorrectly reorders expression containing a CSE resulting in exception thrown in release</Title>
    <Description>The following example throws 

Some more information can be found in https://github.com/dotnet/coreclr/issues/18232#issuecomment-402198147.</Description>
    <Title_Description>RyuJIT incorrectly reorders expression containing a CSE, resulting in exception thrown in release The following example throws 

Some more information can be found in https://github.com/dotnet/coreclr/issues/18232#issuecomment-402198147.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>3/07/2018 6:53:10 PM +00:00</CreatedAt>
    <ClosedAt>14/09/2018 11:58:04 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18769</IssueLabelID>
    <Title>spmi: exclude methods using a file with saved md5 hashes.</Title>
    <Description>Exclude methods are presented in a file with the same name as  length they should be separated with newlines or spaces if we find a value with incorrect length then we ignore this value.</Description>
    <Title_Description>spmi: exclude methods using a file with saved md5 hashes. Exclude methods are presented in a file with the same name as  length they should be separated with newlines or spaces if we find a value with incorrect length then we ignore this value.</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>3/07/2018 5:43:07 PM +00:00</CreatedAt>
    <ClosedAt>28/07/2018 1:44:33 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18765</IssueLabelID>
    <Title>Regression in arm64 r2r jobs.  'defList.IsEmpty()' </Title>
    <Description>Many x64_arm64_altjit_checked_windows_nt_r2r test are failing with:



The regression is caused by #18130 [ci example](https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_arm64_altjit_checked_windows_nt_r2r_prtest/13/testReport/baseservices_threading/_generics_threadstart_GThread18_GThread18_/_generics_threadstart_GThread18_GThread18_cmd/).

</Description>
    <Title_Description>Regression in arm64 r2r jobs.  'defList.IsEmpty()'  Many x64_arm64_altjit_checked_windows_nt_r2r test are failing with:



The regression is caused by #18130 [ci example](https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_arm64_altjit_checked_windows_nt_r2r_prtest/13/testReport/baseservices_threading/_generics_threadstart_GThread18_GThread18_/_generics_threadstart_GThread18_GThread18_cmd/).

</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18764</IssueLabelID>
    <Title>add missing files to package properly on FreeBSD</Title>
    <Description>This is my best guess based on existing Linux and OSX files. 
It creates missing packages expected by core-setup.</Description>
    <Title_Description>add missing files to package properly on FreeBSD This is my best guess based on existing Linux and OSX files. 
It creates missing packages expected by core-setup.</Title_Description>
    <Label>os-freebsd</Label>
    <Assignee>wfurt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18762</IssueLabelID>
    <Title>Enable profiler attach on Windows</Title>
    <Description>This is an ongoing work to enable profiler attach on CoreCLR. This PR enables the profiler attach feature on Windows. I am in process of working on Unix port. </Description>
    <Title_Description>Enable profiler attach on Windows This is an ongoing work to enable profiler attach on CoreCLR. This PR enables the profiler attach feature on Windows. I am in process of working on Unix port. </Title_Description>
    <Label>
    </Label>
    <Assignee>sywhang</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18759</IssueLabelID>
    <Title>Expose Thread ID and TimeStamp on EventWrittenEventArgs</Title>
    <Description>Historically these could always be fetched when the event was dispatched because EventSource does direct dispatch in real-time.  However now that EventPipe can dispatch to EventListeners the Thread ID and TimeStamp aren't known for these events and needs to be plumbed through.</Description>
    <Title_Description>Expose Thread ID and TimeStamp on EventWrittenEventArgs Historically these could always be fetched when the event was dispatched because EventSource does direct dispatch in real-time.  However now that EventPipe can dispatch to EventListeners the Thread ID and TimeStamp aren't known for these events and needs to be plumbed through.</Title_Description>
    <Label>area-Tracing</Label>
    <Assignee>brianrob</Assignee>
    <CreatedAt>2/07/2018 10:14:55 PM +00:00</CreatedAt>
    <ClosedAt>3/08/2018 6:04:53 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18758</IssueLabelID>
    <Title>Implement Efficient Dispatch Polling Mechanism for EventPipe</Title>
    <Description>Context: https://github.com/dotnet/coreclr/pull/18649#discussion_r199631486

We should consider replacing the polling loop when there are no new events with an AutoResetEvent to ensure that the CPU can go quiescent when there are no events.</Description>
    <Title_Description>Implement Efficient Dispatch Polling Mechanism for EventPipe Context: https://github.com/dotnet/coreclr/pull/18649#discussion_r199631486

We should consider replacing the polling loop when there are no new events with an AutoResetEvent to ensure that the CPU can go quiescent when there are no events.</Title_Description>
    <Label>EventPipe</Label>
    <Assignee>davmason</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18756</IssueLabelID>
    <Title>Port perf infrastructure to Azure Pipelines</Title>
    <Description>
    </Description>
    <Title_Description>Port perf infrastructure to Azure Pipelines </Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>billwert</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18755</IssueLabelID>
    <Title>Support Tracing and EventListener Dispatch Concurrently in EventPipe</Title>
    <Description>Right now it's only possible to do one of the following at any given time:

 - Collect a trace using EventPipe.
 - Dispatch events to EventListener.

This issue tracks making it possible to do these concurrently.</Description>
    <Title_Description>Support Tracing and EventListener Dispatch Concurrently in EventPipe Right now it's only possible to do one of the following at any given time:

 - Collect a trace using EventPipe.
 - Dispatch events to EventListener.

This issue tracks making it possible to do these concurrently.</Title_Description>
    <Label>EventPipe</Label>
    <Assignee>brianrob</Assignee>
    <CreatedAt>2/07/2018 8:49:08 PM +00:00</CreatedAt>
    <ClosedAt>15/04/2019 5:43:38 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18754</IssueLabelID>
    <Title>Implement Efficient EventPipeBuffer Reading in Managed Code</Title>
    <Description>EventPipeBuffers can be read when EventListener consumes events from EventPipe.  Right now this is done with a pinvoke per event.  This issue tracks improving this scheme.</Description>
    <Title_Description>Implement Efficient EventPipeBuffer Reading in Managed Code EventPipeBuffers can be read when EventListener consumes events from EventPipe.  Right now this is done with a pinvoke per event.  This issue tracks improving this scheme.</Title_Description>
    <Label>EventPipe</Label>
    <Assignee>brianrob</Assignee>
    <CreatedAt>2/07/2018 8:46:45 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18752</IssueLabelID>
    <Title>Merge EventPipePayloadDecoder.DecodePayload and EventProvider.DecodeObject</Title>
    <Description>There are two event decoder paths in EventSource.  We should look to merge them.</Description>
    <Title_Description>Merge EventPipePayloadDecoder.DecodePayload and EventProvider.DecodeObject There are two event decoder paths in EventSource.  We should look to merge them.</Title_Description>
    <Label>EventPipe</Label>
    <Assignee>sywhang</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18748</IssueLabelID>
    <Title>RyuJIT sometimes drops volatile reads</Title>
    <Description>Morph issue:
?!

category:correctness
theme:volatile
skill-level:expert
cost:large</Description>
    <Title_Description>RyuJIT sometimes drops volatile reads Morph issue:
?!

category:correctness
theme:volatile
skill-level:expert
cost:large</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>2/07/2018 7:32:28 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18746</IssueLabelID>
    <Title>regressions in arm64_altjit r2r jobs: temp != nullptr</Title>
    <Description>Some tests are failing after #18346 for example [b393481](https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_arm64_altjit_checked_windows_nt_r2r_prtest/12/testReport/junit/JIT_Regression/_CLR_x86_JIT_dev10_b393481_b393481_b393481_/_CLR_x86_JIT_dev10_b393481_b393481_b393481_cmd/) fails with .</Description>
    <Title_Description>regressions in arm64_altjit r2r jobs: temp != nullptr Some tests are failing after #18346 for example [b393481](https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_arm64_altjit_checked_windows_nt_r2r_prtest/12/testReport/junit/JIT_Regression/_CLR_x86_JIT_dev10_b393481_b393481_b393481_/_CLR_x86_JIT_dev10_b393481_b393481_b393481_cmd/) fails with .</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18744</IssueLabelID>
    <Title>Determine how to expose hwintrinsics that are only supported in 64-bit mode</Title>
    <Description>There are several hwintrinsics exposed that are only emittable in 64-bit mode and throw a PNSE exception if invoked in 32-bit mode (regardless of the fact that the general  check returns true).

We should have a deeper discussion on how to properly expose this data to the consumer of these APIs.</Description>
    <Title_Description>Determine how to expose hwintrinsics that are only supported in 64-bit mode There are several hwintrinsics exposed that are only emittable in 64-bit mode and throw a PNSE exception if invoked in 32-bit mode (regardless of the fact that the general  check returns true).

We should have a deeper discussion on how to properly expose this data to the consumer of these APIs.</Title_Description>
    <Label>Design Discussion</Label>
    <Assignee>CarolEidt</Assignee>
    <CreatedAt>2/07/2018 4:57:21 PM +00:00</CreatedAt>
    <ClosedAt>9/11/2018 4:35:39 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18743</IssueLabelID>
    <Title>Ensure that the indirect call fallback for HWIntrinsics executes the same instructions as the inlined version</Title>
    <Description>There are a few ) which are emitting a managed software implementation rather than a switch table fallback.

These should be updated to use the switch table fallback instead.</Description>
    <Title_Description>Ensure that the indirect call fallback for HWIntrinsics executes the same instructions as the inlined version There are a few ) which are emitting a managed software implementation rather than a switch table fallback.

These should be updated to use the switch table fallback instead.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
    <CreatedAt>2/07/2018 4:54:51 PM +00:00</CreatedAt>
    <ClosedAt>6/12/2018 8:00:16 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18742</IssueLabelID>
    <Title>Add back DefinePInvokeMethod</Title>
    <Description>https://github.com/dotnet/corefx/issues/30355</Description>
    <Title_Description>Add back DefinePInvokeMethod https://github.com/dotnet/corefx/issues/30355 </Title_Description>
    <Label>area-System.Reflection</Label>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18741</IssueLabelID>
    <Title>Question about software protection</Title>
    <Description>There is a question about software protection. We used confusing software to compiling and then obscure the code and then deploying。we use hardware key to protection secret algorithms so that the software could be prevented from being copied. Now deployed in the container if a customer asks us to deploy a private cloud to them the file is easily copied by . Whether the container can be restricted can not be mounted or can not be copied.</Description>
    <Title_Description>Question about software protection There is a question about software protection. We used confusing software to compiling and then obscure the code and then deploying。we use hardware key to protection secret algorithms so that the software could be prevented from being copied. Now deployed in the container if a customer asks us to deploy a private cloud to them the file is easily copied by . Whether the container can be restricted can not be mounted or can not be copied.</Title_Description>
    <Label>question</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>2/07/2018 10:49:42 AM +00:00</CreatedAt>
    <ClosedAt>2/07/2018 7:00:39 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18739</IssueLabelID>
    <Title>CoreCLR Test Build Broken</Title>
    <Description>Opened on behalf of @RussKeldorph

Warnings: 1
Status Message: failed

Build : Master - 20180701.03 (Product Build)
Failing configurations:
- Alpine3.6
  - Build-Tests-R2R-Release
  - Build-Tests-Release
- RedHat6
  - Build-Tests-R2R-Release
  - Build-Tests-Release
- RedHat 7
  - Build-Tests-R2R-Release
  - Build-Tests-Release
- OSX
  - Build-Tests-R2R-Release
  - Build-Tests-Release
- Windows
  - Build-Tests-R2R-Release-arm64
  - Build-Tests-Release-arm64
  - Build-Tests-R2R-Release
  - Build-Tests-Release
[Mission Control Build Info](https://mc.dot.net/#/product/netcore/master/source/official~2Fcoreclr~2Fmaster~2F/type/build~2Fproduct~2F/build/20180701.03/workItem/Orchestration/analysis/external/Link)
</Description>
    <Title_Description>CoreCLR Test Build Broken Opened on behalf of @RussKeldorph

Warnings: 1
Status Message: failed

Build : Master - 20180701.03 (Product Build)
Failing configurations:
- Alpine3.6
  - Build-Tests-R2R-Release
  - Build-Tests-Release
- RedHat6
  - Build-Tests-R2R-Release
  - Build-Tests-Release
- RedHat 7
  - Build-Tests-R2R-Release
  - Build-Tests-Release
- OSX
  - Build-Tests-R2R-Release
  - Build-Tests-Release
- Windows
  - Build-Tests-R2R-Release-arm64
  - Build-Tests-Release-arm64
  - Build-Tests-R2R-Release
  - Build-Tests-Release
[Mission Control Build Info](https://mc.dot.net/#/product/netcore/master/source/official~2Fcoreclr~2Fmaster~2F/type/build~2Fproduct~2F/build/20180701.03/workItem/Orchestration/analysis/external/Link)
</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>A-And</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18732</IssueLabelID>
    <Title>Create package for Raspbian OS (ARM32)</Title>
    <Description>While there is a working binary download for dotnet (.NET Core) for ARM32 that works on a Raspberry Pi B 3+ with a current Raspbian OS there are no instructions how to install it. And there are no packages for the OS too. So it's a bit of a mystery how to actually make .NET Core work on a Raspi.

I think there should be a package for that OS. It should be as simple as that:

    sudo apt install dotnet

Maybe a custom package source needs to be added but definitely no manual tar file works. Mono was easier to install when it was current like 5 years ago.

Since the docker support on the Raspi with dotnet-runtime packages is very poor (multi-arch fails need to select arm32 image specifically can't get my app in a custom image) I need to install .NET Core on the Raspi OS itself.</Description>
    <Title_Description>Create package for Raspbian OS (ARM32) While there is a working binary download for dotnet (.NET Core) for ARM32 that works on a Raspberry Pi B 3+ with a current Raspbian OS there are no instructions how to install it. And there are no packages for the OS too. So it's a bit of a mystery how to actually make .NET Core work on a Raspi.

I think there should be a package for that OS. It should be as simple as that:

    sudo apt install dotnet

Maybe a custom package source needs to be added but definitely no manual tar file works. Mono was easier to install when it was current like 5 years ago.

Since the docker support on the Raspi with dotnet-runtime packages is very poor (multi-arch fails need to select arm32 image specifically can't get my app in a custom image) I need to install .NET Core on the Raspi OS itself.</Title_Description>
    <Label>
    </Label>
    <Assignee>richlander</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18727</IssueLabelID>
    <Title>JIT : PMI now failing on System.Private.CoreLib on an x64 AES intrinsic</Title>
    <Description>The x64 windows run of PMI over System.Private.Corelib is now failing when trying to jit  as this method exists in metadata and is marked as an intrinsic but the jit does not recognize it. This is relatively new (~ last few days) behavior.

Would be nice to fix this by (say) adding in the names to the recognizer and then (for now) just compiling in the not supported variant.

cc @dotnet/jit-contrib </Description>
    <Title_Description>JIT : PMI now failing on System.Private.CoreLib on an x64 AES intrinsic The x64 windows run of PMI over System.Private.Corelib is now failing when trying to jit  as this method exists in metadata and is marked as an intrinsic but the jit does not recognize it. This is relatively new (~ last few days) behavior.

Would be nice to fix this by (say) adding in the names to the recognizer and then (for now) just compiling in the not supported variant.

cc @dotnet/jit-contrib </Title_Description>
    <Label>arch-x64</Label>
    <Assignee>AndyAyersMS</Assignee>
    <CreatedAt>30/06/2018 12:11:59 AM +00:00</CreatedAt>
    <ClosedAt>2/08/2018 4:41:12 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18723</IssueLabelID>
    <Title>Failure in arm32/arm64 corefx altjit tests</Title>
    <Description>I'm seeing:


Did something change in the corefx tools (msbuild etc.) that makes this syntax invalid now?

This syntax is constructed in coreclr: tests\scripts\run-corefx-tests.py

e.g.: https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64_arm64_altjit/job/jitstress/job/x64_arm64_altjit_checked_windows_nt_corefx_baseline/230/consoleFull#-165810470383554902-aff0-4799-9e92-0ada24ce2a06
</Description>
    <Title_Description>Failure in arm32/arm64 corefx altjit tests I'm seeing:


Did something change in the corefx tools (msbuild etc.) that makes this syntax invalid now?

This syntax is constructed in coreclr: tests\scripts\run-corefx-tests.py

e.g.: https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64_arm64_altjit/job/jitstress/job/x64_arm64_altjit_checked_windows_nt_corefx_baseline/230/consoleFull#-165810470383554902-aff0-4799-9e92-0ada24ce2a06
</Title_Description>
    <Label>
    </Label>
    <Assignee>BruceForstall</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18722</IssueLabelID>
    <Title>reenable fixed arm64 altjit tests</Title>
    <Description>
    </Description>
    <Title_Description>reenable fixed arm64 altjit tests </Title_Description>
    <Label>disabled-test</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>29/06/2018 11:19:56 PM +00:00</CreatedAt>
    <ClosedAt>2/07/2018 5:21:37 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18721</IssueLabelID>
    <Title>SuperPMI: add ability to exclude failing method contexts from replays</Title>
    <Description>The first 3 commits are only refactoring.
The fourth adds a stub and ability to print number of excluded methods.</Description>
    <Title_Description>SuperPMI: add ability to exclude failing method contexts from replays The first 3 commits are only refactoring.
The fourth adds a stub and ability to print number of excluded methods.</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>29/06/2018 11:19:09 PM +00:00</CreatedAt>
    <ClosedAt>3/07/2018 12:32:59 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18719</IssueLabelID>
    <Title>Proposal to add classification info to area-CodeGen issues</Title>
    <Description>There are currently 652 open are-CodeGen issues. To help with triage the jit team went through the issues and compiled classification info for each issue: category theme skill-level and cost. Each issue got one tag from each of the following sets:

category: {cq correctness implementation throughput proposal reach design. documentation testing engsys usability security portability}

theme: {basic-cq register-allocator arm64 jit-coding-style testing inlining optimization benchmarks ir loop-opt vector-codegen hw-intrinsics x86 importer first-class-structs arm32 throughput jit-stress intrinsics sysV helpers bounds-checks runtime flowgraph promotion gc-stress emitter gc-info big-bets large-methods value-numbering debug-dumps ilasm assertion-prop devirtualization block-opts ref-counts profile-feedback barriers msil cse eh ildasm tail-call super-pmi div-mod-rem zero-init stack-allocation type-intrinsics structs morph span&lt;t&gt; jit-ee-interface lower md-arrays invalid-il spmi ssa block-layout alignment range-check liveness copy-prop volatile delegates web-assembly pinning interpreter generics build class-init linux}

skill-level: {beginner intermediate expert}

cost: {small medium large extra-large}

This info is currently in an excel spreadsheet and we would like to propagate it to the issues.
We think adding a label for each of the tags above would be excessive. The proposal is to append this information to the end of the issue description e.g.

Any feedback on this plan is appreciated.

@dotnet/jit-contrib @karelz </Description>
    <Title_Description>Proposal to add classification info to area-CodeGen issues There are currently 652 open are-CodeGen issues. To help with triage the jit team went through the issues and compiled classification info for each issue: category theme skill-level and cost. Each issue got one tag from each of the following sets:

category: {cq correctness implementation throughput proposal reach design. documentation testing engsys usability security portability}

theme: {basic-cq register-allocator arm64 jit-coding-style testing inlining optimization benchmarks ir loop-opt vector-codegen hw-intrinsics x86 importer first-class-structs arm32 throughput jit-stress intrinsics sysV helpers bounds-checks runtime flowgraph promotion gc-stress emitter gc-info big-bets large-methods value-numbering debug-dumps ilasm assertion-prop devirtualization block-opts ref-counts profile-feedback barriers msil cse eh ildasm tail-call super-pmi div-mod-rem zero-init stack-allocation type-intrinsics structs morph span&lt;t&gt; jit-ee-interface lower md-arrays invalid-il spmi ssa block-layout alignment range-check liveness copy-prop volatile delegates web-assembly pinning interpreter generics build class-init linux}

skill-level: {beginner intermediate expert}

cost: {small medium large extra-large}

This info is currently in an excel spreadsheet and we would like to propagate it to the issues.
We think adding a label for each of the tags above would be excessive. The proposal is to append this information to the end of the issue description e.g.

Any feedback on this plan is appreciated.

@dotnet/jit-contrib @karelz </Title_Description>
    <Label>Design Discussion</Label>
    <Assignee>karelz</Assignee>
    <CreatedAt>29/06/2018 8:49:01 PM +00:00</CreatedAt>
    <ClosedAt>10/08/2018 11:37:13 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18717</IssueLabelID>
    <Title>RyuJIT32 performs unnecessary round-trip through double when converting float to byte</Title>
    <Description>Given the following method



That makes for a 13% speed difference in this method.

I also just noticed the bounds check is not elided here just moved.  I can't seem to get it to elide the check.  Any ideas @mikedn?</Description>
    <Title_Description>RyuJIT32 performs unnecessary round-trip through double when converting float to byte Given the following method



That makes for a 13% speed difference in this method.

I also just noticed the bounds check is not elided here just moved.  I can't seem to get it to elide the check.  Any ideas @mikedn?</Title_Description>
    <Label>arch-x86</Label>
    <Assignee>mikedn</Assignee>
    <CreatedAt>29/06/2018 8:39:06 PM +00:00</CreatedAt>
    <ClosedAt>14/09/2018 5:47:07 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18712</IssueLabelID>
    <Title>Implement BMI1 and BMI2 intrinsics</Title>
    <Description>Pending BMI1:
- [x] AndNot
- [ ] BitFieldExtract
- [x] ExtractLowestSetBit
- [x] GetMaskUptoLowestSetBit
- [x] ResetLowestSetBit
- [x] TrailingZeroCount

Pending BMI2:
- [ ] MultiplyNoFlags
- [x] ParallelBitDeposit
- [x] ParallelBitExtract
- [ ] ZeroHighBits</Description>
    <Title_Description>Implement BMI1 and BMI2 intrinsics Pending BMI1:
- [x] AndNot
- [ ] BitFieldExtract
- [x] ExtractLowestSetBit
- [x] GetMaskUptoLowestSetBit
- [x] ResetLowestSetBit
- [x] TrailingZeroCount

Pending BMI2:
- [ ] MultiplyNoFlags
- [x] ParallelBitDeposit
- [x] ParallelBitExtract
- [ ] ZeroHighBits</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>tannergooding</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18710</IssueLabelID>
    <Title>Strange codegen with structure fields accesses</Title>
    <Description>The C# repro code below shows non-uniformity in .NET Core 2.1 JIT behavior regarding (de)optimization of memory accesses having potential side effects. In short test methods attempt to access all three fields of the structure instance of which only two first values are used.

 modifier to all three fields.</Description>
    <Title_Description>Strange codegen with structure fields accesses The C# repro code below shows non-uniformity in .NET Core 2.1 JIT behavior regarding (de)optimization of memory accesses having potential side effects. In short test methods attempt to access all three fields of the structure instance of which only two first values are used.

 modifier to all three fields.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>erozenfeld</Assignee>
    <CreatedAt>29/06/2018 11:53:34 AM +00:00</CreatedAt>
    <ClosedAt>13/07/2018 8:21:28 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18709</IssueLabelID>
    <Title>Issue with large arrays</Title>
    <Description>Have some Machine Learning code which works on .NET and allocates a large array double[6553665536].
To make this working I had to enable gcAllowVeryLargeObjects .

How to do the same in .NET Core?

Right now getting following exception:
System.OutOfMemoryException: 'Array dimensions exceeded supported range.'

Thanks</Description>
    <Title_Description>Issue with large arrays Have some Machine Learning code which works on .NET and allocates a large array double[6553665536].
To make this working I had to enable gcAllowVeryLargeObjects .

How to do the same in .NET Core?

Right now getting following exception:
System.OutOfMemoryException: 'Array dimensions exceeded supported range.'

Thanks</Title_Description>
    <Label>area-GC</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>29/06/2018 10:36:08 AM +00:00</CreatedAt>
    <ClosedAt>1/02/2019 2:40:21 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18705</IssueLabelID>
    <Title>Huge slowdowns on threaded operations when debugger attached (macOS)</Title>
    <Description>When debugging our application (with attached debugger no breakpoints) performance can drop to a point it becomes frustrating to do anything. On occasion we are also seeing OS level hard locking for seconds to minutes which *may* be related.

Reproducible in both VSCode and Jetbrains Rider. This is exclusive to netcore (2.0 and 2.1) – does not occur under mono or net471 runtime environments. It also seems limited to macOS as I have not been able to reproduce on windows.

This can easily be reproduced on our game framework project: https://github.com/ppy/osu-framework (building should require not extra steps beyond checking it out).

- Start in  flag. On removing this flag from hot paths ([#1](https://github.com/ppy/osu-framework/blob/2fb9404792f0d7c39bed1272419e53683d6cb747/osu.Framework/IO/Network/WebRequest.cs#L229) [#2](https://github.com/ppy/osu-framework/blob/5a4bbc322d7d7e334fc1056550d2e3943b24e9c9/osu.Framework/Graphics/Drawable.cs#L145)) performance will return to normal.

I've been trying to reproduce this with a more isolated test case but have not succeeded yet. Some pointers on moving forward in diagnosing this issue would be appreciated!

</Description>
    <Title_Description>Huge slowdowns on threaded operations when debugger attached (macOS) When debugging our application (with attached debugger no breakpoints) performance can drop to a point it becomes frustrating to do anything. On occasion we are also seeing OS level hard locking for seconds to minutes which *may* be related.

Reproducible in both VSCode and Jetbrains Rider. This is exclusive to netcore (2.0 and 2.1) – does not occur under mono or net471 runtime environments. It also seems limited to macOS as I have not been able to reproduce on windows.

This can easily be reproduced on our game framework project: https://github.com/ppy/osu-framework (building should require not extra steps beyond checking it out).

- Start in  flag. On removing this flag from hot paths ([#1](https://github.com/ppy/osu-framework/blob/2fb9404792f0d7c39bed1272419e53683d6cb747/osu.Framework/IO/Network/WebRequest.cs#L229) [#2](https://github.com/ppy/osu-framework/blob/5a4bbc322d7d7e334fc1056550d2e3943b24e9c9/osu.Framework/Graphics/Drawable.cs#L145)) performance will return to normal.

I've been trying to reproduce this with a more isolated test case but have not succeeded yet. Some pointers on moving forward in diagnosing this issue would be appreciated!

</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>mikem8361</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18704</IssueLabelID>
    <Title>System.Net.Primitives.Functional.Tests Failures</Title>
    <Description>The following tests fail in System.Net.Primitives.Functional.Tests with an EntryPointNotFoundException



</Description>
    <Title_Description>System.Net.Primitives.Functional.Tests Failures The following tests fail in System.Net.Primitives.Functional.Tests with an EntryPointNotFoundException



</Title_Description>
    <Label>arch-x64</Label>
    <Assignee>A-And</Assignee>
    <CreatedAt>29/06/2018 1:04:55 AM +00:00</CreatedAt>
    <ClosedAt>3/07/2018 4:35:01 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18703</IssueLabelID>
    <Title>System.Net.Http.Functional.Tests Failures</Title>
    <Description>Three "*Uppercased" tests fail in System.Net.Http.Functional.Tests
Test:
    SocketsHttpHandler_HttpProtocolTests_Dribble.CustomMethod_SentUppercasedIfKnown
Error:
    Xunit.Sdk.StartsWithException Assert.StartsWith() Failure:\\r\\nExpected: GET \\r\\nActual:   get ..

Test:
    SocketsHttpHandler_HttpProtocolTests.CustomMethod_SentUppercasedIfKnown_Additional
Error:
    Xunit.Sdk.StartsWithException Assert.StartsWith() Failure:\\r\\nExpected: DELETE \\r\\nActual:   delete ...

Test:
    SocketsHttpHandler_HttpProtocolTests.CustomMethod_SentUppercasedIfKnown
Error:
    Xunit.Sdk.StartsWithException Assert.StartsWith() Failure:\\r\\nExpected: GET \\r\\nActual:   get ...


### To reproduce failing 

1. 
</Description>
    <Title_Description>System.Net.Http.Functional.Tests Failures Three "*Uppercased" tests fail in System.Net.Http.Functional.Tests
Test:
    SocketsHttpHandler_HttpProtocolTests_Dribble.CustomMethod_SentUppercasedIfKnown
Error:
    Xunit.Sdk.StartsWithException Assert.StartsWith() Failure:\\r\\nExpected: GET \\r\\nActual:   get ..

Test:
    SocketsHttpHandler_HttpProtocolTests.CustomMethod_SentUppercasedIfKnown_Additional
Error:
    Xunit.Sdk.StartsWithException Assert.StartsWith() Failure:\\r\\nExpected: DELETE \\r\\nActual:   delete ...

Test:
    SocketsHttpHandler_HttpProtocolTests.CustomMethod_SentUppercasedIfKnown
Error:
    Xunit.Sdk.StartsWithException Assert.StartsWith() Failure:\\r\\nExpected: GET \\r\\nActual:   get ...


### To reproduce failing 

1. 
</Title_Description>
    <Label>arch-x64</Label>
    <Assignee>A-And</Assignee>
    <CreatedAt>29/06/2018 12:56:08 AM +00:00</CreatedAt>
    <ClosedAt>3/07/2018 4:35:24 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18702</IssueLabelID>
    <Title>System.Linq.Expressions.Tests Failures</Title>
    <Description>Multiple tests in Linq.Expressions.Tests fail. 

With all of the below only some elements in the collections don't pass the test.

</Description>
    <Title_Description>System.Linq.Expressions.Tests Failures Multiple tests in Linq.Expressions.Tests fail. 

With all of the below only some elements in the collections don't pass the test.

</Title_Description>
    <Label>arch-x64</Label>
    <Assignee>A-And</Assignee>
    <CreatedAt>29/06/2018 12:53:14 AM +00:00</CreatedAt>
    <ClosedAt>3/07/2018 4:35:34 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18701</IssueLabelID>
    <Title>System.Security.Principal.Tests Failure</Title>
    <Description>The following error is hit when running System.Security.Principal.Tests - this also crashes the .NET Core Host running the XUnit runner. 
There is a substantial number of tests which fail with </Description>
    <Title_Description>System.Security.Principal.Tests Failure The following error is hit when running System.Security.Principal.Tests - this also crashes the .NET Core Host running the XUnit runner. 
There is a substantial number of tests which fail with </Title_Description>
    <Label>arch-x64</Label>
    <Assignee>A-And</Assignee>
    <CreatedAt>29/06/2018 12:49:35 AM +00:00</CreatedAt>
    <ClosedAt>3/07/2018 4:35:42 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18700</IssueLabelID>
    <Title>System.Linq.Expressions.Tests TypeLoadException in System.Private.CoreLib</Title>
    <Description>A TypeLoadException is hit when running System.Linq.Expressions.
</Description>
    <Title_Description>System.Linq.Expressions.Tests TypeLoadException in System.Private.CoreLib A TypeLoadException is hit when running System.Linq.Expressions.
</Title_Description>
    <Label>arch-x64</Label>
    <Assignee>A-And</Assignee>
    <CreatedAt>29/06/2018 12:47:40 AM +00:00</CreatedAt>
    <ClosedAt>3/07/2018 4:35:11 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18699</IssueLabelID>
    <Title>System.Drawing.Common.Tests Failures</Title>
    <Description>Some System.Drawing tests are failing with invalid Enum values. The disabled tests failing from the same cause are 

</Description>
    <Title_Description>System.Drawing.Common.Tests Failures Some System.Drawing tests are failing with invalid Enum values. The disabled tests failing from the same cause are 

</Title_Description>
    <Label>arch-x64</Label>
    <Assignee>A-And</Assignee>
    <CreatedAt>29/06/2018 12:45:36 AM +00:00</CreatedAt>
    <ClosedAt>23/05/2019 9:38:41 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18698</IssueLabelID>
    <Title>Change CancellationTokenRegistration.Unregister visibility from internal to public</Title>
    <Description>Add a CancellationTokenRegistrationSupport to access CancellationTokenRegistration.Unregister(0 method.

After https://github.com/dotnet/corefx/issues/14903 is fixed  We can remove this public implementation

Corefx repro: https://github.com/dotnet/corefx/pull/30745</Description>
    <Title_Description>Change CancellationTokenRegistration.Unregister visibility from internal to public Add a CancellationTokenRegistrationSupport to access CancellationTokenRegistration.Unregister(0 method.

After https://github.com/dotnet/corefx/issues/14903 is fixed  We can remove this public implementation

Corefx repro: https://github.com/dotnet/corefx/pull/30745</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>luqunl</Assignee>
    <CreatedAt>29/06/2018 12:07:11 AM +00:00</CreatedAt>
    <ClosedAt>29/06/2018 5:59:08 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18692</IssueLabelID>
    <Title>Proposal: Re-introduce support for multi-module assemblies</Title>
    <Description>Is there a technical reason or downside to having multi-module assemblies in CoreCLR?

https://github.com/dotnet/coreclr/commit/1aa7d6b8796f7e28a63162117c5bb16a207a472b removed the code associated with FEATURE_MULTIMODULE_ASSEMBLIES since it was never defined.

If there isn't I'd like to propose we bring this feature back.</Description>
    <Title_Description>Proposal: Re-introduce support for multi-module assemblies Is there a technical reason or downside to having multi-module assemblies in CoreCLR?

https://github.com/dotnet/coreclr/commit/1aa7d6b8796f7e28a63162117c5bb16a207a472b removed the code associated with FEATURE_MULTIMODULE_ASSEMBLIES since it was never defined.

If there isn't I'd like to propose we bring this feature back.</Title_Description>
    <Label>area-AssemblyLoader</Label>
    <Assignee>mjsabby</Assignee>
    <CreatedAt>28/06/2018 9:11:52 PM +00:00</CreatedAt>
    <ClosedAt>9/05/2019 2:53:37 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18691</IssueLabelID>
    <Title>Add public implementation CultureDataSupport</Title>
    <Description>WindowsRuntimeResourceManager  need to access CultureData to see whether a language is supported or not.
Add a public implementation CultureDataSupport for WindowsRuntimeResourceManager  </Description>
    <Title_Description>Add public implementation CultureDataSupport WindowsRuntimeResourceManager  need to access CultureData to see whether a language is supported or not.
Add a public implementation CultureDataSupport for WindowsRuntimeResourceManager  </Title_Description>
    <Label>area-Interop</Label>
    <Assignee>luqunl</Assignee>
    <CreatedAt>28/06/2018 8:09:52 PM +00:00</CreatedAt>
    <ClosedAt>29/06/2018 4:24:45 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18690</IssueLabelID>
    <Title>SuperPmi: add ability to exclude failing methods</Title>
    <Description>SuperPMI is used to collect method context files and replay them using only JIT.
It is also possible to collect plain *.mc but replay with set of  will read method names from this file and skip these methods.</Description>
    <Title_Description>SuperPmi: add ability to exclude failing methods SuperPMI is used to collect method context files and replay them using only JIT.
It is also possible to collect plain *.mc but replay with set of  will read method names from this file and skip these methods.</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>sandreenko</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18688</IssueLabelID>
    <Title>Bounds checks on array/span not eliminated after length check</Title>
    <Description>I've got code similar to the following repro:

but it’d be nice not to have to use Unsafe for cases like this.

cc: @AndyAyersMS 
Related: https://github.com/dotnet/coreclr/issues/12639

category:cq
theme:range-check
skill-level:intermediate
cost:medium</Description>
    <Title_Description>Bounds checks on array/span not eliminated after length check I've got code similar to the following repro:

but it’d be nice not to have to use Unsafe for cases like this.

cc: @AndyAyersMS 
Related: https://github.com/dotnet/coreclr/issues/12639

category:cq
theme:range-check
skill-level:intermediate
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
    <CreatedAt>28/06/2018 5:13:50 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18687</IssueLabelID>
    <Title>Port to 2.1: Fix alternate stack cleanup on MUSL</Title>
    <Description>The MUSL implementation of sigaltstack checks that the ss.ss_size is
larger or equal than the MINSIGSTKSZ even when the ss_flags is set
to SS_DISABLE even though Linux man page for sigaltstack states that
when this flag is set all other ss fields are ignored.

We were not setting the ss_size in this case and it was causing a memory
leak for each thread that has terminated on MUSL based Linux distros
like Alpine.

Glibc implementation doesn't check the ss_size when the SS_DISABLE is set
so the problem was really MUSL specific.</Description>
    <Title_Description>Port to 2.1: Fix alternate stack cleanup on MUSL The MUSL implementation of sigaltstack checks that the ss.ss_size is
larger or equal than the MINSIGSTKSZ even when the ss_flags is set
to SS_DISABLE even though Linux man page for sigaltstack states that
when this flag is set all other ss fields are ignored.

We were not setting the ss_size in this case and it was causing a memory
leak for each thread that has terminated on MUSL based Linux distros
like Alpine.

Glibc implementation doesn't check the ss_size when the SS_DISABLE is set
so the problem was really MUSL specific.</Title_Description>
    <Label>area-PAL</Label>
    <Assignee>janvorli</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18685</IssueLabelID>
    <Title>Fix alternate stack cleanup on MUSL</Title>
    <Description>The MUSL implementation of sigaltstack checks that the ss.ss_size is
larger or equal than the MINSIGSTKSZ even when the ss_flags is set
to SS_DISABLE even though Linux man page for sigaltstack states that
when this flag is set all other ss fields are ignored.

We were not setting the ss_size in this case and it was causing a memory
leak for each thread that has terminated on MUSL based Linux distros
like Alpine.

Glibc implementation doesn't check the ss_size when the SS_DISABLE is set
so the problem was really MUSL specific.</Description>
    <Title_Description>Fix alternate stack cleanup on MUSL The MUSL implementation of sigaltstack checks that the ss.ss_size is
larger or equal than the MINSIGSTKSZ even when the ss_flags is set
to SS_DISABLE even though Linux man page for sigaltstack states that
when this flag is set all other ss fields are ignored.

We were not setting the ss_size in this case and it was causing a memory
leak for each thread that has terminated on MUSL based Linux distros
like Alpine.

Glibc implementation doesn't check the ss_size when the SS_DISABLE is set
so the problem was really MUSL specific.</Title_Description>
    <Label>area-PAL</Label>
    <Assignee>janvorli</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18683</IssueLabelID>
    <Title>Option additionalProbingPaths is not working</Title>
    <Description>According to documentation this parameter should allow the placement of libraries in a different location for example a subdirectory. However the parameter fails to work as advised.

I'm running into the same behavior explained in this posting on StackOverflow: 
https://stackoverflow.com/questions/48650348/additionalprobingpaths-not-respected-after-dotnet-publish

Basically if you put the additional path into the json file it is ignored and moving a library to the new location will produce an error:
"An assembly specified in the application dependencies manifest ([referencedLibrary].deps.json) was not found"

This either does not work at all or it's documentation needs to be greatly improved.</Description>
    <Title_Description>Option additionalProbingPaths is not working According to documentation this parameter should allow the placement of libraries in a different location for example a subdirectory. However the parameter fails to work as advised.

I'm running into the same behavior explained in this posting on StackOverflow: 
https://stackoverflow.com/questions/48650348/additionalprobingpaths-not-respected-after-dotnet-publish

Basically if you put the additional path into the json file it is ignored and moving a library to the new location will produce an error:
"An assembly specified in the application dependencies manifest ([referencedLibrary].deps.json) was not found"

This either does not work at all or it's documentation needs to be greatly improved.</Title_Description>
    <Label>area-AssemblyLoader</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>28/06/2018 7:03:33 AM +00:00</CreatedAt>
    <ClosedAt>3/07/2018 3:32:03 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18682</IssueLabelID>
    <Title>ASP.NET Core application terminates with Segmentation fault on ARM.</Title>
    <Description>I've published my ASP.NET Core application with </Description>
    <Title_Description>ASP.NET Core application terminates with Segmentation fault on ARM. I've published my ASP.NET Core application with </Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>28/06/2018 3:16:34 AM +00:00</CreatedAt>
    <ClosedAt>17/06/2019 9:09:17 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18681</IssueLabelID>
    <Title>Move Is AppDomainUnloadedException check from S.R.WR into S.P.Corelib</Title>
    <Description>Type AppDomainUnloadedException in S.P.Corelib is internal only. Also I can't use public type AppDomainUnloadedException in System.Runtime.Extensions since Type AppDomainUnloadedException in S.P.Corelib and Type AppDomainUnloadedException in System.Runtime.Extensions are two different types.</Description>
    <Title_Description>Move Is AppDomainUnloadedException check from S.R.WR into S.P.Corelib Type AppDomainUnloadedException in S.P.Corelib is internal only. Also I can't use public type AppDomainUnloadedException in System.Runtime.Extensions since Type AppDomainUnloadedException in S.P.Corelib and Type AppDomainUnloadedException in System.Runtime.Extensions are two different types.</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>luqunl</Assignee>
    <CreatedAt>28/06/2018 12:24:49 AM +00:00</CreatedAt>
    <ClosedAt>28/06/2018 6:50:37 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18680</IssueLabelID>
    <Title>Hung .NET Core console app - F5 launch from VS </Title>
    <Description>A .NET Core 2.1 console app hung (right after I pressed Ctrl+C which the console app handles) and inspection suggests the code required to exit the app never executed because the method could not be JITted.

[Dump file](https://microsoft-my.sharepoint.com/:u:/p/andarno/Eahy34c1IvpOgtMkgCPvKQAB2QNonNUbsvL3LcORNs62BQ?e=iA5Cop)

</Description>
    <Title_Description>Hung .NET Core console app - F5 launch from VS  A .NET Core 2.1 console app hung (right after I pressed Ctrl+C which the console app handles) and inspection suggests the code required to exit the app never executed because the method could not be JITted.

[Dump file](https://microsoft-my.sharepoint.com/:u:/p/andarno/Eahy34c1IvpOgtMkgCPvKQAB2QNonNUbsvL3LcORNs62BQ?e=iA5Cop)

</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>AArnott</Assignee>
    <CreatedAt>27/06/2018 11:42:50 PM +00:00</CreatedAt>
    <ClosedAt>25/02/2019 7:03:21 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18679</IssueLabelID>
    <Title>JIT: look at cost impact of assertion dup detection</Title>
    <Description>More follow on from #18327.

When we generate new assertions we check to see if they're duplicates. If so we don't need to record them. Data from PMI shows that about 75% of generated assertions are duplicates.

The check does a linear scan against the existing assertion table which is potentially costly and this cost would grow if we start recording all or more assertions as proposed in #18678.

Profiling (crossgen x64 of Microsoft.CodeAnalysis.VisualBasic.dll) suggests  gets inlined and it currently represents perhaps ~1% of the time spent in the jit. (Assertion prop as whole is about 5%).

category:throughput
theme:assertion-prop
skill-level:intermediate
cost:medium</Description>
    <Title_Description>JIT: look at cost impact of assertion dup detection More follow on from #18327.

When we generate new assertions we check to see if they're duplicates. If so we don't need to record them. Data from PMI shows that about 75% of generated assertions are duplicates.

The check does a linear scan against the existing assertion table which is potentially costly and this cost would grow if we start recording all or more assertions as proposed in #18678.

Profiling (crossgen x64 of Microsoft.CodeAnalysis.VisualBasic.dll) suggests  gets inlined and it currently represents perhaps ~1% of the time spent in the jit. (Assertion prop as whole is about 5%).

category:throughput
theme:assertion-prop
skill-level:intermediate
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
    <CreatedAt>27/06/2018 10:55:34 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18678</IssueLabelID>
    <Title>JIT: possibly revisit how we set assertion prop table size</Title>
    <Description>Some data on how often we drop assertions (from investigations into #18327 via pmi over fx):

Table Size | Num Methods | Avg Assertion Count | Methods with Dropped Assertions 
----- | -------: | --------: | ----:
64 | 159493 | 4.6 | 222
128 | 1801 | 42.3 | 28
256 | 237 | 81.2 | 4

Overall this doesn't seem too bad -- only about 0.16% of methods lost assertions from table size limits. I unfortunately didn't track how many of the size 64 cases were ones where we deliberately limited the size for throughput reasons.

Table size is determined by looking at . So 551 of these were dropped.

There is obviously some consideration of the overall cost of the subsequent dataflow analysis too which is roughly proportional to max assertion size * number of blocks. So if we allow max assertion size to scale up with blocks we potentially see some quadratic behavior. But this seems perhaps solvable too -- we generate all (or more) assertions initially and then only limit the ones we use if we see bad scaling.

This might let us also try and prioritize which assertions should survive though I don't have any particular idea yet how to formulate that (something like the value number equivalent of weighted ref count usage ...?).

Note today we actually generate all assertions. Assertion gen doesn't early out once the table is full (though perhaps it should). It just stops recording assertions once the table fills up. So we are already paying the cost of finding all these assertions. And the table size itself is not a burden

So a rough proposal would be to find and record all assertions -- allowing the table to grow larger (with perhaps some size limit) and have a budget based on blocks * assertions and if over budget start trimming assertions somehow to get under budget.



category:implementation
theme:assertion-prop
skill-level:intermediate
cost:medium</Description>
    <Title_Description>JIT: possibly revisit how we set assertion prop table size Some data on how often we drop assertions (from investigations into #18327 via pmi over fx):

Table Size | Num Methods | Avg Assertion Count | Methods with Dropped Assertions 
----- | -------: | --------: | ----:
64 | 159493 | 4.6 | 222
128 | 1801 | 42.3 | 28
256 | 237 | 81.2 | 4

Overall this doesn't seem too bad -- only about 0.16% of methods lost assertions from table size limits. I unfortunately didn't track how many of the size 64 cases were ones where we deliberately limited the size for throughput reasons.

Table size is determined by looking at . So 551 of these were dropped.

There is obviously some consideration of the overall cost of the subsequent dataflow analysis too which is roughly proportional to max assertion size * number of blocks. So if we allow max assertion size to scale up with blocks we potentially see some quadratic behavior. But this seems perhaps solvable too -- we generate all (or more) assertions initially and then only limit the ones we use if we see bad scaling.

This might let us also try and prioritize which assertions should survive though I don't have any particular idea yet how to formulate that (something like the value number equivalent of weighted ref count usage ...?).

Note today we actually generate all assertions. Assertion gen doesn't early out once the table is full (though perhaps it should). It just stops recording assertions once the table fills up. So we are already paying the cost of finding all these assertions. And the table size itself is not a burden

So a rough proposal would be to find and record all assertions -- allowing the table to grow larger (with perhaps some size limit) and have a budget based on blocks * assertions and if over budget start trimming assertions somehow to get under budget.



category:implementation
theme:assertion-prop
skill-level:intermediate
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
    <CreatedAt>27/06/2018 10:28:42 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18677</IssueLabelID>
    <Title>Re-enable Test Logs and build only test host in CoreFX CI jobs</Title>
    <Description>#18365 has been merged so logging can be reenabled. Additionally this builds only the components required to build CoreFX tests.</Description>
    <Title_Description>Re-enable Test Logs and build only test host in CoreFX CI jobs #18365 has been merged so logging can be reenabled. Additionally this builds only the components required to build CoreFX tests.</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>A-And</Assignee>
    <CreatedAt>27/06/2018 9:43:45 PM +00:00</CreatedAt>
    <ClosedAt>27/06/2018 11:23:38 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18676</IssueLabelID>
    <Title>[NO MERGE] Add crossgen_equivalence scenario to netci.groovy</Title>
    <Description>**NO MERGE**</Description>
    <Title_Description>[NO MERGE] Add crossgen_equivalence scenario to netci.groovy **NO MERGE**</Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>echesakovMSFT</Assignee>
    <CreatedAt>27/06/2018 9:42:55 PM +00:00</CreatedAt>
    <ClosedAt>11/07/2018 6:04:43 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18675</IssueLabelID>
    <Title>Add additional PInvoke tests to coreclr</Title>
    <Description>The PInvoke scenario surface area is large and the coreclr repo doesn't have coverage that would be considered adequate. Missing areas (not exhaustive):

- Arrays
- SafeHandles
- CriticalHandles
- DllImport searching with UNICODE characters

</Description>
    <Title_Description>Add additional PInvoke tests to coreclr The PInvoke scenario surface area is large and the coreclr repo doesn't have coverage that would be considered adequate. Missing areas (not exhaustive):

- Arrays
- SafeHandles
- CriticalHandles
- DllImport searching with UNICODE characters

</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jkoritzinsky</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18674</IssueLabelID>
    <Title>.NET COM server tests</Title>
    <Description>Testing for scenarios when a coreclr application is a COM server should exist</Description>
    <Title_Description>.NET COM server tests Testing for scenarios when a coreclr application is a COM server should exist</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>27/06/2018 8:50:42 PM +00:00</CreatedAt>
    <ClosedAt>11/09/2018 12:25:40 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18673</IssueLabelID>
    <Title>.NET COM client tests</Title>
    <Description>Testing for scenarios when a coreclr application is a COM client should exist</Description>
    <Title_Description>.NET COM client tests Testing for scenarios when a coreclr application is a COM client should exist</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>27/06/2018 8:48:48 PM +00:00</CreatedAt>
    <ClosedAt>19/07/2018 12:53:42 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18672</IssueLabelID>
    <Title>Wrong constant propagation on Linux in release</Title>
    <Description>On Linux in release the following program outputs 

I'm not 100% sure that this isn't the same as #18259 however this only reproduces on Linux so there is definitely something different here.</Description>
    <Title_Description>Wrong constant propagation on Linux in release On Linux in release the following program outputs 

I'm not 100% sure that this isn't the same as #18259 however this only reproduces on Linux so there is definitely something different here.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>briansull</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18671</IssueLabelID>
    <Title>Add Public implementation RemoveEventHandler in EventRegistrationTokenTable</Title>
    <Description>Add a public implementation API GetEventHandlerFromEventRegistrationToken for System.runtime.WindowsRuntime to consume instead of using FriendAccessAllowed/InternalVisiable

Corefx PR:https://github.com/dotnet/corefx/pull/30699
</Description>
    <Title_Description>Add Public implementation RemoveEventHandler in EventRegistrationTokenTable Add a public implementation API GetEventHandlerFromEventRegistrationToken for System.runtime.WindowsRuntime to consume instead of using FriendAccessAllowed/InternalVisiable

Corefx PR:https://github.com/dotnet/corefx/pull/30699
</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>luqunl</Assignee>
    <CreatedAt>27/06/2018 5:54:14 PM +00:00</CreatedAt>
    <ClosedAt>27/06/2018 11:13:11 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18661</IssueLabelID>
    <Title>Remove Conditional Compilation of Generated DotNETRuntimeEventSource.cs</Title>
    <Description>Build scripts and/or project files need to be fixed so that the conditional compilation of DotNETRuntimeEventSource.cs can be replaced with an unconditional compilation.  Otherwise we risk ending up with a build System.Private.CoreLib.dll that doesn't contain the contents of DotNETRuntimeEventSource.cs.

The line of interest is here: https://github.com/dotnet/coreclr/blob/master/src/System.Private.CoreLib/System.Private.CoreLib.csproj#L446.</Description>
    <Title_Description>Remove Conditional Compilation of Generated DotNETRuntimeEventSource.cs Build scripts and/or project files need to be fixed so that the conditional compilation of DotNETRuntimeEventSource.cs can be replaced with an unconditional compilation.  Otherwise we risk ending up with a build System.Private.CoreLib.dll that doesn't contain the contents of DotNETRuntimeEventSource.cs.

The line of interest is here: https://github.com/dotnet/coreclr/blob/master/src/System.Private.CoreLib/System.Private.CoreLib.csproj#L446.</Title_Description>
    <Label>area-Tracing</Label>
    <Assignee>brianrob</Assignee>
    <CreatedAt>26/06/2018 11:01:27 PM +00:00</CreatedAt>
    <ClosedAt>27/06/2018 6:19:39 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18659</IssueLabelID>
    <Title>Provide a Mechanism to Stream Events Out-of-Process from EventPipe</Title>
    <Description>Provide a mechanism to consume events in real time from EventPipe out-of-process.</Description>
    <Title_Description>Provide a Mechanism to Stream Events Out-of-Process from EventPipe Provide a mechanism to consume events in real time from EventPipe out-of-process.</Title_Description>
    <Label>EventPipe</Label>
    <Assignee>jorive</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18658</IssueLabelID>
    <Title>Provide an Out-of-Process Control Mechanism for EventPipe</Title>
    <Description>Right now EventPipe is only controllable via environment variables and private reflection.  We should add an out-of-process control mechanism to significantly improve usability.</Description>
    <Title_Description>Provide an Out-of-Process Control Mechanism for EventPipe Right now EventPipe is only controllable via environment variables and private reflection.  We should add an out-of-process control mechanism to significantly improve usability.</Title_Description>
    <Label>EventPipe</Label>
    <Assignee>jorive</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18656</IssueLabelID>
    <Title>Use IBC to Drive Partial NGEN and Tiered Compilation Behavior</Title>
    <Description>Now that we have tiered compilation in .NET Core we should look for ways to use it to get fast start-up great throughput at steady state and improvements to size-on-disk.

Consider this a tracking item that should be used to drive a plan here.</Description>
    <Title_Description>Use IBC to Drive Partial NGEN and Tiered Compilation Behavior Now that we have tiered compilation in .NET Core we should look for ways to use it to get fast start-up great throughput at steady state and improvements to size-on-disk.

Consider this a tracking item that should be used to drive a plan here.</Title_Description>
    <Label>area-ReadyToRun</Label>
    <Assignee>brianrob</Assignee>
    <CreatedAt>26/06/2018 10:11:31 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18655</IssueLabelID>
    <Title>Enable IBC Optimization on System.Private.CoreLib</Title>
    <Description>
    </Description>
    <Title_Description>Enable IBC Optimization on System.Private.CoreLib </Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>brianrob</Assignee>
    <CreatedAt>26/06/2018 10:05:14 PM +00:00</CreatedAt>
    <ClosedAt>30/04/2019 7:56:15 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18654</IssueLabelID>
    <Title>Enable PGO Optimization for More Platforms / Architectures</Title>
    <Description>The following platforms currently don't get PGO optimized.

 - Windows arm32
 - Windows arm64
 - Linux arm32
 - Linux arm64
 - OSX x64</Description>
    <Title_Description>Enable PGO Optimization for More Platforms / Architectures The following platforms currently don't get PGO optimized.

 - Windows arm32
 - Windows arm64
 - Linux arm32
 - Linux arm64
 - OSX x64</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>brianrob</Assignee>
    <CreatedAt>26/06/2018 10:04:14 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18652</IssueLabelID>
    <Title>Add LastIndexOf compareoptions overload</Title>
    <Description>Relates to https://github.com/dotnet/corefx/issues/30649

I mostly copied the existing implementations and changed to FIND_FROMEND. Please let me know if something is missing here.</Description>
    <Title_Description>Add LastIndexOf compareoptions overload Relates to https://github.com/dotnet/corefx/issues/30649

I mostly copied the existing implementations and changed to FIND_FROMEND. Please let me know if something is missing here.</Title_Description>
    <Label>area-System.Memory</Label>
    <Assignee>ViktorHofer</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18650</IssueLabelID>
    <Title>[NO MERGE] Dummy PR for testing</Title>
    <Description>**NO MERGE**</Description>
    <Title_Description>[NO MERGE] Dummy PR for testing **NO MERGE**</Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>echesakovMSFT</Assignee>
    <CreatedAt>26/06/2018 5:30:20 PM +00:00</CreatedAt>
    <ClosedAt>17/07/2018 3:49:08 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18648</IssueLabelID>
    <Title>Misuse of optPrepareTreeForReplacement leads to incorrect exception thrown in release</Title>
    <Description>This example incorrectly throws an exception in release:
 is a COMMA where both op1 and op2 point to the same constant node
&gt; 
&gt; I'm surprised that this doesn't blow up more often and more spectacularly!</Description>
    <Title_Description>Misuse of optPrepareTreeForReplacement leads to incorrect exception thrown in release This example incorrectly throws an exception in release:
 is a COMMA where both op1 and op2 point to the same constant node
&gt; 
&gt; I'm surprised that this doesn't blow up more often and more spectacularly!</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>mikedn</Assignee>
    <CreatedAt>26/06/2018 4:29:32 PM +00:00</CreatedAt>
    <ClosedAt>26/06/2018 9:38:14 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18643</IssueLabelID>
    <Title>Community Slack engagement story needs work</Title>
    <Description>*[I'm writing this in story form as I believe it's important you look at this through the proper lens]*

# Story time
So put on your new user hat. 🤠 

You want to engage with the CoreCLR community and figure out why you can't debug CoreCLR. You hit the engagement documentation (https://github.com/dotnet/coreclr/blob/master/Documentation/workflow/IssuesFeedbackEngagement.md).

The CoreCLR repository documentation reels you in with a "chat with the community" heading and a badge that shows there's 6517 registered users on Slack. Wow! Sounds great! You click this badge.

Now you're whisked away to some random blog (tattoocoder) where it indicates 7091 users. Hm okay whatever. I'm daring I'll type my email into this random blog widget.

You continue through Slack's awful user flow where it notifies you that you're joining the .NET Slack. Great! But hosted at... aspnetcore.slack.com. You don't care about aspnet. But you continue anyway.

You join the slack and get plopped into the #general channel with no further guidance. You go through the Slack tutorial for the 100th time and remember there are channels. You join the CoreCLR channel and there's only 286 people. You begin to question if everything you did was for nothing ... 

And end scene. 🦑 

# Suggestions

* Make it clear the Slack is or isn't official (it's not clear)
* Set some expectations -- do core maintainers hang out in here? should I use Slack over Gitter for certain scenarios?
* Rename the Slack name/URLs to make sense (https://get.slack.help/hc/en-us/articles/201663443-Change-your-workspace-or-org-name-and-URL)
* Welcome users with a map ([perhaps with custom code](https://api.slack.com/best-practices/blueprints/new-user-notification) or a [simple bot](https://greetbot.io/))

# Dog Tax

![image](https://user-images.githubusercontent.com/475132/41888633-5501900a-78bb-11e8-803a-b66bd988117d.png)

cc: @spboyer 
</Description>
    <Title_Description>Community Slack engagement story needs work *[I'm writing this in story form as I believe it's important you look at this through the proper lens]*

# Story time
So put on your new user hat. 🤠 

You want to engage with the CoreCLR community and figure out why you can't debug CoreCLR. You hit the engagement documentation (https://github.com/dotnet/coreclr/blob/master/Documentation/workflow/IssuesFeedbackEngagement.md).

The CoreCLR repository documentation reels you in with a "chat with the community" heading and a badge that shows there's 6517 registered users on Slack. Wow! Sounds great! You click this badge.

Now you're whisked away to some random blog (tattoocoder) where it indicates 7091 users. Hm okay whatever. I'm daring I'll type my email into this random blog widget.

You continue through Slack's awful user flow where it notifies you that you're joining the .NET Slack. Great! But hosted at... aspnetcore.slack.com. You don't care about aspnet. But you continue anyway.

You join the slack and get plopped into the #general channel with no further guidance. You go through the Slack tutorial for the 100th time and remember there are channels. You join the CoreCLR channel and there's only 286 people. You begin to question if everything you did was for nothing ... 

And end scene. 🦑 

# Suggestions

* Make it clear the Slack is or isn't official (it's not clear)
* Set some expectations -- do core maintainers hang out in here? should I use Slack over Gitter for certain scenarios?
* Rename the Slack name/URLs to make sense (https://get.slack.help/hc/en-us/articles/201663443-Change-your-workspace-or-org-name-and-URL)
* Welcome users with a map ([perhaps with custom code](https://api.slack.com/best-practices/blueprints/new-user-notification) or a [simple bot](https://greetbot.io/))

# Dog Tax

![image](https://user-images.githubusercontent.com/475132/41888633-5501900a-78bb-11e8-803a-b66bd988117d.png)

cc: @spboyer 
</Title_Description>
    <Label>documentation</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>26/06/2018 4:04:37 AM +00:00</CreatedAt>
    <ClosedAt>26/06/2018 1:52:49 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18642</IssueLabelID>
    <Title>ARM: change reserved register (REG_OPT_RSVD) to LR</Title>
    <Description>Currently  is defined as R10. This is a preserved register which means if we need to reserve it we also need to save/restore it in the prolog/epilog.

Can we change this to scratch register LR instead to avoid this?

(We can't obviously use the other scratch register R12 because it is used in some special cases such as VSD dispatch.)
</Description>
    <Title_Description>ARM: change reserved register (REG_OPT_RSVD) to LR Currently  is defined as R10. This is a preserved register which means if we need to reserve it we also need to save/restore it in the prolog/epilog.

Can we change this to scratch register LR instead to avoid this?

(We can't obviously use the other scratch register R12 because it is used in some special cases such as VSD dispatch.)
</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>BruceForstall</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18641</IssueLabelID>
    <Title>Allow setting COR_PRF_ENABLE_REJIT after runtime startup</Title>
    <Description>It would useful to allow ReJIT on attach instead of it being restricted to scenarios where the profiler is loaded at startup.

This can be solved either such that only methods jitted after ReJIT is turned on are rejittable or make all jit compiled methods rejittable from the beginning of process startup. The former can be confusing but is probably easier to implement in the existing runtime with some error checking to fail on methods that are not rejittable.

If we go with the latter implementation calling SetEventMask with  will probably be a no-op and return success so that profilers don't have to change.</Description>
    <Title_Description>Allow setting COR_PRF_ENABLE_REJIT after runtime startup It would useful to allow ReJIT on attach instead of it being restricted to scenarios where the profiler is loaded at startup.

This can be solved either such that only methods jitted after ReJIT is turned on are rejittable or make all jit compiled methods rejittable from the beginning of process startup. The former can be confusing but is probably easier to implement in the existing runtime with some error checking to fail on methods that are not rejittable.

If we go with the latter implementation calling SetEventMask with  will probably be a no-op and return success so that profilers don't have to change.</Title_Description>
    <Label>area-TieredCompilation</Label>
    <Assignee>davmason</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18640</IssueLabelID>
    <Title>Cross-Platform COM Interop</Title>
    <Description>**Goal: enable interop with native libraries with COM ABI and a reasonable subset of COM features on all supported platforms.**

*Related issue with generic discussion: https://github.com/dotnet/coreclr/issues/11279*
This issue is to list specific work areas required to achieve the functionality:

* RCW (Runtime Callable Wrappers).
	* Managed proxy for a native VTable.
	* AddRef on native IUnknown until managed proxy is finalized (or Marshal Release/FinalRelease).
	* Turn managed casts into QI calls to native IUnknown.
	* Turn reflection/dynamic into IDispatch(Ex) calls to native object.

* CCW (COM Callable Wrappers).
	* Generate VTable expose native pointer to it.
	* Keep GC root until final release from native side.
	* Turn IDispatch calls into reflection/dynamic calls on the managed object.

* Marshalling.
	* Mostly the same as in PInvoke.
	* Non-preserve-sig handling:
		* HRESULT into Exception for RCW; Exception into HRESULT for CCW.
		* Out parameter vs. return value transform.
		* Pointer&lt;-&gt;RCW and object&lt;-&gt;CCW transform.
		
Supposedly most of the implementation should already be available from the .NET Framework code. WinAPI implementations should be substituted with crude fallbacks for trivial cases (no activation scenarios no cross-apartment call marshalling no proxy/stubs).
	
Activation: manual from a DLL file or possibly side-by-side scenarios. At first activation is out of scope suppose we create the first COM object with external means (e.g. Pinvoke + GetObjectForIUnknown).

Here are example scenarios for possible application of this functionality.
* CLR Debugger interfaces (ICorDebug et al). We have a success story of running the cross-platform implementation of debugger with native COM interop from C# with Mono on Linux and Mac. Mono has huge problems with correctness of the implementation yet if you're using only core features and trivial marshalling it's working enough to have a functioning debugger. The problems do not look fundamental just of the quality sort. Obviously we would now like to run the same code on CoreCLR.
* Visual Studio COM interfaces have proven a working example of a large-scale native-managed interop with native and managed parts mixed together with no clear separation. That's not exactly about porting but that's a good example of a multi-technology app with native/managed interop API.
* A few of our own helper libraries on Windows are exposing COM interfaces for object-oriented interaction with the app. This experience is nice to have on any platform.
</Description>
    <Title_Description>Cross-Platform COM Interop **Goal: enable interop with native libraries with COM ABI and a reasonable subset of COM features on all supported platforms.**

*Related issue with generic discussion: https://github.com/dotnet/coreclr/issues/11279*
This issue is to list specific work areas required to achieve the functionality:

* RCW (Runtime Callable Wrappers).
	* Managed proxy for a native VTable.
	* AddRef on native IUnknown until managed proxy is finalized (or Marshal Release/FinalRelease).
	* Turn managed casts into QI calls to native IUnknown.
	* Turn reflection/dynamic into IDispatch(Ex) calls to native object.

* CCW (COM Callable Wrappers).
	* Generate VTable expose native pointer to it.
	* Keep GC root until final release from native side.
	* Turn IDispatch calls into reflection/dynamic calls on the managed object.

* Marshalling.
	* Mostly the same as in PInvoke.
	* Non-preserve-sig handling:
		* HRESULT into Exception for RCW; Exception into HRESULT for CCW.
		* Out parameter vs. return value transform.
		* Pointer&lt;-&gt;RCW and object&lt;-&gt;CCW transform.
		
Supposedly most of the implementation should already be available from the .NET Framework code. WinAPI implementations should be substituted with crude fallbacks for trivial cases (no activation scenarios no cross-apartment call marshalling no proxy/stubs).
	
Activation: manual from a DLL file or possibly side-by-side scenarios. At first activation is out of scope suppose we create the first COM object with external means (e.g. Pinvoke + GetObjectForIUnknown).

Here are example scenarios for possible application of this functionality.
* CLR Debugger interfaces (ICorDebug et al). We have a success story of running the cross-platform implementation of debugger with native COM interop from C# with Mono on Linux and Mac. Mono has huge problems with correctness of the implementation yet if you're using only core features and trivial marshalling it's working enough to have a functioning debugger. The problems do not look fundamental just of the quality sort. Obviously we would now like to run the same code on CoreCLR.
* Visual Studio COM interfaces have proven a working example of a large-scale native-managed interop with native and managed parts mixed together with no clear separation. That's not exactly about porting but that's a good example of a multi-technology app with native/managed interop API.
* A few of our own helper libraries on Windows are exposing COM interfaces for object-oriented interaction with the app. This experience is nice to have on any platform.
</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>25/06/2018 7:57:30 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18634</IssueLabelID>
    <Title>CoreCLR fails to run when mlock is unavailable</Title>
    <Description>CoreCLR uses  as something like:

    mmap(NULL 4096 PROT_READ|PROT_WRITE MAP_PRIVATE|MAP_ANONYMOUS -1 0) = 0x7fbd542bb000
    mlock(0x7fbd542bb000 4096)       = -1 EPERM (Operation not permitted)
    write(2 "Failed to initialize CoreCLR HR"... 49) = 49

As a result this makes it basically impossible to build coreclr in some Linux distribution build systems.</Description>
    <Title_Description>CoreCLR fails to run when mlock is unavailable CoreCLR uses  as something like:

    mmap(NULL 4096 PROT_READ|PROT_WRITE MAP_PRIVATE|MAP_ANONYMOUS -1 0) = 0x7fbd542bb000
    mlock(0x7fbd542bb000 4096)       = -1 EPERM (Operation not permitted)
    write(2 "Failed to initialize CoreCLR HR"... 49) = 49

As a result this makes it basically impossible to build coreclr in some Linux distribution build systems.</Title_Description>
    <Label>area-PAL</Label>
    <Assignee>tmds</Assignee>
    <CreatedAt>25/06/2018 3:56:37 PM +00:00</CreatedAt>
    <ClosedAt>20/11/2018 6:52:47 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18632</IssueLabelID>
    <Title>Enable FEATURE_GDBJIT on default builds</Title>
    <Description>On Linux/OSX it would be very nice if the default distributing has FEATURE_GDBJIT enabled so the debugging experience doesn't require manual building of SOS to have *some* debugging experience (presuming one sets the envvar needed for this)</Description>
    <Title_Description>Enable FEATURE_GDBJIT on default builds On Linux/OSX it would be very nice if the default distributing has FEATURE_GDBJIT enabled so the debugging experience doesn't require manual building of SOS to have *some* debugging experience (presuming one sets the envvar needed for this)</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>mikem8361</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18630</IssueLabelID>
    <Title>comcallablewrapper has very misleading commentary</Title>
    <Description>As part of the gutting of FEATURE_CORECLR ifdefs (https://github.com/dotnet/coreclr/commit/54891e0650e69f08832f75a40dc102efc6115d38#diff-ade4b3276f9a170febb781e66ab30039) appx-specific functionality got removed but this comment (https://github.com/dotnet/coreclr/blob/master/src/vm/comcallablewrapper.cpp#L1927-L1937) wasn't updated sending me on a wild goose chase for a few hours.

Was going to submit a PR but guidelines indicate bar wouldn't be met. I disagree hence this issue. Hope we can all agree this comment should be edited.

cc: @danmosemsft </Description>
    <Title_Description>comcallablewrapper has very misleading commentary As part of the gutting of FEATURE_CORECLR ifdefs (https://github.com/dotnet/coreclr/commit/54891e0650e69f08832f75a40dc102efc6115d38#diff-ade4b3276f9a170febb781e66ab30039) appx-specific functionality got removed but this comment (https://github.com/dotnet/coreclr/blob/master/src/vm/comcallablewrapper.cpp#L1927-L1937) wasn't updated sending me on a wild goose chase for a few hours.

Was going to submit a PR but guidelines indicate bar wouldn't be met. I disagree hence this issue. Hope we can all agree this comment should be edited.

cc: @danmosemsft </Title_Description>
    <Label>area-Interop</Label>
    <Assignee>danmosemsft</Assignee>
    <CreatedAt>25/06/2018 8:00:50 AM +00:00</CreatedAt>
    <ClosedAt>25/06/2018 8:13:50 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18619</IssueLabelID>
    <Title>Add a memory budget to the GC</Title>
    <Description>As I understand it GC time is *very roughly* proportional to the number of object references alive. The total time an application spends in GC is also proportional to the number of (full) collections happening. It seems that on servers with a lot of memory there is an optimization opportunity: Collect less often. Simply allow huge amounts of garbage to build up. Allow 10 GBs of garbage to build up and blast it all away in a single G2 collection.

The .NET GC is very autotuning which is a great thing. For that reason by default the GC does not allow too much garbage to build up. This is a good thing because we don't want to impact other apps running on the server. Also this might not improve performance in all cases.

But the GC does not know what a developer is able to know. Developers can measure different GC settings and pick the best one. Developers also know their optimization goal (memory usage vs. CPU usage).

I therefore propose to add a simple tuning knob to the GC to tell it to use more memory than normal. I'm not sure what the best way to specify this would be. Maybe a setting . The developer can calculate an appropriate value at app startup based on the machine hardware. Or he can dynamically adjust this value based on free memory and based on the workload.

Use cases:

1. Server apps on servers with a lot of memory. My ASP.NET apps tend to use a few hundred MBs of memory on servers with many GBs of memory. A lot of memory ends up unused.
2. Console apps running GC heavy batch workloads.
3. Cloud apps where possibly total cost can be reduced by switching to a memory heavy instance. Pay more for memory and save on GC CPU cycles.
4. Games which want to experience less GC pauses on machines with ample memory.
</Description>
    <Title_Description>Add a memory budget to the GC As I understand it GC time is *very roughly* proportional to the number of object references alive. The total time an application spends in GC is also proportional to the number of (full) collections happening. It seems that on servers with a lot of memory there is an optimization opportunity: Collect less often. Simply allow huge amounts of garbage to build up. Allow 10 GBs of garbage to build up and blast it all away in a single G2 collection.

The .NET GC is very autotuning which is a great thing. For that reason by default the GC does not allow too much garbage to build up. This is a good thing because we don't want to impact other apps running on the server. Also this might not improve performance in all cases.

But the GC does not know what a developer is able to know. Developers can measure different GC settings and pick the best one. Developers also know their optimization goal (memory usage vs. CPU usage).

I therefore propose to add a simple tuning knob to the GC to tell it to use more memory than normal. I'm not sure what the best way to specify this would be. Maybe a setting . The developer can calculate an appropriate value at app startup based on the machine hardware. Or he can dynamically adjust this value based on free memory and based on the workload.

Use cases:

1. Server apps on servers with a lot of memory. My ASP.NET apps tend to use a few hundred MBs of memory on servers with many GBs of memory. A lot of memory ends up unused.
2. Console apps running GC heavy batch workloads.
3. Cloud apps where possibly total cost can be reduced by switching to a memory heavy instance. Pay more for memory and save on GC CPU cycles.
4. Games which want to experience less GC pauses on machines with ample memory.
</Title_Description>
    <Label>area-GC</Label>
    <Assignee>luhenry</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18617</IssueLabelID>
    <Title>macOS Mojave: Support for Hardened Runtime</Title>
    <Description>From https://github.com/xamarin/xamarin-macios/issues/4288 / https://github.com/mono/mono/issues/9210 :

In macOS Mojave Apple has introduced support for Hardened Runtime. (This is fully explained somewhere in the WWDC 2018 slides but I cannot right now find exactly where.) One of the hardening mechanisms is a limitation on JIT techniques. It is still fully possible and supported but the MAP_JIT flag must be passed to mmap() calls and a specific entitlement must also be present in the code signature. 

https://developer.apple.com/videos/play/wwdc2018/702/ 20 minute mark has details.</Description>
    <Title_Description>macOS Mojave: Support for Hardened Runtime From https://github.com/xamarin/xamarin-macios/issues/4288 / https://github.com/mono/mono/issues/9210 :

In macOS Mojave Apple has introduced support for Hardened Runtime. (This is fully explained somewhere in the WWDC 2018 slides but I cannot right now find exactly where.) One of the hardening mechanisms is a limitation on JIT techniques. It is still fully possible and supported but the MAP_JIT flag must be passed to mmap() calls and a specific entitlement must also be present in the code signature. 

https://developer.apple.com/videos/play/wwdc2018/702/ 20 minute mark has details.</Title_Description>
    <Label>area-VM</Label>
    <Assignee>janvorli</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18611</IssueLabelID>
    <Title>[WIP] Test with tiering</Title>
    <Description>For https://github.com/dotnet/coreclr/pull/18610</Description>
    <Title_Description>[WIP] Test with tiering For https://github.com/dotnet/coreclr/pull/18610</Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18610</IssueLabelID>
    <Title>Apply tiering's call counting delay more broadly</Title>
    <Description>Issues
- When some time passes between process startup and first significant use of the app startup perf with tiering can be slower because the call counting delay is no longer in effect
- This is especially true when the process is affinitized to one cpu

Fixes
- Initiate and prolong the call counting delay upon tier 0 activity (jitting or r2r code lookup for a new method)
- Stop call counting for a called method when the delay is in effect
- Stop (and don't start) tier 1 jitting when the delay is in effect
- After the delay resume call counting and tier 1 jitting
- If the process is affinitized to one cpu at process startup multiply the delay by 10

No change in benchmarks.</Description>
    <Title_Description>Apply tiering's call counting delay more broadly Issues
- When some time passes between process startup and first significant use of the app startup perf with tiering can be slower because the call counting delay is no longer in effect
- This is especially true when the process is affinitized to one cpu

Fixes
- Initiate and prolong the call counting delay upon tier 0 activity (jitting or r2r code lookup for a new method)
- Stop call counting for a called method when the delay is in effect
- Stop (and don't start) tier 1 jitting when the delay is in effect
- After the delay resume call counting and tier 1 jitting
- If the process is affinitized to one cpu at process startup multiply the delay by 10

No change in benchmarks.</Title_Description>
    <Label>area-VM</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18609</IssueLabelID>
    <Title>Mirror changes from dotnet/corert</Title>
    <Description>This PR contains mirrored changes from dotnet/corert


**Please REBASE this PR when merging**</Description>
    <Title_Description>Mirror changes from dotnet/corert This PR contains mirrored changes from dotnet/corert


**Please REBASE this PR when merging**</Title_Description>
    <Label>
    </Label>
    <Assignee>Anipik</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18607</IssueLabelID>
    <Title>What is the proper way of doing incremental builds on Windows?</Title>
    <Description>I am trying to make changes to native components (eg.  after configuring.</Description>
    <Title_Description>What is the proper way of doing incremental builds on Windows? I am trying to make changes to native components (eg.  after configuring.</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>22/06/2018 2:01:56 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18603</IssueLabelID>
    <Title>RyuJIT and SIMD - suboptimal codegen when performing bitmask comparisons</Title>
    <Description> which sets both _ZF_ and _CF_ (see http://www.felixcloutier.com/x86/PTEST.html).

category:cq
theme:vector-codegen
skill-level:expert
cost:medium</Description>
    <Title_Description>RyuJIT and SIMD - suboptimal codegen when performing bitmask comparisons  which sets both _ZF_ and _CF_ (see http://www.felixcloutier.com/x86/PTEST.html).

category:cq
theme:vector-codegen
skill-level:expert
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>22/06/2018 5:29:49 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18602</IssueLabelID>
    <Title>"Go to disassembly" in VS aborts debugging session</Title>
    <Description>Repro:

- Attach VS to CoreCLR process
- Find frame in System.Private.Corelib
- Select "Go to disassembly"

Result: 

msvsmon.exe crashes
</Description>
    <Title_Description>"Go to disassembly" in VS aborts debugging session Repro:

- Attach VS to CoreCLR process
- Find frame in System.Private.Corelib
- Select "Go to disassembly"

Result: 

msvsmon.exe crashes
</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>noahfalk</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18599</IssueLabelID>
    <Title>Dllimport does not find libraries outside of system default (Linux)</Title>
    <Description>@furoraest commented on [Sun May 20 2018](https://github.com/dotnet/core/issues/1575)

when doing PInvoke call like
[DllImport("mylib")]
        private static extern int some_external_func();
the dotnet does not find library unless in its some system default (like /usr/lib)
If to explicitly state the actual library name like "libmylib.so.0.0.0" it will find it 
ldconfig is finding the libraries correctly using ld.so.conf and stating custom library folder.
Temporary solution was to add LD_LIBRARY_PATH to the running environment  pointing to the library folder which should not be necessary if the ldconfig lists those libraries already.
If already linked library tries to use other library (outside the system default) when the dotnet program will get error:
dotnet: symbol lookup error: /usr/local/lib/libmylib.so: undefined symbol: _ZN2gr6some9awesome4functionEmmPcibi
Used platform: Ubuntu 18.04 and SDK 2.1 RC1
My current solution is to handload the all required libraries using this code:
[DllImport("dl")]
        private static extern IntPtr dlopen (string file int mode);
and then in the function somewhere before first call of the PInvoked function call out the libraries
dlopen("libmyawesomelib-x.y.z.0.so.0.0.0" RTLD_LAZY|RTLD_GLOBAL);
dlopen("libmyawesomelib2-x.y.z.0.so.0.0.0" RTLD_LAZY|RTLD_GLOBAL);


</Description>
    <Title_Description>Dllimport does not find libraries outside of system default (Linux) @furoraest commented on [Sun May 20 2018](https://github.com/dotnet/core/issues/1575)

when doing PInvoke call like
[DllImport("mylib")]
        private static extern int some_external_func();
the dotnet does not find library unless in its some system default (like /usr/lib)
If to explicitly state the actual library name like "libmylib.so.0.0.0" it will find it 
ldconfig is finding the libraries correctly using ld.so.conf and stating custom library folder.
Temporary solution was to add LD_LIBRARY_PATH to the running environment  pointing to the library folder which should not be necessary if the ldconfig lists those libraries already.
If already linked library tries to use other library (outside the system default) when the dotnet program will get error:
dotnet: symbol lookup error: /usr/local/lib/libmylib.so: undefined symbol: _ZN2gr6some9awesome4functionEmmPcibi
Used platform: Ubuntu 18.04 and SDK 2.1 RC1
My current solution is to handload the all required libraries using this code:
[DllImport("dl")]
        private static extern IntPtr dlopen (string file int mode);
and then in the function somewhere before first call of the PInvoked function call out the libraries
dlopen("libmyawesomelib-x.y.z.0.so.0.0.0" RTLD_LAZY|RTLD_GLOBAL);
dlopen("libmyawesomelib2-x.y.z.0.so.0.0.0" RTLD_LAZY|RTLD_GLOBAL);


</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18594</IssueLabelID>
    <Title>Consolidate testing guidelines</Title>
    <Description>There are multiple documents under https://github.com/dotnet/coreclr/tree/master/Documentation/building that describe how testing can be accomplished. These docs include building and running tests. However since we are using platform agnostic tools the instructions should also be largely agnostic of platform. Minor command line differences but that are basically limited to use the .</Description>
    <Title_Description>Consolidate testing guidelines There are multiple documents under https://github.com/dotnet/coreclr/tree/master/Documentation/building that describe how testing can be accomplished. These docs include building and running tests. However since we are using platform agnostic tools the instructions should also be largely agnostic of platform. Minor command line differences but that are basically limited to use the .</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>21/06/2018 4:57:34 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18586</IssueLabelID>
    <Title>Mirror changes from dotnet/corert</Title>
    <Description>This PR contains mirrored changes from dotnet/corert


**Please REBASE this PR when merging**</Description>
    <Title_Description>Mirror changes from dotnet/corert This PR contains mirrored changes from dotnet/corert


**Please REBASE this PR when merging**</Title_Description>
    <Label>
    </Label>
    <Assignee>jkotas</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18582</IssueLabelID>
    <Title>optimize fgMorphTree for GenTreeArgList</Title>
    <Description>We can't usually have deep trees because importer restricts trees depth:
https://github.com/dotnet/coreclr/blob/da40cb1ca8779566ca53ed6bd2fa67a926b29b38/src/jit/importer.cpp#L10173-L10178

However it doesn't restrict depth of .

Fixes DevDiv_635180.


No asm diffs no measurable instruction retired diff for System.Private.CoreLib.
</Description>
    <Title_Description>optimize fgMorphTree for GenTreeArgList We can't usually have deep trees because importer restricts trees depth:
https://github.com/dotnet/coreclr/blob/da40cb1ca8779566ca53ed6bd2fa67a926b29b38/src/jit/importer.cpp#L10173-L10178

However it doesn't restrict depth of .

Fixes DevDiv_635180.


No asm diffs no measurable instruction retired diff for System.Private.CoreLib.
</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>20/06/2018 11:45:45 PM +00:00</CreatedAt>
    <ClosedAt>29/06/2018 8:38:45 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18580</IssueLabelID>
    <Title>Deadlock occuring after calling GetTypes() in visual studio</Title>
    <Description>First of all I'm new to this I'm not even sure I'm posting this at the right place. That being said here is my problem.

I have a C# application that lazy load a dll. In the constructor of a static class in that dll I have a call to GetTypes(). The problem seems to occur with a specific timming and only happens when running the application from visual studio. I'm running the .NET Framework 4.7.1.

To be clear:
MyExecutable.exe:
fffe1534
clr!DomainAssembly::DeliverAsyncEvents+0x40

I have a work around for now I simply construct my static class very soon the the application but I'm wondering if it's a known issue or if I'm doing something wrong.

Again the application works fine when not running it with visual studio.

Visual Studio Professional 2017
Version 15.6.1

.Net Framework
Version 4.7.02558</Description>
    <Title_Description>Deadlock occuring after calling GetTypes() in visual studio First of all I'm new to this I'm not even sure I'm posting this at the right place. That being said here is my problem.

I have a C# application that lazy load a dll. In the constructor of a static class in that dll I have a call to GetTypes(). The problem seems to occur with a specific timming and only happens when running the application from visual studio. I'm running the .NET Framework 4.7.1.

To be clear:
MyExecutable.exe:
fffe1534
clr!DomainAssembly::DeliverAsyncEvents+0x40

I have a work around for now I simply construct my static class very soon the the application but I'm wondering if it's a known issue or if I'm doing something wrong.

Again the application works fine when not running it with visual studio.

Visual Studio Professional 2017
Version 15.6.1

.Net Framework
Version 4.7.02558</Title_Description>
    <Label>area-AssemblyLoader</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>20/06/2018 10:28:54 PM +00:00</CreatedAt>
    <ClosedAt>22/06/2018 5:37:49 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18579</IssueLabelID>
    <Title>DateTime.ToString("d") formats differently on Mac OS and Windows</Title>
    <Description>When I have a DateTime that I call  I would expect that the formatted string would be the same on different platforms but for a date "9/25/2017" it produces 9/25/17 on MacOS and 9/25/2017 on windows.</Description>
    <Title_Description>DateTime.ToString("d") formats differently on Mac OS and Windows When I have a DateTime that I call  I would expect that the formatted string would be the same on different platforms but for a date "9/25/2017" it produces 9/25/17 on MacOS and 9/25/2017 on windows.</Title_Description>
    <Label>area-System.Globalization</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>20/06/2018 8:10:53 PM +00:00</CreatedAt>
    <ClosedAt>21/06/2018 1:45:27 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18577</IssueLabelID>
    <Title>ASP.NET core web API - OOM on Ubuntu after upgrade to 2.1.</Title>
    <Description>We have a .net core web API running on AWS Ubuntu 16.04 VM.
The API is using EF to query a relatively small DB and makes a lot of external requests due to integrations with other systems. After we upgraded to 2.1. we started to have serious OOM problems on production.  During the upgrade we haven't changed much in our execution logic aside from the changes needed to support the changes in the APIs. I made sure we are reusing HttpClients and that the DBContext objects are scoped honestly I don't think it is a memory leak from changes in our code. Moreover the app was running on the same environment with the same user load for roughly a year without problems. We make deployments regularly but let's say it could be running continuously for two weeks.

After the upgrade it consumes 6GB of ram for several hours and then crashes with OOM (actually the whole server crashes). The strange thing is that the memory used by the app goes up and barely goes down even in idle times. It's like barely anything gets released.

Looking at memory snapshots I can see a lot of memory cache collections growing big many of them used by entity framework and the Json.Net lib.

I'm sure that all that memory caching improves performance but my assumption is that the app should trade off performance for memory use based on the params of the system. Also it seems like the GC doesn't release memory but I'm not very familiar with how its implemented. I wonder why it used to work fine with 1.1. We are using supervisor to start and motor the service not sure if it matters but this is also not new.

Is there some important configuration I could be missing to tell the system how much in-memory caching it could do?

Checked a few issues which might be related but none seemed to offer a solution so far and I was not sure which is the 'most' related so I created this one. 

Possibly related:
https://github.com/dotnet/coreclr/issues/18044
https://github.com/dotnet/coreclr/issues/5551
https://github.com/aspnet/Home/issues/1976 (similar to what danports describes here and we are also considering downgrading after days of struggle) 

I noticed that most people reporting the problem are reporting it with web api projects. We have another dot net MVC app running on that machine which doesn't seem to have the problem but it has a significantly lower load the API is just faster to exhaust the memory.
</Description>
    <Title_Description>ASP.NET core web API - OOM on Ubuntu after upgrade to 2.1. We have a .net core web API running on AWS Ubuntu 16.04 VM.
The API is using EF to query a relatively small DB and makes a lot of external requests due to integrations with other systems. After we upgraded to 2.1. we started to have serious OOM problems on production.  During the upgrade we haven't changed much in our execution logic aside from the changes needed to support the changes in the APIs. I made sure we are reusing HttpClients and that the DBContext objects are scoped honestly I don't think it is a memory leak from changes in our code. Moreover the app was running on the same environment with the same user load for roughly a year without problems. We make deployments regularly but let's say it could be running continuously for two weeks.

After the upgrade it consumes 6GB of ram for several hours and then crashes with OOM (actually the whole server crashes). The strange thing is that the memory used by the app goes up and barely goes down even in idle times. It's like barely anything gets released.

Looking at memory snapshots I can see a lot of memory cache collections growing big many of them used by entity framework and the Json.Net lib.

I'm sure that all that memory caching improves performance but my assumption is that the app should trade off performance for memory use based on the params of the system. Also it seems like the GC doesn't release memory but I'm not very familiar with how its implemented. I wonder why it used to work fine with 1.1. We are using supervisor to start and motor the service not sure if it matters but this is also not new.

Is there some important configuration I could be missing to tell the system how much in-memory caching it could do?

Checked a few issues which might be related but none seemed to offer a solution so far and I was not sure which is the 'most' related so I created this one. 

Possibly related:
https://github.com/dotnet/coreclr/issues/18044
https://github.com/dotnet/coreclr/issues/5551
https://github.com/aspnet/Home/issues/1976 (similar to what danports describes here and we are also considering downgrading after days of struggle) 

I noticed that most people reporting the problem are reporting it with web api projects. We have another dot net MVC app running on that machine which doesn't seem to have the problem but it has a significantly lower load the API is just faster to exhaust the memory.
</Title_Description>
    <Label>area-GC</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>20/06/2018 7:24:18 PM +00:00</CreatedAt>
    <ClosedAt>18/04/2019 12:33:17 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18576</IssueLabelID>
    <Title>Mirror changes from Anipik/ corefx</Title>
    <Description>This PR contains mirrored changes from Anipik/ corefx


**Please REBASE this PR when merging**</Description>
    <Title_Description>Mirror changes from Anipik/ corefx This PR contains mirrored changes from Anipik/ corefx


**Please REBASE this PR when merging**</Title_Description>
    <Label>
    </Label>
    <Assignee>Anipik</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18572</IssueLabelID>
    <Title>Port Fix handling of generating relative path to parent (#18460)</Title>
    <Description>Port of #18460

Fixes #30263</Description>
    <Title_Description>Port Fix handling of generating relative path to parent (#18460) Port of #18460

Fixes #30263</Title_Description>
    <Label>area-System.IO</Label>
    <Assignee>JeremyKuhne</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18565</IssueLabelID>
    <Title>Timeout build failures in 'prodcon/coreclr/release/2.1/' - '20180620.01'</Title>
    <Description>There were a set of failures during this build. Here is a summary of these:
* https://devdiv.visualstudio.com/DefaultCollection/DevDiv/_build?_a=summary&amp;buildId=1790648
  - **Agent:** DDVSOLINUXAGE003
  - **Error log:** The job running on agent DDVSOLINUXAGE003 has exceeded the maximum execution time of 90....

* https://devdiv.visualstudio.com/DefaultCollection/DevDiv/_build?_a=summary&amp;buildId=1790650
  - **Agent:** DDVSOLINUXAGE005
  - **Error log:** The job running on agent DDVSOLINUXAGE005 has exceeded the maximum execution time of 90....

@mmitche @RussKeldorph
</Description>
    <Title_Description>Timeout build failures in 'prodcon/coreclr/release/2.1/' - '20180620.01' There were a set of failures during this build. Here is a summary of these:
* https://devdiv.visualstudio.com/DefaultCollection/DevDiv/_build?_a=summary&amp;buildId=1790648
  - **Agent:** DDVSOLINUXAGE003
  - **Error log:** The job running on agent DDVSOLINUXAGE003 has exceeded the maximum execution time of 90....

* https://devdiv.visualstudio.com/DefaultCollection/DevDiv/_build?_a=summary&amp;buildId=1790650
  - **Agent:** DDVSOLINUXAGE005
  - **Error log:** The job running on agent DDVSOLINUXAGE005 has exceeded the maximum execution time of 90....

@mmitche @RussKeldorph
</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>mmitche</Assignee>
    <CreatedAt>20/06/2018 8:05:03 AM +00:00</CreatedAt>
    <ClosedAt>5/07/2018 8:50:48 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18564</IssueLabelID>
    <Title>Segmentation fault in WKS::gc_heap::mark_object_simple on Linux</Title>
    <Description>On a linux machine running CentOS  7.5.1804 and Dotnet 2.1.300 I get the following segfault:



The program runs without problems in Windows. The only native library used is System.Data.SqlClient otherwise its all no-unsafe C# code. Unfortunately I have not been successful in reproducing the bug in a smaller program and I cannot share the original program.

It's possibly (likely?) a memory corruption bug and not a GC bug as I have also experienced some weird C# exceptions (stuff that should be logically impossible).</Description>
    <Title_Description>Segmentation fault in WKS::gc_heap::mark_object_simple on Linux On a linux machine running CentOS  7.5.1804 and Dotnet 2.1.300 I get the following segfault:



The program runs without problems in Windows. The only native library used is System.Data.SqlClient otherwise its all no-unsafe C# code. Unfortunately I have not been successful in reproducing the bug in a smaller program and I cannot share the original program.

It's possibly (likely?) a memory corruption bug and not a GC bug as I have also experienced some weird C# exceptions (stuff that should be logically impossible).</Title_Description>
    <Label>question</Label>
    <Assignee>Maoni0</Assignee>
    <CreatedAt>20/06/2018 7:06:59 AM +00:00</CreatedAt>
    <ClosedAt>11/01/2019 9:42:07 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18562</IssueLabelID>
    <Title>R2R Dumper treats READYTORUN_SECTION_RUNTIME_FUNCTIONS as required</Title>
    <Description>Currently the dumper requires READYTORUN_SECTION_RUNTIME_FUNCTIONS section to be present. It is actually optional - see https://github.com/dotnet/coreclr/blob/master/src/vm/readytoruninfo.cpp#L551

We should handle the case where it's missing gracefully in r2rdump.</Description>
    <Title_Description>R2R Dumper treats READYTORUN_SECTION_RUNTIME_FUNCTIONS as required Currently the dumper requires READYTORUN_SECTION_RUNTIME_FUNCTIONS section to be present. It is actually optional - see https://github.com/dotnet/coreclr/blob/master/src/vm/readytoruninfo.cpp#L551

We should handle the case where it's missing gracefully in r2rdump.</Title_Description>
    <Label>area-ReadyToRun</Label>
    <Assignee>acmyu</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18560</IssueLabelID>
    <Title>GC.GetAllocatedBytesForCurrentThread always returns 0 when processor affinity is set to single proc</Title>
    <Description>When the processor affinity is set in explicit way 

@jkotas @Maoni0 is this expected behavior? am I doing something wrong? 

I am porting CoreCLR benchmarks from xunit-performance to BenchmarkDotNet and I have faced this issue today when I was comparing the results of some unstable benchmarks with affinity set and without.

/cc @jorive 
</Description>
    <Title_Description>GC.GetAllocatedBytesForCurrentThread always returns 0 when processor affinity is set to single proc When the processor affinity is set in explicit way 

@jkotas @Maoni0 is this expected behavior? am I doing something wrong? 

I am porting CoreCLR benchmarks from xunit-performance to BenchmarkDotNet and I have faced this issue today when I was comparing the results of some unstable benchmarks with affinity set and without.

/cc @jorive 
</Title_Description>
    <Label>area-GC</Label>
    <Assignee>VSadov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18559</IssueLabelID>
    <Title>Mirror changes from Anipik/ corefx</Title>
    <Description>This PR contains mirrored changes from Anipik/ corefx


**Please REBASE this PR when merging**</Description>
    <Title_Description>Mirror changes from Anipik/ corefx This PR contains mirrored changes from Anipik/ corefx


**Please REBASE this PR when merging**</Title_Description>
    <Label>
    </Label>
    <Assignee>Anipik</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18558</IssueLabelID>
    <Title>Mirror changes from Anipik/ corefx</Title>
    <Description>This PR contains mirrored changes from Anipik/ corefx


**Please REBASE this PR when merging**</Description>
    <Title_Description>Mirror changes from Anipik/ corefx This PR contains mirrored changes from Anipik/ corefx


**Please REBASE this PR when merging**</Title_Description>
    <Label>
    </Label>
    <Assignee>Anipik</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18557</IssueLabelID>
    <Title>Mirror changes from dotnet/corefx</Title>
    <Description>This PR contains mirrored changes from dotnet/corefx


**Please REBASE this PR when merging**</Description>
    <Title_Description>Mirror changes from dotnet/corefx This PR contains mirrored changes from dotnet/corefx


**Please REBASE this PR when merging**</Title_Description>
    <Label>
    </Label>
    <Assignee>ViktorHofer</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18554</IssueLabelID>
    <Title>Mirror changes from Anipik/ corefx</Title>
    <Description>This PR contains mirrored changes from Anipik/ corefx


**Please REBASE this PR when merging**</Description>
    <Title_Description>Mirror changes from Anipik/ corefx This PR contains mirrored changes from Anipik/ corefx


**Please REBASE this PR when merging**</Title_Description>
    <Label>
    </Label>
    <Assignee>Anipik</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18553</IssueLabelID>
    <Title>SSE2 Insert (pinsrw) has incorrect encoding on containment form</Title>
    <Description>SSE2 .

SSE4.1 Insert works fine and this bug seems introduced from the recent containment change.

I will look into this issue. cc @CarolEidt @tannergooding </Description>
    <Title_Description>SSE2 Insert (pinsrw) has incorrect encoding on containment form SSE2 .

SSE4.1 Insert works fine and this bug seems introduced from the recent containment change.

I will look into this issue. cc @CarolEidt @tannergooding </Title_Description>
    <Label>arch-x64</Label>
    <Assignee>fiigii</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18551</IssueLabelID>
    <Title>Avoid extra allocation in IDNA</Title>
    <Description>Fixes #18545</Description>
    <Title_Description>Avoid extra allocation in IDNA Fixes #18545</Title_Description>
    <Label>area-System.Globalization</Label>
    <Assignee>stephentoub</Assignee>
    <CreatedAt>19/06/2018 6:30:02 PM +00:00</CreatedAt>
    <ClosedAt>20/06/2018 1:50:39 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18549</IssueLabelID>
    <Title>Remove sbyte overloads of Intel AES intrinsics</Title>
    <Description>Currently each </Description>
    <Title_Description>Remove sbyte overloads of Intel AES intrinsics Currently each </Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>fiigii</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18546</IssueLabelID>
    <Title>Avoid two unnecessary string.Substring calls in PunycodeDecode</Title>
    <Description>cc: @tarekgh @krwq </Description>
    <Title_Description>Avoid two unnecessary string.Substring calls in PunycodeDecode cc: @tarekgh @krwq </Title_Description>
    <Label>area-System.Globalization</Label>
    <Assignee>tarekgh</Assignee>
    <CreatedAt>19/06/2018 4:24:11 PM +00:00</CreatedAt>
    <ClosedAt>19/06/2018 9:28:33 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18545</IssueLabelID>
    <Title>GlobalizationMode.Invariant's PunycodeDecode repeatedly calling StringBuilder.ToString</Title>
    <Description>See all of these calls to  isn't changing in this region:
https://github.com/dotnet/coreclr/blob/473d9b09c7e000480f41021c94fbffeae27cb179/src/System.Private.CoreLib/shared/System/Globalization/IdnMapping.cs#L776-L806

Seems like this should either a) create the string once rather than repeatedly creating it or b) retrieve the char from the StringBuilder to test it rather than using a string and an index.  In other words worst case we should be allocating one string here best case zero.  Given the potential expense of indexing into a StringBuilder I'm not sure which ends up being faster.

cc: @tarekgh @krwq </Description>
    <Title_Description>GlobalizationMode.Invariant's PunycodeDecode repeatedly calling StringBuilder.ToString See all of these calls to  isn't changing in this region:
https://github.com/dotnet/coreclr/blob/473d9b09c7e000480f41021c94fbffeae27cb179/src/System.Private.CoreLib/shared/System/Globalization/IdnMapping.cs#L776-L806

Seems like this should either a) create the string once rather than repeatedly creating it or b) retrieve the char from the StringBuilder to test it rather than using a string and an index.  In other words worst case we should be allocating one string here best case zero.  Given the potential expense of indexing into a StringBuilder I'm not sure which ends up being faster.

cc: @tarekgh @krwq </Title_Description>
    <Label>area-System.Globalization</Label>
    <Assignee>tarekgh</Assignee>
    <CreatedAt>19/06/2018 4:16:42 PM +00:00</CreatedAt>
    <ClosedAt>20/06/2018 1:50:39 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18544</IssueLabelID>
    <Title>[Linux/arm64]  GitHub_18497 fails with assert</Title>
    <Description>

@Caroleidt To track new failure introduced in #18499</Description>
    <Title_Description>[Linux/arm64]  GitHub_18497 fails with assert 

@Caroleidt To track new failure introduced in #18499</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18543</IssueLabelID>
    <Title>Internal Error in the .NET Runtime</Title>
    <Description>Hi All
I'm not sure the right place to ask this but I could use some help.
It looks as though after an upgrade to .NET 4.7 we're having our apps randomly crash.
We're seeing errors like this:
Faulting module name: clr.dll version: 4.7.3110.0 time stamp: 0x5ae8c35b
Exception code: 0x800703e9
Fault offset: 0x002b15da
Faulting process id: 0x3110
Faulting application start time: 0x01d407cfc700c079
The process was terminated due to an internal error in the .NET Runtime at IP 72F215DA (72C70000) with exit code 800703e9.

What is the right process for getting this resolved?
</Description>
    <Title_Description>Internal Error in the .NET Runtime Hi All
I'm not sure the right place to ask this but I could use some help.
It looks as though after an upgrade to .NET 4.7 we're having our apps randomly crash.
We're seeing errors like this:
Faulting module name: clr.dll version: 4.7.3110.0 time stamp: 0x5ae8c35b
Exception code: 0x800703e9
Fault offset: 0x002b15da
Faulting process id: 0x3110
Faulting application start time: 0x01d407cfc700c079
The process was terminated due to an internal error in the .NET Runtime at IP 72F215DA (72C70000) with exit code 800703e9.

What is the right process for getting this resolved?
</Title_Description>
    <Label>question</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>19/06/2018 2:16:50 PM +00:00</CreatedAt>
    <ClosedAt>11/01/2019 9:39:35 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18542</IssueLabelID>
    <Title>Inlined Struct wrapper .ctors are non-zero cost</Title>
    <Description>(Some now fixed by https://github.com/dotnet/coreclr/pull/19429)

This is problematic for example when adding formatting and/or buffering capabilities over 

category:cq
theme:structs
skill-level:expert
cost:medium</Description>
    <Title_Description>Inlined Struct wrapper .ctors are non-zero cost (Some now fixed by https://github.com/dotnet/coreclr/pull/19429)

This is problematic for example when adding formatting and/or buffering capabilities over 

category:cq
theme:structs
skill-level:expert
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>mikedn</Assignee>
    <CreatedAt>19/06/2018 12:57:19 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18541</IssueLabelID>
    <Title>0xc0000005(Access violation) when StackOverflow happen in async path?</Title>
    <Description>Test with win10x64 netcoreapp2.1 vscode1.25(Insider)

Debug in vscode/vs. You can see app exited with 

&lt;/details&gt;</Description>
    <Title_Description>0xc0000005(Access violation) when StackOverflow happen in async path? Test with win10x64 netcoreapp2.1 vscode1.25(Insider)

Debug in vscode/vs. You can see app exited with 

&lt;/details&gt;</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>19/06/2018 12:47:01 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18539</IssueLabelID>
    <Title>Call native methods of the CLR itself from managed code</Title>
    <Description>Hi 
is it possible to call a c++ method of the program that hosts the CoreCLR from inside the loaded managed assembly?

I need to integrate a C# programm into my C++ simulation project. So I successfully set up my C++ Project to hosted the CoreCLR and I'm able to call functions from the C# Code.
Now the C# itself needs to call into the C++ Code.

I tried native calls using [DllImport] with some test library successfully. But the external method symbols should be looked up in the main programm instead of another lib like you can do with dlopen(NULL) on linux.

I have done that whole integration in mono a few month ago but as the C# code was origianaly build for .NET Core I want to go with it now.

In Mono you can use the __Internal keyword with the DllImport attribute to encounter this topic. Is there any possibility to do the same with .NETCore? 

Regards
Jens

PS: I cannot use LoadLibrary() since I'm on linux and hence cannot use the kernel32.dll</Description>
    <Title_Description>Call native methods of the CLR itself from managed code Hi 
is it possible to call a c++ method of the program that hosts the CoreCLR from inside the loaded managed assembly?

I need to integrate a C# programm into my C++ simulation project. So I successfully set up my C++ Project to hosted the CoreCLR and I'm able to call functions from the C# Code.
Now the C# itself needs to call into the C++ Code.

I tried native calls using [DllImport] with some test library successfully. But the external method symbols should be looked up in the main programm instead of another lib like you can do with dlopen(NULL) on linux.

I have done that whole integration in mono a few month ago but as the C# code was origianaly build for .NET Core I want to go with it now.

In Mono you can use the __Internal keyword with the DllImport attribute to encounter this topic. Is there any possibility to do the same with .NETCore? 

Regards
Jens

PS: I cannot use LoadLibrary() since I'm on linux and hence cannot use the kernel32.dll</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>19/06/2018 11:23:11 AM +00:00</CreatedAt>
    <ClosedAt>4/01/2019 2:28:24 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18537</IssueLabelID>
    <Title>Test failure: JIT_Regression._JitBlue_GitHub_18497_GitHub_18497_GitHub_18497_/_JitBlue_GitHub_18497_GitHub_18497_GitHub_18497_cmd</Title>
    <Description>Opened on behalf of @Sunny-pu

The test  has failed.


    
    Return code:      1
    Raw output file:      /home/helixbot/dotnetbuild/work/4ad925d1-68a5-4fb6-a02b-ec0e293a9d7b/Work/5adc0e71-0040-44e0-8eb2-8cc4d5380b66/Unzip/Reports\JIT.Regression\JitBlue\GitHub_18497\GitHub_18497\GitHub_18497.output.txt
    Raw output:
    BEGIN EXECUTION
    /home/helixbot/dotnetbuild/work/4ad925d1-68a5-4fb6-a02b-ec0e293a9d7b/Payload/corerun GitHub_18497.exe
    Failed: v = &lt;1 1 236.1857 1 1 1 1 1&gt;
    Expected: 100
    Actual: 255
    END EXECUTION - FAILED
    Test Harness Exitcode is : 1
    
    To run the test:
    &gt; set CORE_ROOT=/home/helixbot/dotnetbuild/work/4ad925d1-68a5-4fb6-a02b-ec0e293a9d7b/Payload
    &gt; /home/helixbot/dotnetbuild/work/4ad925d1-68a5-4fb6-a02b-ec0e293a9d7b/Work/5adc0e71-0040-44e0-8eb2-8cc4d5380b66/Unzip/JitBlue/GitHub_18497/GitHub_18497/GitHub_18497.sh
    
    Expected: True
    Actual:   False

        Stack Trace:

Details: 
https://mc.dot.net/#/product/netcore/master/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fcli~2F/build/20180619.01/workItem/JIT.Regression.XUnitWrapper/analysis/xunit/JIT_Regression._JitBlue_GitHub_18497_GitHub_18497_GitHub_18497_~2F_JitBlue_GitHub_18497_GitHub_18497_GitHub_18497_cmd
        
Build : Master - 20180619.01 (Core Tests)
Failing configurations:
- redhat.69.amd64-x64
  - 
- ubuntu.1804.amd64-x64
  - 
- osx.1013.amd64-x64
  - 
- redhat.73.amd64-x64
  - 
- debian.82.amd64-x64
  -</Description>
    <Title_Description>Test failure: JIT_Regression._JitBlue_GitHub_18497_GitHub_18497_GitHub_18497_/_JitBlue_GitHub_18497_GitHub_18497_GitHub_18497_cmd Opened on behalf of @Sunny-pu

The test  has failed.


    
    Return code:      1
    Raw output file:      /home/helixbot/dotnetbuild/work/4ad925d1-68a5-4fb6-a02b-ec0e293a9d7b/Work/5adc0e71-0040-44e0-8eb2-8cc4d5380b66/Unzip/Reports\JIT.Regression\JitBlue\GitHub_18497\GitHub_18497\GitHub_18497.output.txt
    Raw output:
    BEGIN EXECUTION
    /home/helixbot/dotnetbuild/work/4ad925d1-68a5-4fb6-a02b-ec0e293a9d7b/Payload/corerun GitHub_18497.exe
    Failed: v = &lt;1 1 236.1857 1 1 1 1 1&gt;
    Expected: 100
    Actual: 255
    END EXECUTION - FAILED
    Test Harness Exitcode is : 1
    
    To run the test:
    &gt; set CORE_ROOT=/home/helixbot/dotnetbuild/work/4ad925d1-68a5-4fb6-a02b-ec0e293a9d7b/Payload
    &gt; /home/helixbot/dotnetbuild/work/4ad925d1-68a5-4fb6-a02b-ec0e293a9d7b/Work/5adc0e71-0040-44e0-8eb2-8cc4d5380b66/Unzip/JitBlue/GitHub_18497/GitHub_18497/GitHub_18497.sh
    
    Expected: True
    Actual:   False

        Stack Trace:

Details: 
https://mc.dot.net/#/product/netcore/master/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fcli~2F/build/20180619.01/workItem/JIT.Regression.XUnitWrapper/analysis/xunit/JIT_Regression._JitBlue_GitHub_18497_GitHub_18497_GitHub_18497_~2F_JitBlue_GitHub_18497_GitHub_18497_GitHub_18497_cmd
        
Build : Master - 20180619.01 (Core Tests)
Failing configurations:
- redhat.69.amd64-x64
  - 
- ubuntu.1804.amd64-x64
  - 
- osx.1013.amd64-x64
  - 
- redhat.73.amd64-x64
  - 
- debian.82.amd64-x64
  -</Title_Description>
    <Label>test-run-core</Label>
    <Assignee>RussKeldorph</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18536</IssueLabelID>
    <Title>Adding types to R2R images using profiler metadata emit at ModuleLoadFinished triggers AV</Title>
    <Description>After the ModuleLoadFinished callback returns the runtime attempts to update a type loader cache called the 'AvailableClassHash'. Historically this cache was always created eagerly prior to ModuleLoadFinished being called but ReadyToRun changed the behavior to be lazy. Unfortunately the code path the profiler used to update that cache wasn't changed to account for the lazy creation so it attempts to insert into the non-existent cache and triggers an AV. I stumbled upon the issue accidentally while trying to test something else. My repro was adding a type forwarder to System.Runtime.dll but based on code review I think the issue also applies to adding new TypeDefs.
Currently 'Ready To Run' compilation is used for all framework images except System.Private.CoreLib.dll.

Callstack with the AV:

 	coreclr.dll!ClassLoader::AddExportedTypeHaveLock(Module * pManifestModule unsigned int cl AllocMemTracker * pamTracker) Line 4771	C++
 	[Inline Frame] coreclr.dll!ClassLoader::AddExportedTypeDontHaveLock(Module *) Line 4679	C++
	coreclr.dll!Assembly::AddExportedType(unsigned int cl) Line 2176	C++
 	coreclr.dll!Module::NotifyProfilerLoadFinished(HRESULT hr) Line 248	C++
 	coreclr.dll!DomainFile::PostLoadLibrary() Line 1035	C++
 	coreclr.dll!DomainFile::DoIncrementalLoad(FileLoadLevel level) Line 582	C++
 	coreclr.dll!AppDomain::TryIncrementalLoad(DomainFile * pFile FileLoadLevel workLevel Wrapper&lt;FileLoadLock *&amp;DoNothing&lt;FileLoadLock *&gt;&amp;FileLoadLock::HolderLeave0&amp;CompareDefault&lt;FileLoadLock *&gt;21&gt; &amp; lockHolder) Line 5841	C++
 	coreclr.dll!AppDomain::LoadDomainFile(FileLoadLock * pLock FileLoadLevel targetLevel) Line 5773	C++
 	coreclr.dll!AppDomain::LoadDomainAssemblyInternal(AssemblySpec * pIdentity PEAssembly * pFile FileLoadLevel targetLevel) Line 5603	C++
 	coreclr.dll!AppDomain::LoadDomainAssembly(AssemblySpec * pSpec PEAssembly * pFile FileLoadLevel targetLevel) Line 5490	C++
 	coreclr.dll!Module::LoadAssembly(AppDomain * pDomain unsigned int kAssemblyRef const char * szWinRtTypeNamespace const char * szWinRtTypeClassName) Line 5613	C++
 	coreclr.dll!Assembly::FindModuleByTypeRef(Module * pModule unsigned int tkType Loader::LoadFlag loadFlag int * pfNoResolutionScope) Line 1274	C++
 	coreclr.dll!ClassLoader::LoadTypeDefOrRefThrowing(Module * pModule unsigned int typeDefOrRef ClassLoader::NotFoundAction fNotFoundAction ClassLoader::PermitUninstantiatedFlag fUninstantiated unsigned int tokenNotToLoad ClassLoadLevel level) Line 3003	C++
 	coreclr.dll!ClassLoader::LoadApproxTypeThrowing(Module * pModule unsigned int tok SigPointer * pSigInst const SigTypeContext * pClassTypeContext) Line 3416	C++
 	[Inline Frame] coreclr.dll!ClassLoader::LoadApproxParentThrowing(Module *) Line 3462	C++
 	coreclr.dll!ClassLoader::CreateTypeHandleForTypeDefThrowing(Module * pModule unsigned int cl Instantiation inst AllocMemTracker * pamTracker) Line 11906	C++
 	coreclr.dll!ClassLoader::CreateTypeHandleForTypeKey(TypeKey * pKey AllocMemTracker * pamTracker) Line 3589	C++
 	coreclr.dll!ClassLoader::LoadTypeHandleForTypeKey_Body(TypeKey * pTypeKey TypeHandle typeHnd ClassLoadLevel targetLevel) Line 4325	C++
 	coreclr.dll!ClassLoader::LoadTypeHandleForTypeKey(TypeKey * pTypeKey TypeHandle typeHnd ClassLoadLevel targetLevel const InstantiationContext * pInstContext) Line 4044	C++
 	coreclr.dll!ClassLoader::LoadTypeDefThrowing(Module * pModule unsigned int typeDef ClassLoader::NotFoundAction fNotFoundAction ClassLoader::PermitUninstantiatedFlag fUninstantiated unsigned int tokenNotToLoad ClassLoadLevel level Instantiation * pTargetInstantiation) Line 2887	C++
 	coreclr.dll!ClassLoader::LoadTypeDefOrRefThrowing(Module * pModule unsigned int typeDefOrRef ClassLoader::NotFoundAction fNotFoundAction ClassLoader::PermitUninstantiatedFlag fUninstantiated unsigned int tokenNotToLoad ClassLoadLevel level) Line 3065	C++
 	coreclr.dll!Assembly::GetEntryPoint() Line 1918	C++
 	coreclr.dll!Assembly::ExecuteMainMethod(PtrArray * * stringArgs int) Line 1792	C++
 	coreclr.dll!CorHost2::ExecuteAssembly(unsigned long dwAppDomainId const wchar_t * pwzAssemblyPath int argc const wchar_t * * argv unsigned long * pReturnValue) Line 491	C++
 	coreclr.dll!coreclr_execute_assembly(void * hostHandle unsigned int domainId int argc const char * * argv const char * managedAssemblyPath unsigned int * exitCode) Line 407	C++
</Description>
    <Title_Description>Adding types to R2R images using profiler metadata emit at ModuleLoadFinished triggers AV After the ModuleLoadFinished callback returns the runtime attempts to update a type loader cache called the 'AvailableClassHash'. Historically this cache was always created eagerly prior to ModuleLoadFinished being called but ReadyToRun changed the behavior to be lazy. Unfortunately the code path the profiler used to update that cache wasn't changed to account for the lazy creation so it attempts to insert into the non-existent cache and triggers an AV. I stumbled upon the issue accidentally while trying to test something else. My repro was adding a type forwarder to System.Runtime.dll but based on code review I think the issue also applies to adding new TypeDefs.
Currently 'Ready To Run' compilation is used for all framework images except System.Private.CoreLib.dll.

Callstack with the AV:

 	coreclr.dll!ClassLoader::AddExportedTypeHaveLock(Module * pManifestModule unsigned int cl AllocMemTracker * pamTracker) Line 4771	C++
 	[Inline Frame] coreclr.dll!ClassLoader::AddExportedTypeDontHaveLock(Module *) Line 4679	C++
	coreclr.dll!Assembly::AddExportedType(unsigned int cl) Line 2176	C++
 	coreclr.dll!Module::NotifyProfilerLoadFinished(HRESULT hr) Line 248	C++
 	coreclr.dll!DomainFile::PostLoadLibrary() Line 1035	C++
 	coreclr.dll!DomainFile::DoIncrementalLoad(FileLoadLevel level) Line 582	C++
 	coreclr.dll!AppDomain::TryIncrementalLoad(DomainFile * pFile FileLoadLevel workLevel Wrapper&lt;FileLoadLock *&amp;DoNothing&lt;FileLoadLock *&gt;&amp;FileLoadLock::HolderLeave0&amp;CompareDefault&lt;FileLoadLock *&gt;21&gt; &amp; lockHolder) Line 5841	C++
 	coreclr.dll!AppDomain::LoadDomainFile(FileLoadLock * pLock FileLoadLevel targetLevel) Line 5773	C++
 	coreclr.dll!AppDomain::LoadDomainAssemblyInternal(AssemblySpec * pIdentity PEAssembly * pFile FileLoadLevel targetLevel) Line 5603	C++
 	coreclr.dll!AppDomain::LoadDomainAssembly(AssemblySpec * pSpec PEAssembly * pFile FileLoadLevel targetLevel) Line 5490	C++
 	coreclr.dll!Module::LoadAssembly(AppDomain * pDomain unsigned int kAssemblyRef const char * szWinRtTypeNamespace const char * szWinRtTypeClassName) Line 5613	C++
 	coreclr.dll!Assembly::FindModuleByTypeRef(Module * pModule unsigned int tkType Loader::LoadFlag loadFlag int * pfNoResolutionScope) Line 1274	C++
 	coreclr.dll!ClassLoader::LoadTypeDefOrRefThrowing(Module * pModule unsigned int typeDefOrRef ClassLoader::NotFoundAction fNotFoundAction ClassLoader::PermitUninstantiatedFlag fUninstantiated unsigned int tokenNotToLoad ClassLoadLevel level) Line 3003	C++
 	coreclr.dll!ClassLoader::LoadApproxTypeThrowing(Module * pModule unsigned int tok SigPointer * pSigInst const SigTypeContext * pClassTypeContext) Line 3416	C++
 	[Inline Frame] coreclr.dll!ClassLoader::LoadApproxParentThrowing(Module *) Line 3462	C++
 	coreclr.dll!ClassLoader::CreateTypeHandleForTypeDefThrowing(Module * pModule unsigned int cl Instantiation inst AllocMemTracker * pamTracker) Line 11906	C++
 	coreclr.dll!ClassLoader::CreateTypeHandleForTypeKey(TypeKey * pKey AllocMemTracker * pamTracker) Line 3589	C++
 	coreclr.dll!ClassLoader::LoadTypeHandleForTypeKey_Body(TypeKey * pTypeKey TypeHandle typeHnd ClassLoadLevel targetLevel) Line 4325	C++
 	coreclr.dll!ClassLoader::LoadTypeHandleForTypeKey(TypeKey * pTypeKey TypeHandle typeHnd ClassLoadLevel targetLevel const InstantiationContext * pInstContext) Line 4044	C++
 	coreclr.dll!ClassLoader::LoadTypeDefThrowing(Module * pModule unsigned int typeDef ClassLoader::NotFoundAction fNotFoundAction ClassLoader::PermitUninstantiatedFlag fUninstantiated unsigned int tokenNotToLoad ClassLoadLevel level Instantiation * pTargetInstantiation) Line 2887	C++
 	coreclr.dll!ClassLoader::LoadTypeDefOrRefThrowing(Module * pModule unsigned int typeDefOrRef ClassLoader::NotFoundAction fNotFoundAction ClassLoader::PermitUninstantiatedFlag fUninstantiated unsigned int tokenNotToLoad ClassLoadLevel level) Line 3065	C++
 	coreclr.dll!Assembly::GetEntryPoint() Line 1918	C++
 	coreclr.dll!Assembly::ExecuteMainMethod(PtrArray * * stringArgs int) Line 1792	C++
 	coreclr.dll!CorHost2::ExecuteAssembly(unsigned long dwAppDomainId const wchar_t * pwzAssemblyPath int argc const wchar_t * * argv unsigned long * pReturnValue) Line 491	C++
 	coreclr.dll!coreclr_execute_assembly(void * hostHandle unsigned int domainId int argc const char * * argv const char * managedAssemblyPath unsigned int * exitCode) Line 407	C++
</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>sywhang</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18533</IssueLabelID>
    <Title>EventSource ActivityIds not present in Release UWP (.NET Native) traces</Title>
    <Description>The attached UWP app ([ActivityIdUwp.zip](https://github.com/dotnet/coreclr/files/2113339/ActivityIdUwp.zip)) has a simple self-describing EventSource.



When you take a trace of a **debug** build of the app you will that ActivityIds are automatically computed for the stop and start events.

Event Name | Time MSec | Process Name | Rest
-- | -- | -- | --
TestEventSource/Test/Start | 13081.954 | ActivityIdUwp (10460) | ThreadID="31964" ProcessorNumber="1" ActivityID="/#10460/1/1/"
TestEventSource/Test/Stop | 13237.359 | ActivityIdUwp (10460) | ThreadID="31964" ProcessorNumber="1" DURATION_MSEC="155.405" ActivityID="/#10460/1/1/"

But when you take a trace of a **release** build of the app the activities are **not present**.

Event Name | Time MSec | Process Name | Rest
-- | -- | -- | --
TestEventSource/Test/Start | 9952.188 | ActivityIdUwp (25548) | ThreadID="30972" ProcessorNumber="0"
TestEventSource/Test/Stop | 9958.760 | ActivityIdUwp (25548) | ThreadID="30972" ProcessorNumber="0" DURATION_MSEC="6.573"

@brianrob since this could be related to issue [#18319 Classic EventSources don't work in Release builds using .NET Native (UWP)](https://github.com/dotnet/coreclr/issues/18319).

</Description>
    <Title_Description>EventSource ActivityIds not present in Release UWP (.NET Native) traces The attached UWP app ([ActivityIdUwp.zip](https://github.com/dotnet/coreclr/files/2113339/ActivityIdUwp.zip)) has a simple self-describing EventSource.



When you take a trace of a **debug** build of the app you will that ActivityIds are automatically computed for the stop and start events.

Event Name | Time MSec | Process Name | Rest
-- | -- | -- | --
TestEventSource/Test/Start | 13081.954 | ActivityIdUwp (10460) | ThreadID="31964" ProcessorNumber="1" ActivityID="/#10460/1/1/"
TestEventSource/Test/Stop | 13237.359 | ActivityIdUwp (10460) | ThreadID="31964" ProcessorNumber="1" DURATION_MSEC="155.405" ActivityID="/#10460/1/1/"

But when you take a trace of a **release** build of the app the activities are **not present**.

Event Name | Time MSec | Process Name | Rest
-- | -- | -- | --
TestEventSource/Test/Start | 9952.188 | ActivityIdUwp (25548) | ThreadID="30972" ProcessorNumber="0"
TestEventSource/Test/Stop | 9958.760 | ActivityIdUwp (25548) | ThreadID="30972" ProcessorNumber="0" DURATION_MSEC="6.573"

@brianrob since this could be related to issue [#18319 Classic EventSources don't work in Release builds using .NET Native (UWP)](https://github.com/dotnet/coreclr/issues/18319).

</Title_Description>
    <Label>area-Tracing</Label>
    <Assignee>brianrob</Assignee>
    <CreatedAt>19/06/2018 12:12:23 AM +00:00</CreatedAt>
    <ClosedAt>23/05/2019 9:40:24 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18532</IssueLabelID>
    <Title>spmi doesn't report 'BAD_CODE`</Title>
    <Description>When spmi hits an assert it shows something like: 

</Description>
    <Title_Description>spmi doesn't report 'BAD_CODE
</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>18/06/2018 8:03:45 PM +00:00</CreatedAt>
    <ClosedAt>22/08/2018 11:25:02 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18531</IssueLabelID>
    <Title>Mirror changes from dotnet/corert</Title>
    <Description>This PR contains mirrored changes from dotnet/corert


**Please REBASE this PR when merging**</Description>
    <Title_Description>Mirror changes from dotnet/corert This PR contains mirrored changes from dotnet/corert


**Please REBASE this PR when merging**</Title_Description>
    <Label>
    </Label>
    <Assignee>jkotas</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18528</IssueLabelID>
    <Title>Mirror changes from dotnet/corefx</Title>
    <Description>This PR contains mirrored changes from dotnet/corefx


**Please REBASE this PR when merging**</Description>
    <Title_Description>Mirror changes from dotnet/corefx This PR contains mirrored changes from dotnet/corefx


**Please REBASE this PR when merging**</Title_Description>
    <Label>
    </Label>
    <Assignee>jaredpar</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18527</IssueLabelID>
    <Title>Mirror changes from Anipik/ corefx</Title>
    <Description>This PR contains mirrored changes from Anipik/ corefx


**Please REBASE this PR when merging**</Description>
    <Title_Description>Mirror changes from Anipik/ corefx This PR contains mirrored changes from Anipik/ corefx


**Please REBASE this PR when merging**</Title_Description>
    <Label>
    </Label>
    <Assignee>Anipik</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18525</IssueLabelID>
    <Title>Possible JIT \ cross-gen bug in xplat in 2.2.0-preview1-26614-02 of shared runtime</Title>
    <Description>We started seeing errors during runtime Razor view compilation once we upgraded to build 

We've usually seen these sort of errors on account due to bugs in cross-gen \ JIT.</Description>
    <Title_Description>Possible JIT \ cross-gen bug in xplat in 2.2.0-preview1-26614-02 of shared runtime We started seeing errors during runtime Razor view compilation once we upgraded to build 

We've usually seen these sort of errors on account due to bugs in cross-gen \ JIT.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>18/06/2018 5:04:33 PM +00:00</CreatedAt>
    <ClosedAt>19/06/2018 2:25:24 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18522</IssueLabelID>
    <Title>Deterministic program outputs indeterministic results on Linux in release</Title>
    <Description>On Ubuntu 14.04 using current HEAD (71f4199) the following program outputs 0 in debug but seemingly random values in release. On Windows both debug and release output 0.
</Description>
    <Title_Description>Deterministic program outputs indeterministic results on Linux in release On Ubuntu 14.04 using current HEAD (71f4199) the following program outputs 0 in debug but seemingly random values in release. On Windows both debug and release output 0.
</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18521</IssueLabelID>
    <Title>Marshal.StructureToPtr() only marshals first element of an fixed-size buffer when structure is contained within a managed/non-blittable structure</Title>
    <Description>_From @kpreisser on June 17 2018 15:40_

Hi sorry if this isn't the right place to report this but I couldn't find other reports/explanations of this behavior.

I found that when using ) marshalling works correctly.

Thank you!

_Copied from original issue: dotnet/corefx#30473_</Description>
    <Title_Description>Marshal.StructureToPtr() only marshals first element of an fixed-size buffer when structure is contained within a managed/non-blittable structure _From @kpreisser on June 17 2018 15:40_

Hi sorry if this isn't the right place to report this but I couldn't find other reports/explanations of this behavior.

I found that when using ) marshalling works correctly.

Thank you!

_Copied from original issue: dotnet/corefx#30473_</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>17/06/2018 5:56:51 PM +00:00</CreatedAt>
    <ClosedAt>3/10/2018 4:32:35 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18517</IssueLabelID>
    <Title>Mirror changes from Anipik/ corefx</Title>
    <Description>This PR contains mirrored changes from Anipik/ corefx


**Please REBASE this PR when merging**</Description>
    <Title_Description>Mirror changes from Anipik/ corefx This PR contains mirrored changes from Anipik/ corefx


**Please REBASE this PR when merging**</Title_Description>
    <Label>
    </Label>
    <Assignee>Anipik</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18514</IssueLabelID>
    <Title>Mirror changes from Anipik/ corefx</Title>
    <Description>This PR contains mirrored changes from Anipik/ corefx


**Please REBASE this PR when merging**</Description>
    <Title_Description>Mirror changes from Anipik/ corefx This PR contains mirrored changes from Anipik/ corefx


**Please REBASE this PR when merging**</Title_Description>
    <Label>
    </Label>
    <Assignee>Anipik</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18513</IssueLabelID>
    <Title>Mirror changes from Anipik/ corefx</Title>
    <Description>This PR contains mirrored changes from Anipik/ corefx


**Please REBASE this PR when merging**</Description>
    <Title_Description>Mirror changes from Anipik/ corefx This PR contains mirrored changes from Anipik/ corefx


**Please REBASE this PR when merging**</Title_Description>
    <Label>
    </Label>
    <Assignee>Anipik</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18501</IssueLabelID>
    <Title>Add an aggressively-clear GC mode</Title>
    <Description>There are workstreams which have higher than average requirements about being defensive against in-memory sniffing and heapdumps.  For those customers the clear-on-use behavior of the garbage collector may be a reason that they cannot use .NET or may cause them a lot of regulatory/compliance paperwork to use .NET.

While the primary responsibility of clearing sensitive data would fall on the application there's a fair amount of platform code which makes temporaries and leaves them to the GC.  Additionally immutable types (such as .</Description>
    <Title_Description>Add an aggressively-clear GC mode There are workstreams which have higher than average requirements about being defensive against in-memory sniffing and heapdumps.  For those customers the clear-on-use behavior of the garbage collector may be a reason that they cannot use .NET or may cause them a lot of regulatory/compliance paperwork to use .NET.

While the primary responsibility of clearing sensitive data would fall on the application there's a fair amount of platform code which makes temporaries and leaves them to the GC.  Additionally immutable types (such as .</Title_Description>
    <Label>area-GC</Label>
    <Assignee>bartonjs</Assignee>
    <CreatedAt>16/06/2018 1:20:15 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18498</IssueLabelID>
    <Title>x64 Ubuntu corefx jobs are broken</Title>
    <Description>Looks like there's a netci.groovy configuration problem where we have a flow job for the Linux corefx tests but don't need them. We have both of these jobs:



So they both get triggered e.g.:

https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/x64_checked_ubuntu_corefx_baseline_flow_prtest/31/
https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/x64_checked_ubuntu_corefx_baseline_prtest/342/

but the flow job fails.

Remove the flow/tst job for this case.
</Description>
    <Title_Description>x64 Ubuntu corefx jobs are broken Looks like there's a netci.groovy configuration problem where we have a flow job for the Linux corefx tests but don't need them. We have both of these jobs:



So they both get triggered e.g.:

https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/x64_checked_ubuntu_corefx_baseline_flow_prtest/31/
https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/x64_checked_ubuntu_corefx_baseline_prtest/342/

but the flow job fails.

Remove the flow/tst job for this case.
</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>BruceForstall</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18497</IssueLabelID>
    <Title>[PMI] Assertion failed 'tree-&gt;gtHasReg()' in System.Private.CoreLib.dll</Title>
    <Description>
    </Description>
    <Title_Description>[PMI] Assertion failed 'tree-&gt;gtHasReg()' in System.Private.CoreLib.dll </Title_Description>
    <Label>arch-x64</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18491</IssueLabelID>
    <Title>Logging errors on Linux similar to Windows Event Log</Title>
    <Description>Logging unhandled exceptions to Windows Event Log was enabled with https://github.com/dotnet/coreclr/pull/16875 but currently we don't do anything on Linux. To match the diagnostics experience on Linux for .NET Core developers we should try to log exceptions to something like </Description>
    <Title_Description>Logging errors on Linux similar to Windows Event Log Logging unhandled exceptions to Windows Event Log was enabled with https://github.com/dotnet/coreclr/pull/16875 but currently we don't do anything on Linux. To match the diagnostics experience on Linux for .NET Core developers we should try to log exceptions to something like </Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>sywhang</Assignee>
    <CreatedAt>15/06/2018 8:56:27 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18490</IssueLabelID>
    <Title>RegistrationServices support?</Title>
    <Description>Following the announcement that Windows Forms and WPF will be ported to .NET Core 3.0 I have a question about some complex (but necessary) COM interop that is currently not possible on .NET Core.

Suppose the following:

* I have an application developed in .NET Core 3 that will be distributed through the Windows Store.
* This application will include shell extensions (such as a preview handler) that are exposed through AppX Packaged COM.
* Due to restrictions inherent to Packaged COM these COM-visible types must be vended as an out-of-proc server rather than an in-proc handler.

On .NET Framework I can do this using [the  to be (re)introduced to CoreCLR or alternatively to document another technique for accomplishing this? Thanks!</Description>
    <Title_Description>RegistrationServices support? Following the announcement that Windows Forms and WPF will be ported to .NET Core 3.0 I have a question about some complex (but necessary) COM interop that is currently not possible on .NET Core.

Suppose the following:

* I have an application developed in .NET Core 3 that will be distributed through the Windows Store.
* This application will include shell extensions (such as a preview handler) that are exposed through AppX Packaged COM.
* Due to restrictions inherent to Packaged COM these COM-visible types must be vended as an out-of-proc server rather than an in-proc handler.

On .NET Framework I can do this using [the  to be (re)introduced to CoreCLR or alternatively to document another technique for accomplishing this? Thanks!</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18488</IssueLabelID>
    <Title>Profiler flag to ignore NGEN doesn't seem to be working</Title>
    <Description>/cc @noahfalk 

These [comments](https://github.com/dotnet/coreclr/pull/11040#issuecomment-298004449) indicate that the flag  in CoreFx with OpenCover which does specify the flag and works when the IL version of S.P.C.dll is used instead.

If this is something that can be changed on the short run I may be able to drop some work to restore CI coverage for S.P.C.dll (Windows only).</Description>
    <Title_Description>Profiler flag to ignore NGEN doesn't seem to be working /cc @noahfalk 

These [comments](https://github.com/dotnet/coreclr/pull/11040#issuecomment-298004449) indicate that the flag  in CoreFx with OpenCover which does specify the flag and works when the IL version of S.P.C.dll is used instead.

If this is something that can be changed on the short run I may be able to drop some work to restore CI coverage for S.P.C.dll (Windows only).</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>noahfalk</Assignee>
    <CreatedAt>15/06/2018 7:53:58 PM +00:00</CreatedAt>
    <ClosedAt>16/06/2018 1:49:21 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18486</IssueLabelID>
    <Title>Double free or corruption on Raspbian</Title>
    <Description>After the move from .NETCore 2.0 to 2.1 this started happening very frequently.
PowerShell running on Raspberry Pi 3 Model B ("Raspbian GNU/Linux 9 (stretch)")
crashes with:


Can share the core file with above stack.</Description>
    <Title_Description>Double free or corruption on Raspbian After the move from .NETCore 2.0 to 2.1 this started happening very frequently.
PowerShell running on Raspberry Pi 3 Model B ("Raspbian GNU/Linux 9 (stretch)")
crashes with:


Can share the core file with above stack.</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>janvorli</Assignee>
    <CreatedAt>15/06/2018 6:14:57 PM +00:00</CreatedAt>
    <ClosedAt>28/08/2018 8:29:32 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18485</IssueLabelID>
    <Title>Fix and re-enable StructABI test</Title>
    <Description>This was disabled as part of #1928 but no issue was filed to track fixing and re-enabling it.</Description>
    <Title_Description>Fix and re-enable StructABI test This was disabled as part of #1928 but no issue was filed to track fixing and re-enabling it.</Title_Description>
    <Label>arch-x64</Label>
    <Assignee>jashook</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18482</IssueLabelID>
    <Title>Sequential structs with padding not passed correctly on Linux x64</Title>
    <Description>Repro:



Actual result:

0
3.880453E-39

Expected result:

1
10</Description>
    <Title_Description>Sequential structs with padding not passed correctly on Linux x64 Repro:



Actual result:

0
3.880453E-39

Expected result:

1
10</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18481</IssueLabelID>
    <Title>Investigate named mutexes on FreeBSD</Title>
    <Description>#18480 forced usage of flock() based implementation of named mutexes on FreeBSD. 
According to the detection phtread should work but following test was failing:

&gt; threading/NamedMutex/test1/paltest_namedmutex_test1 test:
&gt; 
&gt; Child process: 'paltest_namedmutex_test1' failed at line 357. Expression: childRunningEvent.Release()
&gt;  

this should be further investigated and understood. 
Note that there is libthr and libpthread on FreeBSD.

related to #18067
</Description>
    <Title_Description>Investigate named mutexes on FreeBSD #18480 forced usage of flock() based implementation of named mutexes on FreeBSD. 
According to the detection phtread should work but following test was failing:

&gt; threading/NamedMutex/test1/paltest_namedmutex_test1 test:
&gt; 
&gt; Child process: 'paltest_namedmutex_test1' failed at line 357. Expression: childRunningEvent.Release()
&gt;  

this should be further investigated and understood. 
Note that there is libthr and libpthread on FreeBSD.

related to #18067
</Title_Description>
    <Label>area-PAL</Label>
    <Assignee>wfurt</Assignee>
    <CreatedAt>15/06/2018 7:29:42 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18480</IssueLabelID>
    <Title>temporarily disable pthread based named mutexes on FreeBSD</Title>
    <Description>This should be further investigated.
With this change all PAL tests do pass now on FreeBSD.

related to #18067


</Description>
    <Title_Description>temporarily disable pthread based named mutexes on FreeBSD This should be further investigated.
With this change all PAL tests do pass now on FreeBSD.

related to #18067


</Title_Description>
    <Label>os-freebsd</Label>
    <Assignee>wfurt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18479</IssueLabelID>
    <Title>fixes for  sos on FreeBSD</Title>
    <Description>add missing arch specific of libunwind so sos plugin can load.
Fix code for OS thread id so it does match with what lldb see. 

With this clrstack works on FreeBSD


</Description>
    <Title_Description>fixes for  sos on FreeBSD add missing arch specific of libunwind so sos plugin can load.
Fix code for OS thread id so it does match with what lldb see. 

With this clrstack works on FreeBSD


</Title_Description>
    <Label>os-freebsd</Label>
    <Assignee>wfurt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18478</IssueLabelID>
    <Title>Question: Does profiling API support Linux?</Title>
    <Description>This was originally posted by @dotnetjt . To avoid pinging the subscribers to our announcement issue (#15136) with a potentially ongoing discussion I moved it here:

&gt; Hi @noahfalk - just wondering if the profiling API support for Linux went out in 2.1. I've been coding off and on still working against a 2.1 preview.
&gt; I fired up a new Ubuntu server and installed the 2.1 runtime and set up environment to point to my (portable) profiler library and it doesn't even attempt to load. I'm pretty sure it's not me as ldd shows that I'm not missing any libraries so all of my static linking is fine.
&gt; Only other thing I can think of is that 2.1 doesn't support it yet.

Glad you reached out and sorry its causing you trouble! Linux is fully supported ([profiler status page](https://github.com/dotnet/coreclr/blob/master/Documentation/project-docs/profiling-api-status.md)) so this should work.

If you have a repro I could help diagnose the problem or if you are set up to [debug the runtime](https://github.com/dotnet/coreclr/blob/master/Documentation/building/debugging-instructions.md) (you don't need SOS regular C++ debugging is fine) you could set a breakpoint at https://github.com/dotnet/coreclr/blob/master/src/vm/profilinghelper.cpp#L690 and then see what fails.
</Description>
    <Title_Description>Question: Does profiling API support Linux? This was originally posted by @dotnetjt . To avoid pinging the subscribers to our announcement issue (#15136) with a potentially ongoing discussion I moved it here:

&gt; Hi @noahfalk - just wondering if the profiling API support for Linux went out in 2.1. I've been coding off and on still working against a 2.1 preview.
&gt; I fired up a new Ubuntu server and installed the 2.1 runtime and set up environment to point to my (portable) profiler library and it doesn't even attempt to load. I'm pretty sure it's not me as ldd shows that I'm not missing any libraries so all of my static linking is fine.
&gt; Only other thing I can think of is that 2.1 doesn't support it yet.

Glad you reached out and sorry its causing you trouble! Linux is fully supported ([profiler status page](https://github.com/dotnet/coreclr/blob/master/Documentation/project-docs/profiling-api-status.md)) so this should work.

If you have a repro I could help diagnose the problem or if you are set up to [debug the runtime](https://github.com/dotnet/coreclr/blob/master/Documentation/building/debugging-instructions.md) (you don't need SOS regular C++ debugging is fine) you could set a breakpoint at https://github.com/dotnet/coreclr/blob/master/src/vm/profilinghelper.cpp#L690 and then see what fails.
</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>noahfalk</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18477</IssueLabelID>
    <Title>Ensure AdjustmentRule.DaylightDelta is within [-1212]</Title>
    <Description>Fixes: https://github.com/dotnet/corefx/issues/29914

Unfortunately this is not ideal way to fix this - Linux currently lacks a good way to get BaseUtcOffset and getting it is purely heuristic. This PR ensures it is at least in the [-1212] range

cc: @jskeet</Description>
    <Title_Description>Ensure AdjustmentRule.DaylightDelta is within [-12,12] Fixes: https://github.com/dotnet/corefx/issues/29914

Unfortunately this is not ideal way to fix this - Linux currently lacks a good way to get BaseUtcOffset and getting it is purely heuristic. This PR ensures it is at least in the [-1212] range

cc: @jskeet</Title_Description>
    <Label>area-System.Runtime</Label>
    <Assignee>krwq</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18476</IssueLabelID>
    <Title>Enable unloading of AssemblyLoadContext</Title>
    <Description>This change is basically the work of @xoofx done some time ago rebased
to the current master and with added fixes. 

My contributions to it were:
* Extensive testing - running all 11753 coreclr Pri1 tests loaded into
AssemblyLoadContext including their dependencies and ensuring 
that they work (except the ones that use features not yet supported 
for unloading like thread local members COM interop).
That uncovered issues listed below.
* Fix few memory leaks
* Enable unloading of assemblies with PInvokes
* Fix virtual stub manager initialization
* Fix issue with unwind info regions reporting for stub linker
* Fix misplaced assert related to statics in collectible assemblies
* Fix issue with SOS domain enumeration.
* Fixed tests that were allocating but not freeing GCHandle that
was preventing the tests from unloading.

I recommend viewing the commits separately.

There is still a lot of work to do to enable e.g. unloading of assemblies
with classes having thread local members and other stuff. But it seems
worth merging these changes in.</Description>
    <Title_Description>Enable unloading of AssemblyLoadContext This change is basically the work of @xoofx done some time ago rebased
to the current master and with added fixes. 

My contributions to it were:
* Extensive testing - running all 11753 coreclr Pri1 tests loaded into
AssemblyLoadContext including their dependencies and ensuring 
that they work (except the ones that use features not yet supported 
for unloading like thread local members COM interop).
That uncovered issues listed below.
* Fix few memory leaks
* Enable unloading of assemblies with PInvokes
* Fix virtual stub manager initialization
* Fix issue with unwind info regions reporting for stub linker
* Fix misplaced assert related to statics in collectible assemblies
* Fix issue with SOS domain enumeration.
* Fixed tests that were allocating but not freeing GCHandle that
was preventing the tests from unloading.

I recommend viewing the commits separately.

There is still a lot of work to do to enable e.g. unloading of assemblies
with classes having thread local members and other stuff. But it seems
worth merging these changes in.</Title_Description>
    <Label>area-VM</Label>
    <Assignee>janvorli</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18475</IssueLabelID>
    <Title>fix the desktop build break</Title>
    <Description>Introduced by #18346.

.
After I merge PR #18318 I will try to sync the list of warnings enabled on desktop with CoreCLR to prevent such breaks.

PTAL @dotnet/jit-contrib </Description>
    <Title_Description>fix the desktop build break Introduced by #18346.

.
After I merge PR #18318 I will try to sync the list of warnings enabled on desktop with CoreCLR to prevent such breaks.

PTAL @dotnet/jit-contrib </Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>14/06/2018 11:04:25 PM +00:00</CreatedAt>
    <ClosedAt>15/06/2018 12:44:56 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18467</IssueLabelID>
    <Title>Intermittent failures in Fma test</Title>
    <Description>I have seen a couple of failures in this test that I can't repro even with various combinations of the  flags for the various ISAs. Not sure what's going on but there's no way that changing an ARM-only #define should cause this to fail. See https://ci.dot.net/job/dotnet_coreclr/job/master/job/x86_release_windows_nt_innerloop_prtest/4371/ and also https://ci.dot.net/job/dotnet_coreclr/job/master/job/x86_release_windows_nt_innerloop_prtest/4376/

The impacted test is Windows_NT.x86.Release\JIT\HardwareIntrinsics\X86\Fma_Vector256\Fma_ro\Fma_ro.cmd

It seems to pass on retry.</Description>
    <Title_Description>Intermittent failures in Fma test I have seen a couple of failures in this test that I can't repro even with various combinations of the  flags for the various ISAs. Not sure what's going on but there's no way that changing an ARM-only #define should cause this to fail. See https://ci.dot.net/job/dotnet_coreclr/job/master/job/x86_release_windows_nt_innerloop_prtest/4371/ and also https://ci.dot.net/job/dotnet_coreclr/job/master/job/x86_release_windows_nt_innerloop_prtest/4376/

The impacted test is Windows_NT.x86.Release\JIT\HardwareIntrinsics\X86\Fma_Vector256\Fma_ro\Fma_ro.cmd

It seems to pass on retry.</Title_Description>
    <Label>arch-x86</Label>
    <Assignee>echesakovMSFT</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18465</IssueLabelID>
    <Title>Linux performance problem</Title>
    <Description>Hello.

I've spotted a performance drop on "Linux s4-srv 4.9.0-6-amd64 #1 SMP Debian 4.9.88-1+deb9u1 (2018-05-07) x86_64 GNU/Linux" compared to Windows/MacOS.

Flame graphs:
![image](https://user-images.githubusercontent.com/3522038/41411837-de9a3232-6fe6-11e8-84f5-d340475951d4.png)

Debian PerfView view:
[deb.perfView.xml.zip](https://github.com/dotnet/coreclr/files/2102298/deb.perfView.xml.zip)


It looks like locale/encoding problem but changing system locale settings (as suggested in https://github.com/dotnet/coreclr/issues/5612) helps not.

Tried on .NET Core runtimes 2.0.7 and 2.1.0.
</Description>
    <Title_Description>Linux performance problem Hello.

I've spotted a performance drop on "Linux s4-srv 4.9.0-6-amd64 #1 SMP Debian 4.9.88-1+deb9u1 (2018-05-07) x86_64 GNU/Linux" compared to Windows/MacOS.

Flame graphs:
![image](https://user-images.githubusercontent.com/3522038/41411837-de9a3232-6fe6-11e8-84f5-d340475951d4.png)

Debian PerfView view:
[deb.perfView.xml.zip](https://github.com/dotnet/coreclr/files/2102298/deb.perfView.xml.zip)


It looks like locale/encoding problem but changing system locale settings (as suggested in https://github.com/dotnet/coreclr/issues/5612) helps not.

Tried on .NET Core runtimes 2.0.7 and 2.1.0.
</Title_Description>
    <Label>area-System.Runtime</Label>
    <Assignee>mikem8361</Assignee>
    <CreatedAt>14/06/2018 12:28:56 PM +00:00</CreatedAt>
    <ClosedAt>31/01/2019 8:15:45 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18464</IssueLabelID>
    <Title>AssemblyBinding with codeBase and href : Support in CoreClr ?</Title>
    <Description>I wanted to solve problem of 

Here is sample project :

1. sf folder is console app that depends on sft library.
2. sft is strong signed.
3. sf has App.config referring to full location of sft library. Please update it to your local path.
4. hand craft sf.deps.json to remove references of sft.dll and move sft.dll to folder referred in (3).

[assemblybinding_codebase.zip](https://github.com/dotnet/coreclr/files/2101044/assemblybinding_codebase.zip)

</Description>
    <Title_Description>AssemblyBinding with codeBase and href : Support in CoreClr ? I wanted to solve problem of 

Here is sample project :

1. sf folder is console app that depends on sft library.
2. sft is strong signed.
3. sf has App.config referring to full location of sft library. Please update it to your local path.
4. hand craft sf.deps.json to remove references of sft.dll and move sft.dll to folder referred in (3).

[assemblybinding_codebase.zip](https://github.com/dotnet/coreclr/files/2101044/assemblybinding_codebase.zip)

</Title_Description>
    <Label>area-AssemblyLoader</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>14/06/2018 6:24:55 AM +00:00</CreatedAt>
    <ClosedAt>1/11/2018 5:11:28 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18463</IssueLabelID>
    <Title>Profiler rejit can break invariants in jit interface</Title>
    <Description>In CEEInfo::ScanToken we exit early if pModule is System.Private.CoreLib as a perf optimization since we expect that System.Private.CoreLib won't have any external references.

However profiler rejit can rewrite any IL including adding external references to IL in System.Private.CoreLib. In our profiler tests I observed the following chain of events.

1.  Profiler rejits System.Private.CoreLib code with calls to an external library that is not yet loaded
2.  When the code is rejitted the external library is not activated because CEEInfoScanToken exits early
3.  On the first call to the rejitted code the method from the external library is jitted and an assert fires because the module is not activated https://github.com/dotnet/coreclr/blob/6bf04a47badd74646e21e70f4e9267c71b7bfd08/src/vm/prestub.cpp#L1522

The test passes on retail but I'm afraid there may be some pathological case lurking here that can cause corruption or a crash.

Code for CEEInfo::ScanToken for reference
 https://github.com/dotnet/coreclr/blob/79b8f94cc52b6b79945074b748508a0b3cbb8be6/src/vm/jitinterface.cpp#L2801-L2884</Description>
    <Title_Description>Profiler rejit can break invariants in jit interface In CEEInfo::ScanToken we exit early if pModule is System.Private.CoreLib as a perf optimization since we expect that System.Private.CoreLib won't have any external references.

However profiler rejit can rewrite any IL including adding external references to IL in System.Private.CoreLib. In our profiler tests I observed the following chain of events.

1.  Profiler rejits System.Private.CoreLib code with calls to an external library that is not yet loaded
2.  When the code is rejitted the external library is not activated because CEEInfoScanToken exits early
3.  On the first call to the rejitted code the method from the external library is jitted and an assert fires because the module is not activated https://github.com/dotnet/coreclr/blob/6bf04a47badd74646e21e70f4e9267c71b7bfd08/src/vm/prestub.cpp#L1522

The test passes on retail but I'm afraid there may be some pathological case lurking here that can cause corruption or a crash.

Code for CEEInfo::ScanToken for reference
 https://github.com/dotnet/coreclr/blob/79b8f94cc52b6b79945074b748508a0b3cbb8be6/src/vm/jitinterface.cpp#L2801-L2884</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>davmason</Assignee>
    <CreatedAt>14/06/2018 5:32:29 AM +00:00</CreatedAt>
    <ClosedAt>15/06/2018 10:16:59 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18460</IssueLabelID>
    <Title>Fix handling of generating relative path to parent</Title>
    <Description>Addresses https://github.com/dotnet/corefx/issues/30263

Test change in CoreFX will be linked in as soon as I post the PR.</Description>
    <Title_Description>Fix handling of generating relative path to parent Addresses https://github.com/dotnet/corefx/issues/30263

Test change in CoreFX will be linked in as soon as I post the PR.</Title_Description>
    <Label>area-System.IO</Label>
    <Assignee>JeremyKuhne</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18459</IssueLabelID>
    <Title>Intrinsic for the rdpmc instruction</Title>
    <Description> intrinsic to the JIT so that it can be accessed in an efficient way. To access this functionality today the cheapest way would be to have a native function that wraps the intrinsic and pinvoke into that which for certain measurements perturbs what is being measured. But more annoyingly a new native dependency is required to achieve this.

This feature would be very valuable in getting crisp performance data from managed code directly.

category:design
theme:intrinsics
skill-level:intermediate
cost:large</Description>
    <Title_Description>Intrinsic for the rdpmc instruction  intrinsic to the JIT so that it can be accessed in an efficient way. To access this functionality today the cheapest way would be to have a native function that wraps the intrinsic and pinvoke into that which for certain measurements perturbs what is being measured. But more annoyingly a new native dependency is required to achieve this.

This feature would be very valuable in getting crisp performance data from managed code directly.

category:design
theme:intrinsics
skill-level:intermediate
cost:large</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>mjsabby</Assignee>
    <CreatedAt>13/06/2018 9:20:34 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18458</IssueLabelID>
    <Title>Add Path.Join string overloads</Title>
    <Description>coreclr part of https://github.com/dotnet/corefx/issues/30049
corefx PR are ready to go https://github.com/dotnet/corefx/compare/master...MarcoRossignoli:joinoverloads

/cc @JeremyKuhne </Description>
    <Title_Description>Add Path.Join string overloads coreclr part of https://github.com/dotnet/corefx/issues/30049
corefx PR are ready to go https://github.com/dotnet/corefx/compare/master...MarcoRossignoli:joinoverloads

/cc @JeremyKuhne </Title_Description>
    <Label>area-System.IO</Label>
    <Assignee>JeremyKuhne</Assignee>
    <CreatedAt>13/06/2018 8:32:26 PM +00:00</CreatedAt>
    <ClosedAt>14/06/2018 5:30:57 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18457</IssueLabelID>
    <Title>Fix allocation methods at few places in PAL</Title>
    <Description>In the utf8.cpp and process.cpp PAL was incorectly using the
global new operator. This results in calling this operator's
definition in coreclr runtime which is wrong. In the case
of the utf8 stuff a customer has reported a crash happening
due to that when the path from which the PAL was initialized
contained chinese characters.

The fix is to use InternalNew / InternalDelete functions instead.

I have also found that we were missing deletions of the DecoderFallbackBuffer
and EncoderFallbackBuffer so I have added them.</Description>
    <Title_Description>Fix allocation methods at few places in PAL In the utf8.cpp and process.cpp PAL was incorectly using the
global new operator. This results in calling this operator's
definition in coreclr runtime which is wrong. In the case
of the utf8 stuff a customer has reported a crash happening
due to that when the path from which the PAL was initialized
contained chinese characters.

The fix is to use InternalNew / InternalDelete functions instead.

I have also found that we were missing deletions of the DecoderFallbackBuffer
and EncoderFallbackBuffer so I have added them.</Title_Description>
    <Label>area-PAL</Label>
    <Assignee>janvorli</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18456</IssueLabelID>
    <Title>Added ISOWeek to System.Globalization</Title>
    <Description>Part of https://github.com/dotnet/corefx/issues/28933

// @tarekgh</Description>
    <Title_Description>Added ISOWeek to System.Globalization Part of https://github.com/dotnet/corefx/issues/28933

// @tarekgh</Title_Description>
    <Label>Hackathon</Label>
    <Assignee>khellang</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18455</IssueLabelID>
    <Title>Adds original error info to NotSupportedException during FileStream initialization</Title>
    <Description>Fixes #18454 

A couple of notes:
- I originally thought of throwing a Win32Exception but Win32Exception is not part of System.Private.Corelib;
- As I understand throwing a new exception type is a breaking change so instead I'm adding the error info to the current exception's InnerException
</Description>
    <Title_Description>Adds original error info to NotSupportedException during FileStream initialization Fixes #18454 

A couple of notes:
- I originally thought of throwing a Win32Exception but Win32Exception is not part of System.Private.Corelib;
- As I understand throwing a new exception type is a breaking change so instead I'm adding the error info to the current exception's InnerException
</Title_Description>
    <Label>area-System.IO</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>13/06/2018 11:10:11 AM +00:00</CreatedAt>
    <ClosedAt>14/06/2018 3:09:21 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18454</IssueLabelID>
    <Title>File.ReadAllBytes throws exception with a misleading message</Title>
    <Description># TL;DR;
The application calls 

And here's the equivalent code on .NET Core: 
https://github.com/dotnet/coreclr/blob/f4e09d1898a8eb172e5c286102ef9d1269b38666/src/System.Private.CoreLib/shared/System/IO/FileStream.Windows.cs#L57-L66

The thing is any error returned from [GetFileType](https://msdn.microsoft.com/en-us/library/windows/desktop/aa364960.aspx) is ignored. In it's place a NotSupportedException with a fixed (and possibly misleading) message is thrown making it harder to troubleshoot real cause of the exception.
</Description>
    <Title_Description>File.ReadAllBytes throws exception with a misleading message # TL;DR;
The application calls 

And here's the equivalent code on .NET Core: 
https://github.com/dotnet/coreclr/blob/f4e09d1898a8eb172e5c286102ef9d1269b38666/src/System.Private.CoreLib/shared/System/IO/FileStream.Windows.cs#L57-L66

The thing is any error returned from [GetFileType](https://msdn.microsoft.com/en-us/library/windows/desktop/aa364960.aspx) is ignored. In it's place a NotSupportedException with a fixed (and possibly misleading) message is thrown making it harder to troubleshoot real cause of the exception.
</Title_Description>
    <Label>area-System.IO</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>13/06/2018 10:57:23 AM +00:00</CreatedAt>
    <ClosedAt>14/06/2018 3:09:21 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18453</IssueLabelID>
    <Title>JIT: don't track arg and local and temp ref classes in minopts or debug mode</Title>
    <Description>If the jit is not optimizing it doesn't need to ask the runtime for the declared types for ref class arguments and locals. Just knowing they are of  can become no-ops in minopts and debug modes.

category:throughput
theme:minopts
skill-level:expert
cost:large</Description>
    <Title_Description>JIT: don't track arg and local and temp ref classes in minopts or debug mode If the jit is not optimizing it doesn't need to ask the runtime for the declared types for ref class arguments and locals. Just knowing they are of  can become no-ops in minopts and debug modes.

category:throughput
theme:minopts
skill-level:expert
cost:large</Title_Description>
    <Label>JitThroughput</Label>
    <Assignee>AndyAyersMS</Assignee>
    <CreatedAt>13/06/2018 8:26:59 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18452</IssueLabelID>
    <Title>Perfcollect issue while executing perf script (kubernetes engine)</Title>
    <Description>Hi

First of all my workload is on Kubernetes engine. We run our pods on  

Does anyone has faced this issue ?

Thank you.</Description>
    <Title_Description>Perfcollect issue while executing perf script (kubernetes engine) Hi

First of all my workload is on Kubernetes engine. We run our pods on  

Does anyone has faced this issue ?

Thank you.</Title_Description>
    <Label>area-Tracing</Label>
    <Assignee>brianrob</Assignee>
    <CreatedAt>13/06/2018 6:05:29 AM +00:00</CreatedAt>
    <ClosedAt>4/04/2019 11:05:27 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18451</IssueLabelID>
    <Title>moving ARM HW Intrinsics files to shared partition</Title>
    <Description>As requested in https://github.com/dotnet/coreclr/pull/18427#discussion_r194609717 moving arm64 HWIntrinsics to shared partition.

Related to: #15922

cc: @eerhardt @tannergooding @sdmaclea @CarolEidt</Description>
    <Title_Description>moving ARM HW Intrinsics files to shared partition As requested in https://github.com/dotnet/coreclr/pull/18427#discussion_r194609717 moving arm64 HWIntrinsics to shared partition.

Related to: #15922

cc: @eerhardt @tannergooding @sdmaclea @CarolEidt</Title_Description>
    <Label>
    </Label>
    <Assignee>maryamariyan</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18450</IssueLabelID>
    <Title>Binding duplicated handle to ThreadPool fails?</Title>
    <Description>When I run the following code I get a System.ArgumentException: ''handle' has already been bound to the thread pool or was not opened for asynchronous I/O.'

This seems weird since it is a copy of the handle bound and it is definitely opened for async I/O. From a glance it looks like the error ultimately comes from CreateIoCompletionPort but that is weird because the documentation implies that you can use DuplicateHandle to share a handle registered to an IO completion port:

&gt; It is best not to share a file handle associated with an I/O completion port by using either handle inheritance or a call to the DuplicateHandle function. Operations performed with such duplicate handles generate completion notifications. Careful consideration is advised.

Is the framework doing something funky here or is the reality more complicated than the documentation for CreateIoCompletionPort would lead you to think?



This is tested on dotnet core 2.1.30 and Windows 10.0.17686.1003.</Description>
    <Title_Description>Binding duplicated handle to ThreadPool fails? When I run the following code I get a System.ArgumentException: ''handle' has already been bound to the thread pool or was not opened for asynchronous I/O.'

This seems weird since it is a copy of the handle bound and it is definitely opened for async I/O. From a glance it looks like the error ultimately comes from CreateIoCompletionPort but that is weird because the documentation implies that you can use DuplicateHandle to share a handle registered to an IO completion port:

&gt; It is best not to share a file handle associated with an I/O completion port by using either handle inheritance or a call to the DuplicateHandle function. Operations performed with such duplicate handles generate completion notifications. Careful consideration is advised.

Is the framework doing something funky here or is the reality more complicated than the documentation for CreateIoCompletionPort would lead you to think?



This is tested on dotnet core 2.1.30 and Windows 10.0.17686.1003.</Title_Description>
    <Label>area-System.IO</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>13/06/2018 4:06:53 AM +00:00</CreatedAt>
    <ClosedAt>31/01/2019 4:51:51 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18448</IssueLabelID>
    <Title>System.BadImageFormatException: 'Bad IL format.'</Title>
    <Description>@atpyk commented on [Wed May 30 2018](https://github.com/dotnet/core/issues/1622)


I've upgraded dotnetcore2.0 to 2.1 and upgraded all packages too.
When I startup my web application the exception prompts.

StackTrace:
   at Microsoft.AspNetCore.Hosting.WebHostBuilder.BuildCommonServices(AggregateException&amp; hostingStartupErrors)
   at Microsoft.AspNetCore.Hosting.WebHostBuilder.Build()
   at GrapeLEAF.AdminService.Program.BuildWebHost(String[] args) in E:\workspace\dotnet\XXX\XXX.AdminService\XXX.AdminService\Program.cs:line 16
   at GrapeLEAF.AdminService.Program.Main(String[] args) in E:\workspace\dotnet\XXX\XXX.AdminService\XXX.AdminService\Program.cs:line 12


---

@atpyk commented on [Thu May 31 2018](https://github.com/dotnet/core/issues/1622#issuecomment-393436939)

I uninstall original .net core sdk and runtime; and reinstall VS2017 and 2.1 sdk. 
I create a new webapi application by scaffold it doesn't work.


---

@VladislavAntonyuk commented on [Thu May 31 2018](https://github.com/dotnet/core/issues/1622#issuecomment-393459163)

https://blogs.msdn.microsoft.com/webdev/2018/05/07/asp-net-core-2-1-0-rc1-now-available/

---

@atpyk commented on [Thu May 31 2018](https://github.com/dotnet/core/issues/1622#issuecomment-393465743)

So sad it doesn't work too.

---

@VladislavAntonyuk commented on [Thu May 31 2018](https://github.com/dotnet/core/issues/1622#issuecomment-393482909)

Make sure you have installed the latest VS and try to reinstall .net core.
Roolback your changes to .net core 2.0 and follow the instruction I have sent you

---

@atpyk commented on [Thu May 31 2018](https://github.com/dotnet/core/issues/1622#issuecomment-393746933)

I debug into Microsoft.AspNetCore.Hosting and find out the error line:
 var hostingServices = BuildCommonServices(out var hostingStartupErrors);

It will throw the exception: 'Bad IL format.'

But if I rename this method to BuildCommonServices111 or other It works.
So weird~
It seems like the namespace "Microsoft.AspNetCore.Hosting"  conflicts with others the .net runtime involves dlls of different version at same time.

---

@VladislavAntonyuk commented on [Fri Jun 01 2018](https://github.com/dotnet/core/issues/1622#issuecomment-393803561)

make sure you have installed version 2.1.300 and try to uninstall all previous versions. Also doublecheck you have finished all steps in the instruction I've sent you 

---

@atpyk commented on [Fri Jun 01 2018](https://github.com/dotnet/core/issues/1622#issuecomment-393810220)

I have reinstall my OS it works.
Thanks.

---

@mangod3 commented on [Sat Jun 02 2018](https://github.com/dotnet/core/issues/1622#issuecomment-394127431)

Did you have NewRelic monitoring your .net app by any chance when you ran into the issue?

---

@Merurino commented on [Sun Jun 03 2018](https://github.com/dotnet/core/issues/1622#issuecomment-394201129)

@mangod3 I was about to comment here. My issue seemed to be Newrelic. Was returning the IL issue. I was building it and running it on docker.



---

@mangod3 commented on [Sun Jun 03 2018](https://github.com/dotnet/core/issues/1622#issuecomment-394224256)

@Merurino Thanks for responding. After debugging the issue it looks like the 2.1 changes related to code versioning (https://github.com/dotnet/coreclr/blob/master/Documentation/design-docs/code-versioning-profiler-breaking-changes.md) are causing issues with profiling APIs. @noahfalk who should we follow up with to get this investigated looks like the ILHeader is not getting initialized correctly after updating a method IL using SetILFunctionBody

---

@noahfalk commented on [Mon Jun 04 2018](https://github.com/dotnet/core/issues/1622#issuecomment-394493650)

 Sorry you are running into trouble! Feel free to start with me as the investigator and I can pull in others as needed. To help get us started:
1) Could you post steps I can follow to try reproducing the problem?
2) Can you let me know what you observed while debugging that lead you to your conclusions?

---

@mangod3 commented on [Mon Jun 04 2018](https://github.com/dotnet/core/issues/1622#issuecomment-394511301)

Thanks for your response @noahfalk. Will package up a repro and send over email. 

---

@joseclament commented on [Wed Jun 06 2018](https://github.com/dotnet/core/issues/1622#issuecomment-395119603)

I have a web job built on netcoreapp2.1 console application targeting the win10-x64 and getting the  "Unhandled Exception: System.BadImageFormatException: Could not load file or assembly exception". 
I haven't had any issue with locally. Deployed using the visual studio directly to the app service. Any thoughts?

---

@noahfalk commented on [Wed Jun 06 2018](https://github.com/dotnet/core/issues/1622#issuecomment-395221204)

@joseclament - Are you aware of any .NET profiler or monitoring agent being used in your deployment environment? If not we should probably a open a new issue because there would be a decent chance that the root cause for you will be unrelated to the root cause here.

---

@joseclament commented on [Thu Jun 07 2018](https://github.com/dotnet/core/issues/1622#issuecomment-395337310)

@noahfalk  I am using AppInsight to push the logs other than no profiling or tooling.
Let me know if I need to open a new issue.


---

@nil4 commented on [Thu Jun 07 2018](https://github.com/dotnet/core/issues/1622#issuecomment-395442460)

@noahfalk I am seeing a similar issue using the [AppDynamics .NET Core profiler agent](https://docs.appdynamics.com/display/PRO44/Install+the+.NET+Core+Microservices+Agent+for+Windows) on a netcoreapp2.1 application and .NET Core SDK 2.1.300. 

When the application starts the following exception is thrown:



---

@noahfalk commented on [Thu Jun 07 2018](https://github.com/dotnet/core/issues/1622#issuecomment-395550918)

@joseclament - Glad you were able to get the bottom of it and very appreciated that you came back to post your findings in case others hit the same issue in the future! Indeed it looks like your issue had a similar symptom but different root cause than the other ones here. I created #1670 to track any further work there.

@nil4 - Thanks for the repro! Let me try repro your issue so we can figure out if this is the same root cause or something else. 

---

@noahfalk commented on [Thu Jun 07 2018](https://github.com/dotnet/core/issues/1622#issuecomment-395614005)

@nil4 - Thanks I was able to reproduce the problem easily using your excellent instructions! Although the AppDynamics issue is slighly different than the NewRelic one (AppDynamics does not call ICorProfilerInfo::SetILFunctionBody or ICorProfilerFunctionControl::SetILFunctionBody)  the fix I submitted earlier today (#18322) does solve both issues at the same time.

I wasn't sure if you were an employee with AppDynamics or a customer of AppDynamics? For potential short term resolutions to the issue you could either continue to use .Net Core 2.0 or use a daily build of .Net Core that has this fix as soon as the installers are ready for download (I'll write back again when they are). A little further in the future I'm attempting to get this fix into the official servicing releases for 2.1. I can also try to reach out to AppDynamics to see if there are any additional solutions available for the issue.

Let me know if you've got any other questions or concerns?

---

@nil4 commented on [Fri Jun 08 2018](https://github.com/dotnet/core/issues/1622#issuecomment-395689332)

@noahfalk glad I could help and thank you for the update much appreciated! I am a customer and have opened an AppDynamics support ticket about this; will update it shortly with a link to this issue.

</Description>
    <Title_Description>System.BadImageFormatException: 'Bad IL format.' @atpyk commented on [Wed May 30 2018](https://github.com/dotnet/core/issues/1622)


I've upgraded dotnetcore2.0 to 2.1 and upgraded all packages too.
When I startup my web application the exception prompts.

StackTrace:
   at Microsoft.AspNetCore.Hosting.WebHostBuilder.BuildCommonServices(AggregateException&amp; hostingStartupErrors)
   at Microsoft.AspNetCore.Hosting.WebHostBuilder.Build()
   at GrapeLEAF.AdminService.Program.BuildWebHost(String[] args) in E:\workspace\dotnet\XXX\XXX.AdminService\XXX.AdminService\Program.cs:line 16
   at GrapeLEAF.AdminService.Program.Main(String[] args) in E:\workspace\dotnet\XXX\XXX.AdminService\XXX.AdminService\Program.cs:line 12


---

@atpyk commented on [Thu May 31 2018](https://github.com/dotnet/core/issues/1622#issuecomment-393436939)

I uninstall original .net core sdk and runtime; and reinstall VS2017 and 2.1 sdk. 
I create a new webapi application by scaffold it doesn't work.


---

@VladislavAntonyuk commented on [Thu May 31 2018](https://github.com/dotnet/core/issues/1622#issuecomment-393459163)

https://blogs.msdn.microsoft.com/webdev/2018/05/07/asp-net-core-2-1-0-rc1-now-available/

---

@atpyk commented on [Thu May 31 2018](https://github.com/dotnet/core/issues/1622#issuecomment-393465743)

So sad it doesn't work too.

---

@VladislavAntonyuk commented on [Thu May 31 2018](https://github.com/dotnet/core/issues/1622#issuecomment-393482909)

Make sure you have installed the latest VS and try to reinstall .net core.
Roolback your changes to .net core 2.0 and follow the instruction I have sent you

---

@atpyk commented on [Thu May 31 2018](https://github.com/dotnet/core/issues/1622#issuecomment-393746933)

I debug into Microsoft.AspNetCore.Hosting and find out the error line:
 var hostingServices = BuildCommonServices(out var hostingStartupErrors);

It will throw the exception: 'Bad IL format.'

But if I rename this method to BuildCommonServices111 or other It works.
So weird~
It seems like the namespace "Microsoft.AspNetCore.Hosting"  conflicts with others the .net runtime involves dlls of different version at same time.

---

@VladislavAntonyuk commented on [Fri Jun 01 2018](https://github.com/dotnet/core/issues/1622#issuecomment-393803561)

make sure you have installed version 2.1.300 and try to uninstall all previous versions. Also doublecheck you have finished all steps in the instruction I've sent you 

---

@atpyk commented on [Fri Jun 01 2018](https://github.com/dotnet/core/issues/1622#issuecomment-393810220)

I have reinstall my OS it works.
Thanks.

---

@mangod3 commented on [Sat Jun 02 2018](https://github.com/dotnet/core/issues/1622#issuecomment-394127431)

Did you have NewRelic monitoring your .net app by any chance when you ran into the issue?

---

@Merurino commented on [Sun Jun 03 2018](https://github.com/dotnet/core/issues/1622#issuecomment-394201129)

@mangod3 I was about to comment here. My issue seemed to be Newrelic. Was returning the IL issue. I was building it and running it on docker.



---

@mangod3 commented on [Sun Jun 03 2018](https://github.com/dotnet/core/issues/1622#issuecomment-394224256)

@Merurino Thanks for responding. After debugging the issue it looks like the 2.1 changes related to code versioning (https://github.com/dotnet/coreclr/blob/master/Documentation/design-docs/code-versioning-profiler-breaking-changes.md) are causing issues with profiling APIs. @noahfalk who should we follow up with to get this investigated looks like the ILHeader is not getting initialized correctly after updating a method IL using SetILFunctionBody

---

@noahfalk commented on [Mon Jun 04 2018](https://github.com/dotnet/core/issues/1622#issuecomment-394493650)

 Sorry you are running into trouble! Feel free to start with me as the investigator and I can pull in others as needed. To help get us started:
1) Could you post steps I can follow to try reproducing the problem?
2) Can you let me know what you observed while debugging that lead you to your conclusions?

---

@mangod3 commented on [Mon Jun 04 2018](https://github.com/dotnet/core/issues/1622#issuecomment-394511301)

Thanks for your response @noahfalk. Will package up a repro and send over email. 

---

@joseclament commented on [Wed Jun 06 2018](https://github.com/dotnet/core/issues/1622#issuecomment-395119603)

I have a web job built on netcoreapp2.1 console application targeting the win10-x64 and getting the  "Unhandled Exception: System.BadImageFormatException: Could not load file or assembly exception". 
I haven't had any issue with locally. Deployed using the visual studio directly to the app service. Any thoughts?

---

@noahfalk commented on [Wed Jun 06 2018](https://github.com/dotnet/core/issues/1622#issuecomment-395221204)

@joseclament - Are you aware of any .NET profiler or monitoring agent being used in your deployment environment? If not we should probably a open a new issue because there would be a decent chance that the root cause for you will be unrelated to the root cause here.

---

@joseclament commented on [Thu Jun 07 2018](https://github.com/dotnet/core/issues/1622#issuecomment-395337310)

@noahfalk  I am using AppInsight to push the logs other than no profiling or tooling.
Let me know if I need to open a new issue.


---

@nil4 commented on [Thu Jun 07 2018](https://github.com/dotnet/core/issues/1622#issuecomment-395442460)

@noahfalk I am seeing a similar issue using the [AppDynamics .NET Core profiler agent](https://docs.appdynamics.com/display/PRO44/Install+the+.NET+Core+Microservices+Agent+for+Windows) on a netcoreapp2.1 application and .NET Core SDK 2.1.300. 

When the application starts the following exception is thrown:



---

@noahfalk commented on [Thu Jun 07 2018](https://github.com/dotnet/core/issues/1622#issuecomment-395550918)

@joseclament - Glad you were able to get the bottom of it and very appreciated that you came back to post your findings in case others hit the same issue in the future! Indeed it looks like your issue had a similar symptom but different root cause than the other ones here. I created #1670 to track any further work there.

@nil4 - Thanks for the repro! Let me try repro your issue so we can figure out if this is the same root cause or something else. 

---

@noahfalk commented on [Thu Jun 07 2018](https://github.com/dotnet/core/issues/1622#issuecomment-395614005)

@nil4 - Thanks I was able to reproduce the problem easily using your excellent instructions! Although the AppDynamics issue is slighly different than the NewRelic one (AppDynamics does not call ICorProfilerInfo::SetILFunctionBody or ICorProfilerFunctionControl::SetILFunctionBody)  the fix I submitted earlier today (#18322) does solve both issues at the same time.

I wasn't sure if you were an employee with AppDynamics or a customer of AppDynamics? For potential short term resolutions to the issue you could either continue to use .Net Core 2.0 or use a daily build of .Net Core that has this fix as soon as the installers are ready for download (I'll write back again when they are). A little further in the future I'm attempting to get this fix into the official servicing releases for 2.1. I can also try to reach out to AppDynamics to see if there are any additional solutions available for the issue.

Let me know if you've got any other questions or concerns?

---

@nil4 commented on [Fri Jun 08 2018](https://github.com/dotnet/core/issues/1622#issuecomment-395689332)

@noahfalk glad I could help and thank you for the update much appreciated! I am a customer and have opened an AppDynamics support ticket about this; will update it shortly with a link to this issue.

</Title_Description>
    <Label>area-TieredCompilation</Label>
    <Assignee>noahfalk</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18447</IssueLabelID>
    <Title>.Net Core and Native dll's always throw BadImageFormat</Title>
    <Description>@SharperC commented on [Sun Jun 10 2018](https://github.com/dotnet/core/issues/1678)

# BadImageFormatException everytime...

After a LOT of times trying to load native code or rather call a native method using  to switch architectures (when launching a sub-process) but until then it's a bit of a pain - https://github.com/dotnet/sdk/issues/1905

---

@SharperC commented on [Mon Jun 11 2018](https://github.com/dotnet/core/issues/1678#issuecomment-396254074)

@markusschaber I know that you mean but i tried both using a 32bit and a 64bit for c++ and dotnet and yes a already noticed that dotnet tends to totaly ignore if you set the assembly in vs to 32 bit

</Description>
    <Title_Description>.Net Core and Native dll's always throw BadImageFormat @SharperC commented on [Sun Jun 10 2018](https://github.com/dotnet/core/issues/1678)

# BadImageFormatException everytime...

After a LOT of times trying to load native code or rather call a native method using  to switch architectures (when launching a sub-process) but until then it's a bit of a pain - https://github.com/dotnet/sdk/issues/1905

---

@SharperC commented on [Mon Jun 11 2018](https://github.com/dotnet/core/issues/1678#issuecomment-396254074)

@markusschaber I know that you mean but i tried both using a 32bit and a 64bit for c++ and dotnet and yes a already noticed that dotnet tends to totaly ignore if you set the assembly in vs to 32 bit

</Title_Description>
    <Label>area-AssemblyLoader</Label>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18446</IssueLabelID>
    <Title>SUSE dotnet 2.0.3 Description: Infinite recursion during resource lookup within System.Private.CoreLib.</Title>
    <Description>@iga1976 commented on [Tue Jun 12 2018](https://github.com/dotnet/core/issues/1687)

SUSE dotnet 2.0.3 Description: Infinite recursion during resource lookup within System.Private.CoreLib. This may be a bug in System.Private.CoreLib or potentially in certain extensibility points such as assembly resolve events or CultureInfo names. Resource name: ArgumentNull_Generic 
https://github.com/dotnet/corefx/issues/30208



</Description>
    <Title_Description>SUSE dotnet 2.0.3 Description: Infinite recursion during resource lookup within System.Private.CoreLib. @iga1976 commented on [Tue Jun 12 2018](https://github.com/dotnet/core/issues/1687)

SUSE dotnet 2.0.3 Description: Infinite recursion during resource lookup within System.Private.CoreLib. This may be a bug in System.Private.CoreLib or potentially in certain extensibility points such as assembly resolve events or CultureInfo names. Resource name: ArgumentNull_Generic 
https://github.com/dotnet/corefx/issues/30208



</Title_Description>
    <Label>area-AssemblyLoader</Label>
    <Assignee>kouvel</Assignee>
    <CreatedAt>13/06/2018 3:12:40 AM +00:00</CreatedAt>
    <ClosedAt>26/10/2018 7:56:22 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18445</IssueLabelID>
    <Title>EEJitManager::SetCpuInfo is not exactly matching the ISA hierarchy described by the architecture manuals</Title>
    <Description>SSE/SSE2 support requires:
* Check for CPUID support
* Check the SSE and/or SSE2 flag

SSE3 support requires:
* Check for SSE/SSE2 support
* Check the SSE3 flag

SSSE3 support requires:
* Check for SSE/SSE2 support
* Check the SSSE3 flag

SSE4.1 support requires:
* Check for SSE/SSE2 Support
* Check for SSE3 Support
* Check for SSSE3 Support
* Check the SSE4.1 flag

SSE4.2 support requires:
* Check for SSE/SSE2 Support
* Check for SSSE3 Support
* Check for SSE4.1 Support
* Check the SSE4.2 flag

etc...</Description>
    <Title_Description>EEJitManager::SetCpuInfo is not exactly matching the ISA hierarchy described by the architecture manuals SSE/SSE2 support requires:
* Check for CPUID support
* Check the SSE and/or SSE2 flag

SSE3 support requires:
* Check for SSE/SSE2 support
* Check the SSE3 flag

SSSE3 support requires:
* Check for SSE/SSE2 support
* Check the SSSE3 flag

SSE4.1 support requires:
* Check for SSE/SSE2 Support
* Check for SSE3 Support
* Check for SSSE3 Support
* Check the SSE4.1 flag

SSE4.2 support requires:
* Check for SSE/SSE2 Support
* Check for SSSE3 Support
* Check for SSE4.1 Support
* Check the SSE4.2 flag

etc...</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>tannergooding</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18444</IssueLabelID>
    <Title>Mirror changes from dotnet/corefx</Title>
    <Description>This PR contains mirrored changes from dotnet/corefx


**Please REBASE this PR when merging**</Description>
    <Title_Description>Mirror changes from dotnet/corefx This PR contains mirrored changes from dotnet/corefx


**Please REBASE this PR when merging**</Title_Description>
    <Label>
    </Label>
    <Assignee>Anipik</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18443</IssueLabelID>
    <Title>[arm/Ubuntu] JIT/Methodical/ELEMENT_TYPE_IU/_il_relu_fld/_il_relu_fld.sh failed in gcstress</Title>
    <Description>https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_gcstress0xc_zapdisable_heapverify1_tst/12/consoleFull#-8536224876a086b3e-df04-41d2-bc4d-43e8f9406d07



I could not reproduce this failure.</Description>
    <Title_Description>[arm/Ubuntu] JIT/Methodical/ELEMENT_TYPE_IU/_il_relu_fld/_il_relu_fld.sh failed in gcstress https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_gcstress0xc_zapdisable_heapverify1_tst/12/consoleFull#-8536224876a086b3e-df04-41d2-bc4d-43e8f9406d07



I could not reproduce this failure.</Title_Description>
    <Label>GCStress</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>12/06/2018 10:55:06 PM +00:00</CreatedAt>
    <ClosedAt>12/06/2018 10:55:22 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18441</IssueLabelID>
    <Title>[arm/Ubuntu] crash under GCStress in test b65423.exe</Title>
    <Description>E.g. https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_gcstress0xc_zapdisable_tst/12/consoleFull#-5931779914b7730ef-150b-4be7-a00f-82ba6c50792b

. I've never seen it take more than 4 runs in a row to reproduce. I can't reproduce the crash under GDB.
</Description>
    <Title_Description>[arm/Ubuntu] crash under GCStress in test b65423.exe E.g. https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_gcstress0xc_zapdisable_tst/12/consoleFull#-5931779914b7730ef-150b-4be7-a00f-82ba6c50792b

. I've never seen it take more than 4 runs in a row to reproduce. I can't reproduce the crash under GDB.
</Title_Description>
    <Label>GCStress</Label>
    <Assignee>BruceForstall</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18439</IssueLabelID>
    <Title>Crash in coreclr when muxer/apphost path contains valid UTF-8 sequence</Title>
    <Description>## Steps to reproduce

On macOS 10.13 (with brew installed 

</Description>
    <Title_Description>Crash in coreclr when muxer/apphost path contains valid UTF-8 sequence ## Steps to reproduce

On macOS 10.13 (with brew installed 

</Title_Description>
    <Label>area-PAL</Label>
    <Assignee>janvorli</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18437</IssueLabelID>
    <Title>GC KeepAlive test incorrectly assumes GC activity</Title>
    <Description>tests\src\GC\API\GC\keepalive.cs is testing  function is made fully interruptible which allows for more GCStress-caused GC events.
</Description>
    <Title_Description>GC KeepAlive test incorrectly assumes GC activity tests\src\GC\API\GC\keepalive.cs is testing  function is made fully interruptible which allows for more GCStress-caused GC events.
</Title_Description>
    <Label>GCStress</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>12/06/2018 6:53:04 PM +00:00</CreatedAt>
    <ClosedAt>13/06/2018 10:04:24 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18436</IssueLabelID>
    <Title>Move SSE/SSE2 Set[All]Vector128 helpers to JIT implementation</Title>
    <Description>The current managed implementation of SSE/SSE2 ). I will look into moving them to JIT-inside implementation.

cc @CarolEidt @tannergooding </Description>
    <Title_Description>Move SSE/SSE2 Set[All]Vector128 helpers to JIT implementation The current managed implementation of SSE/SSE2 ). I will look into moving them to JIT-inside implementation.

cc @CarolEidt @tannergooding </Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>fiigii</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18434</IssueLabelID>
    <Title>Make Line numbers work for crossgened DLLs when profiling with EventPipe </Title>
    <Description>Useing the 2.1 version of .NET Core you profile a simple app .NET Core App o (e.g. a spin loop like)

Using EventPipe (e.g. set COMPlus_EnableEventPipe=1 and run the app) and then open the resulting *.netperf file you will find that PerfView's 'Goto Source' feature works in the main program attributing the cost to the correct source line.  

However if you open up frames that are inside the framework (e.g. System.TimeZoneInfo.GetLocalTimeZoneFromTzFile) you will find that while PerfView can open the source code (it can correctly find the PDBS for System.Private.Corelib.pdb and the source files on Github) but it will attribute all the cost the the first line in the method.

This is because PerfView lacks the Native-&gt;IL mapping needed to map to a particular IL instruction (which in turn can be mapped to a particular line).     These normally given to perfView by the ILToNativeMap events in the runtime.  (Normally PerfView hides these events when you look at a trace but if you pass PerfView the /keepAllEvents when the trace is converted you can see them).  

What you will find is that the mappings exist for all JIT compiled methods (at the time of JIT as well as during rundown) but there are no ILToNativeMap rundown events for DLLs that have been precompiled with Crossgen (which is most of the framework). 

We do force the rundown of all methods (DCStopVerbose) that are precompiled (that is how we know the method) but we do currently do this for the ILToNativeMap.   

Thus the most straightforward solution is to simply log the ILToNativeMap during this rundown as well.  

This will be alot of data and it may not be needed for simple investigations but I think it is best to do the simple thing (always include it) and we can talk about having options for turning it off for advanced scenarios that care about file size.   

@brianrob 


</Description>
    <Title_Description>Make Line numbers work for crossgened DLLs when profiling with EventPipe  Useing the 2.1 version of .NET Core you profile a simple app .NET Core App o (e.g. a spin loop like)

Using EventPipe (e.g. set COMPlus_EnableEventPipe=1 and run the app) and then open the resulting *.netperf file you will find that PerfView's 'Goto Source' feature works in the main program attributing the cost to the correct source line.  

However if you open up frames that are inside the framework (e.g. System.TimeZoneInfo.GetLocalTimeZoneFromTzFile) you will find that while PerfView can open the source code (it can correctly find the PDBS for System.Private.Corelib.pdb and the source files on Github) but it will attribute all the cost the the first line in the method.

This is because PerfView lacks the Native-&gt;IL mapping needed to map to a particular IL instruction (which in turn can be mapped to a particular line).     These normally given to perfView by the ILToNativeMap events in the runtime.  (Normally PerfView hides these events when you look at a trace but if you pass PerfView the /keepAllEvents when the trace is converted you can see them).  

What you will find is that the mappings exist for all JIT compiled methods (at the time of JIT as well as during rundown) but there are no ILToNativeMap rundown events for DLLs that have been precompiled with Crossgen (which is most of the framework). 

We do force the rundown of all methods (DCStopVerbose) that are precompiled (that is how we know the method) but we do currently do this for the ILToNativeMap.   

Thus the most straightforward solution is to simply log the ILToNativeMap during this rundown as well.  

This will be alot of data and it may not be needed for simple investigations but I think it is best to do the simple thing (always include it) and we can talk about having options for turning it off for advanced scenarios that care about file size.   

@brianrob 


</Title_Description>
    <Label>EventPipe</Label>
    <Assignee>brianrob</Assignee>
    <CreatedAt>12/06/2018 6:34:55 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18432</IssueLabelID>
    <Title>Mirror changes from dotnet/corert</Title>
    <Description>This PR contains mirrored changes from dotnet/corert


**Please REBASE this PR when merging**</Description>
    <Title_Description>Mirror changes from dotnet/corert This PR contains mirrored changes from dotnet/corert


**Please REBASE this PR when merging**</Title_Description>
    <Label>
    </Label>
    <Assignee>MichalStrehovsky</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18430</IssueLabelID>
    <Title>ArgumentException.Message and ParamName</Title>
    <Description>When an execption of type System.ArgumentException (or any inheritors) is thrown with paramName set it appends the text "Parameter Name: &lt;paramName&gt;" to the ArgumentException.Message (Ref [this](https://github.com/dotnet/coreclr/blob/1b32b2b795d52bd4bc00fd37efd528ef56b9d7af/src/System.Private.CoreLib/shared/System/ArgumentException.cs#L84)).

My opinion is that this "Parameter Name" addition has nothing to do in the Message property that one should only contain what's . If people want this it is possible to retrieve this using the ParamName property. Stripping it away when reading the exception is not an option since this text is localizable (e.g. "Parameternavn" in Norwegian) and thus impossible to extract in all translation variants.

So it should be removed from ArgumentException.Message however. It should be added to .ToString() override since the intention of this is to display the whole argument exception information including all parameters.

If someone really requires parameter name as a part of the ArgumentExeption.Message they should append this themselves when creating the exception.

I know that this is legacy from before .NET Core and exists in .NET Framework but I can't see why it couldn't be fixed. I suspect that this code is more copy/pasted from the .NET Framework source.
</Description>
    <Title_Description>ArgumentException.Message and ParamName When an execption of type System.ArgumentException (or any inheritors) is thrown with paramName set it appends the text "Parameter Name: &lt;paramName&gt;" to the ArgumentException.Message (Ref [this](https://github.com/dotnet/coreclr/blob/1b32b2b795d52bd4bc00fd37efd528ef56b9d7af/src/System.Private.CoreLib/shared/System/ArgumentException.cs#L84)).

My opinion is that this "Parameter Name" addition has nothing to do in the Message property that one should only contain what's . If people want this it is possible to retrieve this using the ParamName property. Stripping it away when reading the exception is not an option since this text is localizable (e.g. "Parameternavn" in Norwegian) and thus impossible to extract in all translation variants.

So it should be removed from ArgumentException.Message however. It should be added to .ToString() override since the intention of this is to display the whole argument exception information including all parameters.

If someone really requires parameter name as a part of the ArgumentExeption.Message they should append this themselves when creating the exception.

I know that this is legacy from before .NET Core and exists in .NET Framework but I can't see why it couldn't be fixed. I suspect that this code is more copy/pasted from the .NET Framework source.
</Title_Description>
    <Label>area-System.Runtime</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>12/06/2018 12:53:14 PM +00:00</CreatedAt>
    <ClosedAt>31/01/2019 8:14:41 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18429</IssueLabelID>
    <Title>Enable Tiered Compilation by default</Title>
    <Description>1) Changes the default state of the tiered compilation feature check to be ON BY DEFAULT
2) Removed comments about the source about this being a work in progress. Although it will surely continue to evolve and improve remaining issues would be better tracked in our issue tracking system with the same default presumption as other runtime features - assume it works unless noted otherwise.
3) Adjusts a number of tests and automated scripts that made assumptions that the default setting of this feature is off.
4) Stop accepting the deprecated env var COMPLUS_EXPERIMENTAL_TieredCompilation. I'm not aware it has any remaining usage but if so we're going to find out.


@kouvel @adiaaida @adamsitnik @jorive - This isn't going to work just yet (if nothing else I think a bunch of jit tests will be improperly disabled) but I hope its in the ballpark.

I've marked this NO_MERGE to ensure nobody submits it prematurely but I do plan to remove the marking and merge once the PR is green I've given broader heads up to the team that this change is incoming and everyone is ready for it.
</Description>
    <Title_Description>Enable Tiered Compilation by default 1) Changes the default state of the tiered compilation feature check to be ON BY DEFAULT
2) Removed comments about the source about this being a work in progress. Although it will surely continue to evolve and improve remaining issues would be better tracked in our issue tracking system with the same default presumption as other runtime features - assume it works unless noted otherwise.
3) Adjusts a number of tests and automated scripts that made assumptions that the default setting of this feature is off.
4) Stop accepting the deprecated env var COMPLUS_EXPERIMENTAL_TieredCompilation. I'm not aware it has any remaining usage but if so we're going to find out.


@kouvel @adiaaida @adamsitnik @jorive - This isn't going to work just yet (if nothing else I think a bunch of jit tests will be improperly disabled) but I hope its in the ballpark.

I've marked this NO_MERGE to ensure nobody submits it prematurely but I do plan to remove the marking and merge once the PR is green I've given broader heads up to the team that this change is incoming and everyone is ready for it.
</Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>kouvel</Assignee>
    <CreatedAt>12/06/2018 9:03:14 AM +00:00</CreatedAt>
    <ClosedAt>25/07/2018 2:44:04 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18428</IssueLabelID>
    <Title>Add profiling events to describe stub code generated by the runtime</Title>
    <Description>One example of the issue came up when doing some investigation on tiered jitting here: https://github.com/dotnet/coreclr/issues/18361#issuecomment-396495131
In that case we were analyzing sampled instructions and trying to attribute them to code. Several of the instructions were within Precodes and there is no ETW information that correlates this.

At a broader scope as far as I know there aren't profiling events that describe any of our generated code that doesn't come from the JIT. 

This is potentially overlapped with #12070 but that one appears to focus on missing unwind information that would be emitted for the OS to use. This issue covers names and other descriptive information that would be useful for diagnostics tools to show in the UI or to do analysis with.</Description>
    <Title_Description>Add profiling events to describe stub code generated by the runtime One example of the issue came up when doing some investigation on tiered jitting here: https://github.com/dotnet/coreclr/issues/18361#issuecomment-396495131
In that case we were analyzing sampled instructions and trying to attribute them to code. Several of the instructions were within Precodes and there is no ETW information that correlates this.

At a broader scope as far as I know there aren't profiling events that describe any of our generated code that doesn't come from the JIT. 

This is potentially overlapped with #12070 but that one appears to focus on missing unwind information that would be emitted for the OS to use. This issue covers names and other descriptive information that would be useful for diagnostics tools to show in the UI or to do analysis with.</Title_Description>
    <Label>area-TieredCompilation</Label>
    <Assignee>noahfalk</Assignee>
    <CreatedAt>12/06/2018 7:54:51 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18427</IssueLabelID>
    <Title> Move x86 HW intrinsics files to shared</Title>
    <Description>Fixes: #15922
</Description>
    <Title_Description> Move x86 HW intrinsics files to shared Fixes: #15922
</Title_Description>
    <Label>
    </Label>
    <Assignee>maryamariyan</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18426</IssueLabelID>
    <Title>[WIP][test pr] find cases when the cold part does not adjust the hot part.</Title>
    <Description>
    </Description>
    <Title_Description>[WIP][test pr] find cases when the cold part does not adjust the hot part. </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>12/06/2018 1:16:54 AM +00:00</CreatedAt>
    <ClosedAt>12/06/2018 5:35:12 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18423</IssueLabelID>
    <Title>Add public implementation FrameworkEventSourceSupport</Title>
    <Description>Add class FrameworkEventSourceSupport for S.P.WindowsRuntime to use.

corefx PR:https://github.com/dotnet/corefx/pull/30297</Description>
    <Title_Description>Add public implementation FrameworkEventSourceSupport Add class FrameworkEventSourceSupport for S.P.WindowsRuntime to use.

corefx PR:https://github.com/dotnet/corefx/pull/30297</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>luqunl</Assignee>
    <CreatedAt>11/06/2018 9:56:42 PM +00:00</CreatedAt>
    <ClosedAt>28/06/2018 2:55:47 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18422</IssueLabelID>
    <Title>Revert "Temporarily disable package signing in 2.0.0"</Title>
    <Description>Reverts dotnet/coreclr#18421

Don't merge until the 2.0.0 Publish job has signing permissions

CC @weshaggard </Description>
    <Title_Description>Revert "Temporarily disable package signing in 2.0.0" Reverts dotnet/coreclr#18421

Don't merge until the 2.0.0 Publish job has signing permissions

CC @weshaggard </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>wtgodbe</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18420</IssueLabelID>
    <Title>Make a pass to remove dead strings from mscorrc.rc</Title>
    <Description>Some strings in [mscorrc.rc](https://github.com/dotnet/coreclr/blob/master/src/dlls/mscorrc/mscorrc.rc) seem to be dead. eg
</Description>
    <Title_Description>Make a pass to remove dead strings from mscorrc.rc Some strings in [mscorrc.rc](https://github.com/dotnet/coreclr/blob/master/src/dlls/mscorrc/mscorrc.rc) seem to be dead. eg
</Title_Description>
    <Label>easy</Label>
    <Assignee>danmosemsft</Assignee>
    <CreatedAt>11/06/2018 9:40:51 PM +00:00</CreatedAt>
    <ClosedAt>27/06/2018 3:41:34 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18415</IssueLabelID>
    <Title>skip empty regMask in verifyRegistersUsed</Title>
    <Description>Fixes #18367.

To repro this issue we need to call . It means that we need an attached profiler to hit this issue.

Because the cost of the repro is higher that its expected value I have decided to push only the fix.</Description>
    <Title_Description>skip empty regMask in verifyRegistersUsed Fixes #18367.

To repro this issue we need to call . It means that we need an attached profiler to hit this issue.

Because the cost of the repro is higher that its expected value I have decided to push only the fix.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>11/06/2018 7:25:57 PM +00:00</CreatedAt>
    <ClosedAt>11/06/2018 9:29:18 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18410</IssueLabelID>
    <Title>FileNotFoundException being thrown for assemblies that are in fact present or even when loaded into AppDomain</Title>
    <Description>I have a small .NET Core app I am writing which reads all types from an assembly and the XML comments from the corresponding XML comments file. I am facing a problem with loads of **FileNotFoundException**s being thrown when a method constructor or whatever is using a type that comes from another assembly (example:  and confirmed that those assemblies were now in fact loaded into the running app... but unfortunately that also did not work... and exact the same errors were thrown.

So what do I do here?

I have extracted the important parts of the app I am writing and put them info a small demo project here: [LoadAssembliesProblem](https://github.com/gordon-matt/LoadAssembliesProblem)
&gt; **NOTE:** There are some comments in the **Program.cs** file as well.

Is this some kind of a bug or am I doing something wrong here?</Description>
    <Title_Description>FileNotFoundException being thrown for assemblies that are in fact present or even when loaded into AppDomain I have a small .NET Core app I am writing which reads all types from an assembly and the XML comments from the corresponding XML comments file. I am facing a problem with loads of **FileNotFoundException**s being thrown when a method constructor or whatever is using a type that comes from another assembly (example:  and confirmed that those assemblies were now in fact loaded into the running app... but unfortunately that also did not work... and exact the same errors were thrown.

So what do I do here?

I have extracted the important parts of the app I am writing and put them info a small demo project here: [LoadAssembliesProblem](https://github.com/gordon-matt/LoadAssembliesProblem)
&gt; **NOTE:** There are some comments in the **Program.cs** file as well.

Is this some kind of a bug or am I doing something wrong here?</Title_Description>
    <Label>area-AssemblyLoader</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>11/06/2018 12:56:45 PM +00:00</CreatedAt>
    <ClosedAt>12/06/2018 3:19:44 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18408</IssueLabelID>
    <Title>Bad codegen + Assertion failed 'varDsc-&gt;lvIsParam'</Title>
    <Description>Repro:

Compile with </Description>
    <Title_Description>Bad codegen + Assertion failed 'varDsc-&gt;lvIsParam' Repro:

Compile with </Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18407</IssueLabelID>
    <Title>Move the HWIntrinsic Load/Store operations to use GenTreeIndir nodes</Title>
    <Description>Currently the x86 Hardware Intrinsics handle the load/store operations directly. This was done both for quick bring up and in order to easily represent the various new memory operation types.

However it would be ideal if we could merge this functionality back in with the normal Indir handling that already exists.

category:implementation
theme:vector-codegen
skill-level:expert
cost:extra-large</Description>
    <Title_Description>Move the HWIntrinsic Load/Store operations to use GenTreeIndir nodes Currently the x86 Hardware Intrinsics handle the load/store operations directly. This was done both for quick bring up and in order to easily represent the various new memory operation types.

However it would be ideal if we could merge this functionality back in with the normal Indir handling that already exists.

category:implementation
theme:vector-codegen
skill-level:expert
cost:extra-large</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>tannergooding</Assignee>
    <CreatedAt>11/06/2018 1:01:44 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18406</IssueLabelID>
    <Title>Inlining and explicit tail calls</Title>
    <Description>We should re-examine the logic the jit uses for inlining in the presence of explicit tail calls (calls with a  prefix). Currently the jit won't inline any method that is explicitly tail called

https://github.com/dotnet/coreclr/blob/7e215941c8d6a68fa52f98bb8fd2a419d8a1ef5d/src/jit/importer.cpp#L18943-L18949

or any method that makes an explicit tail call:

https://github.com/dotnet/coreclr/blob/7e215941c8d6a68fa52f98bb8fd2a419d8a1ef5d/src/jit/flowgraph.cpp#L5434-L5442

Both of these should be allowed provided with reasonable checks (former: callee frame is not overly huge; latter: call site is in tail position).

category:cq
theme:tail-call
skill-level:intermediate
cost:medium</Description>
    <Title_Description>Inlining and explicit tail calls We should re-examine the logic the jit uses for inlining in the presence of explicit tail calls (calls with a  prefix). Currently the jit won't inline any method that is explicitly tail called

https://github.com/dotnet/coreclr/blob/7e215941c8d6a68fa52f98bb8fd2a419d8a1ef5d/src/jit/importer.cpp#L18943-L18949

or any method that makes an explicit tail call:

https://github.com/dotnet/coreclr/blob/7e215941c8d6a68fa52f98bb8fd2a419d8a1ef5d/src/jit/flowgraph.cpp#L5434-L5442

Both of these should be allowed provided with reasonable checks (former: callee frame is not overly huge; latter: call site is in tail position).

category:cq
theme:tail-call
skill-level:intermediate
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
    <CreatedAt>10/06/2018 4:03:12 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18405</IssueLabelID>
    <Title>Transition from .Net Framework to Coreclr : Moving from GACed Dlls</Title>
    <Description>We are porting our SDK from .NET Framework to Coreclr.

As a platform we have SDK and runtime c# dlls. Most of them are nicely segregated. However the bridge library between SDK and Runtime: A.dll is GACed in .Net Framework. Apps from SDK version X can run on cluster version Y where Y &gt;=X. So we get latest (Y) version of Dlls A always on cluster’s platform.

Problem:
There are classes in sdk dlls like SDK_A.dll which inherit from types in A.dll. So before even Main method is called A.dll is searched and found in GAC in .Net Framework. Since there is no GAC in coreclr we get FileNotFoundException for A.dll in coreclr. 

What we have tried:
1. We have tried adding AssemblyResolver to load these A.dll from Runtime folder. That does not help as exception is thrown before any code (Program’s Main) is executed.
2. We have looked at . It breaks development and packaging workflow for many developers.

What are the guidelines for library and platform writers to move there Dlls from GAC when transitioning form .Net Framework to CoreClr?
</Description>
    <Title_Description>Transition from .Net Framework to Coreclr : Moving from GACed Dlls We are porting our SDK from .NET Framework to Coreclr.

As a platform we have SDK and runtime c# dlls. Most of them are nicely segregated. However the bridge library between SDK and Runtime: A.dll is GACed in .Net Framework. Apps from SDK version X can run on cluster version Y where Y &gt;=X. So we get latest (Y) version of Dlls A always on cluster’s platform.

Problem:
There are classes in sdk dlls like SDK_A.dll which inherit from types in A.dll. So before even Main method is called A.dll is searched and found in GAC in .Net Framework. Since there is no GAC in coreclr we get FileNotFoundException for A.dll in coreclr. 

What we have tried:
1. We have tried adding AssemblyResolver to load these A.dll from Runtime folder. That does not help as exception is thrown before any code (Program’s Main) is executed.
2. We have looked at . It breaks development and packaging workflow for many developers.

What are the guidelines for library and platform writers to move there Dlls from GAC when transitioning form .Net Framework to CoreClr?
</Title_Description>
    <Label>area-AssemblyLoader</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>10/06/2018 2:18:59 PM +00:00</CreatedAt>
    <ClosedAt>9/05/2019 2:55:30 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18404</IssueLabelID>
    <Title>Added CallerArgumentExpressionAttribute (corefx issue 21809)</Title>
    <Description>Adding System.Runtime.CompilerServices.CallerArgumentExpressionAttribute to System.Private.CoreLib for [CoreFX issue 21809](https://github.com/dotnet/corefx/issues/21809).

After this addition is reflected to the System.Private.CoreLib.dll then I will expose it from System.Runtime.dll in corefx. I believe this is the proper place to add this as all other CompilerServices attributes live here but if that is not the case then please let me know.

@karelz @danmosemsft</Description>
    <Title_Description>Added CallerArgumentExpressionAttribute (corefx issue 21809) Adding System.Runtime.CompilerServices.CallerArgumentExpressionAttribute to System.Private.CoreLib for [CoreFX issue 21809](https://github.com/dotnet/corefx/issues/21809).

After this addition is reflected to the System.Private.CoreLib.dll then I will expose it from System.Runtime.dll in corefx. I believe this is the proper place to add this as all other CompilerServices attributes live here but if that is not the case then please let me know.

@karelz @danmosemsft</Title_Description>
    <Label>Hackathon</Label>
    <Assignee>jswolf19</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18403</IssueLabelID>
    <Title>Associating threadpool queues with CPU cores.</Title>
    <Description>New implementation of ThreadPool work queues as lock-free queues softly associated with CPU cores.

The implementation avoids 1:1 strict mapping between work queues and working threads which is often a far greater number than the number of cores.

This implementation improves handling of cases where the number of workers needs to exceeds the number of cores. It avoids precipitous performance drops because:
- the cost of snooping/stealing does not grow with the number of workers.
- the local queues tend to be deeper (since there are fewer of them) and thus stealing is less frequent and less contentious with enqueuing/popping.
- blocking or preempting a worker does not result in its entire work queue be only accessible through stealing.
- reduced likelihood that the workitem will have to execute on a core different from where it was scheduled.

Fixes:#19088

Also may alleviate issues as described in http://labs.criteo.com/2018/10/net-threadpool-starvation-and-how-queuing-makes-it-worse/</Description>
    <Title_Description>Associating threadpool queues with CPU cores. New implementation of ThreadPool work queues as lock-free queues softly associated with CPU cores.

The implementation avoids 1:1 strict mapping between work queues and working threads which is often a far greater number than the number of cores.

This implementation improves handling of cases where the number of workers needs to exceeds the number of cores. It avoids precipitous performance drops because:
- the cost of snooping/stealing does not grow with the number of workers.
- the local queues tend to be deeper (since there are fewer of them) and thus stealing is less frequent and less contentious with enqueuing/popping.
- blocking or preempting a worker does not result in its entire work queue be only accessible through stealing.
- reduced likelihood that the workitem will have to execute on a core different from where it was scheduled.

Fixes:#19088

Also may alleviate issues as described in http://labs.criteo.com/2018/10/net-threadpool-starvation-and-how-queuing-makes-it-worse/</Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>VSadov</Assignee>
    <CreatedAt>10/06/2018 4:02:43 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18402</IssueLabelID>
    <Title>Removed length restrictions on named synchronization primitives lengths on Windows</Title>
    <Description>Fixes https://github.com/dotnet/coreclr/issues/18370
Tests PR :- https://github.com/dotnet/corefx/pull/30243

we're letting the API kick back names that are too long rather than pre-validating them.</Description>
    <Title_Description>Removed length restrictions on named synchronization primitives lengths on Windows Fixes https://github.com/dotnet/coreclr/issues/18370
Tests PR :- https://github.com/dotnet/corefx/pull/30243

we're letting the API kick back names that are too long rather than pre-validating them.</Title_Description>
    <Label>area-System.Threading</Label>
    <Assignee>Anipik</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18401</IssueLabelID>
    <Title>C# `in` parameter modifier: Should I be able to create a delegate for a method with non-matching signature?</Title>
    <Description>While working on Moq (https://github.com/moq/moq4/pull/625) I've run into something strange: It appears that the runtime does not match signatures properly when creating delegates through e.g. 
&lt;/details&gt;
&lt;br&gt;

/cc @zvirja</Description>
    <Title_Description>C# 
&lt;/details&gt;
&lt;br&gt;

/cc @zvirja</Title_Description>
    <Label>area-System.Reflection</Label>
    <Assignee>stakx</Assignee>
    <CreatedAt>9/06/2018 6:33:28 PM +00:00</CreatedAt>
    <ClosedAt>11/06/2018 10:38:07 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18400</IssueLabelID>
    <Title>Optimize placement of VZEROUPPER</Title>
    <Description>Which rules CLR JIT uses to place VZEROUPPER and how do I opt-out ?

The live example is - one flavor of distribution sorting algorithm uses insertion sort subroutine for basic case sorting of small buckets and it gets called quite often esp. for of 2- and 3-record cases.  The insertion sort subroutine itself is highly optimized - it uses SIMD registers (XMMs in my case) HW intrinsics and just basic RSP-based stack frame for couple values. Still VZEROUPPER is generated at the beginning and at the end of subroutine which adds some perfmormance hit. There is natural desire to avoid such penalty knowing that caller will always be other CLR JITted code and all nested method invocations are inlined (checked this manually).

category:cq
theme:vector-codegen
skill-level:expert
cost:medium</Description>
    <Title_Description>Optimize placement of VZEROUPPER Which rules CLR JIT uses to place VZEROUPPER and how do I opt-out ?

The live example is - one flavor of distribution sorting algorithm uses insertion sort subroutine for basic case sorting of small buckets and it gets called quite often esp. for of 2- and 3-record cases.  The insertion sort subroutine itself is highly optimized - it uses SIMD registers (XMMs in my case) HW intrinsics and just basic RSP-based stack frame for couple values. Still VZEROUPPER is generated at the beginning and at the end of subroutine which adds some perfmormance hit. There is natural desire to avoid such penalty knowing that caller will always be other CLR JITted code and all nested method invocations are inlined (checked this manually).

category:cq
theme:vector-codegen
skill-level:expert
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>9/06/2018 11:15:27 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18399</IssueLabelID>
    <Title>StringBuidler  support Offset(int length)</Title>
    <Description>New API:
</Description>
    <Title_Description>StringBuidler  support Offset(int length) New API:
</Title_Description>
    <Label>question</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>9/06/2018 8:20:03 AM +00:00</CreatedAt>
    <ClosedAt>10/06/2018 3:57:13 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18396</IssueLabelID>
    <Title>Build fails when using enable sanitizers script</Title>
    <Description>Disclaimer:  The reason I am trying to do this is so I can run an ASAN enabled native library that I heavily use with P/Invoke.  However it seems if I don't compile coreclr with the same ASAN enabled the arguments from C# get turned into garbage on their way into C++.  If this should not the case then please inform me.

Building against the v2.1.0 tag

I'm running following the instructions I found [here](https://github.com/dotnet/coreclr/blob/master/Documentation/building/linux-instructions.md) verbatim in an ubuntu:14.04 docker container.  The build succeeds using 

(Similar error for coreconsole)</Description>
    <Title_Description>Build fails when using enable sanitizers script Disclaimer:  The reason I am trying to do this is so I can run an ASAN enabled native library that I heavily use with P/Invoke.  However it seems if I don't compile coreclr with the same ASAN enabled the arguments from C# get turned into garbage on their way into C++.  If this should not the case then please inform me.

Building against the v2.1.0 tag

I'm running following the instructions I found [here](https://github.com/dotnet/coreclr/blob/master/Documentation/building/linux-instructions.md) verbatim in an ubuntu:14.04 docker container.  The build succeeds using 

(Similar error for coreconsole)</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>9/06/2018 5:44:12 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18389</IssueLabelID>
    <Title>Fix fragility in setup-stress-dependencies infra</Title>
    <Description>E.g. https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_checked_ubuntu_innerloop_tst_prtest/3663/consoleText


</Description>
    <Title_Description>Fix fragility in setup-stress-dependencies infra E.g. https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_checked_ubuntu_innerloop_tst_prtest/3663/consoleText


</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>9/06/2018 12:24:14 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18387</IssueLabelID>
    <Title>Fix UTF8 encoding fallback index</Title>
    <Description>When falling back in UTF8 decoding we’ll call the DecoderFallbackBuffer.InternalFallback method which takes a pointer to the source bytes pointer which points to where we have progressed inside the source bytes. The problem is before calling DecoderFallbackBuffer.InternalFallback we call GetBytesUnknown which can adjust the source byte pointer and DecoderFallbackBuffer.InternalFallback needs to be called with the pointer before the adjustment. The fix is simply storing the original pointer value of the source byte pointer before calling GetBytesUnknown and then pass the stored original pointer to DecoderFallbackBuffer.InternalFallback instead of the adjusted source byte pointer

Fixes https://github.com/dotnet/corefx/issues/29898</Description>
    <Title_Description>Fix UTF8 encoding fallback index When falling back in UTF8 decoding we’ll call the DecoderFallbackBuffer.InternalFallback method which takes a pointer to the source bytes pointer which points to where we have progressed inside the source bytes. The problem is before calling DecoderFallbackBuffer.InternalFallback we call GetBytesUnknown which can adjust the source byte pointer and DecoderFallbackBuffer.InternalFallback needs to be called with the pointer before the adjustment. The fix is simply storing the original pointer value of the source byte pointer before calling GetBytesUnknown and then pass the stored original pointer to DecoderFallbackBuffer.InternalFallback instead of the adjusted source byte pointer

Fixes https://github.com/dotnet/corefx/issues/29898</Title_Description>
    <Label>
    </Label>
    <Assignee>tarekgh</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18386</IssueLabelID>
    <Title>GC Heap Compaction should clear the source data</Title>
    <Description>During GC heap compaction a copy of data is made.  In cases where there was no practical way to pin data (e.g. a returned  fields would need to use GCHandle and add a finalizer to ensure that the handle got cleared.
* A temporary copy of a secret must be cleared by the creator/owner (e.g. addition/removal of symmetric encryption padding)

If the GC can guarantee that pinning is no longer required to ensure that Span.Clear() removes the data from the heap then a good amount of defensive pinning can be eliminated from current BCL security code (theoretically reducing heap fragmentation?).</Description>
    <Title_Description>GC Heap Compaction should clear the source data During GC heap compaction a copy of data is made.  In cases where there was no practical way to pin data (e.g. a returned  fields would need to use GCHandle and add a finalizer to ensure that the handle got cleared.
* A temporary copy of a secret must be cleared by the creator/owner (e.g. addition/removal of symmetric encryption padding)

If the GC can guarantee that pinning is no longer required to ensure that Span.Clear() removes the data from the heap then a good amount of defensive pinning can be eliminated from current BCL security code (theoretically reducing heap fragmentation?).</Title_Description>
    <Label>area-GC</Label>
    <Assignee>Maoni0</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18384</IssueLabelID>
    <Title>[release/2.1] JIT: Fix bug in finally cloning caused by unsound callfinally reordering</Title>
    <Description>Port of #18348 to release 2.1.

Related issue #18332. Not a regression. This optimization was introduced
in 2.0 and the bug has been there from the beginning.

We need to make sure that if we reorder a callfinally during finally cloning
that the callfinally is actually the one being targeted by the last block in
the try range.

Linked issue has some more detailed notes.</Description>
    <Title_Description>[release/2.1] JIT: Fix bug in finally cloning caused by unsound callfinally reordering Port of #18348 to release 2.1.

Related issue #18332. Not a regression. This optimization was introduced
in 2.0 and the bug has been there from the beginning.

We need to make sure that if we reorder a callfinally during finally cloning
that the callfinally is actually the one being targeted by the last block in
the try range.

Linked issue has some more detailed notes.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18381</IssueLabelID>
    <Title>One CoreCLR 2.1 unit test is failing due to missing ThreadStartBool.sh file</Title>
    <Description>Hi

CoreCLR 2.1 unit tests are failing due to missing ThreadStartBool.sh file

&gt; How to reproduce:
&gt; 
&gt; Build the repos and the tests (release/2.1 branch)
&gt; - ./build.sh x64 release msbuildonunsupportedplatform
&gt; - ./build-test.sh release
&gt; 
&gt; Running the tests:
&gt; - tests/runtest.sh --testRootDir=/build/coreclr/bin/tests/Linux.x64.Release --testNativeBinDir=/build/coreclr/bin/obj/Linux.x64.Release/tests --coreClrBinDir=/build/coreclr/bin/Product/Linux.x64.Release --mscorlibDir=/build/coreclr/bin/Product/Linux.x64.Release --coreFxBinDir=/build/corefx/bin/runtime/netcoreapp-Linux-Release-x64



Hamza.</Description>
    <Title_Description>One CoreCLR 2.1 unit test is failing due to missing ThreadStartBool.sh file Hi

CoreCLR 2.1 unit tests are failing due to missing ThreadStartBool.sh file

&gt; How to reproduce:
&gt; 
&gt; Build the repos and the tests (release/2.1 branch)
&gt; - ./build.sh x64 release msbuildonunsupportedplatform
&gt; - ./build-test.sh release
&gt; 
&gt; Running the tests:
&gt; - tests/runtest.sh --testRootDir=/build/coreclr/bin/tests/Linux.x64.Release --testNativeBinDir=/build/coreclr/bin/obj/Linux.x64.Release/tests --coreClrBinDir=/build/coreclr/bin/Product/Linux.x64.Release --mscorlibDir=/build/coreclr/bin/Product/Linux.x64.Release --coreFxBinDir=/build/corefx/bin/runtime/netcoreapp-Linux-Release-x64



Hamza.</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>RussKeldorph</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18377</IssueLabelID>
    <Title>Initial thoughts on Native Vararg support on Unix platforms for RyuJit</Title>
    <Description>PR #18373 will re-enable __arglist (native vararg support) for coreclr; however currently only Windows platforms support the ABI. This "issue" is more of a brain dump to help any future work to allow native varargs on other currently unsupported/untested platforms. It is platform and arch specific if there are gaps in my familiarity with other platform's/arch's ABIs please let me know I will update the issue.

#
#### Unix Amd64
x64 Unix should only require using RAX to pass the number of floating point arguments passed in registers for setting up the caller function. Change the prolog to spill all the General purpose registers and FP registers. ArgIterator would need to get the next arg based on type from the stack offset.

#
#### Unix Arm64
Currently there are a fair amount of example of where we mangle the vararg type for all arm arches. See https://github.com/dotnet/coreclr/blob/master/src/jit/compiler.hpp#L2607. This and other instances of forcing the argument types away from floating point types such as https://github.com/dotnet/coreclr/blob/master/src/jit/morph.cpp#L3322 need to also be restricted to windows. In addition the prolog ([here](https://github.com/dotnet/coreclr/blob/master/src/jit/codegencommon.cpp#L3302) also assumes all arguments are passing in the general purpose registers. 

#
#### Unix arm32
Everything for Unix arm64 applies. The only difference I can see is that non-fixed args (args in the ... varargs) that are TYP_FLOAT will need to be retyped and used as if they were TYP_DOUBLE. This will require annotating the arguments with new additional information isFixedArg.

#
#### Windows arm32
This is the same ABI as arm64 varargs. Investigation needs to be done to determine if back-filling is supported.

category:reach
theme:varargs
skill-level:expert
cost:medium</Description>
    <Title_Description>Initial thoughts on Native Vararg support on Unix platforms for RyuJit PR #18373 will re-enable __arglist (native vararg support) for coreclr; however currently only Windows platforms support the ABI. This "issue" is more of a brain dump to help any future work to allow native varargs on other currently unsupported/untested platforms. It is platform and arch specific if there are gaps in my familiarity with other platform's/arch's ABIs please let me know I will update the issue.

#
#### Unix Amd64
x64 Unix should only require using RAX to pass the number of floating point arguments passed in registers for setting up the caller function. Change the prolog to spill all the General purpose registers and FP registers. ArgIterator would need to get the next arg based on type from the stack offset.

#
#### Unix Arm64
Currently there are a fair amount of example of where we mangle the vararg type for all arm arches. See https://github.com/dotnet/coreclr/blob/master/src/jit/compiler.hpp#L2607. This and other instances of forcing the argument types away from floating point types such as https://github.com/dotnet/coreclr/blob/master/src/jit/morph.cpp#L3322 need to also be restricted to windows. In addition the prolog ([here](https://github.com/dotnet/coreclr/blob/master/src/jit/codegencommon.cpp#L3302) also assumes all arguments are passing in the general purpose registers. 

#
#### Unix arm32
Everything for Unix arm64 applies. The only difference I can see is that non-fixed args (args in the ... varargs) that are TYP_FLOAT will need to be retyped and used as if they were TYP_DOUBLE. This will require annotating the arguments with new additional information isFixedArg.

#
#### Windows arm32
This is the same ABI as arm64 varargs. Investigation needs to be done to determine if back-filling is supported.

category:reach
theme:varargs
skill-level:expert
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>jashook</Assignee>
    <CreatedAt>8/06/2018 6:33:21 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18375</IssueLabelID>
    <Title>Enable versioning bubbles that span multiple assemblies</Title>
    <Description>The concept of versioning bubbles is described in https://github.com/dotnet/coreclr/blob/master/Documentation/botr/readytorun-overview.md#version-bubbles

The current implementation is hardcoded to each assembly being its own versioning bubble. This issue is about adding an option for larger versioning bubbles:

- [ ] Add command line option to crossgen to allow specifying versioning bubbles
- [ ] Update ZapImportTable::TryEncodeModule). This is required to allow cross-module inlining of non-leaf methods within the version bubble.</Description>
    <Title_Description>Enable versioning bubbles that span multiple assemblies The concept of versioning bubbles is described in https://github.com/dotnet/coreclr/blob/master/Documentation/botr/readytorun-overview.md#version-bubbles

The current implementation is hardcoded to each assembly being its own versioning bubble. This issue is about adding an option for larger versioning bubbles:

- [ ] Add command line option to crossgen to allow specifying versioning bubbles
- [ ] Update ZapImportTable::TryEncodeModule). This is required to allow cross-module inlining of non-leaf methods within the version bubble.</Title_Description>
    <Label>area-ReadyToRun</Label>
    <Assignee>janvorli</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18374</IssueLabelID>
    <Title>Fix coredistools download script now that Packages layout has changed</Title>
    <Description>Fixes #18321</Description>
    <Title_Description>Fix coredistools download script now that Packages layout has changed Fixes #18321</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>dotnet-bot</Assignee>
    <CreatedAt>8/06/2018 6:01:03 PM +00:00</CreatedAt>
    <ClosedAt>8/06/2018 10:27:20 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18371</IssueLabelID>
    <Title>Large Page Support in memory allocated by the GC</Title>
    <Description>Large Pages (a.k.a Huge Pages on Linux) is a feature where the operating system is able to establish memory regions larger than the native page size (often 4K) to improve performance of the application requesting these large pages.

When a virtual-to-physical address translation occurs a cache called the  privelege. Large Pages can also significantly increase the chance of a memory allocation failure because now the OS has to find physically contiguous memory.

What this means for coreclr and the GC is that when the GC does a VirtualReserve at the beginning of the program it must now commit this memory as well.</Description>
    <Title_Description>Large Page Support in memory allocated by the GC Large Pages (a.k.a Huge Pages on Linux) is a feature where the operating system is able to establish memory regions larger than the native page size (often 4K) to improve performance of the application requesting these large pages.

When a virtual-to-physical address translation occurs a cache called the  privelege. Large Pages can also significantly increase the chance of a memory allocation failure because now the OS has to find physically contiguous memory.

What this means for coreclr and the GC is that when the GC does a VirtualReserve at the beginning of the program it must now commit this memory as well.</Title_Description>
    <Label>area-GC</Label>
    <Assignee>Maoni0</Assignee>
    <CreatedAt>8/06/2018 4:31:57 PM +00:00</CreatedAt>
    <ClosedAt>8/04/2019 8:48:21 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18370</IssueLabelID>
    <Title>Remove length restrictions on named synchronization primitives lengths on Windows</Title>
    <Description>From https://github.com/dotnet/coreclr/pull/18320#issuecomment-395603647

If the OS allows creating mutex with the long name we should allow it too. We are just getting into way by blocking the longer names for no good reason.</Description>
    <Title_Description>Remove length restrictions on named synchronization primitives lengths on Windows From https://github.com/dotnet/coreclr/pull/18320#issuecomment-395603647

If the OS allows creating mutex with the long name we should allow it too. We are just getting into way by blocking the longer names for no good reason.</Title_Description>
    <Label>area-System.Threading</Label>
    <Assignee>Anipik</Assignee>
    <CreatedAt>8/06/2018 3:45:41 PM +00:00</CreatedAt>
    <ClosedAt>11/06/2018 2:29:59 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18367</IssueLabelID>
    <Title>[Regression] Assertion failed 'mask != RBM_NONE'</Title>
    <Description>
The regression was introduced by #18230.

cc @dotnet/jit-contrib </Description>
    <Title_Description>[Regression] Assertion failed 'mask != RBM_NONE' 
The regression was introduced by #18230.

cc @dotnet/jit-contrib </Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>sandreenko</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18362</IssueLabelID>
    <Title>[Windows/arm][JitStress] Assertion failed 'defList.IsEmpty()' in System.Numerics.Tests.ComplexTests:Conjugate</Title>
    <Description>Hit this is in PR #18347 during [Windows_NT arm Cross Checked corefx_jitstress1 Build and Test](https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_windows_nt_corefx_jitstress1_tst_prtest/3/consoleText) and [Windows_NT arm Cross Checked corefx_jitstress2 Build and Test](https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_windows_nt_corefx_jitstress2_tst_prtest/3/consoleText)


The issue was introduces sometime between now and May 8 2018
I am going to disable System.Runtime.Numerics.Tests in #18347 
When the issue is resolved please remove corresponding line in tests/arm/corefx_test_exclusions.txt </Description>
    <Title_Description>[Windows/arm][JitStress] Assertion failed 'defList.IsEmpty()' in System.Numerics.Tests.ComplexTests:Conjugate Hit this is in PR #18347 during [Windows_NT arm Cross Checked corefx_jitstress1 Build and Test](https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_windows_nt_corefx_jitstress1_tst_prtest/3/consoleText) and [Windows_NT arm Cross Checked corefx_jitstress2 Build and Test](https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_windows_nt_corefx_jitstress2_tst_prtest/3/consoleText)


The issue was introduces sometime between now and May 8 2018
I am going to disable System.Runtime.Numerics.Tests in #18347 
When the issue is resolved please remove corresponding line in tests/arm/corefx_test_exclusions.txt </Title_Description>
    <Label>JitStress</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18361</IssueLabelID>
    <Title>Performance degradation dotnet core 2.1.300 TieredCompilation</Title>
    <Description>I am very excited about Tiered Compilation in dotnet core so I decided to take it for a spin. Unfortunately in my case I found a performance degradation from 370 ms to 540 ms

## My dotnet version:


</Description>
    <Title_Description>Performance degradation dotnet core 2.1.300 TieredCompilation I am very excited about Tiered Compilation in dotnet core so I decided to take it for a spin. Unfortunately in my case I found a performance degradation from 370 ms to 540 ms

## My dotnet version:


</Title_Description>
    <Label>area-TieredCompilation</Label>
    <Assignee>noahfalk</Assignee>
    <CreatedAt>7/06/2018 10:49:58 PM +00:00</CreatedAt>
    <ClosedAt>18/12/2018 12:29:35 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18359</IssueLabelID>
    <Title>Mirror changes from dotnet/corefx</Title>
    <Description>This PR contains mirrored changes from dotnet/corefx


**Please REBASE this PR when merging**</Description>
    <Title_Description>Mirror changes from dotnet/corefx This PR contains mirrored changes from dotnet/corefx


**Please REBASE this PR when merging**</Title_Description>
    <Label>
    </Label>
    <Assignee>brianrob</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18353</IssueLabelID>
    <Title>JIT: make sure finally cloning isn't cloning along EH only paths</Title>
    <Description>Need to re-examine the selection of which finally clause to clone as I suspect in #18332 that the jit makes a poor choice and clones a finally that can only be reached when an exception is thrown.

Current algorithm is to walk the try region from back to front and picks the finally associated with the "last" exit point in the try hoping that this is the normal try region exit. Perhaps more checks are warranted here -- for instance I think we may also want to screen out blocks that are within some nested handler region.

This is a potential perf enhancement not a correctness issue.</Description>
    <Title_Description>JIT: make sure finally cloning isn't cloning along EH only paths Need to re-examine the selection of which finally clause to clone as I suspect in #18332 that the jit makes a poor choice and clones a finally that can only be reached when an exception is thrown.

Current algorithm is to walk the try region from back to front and picks the finally associated with the "last" exit point in the try hoping that this is the normal try region exit. Perhaps more checks are warranted here -- for instance I think we may also want to screen out blocks that are within some nested handler region.

This is a potential perf enhancement not a correctness issue.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
    <CreatedAt>7/06/2018 7:53:05 PM +00:00</CreatedAt>
    <ClosedAt>12/06/2018 4:49:38 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18347</IssueLabelID>
    <Title>Disable CoreFx tests on Windows/arm and Linux/arm</Title>
    <Description>Disable  failing on Windows/arm due to #18362</Description>
    <Title_Description>Disable CoreFx tests on Windows/arm and Linux/arm Disable  failing on Windows/arm due to #18362</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>dotnet-bot</Assignee>
    <CreatedAt>7/06/2018 4:14:29 PM +00:00</CreatedAt>
    <ClosedAt>8/06/2018 4:32:33 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18342</IssueLabelID>
    <Title>Debugging : The libcoreclr.so module is not loaded yet in the target process : when different build id of dotnet</Title>
    <Description>I have a crash dump from command  of dotnet changed ? Is this our problem ? Or problem in process of dotnet publishing to apt-repos.

</Description>
    <Title_Description>Debugging : The libcoreclr.so module is not loaded yet in the target process : when different build id of dotnet I have a crash dump from command  of dotnet changed ? Is this our problem ? Or problem in process of dotnet publishing to apt-repos.

</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>mikem8361</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18341</IssueLabelID>
    <Title>JIT: disasm assert on OSX</Title>
    <Description>Build checked coreclr on OSX. Set </Description>
    <Title_Description>JIT: disasm assert on OSX Build checked coreclr on OSX. Set </Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>BruceForstall</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18339</IssueLabelID>
    <Title>JIT Performance regression between 1.1 and 2.0 and between 2.0 and 2.1</Title>
    <Description>I've been trying to come up with a simple repro for a perf regression I've been fighting and I think I have it trimmed down as much as possible while still showing the real-world impact.  What I have [here](https://github.com/saucecontrol/Blake2Fast/tree/master/tests/JitRegression) is a stripped-down version of my [Blake2b](http://blake2.net/) hashing algorithm implementation.  The main work is driven through a single CPU-intensive mixing function and I've set up benchmarks with 3 variants of that function to show the problem.

1) is a [no-op version](https://github.com/saucecontrol/Blake2Fast/blob/master/tests/JitRegression/Blake2bMixNoop.cs) that simply runs all the outer loop code as a baseline for determining time spent in the inner loop.
2) is the version I'd like to use with the mixing math in a [separate method](https://github.com/saucecontrol/Blake2Fast/blob/master/tests/JitRegression/Blake2bMixPreferred.cs) marked with 

Method |           Job | Platform | IsBaseline |       Mean |      Error |     StdDev |     Median | Scaled | ScaledSD |
---------------- |-------------- |--------- |----------- |-----------:|-----------:|-----------:|-----------:|-------:|---------:|
MixNoop | netcoreapp1.1 |      X64 |       True |   1.326 ms |  0.1071 ms |  0.3158 ms |   1.331 ms |   1.00 |     0.00 |
MixNoop | netcoreapp2.0 |      X64 |    Default |   1.288 ms |  0.1003 ms |  0.2957 ms |   1.285 ms |   1.03 |     0.36 |
MixNoop | netcoreapp2.1 |      X64 |    Default |   1.352 ms |  0.0928 ms |  0.2735 ms |   1.358 ms |   1.08 |     0.36 |
|               |          |            |            |            |            |            |        |          |
MixNoop | netcoreapp1.1 |      X86 |       True |   2.738 ms |  0.2200 ms |  0.6486 ms |   2.701 ms |   1.00 |     0.00 |
MixNoop | netcoreapp2.0 |      X86 |    Default |   2.673 ms |  0.2034 ms |  0.5998 ms |   2.826 ms |   1.04 |     0.36 |
MixNoop | netcoreapp2.1 |      X86 |    Default |   2.776 ms |  0.2096 ms |  0.6181 ms |   2.740 ms |   1.08 |     0.37 |
|               |          |            |            |            |            |            |        |          |
MixPreferred | netcoreapp1.1 |      X64 |       True |  31.926 ms |  2.2443 ms |  6.6172 ms |  32.740 ms |   1.00 |     0.00 |
MixPreferred | netcoreapp2.0 |      X64 |    Default |  31.898 ms |  2.1440 ms |  6.3216 ms |  31.735 ms |   1.05 |     0.33 |
MixPreferred | netcoreapp2.1 |      X64 |    Default |  27.419 ms |  2.4213 ms |  7.1393 ms |  25.538 ms |   0.90 |     0.32 |
|               |          |            |            |            |            |            |        |          |
MixPreferred | netcoreapp1.1 |      X86 |       True | 341.759 ms | 13.1190 ms | 38.4759 ms | 331.234 ms |   1.00 |     0.00 |
MixPreferred | netcoreapp2.0 |      X86 |    Default | 251.373 ms | 13.1463 ms | 38.3484 ms | 239.499 ms |   0.74 |     0.14 |
MixPreferred | netcoreapp2.1 |      X86 |    Default | 291.564 ms | 10.3316 ms | 29.6434 ms | 285.206 ms |   0.86 |     0.13 |
|               |          |            |            |            |            |            |        |          |
MixManualInline | netcoreapp1.1 |      X64 |       True |  33.165 ms |  2.2903 ms |  6.7529 ms |  33.426 ms |   1.00 |     0.00 |
MixManualInline | netcoreapp2.0 |      X64 |    Default |  33.819 ms |  2.4410 ms |  7.1973 ms |  34.340 ms |   1.07 |     0.34 |
MixManualInline | netcoreapp2.1 |      X64 |    Default |  20.601 ms |  0.1490 ms |  0.1394 ms |  20.606 ms |   0.65 |     0.15 |
|               |          |            |            |            |            |            |        |          |
MixManualInline | netcoreapp1.1 |      X86 |       True | 163.629 ms |  7.6584 ms | 22.3398 ms | 160.224 ms |   1.00 |     0.00 |
MixManualInline | netcoreapp2.0 |      X86 |    Default | 249.708 ms | 11.3452 ms | 32.7336 ms | 240.169 ms |   1.55 |     0.28 |
MixManualInline | netcoreapp2.1 |      X86 |    Default | 285.367 ms |  9.0883 ms | 25.6337 ms | 278.039 ms |   1.77 |     0.27 |

Here there are a few more outliers but it's the same general story.

Full code for the benchmarks is [here](https://github.com/saucecontrol/Blake2Fast/tree/master/tests/JitRegression) if anyone wants to try on different hardware.

category:cq
theme:optimization
skill-level:expert
cost:large</Description>
    <Title_Description>JIT Performance regression between 1.1 and 2.0 and between 2.0 and 2.1 I've been trying to come up with a simple repro for a perf regression I've been fighting and I think I have it trimmed down as much as possible while still showing the real-world impact.  What I have [here](https://github.com/saucecontrol/Blake2Fast/tree/master/tests/JitRegression) is a stripped-down version of my [Blake2b](http://blake2.net/) hashing algorithm implementation.  The main work is driven through a single CPU-intensive mixing function and I've set up benchmarks with 3 variants of that function to show the problem.

1) is a [no-op version](https://github.com/saucecontrol/Blake2Fast/blob/master/tests/JitRegression/Blake2bMixNoop.cs) that simply runs all the outer loop code as a baseline for determining time spent in the inner loop.
2) is the version I'd like to use with the mixing math in a [separate method](https://github.com/saucecontrol/Blake2Fast/blob/master/tests/JitRegression/Blake2bMixPreferred.cs) marked with 

Method |           Job | Platform | IsBaseline |       Mean |      Error |     StdDev |     Median | Scaled | ScaledSD |
---------------- |-------------- |--------- |----------- |-----------:|-----------:|-----------:|-----------:|-------:|---------:|
MixNoop | netcoreapp1.1 |      X64 |       True |   1.326 ms |  0.1071 ms |  0.3158 ms |   1.331 ms |   1.00 |     0.00 |
MixNoop | netcoreapp2.0 |      X64 |    Default |   1.288 ms |  0.1003 ms |  0.2957 ms |   1.285 ms |   1.03 |     0.36 |
MixNoop | netcoreapp2.1 |      X64 |    Default |   1.352 ms |  0.0928 ms |  0.2735 ms |   1.358 ms |   1.08 |     0.36 |
|               |          |            |            |            |            |            |        |          |
MixNoop | netcoreapp1.1 |      X86 |       True |   2.738 ms |  0.2200 ms |  0.6486 ms |   2.701 ms |   1.00 |     0.00 |
MixNoop | netcoreapp2.0 |      X86 |    Default |   2.673 ms |  0.2034 ms |  0.5998 ms |   2.826 ms |   1.04 |     0.36 |
MixNoop | netcoreapp2.1 |      X86 |    Default |   2.776 ms |  0.2096 ms |  0.6181 ms |   2.740 ms |   1.08 |     0.37 |
|               |          |            |            |            |            |            |        |          |
MixPreferred | netcoreapp1.1 |      X64 |       True |  31.926 ms |  2.2443 ms |  6.6172 ms |  32.740 ms |   1.00 |     0.00 |
MixPreferred | netcoreapp2.0 |      X64 |    Default |  31.898 ms |  2.1440 ms |  6.3216 ms |  31.735 ms |   1.05 |     0.33 |
MixPreferred | netcoreapp2.1 |      X64 |    Default |  27.419 ms |  2.4213 ms |  7.1393 ms |  25.538 ms |   0.90 |     0.32 |
|               |          |            |            |            |            |            |        |          |
MixPreferred | netcoreapp1.1 |      X86 |       True | 341.759 ms | 13.1190 ms | 38.4759 ms | 331.234 ms |   1.00 |     0.00 |
MixPreferred | netcoreapp2.0 |      X86 |    Default | 251.373 ms | 13.1463 ms | 38.3484 ms | 239.499 ms |   0.74 |     0.14 |
MixPreferred | netcoreapp2.1 |      X86 |    Default | 291.564 ms | 10.3316 ms | 29.6434 ms | 285.206 ms |   0.86 |     0.13 |
|               |          |            |            |            |            |            |        |          |
MixManualInline | netcoreapp1.1 |      X64 |       True |  33.165 ms |  2.2903 ms |  6.7529 ms |  33.426 ms |   1.00 |     0.00 |
MixManualInline | netcoreapp2.0 |      X64 |    Default |  33.819 ms |  2.4410 ms |  7.1973 ms |  34.340 ms |   1.07 |     0.34 |
MixManualInline | netcoreapp2.1 |      X64 |    Default |  20.601 ms |  0.1490 ms |  0.1394 ms |  20.606 ms |   0.65 |     0.15 |
|               |          |            |            |            |            |            |        |          |
MixManualInline | netcoreapp1.1 |      X86 |       True | 163.629 ms |  7.6584 ms | 22.3398 ms | 160.224 ms |   1.00 |     0.00 |
MixManualInline | netcoreapp2.0 |      X86 |    Default | 249.708 ms | 11.3452 ms | 32.7336 ms | 240.169 ms |   1.55 |     0.28 |
MixManualInline | netcoreapp2.1 |      X86 |    Default | 285.367 ms |  9.0883 ms | 25.6337 ms | 278.039 ms |   1.77 |     0.27 |

Here there are a few more outliers but it's the same general story.

Full code for the benchmarks is [here](https://github.com/saucecontrol/Blake2Fast/tree/master/tests/JitRegression) if anyone wants to try on different hardware.

category:cq
theme:optimization
skill-level:expert
cost:large</Title_Description>
    <Label>arch-x86</Label>
    <Assignee>pgavlin</Assignee>
    <CreatedAt>7/06/2018 3:58:38 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18338</IssueLabelID>
    <Title>CoreCLR failed when build with msvc on windows</Title>
    <Description>CoreCLR failed with warning C4644  when build with msvc on Windows I use latest source on master branch. The source code is ill-formed could you please help take a look at this?
Noted that this issue only found when compiles with unreleased vctoolset that next release of MSVC will have this behavior.

The probably fix: the project either needs to build with /wd4644 pragma push/pop the warning or do as the warning says and use the STL’s offsetof

You can repro this issue as the steps below:
1.git clone https://github.com/dotnet/coreclr D:\CoreCLR\src
2.Open a clean x86 prompt (C:\windows\syswow64\cmd.exe) and browse to D:\CoreCLR\src
3.build x86 release -Rebuild -- /clp:ShowCommandLine

Failures:
d:\coreclr\src\src\vm\i386\profiler.cpp(17210): warning C4644:  usage of the macro-based offsetof pattern in constant expressions is non-standard; use offsetof defined in the C++ standard library instead [D:\CoreCLR\src\bin\obj\Windows_NT.x86.Release\src\vm\wks\cee_wks.vcxproj]
d:\coreclr\src\src\vm\i386\profiler.cpp(17210): warning C4644:     case offsetof(ArgumentRegisters ECX): [D:\CoreCLR\src\bin\obj\Windows_NT.x86.Release\src\vm\wks\cee_wks.vcxproj]
d:\coreclr\src\src\vm\i386\profiler.cpp(17210): warning C4644:          ^ [D:\CoreCLR\src\bin\obj\Windows_NT.x86.Release\src\vm\wks\cee_wks.vcxproj]
d:\coreclr\src\src\vm\i386\profiler.cpp(17410): warning C4644:  usage of the macro-based offsetof pattern in constant expressions is non-standard; use offsetof defined in the C++ standard library instead [D:\CoreCLR\src\bin\obj\Windows_NT.x86.Release\src\vm\wks\cee_wks.vcxproj]
d:\coreclr\src\src\vm\i386\profiler.cpp(17410): warning C4644:     case offsetof(ArgumentRegisters EDX): [D:\CoreCLR\src\bin\obj\Windows_NT.x86.Release\src\vm\wks\cee_wks.vcxproj]
d:\coreclr\src\src\vm\i386\profiler.cpp(17410): warning C4644:          ^ [D:\CoreCLR\src\bin\obj\Windows_NT.x86.Release\src\vm\wks\cee_wks.vcxproj]
&lt;snip&gt;
[D:\CoreCLR\src\bin\obj\Windows_NT.x86.Release\src\vm\wks\cee_wks.vcxproj]
d:\coreclr\src\src\vm\i386\profiler.cpp(17210): error C2220:  warning treated as error - no 'object' file generated [D:\CoreCLR\src\bin\obj\Windows_NT.x86.Release\src\vm\wks\cee_wks.vcxproj]
d:\coreclr\src\src\vm\i386\profiler.cpp(17210): error C2220:     case offsetof(ArgumentRegisters ECX): [D:\CoreCLR\src\bin\obj\Windows_NT.x86.Release\src\vm\wks\cee_wks.vcxproj]
d:\coreclr\src\src\vm\i386\profiler.cpp(17210): error C2220:          ^ [D:\CoreCLR\src\bin\obj\Windows_NT.x86.Release\src\vm\wks\cee_wks.vcxproj]
</Description>
    <Title_Description>CoreCLR failed when build with msvc on windows CoreCLR failed with warning C4644  when build with msvc on Windows I use latest source on master branch. The source code is ill-formed could you please help take a look at this?
Noted that this issue only found when compiles with unreleased vctoolset that next release of MSVC will have this behavior.

The probably fix: the project either needs to build with /wd4644 pragma push/pop the warning or do as the warning says and use the STL’s offsetof

You can repro this issue as the steps below:
1.git clone https://github.com/dotnet/coreclr D:\CoreCLR\src
2.Open a clean x86 prompt (C:\windows\syswow64\cmd.exe) and browse to D:\CoreCLR\src
3.build x86 release -Rebuild -- /clp:ShowCommandLine

Failures:
d:\coreclr\src\src\vm\i386\profiler.cpp(17210): warning C4644:  usage of the macro-based offsetof pattern in constant expressions is non-standard; use offsetof defined in the C++ standard library instead [D:\CoreCLR\src\bin\obj\Windows_NT.x86.Release\src\vm\wks\cee_wks.vcxproj]
d:\coreclr\src\src\vm\i386\profiler.cpp(17210): warning C4644:     case offsetof(ArgumentRegisters ECX): [D:\CoreCLR\src\bin\obj\Windows_NT.x86.Release\src\vm\wks\cee_wks.vcxproj]
d:\coreclr\src\src\vm\i386\profiler.cpp(17210): warning C4644:          ^ [D:\CoreCLR\src\bin\obj\Windows_NT.x86.Release\src\vm\wks\cee_wks.vcxproj]
d:\coreclr\src\src\vm\i386\profiler.cpp(17410): warning C4644:  usage of the macro-based offsetof pattern in constant expressions is non-standard; use offsetof defined in the C++ standard library instead [D:\CoreCLR\src\bin\obj\Windows_NT.x86.Release\src\vm\wks\cee_wks.vcxproj]
d:\coreclr\src\src\vm\i386\profiler.cpp(17410): warning C4644:     case offsetof(ArgumentRegisters EDX): [D:\CoreCLR\src\bin\obj\Windows_NT.x86.Release\src\vm\wks\cee_wks.vcxproj]
d:\coreclr\src\src\vm\i386\profiler.cpp(17410): warning C4644:          ^ [D:\CoreCLR\src\bin\obj\Windows_NT.x86.Release\src\vm\wks\cee_wks.vcxproj]
&lt;snip&gt;
[D:\CoreCLR\src\bin\obj\Windows_NT.x86.Release\src\vm\wks\cee_wks.vcxproj]
d:\coreclr\src\src\vm\i386\profiler.cpp(17210): error C2220:  warning treated as error - no 'object' file generated [D:\CoreCLR\src\bin\obj\Windows_NT.x86.Release\src\vm\wks\cee_wks.vcxproj]
d:\coreclr\src\src\vm\i386\profiler.cpp(17210): error C2220:     case offsetof(ArgumentRegisters ECX): [D:\CoreCLR\src\bin\obj\Windows_NT.x86.Release\src\vm\wks\cee_wks.vcxproj]
d:\coreclr\src\src\vm\i386\profiler.cpp(17210): error C2220:          ^ [D:\CoreCLR\src\bin\obj\Windows_NT.x86.Release\src\vm\wks\cee_wks.vcxproj]
</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>RussKeldorph</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18337</IssueLabelID>
    <Title>Moves CurrentSystemTimeZone ICastable RegistryView and RegistryValueKind to shared</Title>
    <Description>1) As recommended in the comment [here](https://github.com/dotnet/coreclr/issues/17904#issuecomment-391056322) now that Hashtable is available in CoreLib we can undo the split on  changes were done by moving some Win32Native enums to Interop.Kernel32

Related to https://github.com/dotnet/corert/pull/5906

cc: @jkotas </Description>
    <Title_Description>Moves CurrentSystemTimeZone, ICastable, RegistryView and RegistryValueKind to shared 1) As recommended in the comment [here](https://github.com/dotnet/coreclr/issues/17904#issuecomment-391056322) now that Hashtable is available in CoreLib we can undo the split on  changes were done by moving some Win32Native enums to Interop.Kernel32

Related to https://github.com/dotnet/corert/pull/5906

cc: @jkotas </Title_Description>
    <Label>
    </Label>
    <Assignee>maryamariyan</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18332</IssueLabelID>
    <Title>Function erroneously returns null when compiled in release mode</Title>
    <Description>@leecow commented on [Wed Jun 06 2018](https://github.com/dotnet/corefx/issues/30173)

@jlwSL commented on [Wed Jun 06 2018](https://github.com/dotnet/core/issues/1663)

I've discovered a bug that causes a function to return null even if every possible return value is non-null. The issue does not happen if the project is compiled in debug mode. Please see the code attached that reproduces this issue.

. Going to move this to the CoreFX to start. 



---

@0xd4d commented on [Wed Jun 06 2018](https://github.com/dotnet/corefx/issues/30173#issuecomment-395183992)

Looks like a jitter bug so coreclr is a better repo.

&gt; I ran your code on Mac Fedora 28 and a clean CentOS 7 image and all return false

Did you try Release builds?

</Description>
    <Title_Description>Function erroneously returns null when compiled in release mode @leecow commented on [Wed Jun 06 2018](https://github.com/dotnet/corefx/issues/30173)

@jlwSL commented on [Wed Jun 06 2018](https://github.com/dotnet/core/issues/1663)

I've discovered a bug that causes a function to return null even if every possible return value is non-null. The issue does not happen if the project is compiled in debug mode. Please see the code attached that reproduces this issue.

. Going to move this to the CoreFX to start. 



---

@0xd4d commented on [Wed Jun 06 2018](https://github.com/dotnet/corefx/issues/30173#issuecomment-395183992)

Looks like a jitter bug so coreclr is a better repo.

&gt; I ran your code on Mac Fedora 28 and a clean CentOS 7 image and all return false

Did you try Release builds?

</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18330</IssueLabelID>
    <Title>Metrics "framework" for JIT</Title>
    <Description>While hacking the JIT quite often I end up with a simple question - "how many time does X happen?":
* How many JCC instructions are generated?
* How many side effects trees are extracted?
* How many range checks are encountered/removed?

So I end up adding variables 
pretty much anywhere in the JIT code and have such counters dumped to the console like mem stats are. Or included in disassembly comments so that they show up in diffs and maybe be used by jit-analyze.

Counters should be collected per method and if possible per phase as well. And of course some basic aggregations should be included as well.

The API should be as easy to use as possible - the above example shows the use of a string as a counter identifier (so I guess the implementation would be using these strings as a hashtable key). This would avoid the need to add a new enum member - such an enum typically resides in a header that when changed triggers the compilation of all JIT files.  Of course an enum based overload could also provided that would be useful for counters that are useful long term.

@dotnet/jit-contrib Thoughts?

category:implementation
theme:jit-coding-style
skill-level:beginner
cost:medium</Description>
    <Title_Description>Metrics "framework" for JIT While hacking the JIT quite often I end up with a simple question - "how many time does X happen?":
* How many JCC instructions are generated?
* How many side effects trees are extracted?
* How many range checks are encountered/removed?

So I end up adding variables 
pretty much anywhere in the JIT code and have such counters dumped to the console like mem stats are. Or included in disassembly comments so that they show up in diffs and maybe be used by jit-analyze.

Counters should be collected per method and if possible per phase as well. And of course some basic aggregations should be included as well.

The API should be as easy to use as possible - the above example shows the use of a string as a counter identifier (so I guess the implementation would be using these strings as a hashtable key). This would avoid the need to add a new enum member - such an enum typically resides in a header that when changed triggers the compilation of all JIT files.  Of course an enum based overload could also provided that would be useful for counters that are useful long term.

@dotnet/jit-contrib Thoughts?

category:implementation
theme:jit-coding-style
skill-level:beginner
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>pgavlin</Assignee>
    <CreatedAt>6/06/2018 7:48:51 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18328</IssueLabelID>
    <Title>Fix issue in Compiler::impImportStaticFieldAccess</Title>
    <Description>When CORINFO_FIELD_STATIC_SHARED_STATIC_HELPER accessor is being processed for
structs the method creates a GT_IND node instead of GT_OBJ node. For structs
that can be normalized to a specific type (like TYP_SIMD8) it causes an assert
in Compiler::impNormStructVal in the switch case for GT_IND.

This change modifies the node creation to work the same way as in the default
case for accessors creating GT_OBJ for structs and GT_IND otherwise.</Description>
    <Title_Description>Fix issue in Compiler::impImportStaticFieldAccess When CORINFO_FIELD_STATIC_SHARED_STATIC_HELPER accessor is being processed for
structs the method creates a GT_IND node instead of GT_OBJ node. For structs
that can be normalized to a specific type (like TYP_SIMD8) it causes an assert
in Compiler::impNormStructVal in the switch case for GT_IND.

This change modifies the node creation to work the same way as in the default
case for accessors creating GT_OBJ for structs and GT_IND otherwise.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>janvorli</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18327</IssueLabelID>
    <Title>Excessive/strange null reference checks after method inlining</Title>
    <Description>Consider the following repro example (this is actually from the live system just narrowed down significantly):

 and all references to it from structure.

category:cq
theme:value-numbering
skill-level:expert
cost:medium</Description>
    <Title_Description>Excessive/strange null reference checks after method inlining Consider the following repro example (this is actually from the live system just narrowed down significantly):

 and all references to it from structure.

category:cq
theme:value-numbering
skill-level:expert
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>6/06/2018 6:27:55 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18324</IssueLabelID>
    <Title>JIT has run out of instruction bits in instrDesc</Title>
    <Description>We have 9 bits for the instruction field and  is probably only used with the "align loops" option.
</Description>
    <Title_Description>JIT has run out of instruction bits in instrDesc We have 9 bits for the instruction field and  is probably only used with the "align loops" option.
</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>pgavlin</Assignee>
    <CreatedAt>6/06/2018 3:06:50 PM +00:00</CreatedAt>
    <ClosedAt>7/06/2018 11:58:04 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18323</IssueLabelID>
    <Title>Unreproducible InvalidProgramExceptions at random places</Title>
    <Description>Our .NET Core Web Apps running on Azure App Service occasionally start throwing InvalidProgramExceptions at seemly random places in code. For example see the following stack traces:

On .NET Core 2.0:

* https://gist.github.com/chrarnoldus/bc4362ff1b4df11b34d2407f0131a607
* https://gist.github.com/chrarnoldus/f7ceab63117c33a3be8c6128815b7cdb (see inner exception)
* https://gist.github.com/chrarnoldus/101c99d0b14f5ad7e572670ffe913f74

On .NET Core 2.1 so the issue doesn't seem toe be fixed:

* https://gist.github.com/chrarnoldus/d4da9436c575f453e46043aa9b062353 (see inner exception)

Due to the unpredictable nature of these exceptions I suspect the problem is in the runtime and not in the ASP.NET Core libraries used. In all of the cases the exception continued to be thrown every time the affected code was executed. The problem disappears after restarting the process so I don't have steps to reproduce it. I do have memory dumps that were captured by the Application Insights Snapshot Collector. If a Microsoft employee is interested in analysing those in the understanding that they probably contain sensitive data please contact me using the email in my profile.
</Description>
    <Title_Description>Unreproducible InvalidProgramExceptions at random places Our .NET Core Web Apps running on Azure App Service occasionally start throwing InvalidProgramExceptions at seemly random places in code. For example see the following stack traces:

On .NET Core 2.0:

* https://gist.github.com/chrarnoldus/bc4362ff1b4df11b34d2407f0131a607
* https://gist.github.com/chrarnoldus/f7ceab63117c33a3be8c6128815b7cdb (see inner exception)
* https://gist.github.com/chrarnoldus/101c99d0b14f5ad7e572670ffe913f74

On .NET Core 2.1 so the issue doesn't seem toe be fixed:

* https://gist.github.com/chrarnoldus/d4da9436c575f453e46043aa9b062353 (see inner exception)

Due to the unpredictable nature of these exceptions I suspect the problem is in the runtime and not in the ASP.NET Core libraries used. In all of the cases the exception continued to be thrown every time the affected code was executed. The problem disappears after restarting the process so I don't have steps to reproduce it. I do have memory dumps that were captured by the Application Insights Snapshot Collector. If a Microsoft employee is interested in analysing those in the understanding that they probably contain sensitive data please contact me using the email in my profile.
</Title_Description>
    <Label>
    </Label>
    <Assignee>leculver</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18321</IssueLabelID>
    <Title>setup-stress-dependencies.cmd failing</Title>
    <Description>This is causing x86 GCStress testing to fail.

https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/x86_checked_windows_nt_gcstress0xc/

e.g.

https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/x86_checked_windows_nt_gcstress0xc/83/consoleText

</Description>
    <Title_Description>setup-stress-dependencies.cmd failing This is causing x86 GCStress testing to fail.

https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/x86_checked_windows_nt_gcstress0xc/

e.g.

https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/x86_checked_windows_nt_gcstress0xc/83/consoleText

</Title_Description>
    <Label>arch-x86</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>6/06/2018 12:59:28 AM +00:00</CreatedAt>
    <ClosedAt>8/06/2018 10:27:20 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18319</IssueLabelID>
    <Title>Classic EventSources don't work in Release builds using .NET Native (UWP)</Title>
    <Description>Michael Taron  reported this on 6/5/2018 via E-mail to @vancem and @brianrob 

To repro using VS create the 'Blank UWP app' and add the following EventSource

To make the EventSource use self-describing events but that causes a Exception to be thrown (**this seems like an independent but that is also worth fixing**).  

This bug is meant to track this issue (Note it is a .NET Native issue not a .NET Core issue
@brianrob 

</Description>
    <Title_Description>Classic EventSources don't work in Release builds using .NET Native (UWP) Michael Taron  reported this on 6/5/2018 via E-mail to @vancem and @brianrob 

To repro using VS create the 'Blank UWP app' and add the following EventSource

To make the EventSource use self-describing events but that causes a Exception to be thrown (**this seems like an independent but that is also worth fixing**).  

This bug is meant to track this issue (Note it is a .NET Native issue not a .NET Core issue
@brianrob 

</Title_Description>
    <Label>area-Tracing</Label>
    <Assignee>vancem</Assignee>
    <CreatedAt>6/06/2018 12:07:58 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18316</IssueLabelID>
    <Title>Force short date pattern to use yyyy on Linux</Title>
    <Description>The default pattern we get is using yy which causes the years to be displayed as 2 digits. This is not acceptable for many users. The fix here is to force 4-digit year as a default and still keep the original pattern which has 2-digit year in the optional list</Description>
    <Title_Description>Force short date pattern to use yyyy on Linux The default pattern we get is using yy which causes the years to be displayed as 2 digits. This is not acceptable for many users. The fix here is to force 4-digit year as a default and still keep the original pattern which has 2-digit year in the optional list</Title_Description>
    <Label>
    </Label>
    <Assignee>tarekgh</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18315</IssueLabelID>
    <Title>Assertion failed 'killMask == getKillSetForNode(tree)' lsrabuild.cpp</Title>
    <Description>Was caused by #16517.
</Description>
    <Title_Description>Assertion failed 'killMask == getKillSetForNode(tree)' lsrabuild.cpp Was caused by #16517.
</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18312</IssueLabelID>
    <Title>Increase timeout and log the result for some WaitAny tests that expect AbandonedMutexException</Title>
    <Description>Follow-up to https://github.com/dotnet/coreclr/pull/13298 missed a few cases.</Description>
    <Title_Description>Increase timeout and log the result for some WaitAny tests that expect AbandonedMutexException Follow-up to https://github.com/dotnet/coreclr/pull/13298 missed a few cases.</Title_Description>
    <Label>area-System.Threading</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18309</IssueLabelID>
    <Title>[release/2.1] Use WChar instead of char</Title>
    <Description>Use WCHAR to avoid truncate -- pTarget is WCHAR*.

This PR is for 2.1 servicing.

Fix: #18269</Description>
    <Title_Description>[release/2.1] Use WChar instead of char Use WCHAR to avoid truncate -- pTarget is WCHAR*.

This PR is for 2.1 servicing.

Fix: #18269</Title_Description>
    <Label>
    </Label>
    <Assignee>luqunl</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18307</IssueLabelID>
    <Title>Alpine Linux coreclr dac dbi not honoring PAL symbol versions</Title>
    <Description>The loader on Alpine links the libmscordbi.so PAL references to libvsbaseservices.so (which contains VS's debug engine PAL) instead of the the PAL in libmscordaccore.so.

On Alpine Linux the export PAL APIs from the DAC need to have a module specific prefix added so the loader links to the right module/PAL.</Description>
    <Title_Description>Alpine Linux coreclr, dac, dbi not honoring PAL symbol versions The loader on Alpine links the libmscordbi.so PAL references to libvsbaseservices.so (which contains VS's debug engine PAL) instead of the the PAL in libmscordaccore.so.

On Alpine Linux the export PAL APIs from the DAC need to have a module specific prefix added so the loader links to the right module/PAL.</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>mikem8361</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18305</IssueLabelID>
    <Title>Skip old time zones adjustments with offsets higher than 14h</Title>
    <Description>Fixes: https://github.com/dotnet/corefx/issues/29820
Tested locally with original repro.

Some old time zones (i.e. Asia/Manilla - see comment in the code for more examples) had adjustment higher than our max expected value 14h. Because of compatibility with SQL server concerns we cannot change the max value (i.e. Windows does not have that data at all). Last known adjustment with offset larger than 14h is in year 1900.</Description>
    <Title_Description>Skip old time zones adjustments with offsets higher than 14h Fixes: https://github.com/dotnet/corefx/issues/29820
Tested locally with original repro.

Some old time zones (i.e. Asia/Manilla - see comment in the code for more examples) had adjustment higher than our max expected value 14h. Because of compatibility with SQL server concerns we cannot change the max value (i.e. Windows does not have that data at all). Last known adjustment with offset larger than 14h is in year 1900.</Title_Description>
    <Label>
    </Label>
    <Assignee>tarekgh</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18300</IssueLabelID>
    <Title>Sse2.Set[All]Vector128([u]long [u]long) crashes with PNSE when run in 32-bit process</Title>
    <Description>My guess is - these method have managed implementation behind them involving ) unavailable in 32-bit mode.
Since these are all just helper methods not necessarily mapped to some specific HW intrinsic directly my understanding is that the implementation should behave considering current process bitness - eg. use set of 32-bit HW intrinsics to setup the result when in 32-bit mode.</Description>
    <Title_Description>Sse2.Set[All]Vector128([u]long, [u]long) crashes with PNSE when run in 32-bit process My guess is - these method have managed implementation behind them involving ) unavailable in 32-bit mode.
Since these are all just helper methods not necessarily mapped to some specific HW intrinsic directly my understanding is that the implementation should behave considering current process bitness - eg. use set of 32-bit HW intrinsics to setup the result when in 32-bit mode.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
    <CreatedAt>5/06/2018 3:34:28 PM +00:00</CreatedAt>
    <ClosedAt>6/12/2018 7:50:41 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18299</IssueLabelID>
    <Title>Methods with operations on pointers to unmanaged type (T* where T: unmanaged) not getting inlined</Title>
    <Description>VS 15.7.3 .NET Framework 4.7.2


| Method |     Mean |     Error |    StdDev |
|------- |---------:|----------:|----------:|
|   Run1 | 80.98 ms | 0.9829 ms | 0.8713 ms |
|   Run2 | 20.79 ms | 0.0431 ms | 0.0337 ms |
</Description>
    <Title_Description>Methods with operations on pointers to unmanaged type (T*, where T: unmanaged) not getting inlined VS 15.7.3 .NET Framework 4.7.2


| Method |     Mean |     Error |    StdDev |
|------- |---------:|----------:|----------:|
|   Run1 | 80.98 ms | 0.9829 ms | 0.8713 ms |
|   Run2 | 20.79 ms | 0.0431 ms | 0.0337 ms |
</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
    <CreatedAt>5/06/2018 12:22:08 PM +00:00</CreatedAt>
    <ClosedAt>5/06/2018 4:18:53 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18296</IssueLabelID>
    <Title>Avoid marking the frame pointer is used in genFuncletProlog</Title>
    <Description>This pull request is a follow up of the pull request (#18230) I made earlier.

Initially I followed the advice to mark the frame pointer as modified in  the frame pointer but not really ...

In some sense the original code did pretty much that same but it brackets a much larger region. This change narrowed down the region to just emitting one instruction in the large frame case.</Description>
    <Title_Description>Avoid marking the frame pointer is used in genFuncletProlog This pull request is a follow up of the pull request (#18230) I made earlier.

Initially I followed the advice to mark the frame pointer as modified in  the frame pointer but not really ...

In some sense the original code did pretty much that same but it brackets a much larger region. This change narrowed down the region to just emitting one instruction in the large frame case.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>cshung</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18295</IssueLabelID>
    <Title>[arm32] Assertion failed 'genIsValidIntReg(dstReg)'</Title>
    <Description>It seems that this has been broken for a while. I recently caught this during PR #18289 testing
But the regression was introduced earlier - sometime between  [Build #18 (May 17 2018 4:32:43 AM) ](https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_corefx_baseline_tst/18/) and [Build #19 (May 24 2018 4:27:51 AM)](https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_corefx_baseline_tst/19/)

**Update:** The issue is also reproducible on Windows/ARM (e.g. https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_corefx_baseline_tst/21/consoleText)

When the issue is resolved enable back tests disabled in PR #18347</Description>
    <Title_Description>[arm32] Assertion failed 'genIsValidIntReg(dstReg)' It seems that this has been broken for a while. I recently caught this during PR #18289 testing
But the regression was introduced earlier - sometime between  [Build #18 (May 17 2018 4:32:43 AM) ](https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_corefx_baseline_tst/18/) and [Build #19 (May 24 2018 4:27:51 AM)](https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_corefx_baseline_tst/19/)

**Update:** The issue is also reproducible on Windows/ARM (e.g. https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_corefx_baseline_tst/21/consoleText)

When the issue is resolved enable back tests disabled in PR #18347</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18294</IssueLabelID>
    <Title>Use WChar instead of char</Title>
    <Description>Use WCHAR to avoid truncate -- pTarget  is WCHAR*.

Fix: https://github.com/dotnet/coreclr/issues/18269</Description>
    <Title_Description>Use WChar instead of char Use WCHAR to avoid truncate -- pTarget  is WCHAR*.

Fix: https://github.com/dotnet/coreclr/issues/18269</Title_Description>
    <Label>
    </Label>
    <Assignee>luqunl</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18292</IssueLabelID>
    <Title>Workaround for  compiler.hpp (1848) - Assertion failed 'lvRefCnt'</Title>
    <Description>The description is in #18291.

The fix is to replace  could receive a statement that was already removed still exists.</Description>
    <Title_Description>Workaround for  compiler.hpp (1848) - Assertion failed 'lvRefCnt' The description is in #18291.

The fix is to replace  could receive a statement that was already removed still exists.</Title_Description>
    <Label>bug</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>4/06/2018 10:57:40 PM +00:00</CreatedAt>
    <ClosedAt>8/06/2018 5:30:44 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18291</IssueLabelID>
    <Title>optVNConstantPropOnJTrue with uncondition throw removes the tree twice</Title>
    <Description>An example:
.

Affects all targets affects 2.1 but it does not generate bad code in release however I think it is possible to cause it with this issue.

category:testing
theme:basic-cq
skill-level:expert
cost:small</Description>
    <Title_Description>optVNConstantPropOnJTrue with uncondition throw removes the tree twice An example:
.

Affects all targets affects 2.1 but it does not generate bad code in release however I think it is possible to cause it with this issue.

category:testing
theme:basic-cq
skill-level:expert
cost:small</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>sandreenko</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18286</IssueLabelID>
    <Title>[Arm64/Linux] gcStress=1/2/3 intermittent failures</Title>
    <Description>This issue is for tracking intermittent gcGtress failures which are not threading related..

While the occurrence rate of these failures is low it is worth tracking them here to help detect patterns.</Description>
    <Title_Description>[Arm64/Linux] gcStress=1/2/3 intermittent failures This issue is for tracking intermittent gcGtress failures which are not threading related..

While the occurrence rate of these failures is low it is worth tracking them here to help detect patterns.</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>Maoni0</Assignee>
    <CreatedAt>4/06/2018 5:29:43 PM +00:00</CreatedAt>
    <ClosedAt>10/04/2019 5:00:02 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18285</IssueLabelID>
    <Title>[Arm64/Linux] gcServer intermittent failures</Title>
    <Description>These have been a few intermittent failures in gcServer modes

Opening this issue to track these intermittent failures.

@Maoni0 </Description>
    <Title_Description>[Arm64/Linux] gcServer intermittent failures These have been a few intermittent failures in gcServer modes

Opening this issue to track these intermittent failures.

@Maoni0 </Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>VSadov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18284</IssueLabelID>
    <Title>Working folder when debugging a .NET Core app changing bizarrely</Title>
    <Description>_From @adamralph on June 1 2018 22:33_

_Continuing from [Twitter](https://twitter.com/davkean/status/1002675512399970304)._

Note that the breakpoint is _before_ the call to !

![working-dir](https://user-images.githubusercontent.com/677704/40866148-6f48d7b0-65fc-11e8-9e9b-498bae7e57c2.gif)


_Copied from original issue: dotnet/project-system#3609_</Description>
    <Title_Description>Working folder when debugging a .NET Core app changing bizarrely _From @adamralph on June 1 2018 22:33_

_Continuing from [Twitter](https://twitter.com/davkean/status/1002675512399970304)._

Note that the breakpoint is _before_ the call to !

![working-dir](https://user-images.githubusercontent.com/677704/40866148-6f48d7b0-65fc-11e8-9e9b-498bae7e57c2.gif)


_Copied from original issue: dotnet/project-system#3609_</Title_Description>
    <Label>area-Meta-corelib</Label>
    <Assignee>danmosemsft</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18283</IssueLabelID>
    <Title>Moves FastResourceComparer and TaskAwaiter to shared</Title>
    <Description>cc: @jkotas 

Related to corert PR: https://github.com/dotnet/corert/pull/5893</Description>
    <Title_Description>Moves FastResourceComparer and TaskAwaiter to shared cc: @jkotas 

Related to corert PR: https://github.com/dotnet/corert/pull/5893</Title_Description>
    <Label>
    </Label>
    <Assignee>maryamariyan</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18280</IssueLabelID>
    <Title>Interpretation of ByRefLikeAttribute in .NET Core 2.1 is a breaking change and a standard violation</Title>
    <Description>As a matter of facts it is possible in .NET Core 2.0 to use a ref struct as an argument of a generic parameter if you're generating MSIL but this same MSIL code no longer runs in .NET Core 2.1. We used this compilation pattern in PostSharp and did all the testing in .NET Core 2.0 just to see it's breaking in .NET Core 2.1.

I understand why you guys have taken this approach as this is a pragmatic way but I think it is my role as a third-party tool developer to respectfully complain.

Giving a runtime meaning to a custom attribute (ByRefLikeAttribute) is non-standard-compliant (ECMA-335) so the least I would expect is that you document an extension or violation of the standard. An orthodox approach would have been to define a new TypeAttribute and to cope with the problem that the compiler will need a specific version of the runtime. 

The concrete impact for this change and as far as PostSharp is concerned is minimal because support for C# 7.2 in PostSharp wasn't made RTW yet.

However as a policy breaking standards and relying on "tricks" (like ObsoleteAttribute) to minimize their impact is unhealthy and warrants this complain.

It seems there's a need for a well-thought solution to this problem. Like .NET Standard is the API-level answer to this issue should it be some CLR Standard? Maybe the compiler could emit a list of non-standard-compliant extensions marked as MUST UNDERSTAND or OPTIONAL that all members of the MSIL pipeline (therefore including the compiler PostSharp and the CLR) would respect.




</Description>
    <Title_Description>Interpretation of ByRefLikeAttribute in .NET Core 2.1 is a breaking change and a standard violation As a matter of facts it is possible in .NET Core 2.0 to use a ref struct as an argument of a generic parameter if you're generating MSIL but this same MSIL code no longer runs in .NET Core 2.1. We used this compilation pattern in PostSharp and did all the testing in .NET Core 2.0 just to see it's breaking in .NET Core 2.1.

I understand why you guys have taken this approach as this is a pragmatic way but I think it is my role as a third-party tool developer to respectfully complain.

Giving a runtime meaning to a custom attribute (ByRefLikeAttribute) is non-standard-compliant (ECMA-335) so the least I would expect is that you document an extension or violation of the standard. An orthodox approach would have been to define a new TypeAttribute and to cope with the problem that the compiler will need a specific version of the runtime. 

The concrete impact for this change and as far as PostSharp is concerned is minimal because support for C# 7.2 in PostSharp wasn't made RTW yet.

However as a policy breaking standards and relying on "tricks" (like ObsoleteAttribute) to minimize their impact is unhealthy and warrants this complain.

It seems there's a need for a well-thought solution to this problem. Like .NET Standard is the API-level answer to this issue should it be some CLR Standard? Maybe the compiler could emit a list of non-standard-compliant extensions marked as MUST UNDERSTAND or OPTIONAL that all members of the MSIL pipeline (therefore including the compiler PostSharp and the CLR) would respect.




</Title_Description>
    <Label>area-TypeSystem</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>4/06/2018 2:02:29 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18278</IssueLabelID>
    <Title>Build failure: src\vm\codeversion.cpp(2523): warning C4101: 'hr': unreferenced local variable</Title>
    <Description>Opened on behalf of @RussKeldorph

Warnings: 2
Status Message: failed

Build : Master - 20180604.03 (Product Build)
Failing configurations:
- Windows
  - PortableBuild-Checked-arm
  - PortableBuild-Checked-arm64
  - PortableBuild-Debug-arm
  - PortableBuild-Debug-arm64
  - PortableBuild-Release-arm
  - PortableBuild-Release-arm64
[Mission Control Build Info](https://mc.dot.net/#/product/netcore/master/source/official~2Fcoreclr~2Fmaster~2F/type/build~2Fproduct~2F/build/20180604.03/workItem/Orchestration/analysis/external/Link)
</Description>
    <Title_Description>Build failure: src\vm\codeversion.cpp(2523): warning C4101: 'hr': unreferenced local variable Opened on behalf of @RussKeldorph

Warnings: 2
Status Message: failed

Build : Master - 20180604.03 (Product Build)
Failing configurations:
- Windows
  - PortableBuild-Checked-arm
  - PortableBuild-Checked-arm64
  - PortableBuild-Debug-arm
  - PortableBuild-Debug-arm64
  - PortableBuild-Release-arm
  - PortableBuild-Release-arm64
[Mission Control Build Info](https://mc.dot.net/#/product/netcore/master/source/official~2Fcoreclr~2Fmaster~2F/type/build~2Fproduct~2F/build/20180604.03/workItem/Orchestration/analysis/external/Link)
</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>4/06/2018 1:04:33 PM +00:00</CreatedAt>
    <ClosedAt>4/06/2018 3:11:19 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18277</IssueLabelID>
    <Title>Consider using SIMD registers for "hot" local variables instead of placing them on stack when out of free GP registers</Title>
    <Description>The idea is intuitive though I'm not sure it was ever sounded in context of CLR JIT - why not use X/Y/ZMM registers for "hot" local variables to avoid stack memory accesses just like common GP registers are used to load/store the values? (I'm not talking here about operations other than load/store  because it's much deeper topic which may include auto-vectorization and other funny stuff.)

There are always up to at least 6 volatile SIMD registers and the number of regs used may be increased up to the size of SIMD register file. With more complex techniques this may provide up to 8 regs for x86/SSE+ up to 16 regs for x64/SSE+ up to 32 regs for x64/AVX-512 (future). These numbers may be achievable in the context of CLR due to the fact that at the moment few code in system assemblies uses vectors and to my understanding SIMD ops are now only used for FP operations otherwise.

Even taking into account the store forwarding mechanisms implemented in modern CPUs when accessing memory the significant speed-up could be achieved. One extra point is that on HyperThreaded CPUs the register files are independent on each other whereas memory access circuitry is mostly shared by (sub-)cores.

category:design
theme:register-allocator
skill-level:expert
cost:large</Description>
    <Title_Description>Consider using SIMD registers for "hot" local variables instead of placing them on stack when out of free GP registers The idea is intuitive though I'm not sure it was ever sounded in context of CLR JIT - why not use X/Y/ZMM registers for "hot" local variables to avoid stack memory accesses just like common GP registers are used to load/store the values? (I'm not talking here about operations other than load/store  because it's much deeper topic which may include auto-vectorization and other funny stuff.)

There are always up to at least 6 volatile SIMD registers and the number of regs used may be increased up to the size of SIMD register file. With more complex techniques this may provide up to 8 regs for x86/SSE+ up to 16 regs for x64/SSE+ up to 32 regs for x64/AVX-512 (future). These numbers may be achievable in the context of CLR due to the fact that at the moment few code in system assemblies uses vectors and to my understanding SIMD ops are now only used for FP operations otherwise.

Even taking into account the store forwarding mechanisms implemented in modern CPUs when accessing memory the significant speed-up could be achieved. One extra point is that on HyperThreaded CPUs the register files are independent on each other whereas memory access circuitry is mostly shared by (sub-)cores.

category:design
theme:register-allocator
skill-level:expert
cost:large</Title_Description>
    <Label>Design Discussion</Label>
    <Assignee>tannergooding</Assignee>
    <CreatedAt>4/06/2018 12:33:15 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18272</IssueLabelID>
    <Title>Fix error during compilation with /permissive-</Title>
    <Description>Closes #17944 </Description>
    <Title_Description>Fix error during compilation with /permissive- Closes #17944 </Title_Description>
    <Label>Hackathon</Label>
    <Assignee>kant2002</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18270</IssueLabelID>
    <Title>Unsafe.AsRef is not getting inlined in Span.GetPinnableReference</Title>
    <Description>Repro:

 is not inlined</Description>
    <Title_Description>Unsafe.AsRef is not getting inlined in Span.GetPinnableReference Repro:

 is not inlined</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
    <CreatedAt>4/06/2018 12:24:31 AM +00:00</CreatedAt>
    <ClosedAt>4/06/2018 11:02:02 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18269</IssueLabelID>
    <Title>Regression in 2.1.300: AssemblyName parsing with unicode/emoji crashes</Title>
    <Description>I found a regression in 2.1.300 when trying to upgrade [Xamarin Workbooks](https://github.com/Microsoft/workbooks) to 

_1. If you're interested in _why_ we have assembly names with this particular sequence of emoji feel free to ask!_</Description>
    <Title_Description>Regression in 2.1.300: AssemblyName parsing with unicode/emoji crashes I found a regression in 2.1.300 when trying to upgrade [Xamarin Workbooks](https://github.com/Microsoft/workbooks) to 

_1. If you're interested in _why_ we have assembly names with this particular sequence of emoji feel free to ask!_</Title_Description>
    <Label>area-AssemblyLoader</Label>
    <Assignee>luqunl</Assignee>
    <CreatedAt>3/06/2018 11:43:38 PM +00:00</CreatedAt>
    <ClosedAt>17/07/2018 4:23:09 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18264</IssueLabelID>
    <Title>Set GTF_RELOP_QMARK in gtNewQmarkNode</Title>
    <Description>Add/Set  GTF_RELOP_QMARK in gtNewQmarkNode

Fix https://github.com/dotnet/coreclr/issues/18192
</Description>
    <Title_Description>Set GTF_RELOP_QMARK in gtNewQmarkNode Add/Set  GTF_RELOP_QMARK in gtNewQmarkNode

Fix https://github.com/dotnet/coreclr/issues/18192
</Title_Description>
    <Label>Hackathon</Label>
    <Assignee>luqunl</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18260</IssueLabelID>
    <Title>Warnings cleanup</Title>
    <Description>- Reenables all warnings that do not trigger
- Fixes two of the easier warnings and reenables them too.

contributes to #18128 </Description>
    <Title_Description>Warnings cleanup - Reenables all warnings that do not trigger
- Fixes two of the easier warnings and reenables them too.

contributes to #18128 </Title_Description>
    <Label>Hackathon</Label>
    <Assignee>Suchiman</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18259</IssueLabelID>
    <Title>Wrong value passed to generic interface method in release</Title>
    <Description>On .NET core 2.1.0 and .NET framework 4.7.1 the following program prints </Description>
    <Title_Description>Wrong value passed to generic interface method in release On .NET core 2.1.0 and .NET framework 4.7.1 the following program prints </Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>briansull</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18258</IssueLabelID>
    <Title>Cleanup and remove unused parameters from genCreateAddrMode</Title>
    <Description>fixes #18177</Description>
    <Title_Description>Cleanup and remove unused parameters from genCreateAddrMode fixes #18177</Title_Description>
    <Label>Hackathon</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18257</IssueLabelID>
    <Title>Change gtExtractSideEffList to use GenTreeVisitor</Title>
    <Description>This changes  slows down things a bit - around 0.05% instructions retired. But I don't think such a small regression can justify keeping the custom/duplicate tree traversal logic especially if it can lead to bugs. Besides there are plenty of places in the JIT where one can recover 0.05% without compromising code reliability and clarity.

Fixes #18232</Description>
    <Title_Description>Change gtExtractSideEffList to use GenTreeVisitor This changes  slows down things a bit - around 0.05% instructions retired. But I don't think such a small regression can justify keeping the custom/duplicate tree traversal logic especially if it can lead to bugs. Besides there are plenty of places in the JIT where one can recover 0.05% without compromising code reliability and clarity.

Fixes #18232</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>mikedn</Assignee>
    <CreatedAt>2/06/2018 7:38:04 PM +00:00</CreatedAt>
    <ClosedAt>23/07/2018 7:21:35 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18256</IssueLabelID>
    <Title>Share more of the HWIntrinsic base code between ARM and XArch if possible</Title>
    <Description>https://github.com/dotnet/coreclr/pull/18255 did a fairly big refactoring of the XArch HWIntrinsic code.

There are likely several functions which could be shared between Arm64 and XArch. This issue tracks the initial investigation and any work required.

category:design
theme:intrinsics
skill-level:expert
cost:medium</Description>
    <Title_Description>Share more of the HWIntrinsic base code between ARM and XArch, if possible https://github.com/dotnet/coreclr/pull/18255 did a fairly big refactoring of the XArch HWIntrinsic code.

There are likely several functions which could be shared between Arm64 and XArch. This issue tracks the initial investigation and any work required.

category:design
theme:intrinsics
skill-level:expert
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>tannergooding</Assignee>
    <CreatedAt>2/06/2018 7:25:04 PM +00:00</CreatedAt>
    <ClosedAt>16/10/2019 9:55:14 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18253</IssueLabelID>
    <Title>Implement corefx/#16619: Add FormattableString.CurrentCulture</Title>
    <Description>Implement https://github.com/dotnet/corefx/issues/16619: Add FormattableString.CurrentCulture</Description>
    <Title_Description>Implement corefx/#16619: Add FormattableString.CurrentCulture Implement https://github.com/dotnet/corefx/issues/16619: Add FormattableString.CurrentCulture</Title_Description>
    <Label>Hackathon</Label>
    <Assignee>mikhailshilkov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18252</IssueLabelID>
    <Title>Setting breakpoint in managed function using lldb</Title>
    <Description>I want to set breakpoint on my function 
</Description>
    <Title_Description>Setting breakpoint in managed function using lldb I want to set breakpoint on my function 
</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>2/06/2018 11:54:29 AM +00:00</CreatedAt>
    <ClosedAt>7/06/2018 11:13:35 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18249</IssueLabelID>
    <Title>Convert Decimal to all-managed implementation</Title>
    <Description>CoreCLR's is in
https://github.com/dotnet/coreclr/blob/master/src/System.Private.CoreLib/src/System/Decimal.cs
https://github.com/dotnet/coreclr/blob/master/src/classlibnative/bcltype/decimal.cpp

The place to start is by grabbing the code verbatim from CoreRT and measuring performance then optimizing to fix any regression:

https://github.com/dotnet/corert/blob/master/src/System.Private.CoreLib/src/System/Decimal.cs
https://github.com/dotnet/corert/blob/master/src/System.Private.CoreLib/src/System/Decimal.DecCalc.cs

Ensuring tests have good coverage of course.</Description>
    <Title_Description>Convert Decimal to all-managed implementation CoreCLR's is in
https://github.com/dotnet/coreclr/blob/master/src/System.Private.CoreLib/src/System/Decimal.cs
https://github.com/dotnet/coreclr/blob/master/src/classlibnative/bcltype/decimal.cpp

The place to start is by grabbing the code verbatim from CoreRT and measuring performance then optimizing to fix any regression:

https://github.com/dotnet/corert/blob/master/src/System.Private.CoreLib/src/System/Decimal.cs
https://github.com/dotnet/corert/blob/master/src/System.Private.CoreLib/src/System/Decimal.DecCalc.cs

Ensuring tests have good coverage of course.</Title_Description>
    <Label>Hackathon</Label>
    <Assignee>pentp</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18247</IssueLabelID>
    <Title>Fix PCODE not having thumb bit set when comparing two addresses</Title>
    <Description>
    </Description>
    <Title_Description>Fix PCODE not having thumb bit set when comparing two addresses </Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>chsienki</Assignee>
    <CreatedAt>1/06/2018 10:44:09 PM +00:00</CreatedAt>
    <ClosedAt>11/06/2018 6:12:45 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18246</IssueLabelID>
    <Title>Enable tailcall_v4\smallFrame\smallFrame</Title>
    <Description>PR #11316  removed the bad IL sequences from this test but left these tests disabled for arm/arm64.</Description>
    <Title_Description>Enable tailcall_v4\smallFrame\smallFrame PR #11316  removed the bad IL sequences from this test but left these tests disabled for arm/arm64.</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>1/06/2018 10:35:51 PM +00:00</CreatedAt>
    <ClosedAt>2/06/2018 10:40:14 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18245</IssueLabelID>
    <Title>Replace some sizeof-s with target specific constants</Title>
    <Description>The goal of this PR is to identify all places in VM using sizeof operator that should be made target-specific in order to support cross-bitness scenario #16513. &lt;s&gt;The proposal is to introduce CrossBitness_SizeOf operator to make such places *explicit*.

CrossBitness_SizeOf operator satisfies the following conditions:
1. CrossBitness_SizeOf(X) == sizeof(X) in non-crossbitness scenarios;
2. CrossBitness_SizeOf(X) == sizeof(Y) where Y is a "fake" structure created to describe layout of X on the target platform in crossbitness scenarios (i.e. x64_arm). Note that usually sizeof(X) != sizeof(Y).&lt;/s&gt;

It's been proven experimentally that this subset of changes is needed in order to get outputs of x64_arm and arm_arm crossgens to be binary identical for S.P.C.dll and CoreFx assemblies.&lt;/s&gt;

This PR also includes other related changes:
1.  expressions with target-specifics constants

@jkotas PTAL</Description>
    <Title_Description>Replace some sizeof-s with target specific constants The goal of this PR is to identify all places in VM using sizeof operator that should be made target-specific in order to support cross-bitness scenario #16513. &lt;s&gt;The proposal is to introduce CrossBitness_SizeOf operator to make such places *explicit*.

CrossBitness_SizeOf operator satisfies the following conditions:
1. CrossBitness_SizeOf(X) == sizeof(X) in non-crossbitness scenarios;
2. CrossBitness_SizeOf(X) == sizeof(Y) where Y is a "fake" structure created to describe layout of X on the target platform in crossbitness scenarios (i.e. x64_arm). Note that usually sizeof(X) != sizeof(Y).&lt;/s&gt;

It's been proven experimentally that this subset of changes is needed in order to get outputs of x64_arm and arm_arm crossgens to be binary identical for S.P.C.dll and CoreFx assemblies.&lt;/s&gt;

This PR also includes other related changes:
1.  expressions with target-specifics constants

@jkotas PTAL</Title_Description>
    <Label>area-VM</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>1/06/2018 10:34:34 PM +00:00</CreatedAt>
    <ClosedAt>4/06/2018 5:08:23 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18244</IssueLabelID>
    <Title>Exception when trying to GCHandle.Alloc(new ValueTuple&lt;ulong ulong&gt;[1] GCHandleType.Pinned)</Title>
    <Description>I'm getting exception when I try to pin array of s using this statement with .NET Core 2.1 release:

&gt; GCHandle.Alloc(new ValueTuple&lt;ulong ulong&gt;[1] GCHandleType.Pinned)

The exception tells:
&gt; System.ArgumentException
&gt;   HResult=0x80070057
&gt;   Message=Object contains non-primitive or non-blittable data.
&gt;   Source=System.Private.CoreLib
&gt;   StackTrace:
&gt;    at System.Runtime.InteropServices.GCHandle.InternalAlloc(Object value GCHandleType type)
&gt;    at System.Runtime.InteropServices.GCHandle.Alloc(Object value GCHandleType type) in E:\A\_work\31\s\src\mscorlib\src\System\Runtime\InteropServices\GcHandle.cs:line 94
</Description>
    <Title_Description>Exception when trying to GCHandle.Alloc(new ValueTuple&lt;ulong, ulong&gt;[1], GCHandleType.Pinned) I'm getting exception when I try to pin array of s using this statement with .NET Core 2.1 release:

&gt; GCHandle.Alloc(new ValueTuple&lt;ulong ulong&gt;[1] GCHandleType.Pinned)

The exception tells:
&gt; System.ArgumentException
&gt;   HResult=0x80070057
&gt;   Message=Object contains non-primitive or non-blittable data.
&gt;   Source=System.Private.CoreLib
&gt;   StackTrace:
&gt;    at System.Runtime.InteropServices.GCHandle.InternalAlloc(Object value GCHandleType type)
&gt;    at System.Runtime.InteropServices.GCHandle.Alloc(Object value GCHandleType type) in E:\A\_work\31\s\src\mscorlib\src\System\Runtime\InteropServices\GcHandle.cs:line 94
</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>1/06/2018 9:37:41 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18242</IssueLabelID>
    <Title>Mirror changes from dotnet/corert</Title>
    <Description>This PR contains mirrored changes from dotnet/corert


**Please REBASE this PR when merging**</Description>
    <Title_Description>Mirror changes from dotnet/corert This PR contains mirrored changes from dotnet/corert


**Please REBASE this PR when merging**</Title_Description>
    <Label>
    </Label>
    <Assignee>jkotas</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18238</IssueLabelID>
    <Title>Cast to ushort is dropped in release</Title>
    <Description>The following program gives different outputs for release and debug:
.
@mikedn has analyzed the cause [here](https://github.com/dotnet/coreclr/issues/18235#issuecomment-393915294).

This issue repros on .NET framework as well with 64-bit JIT (it does not repro with 32-bit JIT).</Description>
    <Title_Description>Cast to ushort is dropped in release The following program gives different outputs for release and debug:
.
@mikedn has analyzed the cause [here](https://github.com/dotnet/coreclr/issues/18235#issuecomment-393915294).

This issue repros on .NET framework as well with 64-bit JIT (it does not repro with 32-bit JIT).</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>erozenfeld</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18235</IssueLabelID>
    <Title>Wrong integer promotion in release</Title>
    <Description>For .NET core 2.1 the following program outputs 1023 in debug but 255 in release.


This issue repros on .NET framework 4.6.1 as well with 64-bit JIT (it does not repro with 32-bit JIT). The compiler used is csc.exe 2.8.3.62923 (7aafab56).</Description>
    <Title_Description>Wrong integer promotion in release For .NET core 2.1 the following program outputs 1023 in debug but 255 in release.


This issue repros on .NET framework 4.6.1 as well with 64-bit JIT (it does not repro with 32-bit JIT). The compiler used is csc.exe 2.8.3.62923 (7aafab56).</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>jakobbotsch</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18234</IssueLabelID>
    <Title>Enable Alpine cross build for arm and arm64</Title>
    <Description>This change enables cross build and rootfs creation for
Alpine Linux ARM / ARM64 targets.

Besides that I've cleaned up the toolchain.cmake and got rid
of the explicit specification of GCC version specific include
and lib folders for all targets except of Tizen. Clang is able
to figure that out on its own the same way as it does when doing
regular non-cross builds but it needed one more option for that.

I've also fixed a bug in the  would do nothing.
</Description>
    <Title_Description>Enable Alpine cross build for arm and arm64 This change enables cross build and rootfs creation for
Alpine Linux ARM / ARM64 targets.

Besides that I've cleaned up the toolchain.cmake and got rid
of the explicit specification of GCC version specific include
and lib folders for all targets except of Tizen. Clang is able
to figure that out on its own the same way as it does when doing
regular non-cross builds but it needed one more option for that.

I've also fixed a bug in the  would do nothing.
</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>janvorli</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18232</IssueLabelID>
    <Title>NullReferenceException thrown for multi-dimensional arrays in release</Title>
    <Description>The following program runs successfully in debug but throws a  is used.</Description>
    <Title_Description>NullReferenceException thrown for multi-dimensional arrays in release The following program runs successfully in debug but throws a  is used.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>mikedn</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18230</IssueLabelID>
    <Title>JIT: Eliminate RegTracker (#18179)</Title>
    <Description>https://github.com/dotnet/coreclr/issues/18179
@BruceForstall 
@CarolEidt </Description>
    <Title_Description>JIT: Eliminate RegTracker (#18179) https://github.com/dotnet/coreclr/issues/18179
@BruceForstall 
@CarolEidt </Title_Description>
    <Label>Hackathon</Label>
    <Assignee>cshung</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18229</IssueLabelID>
    <Title>x64 JIT crash 'Compiler::implResolveToken' for typeof(ValueType) containing array of self</Title>
    <Description>The following program crashes the **x64** JIT.

    using System;

    public struct StructTree
    {
        public Double P;
        public StructTree[] rg;
    };

    class Program
    {
        static void Main() =&gt; T = typeof(StructTree);      // &lt;-- EETypeLoadException

        static Type T; // (not important that 'T' be a non-local variable; only done here to
                       // prevent the above assignment from being fully optimized-out)
    }

The exception:

&gt;Exception thrown at 0x00007FFDFD13F218 in ConsoleApp23.exe: Microsoft C++ exception: EETypeLoadException at memory location 0x0000003F1433A450.

Stack trace:

	RaiseException()
	_CxxThrowException()
	Compiler::impResolveToken() Line 277          &lt;--- EETypeLoadException
	Compiler::impImportBlockCode() Line 14293
	Compiler::impImportBlock() Line 16079
	Compiler::impImport() Line 17163
	[Inline Frame] Compiler::fgImport() Line 6800
	Compiler::compCompile() Line 4386
	Compiler::compCompileHelper() Line 6025
	Compiler::compCompile() Line 5359
	jitNativeCode() Line 6666
	CILJit::compileMethod() Line 315
	_CorExeMain()
	_CorExeMain_Exported()
	BaseThreadInitThunk()
	RtlUserThreadStart()

Here's a link to the throwing source code form the [coreclr repo](https://github.com/dotnet/coreclr):

https://github.com/dotnet/coreclr/blob/86c438de4043359942f3e0f46c55fdaa98dc5b2f/src/jit/importer.cpp#L262-L277

As best as I can tell that would be here:

![asm](https://user-images.githubusercontent.com/5589855/40815819-f5e8d6c6-64fd-11e8-9901-98adcc270f9b.png)

The **IL** code for the problematic **C#** JIT target method () is essentially the same for *Debug* and *Release* builds and both exhibit the crash.

	L_0000: ldtoken StructTree
	L_0005: call class [mscorlib]Type [mscorlib]Type::GetTypeFromHandle(valuetype [mscorlib]RuntimeTypeHandle)
	L_000a: stsfld class [mscorlib]Type Program::T
	L_000f: ret 

To Reproduce
----

To reproduce this crash create a new **C#** project for .NET 4.7.2 in the latest VS2017. Enter the code shown at the top. Alternatively [here's a zip](https://github.com/dotnet/coreclr/files/2060673/jit-crash-resolve-token-recursive.zip) of the whole project.

Next on the *Project Properties* pane enable **Native Code Debugging**:

![app-properties](https://user-images.githubusercontent.com/5589855/40815912-a3573802-64fe-11e8-9d48-b0b8c86e142d.png)

On the *Exception Settings* pane enable exceptions as shown here:

![ex-settings](https://user-images.githubusercontent.com/5589855/40815934-cd6d1526-64fe-11e8-8929-2b773df0df56.png)

Here are the debugger settings I used. In the case of **Suppress JIT optimization on module load** it does not have any effect on the issue (the crash occurs in both modes).


![dbg-opts](https://user-images.githubusercontent.com/5589855/40816102-d3693878-64ff-11e8-82e0-16dfaa56e038.png)
</Description>
    <Title_Description>x64 JIT crash 'Compiler::implResolveToken' for typeof(ValueType) containing array of self The following program crashes the **x64** JIT.

    using System;

    public struct StructTree
    {
        public Double P;
        public StructTree[] rg;
    };

    class Program
    {
        static void Main() =&gt; T = typeof(StructTree);      // &lt;-- EETypeLoadException

        static Type T; // (not important that 'T' be a non-local variable; only done here to
                       // prevent the above assignment from being fully optimized-out)
    }

The exception:

&gt;Exception thrown at 0x00007FFDFD13F218 in ConsoleApp23.exe: Microsoft C++ exception: EETypeLoadException at memory location 0x0000003F1433A450.

Stack trace:

	RaiseException()
	_CxxThrowException()
	Compiler::impResolveToken() Line 277          &lt;--- EETypeLoadException
	Compiler::impImportBlockCode() Line 14293
	Compiler::impImportBlock() Line 16079
	Compiler::impImport() Line 17163
	[Inline Frame] Compiler::fgImport() Line 6800
	Compiler::compCompile() Line 4386
	Compiler::compCompileHelper() Line 6025
	Compiler::compCompile() Line 5359
	jitNativeCode() Line 6666
	CILJit::compileMethod() Line 315
	_CorExeMain()
	_CorExeMain_Exported()
	BaseThreadInitThunk()
	RtlUserThreadStart()

Here's a link to the throwing source code form the [coreclr repo](https://github.com/dotnet/coreclr):

https://github.com/dotnet/coreclr/blob/86c438de4043359942f3e0f46c55fdaa98dc5b2f/src/jit/importer.cpp#L262-L277

As best as I can tell that would be here:

![asm](https://user-images.githubusercontent.com/5589855/40815819-f5e8d6c6-64fd-11e8-9901-98adcc270f9b.png)

The **IL** code for the problematic **C#** JIT target method () is essentially the same for *Debug* and *Release* builds and both exhibit the crash.

	L_0000: ldtoken StructTree
	L_0005: call class [mscorlib]Type [mscorlib]Type::GetTypeFromHandle(valuetype [mscorlib]RuntimeTypeHandle)
	L_000a: stsfld class [mscorlib]Type Program::T
	L_000f: ret 

To Reproduce
----

To reproduce this crash create a new **C#** project for .NET 4.7.2 in the latest VS2017. Enter the code shown at the top. Alternatively [here's a zip](https://github.com/dotnet/coreclr/files/2060673/jit-crash-resolve-token-recursive.zip) of the whole project.

Next on the *Project Properties* pane enable **Native Code Debugging**:

![app-properties](https://user-images.githubusercontent.com/5589855/40815912-a3573802-64fe-11e8-9d48-b0b8c86e142d.png)

On the *Exception Settings* pane enable exceptions as shown here:

![ex-settings](https://user-images.githubusercontent.com/5589855/40815934-cd6d1526-64fe-11e8-8929-2b773df0df56.png)

Here are the debugger settings I used. In the case of **Suppress JIT optimization on module load** it does not have any effect on the issue (the crash occurs in both modes).


![dbg-opts](https://user-images.githubusercontent.com/5589855/40816102-d3693878-64ff-11e8-82e0-16dfaa56e038.png)
</Title_Description>
    <Label>area-TypeSystem</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>1/06/2018 1:45:43 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18228</IssueLabelID>
    <Title>[arm32][JitStressRegs=3] Assertion failed 'farthestRefPhysRegRecord != nullptr'</Title>
    <Description>https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_jitstressregs3_tst/9/consoleFull



Possibly related: https://github.com/dotnet/coreclr/issues/18153
</Description>
    <Title_Description>[arm32][JitStressRegs=3] Assertion failed 'farthestRefPhysRegRecord != nullptr' https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_jitstressregs3_tst/9/consoleFull



Possibly related: https://github.com/dotnet/coreclr/issues/18153
</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18210</IssueLabelID>
    <Title>Fix GitHub_16041 test.</Title>
    <Description>This was doing a cpblk of 28 bytes (size of StructY) from StructX but StructX was only 12 bytes big. Change StructY size to 12.

The discussion was in #16090.
cc @dotnet/jit-contrib.

I have checked that with the new size it still repro the original issue (but only on the old version now It doesn't create necessary  for some reasons).</Description>
    <Title_Description>Fix GitHub_16041 test. This was doing a cpblk of 28 bytes (size of StructY) from StructX but StructX was only 12 bytes big. Change StructY size to 12.

The discussion was in #16090.
cc @dotnet/jit-contrib.

I have checked that with the new size it still repro the original issue (but only on the old version now It doesn't create necessary  for some reasons).</Title_Description>
    <Label>test bug</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>30/05/2018 11:36:27 PM +00:00</CreatedAt>
    <ClosedAt>1/06/2018 6:08:34 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18209</IssueLabelID>
    <Title>Support new Japanese calendar eras</Title>
    <Description>Japan is going to introduce the new era next year 2019 this new era will be added to the Japanese calendar. This new era would affect anyone converting formatting or parsing dates using the Japanese calendar.
Users who formatted future dates before introducing the new era and then try to parse these dates after introducing the new era will fail and get parsing exception. The reason is the year number will not be valid in the old era anymore because the new era set a year limit to the old era.

Here is an example:

Format a date like "平成 32年2月1日" which saying year 32 in the era "平成". after we introduce the new era the old era "平成" will be limited up to and including year 31 so year 32 is exceeding the era end.

The fix is to allow the parser succeeds with such dates and have a config switch which can be used to for anyone want the old behavior.</Description>
    <Title_Description>Support new Japanese calendar eras Japan is going to introduce the new era next year 2019 this new era will be added to the Japanese calendar. This new era would affect anyone converting formatting or parsing dates using the Japanese calendar.
Users who formatted future dates before introducing the new era and then try to parse these dates after introducing the new era will fail and get parsing exception. The reason is the year number will not be valid in the old era anymore because the new era set a year limit to the old era.

Here is an example:

Format a date like "平成 32年2月1日" which saying year 32 in the era "平成". after we introduce the new era the old era "平成" will be limited up to and including year 31 so year 32 is exceeding the era end.

The fix is to allow the parser succeeds with such dates and have a config switch which can be used to for anyone want the old behavior.</Title_Description>
    <Label>area-System.Globalization</Label>
    <Assignee>tarekgh</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18208</IssueLabelID>
    <Title>Optimize Encoding.ASCII</Title>
    <Description> checks and so on.

(This is a nice-to-have. This isn't blocking anything as I know.)</Description>
    <Title_Description>Optimize Encoding.ASCII  checks and so on.

(This is a nice-to-have. This isn't blocking anything as I know.)</Title_Description>
    <Label>area-System.Runtime</Label>
    <Assignee>GrabYourPitchforks</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18207</IssueLabelID>
    <Title>Moving MissingFieldException (fully) and MissingMethodException (partially) to shared</Title>
    <Description>- **[First 5 commits explained]**: Reduce diff of StackTrace with coreclr version by (1) moving StackFrameHelper class to its own file (2) renaming and (3) cleaning up documentation
- Reduces diff in MemoryFailPoint by renaming private field
- Reduces diff in TypeLoadException by changing String to string
- Reduces diff in ThrowHelper by sorting using
- **[Last 4 commits explained]**: Moving MissingFieldException and MissingMethodException partially to shared

CoreRT PR: https://github.com/dotnet/corert/pull/5868

cc: @jkotas </Description>
    <Title_Description>Moving MissingFieldException (fully) and MissingMethodException (partially) to shared - **[First 5 commits explained]**: Reduce diff of StackTrace with coreclr version by (1) moving StackFrameHelper class to its own file (2) renaming and (3) cleaning up documentation
- Reduces diff in MemoryFailPoint by renaming private field
- Reduces diff in TypeLoadException by changing String to string
- Reduces diff in ThrowHelper by sorting using
- **[Last 4 commits explained]**: Moving MissingFieldException and MissingMethodException partially to shared

CoreRT PR: https://github.com/dotnet/corert/pull/5868

cc: @jkotas </Title_Description>
    <Label>
    </Label>
    <Assignee>maryamariyan</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18206</IssueLabelID>
    <Title>[arm64] Disable `a % b = a &amp; (b - 1);` optimization.</Title>
    <Description>Morph can't relay on Lower optimization that it can't guarantee.

In this test case we have such tree:


The fix is similar to #17338.

Fixes #17968.

PR #15690 can help to return this optimization back.</Description>
    <Title_Description>[arm64] Disable 

The fix is similar to #17338.

Fixes #17968.

PR #15690 can help to return this optimization back.</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>30/05/2018 9:42:47 PM +00:00</CreatedAt>
    <ClosedAt>1/06/2018 11:19:19 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18205</IssueLabelID>
    <Title>Remove some GT_ASG_op leftovers</Title>
    <Description>
    </Description>
    <Title_Description>Remove some GT_ASG_op leftovers </Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>30/05/2018 7:31:08 PM +00:00</CreatedAt>
    <ClosedAt>25/08/2018 10:30:58 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18204</IssueLabelID>
    <Title>Expose SpinWait.SpinOnce(int sleep1Threshold) overload</Title>
    <Description>To allow customizing the spin count threshold for Sleep(1) usage and to allow disabling the use of Sleep(1).

API review: https://github.com/dotnet/corefx/issues/29623
Part of fix for https://github.com/dotnet/corefx/issues/29595</Description>
    <Title_Description>Expose SpinWait.SpinOnce(int sleep1Threshold) overload To allow customizing the spin count threshold for Sleep(1) usage and to allow disabling the use of Sleep(1).

API review: https://github.com/dotnet/corefx/issues/29623
Part of fix for https://github.com/dotnet/corefx/issues/29595</Title_Description>
    <Label>area-System.Threading</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18203</IssueLabelID>
    <Title>Expose Exception.set_HResult as Public</Title>
    <Description>This is to change Excetion.set_HResult from protected to public so that others can set HResult value for a given exception.

Approved API: https://github.com/dotnet/corefx/issues/29696
Related Corefx Change(ref assembly): https://github.com/dotnet/corefx/pull/29986</Description>
    <Title_Description>Expose Exception.set_HResult as Public This is to change Excetion.set_HResult from protected to public so that others can set HResult value for a given exception.

Approved API: https://github.com/dotnet/corefx/issues/29696
Related Corefx Change(ref assembly): https://github.com/dotnet/corefx/pull/29986</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>luqunl</Assignee>
    <CreatedAt>30/05/2018 6:54:14 PM +00:00</CreatedAt>
    <ClosedAt>31/05/2018 2:37:51 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18202</IssueLabelID>
    <Title>Is Multi-Core JIT ProfileOptimization possible with CoreCLR?</Title>
    <Description>Hey 

This is a question regarding the API . It doesn't seem to be available through .NET CoreCLR (and almost no issues apart #17124) there is a bit of multi-core JIT in [multicorejit.h](https://github.com/dotnet/coreclr/blob/master/src/vm/multicorejit.h) with actually the internal calls declared for both SetProfileRoot/StartProfile... but no C# version of it...

So just wondering if it could be available? If not what were the reason? (Not really used? Not compatible with CoreCLR?...etc.)

Thanks!</Description>
    <Title_Description>Is Multi-Core JIT, ProfileOptimization possible with CoreCLR? Hey 

This is a question regarding the API . It doesn't seem to be available through .NET CoreCLR (and almost no issues apart #17124) there is a bit of multi-core JIT in [multicorejit.h](https://github.com/dotnet/coreclr/blob/master/src/vm/multicorejit.h) with actually the internal calls declared for both SetProfileRoot/StartProfile... but no C# version of it...

So just wondering if it could be available? If not what were the reason? (Not really used? Not compatible with CoreCLR?...etc.)

Thanks!</Title_Description>
    <Label>area-VM</Label>
    <Assignee>brianrob</Assignee>
    <CreatedAt>30/05/2018 6:47:24 PM +00:00</CreatedAt>
    <ClosedAt>31/05/2018 2:51:51 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18201</IssueLabelID>
    <Title>Eliminate GenTreeRegVar and GT_REG_VAR</Title>
    <Description>These are no longer used with the removal of .

category:design
theme:ir
skill-level:intermediate
cost:small</Description>
    <Title_Description>Eliminate GenTreeRegVar and GT_REG_VAR These are no longer used with the removal of .

category:design
theme:ir
skill-level:intermediate
cost:small</Title_Description>
    <Label>Hackathon</Label>
    <Assignee>CarolEidt</Assignee>
    <CreatedAt>30/05/2018 6:22:45 PM +00:00</CreatedAt>
    <ClosedAt>4/01/2019 3:41:21 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18198</IssueLabelID>
    <Title>Clean up threading tests to make them deterministic and not rely on timing</Title>
    <Description>
    </Description>
    <Title_Description>Clean up threading tests to make them deterministic and not rely on timing </Title_Description>
    <Label>area-System.Threading</Label>
    <Assignee>kouvel</Assignee>
    <CreatedAt>30/05/2018 4:34:43 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18196</IssueLabelID>
    <Title>JIT: Implement or eliminate GTF_REG_BIRTH</Title>
    <Description>This flag is no longer used after the removal of  over using "birth" and "death" terminology.

category:design
theme:liveness
skill-level:expert
cost:medium</Description>
    <Title_Description>JIT: Implement or eliminate GTF_REG_BIRTH This flag is no longer used after the removal of  over using "birth" and "death" terminology.

category:design
theme:liveness
skill-level:expert
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
    <CreatedAt>30/05/2018 4:12:18 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18192</IssueLabelID>
    <Title>Set GTF_RELOP_QMARK in gtNewQmarkNode</Title>
    <Description>Each caller of  rather than at each call site.</Description>
    <Title_Description>Set GTF_RELOP_QMARK in gtNewQmarkNode Each caller of  rather than at each call site.</Title_Description>
    <Label>Hackathon</Label>
    <Assignee>luqunl</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18190</IssueLabelID>
    <Title>[arm64] Implement compRsvdRegCheck</Title>
    <Description>.

category:design
theme:basic-cq
skill-level:intermediate
cost:small
</Description>
    <Title_Description>[arm64] Implement compRsvdRegCheck .

category:design
theme:basic-cq
skill-level:intermediate
cost:small
</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>30/05/2018 12:13:36 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18187</IssueLabelID>
    <Title>[arm32arm64] Stop setting EMIT_TRACK_STACK_DEPTH to 1</Title>
    <Description>In target.h:

Is this a "workaround" that can be fixed?

category:design
theme:gc-info
skill-level:expert
cost:small</Description>
    <Title_Description>[arm32,arm64] Stop setting EMIT_TRACK_STACK_DEPTH to 1 In target.h:

Is this a "workaround" that can be fixed?

category:design
theme:gc-info
skill-level:expert
cost:small</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>29/05/2018 11:53:17 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18186</IssueLabelID>
    <Title>[WIP]Add DllImport Charset UTF8</Title>
    <Description>The purpose is to enable Charset.UTF8 support for DllImport which will help customer to write cross-platform PInvoke.

Partial Fix https://github.com/dotnet/coreclr/issues/1012

Remaining problems:
1. UTF8 Array isn't support yet. 
2. Update roslyn to support Charset UTF8
3. There are couple shift/reduce reduce/reduce conflict for ilasm yy file
4. More testing

Open problems:
1. What's the native type for default char marshalling with [DllImport(CharSet = CharSet.UTF8)]
Currently use U2 instead.
2. Whether UnmanagedType.LPTSTR should support UTF8? 
Currently LPTSTR only supports ANSI/Unicode
3. Whether UnmanagedType.AsAny should support UTF8?  
Currently AsAny doesn't support UTF8.
4. Ongoing support for UTF16(LE/BE) UTF32?


</Description>
    <Title_Description>[WIP]Add DllImport Charset UTF8 The purpose is to enable Charset.UTF8 support for DllImport which will help customer to write cross-platform PInvoke.

Partial Fix https://github.com/dotnet/coreclr/issues/1012

Remaining problems:
1. UTF8 Array isn't support yet. 
2. Update roslyn to support Charset UTF8
3. There are couple shift/reduce reduce/reduce conflict for ilasm yy file
4. More testing

Open problems:
1. What's the native type for default char marshalling with [DllImport(CharSet = CharSet.UTF8)]
Currently use U2 instead.
2. Whether UnmanagedType.LPTSTR should support UTF8? 
Currently LPTSTR only supports ANSI/Unicode
3. Whether UnmanagedType.AsAny should support UTF8?  
Currently AsAny doesn't support UTF8.
4. Ongoing support for UTF16(LE/BE) UTF32?


</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>luqunl</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18185</IssueLabelID>
    <Title>JIT: Eliminate RegTracker</Title>
    <Description>Now that </Description>
    <Title_Description>JIT: Eliminate RegTracker Now that </Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
    <CreatedAt>29/05/2018 11:22:44 PM +00:00</CreatedAt>
    <ClosedAt>29/05/2018 11:36:28 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18182</IssueLabelID>
    <Title>[arm32 arm64] Build framework with IBC data and hot/cold splitting</Title>
    <Description>Apparently the official builds for arm32 and arm64 do not implement IBC data optimization. We should implement this to gain those benefits.

This issue should probably be in some other repo but putting it here for tracking for now.

Related: https://github.com/dotnet/coreclr/issues/18181
</Description>
    <Title_Description>[arm32, arm64] Build framework with IBC data and hot/cold splitting Apparently the official builds for arm32 and arm64 do not implement IBC data optimization. We should implement this to gain those benefits.

This issue should probably be in some other repo but putting it here for tracking for now.

Related: https://github.com/dotnet/coreclr/issues/18181
</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>29/05/2018 9:53:00 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18181</IssueLabelID>
    <Title>[arm64] Implement hot/cold splitting</Title>
    <Description>From 


category:cq
theme:optimization
skill-level:expert
cost:large</Description>
    <Title_Description>[arm64] Implement hot/cold splitting From 


category:cq
theme:optimization
skill-level:expert
cost:large</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>29/05/2018 9:40:05 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18179</IssueLabelID>
    <Title>JIT: Eliminate RegTracker</Title>
    <Description>Now that  is gone do we still need RegTracker?
</Description>
    <Title_Description>JIT: Eliminate RegTracker Now that  is gone do we still need RegTracker?
</Title_Description>
    <Label>Hackathon</Label>
    <Assignee>cshung</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18178</IssueLabelID>
    <Title>[arm64] Implement/remove NYI_ARM64</Title>
    <Description>The following are the remaining . They should either be removed if not needed or implemented or split into a separate issue for each related unimplemented feature.

| File | NYI |
| --- | --- |
| codegenarmarch.cpp | NYI_ARM64("CodeGen::genJmpMethod with multireg HFA arg") |
| ~~codegencommon.cpp~~ | ~~NYI_ARM64("Unsupported JMP indirection")~~ |
| ~~emit.cpp~~ | ~~NYI_ARM64("Need to handle fix-up to data from cold code.")~~ |
| ~~emitarm64.cpp~~ | ~~NYI_ARM64("Relocation Support for long address")~~ |
| ~~morph.cpp~~ | ~~NYI_ARM64("Tail calls via stub are unsupported on this platform.")~~ |
| ~~register_arg_convention.cpp~~ | ~~NYI_ARM64("alignReg")~~ |

category:correctness
theme:testing
skill-level:expert
cost:small</Description>
    <Title_Description>[arm64] Implement/remove NYI_ARM64 The following are the remaining . They should either be removed if not needed or implemented or split into a separate issue for each related unimplemented feature.

| File | NYI |
| --- | --- |
| codegenarmarch.cpp | NYI_ARM64("CodeGen::genJmpMethod with multireg HFA arg") |
| ~~codegencommon.cpp~~ | ~~NYI_ARM64("Unsupported JMP indirection")~~ |
| ~~emit.cpp~~ | ~~NYI_ARM64("Need to handle fix-up to data from cold code.")~~ |
| ~~emitarm64.cpp~~ | ~~NYI_ARM64("Relocation Support for long address")~~ |
| ~~morph.cpp~~ | ~~NYI_ARM64("Tail calls via stub are unsupported on this platform.")~~ |
| ~~register_arg_convention.cpp~~ | ~~NYI_ARM64("alignReg")~~ |

category:correctness
theme:testing
skill-level:expert
cost:small</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>BruceForstall</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18177</IssueLabelID>
    <Title>JIT: Remove unused parameters from genCreateAddrMode</Title>
    <Description>Now that the  and it would be good to clean up this header to follow the format here: https://github.com/dotnet/coreclr/blob/master/Documentation/coding-guidelines/clr-jit-coding-conventions.md#94-function-header-comment</Description>
    <Title_Description>JIT: Remove unused parameters from genCreateAddrMode Now that the  and it would be good to clean up this header to follow the format here: https://github.com/dotnet/coreclr/blob/master/Documentation/coding-guidelines/clr-jit-coding-conventions.md#94-function-header-comment</Title_Description>
    <Label>Hackathon</Label>
    <Assignee>Suchiman</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18176</IssueLabelID>
    <Title>JIT: x86 assertion failed 'header-&gt;gsCookieOffset != INVALID_GS_COOKIE_OFFSET'</Title>
    <Description>Regression caused by #17996.

If the jit sees a zero-sized stackalloc it will push a null unmanaged pointer. Unfortunately the jit may have already decided it needs a GS cookie and without a proper stackalloc it never sets a slot for the GS cookie hence the assert.

Recent CSCs fold away computations leading to zero-sized stackallocs and do this optimization directly in IL. But older CSCs will leave the computations around:

 and so the jit now folds the size computation to zero.</Description>
    <Title_Description>JIT: x86 assertion failed 'header-&gt;gsCookieOffset != INVALID_GS_COOKIE_OFFSET' Regression caused by #17996.

If the jit sees a zero-sized stackalloc it will push a null unmanaged pointer. Unfortunately the jit may have already decided it needs a GS cookie and without a proper stackalloc it never sets a slot for the GS cookie hence the assert.

Recent CSCs fold away computations leading to zero-sized stackallocs and do this optimization directly in IL. But older CSCs will leave the computations around:

 and so the jit now folds the size computation to zero.</Title_Description>
    <Label>arch-x86</Label>
    <Assignee>AndyAyersMS</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18175</IssueLabelID>
    <Title>[Arm64] Enable HW intrinsics for Windows</Title>
    <Description>It appears arm64 HW intrinsics capabilities are enabled for Linux via  and not via a cross-platform mechanism used by Windows.

Enable Windows/Linux parity by enabling (and testing) the HW intrinsics for Windows as well.
</Description>
    <Title_Description>[Arm64] Enable HW intrinsics for Windows It appears arm64 HW intrinsics capabilities are enabled for Linux via  and not via a cross-platform mechanism used by Windows.

Enable Windows/Linux parity by enabling (and testing) the HW intrinsics for Windows as well.
</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18174</IssueLabelID>
    <Title>[arm64/Linux] Enable 'jitnosimd' testing?</Title>
    <Description>Arm64/Linux is missing the netci.groovy 'jitnosimd' testing job ().

It doesn't make sense (or is duplicative) for arm32. But arm64 does support SIMD so should support this mode.
</Description>
    <Title_Description>[arm64/Linux] Enable 'jitnosimd' testing? Arm64/Linux is missing the netci.groovy 'jitnosimd' testing job ().

It doesn't make sense (or is duplicative) for arm32. But arm64 does support SIMD so should support this mode.
</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>BruceForstall</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18172</IssueLabelID>
    <Title>Fix CI views to only include top-level flow jobs</Title>
    <Description>Jobs that are only executed as part of flow jobs should not be included in the per-architecture Jenkins views.

E.g. https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm64/ should not include "_tst" jobs.
</Description>
    <Title_Description>Fix CI views to only include top-level flow jobs Jobs that are only executed as part of flow jobs should not be included in the per-architecture Jenkins views.

E.g. https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm64/ should not include "_tst" jobs.
</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>BruceForstall</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18170</IssueLabelID>
    <Title>[arm64/Windows] Add corefx testing to CI</Title>
    <Description>We have arm32 Windows and Ubuntu arm64 altjit and arm64 Ubuntu corefx testing in CI. Add arm64 Windows (hardware) corefx testing.
</Description>
    <Title_Description>[arm64/Windows] Add corefx testing to CI We have arm32 Windows and Ubuntu arm64 altjit and arm64 Ubuntu corefx testing in CI. Add arm64 Windows (hardware) corefx testing.
</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>BruceForstall</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18162</IssueLabelID>
    <Title>Remove unsafe code from number parsing</Title>
    <Description>There is heavy use of unsafe code in number.parsing.cs and calling code (eg at https://github.com/dotnet/corefx/blob/master/src/Common/src/CoreLib/System/Number.Parsing.cs#L399). This could be rewritten with  resulting in safer code that is also easier to read.

Relates to https://github.com/dotnet/coreclr/pull/17808</Description>
    <Title_Description>Remove unsafe code from number parsing There is heavy use of unsafe code in number.parsing.cs and calling code (eg at https://github.com/dotnet/corefx/blob/master/src/Common/src/CoreLib/System/Number.Parsing.cs#L399). This could be rewritten with  resulting in safer code that is also easier to read.

Relates to https://github.com/dotnet/coreclr/pull/17808</Title_Description>
    <Label>area-System.Runtime</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>29/05/2018 5:32:14 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18157</IssueLabelID>
    <Title> An assembly specified in the application dependencies manifest was not found</Title>
    <Description>I got the following error when I am trying to start asp.net core server not on my dev system:

	  An assembly specified in the application dependencies manifest (PublishError.deps.json) was not found:
		package: 'HtmlAgilityPack' version: '1.8.4'
		path: 'lib/netstandard2.0/HtmlAgilityPack.dll'

Now server is Win 10  but I got this error both on Windows and Linux. On Windows I got not only runtime but also an sdk - doesnt help .

Sample project can be [found here](https://drive.google.com/open?id=1H0ecF5kqkbSCkPM6_Bi9CGX6DlBf9ApS
).</Description>
    <Title_Description> An assembly specified in the application dependencies manifest was not found I got the following error when I am trying to start asp.net core server not on my dev system:

	  An assembly specified in the application dependencies manifest (PublishError.deps.json) was not found:
		package: 'HtmlAgilityPack' version: '1.8.4'
		path: 'lib/netstandard2.0/HtmlAgilityPack.dll'

Now server is Win 10  but I got this error both on Windows and Linux. On Windows I got not only runtime but also an sdk - doesnt help .

Sample project can be [found here](https://drive.google.com/open?id=1H0ecF5kqkbSCkPM6_Bi9CGX6DlBf9ApS
).</Title_Description>
    <Label>area-AssemblyLoader</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>29/05/2018 12:11:30 PM +00:00</CreatedAt>
    <ClosedAt>30/04/2019 7:59:38 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18156</IssueLabelID>
    <Title>Run CoreFX tests as default PR-triggered CI jobs </Title>
    <Description># CoreFX CI Testing Scenario for CoreCLR #

## Current State of CoreFX testing in CoreCLR
Currently the CoreCLR repos runs CoreFX tests by checking out the CoreFX repository at a specified commit (or HEAD by default) building the repo on top of the runtime to test building all tests and subsequently running them.  These jobs run post-check-in in multiple different stress configurations.
While this approach is flexible a few details make it less suited to be used in CI. Firstly breaking changes can creep in due to CoreFX version mismatches. Secondly this process is time-consuming and storage-heavy which is not ideal for quick PR runs. Thirdly in the current state the way to skip running tests is by annotating the test code itself with XUnit annotations requiring changes to be made in both repos and slowing down development 

## Current State of CoreFX testing in CoreRT (Proof of Concept)
When Helix runs CoreFX tests the produced project and test binaries are saved and kept for a limited time. A Test List is produced on every build with the URLs of the binaries. These built test assemblies can be reused for CI jobs allowing a quicker and less resource-intensive way to test changes made to the runtime.
In CoreRT a small subset of framework tests run for every PR. These tests are not built locally but instead an already built set of tests is saved in blob storage and downloaded on request. Each test project includes a XUnit test runner eliminating the need to build it independently.
A minimal test “harness” (in the form of a dummy ) as well as which tests should be excluded – defined either by fully-qualified name their class or namespace with a required reason for exclusion (validated on every test run). The feature will allow CI checks to pass even if a breaking change is propagating - the failing test(s) can be added to the exclusion list with a link to the associated issue or other reason for skipping during test runs avoiding the need to make any modifications to CoreFX-side test code. 

This gives a large degree of flexibility in defining test runs – each definition can be created as an easily extensible JSON file. Utilizing the enforced JSON schema additional tooling can be built around the framework – for example validity of exclusions can be tracked by an associated link to a GitHub issue. The validity of issues can be checked on each test run – using a library/tool similar to [Octokit.NET]( https://github.com/octokit/octokit.net ) .

## Proposal
The approach taken in CoreRT will be extended to cover CoreCLR. The CoreCLR components to be tested will be laid out such that they can be run with the dotnet cli mirroring the [binplacing approach](https://github.com/dotnet/corefx/blob/master/dir.props) in the CoreFX repo 

The established infrastructure pattern will be modified for better integration with the existing codebase – the test harness defining dependencies will be removed and instead the repo's XUnit version will be reused. The Core_Root folder built for current testing scenarios contains most components necessary to run tests and will therefore be reused. 

A test list will sit in the root of the blob storage instance with URL values of each test for supported configurations (e.g. Windows_NT x64). Once tests are run with a specified configuration the test list will be read and the test suites at the relevant URLs downloaded.

Each test flight’s included test assemblies and method/class/namespace exclusions will be defined via a JSON file. The test assemblies can be automatically updated and replaced in blob storage by running a full CoreFX build for each respective configuration. For the current work built CoreFX test assemblies will be copied into separate blob storage to be used by the CI setup. 

Outside of the scope of this proposal binary management can be automated by adding features to dotnet-maestro-bot updating the test assemblies on every update to the current CoreFX version.

</Description>
    <Title_Description>Run CoreFX tests as default PR-triggered CI jobs  # CoreFX CI Testing Scenario for CoreCLR #

## Current State of CoreFX testing in CoreCLR
Currently the CoreCLR repos runs CoreFX tests by checking out the CoreFX repository at a specified commit (or HEAD by default) building the repo on top of the runtime to test building all tests and subsequently running them.  These jobs run post-check-in in multiple different stress configurations.
While this approach is flexible a few details make it less suited to be used in CI. Firstly breaking changes can creep in due to CoreFX version mismatches. Secondly this process is time-consuming and storage-heavy which is not ideal for quick PR runs. Thirdly in the current state the way to skip running tests is by annotating the test code itself with XUnit annotations requiring changes to be made in both repos and slowing down development 

## Current State of CoreFX testing in CoreRT (Proof of Concept)
When Helix runs CoreFX tests the produced project and test binaries are saved and kept for a limited time. A Test List is produced on every build with the URLs of the binaries. These built test assemblies can be reused for CI jobs allowing a quicker and less resource-intensive way to test changes made to the runtime.
In CoreRT a small subset of framework tests run for every PR. These tests are not built locally but instead an already built set of tests is saved in blob storage and downloaded on request. Each test project includes a XUnit test runner eliminating the need to build it independently.
A minimal test “harness” (in the form of a dummy ) as well as which tests should be excluded – defined either by fully-qualified name their class or namespace with a required reason for exclusion (validated on every test run). The feature will allow CI checks to pass even if a breaking change is propagating - the failing test(s) can be added to the exclusion list with a link to the associated issue or other reason for skipping during test runs avoiding the need to make any modifications to CoreFX-side test code. 

This gives a large degree of flexibility in defining test runs – each definition can be created as an easily extensible JSON file. Utilizing the enforced JSON schema additional tooling can be built around the framework – for example validity of exclusions can be tracked by an associated link to a GitHub issue. The validity of issues can be checked on each test run – using a library/tool similar to [Octokit.NET]( https://github.com/octokit/octokit.net ) .

## Proposal
The approach taken in CoreRT will be extended to cover CoreCLR. The CoreCLR components to be tested will be laid out such that they can be run with the dotnet cli mirroring the [binplacing approach](https://github.com/dotnet/corefx/blob/master/dir.props) in the CoreFX repo 

The established infrastructure pattern will be modified for better integration with the existing codebase – the test harness defining dependencies will be removed and instead the repo's XUnit version will be reused. The Core_Root folder built for current testing scenarios contains most components necessary to run tests and will therefore be reused. 

A test list will sit in the root of the blob storage instance with URL values of each test for supported configurations (e.g. Windows_NT x64). Once tests are run with a specified configuration the test list will be read and the test suites at the relevant URLs downloaded.

Each test flight’s included test assemblies and method/class/namespace exclusions will be defined via a JSON file. The test assemblies can be automatically updated and replaced in blob storage by running a full CoreFX build for each respective configuration. For the current work built CoreFX test assemblies will be copied into separate blob storage to be used by the CI setup. 

Outside of the scope of this proposal binary management can be automated by adding features to dotnet-maestro-bot updating the test assemblies on every update to the current CoreFX version.

</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>A-And</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18155</IssueLabelID>
    <Title>Generate native image from IL the same way as produced by JIT</Title>
    <Description>Question:
Is there any way I could get a dump of native executable code that .NET Core JIT creates with some additional custom markup? It is not required to be runnable when transferred to different PC.

I'd like to try to run the tool called "Intel Architecture Code Analyzer" (https://software.intel.com/en-us/articles/intel-architecture-code-analyzer) to analyze the performance of my tool which is currently under development in context of different CPUs - this is what the IACA tool does but it normally accepts compiled native binary file with "magic" byte sequences inserted telling the region of code which is subject for the analysis.
Thanks.
category:design
theme:ngen
skill-level:expert
cost:large</Description>
    <Title_Description>Generate native image from IL the same way as produced by JIT Question:
Is there any way I could get a dump of native executable code that .NET Core JIT creates with some additional custom markup? It is not required to be runnable when transferred to different PC.

I'd like to try to run the tool called "Intel Architecture Code Analyzer" (https://software.intel.com/en-us/articles/intel-architecture-code-analyzer) to analyze the performance of my tool which is currently under development in context of different CPUs - this is what the IACA tool does but it normally accepts compiled native binary file with "magic" byte sequences inserted telling the region of code which is subject for the analysis.
Thanks.
category:design
theme:ngen
skill-level:expert
cost:large</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>28/05/2018 5:46:07 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18154</IssueLabelID>
    <Title>[WIP] Upload perf artifacts to Azure Blob Storage using AzCopy</Title>
    <Description>
    </Description>
    <Title_Description>[WIP] Upload perf artifacts to Azure Blob Storage using AzCopy </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>dotnet-bot</Assignee>
    <CreatedAt>28/05/2018 12:54:12 PM +00:00</CreatedAt>
    <ClosedAt>8/10/2018 3:43:11 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18153</IssueLabelID>
    <Title>Assertion failed 'farthestRefPhysRegRecord != nullptr' /dotnet/coreclr/src/jit/lsra.cpp:3637 </Title>
    <Description>I'm using the x86 version of the CoreCLR to run CoreRT and compile tests for ARM.

After the commit:
&gt; b39a5b2cfad4620ae23cda84186a36ffb463cd5a 

compilation fails (for all tests) with message

&gt; cd /overlay.arm.Debug &amp;&amp; ./corerun ilc.dll --codegenopt "AltJitNgen=*" @/overlay.arm.Debug/pow3/base.ilc.rsp
/dotnet/coreclr/src/jit/lsra.cpp:3637
Assertion failed 'farthestRefPhysRegRecord != nullptr' in 'Sys:DoubleToString(doubleintintint):int' (IL size 14)

The folder /overlay.arm.Debug/ contains necessary parts from CoreRT CoreCLR and CoreFX to 
cross-compile IL binary to native ARM code.  I've followed the following guide: [https://github.com/dotnet/corert/blob/master/Documentation/cross-building.md](url)
The 

I've checked with the following versions of the CoreCRL CoreRT and CoreFX:

CoreCLR: 6bf04a47badd74646e21e70f4e9267c71b7bfd08
CoreFX: ccdb5a48a49d3e932aa00d02749777464f4c8d5b
CoreRT: a028615abe80057e413d632a7c9257208b7c6865


</Description>
    <Title_Description>Assertion failed 'farthestRefPhysRegRecord != nullptr' /dotnet/coreclr/src/jit/lsra.cpp:3637  I'm using the x86 version of the CoreCLR to run CoreRT and compile tests for ARM.

After the commit:
&gt; b39a5b2cfad4620ae23cda84186a36ffb463cd5a 

compilation fails (for all tests) with message

&gt; cd /overlay.arm.Debug &amp;&amp; ./corerun ilc.dll --codegenopt "AltJitNgen=*" @/overlay.arm.Debug/pow3/base.ilc.rsp
/dotnet/coreclr/src/jit/lsra.cpp:3637
Assertion failed 'farthestRefPhysRegRecord != nullptr' in 'Sys:DoubleToString(doubleintintint):int' (IL size 14)

The folder /overlay.arm.Debug/ contains necessary parts from CoreRT CoreCLR and CoreFX to 
cross-compile IL binary to native ARM code.  I've followed the following guide: [https://github.com/dotnet/corert/blob/master/Documentation/cross-building.md](url)
The 

I've checked with the following versions of the CoreCRL CoreRT and CoreFX:

CoreCLR: 6bf04a47badd74646e21e70f4e9267c71b7bfd08
CoreFX: ccdb5a48a49d3e932aa00d02749777464f4c8d5b
CoreRT: a028615abe80057e413d632a7c9257208b7c6865


</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18151</IssueLabelID>
    <Title>Test failure: GC_Coverage._delete_next_card_table_delete_next_card_table_/_delete_next_card_table_delete_next_card_table_cmd</Title>
    <Description>Opened on behalf of @Sunny-pu

The test  has failed.

Test Infrastructure Failure: Could not load file or assembly 'System.Memory Version=4.1.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. The system cannot find the file specified.
    
    Expected: True
    Actual:   False

        Stack Trace:

        
Build : Master - 20180528.01 (Ready-To-Run Tests)
Failing configurations:
- ubuntu.1604.amd64
  - x64

Details: https://mc.dot.net/#/product/netcore/master/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fr2r~2Fcli~2F/build/20180528.01/workItem/GC.Coverage.XUnitWrapper/analysis/xunit/GC_Coverage._delete_next_card_table_delete_next_card_table_~2F_delete_next_card_table_delete_next_card_table_cmd</Description>
    <Title_Description>Test failure: GC_Coverage._delete_next_card_table_delete_next_card_table_/_delete_next_card_table_delete_next_card_table_cmd Opened on behalf of @Sunny-pu

The test  has failed.

Test Infrastructure Failure: Could not load file or assembly 'System.Memory Version=4.1.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. The system cannot find the file specified.
    
    Expected: True
    Actual:   False

        Stack Trace:

        
Build : Master - 20180528.01 (Ready-To-Run Tests)
Failing configurations:
- ubuntu.1604.amd64
  - x64

Details: https://mc.dot.net/#/product/netcore/master/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fr2r~2Fcli~2F/build/20180528.01/workItem/GC.Coverage.XUnitWrapper/analysis/xunit/GC_Coverage._delete_next_card_table_delete_next_card_table_~2F_delete_next_card_table_delete_next_card_table_cmd</Title_Description>
    <Label>test-run-uwp-coreclr</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>28/05/2018 7:27:44 AM +00:00</CreatedAt>
    <ClosedAt>30/05/2018 6:19:27 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18149</IssueLabelID>
    <Title>Multiple restart of runtime host within the same process</Title>
    <Description>We have requirement to restart the runtime host within the same process. We are using following sequence of calls with ICLRRuntimeHost4 interface as listed in https://docs.microsoft.com/en-us/dotnet/core/tutorials/netcore-hosting

1. Load coreclr library and get m_runtimehost (of type ICLRRuntimeHost4) by calling GetCLRRuntimeHost
2. m_runtimehost-&gt;Start()
3. m_runtimehost-&gt;CreateAppDomainwithManager() =&gt; using SINGLE_APP_DOMAIN
4. m_runtimehost-&gt;CreateDelegate()
5. Call delegates
6. m_runtimehost-&gt;UnloadAppDomain2()
7. m_runtimehost-&gt;Stop()
8. Unload the coreclr library

When we try to repeat the above sequence without restart of the process we get access violation exception at step 2 above with following call stack

        coreclr.dll!SystemDomain::LoadBaseSystemClasses() Line 2715	C++
 	coreclr.dll!SystemDomain::Init() Line 2460	C++
 	coreclr.dll!EEStartupHelper(tagCOINITEE) Line 1058	C++
 	coreclr.dll!EEStartup(tagCOINITEE) Line 1237	C++
 	coreclr.dll!EnsureEEStarted(tagCOINITEE) Line 375	C++
 	coreclr.dll!CorHost2::Start() Line 189	C++

1. Is this known issue? Is there any workaround to restart the runtime host multiple times without restarting the process? We see similar issue with Linux hosts throwing exception in coreclr_initialize method.
2. We are also seeing managed assemblies not being unloaded with UnloadAppDomain2 call mentioned in the step 6 above. Also we expect memory to be released when we call m_runtimehost-&gt;Stop() mentioned in the step 7 above.
</Description>
    <Title_Description>Multiple restart of runtime host within the same process We have requirement to restart the runtime host within the same process. We are using following sequence of calls with ICLRRuntimeHost4 interface as listed in https://docs.microsoft.com/en-us/dotnet/core/tutorials/netcore-hosting

1. Load coreclr library and get m_runtimehost (of type ICLRRuntimeHost4) by calling GetCLRRuntimeHost
2. m_runtimehost-&gt;Start()
3. m_runtimehost-&gt;CreateAppDomainwithManager() =&gt; using SINGLE_APP_DOMAIN
4. m_runtimehost-&gt;CreateDelegate()
5. Call delegates
6. m_runtimehost-&gt;UnloadAppDomain2()
7. m_runtimehost-&gt;Stop()
8. Unload the coreclr library

When we try to repeat the above sequence without restart of the process we get access violation exception at step 2 above with following call stack

        coreclr.dll!SystemDomain::LoadBaseSystemClasses() Line 2715	C++
 	coreclr.dll!SystemDomain::Init() Line 2460	C++
 	coreclr.dll!EEStartupHelper(tagCOINITEE) Line 1058	C++
 	coreclr.dll!EEStartup(tagCOINITEE) Line 1237	C++
 	coreclr.dll!EnsureEEStarted(tagCOINITEE) Line 375	C++
 	coreclr.dll!CorHost2::Start() Line 189	C++

1. Is this known issue? Is there any workaround to restart the runtime host multiple times without restarting the process? We see similar issue with Linux hosts throwing exception in coreclr_initialize method.
2. We are also seeing managed assemblies not being unloaded with UnloadAppDomain2 call mentioned in the step 6 above. Also we expect memory to be released when we call m_runtimehost-&gt;Stop() mentioned in the step 7 above.
</Title_Description>
    <Label>question</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>28/05/2018 4:00:28 AM +00:00</CreatedAt>
    <ClosedAt>31/05/2018 2:13:45 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18148</IssueLabelID>
    <Title>Question: How do I diagnose an IPE?</Title>
    <Description>I am running code on .NET Core that is ported over from mono. The same compiler was used in both instances. Mono runs the IL fine but .NET Core is complaining about invalid IL in a particular method. Is there a debug flag that will make .NET Core spit out the exact instruction that it finds invalid? As the author of said compiler I could fix the bug pointed out by the CLR if I had the instruction pointed out.</Description>
    <Title_Description>Question: How do I diagnose an IPE? I am running code on .NET Core that is ported over from mono. The same compiler was used in both instances. Mono runs the IL fine but .NET Core is complaining about invalid IL in a particular method. Is there a debug flag that will make .NET Core spit out the exact instruction that it finds invalid? As the author of said compiler I could fix the bug pointed out by the CLR if I had the instruction pointed out.</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>27/05/2018 8:05:16 PM +00:00</CreatedAt>
    <ClosedAt>22/02/2019 10:51:57 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18147</IssueLabelID>
    <Title>Report a better error message when assembly version conflict is encountered</Title>
    <Description>The simplest possible .NET Core 1.0 console application throws a 

[ConsoleApp20.zip](https://github.com/dotnet/coreclr/files/2042920/ConsoleApp20.zip)
</Description>
    <Title_Description>Report a better error message when assembly version conflict is encountered The simplest possible .NET Core 1.0 console application throws a 

[ConsoleApp20.zip](https://github.com/dotnet/coreclr/files/2042920/ConsoleApp20.zip)
</Title_Description>
    <Label>area-AssemblyLoader</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>27/05/2018 6:59:24 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18145</IssueLabelID>
    <Title>Some integer scalar and vectored methods/overloads are not exposed in HW intrinsics API</Title>
    <Description>1. Currently the intrinsics are exposed for signed int -&gt; signed int and for unsigned int -&gt; signed int upconversion when both src and dest are 128-bit vector. But no such API method is directly exposed for **unsigned int -&gt; unsigned int** so one has to either use  - merge single element from [m] into xmm. There is special issue open on API for INSERTPS ( #18143 ).

category:testing
theme:intrinsics
skill-level:intermediate
cost:medium</Description>
    <Title_Description>Some integer scalar and vectored methods/overloads are not exposed in HW intrinsics API 1. Currently the intrinsics are exposed for signed int -&gt; signed int and for unsigned int -&gt; signed int upconversion when both src and dest are 128-bit vector. But no such API method is directly exposed for **unsigned int -&gt; unsigned int** so one has to either use  - merge single element from [m] into xmm. There is special issue open on API for INSERTPS ( #18143 ).

category:testing
theme:intrinsics
skill-level:intermediate
cost:medium</Title_Description>
    <Label>Design Discussion</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>27/05/2018 4:27:50 PM +00:00</CreatedAt>
    <ClosedAt>21/03/2019 4:15:48 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18144</IssueLabelID>
    <Title>Sub-optimal performance when saving/restoring upper parts of YMM regs on AVX+ before/after invoking nested methods</Title>
    <Description>Currently 
category:cq
theme:register-allocator
skill-level:expert
cost:medium
</Description>
    <Title_Description>Sub-optimal performance when saving/restoring upper parts of YMM regs on AVX+ before/after invoking nested methods Currently 
category:cq
theme:register-allocator
skill-level:expert
cost:medium
</Title_Description>
    <Label>arch-x64</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18143</IssueLabelID>
    <Title>HW intrinsics API declaration is incorrect for Sse41.Insert() that operates on vector of 32-bit floats</Title>
    <Description>The </Description>
    <Title_Description>HW intrinsics API declaration is incorrect for Sse41.Insert() that operates on vector of 32-bit floats The </Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
    <CreatedAt>27/05/2018 12:33:45 PM +00:00</CreatedAt>
    <ClosedAt>18/06/2018 8:17:42 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18137</IssueLabelID>
    <Title>Create a profiler API that appends to the TPA list</Title>
    <Description>This is a more distilled design proposal that solves issues raised in #3894. The idea is to add a new profiler API such as:

    ICorProfilerInfo10::AddAssemblyPath(AppDomainID appDomainId const WCHAR* pAssemblyPath)

which will add a path to list of assemblies that the runtime probes to resolve assembly references. This allows profilers to instrument managed code and include assembly references to a new assembly that was deployed by the profiler rather than being deployed as part of the application.


**Background info to assist implementors**

Probably the hardest part of the problem is creating a testable repro scenario (assuming you don't already have your own IL instrumenting profiler handy). There is an example instrumenting profiler here: https://github.com/Microsoft/clr-samples/tree/master/ProfilingAPI/ReJITEnterLeaveHooks that has most of what is necessary. However this example instruments using a CALLI instruction:
https://github.com/Microsoft/clr-samples/blob/master/ProfilingAPI/ReJITEnterLeaveHooks/ILRewriter.cpp#L746

To reproduce the problem here the profiler instead needs to:
1) Include with the profiler a new managed assembly that has the implementation of some simple callback within it. Lets call this ManagedInstrumentation.dll.



2) Use IMetaDataAssemblyEmit::DefineAssemblyRef to create an AssemblyRef token that refers to the ManagedInstrumentation.dll assembly.
https://docs.microsoft.com/en-us/dotnet/framework/unmanaged-api/metadata/imetadataassemblyemit-defineassemblyref-method
3) Use IMetaDataEmit::DefineTypeRefByName and DefineMemberRef 
https://docs.microsoft.com/en-us/dotnet/framework/unmanaged-api/metadata/imetadataemit-definetyperefbyname-method
https://docs.microsoft.com/en-us/dotnet/framework/unmanaged-api/metadata/imetadataemit-definememberref-method
to create a MemberRef token that refers to ManagedCallbackFunctions.OnMethodEnter
4) Change the instrumentation to use an IL CALL opcode with the ManagedCallbackFunctions.OnMethodEnter token

Running an application with this profiler should fail because ManagedInstrumentation.dll can't be located.

5) To test the new API you will need to handle the AppDomainCreationFinished callback. In the handler QI for ICorProfilerInfo10 and then invoke AddTrustedAssemblyPath(domainId path_to_ManagedInstrumentation.dll). Initially the QI will fail but once the feature is implemented this call should succeed at modifying the assembly list. Later the compilation of instrumented methods should also succeed because the runtime will find ManagedInstrumentation.dll and load it.

To implement the feature:
1) Add the new API to https://github.com/dotnet/coreclr/blob/master/src/inc/corprof.idl
2) Add an implementation to 
https://github.com/dotnet/coreclr/blob/master/src/vm/proftoeeinterfaceimpl.h
https://github.com/dotnet/coreclr/blob/master/src/vm/proftoeeinterfaceimpl.cpp

The implementation of the method needs to change the TPA list which is stored here: 
https://github.com/dotnet/coreclr/blob/32f0f9721afb584b4a14d69135bea7ddc129f755/src/binder/inc/applicationcontext.inl#L74

Navigating to that datastructure should be something like:

    BaseDomain* pDomain = (BaseDomain *) appDomainId;
    pDomain-&gt;GetTPABinderContext()-&gt;GetAppContext()-&gt;GetTpaList();


More background docs about CLR and profiling:
https://github.com/dotnet/coreclr/tree/master/Documentation/botr
https://github.com/dotnet/coreclr/blob/master/Documentation/botr/profiling.md
https://github.com/dotnet/coreclr/blob/master/Documentation/botr/profilability.md

Where the TPA list normally gets set from without using a profiler:
https://github.com/dotnet/coreclr/blob/ef88a92215a8f90fe0bd8b0327c16bb889902105/src/vm/corhost.cpp#L820
Inside the pProfilerNames/Values there is a property named TRUSTED_PLATFORM_ASSEMBLIES with a list of assembly paths. The runtime host constructs this list however they want (dotnet.exe assembles it from some .json configuration files like app.deps.json) and then the runtime stores it.

</Description>
    <Title_Description>Create a profiler API that appends to the TPA list This is a more distilled design proposal that solves issues raised in #3894. The idea is to add a new profiler API such as:

    ICorProfilerInfo10::AddAssemblyPath(AppDomainID appDomainId const WCHAR* pAssemblyPath)

which will add a path to list of assemblies that the runtime probes to resolve assembly references. This allows profilers to instrument managed code and include assembly references to a new assembly that was deployed by the profiler rather than being deployed as part of the application.


**Background info to assist implementors**

Probably the hardest part of the problem is creating a testable repro scenario (assuming you don't already have your own IL instrumenting profiler handy). There is an example instrumenting profiler here: https://github.com/Microsoft/clr-samples/tree/master/ProfilingAPI/ReJITEnterLeaveHooks that has most of what is necessary. However this example instruments using a CALLI instruction:
https://github.com/Microsoft/clr-samples/blob/master/ProfilingAPI/ReJITEnterLeaveHooks/ILRewriter.cpp#L746

To reproduce the problem here the profiler instead needs to:
1) Include with the profiler a new managed assembly that has the implementation of some simple callback within it. Lets call this ManagedInstrumentation.dll.



2) Use IMetaDataAssemblyEmit::DefineAssemblyRef to create an AssemblyRef token that refers to the ManagedInstrumentation.dll assembly.
https://docs.microsoft.com/en-us/dotnet/framework/unmanaged-api/metadata/imetadataassemblyemit-defineassemblyref-method
3) Use IMetaDataEmit::DefineTypeRefByName and DefineMemberRef 
https://docs.microsoft.com/en-us/dotnet/framework/unmanaged-api/metadata/imetadataemit-definetyperefbyname-method
https://docs.microsoft.com/en-us/dotnet/framework/unmanaged-api/metadata/imetadataemit-definememberref-method
to create a MemberRef token that refers to ManagedCallbackFunctions.OnMethodEnter
4) Change the instrumentation to use an IL CALL opcode with the ManagedCallbackFunctions.OnMethodEnter token

Running an application with this profiler should fail because ManagedInstrumentation.dll can't be located.

5) To test the new API you will need to handle the AppDomainCreationFinished callback. In the handler QI for ICorProfilerInfo10 and then invoke AddTrustedAssemblyPath(domainId path_to_ManagedInstrumentation.dll). Initially the QI will fail but once the feature is implemented this call should succeed at modifying the assembly list. Later the compilation of instrumented methods should also succeed because the runtime will find ManagedInstrumentation.dll and load it.

To implement the feature:
1) Add the new API to https://github.com/dotnet/coreclr/blob/master/src/inc/corprof.idl
2) Add an implementation to 
https://github.com/dotnet/coreclr/blob/master/src/vm/proftoeeinterfaceimpl.h
https://github.com/dotnet/coreclr/blob/master/src/vm/proftoeeinterfaceimpl.cpp

The implementation of the method needs to change the TPA list which is stored here: 
https://github.com/dotnet/coreclr/blob/32f0f9721afb584b4a14d69135bea7ddc129f755/src/binder/inc/applicationcontext.inl#L74

Navigating to that datastructure should be something like:

    BaseDomain* pDomain = (BaseDomain *) appDomainId;
    pDomain-&gt;GetTPABinderContext()-&gt;GetAppContext()-&gt;GetTpaList();


More background docs about CLR and profiling:
https://github.com/dotnet/coreclr/tree/master/Documentation/botr
https://github.com/dotnet/coreclr/blob/master/Documentation/botr/profiling.md
https://github.com/dotnet/coreclr/blob/master/Documentation/botr/profilability.md

Where the TPA list normally gets set from without using a profiler:
https://github.com/dotnet/coreclr/blob/ef88a92215a8f90fe0bd8b0327c16bb889902105/src/vm/corhost.cpp#L820
Inside the pProfilerNames/Values there is a property named TRUSTED_PLATFORM_ASSEMBLIES with a list of assembly paths. The runtime host constructs this list however they want (dotnet.exe assembles it from some .json configuration files like app.deps.json) and then the runtime stores it.

</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>noahfalk</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18133</IssueLabelID>
    <Title>Improve SOS to display current profiler state</Title>
    <Description>**Issue description**
Add a command to SOS to display the profiler's state in a process (whether it is attached and what configuration flags it was set up with). 

The task should be fairly straightforward as all the information that SOS needs to display is already stored in the g_profControlBlock struct. My estimation is roughly 3-4 hours for someone who's not already familiar with the codebase.

This issue is originally from: https://github.com/dotnet/coreclr/issues/12719 (partially)

**A little bit of background**
SOS (Son of Strike) is a debugging extension that allows us to debug managed applications running on top of CLR. You can find the source in the ).

You can follow the code path for other SOS commands that are already implemented (i.e. DumpHeap ClrStack) to see how they are implemented as a reference.

CC @mikem8361 @noahfalk </Description>
    <Title_Description>Improve SOS to display current profiler state **Issue description**
Add a command to SOS to display the profiler's state in a process (whether it is attached and what configuration flags it was set up with). 

The task should be fairly straightforward as all the information that SOS needs to display is already stored in the g_profControlBlock struct. My estimation is roughly 3-4 hours for someone who's not already familiar with the codebase.

This issue is originally from: https://github.com/dotnet/coreclr/issues/12719 (partially)

**A little bit of background**
SOS (Son of Strike) is a debugging extension that allows us to debug managed applications running on top of CLR. You can find the source in the ).

You can follow the code path for other SOS commands that are already implemented (i.e. DumpHeap ClrStack) to see how they are implemented as a reference.

CC @mikem8361 @noahfalk </Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>mikem8361</Assignee>
    <CreatedAt>25/05/2018 11:46:48 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18131</IssueLabelID>
    <Title>Enhance ABI and ISA support in altjits</Title>
    <Description>It would be desirable when an altjit is being used to have the full ABI information available plus a default setting for the ISA support (for hardware intrinsics). This might be easier to accomplish with a cleaner refactored .

category:design
theme:calling-convention
skill-level:expert
cost:medium</Description>
    <Title_Description>Enhance ABI and ISA support in altjits It would be desirable when an altjit is being used to have the full ABI information available plus a default setting for the ISA support (for hardware intrinsics). This might be easier to accomplish with a cleaner refactored .

category:design
theme:calling-convention
skill-level:expert
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
    <CreatedAt>25/05/2018 8:27:16 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18130</IssueLabelID>
    <Title>[Arm64] JIT generate LSE Atomics</Title>
    <Description>When ARMv8.1 LSE Atomics are available use them to implement
Interlocked operations.

@briansull @BruceForstall @CarolEidt @dotnet/jit-contrib </Description>
    <Title_Description>[Arm64] JIT generate LSE Atomics When ARMv8.1 LSE Atomics are available use them to implement
Interlocked operations.

@briansull @BruceForstall @CarolEidt @dotnet/jit-contrib </Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>briansull</Assignee>
    <CreatedAt>25/05/2018 7:51:36 PM +00:00</CreatedAt>
    <ClosedAt>27/06/2018 4:51:33 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18128</IssueLabelID>
    <Title>Clean the list of disabled warnings for CoreCLR</Title>
    <Description>[\src\inc\warningcontrol.h](https://github.com/dotnet/coreclr/blob/master/src/inc/warningcontrol.h) has list of disabled warning for all CoreCLR projects many of them came from the desktop and do not fire on CoreCLR (like 4053 4056 4100 etc) some of them need small fixed (4430) so the task is to:
1. delete all warnings that do not fire;
2. delete warning that needs simple small fixes (and fix them);</Description>
    <Title_Description>Clean the list of disabled warnings for CoreCLR [\src\inc\warningcontrol.h](https://github.com/dotnet/coreclr/blob/master/src/inc/warningcontrol.h) has list of disabled warning for all CoreCLR projects many of them came from the desktop and do not fire on CoreCLR (like 4053 4056 4100 etc) some of them need small fixed (4430) so the task is to:
1. delete all warnings that do not fire;
2. delete warning that needs simple small fixes (and fix them);</Title_Description>
    <Label>Hackathon</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>25/05/2018 6:07:39 PM +00:00</CreatedAt>
    <ClosedAt>4/03/2019 6:40:48 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18123</IssueLabelID>
    <Title>CoreCLR failed when build in conformance mode (/permissive-)  </Title>
    <Description>I build CoreCLR with Visual studio 15.7.1 in conformance mode (/permissive-) on Windows it failed with error C4596 The changes involved by
https://github.com/dotnet/coreclr/commit/b39a5b2cfad4620ae23cda84186a36ffb463cd5a#diff-7844842ffbae44d891b5170d2a229d4bR1590

Could you help remove the redundant "LinearScan::" on BuildRMWUses. The compiler complains about this in conformance mode (/permissive-)

Failures:
d:\coreclr\src\src\jit\lsra.h(1590): error C4596: 'BuildRMWUses': illegal qualified name in member declaration </Description>
    <Title_Description>CoreCLR failed when build in conformance mode (/permissive-)   I build CoreCLR with Visual studio 15.7.1 in conformance mode (/permissive-) on Windows it failed with error C4596 The changes involved by
https://github.com/dotnet/coreclr/commit/b39a5b2cfad4620ae23cda84186a36ffb463cd5a#diff-7844842ffbae44d891b5170d2a229d4bR1590

Could you help remove the redundant "LinearScan::" on BuildRMWUses. The compiler complains about this in conformance mode (/permissive-)

Failures:
d:\coreclr\src\src\jit\lsra.h(1590): error C4596: 'BuildRMWUses': illegal qualified name in member declaration </Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>25/05/2018 6:03:25 AM +00:00</CreatedAt>
    <ClosedAt>4/06/2018 5:10:31 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18121</IssueLabelID>
    <Title>delete unused variables from jit</Title>
    <Description>Delete unused variables after the  death.</Description>
    <Title_Description>delete unused variables from jit Delete unused variables after the  death.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>24/05/2018 11:07:47 PM +00:00</CreatedAt>
    <ClosedAt>25/05/2018 10:02:21 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18117</IssueLabelID>
    <Title>[JitStress] Crossgen JIT/Regression/JitBlue/GitHub_18056/Bool_And_Op_cs_do Jit Assert</Title>
    <Description>Hit this during crossgen in [ 
Ubuntu arm Cross Checked r2r_jitstress1 Build and Test](https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_ubuntu_r2r_jitstress1_tst_prtest/6/consoleText) when testing #18053
</Description>
    <Title_Description>[JitStress] Crossgen JIT/Regression/JitBlue/GitHub_18056/Bool_And_Op_cs_do Jit Assert Hit this during crossgen in [ 
Ubuntu arm Cross Checked r2r_jitstress1 Build and Test](https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_ubuntu_r2r_jitstress1_tst_prtest/6/consoleText) when testing #18053
</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>echesakovMSFT</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18114</IssueLabelID>
    <Title>Collecting StackTrace performance</Title>
    <Description>Why can't I collect stack information?
Currently in the slow tracking details or error details the stack information corresponding to the .NET Core code method cannot be consulted.

The root cause is the poor performance of collecting StackTrace on the .NET Core 2.0 platform. After evaluation each execution of StackTrace will result in millisecond CPU usage.

Technically speaking we can collect the stack but due to performance issues releasing this feature will result in serious impact on user application performance so at present we have not yet opened the stack.

To solve this problem you must expect the .NET Core kernel team to develop a more efficient StackTrace approach.</Description>
    <Title_Description>Collecting StackTrace performance Why can't I collect stack information?
Currently in the slow tracking details or error details the stack information corresponding to the .NET Core code method cannot be consulted.

The root cause is the poor performance of collecting StackTrace on the .NET Core 2.0 platform. After evaluation each execution of StackTrace will result in millisecond CPU usage.

Technically speaking we can collect the stack but due to performance issues releasing this feature will result in serious impact on user application performance so at present we have not yet opened the stack.

To solve this problem you must expect the .NET Core kernel team to develop a more efficient StackTrace approach.</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>24/05/2018 9:26:56 AM +00:00</CreatedAt>
    <ClosedAt>24/05/2018 5:52:14 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18113</IssueLabelID>
    <Title>dynamic keyword takes too much time.</Title>
    <Description>We found that 

[Program.cs.zip](https://github.com/dotnet/coreclr/files/2034454/Program.cs.zip)

</Description>
    <Title_Description>dynamic keyword takes too much time. We found that 

[Program.cs.zip](https://github.com/dotnet/coreclr/files/2034454/Program.cs.zip)

</Title_Description>
    <Label>tenet-performance</Label>
    <Assignee>janvorli</Assignee>
    <CreatedAt>24/05/2018 8:51:16 AM +00:00</CreatedAt>
    <ClosedAt>30/05/2018 5:17:32 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18112</IssueLabelID>
    <Title>Add additional preds checks to flowgraph.</Title>
    <Description>
    </Description>
    <Title_Description>Add additional preds checks to flowgraph. </Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>24/05/2018 7:38:27 AM +00:00</CreatedAt>
    <ClosedAt>1/06/2018 7:05:12 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18111</IssueLabelID>
    <Title>Add managed views of the EE datastructures like MethodTable </Title>
    <Description>CoreRT CoreLib does this already. Related https://github.com/dotnet/coreclr/issues/9474.

It can be used for performance optimizations like https://github.com/dotnet/coreclr/pull/18101#discussion_r190346937</Description>
    <Title_Description>Add managed views of the EE datastructures like MethodTable  CoreRT CoreLib does this already. Related https://github.com/dotnet/coreclr/issues/9474.

It can be used for performance optimizations like https://github.com/dotnet/coreclr/pull/18101#discussion_r190346937</Title_Description>
    <Label>area-Meta-corelib</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>24/05/2018 7:23:14 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18106</IssueLabelID>
    <Title>[Ignore] Testing some issue editing automation.</Title>
    <Description>Please ignore this issue. I'm using it to test some issue editing  automation. It will be deleted.

   category:somecategory1
 theme:sometheme1
     skill-level:beginner
  cost:medium</Description>
    <Title_Description>[Ignore] Testing some issue editing automation. Please ignore this issue. I'm using it to test some issue editing  automation. It will be deleted.

   category:somecategory1
 theme:sometheme1
     skill-level:beginner
  cost:medium</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>erozenfeld</Assignee>
    <CreatedAt>23/05/2018 11:52:41 PM +00:00</CreatedAt>
    <ClosedAt>11/08/2018 7:21:43 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18104</IssueLabelID>
    <Title>[Arm64] Crypto assertion failure</Title>
    <Description>Recent regression 
JIT/HardwareIntrinsics/Arm64/Crypto/Crypto.sh


Failing on 6185b9af8
Passing on fa3e66ea42

@dotnet/arm64-contrib @CarolEidt </Description>
    <Title_Description>[Arm64] Crypto assertion failure Recent regression 
JIT/HardwareIntrinsics/Arm64/Crypto/Crypto.sh


Failing on 6185b9af8
Passing on fa3e66ea42

@dotnet/arm64-contrib @CarolEidt </Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>CarolEidt</Assignee>
    <CreatedAt>23/05/2018 10:16:32 PM +00:00</CreatedAt>
    <ClosedAt>1/06/2018 9:06:20 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18102</IssueLabelID>
    <Title>sharing SerializationInfo for corert and coreclr</Title>
    <Description>I tested locally on corert and on corefx and ran tests to make sure there is nothing is breaking.

I did multiple commits so that it's easier to review. Overall there was not much implementation difference more so it was code styles or renamings in the diff than anything else.

I had to add CORECLR condition in two places only.

I added  method and seems like the api is only public for corefx access. Let me know if we would like to keep it public. It was public in both repos anyway. I did however end up merging the comment contents for this method.

cc: @jkotas @danmosemsft </Description>
    <Title_Description>sharing SerializationInfo for corert and coreclr I tested locally on corert and on corefx and ran tests to make sure there is nothing is breaking.

I did multiple commits so that it's easier to review. Overall there was not much implementation difference more so it was code styles or renamings in the diff than anything else.

I had to add CORECLR condition in two places only.

I added  method and seems like the api is only public for corefx access. Let me know if we would like to keep it public. It was public in both repos anyway. I did however end up merging the comment contents for this method.

cc: @jkotas @danmosemsft </Title_Description>
    <Label>area-System.Runtime</Label>
    <Assignee>maryamariyan</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18100</IssueLabelID>
    <Title>[JIT] Allow the developer to instruct the JIT to do not reorder goto based blocks.</Title>
    <Description>When manually rearranging blocks you end up in situations where you know best what the arrangement is. I hit one of those cases when optimizing memory diffing. Example: https://youtu.be/DD3w66Ff8Ms?t=20859

Give the JIT a hint could help. 



Details on all the tricks can be found at: https://www.youtube.com/watch?time_continue=18053&amp;v=DD3w66Ff8Ms

cc @AndyAyersMS </Description>
    <Title_Description>[JIT] Allow the developer to instruct the JIT to do not reorder goto based blocks. When manually rearranging blocks you end up in situations where you know best what the arrangement is. I hit one of those cases when optimizing memory diffing. Example: https://youtu.be/DD3w66Ff8Ms?t=20859

Give the JIT a hint could help. 



Details on all the tricks can be found at: https://www.youtube.com/watch?time_continue=18053&amp;v=DD3w66Ff8Ms

cc @AndyAyersMS </Title_Description>
    <Label>Design Discussion</Label>
    <Assignee>AndyAyersMS</Assignee>
    <CreatedAt>23/05/2018 4:25:35 PM +00:00</CreatedAt>
    <ClosedAt>24/05/2018 8:09:54 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18098</IssueLabelID>
    <Title>Cancel CTS immediately if delay is zero.</Title>
    <Description>The intended behaviour on specifying a delay of zero is that the CancellationTokenSource is cancelled immediately - before this change it would depend on the scheduling of the timer callback which could lead to seeing a non-cancelled token. Now it marks itself as cancelled immediately without invoking any callbacks (as this method is called only from within the constructor of the object before any callbacks could have been registered.

I can't find any tests for this code so I'm not in a position to update those apologies if I've missed them.</Description>
    <Title_Description>Cancel CTS immediately if delay is zero. The intended behaviour on specifying a delay of zero is that the CancellationTokenSource is cancelled immediately - before this change it would depend on the scheduling of the timer callback which could lead to seeing a non-cancelled token. Now it marks itself as cancelled immediately without invoking any callbacks (as this method is called only from within the constructor of the object before any callbacks could have been registered.

I can't find any tests for this code so I'm not in a position to update those apologies if I've missed them.</Title_Description>
    <Label>
    </Label>
    <Assignee>stephentoub</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18097</IssueLabelID>
    <Title>Which dependencies are runtime dependencies and which ones are build dependencies?</Title>
    <Description>I have a question about the dependencies listed in [the coreclr instructions](https://github.com/dotnet/coreclr/blob/release/2.1/Documentation/building/linux-instructions.md) and [the corefx instructions](https://github.com/dotnet/corefx/blob/master/Documentation/building/unix-instructions.md).
Which dependencies are for runtime and which ones are for build-time only?

Also if I install the SDK and run ldd on all the .so files included and all the dependencies resolve correctly does that mean I have everything I need for runtime installed on the box?
In other words are there any DllImports in the C# for shared libraries other than the ones included in the SDK?</Description>
    <Title_Description>Which dependencies are runtime dependencies and which ones are build dependencies? I have a question about the dependencies listed in [the coreclr instructions](https://github.com/dotnet/coreclr/blob/release/2.1/Documentation/building/linux-instructions.md) and [the corefx instructions](https://github.com/dotnet/corefx/blob/master/Documentation/building/unix-instructions.md).
Which dependencies are for runtime and which ones are for build-time only?

Also if I install the SDK and run ldd on all the .so files included and all the dependencies resolve correctly does that mean I have everything I need for runtime installed on the box?
In other words are there any DllImports in the C# for shared libraries other than the ones included in the SDK?</Title_Description>
    <Label>area-PAL</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>23/05/2018 2:38:14 PM +00:00</CreatedAt>
    <ClosedAt>23/05/2018 9:45:02 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18093</IssueLabelID>
    <Title>Fix parallel spmi return code.</Title>
    <Description>Sort and merge children return codes for the parallel spmi runs.
Found after #17997; our internal system reports exit code 0x3 (missing values) even if there are actual errors (0x1).

cc @dotnet/jit-contrib </Description>
    <Title_Description>Fix parallel spmi return code. Sort and merge children return codes for the parallel spmi runs.
Found after #17997; our internal system reports exit code 0x3 (missing values) even if there are actual errors (0x1).

cc @dotnet/jit-contrib </Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>23/05/2018 1:36:16 AM +00:00</CreatedAt>
    <ClosedAt>23/05/2018 5:23:19 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18091</IssueLabelID>
    <Title>Unexplained ref count sorting for ARM only</Title>
    <Description>The following code in Compiler::WtdRefCntCmp() (and also in the currently-unused Compiler::RefCntCmp) is only for non-ARM targets. This seems strange and unexplained. Should the 
category:cq
theme:basic-cq
skill-level:intermediate
cost:small</Description>
    <Title_Description>Unexplained ref count sorting for ARM only The following code in Compiler::WtdRefCntCmp() (and also in the currently-unused Compiler::RefCntCmp) is only for non-ARM targets. This seems strange and unexplained. Should the 
category:cq
theme:basic-cq
skill-level:intermediate
cost:small</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>22/05/2018 10:44:27 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18088</IssueLabelID>
    <Title>Add -Wthread-safety to CoreCLR build</Title>
    <Description>This found a real issue for us at least on BSD with Clang3.9 and may be more useful as headers are updated. It has no effect on the generated binaries so probably reasonable for us to enable for CoreCLR.

See https://github.com/dotnet/corefx/pull/29850
https://clang.llvm.org/docs/ThreadSafetyAnalysis.html

@janvorli </Description>
    <Title_Description>Add -Wthread-safety to CoreCLR build This found a real issue for us at least on BSD with Clang3.9 and may be more useful as headers are updated. It has no effect on the generated binaries so probably reasonable for us to enable for CoreCLR.

See https://github.com/dotnet/corefx/pull/29850
https://clang.llvm.org/docs/ThreadSafetyAnalysis.html

@janvorli </Title_Description>
    <Label>Hackathon</Label>
    <Assignee>janvorli</Assignee>
    <CreatedAt>22/05/2018 9:37:03 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18084</IssueLabelID>
    <Title>Basic block moved out of the loop flow after JIT optimization</Title>
    <Description>Sometimes JITter moves basic block away from the loop giving two extra 
category:cq
theme:basic-cq
skill-level:intermediate
cost:small</Description>
    <Title_Description>Basic block moved out of the loop flow after JIT optimization Sometimes JITter moves basic block away from the loop giving two extra 
category:cq
theme:basic-cq
skill-level:intermediate
cost:small</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>22/05/2018 11:59:24 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18082</IssueLabelID>
    <Title>Refactor fgDebugCheckBBlist</Title>
    <Description>No Spmi diffs.

This is a preparation PR before the fix for #18056 .</Description>
    <Title_Description>Refactor fgDebugCheckBBlist No Spmi diffs.

This is a preparation PR before the fix for #18056 .</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>22/05/2018 5:49:22 AM +00:00</CreatedAt>
    <ClosedAt>23/05/2018 8:52:16 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18081</IssueLabelID>
    <Title>Implement the HWIntrinsics for FMA</Title>
    <Description>
    </Description>
    <Title_Description>Implement the HWIntrinsics for FMA </Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>tannergooding</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18076</IssueLabelID>
    <Title>Build failure: Link</Title>
    <Description>Opened on behalf of @RussKeldorph

Warnings: 6
Status Message: failed

Build : Master - 20180518.01 (Product Build)
Failing configurations:
- Linux
  - PortableCrossBuild-Checked-arm
  - PortableCrossBuild-Debug-arm64
  - PortableCrossBuild-Release-arm64
  - PortableCrossBuild-Release-arm
  - PortableCrossBuild-Debug-arm
  - Debug-x64
  - Release-x64
  - Checked-x64
  - PortableCrossBuild-Checked-arm64
- Linux-musl
  - Release-x64
  - Checked-x64
  - Debug-x64
- RedHat6
  - Checked-x64
  - Release-x64
  - Debug-x64
- OSX
  - PortableBuild-Release-x64
  - PortableBuild-Debug-x64
  - PortableBuild-Checked-x64
[Mission Control Build Info](https://mc.dot.net/#/product/netcore/master/source/official~2Fcoreclr~2Fmaster~2F/type/build~2Fproduct~2F/build/20180518.01/workItem/Orchestration/analysis/external/Link)
</Description>
    <Title_Description>Build failure: Link Opened on behalf of @RussKeldorph

Warnings: 6
Status Message: failed

Build : Master - 20180518.01 (Product Build)
Failing configurations:
- Linux
  - PortableCrossBuild-Checked-arm
  - PortableCrossBuild-Debug-arm64
  - PortableCrossBuild-Release-arm64
  - PortableCrossBuild-Release-arm
  - PortableCrossBuild-Debug-arm
  - Debug-x64
  - Release-x64
  - Checked-x64
  - PortableCrossBuild-Checked-arm64
- Linux-musl
  - Release-x64
  - Checked-x64
  - Debug-x64
- RedHat6
  - Checked-x64
  - Release-x64
  - Debug-x64
- OSX
  - PortableBuild-Release-x64
  - PortableBuild-Debug-x64
  - PortableBuild-Checked-x64
[Mission Control Build Info](https://mc.dot.net/#/product/netcore/master/source/official~2Fcoreclr~2Fmaster~2F/type/build~2Fproduct~2F/build/20180518.01/workItem/Orchestration/analysis/external/Link)
</Title_Description>
    <Label>area-Tracing</Label>
    <Assignee>brianrob</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18071</IssueLabelID>
    <Title>coreclr.lib</Title>
    <Description>Copying from Dotnet: https://github.com/Microsoft/dotnet/issues/753


daoqiang commented 9 hours ago • edited  
I want to add coreclr to my project. I must introduce it in a static way. What should I do?
There can be no dynamic reference，thank you</Description>
    <Title_Description>coreclr.lib Copying from Dotnet: https://github.com/Microsoft/dotnet/issues/753


daoqiang commented 9 hours ago • edited  
I want to add coreclr to my project. I must introduce it in a static way. What should I do?
There can be no dynamic reference，thank you</Title_Description>
    <Label>area-AssemblyLoader</Label>
    <Assignee>jeffschwMSFT</Assignee>
    <CreatedAt>21/05/2018 5:45:54 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18069</IssueLabelID>
    <Title>Sub-optimal codegen when using Sse.StaticCast&lt;TFromTTo&gt;() with non-VEX encoded HW intrinsics</Title>
    <Description>Below is the source code (basically this is an example of partial vector update code trimmed down for repro):

            // Setup constants
            Vector128&lt;ushort&gt; valuesIncrement = Sse2.SetAllVector128((ushort)0x0001U); // &lt;== no. 1
            Vector128&lt;ushort&gt; opCookie = Sse.StaticCast&lt;ulong ushort&gt;( //&lt;== no. 2
                Sse2.SetVector128(
                    0x0001_0002_0003_0004UL
                    0x0005_0006_0007_0008UL));

            // Setup initial condition
            Vector128&lt;ushort&gt; values = Sse2.SetVector128(
                (ushort)0x1111U (ushort)0x2222U (ushort)0x3333U (ushort)0x4444U
                (ushort)0x5555U (ushort)0x6666U (ushort)0x7777U (ushort)0x8888U);

            // Simulate op
            Vector128&lt;ushort&gt; updateSelector = Sse2.SetAllVector128((ushort)0x0004U);
            Vector128&lt;ushort&gt; updateMask = Sse2.CompareEqual(updateSelector opCookie);
            Vector128&lt;ushort&gt; newValues = Sse2.AddSaturate(values valuesIncrement);

            // Generate codegen issue
            values =
                Sse.StaticCast&lt;byte ushort&gt;(
                    Sse41.BlendVariable(
                        Sse.StaticCast&lt;ushort byte&gt;(values)
                        Sse.StaticCast&lt;ushort byte&gt;(newValues)
                        Sse.StaticCast&lt;ushort byte&gt;(updateMask)));

            Console.WriteLine(values);

With  my i5-750 CPU (Nehalem uarch) which does not support VEX encoding I've got the following asm code with .NET Core 2.1 RC1 JITter (look for the 

(Just checked with Haswell CPU - no major issues appear when VEX-encoded)</Description>
    <Title_Description>Sub-optimal codegen when using Sse.StaticCast&lt;TFrom,TTo&gt;() with non-VEX encoded HW intrinsics Below is the source code (basically this is an example of partial vector update code trimmed down for repro):

            // Setup constants
            Vector128&lt;ushort&gt; valuesIncrement = Sse2.SetAllVector128((ushort)0x0001U); // &lt;== no. 1
            Vector128&lt;ushort&gt; opCookie = Sse.StaticCast&lt;ulong ushort&gt;( //&lt;== no. 2
                Sse2.SetVector128(
                    0x0001_0002_0003_0004UL
                    0x0005_0006_0007_0008UL));

            // Setup initial condition
            Vector128&lt;ushort&gt; values = Sse2.SetVector128(
                (ushort)0x1111U (ushort)0x2222U (ushort)0x3333U (ushort)0x4444U
                (ushort)0x5555U (ushort)0x6666U (ushort)0x7777U (ushort)0x8888U);

            // Simulate op
            Vector128&lt;ushort&gt; updateSelector = Sse2.SetAllVector128((ushort)0x0004U);
            Vector128&lt;ushort&gt; updateMask = Sse2.CompareEqual(updateSelector opCookie);
            Vector128&lt;ushort&gt; newValues = Sse2.AddSaturate(values valuesIncrement);

            // Generate codegen issue
            values =
                Sse.StaticCast&lt;byte ushort&gt;(
                    Sse41.BlendVariable(
                        Sse.StaticCast&lt;ushort byte&gt;(values)
                        Sse.StaticCast&lt;ushort byte&gt;(newValues)
                        Sse.StaticCast&lt;ushort byte&gt;(updateMask)));

            Console.WriteLine(values);

With  my i5-750 CPU (Nehalem uarch) which does not support VEX encoding I've got the following asm code with .NET Core 2.1 RC1 JITter (look for the 

(Just checked with Haswell CPU - no major issues appear when VEX-encoded)</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>mikedn</Assignee>
    <CreatedAt>21/05/2018 3:31:30 PM +00:00</CreatedAt>
    <ClosedAt>12/07/2018 3:36:44 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18068</IssueLabelID>
    <Title>Excess MOVAPS on some non-VEX encoded SSE HW intrinsics having the same 1st and 2nd operand</Title>
    <Description>Codegen for some HW intrinsics on pre-AVX CPU provides result which is obviously too verbose.
Here is sample code:

                Vector128&lt;ulong&gt; vU64 = Sse2.ConvertScalarToVector128UInt64(1UL);
                vU64 = Sse2.UnpackHigh(vU64 vU64);
                Console.WriteLine(vU64);

Here is asm code generated on my i5-750 (Nehalem uarch):

&gt; 000007FE650F5D20  mov         rsircx  
&gt; 000007FE650F5D23  mov         ecx1  
&gt; 000007FE650F5D28  movq        xmm6rcx  
&gt;                 vU64 = Sse2.UnpackHigh(vU64 vU64);
&gt; 000007FE650F5D2D  movaps      xmm0xmm6        ; &lt;==========
&gt; 000007FE650F5D30  punpckhqdq  xmm0xmm6     ; &lt;==========
&gt; 000007FE650F5D34  movaps      xmm6xmm0  
&gt;                 Console.WriteLine(vU64);
&gt; 000007FE650F5D37  mov         rcx7FE650E6750h  
&gt; 000007FE650F5D41  call        000007FEC4BB1940  
&gt; 000007FE650F5D46  mov         rcxrax  
&gt; 000007FE650F5D49  movups      xmmword ptr [rcx+8]xmm6  
&gt; 000007FE650F5D4D  call        000007FE650F2558

 generated - tested with i7-4790K (Haswell uarch w/ AVX &amp; AVX2).

UPD: I'm using .NET Core 2.1 RC1

category:cq
theme:register-allocator
skill-level:intermediate
cost:small</Description>
    <Title_Description>Excess MOVAPS on some non-VEX encoded SSE HW intrinsics having the same 1st and 2nd operand Codegen for some HW intrinsics on pre-AVX CPU provides result which is obviously too verbose.
Here is sample code:

                Vector128&lt;ulong&gt; vU64 = Sse2.ConvertScalarToVector128UInt64(1UL);
                vU64 = Sse2.UnpackHigh(vU64 vU64);
                Console.WriteLine(vU64);

Here is asm code generated on my i5-750 (Nehalem uarch):

&gt; 000007FE650F5D20  mov         rsircx  
&gt; 000007FE650F5D23  mov         ecx1  
&gt; 000007FE650F5D28  movq        xmm6rcx  
&gt;                 vU64 = Sse2.UnpackHigh(vU64 vU64);
&gt; 000007FE650F5D2D  movaps      xmm0xmm6        ; &lt;==========
&gt; 000007FE650F5D30  punpckhqdq  xmm0xmm6     ; &lt;==========
&gt; 000007FE650F5D34  movaps      xmm6xmm0  
&gt;                 Console.WriteLine(vU64);
&gt; 000007FE650F5D37  mov         rcx7FE650E6750h  
&gt; 000007FE650F5D41  call        000007FEC4BB1940  
&gt; 000007FE650F5D46  mov         rcxrax  
&gt; 000007FE650F5D49  movups      xmmword ptr [rcx+8]xmm6  
&gt; 000007FE650F5D4D  call        000007FE650F2558

 generated - tested with i7-4790K (Haswell uarch w/ AVX &amp; AVX2).

UPD: I'm using .NET Core 2.1 RC1

category:cq
theme:register-allocator
skill-level:intermediate
cost:small</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18067</IssueLabelID>
    <Title>On porting .NET Core to FreeBSD</Title>
    <Description>Hello

I'm working on a [project](https://wiki.freebsd.org/SummerOfCode2018Projects/PortingPowerShellPorting) with Google Summer of Code and FreeBSD to port the .NET Core runtime and SDK as well as PowerShell over to the FreeBSD platform. Right now I'm gathering information on how to build and put together the tooling and runtime since the components are pretty scattered around in different repositories.

I've started with CoreCLR and CoreFX to build a working runtime which I'm basing on the 2.1.0 RC1 release -- commit hash [ folder I tried executing a little HelloWorld.dll program I created and built elsewhere on my own built-from-source runtime and it complained about a missing Microsoft.NETCore.App.deps.json file. In what step should it get built and how do I build it?

cc @Petermarcu @jkotas 

I should mention this project is being mentored by @DragonSA (FreeBSD) and @davidchisnall (Microsoft Research and FreeBSD)</Description>
    <Title_Description>On porting .NET Core to FreeBSD Hello

I'm working on a [project](https://wiki.freebsd.org/SummerOfCode2018Projects/PortingPowerShellPorting) with Google Summer of Code and FreeBSD to port the .NET Core runtime and SDK as well as PowerShell over to the FreeBSD platform. Right now I'm gathering information on how to build and put together the tooling and runtime since the components are pretty scattered around in different repositories.

I've started with CoreCLR and CoreFX to build a working runtime which I'm basing on the 2.1.0 RC1 release -- commit hash [ folder I tried executing a little HelloWorld.dll program I created and built elsewhere on my own built-from-source runtime and it complained about a missing Microsoft.NETCore.App.deps.json file. In what step should it get built and how do I build it?

cc @Petermarcu @jkotas 

I should mention this project is being mentored by @DragonSA (FreeBSD) and @davidchisnall (Microsoft Research and FreeBSD)</Title_Description>
    <Label>area-PAL</Label>
    <Assignee>bartonjs</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18063</IssueLabelID>
    <Title>Fix ARM cast codegen</Title>
    <Description>ARM cast codegen is rather convoluted and sometimes does the wrong thing by applying  to the destination type even though this flag is only about the source type.

Fixes #18040</Description>
    <Title_Description>Fix ARM cast codegen ARM cast codegen is rather convoluted and sometimes does the wrong thing by applying  to the destination type even though this flag is only about the source type.

Fixes #18040</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>mikedn</Assignee>
    <CreatedAt>19/05/2018 2:38:47 PM +00:00</CreatedAt>
    <ClosedAt>7/06/2018 5:19:01 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18060</IssueLabelID>
    <Title>Don't close the JIT func info file on shutdown</Title>
    <Description>During shutdown there can be a race between closing/nulling  and a background thread trying to write to it after checking that it was not null. This was found with tiering enabled but it looks like it can happen normally with unlucky timing because background threads aren't torn down on the shutdown path after main exits.</Description>
    <Title_Description>Don't close the JIT func info file on shutdown During shutdown there can be a race between closing/nulling  and a background thread trying to write to it after checking that it was not null. This was found with tiering enabled but it looks like it can happen normally with unlucky timing because background threads aren't torn down on the shutdown path after main exits.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18057</IssueLabelID>
    <Title>add repro for #18056 </Title>
    <Description>Link #18056.

Note: if you change file names then it will change methods hashes and the bug stops to repro.</Description>
    <Title_Description>add repro for #18056  Link #18056.

Note: if you change file names then it will change methods hashes and the bug stops to repro.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>18/05/2018 11:43:43 PM +00:00</CreatedAt>
    <ClosedAt>22/05/2018 4:08:59 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18056</IssueLabelID>
    <Title>[RyuJit/STRESS_BB_PROFILE] flowgraph.cpp  noway_assert(blockPred-&gt;bbTraversalStamp == curTraversalStamp) fails</Title>
    <Description>1. .

Repro: #18057 

category:correctness
theme:testing
skill-level:intermediate
cost:medium</Description>
    <Title_Description>[RyuJit/STRESS_BB_PROFILE] flowgraph.cpp  noway_assert(blockPred-&gt;bbTraversalStamp == curTraversalStamp) fails 1. .

Repro: #18057 

category:correctness
theme:testing
skill-level:intermediate
cost:medium</Title_Description>
    <Label>JitStress</Label>
    <Assignee>sandreenko</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18055</IssueLabelID>
    <Title>[Release/2.1] Use sysconf(_SC_NPROCESSORS_ONLN) in PAL_GetLogicalCpuCountFromOS (#18053)</Title>
    <Description>This is #18053 ifdef-d under  only as suggested in https://github.com/dotnet/coreclr/pull/18053#issuecomment-390349093

/cc @RussKeldorph @dotnet/arm32-contrib @dotnet/arm64-contrib </Description>
    <Title_Description>[Release/2.1] Use sysconf(_SC_NPROCESSORS_ONLN) in PAL_GetLogicalCpuCountFromOS (#18053) This is #18053 ifdef-d under  only as suggested in https://github.com/dotnet/coreclr/pull/18053#issuecomment-390349093

/cc @RussKeldorph @dotnet/arm32-contrib @dotnet/arm64-contrib </Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>18/05/2018 10:56:19 PM +00:00</CreatedAt>
    <ClosedAt>22/05/2018 5:06:14 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18054</IssueLabelID>
    <Title>.NET Core console app hangs</Title>
    <Description>I have a simple ASP.NET Core app with a background service. This background service perform batch data loading. On my dev machine I log these executed SQL commands to the console with EF Core this is a lot of output.
Sometimes in the middle of a batch load the app hangs. Web server is not responding.
OS: Windows 10 Enterprise
.NET Core version 2.1 preview2

I took  dump of the app when it hung. Here is the interesting thread's stack:

Thread   8
Current frame: ntdll!NtWaitForSingleObject + 0x14
Child-SP         RetAddr          Caller Callee
000000554eb3ee90 00007ff97c3e3b7f KERNELBASE!WaitForSingleObjectEx + 0x9f calling ntdll!NtWaitForSingleObject
000000554eb3eea0 00007ff93e320f3b coreclr!Thread::DoAppropriateWaitWorker + 0x2c3 [e:\a\_work\37\s\src\vm\threads.cpp:3780] calling coreclr!ThreadStateNCStackHolder::~ThreadStateNCStackHolder [e:\a\_work\37\s\src\vm\threads.h:7442]
000000554eb3eec0 00007ff93e3bf756 coreclr!EnterMonitorForRestore + 0x5e [e:\a\_work\37\s\src\vm\threads.cpp:4166] calling coreclr!CLRException::HandlerState::CleanupTry [e:\a\_work\37\s\src\vm\clrex.cpp:901]
000000554eb3ef30 00007ff93e37b530 coreclr!CLREventWaitHelper + 0x20 [e:\a\_work\37\s\src\vm\synch.cpp:411] calling kernel32!WaitForSingleObjectEx
000000554eb3ef90 00007ff93e5fb6dd coreclr!SVR::GCHeap::WaitUntilGCComplete + 0x3d [e:\a\_work\37\s\src\gc\gcee.cpp:402] calling coreclr!CLREventBase::WaitEx [e:\a\_work\37\s\src\vm\synch.cpp:431]
000000554eb3efc0 00007ff93e31f74d coreclr!Thread::RareDisablePreemptiveGC + 0x145 [e:\a\_work\37\s\src\vm\threadsuspend.cpp:3065]
000000554eb3f010 00007ff93e3c78e8 coreclr!JIT_RareDisableHelperWorker + 0x68 [e:\a\_work\37\s\src\vm\jithelpers.cpp:5560] calling coreclr!Thread::RareDisablePreemptiveGC [e:\a\_work\37\s\src\vm\threadsuspend.cpp:2981]
000000554eb3f070 00007ff97c42840a KERNELBASE!WideCharToMultiByte + 0x3ca calling KERNELBASE!GetMBNoDefault
000000554eb3f0b0 00007ff97c3febd9 KERNELBASE!ConsoleCallServerGeneric + 0x119 calling KERNELBASE!_security_check_cookie
000000554eb3f110 00007ff8df304b8b (MethodDesc 00007ff8df419f38 + 0xab DomainBoundILStubClass.IL_STUB_PInvoke(UInt32 UInt32 Char* Int32 Byte* Int32 IntPtr IntPtr))
000000554eb3f120 00007ff97fd516d0 ntdll!RtlSetLastWin32Error + 0x40 calling ntdll!_security_check_cookie
000000554eb3f130 00007ff97c412a3a KERNELBASE!WriteFile + 0x7a calling ntdll!NtWriteFile
000000554eb3f160 00007ff93e3cec54 coreclr!JIT_RareDisableHelper + 0x14 [E:\A\_work\37\s\src\vm\amd64\AsmHelpers.asm:234] calling coreclr!JIT_RareDisableHelperWorker [e:\a\_work\37\s\src\vm\jithelpers.cpp:5523]
000000554eb3f1a0 00007ff8df303fff (MethodDesc 00007ff8df4186d8 + 0xbf DomainBoundILStubClass.IL_STUB_PInvoke(IntPtr Byte* Int32 Int32 ByRef IntPtr))
000000554eb3f200 00007ff8df303fdf (MethodDesc 00007ff8df4186d8 + 0x9f DomainBoundILStubClass.IL_STUB_PInvoke(IntPtr Byte* Int32 Int32 ByRef IntPtr))
000000554eb3f260 00007ff9581391b8 (MethodDesc 00007ff8df418520 + 0x68 System.ConsolePal+WindowsConsoleStream.WriteFileNative(IntPtr Byte[] Int32 Int32 Boolean)) calling 00007ff8df303238 (stub for Interop+Kernel32.WriteFile(IntPtr Byte* Int32 Int32 ByRef IntPtr))
000000554eb3f270 00007ff97c445274 KERNELBASE!SetConsoleTextAttribute + 0x24 calling KERNELBASE!ConsoleCallServer
000000554eb3f2c0 00007ff958138f59 (MethodDesc 00007ff8df418500 + 0x49 System.ConsolePal+WindowsConsoleStream.Write(Byte[] Int32 Int32)) calling (MethodDesc 00007ff8df418520 + 0 System.ConsolePal+WindowsConsoleStream.WriteFileNative(IntPtr Byte[] Int32 Int32 Boolean))
000000554eb3f310 00007ff93de6b600 (MethodDesc 00007ff93d7ed5e8 + 0xe0 System.IO.StreamWriter.Flush(Boolean Boolean))
000000554eb3f390 00007ff93de6bed9 (MethodDesc 00007ff93d7ed668 + 0xf9 System.IO.StreamWriter.Write(System.String)) calling (MethodDesc 00007ff93d7ed5e8 + 0 System.IO.StreamWriter.Flush(Boolean Boolean))
000000554eb3f400 00007ff95813e4f0 (MethodDesc 00007ff8df419b30 + 0x50 System.IO.SyncTextWriter.Write(System.String)) calling 00007ff8de7ed300
000000554eb3f420 00007ff9581345fb (MethodDesc 00007ff8df415fb0 + 0xb System.Console.ResetColor()) calling (MethodDesc 00007ff8df4167e0 + 0 System.ConsolePal.ResetColor())
000000554eb3f450 00007ff93bcca77d (MethodDesc 00007ff8deb0b7b0 + 0x3d Microsoft.Extensions.Logging.Console.Internal.WindowsLogConsole.Write(System.String System.Nullable1&lt;System.ConsoleColor&gt;)) calling 00007ff8de7ed340
000000554eb3f480 00007ff93bcca4ad (MethodDesc 00007ff8deafba48 + 0x4d Microsoft.Extensions.Logging.Console.Internal.ConsoleLoggerProcessor.WriteMessage(Microsoft.Extensions.Logging.Console.Internal.LogMessageEntry)) calling 00007ff8de7ed320
000000554eb3f4c0 00007ff93bcca58b (MethodDesc 00007ff8deafba50 + 0xbb Microsoft.Extensions.Logging.Console.Internal.ConsoleLoggerProcessor.ProcessLogQueue()) calling 00007ff8de7ed880
000000554eb3f560 00007ff963236fc0 (MethodDesc 00007ff8deaff048 + 0x40 System.Threading.Thread.ThreadMain_ThreadStart())
000000554eb3f590 00007ff93dc5a4f9 (MethodDesc 00007ff93d7b1d28 + 0x89 System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext System.Threading.ContextCallback System.Object))
000000554eb3f610 00007ff93e3cfa83 coreclr!CallDescrWorkerInternal + 0x83 [E:\A\_work\37\s\src\vm\amd64\CallDescrWorkerAMD64.asm:101]
000000554eb3f628 00007ff93e31733e coreclr!MethodDesc::GetSingleCallableAddrOfVirtualizedCode + 0x92 [e:\a\_work\37\s\src\vm\method.cpp:2010] calling coreclr!MethodTable::GetRestoredSlot [e:\a\_work\37\s\src\vm\methodtable.cpp:9650]
000000554eb3f650 00007ff93e335a39 coreclr!MethodDescCallSite::CallTargetWorker + 0x2b5 [e:\a\_work\37\s\src\vm\callhelpers.cpp:628] calling coreclr!CallDescrWorkerInternal [E:\A\_work\37\s\src\vm\amd64\CallDescrWorkerAMD64.asm:38]
000000554eb3f680 00007ff93e332b0b coreclr!GCToCLREventSink::FirePrvDestroyGCHandle + 0x6b [e:\a\_work\37\s\src\vm\gctoclreventsink.cpp:329] calling coreclr!__security_check_cookie
000000554eb3f6d0 00007ff93e31733e coreclr!MethodDesc::GetSingleCallableAddrOfVirtualizedCode + 0x92 [e:\a\_work\37\s\src\vm\method.cpp:2010] calling coreclr!MethodTable::GetRestoredSlot [e:\a\_work\37\s\src\vm\methodtable.cpp:9650]
000000554eb3f7a0 00007ff93e3a1283 coreclr!ThreadNative::KickOffThread_Worker + 0x143 [e:\a\_work\37\s\src\vm\comsynchronizable.cpp:260] calling coreclr!MethodDescCallSite::CallTargetWorker [e:\a\_work\37\s\src\vm\callhelpers.cpp:333]
000000554eb3f7d0 00007ff97ed99f67 combase!CoVrfNotifyCoInit + 0xf [onecore\com\combase\verifier\threadstate.cxx:490] calling combase!ComVerifierSettings::VerifyThreadStateEnabled [onecore\com\combase\inc\verify.hxx:208]
000000554eb3f830 00007ff97fd4fa44 ntdll!LdrpDropLastInProgressCount + 0x38 calling ntdll!RtlLeaveCriticalSection
000000554eb3f900 00007ff97ed98df6 combase!CoInitializeEx + 0x36 [onecore\com\combase\class\compobj.cxx:3905] calling combase!_CoInitializeEx [onecore\com\combase\class\compobj.cxx:3668]
000000554eb3f910 00007ff93e334ba2 coreclr!ManagedThreadBase_DispatchInner + 0x5a [e:\a\_work\37\s\src\vm\threads.cpp:8852]
000000554eb3f950 00007ff93e3349fe coreclr!ManagedThreadBase_DispatchMiddle + 0x76 [e:\a\_work\37\s\src\vm\threads.cpp:8901] calling coreclr!ManagedThreadBase_DispatchInner [e:\a\_work\37\s\src\vm\threads.cpp:8808]
000000554eb3f960 00007ff93e2d7549 coreclr!EEHeapAllocInProcessHeap + 0x29 [e:\a\_work\37\s\src\vm\hosting.cpp:463] calling ntdll!RtlAllocateHeap
000000554eb3f970 00007ff93e3a8e81 coreclr!ClrFlsIncrementValue + 0x29 [e:\a\_work\37\s\src\inc\clrhost.h:99]
000000554eb3fa50 00007ff93e3348fd coreclr!ManagedThreadBase_DispatchOuter + 0x91 [e:\a\_work\37\s\src\vm\threads.cpp:9140] calling coreclr!ManagedThreadBase_DispatchMiddle [e:\a\_work\37\s\src\vm\threads.cpp:8855]
000000554eb3fac0 00007ff93e3c8573 coreclr!ManagedThreadBase_FullTransitionWithAD + 0x2f [e:\a\_work\37\s\src\vm\threads.cpp:9200] calling coreclr!ManagedThreadBase_DispatchOuter [e:\a\_work\37\s\src\vm\threads.cpp:9092]
000000554eb3fb20 00007ff93e38568a coreclr!ThreadNative::KickOffThread + 0x10a [e:\a\_work\37\s\src\vm\comsynchronizable.cpp:380] calling coreclr!ManagedThreadBase_FullTransitionWithAD [e:\a\_work\37\s\src\vm\threads.cpp:9189]
000000554eb3fc00 00007ff93e385558 coreclr!Thread::intermediateThreadProc + 0x88 [e:\a\_work\37\s\src\vm\threads.cpp:2255]
000000554eb3fe80 00007ff93e385533 coreclr!Thread::intermediateThreadProc + 0x63 [e:\a\_work\37\s\src\vm\threads.cpp:2250] calling coreclr!__chkstk
000000554eb3fec0 00007ff97f6e1fe4 kernel32!BaseThreadInitThunk + 0x14 calling ntdll!LdrpDispatchUserCallTarget
000000554eb3fef0 00007ff97fd7f061 ntdll!RtlUserThreadStart + 0x21 calling ntdll!LdrpDispatchUserCallTarget

Is this a known issue?

</Description>
    <Title_Description>.NET Core console app hangs I have a simple ASP.NET Core app with a background service. This background service perform batch data loading. On my dev machine I log these executed SQL commands to the console with EF Core this is a lot of output.
Sometimes in the middle of a batch load the app hangs. Web server is not responding.
OS: Windows 10 Enterprise
.NET Core version 2.1 preview2

I took  dump of the app when it hung. Here is the interesting thread's stack:

Thread   8
Current frame: ntdll!NtWaitForSingleObject + 0x14
Child-SP         RetAddr          Caller Callee
000000554eb3ee90 00007ff97c3e3b7f KERNELBASE!WaitForSingleObjectEx + 0x9f calling ntdll!NtWaitForSingleObject
000000554eb3eea0 00007ff93e320f3b coreclr!Thread::DoAppropriateWaitWorker + 0x2c3 [e:\a\_work\37\s\src\vm\threads.cpp:3780] calling coreclr!ThreadStateNCStackHolder::~ThreadStateNCStackHolder [e:\a\_work\37\s\src\vm\threads.h:7442]
000000554eb3eec0 00007ff93e3bf756 coreclr!EnterMonitorForRestore + 0x5e [e:\a\_work\37\s\src\vm\threads.cpp:4166] calling coreclr!CLRException::HandlerState::CleanupTry [e:\a\_work\37\s\src\vm\clrex.cpp:901]
000000554eb3ef30 00007ff93e37b530 coreclr!CLREventWaitHelper + 0x20 [e:\a\_work\37\s\src\vm\synch.cpp:411] calling kernel32!WaitForSingleObjectEx
000000554eb3ef90 00007ff93e5fb6dd coreclr!SVR::GCHeap::WaitUntilGCComplete + 0x3d [e:\a\_work\37\s\src\gc\gcee.cpp:402] calling coreclr!CLREventBase::WaitEx [e:\a\_work\37\s\src\vm\synch.cpp:431]
000000554eb3efc0 00007ff93e31f74d coreclr!Thread::RareDisablePreemptiveGC + 0x145 [e:\a\_work\37\s\src\vm\threadsuspend.cpp:3065]
000000554eb3f010 00007ff93e3c78e8 coreclr!JIT_RareDisableHelperWorker + 0x68 [e:\a\_work\37\s\src\vm\jithelpers.cpp:5560] calling coreclr!Thread::RareDisablePreemptiveGC [e:\a\_work\37\s\src\vm\threadsuspend.cpp:2981]
000000554eb3f070 00007ff97c42840a KERNELBASE!WideCharToMultiByte + 0x3ca calling KERNELBASE!GetMBNoDefault
000000554eb3f0b0 00007ff97c3febd9 KERNELBASE!ConsoleCallServerGeneric + 0x119 calling KERNELBASE!_security_check_cookie
000000554eb3f110 00007ff8df304b8b (MethodDesc 00007ff8df419f38 + 0xab DomainBoundILStubClass.IL_STUB_PInvoke(UInt32 UInt32 Char* Int32 Byte* Int32 IntPtr IntPtr))
000000554eb3f120 00007ff97fd516d0 ntdll!RtlSetLastWin32Error + 0x40 calling ntdll!_security_check_cookie
000000554eb3f130 00007ff97c412a3a KERNELBASE!WriteFile + 0x7a calling ntdll!NtWriteFile
000000554eb3f160 00007ff93e3cec54 coreclr!JIT_RareDisableHelper + 0x14 [E:\A\_work\37\s\src\vm\amd64\AsmHelpers.asm:234] calling coreclr!JIT_RareDisableHelperWorker [e:\a\_work\37\s\src\vm\jithelpers.cpp:5523]
000000554eb3f1a0 00007ff8df303fff (MethodDesc 00007ff8df4186d8 + 0xbf DomainBoundILStubClass.IL_STUB_PInvoke(IntPtr Byte* Int32 Int32 ByRef IntPtr))
000000554eb3f200 00007ff8df303fdf (MethodDesc 00007ff8df4186d8 + 0x9f DomainBoundILStubClass.IL_STUB_PInvoke(IntPtr Byte* Int32 Int32 ByRef IntPtr))
000000554eb3f260 00007ff9581391b8 (MethodDesc 00007ff8df418520 + 0x68 System.ConsolePal+WindowsConsoleStream.WriteFileNative(IntPtr Byte[] Int32 Int32 Boolean)) calling 00007ff8df303238 (stub for Interop+Kernel32.WriteFile(IntPtr Byte* Int32 Int32 ByRef IntPtr))
000000554eb3f270 00007ff97c445274 KERNELBASE!SetConsoleTextAttribute + 0x24 calling KERNELBASE!ConsoleCallServer
000000554eb3f2c0 00007ff958138f59 (MethodDesc 00007ff8df418500 + 0x49 System.ConsolePal+WindowsConsoleStream.Write(Byte[] Int32 Int32)) calling (MethodDesc 00007ff8df418520 + 0 System.ConsolePal+WindowsConsoleStream.WriteFileNative(IntPtr Byte[] Int32 Int32 Boolean))
000000554eb3f310 00007ff93de6b600 (MethodDesc 00007ff93d7ed5e8 + 0xe0 System.IO.StreamWriter.Flush(Boolean Boolean))
000000554eb3f390 00007ff93de6bed9 (MethodDesc 00007ff93d7ed668 + 0xf9 System.IO.StreamWriter.Write(System.String)) calling (MethodDesc 00007ff93d7ed5e8 + 0 System.IO.StreamWriter.Flush(Boolean Boolean))
000000554eb3f400 00007ff95813e4f0 (MethodDesc 00007ff8df419b30 + 0x50 System.IO.SyncTextWriter.Write(System.String)) calling 00007ff8de7ed300
000000554eb3f420 00007ff9581345fb (MethodDesc 00007ff8df415fb0 + 0xb System.Console.ResetColor()) calling (MethodDesc 00007ff8df4167e0 + 0 System.ConsolePal.ResetColor())
000000554eb3f450 00007ff93bcca77d (MethodDesc 00007ff8deb0b7b0 + 0x3d Microsoft.Extensions.Logging.Console.Internal.WindowsLogConsole.Write(System.String System.Nullable1&lt;System.ConsoleColor&gt;)) calling 00007ff8de7ed340
000000554eb3f480 00007ff93bcca4ad (MethodDesc 00007ff8deafba48 + 0x4d Microsoft.Extensions.Logging.Console.Internal.ConsoleLoggerProcessor.WriteMessage(Microsoft.Extensions.Logging.Console.Internal.LogMessageEntry)) calling 00007ff8de7ed320
000000554eb3f4c0 00007ff93bcca58b (MethodDesc 00007ff8deafba50 + 0xbb Microsoft.Extensions.Logging.Console.Internal.ConsoleLoggerProcessor.ProcessLogQueue()) calling 00007ff8de7ed880
000000554eb3f560 00007ff963236fc0 (MethodDesc 00007ff8deaff048 + 0x40 System.Threading.Thread.ThreadMain_ThreadStart())
000000554eb3f590 00007ff93dc5a4f9 (MethodDesc 00007ff93d7b1d28 + 0x89 System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext System.Threading.ContextCallback System.Object))
000000554eb3f610 00007ff93e3cfa83 coreclr!CallDescrWorkerInternal + 0x83 [E:\A\_work\37\s\src\vm\amd64\CallDescrWorkerAMD64.asm:101]
000000554eb3f628 00007ff93e31733e coreclr!MethodDesc::GetSingleCallableAddrOfVirtualizedCode + 0x92 [e:\a\_work\37\s\src\vm\method.cpp:2010] calling coreclr!MethodTable::GetRestoredSlot [e:\a\_work\37\s\src\vm\methodtable.cpp:9650]
000000554eb3f650 00007ff93e335a39 coreclr!MethodDescCallSite::CallTargetWorker + 0x2b5 [e:\a\_work\37\s\src\vm\callhelpers.cpp:628] calling coreclr!CallDescrWorkerInternal [E:\A\_work\37\s\src\vm\amd64\CallDescrWorkerAMD64.asm:38]
000000554eb3f680 00007ff93e332b0b coreclr!GCToCLREventSink::FirePrvDestroyGCHandle + 0x6b [e:\a\_work\37\s\src\vm\gctoclreventsink.cpp:329] calling coreclr!__security_check_cookie
000000554eb3f6d0 00007ff93e31733e coreclr!MethodDesc::GetSingleCallableAddrOfVirtualizedCode + 0x92 [e:\a\_work\37\s\src\vm\method.cpp:2010] calling coreclr!MethodTable::GetRestoredSlot [e:\a\_work\37\s\src\vm\methodtable.cpp:9650]
000000554eb3f7a0 00007ff93e3a1283 coreclr!ThreadNative::KickOffThread_Worker + 0x143 [e:\a\_work\37\s\src\vm\comsynchronizable.cpp:260] calling coreclr!MethodDescCallSite::CallTargetWorker [e:\a\_work\37\s\src\vm\callhelpers.cpp:333]
000000554eb3f7d0 00007ff97ed99f67 combase!CoVrfNotifyCoInit + 0xf [onecore\com\combase\verifier\threadstate.cxx:490] calling combase!ComVerifierSettings::VerifyThreadStateEnabled [onecore\com\combase\inc\verify.hxx:208]
000000554eb3f830 00007ff97fd4fa44 ntdll!LdrpDropLastInProgressCount + 0x38 calling ntdll!RtlLeaveCriticalSection
000000554eb3f900 00007ff97ed98df6 combase!CoInitializeEx + 0x36 [onecore\com\combase\class\compobj.cxx:3905] calling combase!_CoInitializeEx [onecore\com\combase\class\compobj.cxx:3668]
000000554eb3f910 00007ff93e334ba2 coreclr!ManagedThreadBase_DispatchInner + 0x5a [e:\a\_work\37\s\src\vm\threads.cpp:8852]
000000554eb3f950 00007ff93e3349fe coreclr!ManagedThreadBase_DispatchMiddle + 0x76 [e:\a\_work\37\s\src\vm\threads.cpp:8901] calling coreclr!ManagedThreadBase_DispatchInner [e:\a\_work\37\s\src\vm\threads.cpp:8808]
000000554eb3f960 00007ff93e2d7549 coreclr!EEHeapAllocInProcessHeap + 0x29 [e:\a\_work\37\s\src\vm\hosting.cpp:463] calling ntdll!RtlAllocateHeap
000000554eb3f970 00007ff93e3a8e81 coreclr!ClrFlsIncrementValue + 0x29 [e:\a\_work\37\s\src\inc\clrhost.h:99]
000000554eb3fa50 00007ff93e3348fd coreclr!ManagedThreadBase_DispatchOuter + 0x91 [e:\a\_work\37\s\src\vm\threads.cpp:9140] calling coreclr!ManagedThreadBase_DispatchMiddle [e:\a\_work\37\s\src\vm\threads.cpp:8855]
000000554eb3fac0 00007ff93e3c8573 coreclr!ManagedThreadBase_FullTransitionWithAD + 0x2f [e:\a\_work\37\s\src\vm\threads.cpp:9200] calling coreclr!ManagedThreadBase_DispatchOuter [e:\a\_work\37\s\src\vm\threads.cpp:9092]
000000554eb3fb20 00007ff93e38568a coreclr!ThreadNative::KickOffThread + 0x10a [e:\a\_work\37\s\src\vm\comsynchronizable.cpp:380] calling coreclr!ManagedThreadBase_FullTransitionWithAD [e:\a\_work\37\s\src\vm\threads.cpp:9189]
000000554eb3fc00 00007ff93e385558 coreclr!Thread::intermediateThreadProc + 0x88 [e:\a\_work\37\s\src\vm\threads.cpp:2255]
000000554eb3fe80 00007ff93e385533 coreclr!Thread::intermediateThreadProc + 0x63 [e:\a\_work\37\s\src\vm\threads.cpp:2250] calling coreclr!__chkstk
000000554eb3fec0 00007ff97f6e1fe4 kernel32!BaseThreadInitThunk + 0x14 calling ntdll!LdrpDispatchUserCallTarget
000000554eb3fef0 00007ff97fd7f061 ntdll!RtlUserThreadStart + 0x21 calling ntdll!LdrpDispatchUserCallTarget

Is this a known issue?

</Title_Description>
    <Label>area-GC</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>18/05/2018 10:32:51 PM +00:00</CreatedAt>
    <ClosedAt>22/05/2018 1:01:27 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18053</IssueLabelID>
    <Title>Use sysconf(_SC_NPROCESSORS_CONF) in PAL_GetLogicalCpuCountFromOS</Title>
    <Description>As we found in #17851  and https://github.com/seanmonstar/num_cpus/issues/34 should be used instead.</Description>
    <Title_Description>Use sysconf(_SC_NPROCESSORS_CONF) in PAL_GetLogicalCpuCountFromOS As we found in #17851  and https://github.com/seanmonstar/num_cpus/issues/34 should be used instead.</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>echesakovMSFT</Assignee>
    <CreatedAt>18/05/2018 10:12:31 PM +00:00</CreatedAt>
    <ClosedAt>24/05/2018 8:57:48 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18052</IssueLabelID>
    <Title>[Arm64] jitStressRegs=3 failures</Title>
    <Description>The following tests fail with jitStressRegs=3 when run on x64/windows using the arm64 altjit:

CoreMangLib\cti\system\mathf\MathFSign\MathFSign.cmd
JIT\Generics\Locals\static_assignment_class01\static_assignment_class01.cmd
JIT\Generics\Constraints\convert_static01\convert_static01.cmd
JIT\IL_Conformance\Old\Conformance_Base\add_ovf_u2\add_ovf_u2.cmd
JIT\jit64\opt\regress\vswhidbey\481244\foo_opt\foo_opt.cmd

Note that this test leg was last run in the CI system on 16 Feb.</Description>
    <Title_Description>[Arm64] jitStressRegs=3 failures The following tests fail with jitStressRegs=3 when run on x64/windows using the arm64 altjit:

CoreMangLib\cti\system\mathf\MathFSign\MathFSign.cmd
JIT\Generics\Locals\static_assignment_class01\static_assignment_class01.cmd
JIT\Generics\Constraints\convert_static01\convert_static01.cmd
JIT\IL_Conformance\Old\Conformance_Base\add_ovf_u2\add_ovf_u2.cmd
JIT\jit64\opt\regress\vswhidbey\481244\foo_opt\foo_opt.cmd

Note that this test leg was last run in the CI system on 16 Feb.</Title_Description>
    <Label>JitStress</Label>
    <Assignee>CarolEidt</Assignee>
    <CreatedAt>18/05/2018 10:09:45 PM +00:00</CreatedAt>
    <ClosedAt>19/05/2018 1:47:58 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18051</IssueLabelID>
    <Title>Mirror changes from dotnet/corert</Title>
    <Description>This PR contains mirrored changes from dotnet/corert


**Please REBASE this PR when merging**</Description>
    <Title_Description>Mirror changes from dotnet/corert This PR contains mirrored changes from dotnet/corert


**Please REBASE this PR when merging**</Title_Description>
    <Label>
    </Label>
    <Assignee>jkotas</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18049</IssueLabelID>
    <Title>Move InsufficientMemory OutOfMemory and ThreadInterrupted exceptions</Title>
    <Description>Moving InsufficientMemoryException OutOfMemoryException and ThreadInterruptedException to shared

The diff shows the difference between the coreclr and corert files.

GetMessageFromNativeResources() is available in Exception.cs. Click [here](https://github.com/dotnet/coreclr/blame/85374ceaed177f71472cc4c23c69daf7402e5048/src/System.Private.CoreLib/src/System/Exception.cs#L731-L757) to view:



cc: @jkotas @danmosemsft should I instead keep using the GetMessageFromNativeResources() (shown above) as I move these exception classes to shared?

Related to: dotnet/coreclr#17904</Description>
    <Title_Description>Move InsufficientMemory, OutOfMemory and ThreadInterrupted exceptions Moving InsufficientMemoryException OutOfMemoryException and ThreadInterruptedException to shared

The diff shows the difference between the coreclr and corert files.

GetMessageFromNativeResources() is available in Exception.cs. Click [here](https://github.com/dotnet/coreclr/blame/85374ceaed177f71472cc4c23c69daf7402e5048/src/System.Private.CoreLib/src/System/Exception.cs#L731-L757) to view:



cc: @jkotas @danmosemsft should I instead keep using the GetMessageFromNativeResources() (shown above) as I move these exception classes to shared?

Related to: dotnet/coreclr#17904</Title_Description>
    <Label>
    </Label>
    <Assignee>maryamariyan</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18048</IssueLabelID>
    <Title>[arm64/Windows] Build using public SDK</Title>
    <Description>Arm64/Windows is currently built in the CI (and locally) using a private Microsoft SDK. With Windows 10 SDK 10.0.17134.0 (shipped with VS 2017 15.7.1) I believe all required arm64 files are public. Also Visual Studio has (since 15.4?) public arm64 Windows compilers. And recent cmake versions supposedly support these new tools.

Thus we should change the build infrastructure including CI and official builds to build arm64/Windows with all public tools and stop using the private toolset.
</Description>
    <Title_Description>[arm64/Windows] Build using public SDK Arm64/Windows is currently built in the CI (and locally) using a private Microsoft SDK. With Windows 10 SDK 10.0.17134.0 (shipped with VS 2017 15.7.1) I believe all required arm64 files are public. Also Visual Studio has (since 15.4?) public arm64 Windows compilers. And recent cmake versions supposedly support these new tools.

Thus we should change the build infrastructure including CI and official builds to build arm64/Windows with all public tools and stop using the private toolset.
</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>BruceForstall</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18047</IssueLabelID>
    <Title>[Arm64/Linux] Intermittent thread failures</Title>
    <Description>There are occasional intermittent failures in thread related tests.

In an effort to fix #18026 it seems worthwhile to track and investigate these.
</Description>
    <Title_Description>[Arm64/Linux] Intermittent thread failures There are occasional intermittent failures in thread related tests.

In an effort to fix #18026 it seems worthwhile to track and investigate these.
</Title_Description>
    <Label>area-System.Threading</Label>
    <Assignee>kouvel</Assignee>
    <CreatedAt>18/05/2018 6:24:44 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18045</IssueLabelID>
    <Title>Intel Hardware Intrinsics test framework design deficiences</Title>
    <Description>A while ago we have had a long discussion about the scope of testing which should be done during Intel Hardware Intrinsics development (for details see https://github.com/dotnet/coreclr/pull/15771).

There were two proposals put forward:
1. Test as little as possible concentrating on a check if expected assembly instruction is emitted;
2. Test for wider range of values including known problematic ones

Currently we use approach from point 1 which IMO opinion is deficient since it led to several missed implementation bugs i.e.:

https://github.com/dotnet/coreclr/issues/17957
https://github.com/dotnet/coreclr/issues/18039
https://github.com/dotnet/coreclr/issues/18041
https://github.com/dotnet/coreclr/issues/18043

It seems that using small set of problematic values for each numeric type would solve that problem without need for creating complex test scenarios i.e.:

1) for integral types: min max -1 0 1
2) for unsigned integral types: min max 1
3) for floating types: +/- infinity +/- max/min +/- 0 subnormal

@AndyAyersMS  @CarolEidt @fiigii @sdmaclea @tannergooding

category:testing
theme:intrinsics
skill-level:intermediate
cost:small
</Description>
    <Title_Description>Intel Hardware Intrinsics test framework design deficiences A while ago we have had a long discussion about the scope of testing which should be done during Intel Hardware Intrinsics development (for details see https://github.com/dotnet/coreclr/pull/15771).

There were two proposals put forward:
1. Test as little as possible concentrating on a check if expected assembly instruction is emitted;
2. Test for wider range of values including known problematic ones

Currently we use approach from point 1 which IMO opinion is deficient since it led to several missed implementation bugs i.e.:

https://github.com/dotnet/coreclr/issues/17957
https://github.com/dotnet/coreclr/issues/18039
https://github.com/dotnet/coreclr/issues/18041
https://github.com/dotnet/coreclr/issues/18043

It seems that using small set of problematic values for each numeric type would solve that problem without need for creating complex test scenarios i.e.:

1) for integral types: min max -1 0 1
2) for unsigned integral types: min max 1
3) for floating types: +/- infinity +/- max/min +/- 0 subnormal

@AndyAyersMS  @CarolEidt @fiigii @sdmaclea @tannergooding

category:testing
theme:intrinsics
skill-level:intermediate
cost:small
</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
    <CreatedAt>18/05/2018 4:29:49 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18044</IssueLabelID>
    <Title>.NET Core application running in docker gets OOMKilled if swapping is disabled</Title>
    <Description>We are running .NET Core applications inside docker containers on a kubernetes cluster. Docker containers get OOMKilled because GC is not executed.

To test this we created a test program which allocates arrays in a loop. These arrays should get deleted by the GC. The program is executed in a docker container with 100Mb memory limit. Kubernetes is not involved in the tests.

When running the test with **swap enabled** everything works as expected and the GC gets triggered when the total memory reaches 100Mb. The test never gets killed.

When running the test with **swap disabled** the test gets OOMKilled when the total memory reaches 100Mb. We have tested this behaviour with ServerGC=true|false and with .NET Core 2.0 and 2.1

Enabling swap is not an option cause it's neither recommended nor supported by Kubernetes.

# Code
you can find out test program here: https://github.com/devKlausS/dotnet_mem_allocator
      
    var rand = new Random();
    List&lt;byte[]&gt; m_arrays = new List&lt;byte[]&gt;();
    
    int iLoop = 0;
    while (true)
    {
        var array = new byte[iAllocBytes];
        var value = (byte)rand.Next();
        Parallel.ForEach(array (item) =&gt;
        {
            item = value;
        });
        rand.NextBytes(array);
    
        if(!bFree)
            m_arrays.Add(array);
    
        if(iCollect &gt; 0 &amp;&amp; iLoop % iCollect == 0)
        {
            Console.WriteLine("run GC");
            GC.Collect();
        }
    
        Console.Write("AllocatedBytesForCurrentThread: " + GC.GetAllocatedBytesForCurrentThread() / 1000000 + "Mb " +
            "TotalMemory: " + GC.GetTotalMemory(bForceFullCollection) / 1000000 + "Mb ");
    
        for(int i = 0; i &lt; GC.MaxGeneration; i++)
        {
            Console.Write("CollectionCount("+i+"): " + GC.CollectionCount(i) + " ");
        }
    
        Console.WriteLine("");
    
        Thread.Sleep(iSleepMs);
        iLoop++;
    }
# Docker images 

### ServerGC=false alloc/free .NET CORE 2.0
    docker run -ti -m 100M schaefferlinkbit/dotnet_mem_allocator:1.0.3895_20_client_GC /alloc_mb=20 /free=false
### ServerGC=true alloc/free .NET CORE 2.0
    docker run -ti -m 100M schaefferlinkbit/dotnet_mem_allocator:1.0.3895_20_server_GC /alloc_mb=20
### ServerGC=false alloc/free .NET CORE 2.1
    docker run -ti -m 100M schaefferlinkbit/dotnet_mem_allocator:1.0.3895_21_client_GC /alloc_mb=20 /free=false
### ServerGC=true alloc/free .NET CORE 2.1
    docker run -ti -m 100M schaefferlinkbit/dotnet_mem_allocator:1.0.3895_21_server_GC /alloc_mb=20

# cgroup limits
After reading multiple issues according to .NET Core GC and docker limits we started to dig into the cgroup limits. We compiled https://github.com/dotnet/coreclr/blob/master/src/gc/unix/cgroup.cpp and executed the program inside the docker container. As shown in the following screenshot the the path of the memory.limit_in_bytes file is pointing to the directory of the host machine and the file open operation fails.
![screenshot from 2018-05-18 11-27-29](https://user-images.githubusercontent.com/13675575/40230729-f77807ba-5a98-11e8-9740-7da4217a4777.png)
The next screenshot shows the volume mounts of the container. The host machine path is mounted to /sys/fs/memory inside the container. When reading memory.limit_in_bytes we see ~300MB (we pass -m 300M to the docker container)
![screenshot from 2018-05-18 11-27-40](https://user-images.githubusercontent.com/13675575/40230855-64052d4a-5a99-11e8-854f-c5751ab2f56b.png)

It seems like CLR is not able to read the physical memory limits from cgroup and therefore the GC is not triggered correctly. As a result the process is killed because of OOM. We guess that CLR is triggering GC when it has to do swapping and this is the reason why our process is not killed when swapping is enabled.
</Description>
    <Title_Description>.NET Core application running in docker gets OOMKilled if swapping is disabled We are running .NET Core applications inside docker containers on a kubernetes cluster. Docker containers get OOMKilled because GC is not executed.

To test this we created a test program which allocates arrays in a loop. These arrays should get deleted by the GC. The program is executed in a docker container with 100Mb memory limit. Kubernetes is not involved in the tests.

When running the test with **swap enabled** everything works as expected and the GC gets triggered when the total memory reaches 100Mb. The test never gets killed.

When running the test with **swap disabled** the test gets OOMKilled when the total memory reaches 100Mb. We have tested this behaviour with ServerGC=true|false and with .NET Core 2.0 and 2.1

Enabling swap is not an option cause it's neither recommended nor supported by Kubernetes.

# Code
you can find out test program here: https://github.com/devKlausS/dotnet_mem_allocator
      
    var rand = new Random();
    List&lt;byte[]&gt; m_arrays = new List&lt;byte[]&gt;();
    
    int iLoop = 0;
    while (true)
    {
        var array = new byte[iAllocBytes];
        var value = (byte)rand.Next();
        Parallel.ForEach(array (item) =&gt;
        {
            item = value;
        });
        rand.NextBytes(array);
    
        if(!bFree)
            m_arrays.Add(array);
    
        if(iCollect &gt; 0 &amp;&amp; iLoop % iCollect == 0)
        {
            Console.WriteLine("run GC");
            GC.Collect();
        }
    
        Console.Write("AllocatedBytesForCurrentThread: " + GC.GetAllocatedBytesForCurrentThread() / 1000000 + "Mb " +
            "TotalMemory: " + GC.GetTotalMemory(bForceFullCollection) / 1000000 + "Mb ");
    
        for(int i = 0; i &lt; GC.MaxGeneration; i++)
        {
            Console.Write("CollectionCount("+i+"): " + GC.CollectionCount(i) + " ");
        }
    
        Console.WriteLine("");
    
        Thread.Sleep(iSleepMs);
        iLoop++;
    }
# Docker images 

### ServerGC=false alloc/free .NET CORE 2.0
    docker run -ti -m 100M schaefferlinkbit/dotnet_mem_allocator:1.0.3895_20_client_GC /alloc_mb=20 /free=false
### ServerGC=true alloc/free .NET CORE 2.0
    docker run -ti -m 100M schaefferlinkbit/dotnet_mem_allocator:1.0.3895_20_server_GC /alloc_mb=20
### ServerGC=false alloc/free .NET CORE 2.1
    docker run -ti -m 100M schaefferlinkbit/dotnet_mem_allocator:1.0.3895_21_client_GC /alloc_mb=20 /free=false
### ServerGC=true alloc/free .NET CORE 2.1
    docker run -ti -m 100M schaefferlinkbit/dotnet_mem_allocator:1.0.3895_21_server_GC /alloc_mb=20

# cgroup limits
After reading multiple issues according to .NET Core GC and docker limits we started to dig into the cgroup limits. We compiled https://github.com/dotnet/coreclr/blob/master/src/gc/unix/cgroup.cpp and executed the program inside the docker container. As shown in the following screenshot the the path of the memory.limit_in_bytes file is pointing to the directory of the host machine and the file open operation fails.
![screenshot from 2018-05-18 11-27-29](https://user-images.githubusercontent.com/13675575/40230729-f77807ba-5a98-11e8-9740-7da4217a4777.png)
The next screenshot shows the volume mounts of the container. The host machine path is mounted to /sys/fs/memory inside the container. When reading memory.limit_in_bytes we see ~300MB (we pass -m 300M to the docker container)
![screenshot from 2018-05-18 11-27-40](https://user-images.githubusercontent.com/13675575/40230855-64052d4a-5a99-11e8-854f-c5751ab2f56b.png)

It seems like CLR is not able to read the physical memory limits from cgroup and therefore the GC is not triggered correctly. As a result the process is killed because of OOM. We guess that CLR is triggering GC when it has to do swapping and this is the reason why our process is not killed when swapping is enabled.
</Title_Description>
    <Label>area-GC</Label>
    <Assignee>janvorli</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18043</IssueLabelID>
    <Title>JIT: assert in test with call to Array&lt;T&gt;.IndexOf with Vector type</Title>
    <Description>
</Description>
    <Title_Description>JIT: assert in test with call to Array&lt;T&gt;.IndexOf with Vector type 
</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
    <CreatedAt>18/05/2018 8:40:45 AM +00:00</CreatedAt>
    <ClosedAt>18/05/2018 8:00:30 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18042</IssueLabelID>
    <Title>CoreCLR failed when build with MSVC on Windows</Title>
    <Description>Hello

I tried to build CoreCLR on Windows with VS2017 Update2. It failed to build due to the error CS2001: Source file 'D:\CoreCLR\src\bin\obj\Windows_NT.x86.Release\System.Private.CoreLib\..\eventing\DotNETRuntimeEventSource.cs' could not be found. This issue is caused by master branch revision [0fbd0f5](https://github.com/dotnet/coreclr/commit/0fbd0f535e566bcde591701adc2de51ee0f020af). Could you please help take a look at this? Thank you!

**You can repro this issue as the steps below:**
1. git clone https://github.com/dotnet/coreclr D:\CoreCLR\src
2. Open a clean x86 prompt (C:\windows\syswow64\cmd.exe) and browse to D:\CoreCLR\src
3. build x86 release -Rebuild -- /clp:ShowCommandLine

**Error info:**
CSC : error CS2001: Source file 'D:\CoreCLR\src\bin\obj\Windows_NT.x86.Release\System.Private.CoreLib\..\eventing\DotNETRuntimeEventSource.cs' could not be found. [D:\CoreCLR\src\src\System.Private.CoreLib\System.Private.CoreLib.csproj]</Description>
    <Title_Description>CoreCLR failed when build with MSVC on Windows Hello

I tried to build CoreCLR on Windows with VS2017 Update2. It failed to build due to the error CS2001: Source file 'D:\CoreCLR\src\bin\obj\Windows_NT.x86.Release\System.Private.CoreLib\..\eventing\DotNETRuntimeEventSource.cs' could not be found. This issue is caused by master branch revision [0fbd0f5](https://github.com/dotnet/coreclr/commit/0fbd0f535e566bcde591701adc2de51ee0f020af). Could you please help take a look at this? Thank you!

**You can repro this issue as the steps below:**
1. git clone https://github.com/dotnet/coreclr D:\CoreCLR\src
2. Open a clean x86 prompt (C:\windows\syswow64\cmd.exe) and browse to D:\CoreCLR\src
3. build x86 release -Rebuild -- /clp:ShowCommandLine

**Error info:**
CSC : error CS2001: Source file 'D:\CoreCLR\src\bin\obj\Windows_NT.x86.Release\System.Private.CoreLib\..\eventing\DotNETRuntimeEventSource.cs' could not be found. [D:\CoreCLR\src\src\System.Private.CoreLib\System.Private.CoreLib.csproj]</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>brianrob</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18041</IssueLabelID>
    <Title>JIT: assert when jitting Sse2.ConvertToInt32WithTruncation</Title>
    <Description>
    </Description>
    <Title_Description>JIT: assert when jitting Sse2.ConvertToInt32WithTruncation </Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>4creators</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18040</IssueLabelID>
    <Title>Broken conv.ovf.i8.un decomposition</Title>
    <Description>IL sample:
 hides the issue since is sign extends again the byte previously loaded.

Found while adding tests for #12676. Test coverage for casts seems to be lacking I keep running into bugs (either existing or of my own doing) and existing tests fail to catch them so I generated some. This case failed on ARM32 but not on x86.</Description>
    <Title_Description>Broken conv.ovf.i8.un decomposition IL sample:
 hides the issue since is sign extends again the byte previously loaded.

Found while adding tests for #12676. Test coverage for casts seems to be lacking I keep running into bugs (either existing or of my own doing) and existing tests fail to catch them so I generated some. This case failed on ARM32 but not on x86.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
    <CreatedAt>18/05/2018 6:37:04 AM +00:00</CreatedAt>
    <ClosedAt>7/06/2018 5:19:00 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18039</IssueLabelID>
    <Title>JIT: assert when jitting Sse2.MoveScalar(Vector128&lt;long&gt;)</Title>
    <Description>
</Description>
    <Title_Description>JIT: assert when jitting Sse2.MoveScalar(Vector128&lt;long&gt;) 
</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
    <CreatedAt>18/05/2018 12:39:24 AM +00:00</CreatedAt>
    <ClosedAt>1/06/2018 11:57:00 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18037</IssueLabelID>
    <Title>Extra stloc and ldloc in switch statement compared to if statement</Title>
    <Description>I noticed an extra stloc and ldloc in the following switch statement compared to the equivalent if statement (this is just a shortened version of a longer and nested statement).
The il and disassembly looks pretty much the same except for the 
&lt;/details&gt;
category:cq
theme:basic-cq
skill-level:beginner
cost:small</Description>
    <Title_Description>Extra stloc and ldloc in switch statement compared to if statement I noticed an extra stloc and ldloc in the following switch statement compared to the equivalent if statement (this is just a shortened version of a longer and nested statement).
The il and disassembly looks pretty much the same except for the 
&lt;/details&gt;
category:cq
theme:basic-cq
skill-level:beginner
cost:small</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>17/05/2018 10:12:53 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18034</IssueLabelID>
    <Title>[Arm64] System.Reflection.Emit.Tests.TypeBuilderIsGenericTypeDefinition.IsGenericTypeDefinition_GenericType_ReturnsTrue [FAIL]</Title>
    <Description>This is a recent regression on tip.
         
</Description>
    <Title_Description>[Arm64] System.Reflection.Emit.Tests.TypeBuilderIsGenericTypeDefinition.IsGenericTypeDefinition_GenericType_ReturnsTrue [FAIL] This is a recent regression on tip.
         
</Title_Description>
    <Label>area-System.Reflection</Label>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18033</IssueLabelID>
    <Title>JIT: examine need for canInlineTypeCheckWithObjectVTable</Title>
    <Description>When the jit is optimizing type equality and inequality tests it may run into the following case:
 to identify the cases where the optimization is valid.

https://github.com/dotnet/coreclr/blob/3c01252879f2d2223f63d5b222b6584c28fc07f4/src/jit/gentree.cpp#L13141-L13147

Per Jan's comments in #18005 it seems in CoreCLR this optimization is likely always valid and the check is no longer needed.

category:cq
theme:basic-cq
skill-level:intermediate
cost:small</Description>
    <Title_Description>JIT: examine need for canInlineTypeCheckWithObjectVTable When the jit is optimizing type equality and inequality tests it may run into the following case:
 to identify the cases where the optimization is valid.

https://github.com/dotnet/coreclr/blob/3c01252879f2d2223f63d5b222b6584c28fc07f4/src/jit/gentree.cpp#L13141-L13147

Per Jan's comments in #18005 it seems in CoreCLR this optimization is likely always valid and the check is no longer needed.

category:cq
theme:basic-cq
skill-level:intermediate
cost:small</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
    <CreatedAt>17/05/2018 5:50:45 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18031</IssueLabelID>
    <Title>[JIT/ARM] Fix Compiler::lvaFrameAddress</Title>
    <Description>Use sp-based offset only if r10 reserved or offset is lower than encoding limit.

Fixes https://github.com/dotnet/coreclr/issues/17882</Description>
    <Title_Description>[JIT/ARM] Fix Compiler::lvaFrameAddress Use sp-based offset only if r10 reserved or offset is lower than encoding limit.

Fixes https://github.com/dotnet/coreclr/issues/17882</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>alpencolt</Assignee>
    <CreatedAt>17/05/2018 2:45:38 PM +00:00</CreatedAt>
    <ClosedAt>21/06/2018 3:57:45 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18030</IssueLabelID>
    <Title>Possible Bug: Complete lock-up in ASP.NET Core startup due to StubHelpers?</Title>
    <Description>Hi all

This is potentially a difficult issue to track down. I have been developing with ASP.NET Core for a few months now and (very) rarely the application locks-up completely during start up. I am currently running version 2.1.101 but don't recall which version I was running when I first encountered this issue. The time between manifestations is measured in weeks. I assume this is some kind of unlucky race condition.

I captured this screenshot from the latest occurrence. The lock-up always occurs within WebHostBuilder.Build(). The rest of the stack trace might be variable because this is the first time I've had a proper look at it.

In this instance the code appears to be stuck in StubHelpers.AddToCleanupList (hence why I am posting this here). Resuming the application has no effect. We remain stuck in the same place. I need to restart the application to get past this point. 

![image](https://user-images.githubusercontent.com/16805881/40167385-cecbed26-59b8-11e8-8b6c-e57aef1681ac.png)</Description>
    <Title_Description>Possible Bug: Complete lock-up in ASP.NET Core startup due to StubHelpers? Hi all

This is potentially a difficult issue to track down. I have been developing with ASP.NET Core for a few months now and (very) rarely the application locks-up completely during start up. I am currently running version 2.1.101 but don't recall which version I was running when I first encountered this issue. The time between manifestations is measured in weeks. I assume this is some kind of unlucky race condition.

I captured this screenshot from the latest occurrence. The lock-up always occurs within WebHostBuilder.Build(). The rest of the stack trace might be variable because this is the first time I've had a proper look at it.

In this instance the code appears to be stuck in StubHelpers.AddToCleanupList (hence why I am posting this here). Resuming the application has no effect. We remain stuck in the same place. I need to restart the application to get past this point. 

![image](https://user-images.githubusercontent.com/16805881/40167385-cecbed26-59b8-11e8-8b6c-e57aef1681ac.png)</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>cshung</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18026</IssueLabelID>
    <Title>[Arm64/Linux] Stabilize SDK</Title>
    <Description>#17933 will be fixed by #17991 

Using a variant of the patch in #17991 I was able to bootstrap build a linux-arm64 cli/sdk based on 2.1.300-rtm-008820.  To check stability I tried to use it to build coreclr natively.



</Description>
    <Title_Description>[Arm64/Linux] Stabilize SDK #17933 will be fixed by #17991 

Using a variant of the patch in #17991 I was able to bootstrap build a linux-arm64 cli/sdk based on 2.1.300-rtm-008820.  To check stability I tried to use it to build coreclr natively.



</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>kouvel</Assignee>
    <CreatedAt>16/05/2018 8:50:13 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18025</IssueLabelID>
    <Title>Mirror changes from dotnet/corefx</Title>
    <Description>This PR contains mirrored changes from dotnet/corefx


**Please REBASE this PR when merging**</Description>
    <Title_Description>Mirror changes from dotnet/corefx This PR contains mirrored changes from dotnet/corefx


**Please REBASE this PR when merging**</Title_Description>
    <Label>
    </Label>
    <Assignee>stephentoub</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18024</IssueLabelID>
    <Title>Making IProducerConsumerCollectionDebugView APIs public</Title>
    <Description>Moving ConcurrentQueue to shared

Applying code review feedbacks: 

1- Making IProducerConsumerCollectionDebugView apis public

2- Renaming 
- Segment to ConcurrentQueueSegment. 
- ProducerConsumerCollectionDebugView  to IProducerConsumerCollectionDebugView 

Fixes: #17751

cc: @jkotas @stephentoub @danmosemsft @safern </Description>
    <Title_Description>Making IProducerConsumerCollectionDebugView APIs public Moving ConcurrentQueue to shared

Applying code review feedbacks: 

1- Making IProducerConsumerCollectionDebugView apis public

2- Renaming 
- Segment to ConcurrentQueueSegment. 
- ProducerConsumerCollectionDebugView  to IProducerConsumerCollectionDebugView 

Fixes: #17751

cc: @jkotas @stephentoub @danmosemsft @safern </Title_Description>
    <Label>area-System.Collections</Label>
    <Assignee>maryamariyan</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18022</IssueLabelID>
    <Title>Suboptimal codegen when comparing sbyte and 16-bit values</Title>
    <Description>I have the following two repro methods along with their x64 codegen using the latest RyuJIT.


category:cq
theme:basic-cq
skill-level:intermediate
cost:small
</Description>
    <Title_Description>Suboptimal codegen when comparing sbyte and 16-bit values I have the following two repro methods along with their x64 codegen using the latest RyuJIT.


category:cq
theme:basic-cq
skill-level:intermediate
cost:small
</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>16/05/2018 5:53:08 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18019</IssueLabelID>
    <Title>Proposal - Incorporate deadlock detection into the CLR.</Title>
    <Description>Given that the simply freeze.

The ultimate benefit is not that deadlocks would be eliminated but that they could be detected at the instant they arise and used during testing or when attempting to reproduce a deadlock that has been reported in an app or class library.

Thoughts?</Description>
    <Title_Description>Proposal - Incorporate deadlock detection into the CLR. Given that the simply freeze.

The ultimate benefit is not that deadlocks would be eliminated but that they could be detected at the instant they arise and used during testing or when attempting to reproduce a deadlock that has been reported in an app or class library.

Thoughts?</Title_Description>
    <Label>Design Discussion</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>16/05/2018 3:25:34 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18016</IssueLabelID>
    <Title>Allow partial loop-unrolling for JIT(optUnrollLoops)</Title>
    <Description>https://github.com/dotnet/coreclr/issues/11606

following methods will be fixed.
1. Support non-vector unrolling.
2. Support partial unrolling. and threshold.
3. Support unsafe array access unrolling.</Description>
    <Title_Description>Allow partial loop-unrolling for JIT(optUnrollLoops) https://github.com/dotnet/coreclr/issues/11606

following methods will be fixed.
1. Support non-vector unrolling.
2. Support partial unrolling. and threshold.
3. Support unsafe array access unrolling.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
    <CreatedAt>16/05/2018 3:52:12 AM +00:00</CreatedAt>
    <ClosedAt>25/06/2018 7:22:18 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18014</IssueLabelID>
    <Title>Add mixed-mode Book of the Runtime entry</Title>
    <Description>Adds a Book of the Runtime entry to document how mixed-mode assemblies are specified and work in general. This is not a design for how it will be integrated into .NET Core (that will be done separately). 

Progress toward #18013 </Description>
    <Title_Description>Add mixed-mode Book of the Runtime entry Adds a Book of the Runtime entry to document how mixed-mode assemblies are specified and work in general. This is not a design for how it will be integrated into .NET Core (that will be done separately). 

Progress toward #18013 </Title_Description>
    <Label>documentation</Label>
    <Assignee>morganbr</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18013</IssueLabelID>
    <Title>Support mixed-mode assemblies on Windows</Title>
    <Description>This issue will track progress toward supporting loading and running mixed-mode assemblies on CoreCLR. The main goal is to provide support for WPF and other existing C++/CLI code on .NET Core. Some of the work will be dependent on updates to the MSVC compiler.

Steps include:
- [x] Documenting how mixed-mode assemblies work in general
- [x] Proposing a .NET Core design
- [x] Loading mixed-mode assemblies into running managed code
- [x] Starting the runtime from native code in mixed-mode assemblies

This is related to #659 but cross-platform support is outside of the scope of this issue as it's a compiler feature not a runtime feature.</Description>
    <Title_Description>Support mixed-mode assemblies on Windows This issue will track progress toward supporting loading and running mixed-mode assemblies on CoreCLR. The main goal is to provide support for WPF and other existing C++/CLI code on .NET Core. Some of the work will be dependent on updates to the MSVC compiler.

Steps include:
- [x] Documenting how mixed-mode assemblies work in general
- [x] Proposing a .NET Core design
- [x] Loading mixed-mode assemblies into running managed code
- [x] Starting the runtime from native code in mixed-mode assemblies

This is related to #659 but cross-platform support is outside of the scope of this issue as it's a compiler feature not a runtime feature.</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jkoritzinsky</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18005</IssueLabelID>
    <Title>ReadOnlySpan.CopyTo is surprisingly (relatively) expensive and doesn't inline</Title>
    <Description>Its mostly a wrapper on BufferMemmove with some checks
</Description>
    <Title_Description>ReadOnlySpan.CopyTo is surprisingly (relatively) expensive and doesn't inline Its mostly a wrapper on BufferMemmove with some checks
</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>15/05/2018 5:55:50 PM +00:00</CreatedAt>
    <ClosedAt>30/05/2018 6:03:05 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18004</IssueLabelID>
    <Title>Publish master branch symbols to symweb and MSDL endpoints</Title>
    <Description>Right now the official builds of .

Docs on how to do this correctly aren't currently available tracked by https://github.com/dotnet/core-eng/issues/3382.</Description>
    <Title_Description>Publish master branch symbols to symweb and MSDL endpoints Right now the official builds of .

Docs on how to do this correctly aren't currently available tracked by https://github.com/dotnet/core-eng/issues/3382.</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>dagood</Assignee>
    <CreatedAt>15/05/2018 5:50:16 PM +00:00</CreatedAt>
    <ClosedAt>15/05/2018 6:07:46 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18003</IssueLabelID>
    <Title>format spmi sources</Title>
    <Description>
    </Description>
    <Title_Description>format spmi sources </Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>15/05/2018 5:22:02 PM +00:00</CreatedAt>
    <ClosedAt>15/05/2018 6:17:48 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18002</IssueLabelID>
    <Title>ignore .tail opcode on arm64</Title>
    <Description>when Jit can't do a fast tail call.

Fixes #18001.</Description>
    <Title_Description>ignore .tail opcode on arm64 when Jit can't do a fast tail call.

Fixes #18001.</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>15/05/2018 5:10:48 PM +00:00</CreatedAt>
    <ClosedAt>16/05/2018 2:02:01 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18001</IssueLabelID>
    <Title>[Arm64] Tailcall regression</Title>
    <Description>Tailcode opcode should be treated as a hint to the JIT.  When it is not supported it should not assert.

The following tests have recently regressed 


This was probably introduced as a diagnostic by @sandreenko as mentioned in here 
https://github.com/dotnet/coreclr/issues/6675#issuecomment-388917599

@janvorli @dotnet/arm64-contrib </Description>
    <Title_Description>[Arm64] Tailcall regression Tailcode opcode should be treated as a hint to the JIT.  When it is not supported it should not assert.

The following tests have recently regressed 


This was probably introduced as a diagnostic by @sandreenko as mentioned in here 
https://github.com/dotnet/coreclr/issues/6675#issuecomment-388917599

@janvorli @dotnet/arm64-contrib </Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>sandreenko</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17997</IssueLabelID>
    <Title>Tolerate spmi misses</Title>
    <Description>before:
 failure notifications.

PTAL @BruceForstall 
cc @dotnet/jit-contrib </Description>
    <Title_Description>Tolerate spmi misses before:
 failure notifications.

PTAL @BruceForstall 
cc @dotnet/jit-contrib </Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>15/05/2018 6:41:23 AM +00:00</CreatedAt>
    <ClosedAt>15/05/2018 11:29:27 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17992</IssueLabelID>
    <Title>[Linux/arm] baseservices/compilerservices/FixedAddressValueType failure</Title>
    <Description>
    </Description>
    <Title_Description>[Linux/arm] baseservices/compilerservices/FixedAddressValueType failure </Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>BruceForstall</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17986</IssueLabelID>
    <Title>Reflection.Emit: Assertion failure in SignatureHelper.AddOneArgTypeHelper. Missing argument validation in public API?</Title>
    <Description>I've come across a failing  should actively check for empty arrays and correct them.</Description>
    <Title_Description>Reflection.Emit: Assertion failure in SignatureHelper.AddOneArgTypeHelper. Missing argument validation in public API? I've come across a failing  should actively check for empty arrays and correct them.</Title_Description>
    <Label>area-System.Reflection</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>14/05/2018 7:54:44 AM +00:00</CreatedAt>
    <ClosedAt>15/05/2018 10:39:03 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17984</IssueLabelID>
    <Title>Odd side-effect check code generation with fixed keyword</Title>
    <Description>There is something wired side-effect check code generation on fixed pointers.
I don't know its because Roslyn generates wrong MSIL. but first. I am writing here.

Example here.

category:cq
theme:basic-cq
skill-level:intermediate
cost:small</Description>
    <Title_Description>Odd side-effect check code generation with fixed keyword There is something wired side-effect check code generation on fixed pointers.
I don't know its because Roslyn generates wrong MSIL. but first. I am writing here.

Example here.

category:cq
theme:basic-cq
skill-level:intermediate
cost:small</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>mikedn</Assignee>
    <CreatedAt>14/05/2018 4:11:30 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17980</IssueLabelID>
    <Title>What's data stored in method handle?</Title>
    <Description>

I know the lower bits is the order number of a method but I don't know which position is the first bit.

What's the meaning of all the bits?</Description>
    <Title_Description>What's data stored in method handle? 

I know the lower bits is the order number of a method but I don't know which position is the first bit.

What's the meaning of all the bits?</Title_Description>
    <Label>question</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>13/05/2018 10:12:52 AM +00:00</CreatedAt>
    <ClosedAt>13/05/2018 7:56:01 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17977</IssueLabelID>
    <Title>Reflection: Allow ParameterBuilder.SetConstant(nonNullValue) for nullable enum parameters</Title>
    <Description>This is a fix for #17893.

* Makes it possible to call 

/cc @AtsushiKan</Description>
    <Title_Description>Reflection: Allow ParameterBuilder.SetConstant(nonNullValue) for nullable enum parameters This is a fix for #17893.

* Makes it possible to call 

/cc @AtsushiKan</Title_Description>
    <Label>netfx-port-consider</Label>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17969</IssueLabelID>
    <Title>Don't eliminate a cpblk when offsets are different</Title>
    <Description>When the JIT encounters a cpblk between two different offsets of the same local if both fields are not recognizable to the JIT (i.e. the ) it will incorrectly optimize away the cpblk.</Description>
    <Title_Description>Don't eliminate a cpblk when offsets are different When the JIT encounters a cpblk between two different offsets of the same local if both fields are not recognizable to the JIT (i.e. the ) it will incorrectly optimize away the cpblk.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17968</IssueLabelID>
    <Title>[arm64/RyuJit] assert(!"Shouldn't see an integer typed GT_MOD node in ARM64");</Title>
    <Description>It was found in our internal test runs I have added an IL test for this issue: tests/src/JIT/Regression/JitBlue/DevDiv_590772/DevDiv_590772.il  (#17759)
To repro crossgen this test with altjit_arm64 or on arm64 itself.
Once it fixed delete change tests/arm64/Tests.lst to enable the test.</Description>
    <Title_Description>[arm64/RyuJit] assert(!"Shouldn't see an integer typed GT_MOD node in ARM64"); It was found in our internal test runs I have added an IL test for this issue: tests/src/JIT/Regression/JitBlue/DevDiv_590772/DevDiv_590772.il  (#17759)
To repro crossgen this test with altjit_arm64 or on arm64 itself.
Once it fixed delete change tests/arm64/Tests.lst to enable the test.</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>sandreenko</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17967</IssueLabelID>
    <Title>[arm64/RyuJit] assert(!"We should never encounter a reference to a lclVar that has a zero refCnt.");</Title>
    <Description>It was found in our internal test runs I have added an IL test for this issue: tests/src/JIT/Regression/JitBlue/DevDiv_590771/DevDiv_590771.il  (#17759)

To repro crossgen this test with altjit_arm64 or on arm64 itself.

Once it fixed delete change  to enable the test.</Description>
    <Title_Description>[arm64/RyuJit] assert(!"We should never encounter a reference to a lclVar that has a zero refCnt."); It was found in our internal test runs I have added an IL test for this issue: tests/src/JIT/Regression/JitBlue/DevDiv_590771/DevDiv_590771.il  (#17759)

To repro crossgen this test with altjit_arm64 or on arm64 itself.

Once it fixed delete change  to enable the test.</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>AndyAyersMS</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17966</IssueLabelID>
    <Title>[arm64/RyuJit] NYI("Initialize floating-point register to zero");</Title>
    <Description>It was found in our internal test runs I have added an IL test for this issue: tests/src/JIT/Regression/JitBlue/DevDiv_605447/DevDiv_605447.il (#17759)

To repro crossgen this test with altjit_arm64 or on arm64 itself.

Once it fixed delete change  to enable the test.</Description>
    <Title_Description>[arm64/RyuJit] NYI("Initialize floating-point register to zero"); It was found in our internal test runs I have added an IL test for this issue: tests/src/JIT/Regression/JitBlue/DevDiv_605447/DevDiv_605447.il (#17759)

To repro crossgen this test with altjit_arm64 or on arm64 itself.

Once it fixed delete change  to enable the test.</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>sdmaclea</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17963</IssueLabelID>
    <Title>Jit can generate pointless movs</Title>
    <Description>e.g.

category:cq
theme:basic-cq
skill-level:intermediate
cost:medium</Description>
    <Title_Description>Jit can generate pointless movs e.g.

category:cq
theme:basic-cq
skill-level:intermediate
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>11/05/2018 3:53:33 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17962</IssueLabelID>
    <Title>Mirror changes from dotnet/corefx</Title>
    <Description>This PR contains mirrored changes from dotnet/corefx


**Please REBASE this PR when merging**</Description>
    <Title_Description>Mirror changes from dotnet/corefx This PR contains mirrored changes from dotnet/corefx


**Please REBASE this PR when merging**</Title_Description>
    <Label>
    </Label>
    <Assignee>stephentoub</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17960</IssueLabelID>
    <Title>Add explicit null check for VSD via tail call stub.</Title>
    <Description>Always add explicit null check before calling tail call stub that calls VSD.

Fixes #17585.

For arm64 it hits #6675.</Description>
    <Title_Description>Add explicit null check for VSD via tail call stub. Always add explicit null check before calling tail call stub that calls VSD.

Fixes #17585.

For arm64 it hits #6675.</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>11/05/2018 12:57:15 AM +00:00</CreatedAt>
    <ClosedAt>13/05/2018 4:58:33 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17959</IssueLabelID>
    <Title>LoopCloneContext::EvaluateConditions need to evaluate for const init limit condition. </Title>
    <Description>current EvaluateConditions should evaluate const-init const-limit for not cloning very natural loops
this is **actually** statically known as true. (always taken)

this makes loop to clone(evaluate as not statically known as true or false) which causes not to unroll general natural loops (flagged as   which that doesn't really need to be cloned.

category:cq
theme:loop-opt
skill-level:expert
cost:medium</Description>
    <Title_Description>LoopCloneContext::EvaluateConditions need to evaluate for const init, limit condition.  current EvaluateConditions should evaluate const-init const-limit for not cloning very natural loops
this is **actually** statically known as true. (always taken)

this makes loop to clone(evaluate as not statically known as true or false) which causes not to unroll general natural loops (flagged as   which that doesn't really need to be cloned.

category:cq
theme:loop-opt
skill-level:expert
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
    <CreatedAt>11/05/2018 12:31:09 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17958</IssueLabelID>
    <Title>[Arm64] System.Linq.Expressions.Tests.ArrayBoundsTests.SingleNegativeBoundErrorMessage regression</Title>
    <Description>This test case was passing near 2.1 fork.


@dotnet/arm64-contrib @VSadov @OmarTawfik  FYI</Description>
    <Title_Description>[Arm64] System.Linq.Expressions.Tests.ArrayBoundsTests.SingleNegativeBoundErrorMessage regression This test case was passing near 2.1 fork.


@dotnet/arm64-contrib @VSadov @OmarTawfik  FYI</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>VSadov</Assignee>
    <CreatedAt>10/05/2018 10:27:19 PM +00:00</CreatedAt>
    <ClosedAt>20/09/2019 6:43:20 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17956</IssueLabelID>
    <Title>Moving ConcurrentQueue to shared folder</Title>
    <Description>corefx PR: dotnet/corefx#29643

Fixes coreclr issue: #17751 

Related to this [comment](https://github.com/dotnet/coreclr/pull/17800#issuecomment-385092192) made by @stephentoub:
&gt; That just leaves ConcurrentQueue which is used by ThreadPool. I agree that one is reasonable to move down.

cc: @stephentoub @jkotas @safern @danmosemsft </Description>
    <Title_Description>Moving ConcurrentQueue to shared folder corefx PR: dotnet/corefx#29643

Fixes coreclr issue: #17751 

Related to this [comment](https://github.com/dotnet/coreclr/pull/17800#issuecomment-385092192) made by @stephentoub:
&gt; That just leaves ConcurrentQueue which is used by ThreadPool. I agree that one is reasonable to move down.

cc: @stephentoub @jkotas @safern @danmosemsft </Title_Description>
    <Label>area-System.Collections</Label>
    <Assignee>maryamariyan</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17950</IssueLabelID>
    <Title>Build error: PE file is already strong-name signed</Title>
    <Description>Hello.

Next errors happen during build of current master:


Do you know what could be the reason of this?

cc @alpencolt @Dmitri-Botcharnikov </Description>
    <Title_Description>Build error: PE file is already strong-name signed Hello.

Next errors happen during build of current master:


Do you know what could be the reason of this?

cc @alpencolt @Dmitri-Botcharnikov </Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>alpencolt</Assignee>
    <CreatedAt>10/05/2018 6:16:36 PM +00:00</CreatedAt>
    <ClosedAt>10/05/2018 10:46:44 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17949</IssueLabelID>
    <Title>JIT: track more information about variable definitions in the importer</Title>
    <Description>In many cases the use of a variable has a single reaching definition. We should consider tracking this information in the importer and using it to drive early optimizations.

The idea for now is to look at only the simplest cases ones where a variable has:
* a single definition and all uses are clearly dominated by the definition
  * arguments that are not exposed or redefined
  * a subset of the temps introduced by the jit like the  temps for ref types. But likely the full expression would be cheap enough to track.

The tracking mechanism needs to be robust in the presence of reimportation and should have some kind of post-importer sanity check.

It would also be good if this information remained viable through the early phases of the jit -- for instance it could be used and maintained during inlining.

category:cq
theme:basic-cq
skill-level:expert
cost:medium</Description>
    <Title_Description>JIT: track more information about variable definitions in the importer In many cases the use of a variable has a single reaching definition. We should consider tracking this information in the importer and using it to drive early optimizations.

The idea for now is to look at only the simplest cases ones where a variable has:
* a single definition and all uses are clearly dominated by the definition
  * arguments that are not exposed or redefined
  * a subset of the temps introduced by the jit like the  temps for ref types. But likely the full expression would be cheap enough to track.

The tracking mechanism needs to be robust in the presence of reimportation and should have some kind of post-importer sanity check.

It would also be good if this information remained viable through the early phases of the jit -- for instance it could be used and maintained during inlining.

category:cq
theme:basic-cq
skill-level:expert
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
    <CreatedAt>10/05/2018 4:00:58 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17947</IssueLabelID>
    <Title>Add reporting exception from ResolveEHClause</Title>
    <Description>When an exception like EEFileLoadException happens in the
ResolveEHClause it was not caught by the runtime and so it caused exit
with 
message without any additional details.

This change adds catching the exception reporting its details and call
stack and then failing fast.

Close #16438</Description>
    <Title_Description>Add reporting exception from ResolveEHClause When an exception like EEFileLoadException happens in the
ResolveEHClause it was not caught by the runtime and so it caused exit
with 
message without any additional details.

This change adds catching the exception reporting its details and call
stack and then failing fast.

Close #16438</Title_Description>
    <Label>area-VM</Label>
    <Assignee>janvorli</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17946</IssueLabelID>
    <Title>ResourceReader Cannot Read Resource File</Title>
    <Description>We are in the process of migrating an application from the .NET Framework to .NET Core 2 but it looks like the ResourceReader cannot process a valid resx file.

When I create the ResourceReader I get 




Here is a [gist](https://gist.github.com/zeus82/e45838a029f58784ebe2e118b11f21cf) to the contents of the resx file.</Description>
    <Title_Description>ResourceReader Cannot Read Resource File We are in the process of migrating an application from the .NET Framework to .NET Core 2 but it looks like the ResourceReader cannot process a valid resx file.

When I create the ResourceReader I get 




Here is a [gist](https://gist.github.com/zeus82/e45838a029f58784ebe2e118b11f21cf) to the contents of the resx file.</Title_Description>
    <Label>question</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>10/05/2018 12:38:32 PM +00:00</CreatedAt>
    <ClosedAt>10/05/2018 6:47:59 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17944</IssueLabelID>
    <Title>CoreCLR failures when build permissive- + msvc on windows</Title>
    <Description>Hi
We found 3 failures when build CoreCLR with permissive- by msvc on windows could you help take a look?

You can repro this issue as the steps below:
1.	git clone https://github.com/dotnet/coreclr D:\CoreCLR\src
2.	Open VS2017 x86 command prompt and browse to D:\CoreCLR\src
3.	Set  _CL_=/wd5043 /permissive-
4.	build x86 release -Rebuild -- /clp:ShowCommandLine
5.	build-test.cmd x86 release -- /clp:ShowCommandLine

See the issue as following:
Issue #1: 
d:\coreclr\src\src\classlibnative\bcltype\grisu3.h(36): error C4596: 'BiggestPowerTenLessThanOrEqualTo': illegal qualified name in member declaration
Probably fix:
Change
   static void Grisu3::BiggestPowerTenLessThanOrEqualTo(UINT32 number int bits UINT32 *power int *exponent);
To
static void BiggestPowerTenLessThanOrEqualTo(UINT32 number int bits UINT32 *power int *exponent);

Issue #2
d:\coreclr\src\src\vm\dllimport.cpp(6098): error C2664: 'BOOL SString::Find(SString::CIterator &amp;WCHAR) const': cannot convert argument 1 from 'SString::CIterator' to 'SString::CIterator &amp;' [D:\CoreCLR\src\bin\obj\Windows_NT.x86.Release\src\vm\wks\cee_wks.vcxproj]
  d:\coreclr\src\src\vm\dllimport.cpp(6098): note: A non-const reference may only be bound to an lvalue
Probably fix:
Needs to change from:
if (!libNameIsRelativePath ||
!libName.Find(libName.Begin() W('.')) ||

To:
auto it = libName.Begin();
if (!libNameIsRelativePath ||
!libName.Find(it W('.')) ||

Issue #3 
d:\coreclr\src\src\inc\winrt\paraminstanceapi.h(422): error C3861: '_size': identifier not found (compiling source file D:\CoreCLR\src\src\vm\interoputil.cpp
Probably fix:
Change
for (size_t i = 0; i != _size; ++i) 
To
for (size_t i = 0; i != size; ++i)
</Description>
    <Title_Description>CoreCLR failures when build permissive- + msvc on windows Hi
We found 3 failures when build CoreCLR with permissive- by msvc on windows could you help take a look?

You can repro this issue as the steps below:
1.	git clone https://github.com/dotnet/coreclr D:\CoreCLR\src
2.	Open VS2017 x86 command prompt and browse to D:\CoreCLR\src
3.	Set  _CL_=/wd5043 /permissive-
4.	build x86 release -Rebuild -- /clp:ShowCommandLine
5.	build-test.cmd x86 release -- /clp:ShowCommandLine

See the issue as following:
Issue #1: 
d:\coreclr\src\src\classlibnative\bcltype\grisu3.h(36): error C4596: 'BiggestPowerTenLessThanOrEqualTo': illegal qualified name in member declaration
Probably fix:
Change
   static void Grisu3::BiggestPowerTenLessThanOrEqualTo(UINT32 number int bits UINT32 *power int *exponent);
To
static void BiggestPowerTenLessThanOrEqualTo(UINT32 number int bits UINT32 *power int *exponent);

Issue #2
d:\coreclr\src\src\vm\dllimport.cpp(6098): error C2664: 'BOOL SString::Find(SString::CIterator &amp;WCHAR) const': cannot convert argument 1 from 'SString::CIterator' to 'SString::CIterator &amp;' [D:\CoreCLR\src\bin\obj\Windows_NT.x86.Release\src\vm\wks\cee_wks.vcxproj]
  d:\coreclr\src\src\vm\dllimport.cpp(6098): note: A non-const reference may only be bound to an lvalue
Probably fix:
Needs to change from:
if (!libNameIsRelativePath ||
!libName.Find(libName.Begin() W('.')) ||

To:
auto it = libName.Begin();
if (!libNameIsRelativePath ||
!libName.Find(it W('.')) ||

Issue #3 
d:\coreclr\src\src\inc\winrt\paraminstanceapi.h(422): error C3861: '_size': identifier not found (compiling source file D:\CoreCLR\src\src\vm\interoputil.cpp
Probably fix:
Change
for (size_t i = 0; i != _size; ++i) 
To
for (size_t i = 0; i != size; ++i)
</Title_Description>
    <Label>Hackathon</Label>
    <Assignee>kant2002</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17943</IssueLabelID>
    <Title>Reliability - Watson crash in AssemblySpec::Bind  </Title>
    <Description>We have a failure during EEStartup tracked by this internal Watson bucket:
https://watson/Failure?FailureSearchText=4a3aff04-3ef6-bbbe-2ae8-2cffa0b278c3

This accounts for 91.6% of reported external failures in coreclr.dll:

    0 coreclr!AssemblySpec::Bind  0x0000000000000183    coreassemblyspec.cpp 
    1 coreclr!AppDomain::BindAssemblySpec  0x0000000000000126    appdomain.cpp 
    2 coreclr!PEFile::LoadAssembly  0x000000000000010C    pefile.cpp 
    3 coreclr!Module::LoadAssembly  0x00000000000000F6    ceeload.cpp 
    4 coreclr!Assembly::FindModuleByTypeRef  0x00000000000001F9    assembly.cpp 
    5 coreclr!ClassLoader::LoadTypeDefOrRefThrowing  0x00000000000002AE    clsload.cpp 
    6 coreclr!SigPointer::GetTypeHandleThrowing  0x000000000000021F    siginfo.cpp 
    7 coreclr!MemberLoader::GetDescFromMemberRef  0x000000000000039B    memberload.cpp 
    8 coreclr!CEEInfo::resolveToken  0x00000000000005A6    jitinterface.cpp 
    9 clrjit!Compiler::impImportBlockCode  0x0000000000000927    importer.cpp 
    10 clrjit!Compiler::impImportBlock  0x0000000000000093    importer.cpp 
    11 clrjit!Compiler::impImport  0x00000000000002DB    importer.cpp 
    12 clrjit!Compiler::compCompile  0x00000000000000A4    compiler.cpp 
    13 clrjit!Compiler::compCompileHelper  0x0000000000000299    compiler.cpp 
    14 clrjit!Compiler::compCompile  0x000000000000025D    compiler.cpp 
    15 clrjit!jitNativeCode  0x000000000000026E    compiler.cpp 
    16 clrjit!CILJit::compileMethod  0x00000000000000A2    ee_il_dll.cpp 
    17 coreclr!invokeCompileMethod  0x00000000000000E5    jitinterface.cpp 
    18 coreclr!CallCompileMethodWithSEHWrapper  0x0000000000000052    jitinterface.cpp 
    19 coreclr!UnsafeJitFunction  0x00000000000004F5    jitinterface.cpp 
    20 coreclr!MethodDesc::JitCompileCodeLocked  0x00000000000001FE    prestub.cpp 
    21 coreclr!MethodDesc::JitCompileCodeLockedEventWrapper  0x00000000001313C1    prestub.cpp 
    22 coreclr!MethodDesc::JitCompileCode  0x0000000000000399    prestub.cpp 
    23 coreclr!MethodDesc::DoPrestub  0x000000000000059E    prestub.cpp 
    24 coreclr!PreStubWorker  0x000000000000037A    prestub.cpp 
    25 coreclr!ThePreStub  0x0000000000000055    ThePreStubAMD64.asm 
    26 coreclr!CallDescrWorkerInternal  0x0000000000000083    CallDescrWorkerAMD64.asm 
    27 coreclr!MethodDescCallSite::CallTargetWorker  0x00000000000002B5    callhelpers.cpp 
    28 coreclr!AppDomain::InitializeDomainContext  0x0000000000000105    appdomain.cpp 
    29 coreclr!SystemDomain::InitializeDefaultDomain  0x000000000000004E    appdomain.cpp 
    30 coreclr!SystemDomain::SetupDefaultDomain  0x0000000000000199    appdomain.cpp 
    31 coreclr!SystemDomain::SetupDefaultDomainNoThrow  0x000000000000004D    appdomain.cpp 
    32 coreclr!EEStartup  0x000000000000006E    ceemain.cpp 
</Description>
    <Title_Description>Reliability - Watson crash in AssemblySpec::Bind   We have a failure during EEStartup tracked by this internal Watson bucket:
https://watson/Failure?FailureSearchText=4a3aff04-3ef6-bbbe-2ae8-2cffa0b278c3

This accounts for 91.6% of reported external failures in coreclr.dll:

    0 coreclr!AssemblySpec::Bind  0x0000000000000183    coreassemblyspec.cpp 
    1 coreclr!AppDomain::BindAssemblySpec  0x0000000000000126    appdomain.cpp 
    2 coreclr!PEFile::LoadAssembly  0x000000000000010C    pefile.cpp 
    3 coreclr!Module::LoadAssembly  0x00000000000000F6    ceeload.cpp 
    4 coreclr!Assembly::FindModuleByTypeRef  0x00000000000001F9    assembly.cpp 
    5 coreclr!ClassLoader::LoadTypeDefOrRefThrowing  0x00000000000002AE    clsload.cpp 
    6 coreclr!SigPointer::GetTypeHandleThrowing  0x000000000000021F    siginfo.cpp 
    7 coreclr!MemberLoader::GetDescFromMemberRef  0x000000000000039B    memberload.cpp 
    8 coreclr!CEEInfo::resolveToken  0x00000000000005A6    jitinterface.cpp 
    9 clrjit!Compiler::impImportBlockCode  0x0000000000000927    importer.cpp 
    10 clrjit!Compiler::impImportBlock  0x0000000000000093    importer.cpp 
    11 clrjit!Compiler::impImport  0x00000000000002DB    importer.cpp 
    12 clrjit!Compiler::compCompile  0x00000000000000A4    compiler.cpp 
    13 clrjit!Compiler::compCompileHelper  0x0000000000000299    compiler.cpp 
    14 clrjit!Compiler::compCompile  0x000000000000025D    compiler.cpp 
    15 clrjit!jitNativeCode  0x000000000000026E    compiler.cpp 
    16 clrjit!CILJit::compileMethod  0x00000000000000A2    ee_il_dll.cpp 
    17 coreclr!invokeCompileMethod  0x00000000000000E5    jitinterface.cpp 
    18 coreclr!CallCompileMethodWithSEHWrapper  0x0000000000000052    jitinterface.cpp 
    19 coreclr!UnsafeJitFunction  0x00000000000004F5    jitinterface.cpp 
    20 coreclr!MethodDesc::JitCompileCodeLocked  0x00000000000001FE    prestub.cpp 
    21 coreclr!MethodDesc::JitCompileCodeLockedEventWrapper  0x00000000001313C1    prestub.cpp 
    22 coreclr!MethodDesc::JitCompileCode  0x0000000000000399    prestub.cpp 
    23 coreclr!MethodDesc::DoPrestub  0x000000000000059E    prestub.cpp 
    24 coreclr!PreStubWorker  0x000000000000037A    prestub.cpp 
    25 coreclr!ThePreStub  0x0000000000000055    ThePreStubAMD64.asm 
    26 coreclr!CallDescrWorkerInternal  0x0000000000000083    CallDescrWorkerAMD64.asm 
    27 coreclr!MethodDescCallSite::CallTargetWorker  0x00000000000002B5    callhelpers.cpp 
    28 coreclr!AppDomain::InitializeDomainContext  0x0000000000000105    appdomain.cpp 
    29 coreclr!SystemDomain::InitializeDefaultDomain  0x000000000000004E    appdomain.cpp 
    30 coreclr!SystemDomain::SetupDefaultDomain  0x0000000000000199    appdomain.cpp 
    31 coreclr!SystemDomain::SetupDefaultDomainNoThrow  0x000000000000004D    appdomain.cpp 
    32 coreclr!EEStartup  0x000000000000006E    ceemain.cpp 
</Title_Description>
    <Label>area-AssemblyLoader</Label>
    <Assignee>jeffschwMSFT</Assignee>
    <CreatedAt>10/05/2018 1:50:51 AM +00:00</CreatedAt>
    <ClosedAt>13/06/2018 4:35:17 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17936</IssueLabelID>
    <Title>Fix alternate stack for Alpine docker on SELinux</Title>
    <Description>For some reason the Alpine docker container running on a SELinux host maps
heap as RWX. When we allocate alternate stack from the heap we also
change the protection of the first page to PROT_NONE so that it can
serve as a guard page to catch stack overflow. And when we free the
alternate stack we restore the protection back to PROT_READ |
PROT_WRITE. The restoration fails in Alpine docker container running on
a SELinux host with EPROT failure and the SELinux log reports that an
attempt to change heap to executable was made. So it looks like the
kernel has added the PERM_EXEC to the permissions we have passed to the
mprotect call. There is a code in the mprotect implementation that can
do that although I don't fully understand the exact conditions under which it
happens yet. This is driven by the VM_MAYEXEC flag in the internal VMA block
structure. 
To fix that I've modified the alternate stack allocation to use mmap /
munmap instead of C heap allocation.

Close #17931</Description>
    <Title_Description>Fix alternate stack for Alpine docker on SELinux For some reason the Alpine docker container running on a SELinux host maps
heap as RWX. When we allocate alternate stack from the heap we also
change the protection of the first page to PROT_NONE so that it can
serve as a guard page to catch stack overflow. And when we free the
alternate stack we restore the protection back to PROT_READ |
PROT_WRITE. The restoration fails in Alpine docker container running on
a SELinux host with EPROT failure and the SELinux log reports that an
attempt to change heap to executable was made. So it looks like the
kernel has added the PERM_EXEC to the permissions we have passed to the
mprotect call. There is a code in the mprotect implementation that can
do that although I don't fully understand the exact conditions under which it
happens yet. This is driven by the VM_MAYEXEC flag in the internal VMA block
structure. 
To fix that I've modified the alternate stack allocation to use mmap /
munmap instead of C heap allocation.

Close #17931</Title_Description>
    <Label>area-PAL</Label>
    <Assignee>janvorli</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17935</IssueLabelID>
    <Title>JIT: have inlining heuristics look for cases where inlining might enable devirtualization</Title>
    <Description>When a caller argument is an exact type and feeds a virtual or interface call in the callee we might want to inline more aggressively.

A toy example of this can be found in [this BenchmarkDotNet sample](https://github.com/dotnet/BenchmarkDotNet/blob/master/samples/BenchmarkDotNet.Samples/JIT/Jit_InterfaceMethod.cs). Here 

Likely we would not give a ~3.65x boost to inlining benefit based on one argument reaching one call site. But if we also realized the call site was in a loop perhaps the net effect would be enough to justify an inline.

Currently we don't know when observing arg uses whether that use is in a loop or not. But if we were to associate uses with callee IL offsets we could circle back after finding all the branch targets and develop a crude estimator for loop depth then sum up the weighted observations.

It would also be nice to tabulate a few more opportunities of this kind. The basic observational part change is simple enough to prototype that perhaps just building it is one way to make forward progress.

category:cq
theme:inlining
skill-level:intermediate
cost:medium</Description>
    <Title_Description>JIT: have inlining heuristics look for cases where inlining might enable devirtualization When a caller argument is an exact type and feeds a virtual or interface call in the callee we might want to inline more aggressively.

A toy example of this can be found in [this BenchmarkDotNet sample](https://github.com/dotnet/BenchmarkDotNet/blob/master/samples/BenchmarkDotNet.Samples/JIT/Jit_InterfaceMethod.cs). Here 

Likely we would not give a ~3.65x boost to inlining benefit based on one argument reaching one call site. But if we also realized the call site was in a loop perhaps the net effect would be enough to justify an inline.

Currently we don't know when observing arg uses whether that use is in a loop or not. But if we were to associate uses with callee IL offsets we could circle back after finding all the branch targets and develop a crude estimator for loop depth then sum up the weighted observations.

It would also be nice to tabulate a few more opportunities of this kind. The basic observational part change is simple enough to prototype that perhaps just building it is one way to make forward progress.

category:cq
theme:inlining
skill-level:intermediate
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
    <CreatedAt>9/05/2018 10:06:21 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17934</IssueLabelID>
    <Title>[arm/arm64] fix semicolon and priorities for new excluded tests</Title>
    <Description>Small fix for #17855.</Description>
    <Title_Description>[arm/arm64] fix semicolon and priorities for new excluded tests Small fix for #17855.</Title_Description>
    <Label>test enhancement</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>9/05/2018 9:48:36 PM +00:00</CreatedAt>
    <ClosedAt>10/05/2018 12:14:25 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17933</IssueLabelID>
    <Title>[Arm64/Linux] SDK fails to build hello world</Title>
    <Description>@richlander @dotnet/arm64-contrib @Petermarcu 

As noted in various places the 2.1 arm64-linux SDK is failing during the build of Hello World with either an assertion or a segmentation fault</Description>
    <Title_Description>[Arm64/Linux] SDK fails to build hello world @richlander @dotnet/arm64-contrib @Petermarcu 

As noted in various places the 2.1 arm64-linux SDK is failing during the build of Hello World with either an assertion or a segmentation fault</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>richlander</Assignee>
    <CreatedAt>9/05/2018 5:20:33 PM +00:00</CreatedAt>
    <ClosedAt>18/05/2018 6:11:51 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17932</IssueLabelID>
    <Title>Possible Performance Regression from 2.0.7 to 2.1-RC1 on Windows Server 2016 w/ Hyper-V Role</Title>
    <Description>@Mike-EEE commented on [Wed May 09 2018](https://github.com/dotnet/core/issues/1524)

Hello .NET Core Team and Community

I have a very interesting performance issue for you here.  I have produced some code that demonstrates a regressing difference in performance when switching from the .NET Core 2.0.x runtime to 2.1-RC1 on my Windows Server 2016 machine that I am using as a Hyper-V server.  Please note that I am also using Visual Studio 2017 15.7.1 in producing my output here.

To start this issue has context that is most recently rooted in a Benchmark.NET issue that you [can view here](https://github.com/dotnet/BenchmarkDotNet/issues/739).  I have created a series of five benchmarks using the exact same underlying test code.  Each have a slight modification that produce different results in 2.0.7 when run on my Windows Server host machine (note: the host machine and not a VM instance).  You can see an [overview of this information here](https://github.com/dotnet/BenchmarkDotNet/issues/739#issuecomment-386811232).

I took the code that is in the 3rd example and by simply rebuilding it and running it in the 2.1 runtime it produced slower results.  I have [created this 2.1 branch here](https://github.com/Mike-EEE/BenchmarkDotNet.InProcess/tree/TheWeird_03a) for your convenience.

(Please do note that the results of each scenario are found in the README.md of their respective branches.)

Additionally with a small change I was once again able to produce the faster result times as seen in 2.0.7 but within the 2.1 runtime.  I have published this [branch here](https://github.com/Mike-EEE/BenchmarkDotNet.InProcess/tree/TheWeird_03b).  This is consistent with the bizarre behavior referenced in the five earlier examples but seen here in a different form (or configuration for lack of a better term) in 2.1.

I feel it's worthy to note that I believe that this is a gremlin of a problem that I have been chasing in .NET Core tooling since 1.1.  I have encountered the most weird of circumstances around this behavior while trying to benchmark code using Benchmark.NET.  You can see previous iterations of my previous more complicated attempts at wrestling this beast here for your reference:
https://github.com/dotnet/BenchmarkDotNet/issues/330
https://github.com/dotnet/BenchmarkDotNet/issues/433

Now that I have been able to show a (regressing) discrepancy in performance between 2.0.7 and 2.1 RC1 with a simple recompile I believe this could be due to a tooling/SDK problem that has been around for some time now.  Fortunately I have been able to capture it using a very simple project this time and am more than happy to share it now in hopes to finally tracking down this very weird issue. 😄 

Finally I will provide an overview of my Windows Server specifications here.



Please let me know if you require any further information around this issue or my environment and I will be happy to get it for you.

Thank you for any assistance you can provide towards solving this issue!

</Description>
    <Title_Description>Possible Performance Regression from 2.0.7 to 2.1-RC1 on Windows Server 2016 w/ Hyper-V Role @Mike-EEE commented on [Wed May 09 2018](https://github.com/dotnet/core/issues/1524)

Hello .NET Core Team and Community

I have a very interesting performance issue for you here.  I have produced some code that demonstrates a regressing difference in performance when switching from the .NET Core 2.0.x runtime to 2.1-RC1 on my Windows Server 2016 machine that I am using as a Hyper-V server.  Please note that I am also using Visual Studio 2017 15.7.1 in producing my output here.

To start this issue has context that is most recently rooted in a Benchmark.NET issue that you [can view here](https://github.com/dotnet/BenchmarkDotNet/issues/739).  I have created a series of five benchmarks using the exact same underlying test code.  Each have a slight modification that produce different results in 2.0.7 when run on my Windows Server host machine (note: the host machine and not a VM instance).  You can see an [overview of this information here](https://github.com/dotnet/BenchmarkDotNet/issues/739#issuecomment-386811232).

I took the code that is in the 3rd example and by simply rebuilding it and running it in the 2.1 runtime it produced slower results.  I have [created this 2.1 branch here](https://github.com/Mike-EEE/BenchmarkDotNet.InProcess/tree/TheWeird_03a) for your convenience.

(Please do note that the results of each scenario are found in the README.md of their respective branches.)

Additionally with a small change I was once again able to produce the faster result times as seen in 2.0.7 but within the 2.1 runtime.  I have published this [branch here](https://github.com/Mike-EEE/BenchmarkDotNet.InProcess/tree/TheWeird_03b).  This is consistent with the bizarre behavior referenced in the five earlier examples but seen here in a different form (or configuration for lack of a better term) in 2.1.

I feel it's worthy to note that I believe that this is a gremlin of a problem that I have been chasing in .NET Core tooling since 1.1.  I have encountered the most weird of circumstances around this behavior while trying to benchmark code using Benchmark.NET.  You can see previous iterations of my previous more complicated attempts at wrestling this beast here for your reference:
https://github.com/dotnet/BenchmarkDotNet/issues/330
https://github.com/dotnet/BenchmarkDotNet/issues/433

Now that I have been able to show a (regressing) discrepancy in performance between 2.0.7 and 2.1 RC1 with a simple recompile I believe this could be due to a tooling/SDK problem that has been around for some time now.  Fortunately I have been able to capture it using a very simple project this time and am more than happy to share it now in hopes to finally tracking down this very weird issue. 😄 

Finally I will provide an overview of my Windows Server specifications here.



Please let me know if you require any further information around this issue or my environment and I will be happy to get it for you.

Thank you for any assistance you can provide towards solving this issue!

</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>Petermarcu</Assignee>
    <CreatedAt>9/05/2018 3:26:12 PM +00:00</CreatedAt>
    <ClosedAt>22/10/2018 8:52:00 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17931</IssueLabelID>
    <Title>Using Alpine docker image from system w/ SELinux execheap enforcement triggers segfault</Title>
    <Description>@petejohanson commented on [Sun May 06 2018](https://github.com/dotnet/core/issues/1503)

# Alpine docker image segfault when run from a host system w/ SELinux execheap enforcement

From my Fedora laptop attempting to use the  so that should just work.

---

@janvorli commented on [Wed May 09 2018](https://github.com/dotnet/core/issues/1503#issuecomment-387766924)

So my assumption is that kernel adds PROT_EXEC as a result of VM_MAYEXEC being set for mprotect in the memory allocated from the heap. I've noticed that when running in the alpine docker container on the SELinux enabled Fedora 28 the heap has all three RWX flags set. 

I've tried to fix it by allocating the alternate stack using mmap instead of getting it from the heap and it worked fine. I am going to create a PR for this fix.


---

@Petermarcu commented on [Wed May 09 2018](https://github.com/dotnet/core/issues/1503#issuecomment-387770480)

Is this Alpine specific or SE Linux? Is this a regression from 2.0?

</Description>
    <Title_Description>Using Alpine docker image from system w/ SELinux execheap enforcement triggers segfault @petejohanson commented on [Sun May 06 2018](https://github.com/dotnet/core/issues/1503)

# Alpine docker image segfault when run from a host system w/ SELinux execheap enforcement

From my Fedora laptop attempting to use the  so that should just work.

---

@janvorli commented on [Wed May 09 2018](https://github.com/dotnet/core/issues/1503#issuecomment-387766924)

So my assumption is that kernel adds PROT_EXEC as a result of VM_MAYEXEC being set for mprotect in the memory allocated from the heap. I've noticed that when running in the alpine docker container on the SELinux enabled Fedora 28 the heap has all three RWX flags set. 

I've tried to fix it by allocating the alternate stack using mmap instead of getting it from the heap and it worked fine. I am going to create a PR for this fix.


---

@Petermarcu commented on [Wed May 09 2018](https://github.com/dotnet/core/issues/1503#issuecomment-387770480)

Is this Alpine specific or SE Linux? Is this a regression from 2.0?

</Title_Description>
    <Label>area-PAL</Label>
    <Assignee>janvorli</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17929</IssueLabelID>
    <Title>Unexpected coredumps</Title>
    <Description>I notice my system was creating coredumps for .NET Core processes.

Repro:

I didn't expect this program to generate a coredump.</Description>
    <Title_Description>Unexpected coredumps I notice my system was creating coredumps for .NET Core processes.

Repro:

I didn't expect this program to generate a coredump.</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>mikedn</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17926</IssueLabelID>
    <Title>Rename mscorlib to System.Private.Corelib</Title>
    <Description>cc: @jkotas @safern @danmosemsft 

Fixes: #17905</Description>
    <Title_Description>Rename mscorlib to System.Private.Corelib cc: @jkotas @safern @danmosemsft 

Fixes: #17905</Title_Description>
    <Label>area-Meta-corelib</Label>
    <Assignee>maryamariyan</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17924</IssueLabelID>
    <Title>Following build/test instructions doesn't build any tests</Title>
    <Description>I'm trying to build coreclr release/2.1 on Amazon Linux 2017.03 and can't get the tests to build.  (I have the same issue on Ubuntu)
Here are the instructions I'm following:
https://github.com/dotnet/coreclr/blob/release/2.1/Documentation/building/linux-instructions.md
https://github.com/dotnet/coreclr/blob/release/2.1/Documentation/building/unix-test-instructions.md

Here's my script:

Then when I run my runtest.sh command from above the test is run.

How do I get the tests to build?

</Description>
    <Title_Description>Following build/test instructions doesn't build any tests I'm trying to build coreclr release/2.1 on Amazon Linux 2017.03 and can't get the tests to build.  (I have the same issue on Ubuntu)
Here are the instructions I'm following:
https://github.com/dotnet/coreclr/blob/release/2.1/Documentation/building/linux-instructions.md
https://github.com/dotnet/coreclr/blob/release/2.1/Documentation/building/unix-test-instructions.md

Here's my script:

Then when I run my runtest.sh command from above the test is run.

How do I get the tests to build?

</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>jashook</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17922</IssueLabelID>
    <Title>Mirror changes from dotnet/corert</Title>
    <Description>This PR contains mirrored changes from dotnet/corert


**Please REBASE this PR when merging**</Description>
    <Title_Description>Mirror changes from dotnet/corert This PR contains mirrored changes from dotnet/corert


**Please REBASE this PR when merging**</Title_Description>
    <Label>
    </Label>
    <Assignee>jkotas</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17917</IssueLabelID>
    <Title>Reflection: Fix FormatException when querying ParameterInfo.DefaultValue of optional (closed generic) enum parameter</Title>
    <Description>This is similar to #17877 but about enums instead of  constant in metadata which isn't usually the case for enums.)

/cc @AtsushiKan</Description>
    <Title_Description>Reflection: Fix FormatException when querying ParameterInfo.DefaultValue of optional (closed generic) enum parameter This is similar to #17877 but about enums instead of  constant in metadata which isn't usually the case for enums.)

/cc @AtsushiKan</Title_Description>
    <Label>netfx-port-consider</Label>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17915</IssueLabelID>
    <Title>[WIP] Fix failing System.Reflection.Emit tests</Title>
    <Description>Commit fceac03e82 removed a test from .</Description>
    <Title_Description>[WIP] Fix failing System.Reflection.Emit tests Commit fceac03e82 removed a test from .</Title_Description>
    <Label>netfx-port-consider</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>8/05/2018 11:28:35 AM +00:00</CreatedAt>
    <ClosedAt>8/05/2018 2:39:18 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17909</IssueLabelID>
    <Title>Remove ConcurrentStack from System.Private.CoreLib </Title>
    <Description>This issue is opened to track removing ConcurrentStack from System.Private.CoreLib 

Referring to [comment](https://github.com/dotnet/coreclr/pull/17800#issuecomment-385092192) _From @stephentoub on Apr 27 2018 1:57 PM PDT_:

&gt; ConcurrentStack is to my knowledge used in only one place in corelib by PinnableBufferCache which is in turn only used by Overlapped as a way to cache OverlappedData instances and I think we could come up with something better than ConcurrentStack for this use case in particular since every Push ends up allocating a Node in ConcurrentStack.

Related to issue: https://github.com/dotnet/coreclr/issues/17751

cc: @stephentoub @danmosemsft @jkotas </Description>
    <Title_Description>Remove ConcurrentStack from System.Private.CoreLib  This issue is opened to track removing ConcurrentStack from System.Private.CoreLib 

Referring to [comment](https://github.com/dotnet/coreclr/pull/17800#issuecomment-385092192) _From @stephentoub on Apr 27 2018 1:57 PM PDT_:

&gt; ConcurrentStack is to my knowledge used in only one place in corelib by PinnableBufferCache which is in turn only used by Overlapped as a way to cache OverlappedData instances and I think we could come up with something better than ConcurrentStack for this use case in particular since every Push ends up allocating a Node in ConcurrentStack.

Related to issue: https://github.com/dotnet/coreclr/issues/17751

cc: @stephentoub @danmosemsft @jkotas </Title_Description>
    <Label>area-System.Collections</Label>
    <Assignee>stephentoub</Assignee>
    <CreatedAt>7/05/2018 5:04:42 PM +00:00</CreatedAt>
    <ClosedAt>9/06/2018 8:40:00 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17842</IssueLabelID>
    <Title>Add better portable PDB caching to System.Diagnostics.StackTrace</Title>
    <Description>Issue #17701

Add portable PDB caching to StackTrace.

This is the mscorlib/System.Private.Corelib side of the change.</Description>
    <Title_Description>Add better portable PDB caching to System.Diagnostics.StackTrace Issue #17701

Add portable PDB caching to StackTrace.

This is the mscorlib/System.Private.Corelib side of the change.</Title_Description>
    <Label>
    </Label>
    <Assignee>mikem8361</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17841</IssueLabelID>
    <Title>[Arm64] GitHub_17777  - Assertion failed 'emitCurIG != emitPrologIG' in </Title>
    <Description>JIT/Regression/JitBlue/GitHub_17777/GitHub_17777/GitHub_17777.sh

</Description>
    <Title_Description>[Arm64] GitHub_17777  - Assertion failed 'emitCurIG != emitPrologIG' in  JIT/Regression/JitBlue/GitHub_17777/GitHub_17777/GitHub_17777.sh

</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>briansull</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17840</IssueLabelID>
    <Title>[master] Add runtimeconfig.json support for tiered compilation</Title>
    <Description>cc @kouvel @4creators </Description>
    <Title_Description>[master] Add runtimeconfig.json support for tiered compilation cc @kouvel @4creators </Title_Description>
    <Label>area-TieredCompilation</Label>
    <Assignee>kouvel</Assignee>
    <CreatedAt>30/04/2018 9:00:41 PM +00:00</CreatedAt>
    <ClosedAt>30/04/2018 10:51:04 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17839</IssueLabelID>
    <Title>Add runtimeconfig.json support for tiered compilation</Title>
    <Description>
    </Description>
    <Title_Description>Add runtimeconfig.json support for tiered compilation </Title_Description>
    <Label>area-TieredCompilation</Label>
    <Assignee>noahfalk</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17838</IssueLabelID>
    <Title>JIT: volatile compares should not be foldable</Title>
    <Description>
Folding the compare is unsafe in general.

See also the somewhat related #6172.

category:correctness
theme:basic-cq
skill-level:intermediate
cost:small</Description>
    <Title_Description>JIT: volatile compares should not be foldable 
Folding the compare is unsafe in general.

See also the somewhat related #6172.

category:correctness
theme:basic-cq
skill-level:intermediate
cost:small</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
    <CreatedAt>30/04/2018 8:29:36 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17837</IssueLabelID>
    <Title>GC env vars</Title>
    <Description>Remove CORECLR_SERVER_GC and CORECLR_CONCURRENT_GC and make COMPlus_gcServer and COMPlus_gcConcurrent available on Windows.</Description>
    <Title_Description>GC env vars Remove CORECLR_SERVER_GC and CORECLR_CONCURRENT_GC and make COMPlus_gcServer and COMPlus_gcConcurrent available on Windows.</Title_Description>
    <Label>
    </Label>
    <Assignee>sywhang</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17835</IssueLabelID>
    <Title>[arm/corefx] System.Tests.TypedReferenceTests.NegativeMakeTypedReference fails</Title>
    <Description>[ci run](https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_corefx_baseline_tst/13/consoleText) shows:


link  https://github.com/dotnet/coreclr/issues/16001#issuecomment-385319873.

Probably it will fix #17585.</Description>
    <Title_Description>[arm/corefx] System.Tests.TypedReferenceTests.NegativeMakeTypedReference fails [ci run](https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_corefx_baseline_tst/13/consoleText) shows:


link  https://github.com/dotnet/coreclr/issues/16001#issuecomment-385319873.

Probably it will fix #17585.</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>sandreenko</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17833</IssueLabelID>
    <Title>PropertyInfo.SetValue on ref-returning members</Title>
    <Description>https://github.com/dotnet/corefx/issues/15960

This invokes the getter and writes the argument
value into the reference. InvalidOpException
if the property is readonly ref.</Description>
    <Title_Description>PropertyInfo.SetValue on ref-returning members https://github.com/dotnet/corefx/issues/15960

This invokes the getter and writes the argument
value into the reference. InvalidOpException
if the property is readonly ref.</Title_Description>
    <Label>area-System.Reflection</Label>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17831</IssueLabelID>
    <Title>Mirror changes from dotnet/corefx</Title>
    <Description>This PR contains mirrored changes from dotnet/corefx


**Please REBASE this PR when merging**</Description>
    <Title_Description>Mirror changes from dotnet/corefx This PR contains mirrored changes from dotnet/corefx


**Please REBASE this PR when merging**</Title_Description>
    <Label>
    </Label>
    <Assignee>jkotas</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17828</IssueLabelID>
    <Title>[JIT]: Stack allocation to Span</Title>
    <Description>I looked at what IL and x86 code is generated for different ways of allocating memory on stack
and think there is room for optimizations. 

1. Roslyn could generate better IL for 
&lt;/p&gt;
&lt;/details&gt;



</Description>
    <Title_Description>[JIT]: Stack allocation to Span I looked at what IL and x86 code is generated for different ways of allocating memory on stack
and think there is room for optimizations. 

1. Roslyn could generate better IL for 
&lt;/p&gt;
&lt;/details&gt;



</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>VSadov</Assignee>
    <CreatedAt>28/04/2018 2:10:13 PM +00:00</CreatedAt>
    <ClosedAt>6/05/2018 6:27:50 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17827</IssueLabelID>
    <Title>Should FEATURE_APPX be enabled in coreclr builds?</Title>
    <Description>
/cc @jkotas @danmosemsft </Description>
    <Title_Description>Should FEATURE_APPX be enabled in coreclr builds? 
/cc @jkotas @danmosemsft </Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>28/04/2018 12:57:27 PM +00:00</CreatedAt>
    <ClosedAt>28/04/2018 1:44:54 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17825</IssueLabelID>
    <Title>SEHException occurs VS 2017 Remote Debugging on Windows  to debug Linux ASP.NET Core application</Title>
    <Description>Application Environment: Oracle Linux 7.4 (RedHat 7.4)
Debugging Environment: Visual Studio Enterprise 2017 v15.6.6 on Windows
.NET Core SDK Version on both Windows and Linux: 2.1.101

VS is able to attach the Linux ASP .NET Core process in the debugger.  However when trying to step over or continue the execution SEHException occurs.  Here is the exception information:
 - Data: System.Collections.ListDictionaryInternal
 - ErrorCode/HResult: -2147467259
 - Message: "External component has thrown an exception."

We have Microsoft sessions on site to talk about VS remote debugging for ASP.NET Core on Linux  and have documentation to describe how to do that.  However the documentation is based on ubuntu Linux.    We follow similar steps in Oracle Linux v7.4 and encountered SEHException.  We also tried Console Application and also encountered exception.

We need to know if VS Remote debugging on Window can debug .NET Core process in  Oracle Linux v7.1 or above.    
</Description>
    <Title_Description>SEHException occurs VS 2017 Remote Debugging on Windows  to debug Linux ASP.NET Core application Application Environment: Oracle Linux 7.4 (RedHat 7.4)
Debugging Environment: Visual Studio Enterprise 2017 v15.6.6 on Windows
.NET Core SDK Version on both Windows and Linux: 2.1.101

VS is able to attach the Linux ASP .NET Core process in the debugger.  However when trying to step over or continue the execution SEHException occurs.  Here is the exception information:
 - Data: System.Collections.ListDictionaryInternal
 - ErrorCode/HResult: -2147467259
 - Message: "External component has thrown an exception."

We have Microsoft sessions on site to talk about VS remote debugging for ASP.NET Core on Linux  and have documentation to describe how to do that.  However the documentation is based on ubuntu Linux.    We follow similar steps in Oracle Linux v7.4 and encountered SEHException.  We also tried Console Application and also encountered exception.

We need to know if VS Remote debugging on Window can debug .NET Core process in  Oracle Linux v7.1 or above.    
</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>28/04/2018 1:18:41 AM +00:00</CreatedAt>
    <ClosedAt>1/05/2018 7:13:01 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17824</IssueLabelID>
    <Title>Concurrent GC enabled with multiple env vars</Title>
    <Description>Concurrent GC can be enabled by setting environment variable COMPlus_gcConcurrent=1

There is another variable that sets this: CORECLR_CONCURRENT_GC.

We should only have one variable that sets concurrent GC instead of having multiple of them.

Similar issue to https://github.com/dotnet/coreclr/issues/17760</Description>
    <Title_Description>Concurrent GC enabled with multiple env vars Concurrent GC can be enabled by setting environment variable COMPlus_gcConcurrent=1

There is another variable that sets this: CORECLR_CONCURRENT_GC.

We should only have one variable that sets concurrent GC instead of having multiple of them.

Similar issue to https://github.com/dotnet/coreclr/issues/17760</Title_Description>
    <Label>area-GC</Label>
    <Assignee>sywhang</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17823</IssueLabelID>
    <Title>Ensure that any byrefs created in genCodeForIndexAddr cannot point outside of the array</Title>
    <Description>For Arm/arm64 in  we need to insure that we don't create a byref that might point outside of the array object.

</Description>
    <Title_Description>Ensure that any byrefs created in genCodeForIndexAddr cannot point outside of the array For Arm/arm64 in  we need to insure that we don't create a byref that might point outside of the array object.

</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>briansull</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17822</IssueLabelID>
    <Title>Main thread is not CoInitializeEx'ed to MTA by default</Title>
    <Description>When the attribute is not present. Forked from https://github.com/dotnet/coreclr/issues/17787. Fixes for both issues would be breaking changes and should be fixed for the next major version release (3.0).

https://github.com/dotnet/coreclr/blob/53450d7cd4f3d73aa976d2d6be96a3bfe6c028c9/src/vm/assembly.cpp#L1804 and  at this point).

[Milestone = 3.0]</Description>
    <Title_Description>Main thread is not CoInitializeEx'ed to MTA by default When the attribute is not present. Forked from https://github.com/dotnet/coreclr/issues/17787. Fixes for both issues would be breaking changes and should be fixed for the next major version release (3.0).

https://github.com/dotnet/coreclr/blob/53450d7cd4f3d73aa976d2d6be96a3bfe6c028c9/src/vm/assembly.cpp#L1804 and  at this point).

[Milestone = 3.0]</Title_Description>
    <Label>area-System.Threading</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17821</IssueLabelID>
    <Title>Adding back test for windows event log</Title>
    <Description>This test was added with https://github.com/dotnet/coreclr/pull/17401 but had to be removed in https://github.com/dotnet/coreclr/pull/17482 because the tests were failing. Fixed it by allowing more leeway in checking for timestamps in the event log entries and moving the test dependency into Common directory instead of the test itself.</Description>
    <Title_Description>Adding back test for windows event log This test was added with https://github.com/dotnet/coreclr/pull/17401 but had to be removed in https://github.com/dotnet/coreclr/pull/17482 because the tests were failing. Fixed it by allowing more leeway in checking for timestamps in the event log entries and moving the test dependency into Common directory instead of the test itself.</Title_Description>
    <Label>
    </Label>
    <Assignee>sywhang</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17818</IssueLabelID>
    <Title>Post-2.1 plan of Intel hardware intrinsic</Title>
    <Description>1. Refine the API design of Intel hardware intrinsic
    - related issues/PRs: https://github.com/dotnet/coreclr/pull/17637 https://github.com/dotnet/corefx/issues/29247
2. Implement remaining AVX2 intrinsic [rely on (1)]
    - related issues/PRs: https://github.com/dotnet/coreclr/issues/16653
3. Implement remaining SSE4.2 intrinsic [rely on (1)]
    - related issues/PRs: https://github.com/dotnet/coreclr/issues/16270
4. Enable containment analysis on more hardware intrinsic forms (e.g. imm 1-arg 3-arg etc.)
5. Implement FMA intrinsic [rely on (4)]
    - FMA intrinsic codegen is different from other ISAs whose instruction selection depends on the operator's position (e.g. in registers or memory?)
6. Implement other ISA classes ()
    - fully support all the Intel hardware intrinsic of existing APIs 
7. Create non-trivial benchmarks for Intel hardware intrinsic
    - related issues/PRs: https://github.com/dotnet/coreclr/issues/17798
8. Improve the CQ of Intel hardware intrinsic base-on key scenarios [partially rely on (7)]
    - especially when intrinsics are used in combination or with things like Vectors and identify areas that need work.
    - related issues/PRs: https://github.com/dotnet/coreclr/issues/17073 https://github.com/dotnet/coreclr/issues/17108
9. Investigate the JIT throughput impact from hardware intrinsic recognition [rely on (7)]
    - related discussion: https://github.com/dotnet/coreclr/pull/14020#issuecomment-331611668
10. Identify candidates that can be optimized using HW intrinsics and implement them using intrinsics (CoreFX mscorlib HPC ML etc.)
    - related issues/PRs: https://github.com/dotnet/coreclr/issues/15506 https://github.com/dotnet/corefx/issues/25386
11. more...

category:cq
theme:intrinsics
skill-level:intermediate
cost:extra-large</Description>
    <Title_Description>Post-2.1 plan of Intel hardware intrinsic 1. Refine the API design of Intel hardware intrinsic
    - related issues/PRs: https://github.com/dotnet/coreclr/pull/17637 https://github.com/dotnet/corefx/issues/29247
2. Implement remaining AVX2 intrinsic [rely on (1)]
    - related issues/PRs: https://github.com/dotnet/coreclr/issues/16653
3. Implement remaining SSE4.2 intrinsic [rely on (1)]
    - related issues/PRs: https://github.com/dotnet/coreclr/issues/16270
4. Enable containment analysis on more hardware intrinsic forms (e.g. imm 1-arg 3-arg etc.)
5. Implement FMA intrinsic [rely on (4)]
    - FMA intrinsic codegen is different from other ISAs whose instruction selection depends on the operator's position (e.g. in registers or memory?)
6. Implement other ISA classes ()
    - fully support all the Intel hardware intrinsic of existing APIs 
7. Create non-trivial benchmarks for Intel hardware intrinsic
    - related issues/PRs: https://github.com/dotnet/coreclr/issues/17798
8. Improve the CQ of Intel hardware intrinsic base-on key scenarios [partially rely on (7)]
    - especially when intrinsics are used in combination or with things like Vectors and identify areas that need work.
    - related issues/PRs: https://github.com/dotnet/coreclr/issues/17073 https://github.com/dotnet/coreclr/issues/17108
9. Investigate the JIT throughput impact from hardware intrinsic recognition [rely on (7)]
    - related discussion: https://github.com/dotnet/coreclr/pull/14020#issuecomment-331611668
10. Identify candidates that can be optimized using HW intrinsics and implement them using intrinsics (CoreFX mscorlib HPC ML etc.)
    - related issues/PRs: https://github.com/dotnet/coreclr/issues/15506 https://github.com/dotnet/corefx/issues/25386
11. more...

category:cq
theme:intrinsics
skill-level:intermediate
cost:extra-large</Title_Description>
    <Label>Design Discussion</Label>
    <Assignee>CarolEidt</Assignee>
    <CreatedAt>27/04/2018 6:10:53 PM +00:00</CreatedAt>
    <ClosedAt>11/01/2019 10:24:57 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17816</IssueLabelID>
    <Title>ResourceManager doesn't take the SatelliteContractVersion attribute into account</Title>
    <Description>I have a third-party .NET Standard 2.0 class library built with MSBuild via VisualStudio. The library has the SatelliteContractVersion attribute. The corresponding satellite assembly with localization resources has an assembly version that differs from the main library's assembly version.
The main assembly is loaded successfully by the .NET Framework 4.6.1 and .NET Core framework. But the satellite assembly is loaded only if an application that uses the library is built with .NET Framework 4.6.1. 
 
The issue occurs in .NET Core because the ResourceManager.GetSatelliteContractVersion() method always returns the 'null' value. So the ResourceManager in .NET Core ignores the version of the satellite assembly which is specified in the SatelliteContractVersion attribute of the main assembly. Instead the ResourceManager tries to load the satellite assembly with the version specified in the AssemblyVersion attribute of the main assembly.

For example the following attributes are applied to the assembly:
- [assembly: AssemblyVersion("1.2.3.4")]
- [assembly: SatelliteContractVersion("1.2.0.0")]

After building using MSBuild the following assemblies are created:
- a main assembly "A.dll" with version 1.2.3.4;
- a satellite assembly "A.resources.dll" with version 1.2.0.0.

.NET Core framework loads assembly "A.dll" with version 1.2.3.4 and tries to load the "A.resource.dll" assembly with version 1.2.3.4.

.NET Framework 4.6.1 loads assembly "A.dll" with version 1.2.3.4 and tries to load the "A.resouces.dll" assembly with version 1.2.0.0.

The issue leads to different behavior if the existing libraries with the SatelliteContractVersionAttribute are built by MSBuild in .NET Framework applications and .NET Core applications.</Description>
    <Title_Description>ResourceManager doesn't take the SatelliteContractVersion attribute into account I have a third-party .NET Standard 2.0 class library built with MSBuild via VisualStudio. The library has the SatelliteContractVersion attribute. The corresponding satellite assembly with localization resources has an assembly version that differs from the main library's assembly version.
The main assembly is loaded successfully by the .NET Framework 4.6.1 and .NET Core framework. But the satellite assembly is loaded only if an application that uses the library is built with .NET Framework 4.6.1. 
 
The issue occurs in .NET Core because the ResourceManager.GetSatelliteContractVersion() method always returns the 'null' value. So the ResourceManager in .NET Core ignores the version of the satellite assembly which is specified in the SatelliteContractVersion attribute of the main assembly. Instead the ResourceManager tries to load the satellite assembly with the version specified in the AssemblyVersion attribute of the main assembly.

For example the following attributes are applied to the assembly:
- [assembly: AssemblyVersion("1.2.3.4")]
- [assembly: SatelliteContractVersion("1.2.0.0")]

After building using MSBuild the following assemblies are created:
- a main assembly "A.dll" with version 1.2.3.4;
- a satellite assembly "A.resources.dll" with version 1.2.0.0.

.NET Core framework loads assembly "A.dll" with version 1.2.3.4 and tries to load the "A.resource.dll" assembly with version 1.2.3.4.

.NET Framework 4.6.1 loads assembly "A.dll" with version 1.2.3.4 and tries to load the "A.resouces.dll" assembly with version 1.2.0.0.

The issue leads to different behavior if the existing libraries with the SatelliteContractVersionAttribute are built by MSBuild in .NET Framework applications and .NET Core applications.</Title_Description>
    <Label>area-AssemblyLoader</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>27/04/2018 3:38:01 PM +00:00</CreatedAt>
    <ClosedAt>16/03/2019 4:30:59 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17815</IssueLabelID>
    <Title>HW intrinsics shouldn't assert for unsupported</Title>
    <Description>For example here:
https://github.com/dotnet/coreclr/blob/master/src/jit/hwintrinsicxarch.cpp#L816
As described in the comments for https://github.com/dotnet/coreclr/pull/17737 this can lead to an assert in the case where the user knows the path will not be taken. Such cases should simply return  so that the IL method will be invoked.

category:correctness
theme:intrinsics
skill-level:beginner
cost:small</Description>
    <Title_Description>HW intrinsics shouldn't assert for unsupported For example here:
https://github.com/dotnet/coreclr/blob/master/src/jit/hwintrinsicxarch.cpp#L816
As described in the comments for https://github.com/dotnet/coreclr/pull/17737 this can lead to an assert in the case where the user knows the path will not be taken. Such cases should simply return  so that the IL method will be invoked.

category:correctness
theme:intrinsics
skill-level:beginner
cost:small</Title_Description>
    <Label>arch-x64</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17812</IssueLabelID>
    <Title>Whether to support.Net native and how to use it</Title>
    <Description>Whether to support.Net native and how to use the .net native，
thank you</Description>
    <Title_Description>Whether to support.Net native and how to use it Whether to support.Net native and how to use the .net native，
thank you</Title_Description>
    <Label>question</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>27/04/2018 12:10:48 PM +00:00</CreatedAt>
    <ClosedAt>27/04/2018 12:37:37 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17810</IssueLabelID>
    <Title>Test failure: Interop_StructPacking._StructPacking_StructPacking_/_StructPacking_StructPacking_cmd</Title>
    <Description>Opened on behalf of @Sunny-pu

The test 
        
Build : Master - 20180427.01 (Core Tests)
Failing configurations:
- redhat.69.amd64-x64
  - 

Details:
https://mc.dot.net/#/product/netcore/master/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fcli~2F/build/20180427.01/workItem/Interop.StructPacking.XUnitWrapper/analysis/xunit/Interop_StructPacking._StructPacking_StructPacking_~2F_StructPacking_StructPacking_cmd</Description>
    <Title_Description>Test failure: Interop_StructPacking._StructPacking_StructPacking_/_StructPacking_StructPacking_cmd Opened on behalf of @Sunny-pu

The test 
        
Build : Master - 20180427.01 (Core Tests)
Failing configurations:
- redhat.69.amd64-x64
  - 

Details:
https://mc.dot.net/#/product/netcore/master/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fcli~2F/build/20180427.01/workItem/Interop.StructPacking.XUnitWrapper/analysis/xunit/Interop_StructPacking._StructPacking_StructPacking_~2F_StructPacking_StructPacking_cmd</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>27/04/2018 8:49:40 AM +00:00</CreatedAt>
    <ClosedAt>22/05/2019 6:09:35 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17809</IssueLabelID>
    <Title>Request safe non-allocation bit converter between value type and byte array</Title>
    <Description>I always face some needs like write some value type to a chunk of memory (and read back) byte by byte.
But there is no way to write a struct or struct array to an existing byte array for now except the unsafe pointer way.

Add APIs like below will be a big help:

public static void Write&lt; T &gt;(Span&lt; T &gt; elem Span&lt; byte &gt;)where T:struct
public static void Read&lt; T &gt;(Span&lt; T &gt; elem Span&lt; byte &gt;)where T:struct</Description>
    <Title_Description>Request safe non-allocation bit converter between value type and byte array I always face some needs like write some value type to a chunk of memory (and read back) byte by byte.
But there is no way to write a struct or struct array to an existing byte array for now except the unsafe pointer way.

Add APIs like below will be a big help:

public static void Write&lt; T &gt;(Span&lt; T &gt; elem Span&lt; byte &gt;)where T:struct
public static void Read&lt; T &gt;(Span&lt; T &gt; elem Span&lt; byte &gt;)where T:struct</Title_Description>
    <Label>area-System.Memory</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>27/04/2018 7:02:27 AM +00:00</CreatedAt>
    <ClosedAt>27/04/2018 12:44:32 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17807</IssueLabelID>
    <Title>Add runtimeconfig.json support for tiered compilation</Title>
    <Description>Previously this feature could only be enabled via COMPLUS_TieredCompilation variable. Now it can also be enabled from configProperties in the runtimeconfig.json.</Description>
    <Title_Description>Add runtimeconfig.json support for tiered compilation Previously this feature could only be enabled via COMPLUS_TieredCompilation variable. Now it can also be enabled from configProperties in the runtimeconfig.json.</Title_Description>
    <Label>area-TieredCompilation</Label>
    <Assignee>dotnet-bot</Assignee>
    <CreatedAt>27/04/2018 4:36:24 AM +00:00</CreatedAt>
    <ClosedAt>30/04/2018 8:40:48 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17805</IssueLabelID>
    <Title>Floating point formatting changed 2.0 -&gt; 2.1</Title>
    <Description>Repro:



.NET Core 2.0: -122.194458007813
.NET Core 2.1: -122.194458007812

Reported by @mjsabby @ Bing</Description>
    <Title_Description>Floating point formatting changed 2.0 -&gt; 2.1 Repro:



.NET Core 2.0: -122.194458007813
.NET Core 2.1: -122.194458007812

Reported by @mjsabby @ Bing</Title_Description>
    <Label>area-System.Runtime</Label>
    <Assignee>mjsabby</Assignee>
    <CreatedAt>27/04/2018 1:42:51 AM +00:00</CreatedAt>
    <ClosedAt>27/04/2018 5:24:01 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17804</IssueLabelID>
    <Title>Add better portable PDB caching to System.Diagnostics.StackTrace.</Title>
    <Description>This is the mscorlib/System.Private.CoreLib side of the change.</Description>
    <Title_Description>Add better portable PDB caching to System.Diagnostics.StackTrace. This is the mscorlib/System.Private.CoreLib side of the change.</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>mikem8361</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17801</IssueLabelID>
    <Title>[arm32] corefx System.Security.Cryptography.X509Certificates.Tests failures</Title>
    <Description>Windows/arm32 corefx System.Security.Cryptography.X509Certificates.Tests failure with COMPlus_JitStressRegs=0x1000 or COMPlus_JitStressRegs=3 or COMPlus_JitMinOpts=1

https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_corefx_jitstressregs0x1000_tst/12/consoleText
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_corefx_jitstressregs3_tst/12/consoleText
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_corefx_minopts_tst/11/consoleText


</Description>
    <Title_Description>[arm32] corefx System.Security.Cryptography.X509Certificates.Tests failures Windows/arm32 corefx System.Security.Cryptography.X509Certificates.Tests failure with COMPlus_JitStressRegs=0x1000 or COMPlus_JitStressRegs=3 or COMPlus_JitMinOpts=1

https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_corefx_jitstressregs0x1000_tst/12/consoleText
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_corefx_jitstressregs3_tst/12/consoleText
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_corefx_minopts_tst/11/consoleText


</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>echesakovMSFT</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17800</IssueLabelID>
    <Title>[WIP] Move Concurrent collections into shared</Title>
    <Description>cc: @safern @danmosemsft @jkotas 

corefx PR: dotnet/corefx#29356

Fixes coreclr issue: #17751 </Description>
    <Title_Description>[WIP] Move Concurrent collections into shared cc: @safern @danmosemsft @jkotas 

corefx PR: dotnet/corefx#29356

Fixes coreclr issue: #17751 </Title_Description>
    <Label>area-System.Collections</Label>
    <Assignee>maryamariyan</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17799</IssueLabelID>
    <Title>[arm32] corefx System.Diagnostics.PerformanceCounter.Tests failure</Title>
    <Description>arm32/Windows corefx test System.Diagnostics.PerformanceCounter.Tests fails:

https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_corefx_baseline_tst/14/consoleText

</Description>
    <Title_Description>[arm32] corefx System.Diagnostics.PerformanceCounter.Tests failure arm32/Windows corefx test System.Diagnostics.PerformanceCounter.Tests fails:

https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_corefx_baseline_tst/14/consoleText

</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>26/04/2018 11:08:42 PM +00:00</CreatedAt>
    <ClosedAt>27/04/2018 7:51:30 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17798</IssueLabelID>
    <Title>Port RayTracer benchmark to SoA algorithm using Vector128/256&lt;T&gt;</Title>
    <Description>The current SIMD benchmark [RayTracer](https://github.com/dotnet/coreclr/tree/master/tests/src/JIT/Performance/CodeQuality/SIMD/RayTracer) is using .

cc @CarolEidt @tannergooding @AndyAyersMS @jkotas 
</Description>
    <Title_Description>Port RayTracer benchmark to SoA algorithm using Vector128/256&lt;T&gt; The current SIMD benchmark [RayTracer](https://github.com/dotnet/coreclr/tree/master/tests/src/JIT/Performance/CodeQuality/SIMD/RayTracer) is using .

cc @CarolEidt @tannergooding @AndyAyersMS @jkotas 
</Title_Description>
    <Label>arch-x64</Label>
    <Assignee>fiigii</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17797</IssueLabelID>
    <Title>RyuJIT: Add side effect flag checking to LIR::Range::CheckLIR()</Title>
    <Description>We check for correctness of side effect flags in fgDebugCheckFlags. We should do that for LIR as well in LIR::Range::CheckLIR().

There is a fundamental difference between side-effects in HIR and LIR in that the flags on a node do not need to be a summary of that node's side effects along with those of its operands: instead the flags for a node should reflect only that node's side effects.

category:correctness
theme:ir
skill-level:intermediate
cost:medium</Description>
    <Title_Description>RyuJIT: Add side effect flag checking to LIR::Range::CheckLIR() We check for correctness of side effect flags in fgDebugCheckFlags. We should do that for LIR as well in LIR::Range::CheckLIR().

There is a fundamental difference between side-effects in HIR and LIR in that the flags on a node do not need to be a summary of that node's side effects along with those of its operands: instead the flags for a node should reflect only that node's side effects.

category:correctness
theme:ir
skill-level:intermediate
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>erozenfeld</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17796</IssueLabelID>
    <Title>RyuJIT: Improve checking of GTF_ORDER_SIDEEFF flags</Title>
    <Description>#13668 enabled strict checking of GTF_EXCEPT and GTF_ASG flags in fgDebugCheckFlags.
The same should be done for GTF_ORDER_SIDEEFF flags.

category:correctness
theme:ir
skill-level:intermediate
cost:medium</Description>
    <Title_Description>RyuJIT: Improve checking of GTF_ORDER_SIDEEFF flags #13668 enabled strict checking of GTF_EXCEPT and GTF_ASG flags in fgDebugCheckFlags.
The same should be done for GTF_ORDER_SIDEEFF flags.

category:correctness
theme:ir
skill-level:intermediate
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>erozenfeld</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17795</IssueLabelID>
    <Title>RyuJIT: Improve checking of GTF_GLOB_REF flags</Title>
    <Description>#13668 enabled strict checking of GTF_EXCEPT and GTF_ASG flags in fgDebugCheckFlags.
The same should be done for GTF_GLOB_REF flags.

category:correctness
theme:ir
skill-level:intermediate
cost:medium</Description>
    <Title_Description>RyuJIT: Improve checking of GTF_GLOB_REF flags #13668 enabled strict checking of GTF_EXCEPT and GTF_ASG flags in fgDebugCheckFlags.
The same should be done for GTF_GLOB_REF flags.

category:correctness
theme:ir
skill-level:intermediate
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>erozenfeld</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17794</IssueLabelID>
    <Title>RyuJIT: Improve checking of GTF_CALL flag</Title>
    <Description>#13668 enabled strict checking of GTF_EXCEPT and GTF_ASG flags in fgDebugCheckFlags.
The same should be done for GTF_CALL flags.
</Description>
    <Title_Description>RyuJIT: Improve checking of GTF_CALL flag #13668 enabled strict checking of GTF_EXCEPT and GTF_ASG flags in fgDebugCheckFlags.
The same should be done for GTF_CALL flags.
</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>erozenfeld</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17790</IssueLabelID>
    <Title>ICLRRuntimeHost2，is it multithread  safe？</Title>
    <Description>ICLRRuntimeHost2，is it multithread  safe？
thank you</Description>
    <Title_Description>ICLRRuntimeHost2，is it multithread  safe？ ICLRRuntimeHost2，is it multithread  safe？
thank you</Title_Description>
    <Label>question</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>26/04/2018 1:03:47 PM +00:00</CreatedAt>
    <ClosedAt>27/04/2018 12:35:51 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17789</IssueLabelID>
    <Title>[local gc] fix com interop issues on local gc</Title>
    <Description>See https://github.com/dotnet/coreclr/blob/54bdc1681c08cf9230561733d4728bc13cbc494e/src/gc/objecthandle.cpp#L451-L467 </Description>
    <Title_Description>[local gc] fix com interop issues on local gc See https://github.com/dotnet/coreclr/blob/54bdc1681c08cf9230561733d4728bc13cbc494e/src/gc/objecthandle.cpp#L451-L467 </Title_Description>
    <Label>area-GC</Label>
    <Assignee>davmason</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17787</IssueLabelID>
    <Title>AF: WaitAll for multiple handles on a STA thread</Title>
    <Description>Example:
.

Is it something expected? Found during work on #17585.
</Description>
    <Title_Description>AF: WaitAll for multiple handles on a STA thread Example:
.

Is it something expected? Found during work on #17585.
</Title_Description>
    <Label>area-System.Threading</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17783</IssueLabelID>
    <Title>Publish release/uwp6.0 and release/uwp6.1 symbols Publish symbols using Microsoft.SymbolUploader.Build.Task package</Title>
    <Description>See https://github.com/dotnet/coreclr/issues/16482. This tracks porting infrastructure to the  branches.</Description>
    <Title_Description>Publish release/uwp6.0 and release/uwp6.1 symbols Publish symbols using Microsoft.SymbolUploader.Build.Task package See https://github.com/dotnet/coreclr/issues/16482. This tracks porting infrastructure to the  branches.</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>25/04/2018 9:38:27 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17782</IssueLabelID>
    <Title>XPlat C# Debugger is failing to show Async Callstack frames</Title>
    <Description>Found by @chuckries during scenario testing.</Description>
    <Title_Description>XPlat C# Debugger is failing to show Async Callstack frames Found by @chuckries during scenario testing.</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>chuckries</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17778</IssueLabelID>
    <Title>release/uwp6.0 and release/uwp6.1 long-name DAC/SOS have incorrect version</Title>
    <Description>See https://github.com/dotnet/coreclr/issues/17619. The long-name DAC/SOS aren't indexed properly because the DLLs have the wrong name in the symbol packages.

~~The same~~ A similar problem to  (expected)

https://github.com/dotnet/coreclr/blob/9afe551aa13b52d7ebca9aeed1da97edc51b843f/src/.nuget/Microsoft.NETCore.Runtime.CoreCLR/runtime.Windows_NT.Microsoft.NETCore.Runtime.CoreCLR.props#L9-L10

https://github.com/dotnet/coreclr/blob/25c45ac5da9e2f709be7b8fb115e116d3ae44ac4/src/.nuget/Microsoft.NETCore.Runtime.CoreCLR/runtime.Windows_NT.Microsoft.NETCore.Runtime.CoreCLR.props#L9-L10

These branches should be fixed before they're next released or there will have to be more manual fix-ups on the symbol packages for the long-name DAC/SOS files. @nattress @zamont do you know the status of these CoreCLR branches?

/cc @lt72 @mikem8361 @leculver @weshaggard </Description>
    <Title_Description>release/uwp6.0 and release/uwp6.1 long-name DAC/SOS have incorrect version See https://github.com/dotnet/coreclr/issues/17619. The long-name DAC/SOS aren't indexed properly because the DLLs have the wrong name in the symbol packages.

~~The same~~ A similar problem to  (expected)

https://github.com/dotnet/coreclr/blob/9afe551aa13b52d7ebca9aeed1da97edc51b843f/src/.nuget/Microsoft.NETCore.Runtime.CoreCLR/runtime.Windows_NT.Microsoft.NETCore.Runtime.CoreCLR.props#L9-L10

https://github.com/dotnet/coreclr/blob/25c45ac5da9e2f709be7b8fb115e116d3ae44ac4/src/.nuget/Microsoft.NETCore.Runtime.CoreCLR/runtime.Windows_NT.Microsoft.NETCore.Runtime.CoreCLR.props#L9-L10

These branches should be fixed before they're next released or there will have to be more manual fix-ups on the symbol packages for the long-name DAC/SOS files. @nattress @zamont do you know the status of these CoreCLR branches?

/cc @lt72 @mikem8361 @leculver @weshaggard </Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>nattress</Assignee>
    <CreatedAt>25/04/2018 8:01:57 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17777</IssueLabelID>
    <Title>Fix IMPL_LIMITATION on Struct LclVar Offsets for 64-bit targets</Title>
    <Description>The emitter has a  which has  a limitation on offset values for large LclVars numbers (above 32767)   For our 64-bit targets we can use some extra bits to eliminate this limiation.
</Description>
    <Title_Description>Fix IMPL_LIMITATION on Struct LclVar Offsets for 64-bit targets The emitter has a  which has  a limitation on offset values for large LclVars numbers (above 32767)   For our 64-bit targets we can use some extra bits to eliminate this limiation.
</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>briansull</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17775</IssueLabelID>
    <Title>Fix instruction groups offset on the border between cold/hot code.</Title>
    <Description>Fixes DevDiv_601045; assert while generating diffs:
https://github.com/dotnet/coreclr/blob/71f4199f7dd043c4901a187b9bd88ab40e2b87e2/src/jit/emit.cpp#L7185

I was not able to repro the original issue on Core and it did not allow me to go back and find when the desktop issue appeared. The new checks show that the problem exists in CoreCLR as well.

The fix doesn't change the generated code (it changes only unused allocated parts) and doesn't cause any diffs.

The important changes are in the fourth commit.</Description>
    <Title_Description>Fix instruction groups offset on the border between cold/hot code. Fixes DevDiv_601045; assert while generating diffs:
https://github.com/dotnet/coreclr/blob/71f4199f7dd043c4901a187b9bd88ab40e2b87e2/src/jit/emit.cpp#L7185

I was not able to repro the original issue on Core and it did not allow me to go back and find when the desktop issue appeared. The new checks show that the problem exists in CoreCLR as well.

The fix doesn't change the generated code (it changes only unused allocated parts) and doesn't cause any diffs.

The important changes are in the fourth commit.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>25/04/2018 6:13:09 PM +00:00</CreatedAt>
    <ClosedAt>20/06/2018 1:02:12 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17772</IssueLabelID>
    <Title>Use of created nested types in dynamic assembly builders cause TypeLoadExceptions</Title>
    <Description>When attempting to generate a dynamic type that contains a nested type use of the type to generate fields on the parent type fails with a [TypeLoadException][exception] if the type has been realized using 

[repro-project]: https://github.com/dotnet/core/files/1947057/Scratchpad.zip
[exception]: https://gist.github.com/Nihlus/63eb35f3ee3a2f38456002c60bb5d057</Description>
    <Title_Description>Use of created nested types in dynamic assembly builders cause TypeLoadExceptions When attempting to generate a dynamic type that contains a nested type use of the type to generate fields on the parent type fails with a [TypeLoadException][exception] if the type has been realized using 

[repro-project]: https://github.com/dotnet/core/files/1947057/Scratchpad.zip
[exception]: https://gist.github.com/Nihlus/63eb35f3ee3a2f38456002c60bb5d057</Title_Description>
    <Label>area-System.Reflection</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>25/04/2018 1:12:58 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17771</IssueLabelID>
    <Title>[local gc] enable AnalyzeSurvivorsRequested and DACNotifyGcMarkEnd </Title>
    <Description>AnalyzeSurvivorsRequested and DACNotifyGcMarkEnd are disabled for local gc because they require GCnotifications which doesn't currently work across the GC interface</Description>
    <Title_Description>[local gc] enable AnalyzeSurvivorsRequested and DACNotifyGcMarkEnd  AnalyzeSurvivorsRequested and DACNotifyGcMarkEnd are disabled for local gc because they require GCnotifications which doesn't currently work across the GC interface</Title_Description>
    <Label>area-GC</Label>
    <Assignee>davmason</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17770</IssueLabelID>
    <Title>[local gc] enable use of NumaNodeInfo for local gc and PAL</Title>
    <Description>Right now we skip NumaNodeInfo for local gc and pal. See virtual_alloc_commit_for_heap in gc.cpp.</Description>
    <Title_Description>[local gc] enable use of NumaNodeInfo for local gc and PAL Right now we skip NumaNodeInfo for local gc and pal. See virtual_alloc_commit_for_heap in gc.cpp.</Title_Description>
    <Label>area-GC</Label>
    <Assignee>davmason</Assignee>
    <CreatedAt>25/04/2018 7:46:22 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17768</IssueLabelID>
    <Title>Delete InternalsVisibleTo attributes from S.P.CoreLib</Title>
    <Description>https://github.com/dotnet/coreclr/blob/master/src/mscorlib/src/mscorlib.Friends.cs

There attributes are needed for WinRT interop on Windows today. They prevent ILLinker from stripping unreachable code from S.P.CoreLib.

Fixing this should reduce size of S.P.CoreLib IL image by ~80kB.</Description>
    <Title_Description>Delete InternalsVisibleTo attributes from S.P.CoreLib https://github.com/dotnet/coreclr/blob/master/src/mscorlib/src/mscorlib.Friends.cs

There attributes are needed for WinRT interop on Windows today. They prevent ILLinker from stripping unreachable code from S.P.CoreLib.

Fixing this should reduce size of S.P.CoreLib IL image by ~80kB.</Title_Description>
    <Label>area-Meta-corelib</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>25/04/2018 3:19:44 AM +00:00</CreatedAt>
    <ClosedAt>16/07/2018 5:27:55 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17767</IssueLabelID>
    <Title>Fix AsyncLocal&lt;class&gt; changed event to not be raised multiple times for one change in value</Title>
    <Description>Functional fix for https://github.com/dotnet/coreclr/issues/17758</Description>
    <Title_Description>Fix AsyncLocal&lt;class&gt; changed event to not be raised multiple times for one change in value Functional fix for https://github.com/dotnet/coreclr/issues/17758</Title_Description>
    <Label>area-System.Threading</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17760</IssueLabelID>
    <Title>Server GC is set with different env vars across platforms</Title>
    <Description>On Unix we set server gc by setting 

We should try to make these into one variable that works across all platforms. </Description>
    <Title_Description>Server GC is set with different env vars across platforms On Unix we set server gc by setting 

We should try to make these into one variable that works across all platforms. </Title_Description>
    <Label>area-GC</Label>
    <Assignee>sywhang</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17759</IssueLabelID>
    <Title>Add tests for arm64 il issues.</Title>
    <Description>The PR adds tests that are failing in our internal test system with arm64 altjit.
Failures are:

</Description>
    <Title_Description>Add tests for arm64 il issues. The PR adds tests that are failing in our internal test system with arm64 altjit.
Failures are:

</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>24/04/2018 9:36:31 PM +00:00</CreatedAt>
    <ClosedAt>14/05/2018 8:29:43 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17758</IssueLabelID>
    <Title>AsyncLocal&lt;class&gt; changed event can be raised multiple times for one change in value</Title>
    <Description> the key not existing means it will add a new change notification. So each transition of an AsyncLocal&lt;class&gt;'s value from null to non-null will add an additional change notification. The fix would probably be to keep the key in the IAsyncLocalValueMap despite its value becoming null.

The issue currently requires two AsyncLocals to reproduce because [for the first AsyncLocal](https://github.com/dotnet/coreclr/blob/master/src/mscorlib/shared/System/Threading/ExecutionContext.cs#L337) it does not consider whether the new value is null as opposed to AsyncLocalValueMap's implementation.

CC @stephentoub </Description>
    <Title_Description>AsyncLocal&lt;class&gt; changed event can be raised multiple times for one change in value  the key not existing means it will add a new change notification. So each transition of an AsyncLocal&lt;class&gt;'s value from null to non-null will add an additional change notification. The fix would probably be to keep the key in the IAsyncLocalValueMap despite its value becoming null.

The issue currently requires two AsyncLocals to reproduce because [for the first AsyncLocal](https://github.com/dotnet/coreclr/blob/master/src/mscorlib/shared/System/Threading/ExecutionContext.cs#L337) it does not consider whether the new value is null as opposed to AsyncLocalValueMap's implementation.

CC @stephentoub </Title_Description>
    <Label>area-System.Threading</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17756</IssueLabelID>
    <Title>[arm32/Ubuntu][JitStressRegs] corefx System.Net.NameResolution.Functional.Tests failures</Title>
    <Description>With JitStressRegs=0x10

https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_tst_prtest/1/consoleText


</Description>
    <Title_Description>[arm32/Ubuntu][JitStressRegs] corefx System.Net.NameResolution.Functional.Tests failures With JitStressRegs=0x10

https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_tst_prtest/1/consoleText


</Title_Description>
    <Label>JitStress</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17755</IssueLabelID>
    <Title>[arm32/Ubuntu][JitStress] corefx System.Runtime.Tests times out</Title>
    <Description>With JitStress=1 or JitStress=2 the test times out (or hangs):



https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstress1_tst_prtest/1/consoleText
https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstress2_tst_prtest/1/consoleText</Description>
    <Title_Description>[arm32/Ubuntu][JitStress] corefx System.Runtime.Tests times out With JitStress=1 or JitStress=2 the test times out (or hangs):



https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstress1_tst_prtest/1/consoleText
https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstress2_tst_prtest/1/consoleText</Title_Description>
    <Label>JitStress</Label>
    <Assignee>echesakovMSFT</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17754</IssueLabelID>
    <Title>[arm32/Ubuntu] corefx test timeouts</Title>
    <Description>The following tests time out (with 10 minute default timeout) in a corefx test run:



e.g.

https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_ubuntu_corefx_baseline_tst_prtest/1/consoleText
</Description>
    <Title_Description>[arm32/Ubuntu] corefx test timeouts The following tests time out (with 10 minute default timeout) in a corefx test run:



e.g.

https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_ubuntu_corefx_baseline_tst_prtest/1/consoleText
</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>echesakovMSFT</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17753</IssueLabelID>
    <Title>[arm32/Ubuntu] corefx test failures: System.Net.NetworkInformation.Functional.Tests System.Net.Sockets.Tests</Title>
    <Description>These tests:


have segmentation faults in the corefx test run e.g.:

https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_ubuntu_corefx_baseline_tst_prtest/1/consoleText
</Description>
    <Title_Description>[arm32/Ubuntu] corefx test failures: System.Net.NetworkInformation.Functional.Tests, System.Net.Sockets.Tests These tests:


have segmentation faults in the corefx test run e.g.:

https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_ubuntu_corefx_baseline_tst_prtest/1/consoleText
</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>echesakovMSFT</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17751</IssueLabelID>
    <Title>Move Concurrent collections into shared</Title>
    <Description>These seem like they can be reconciled 


Usual procedure is 
1. Upgrade CoreCLR versions to have functionality of CoreFX ones. This may mean just copying over the CoreFX ones. Move to C:\git\coreclr\src\mscorlib\shared\System\Collections\Concurrent
1. Prepare a PR in CoreFX that deletes the 4 files there and instead pulls them from C:\git\corefx\src\Common\src\CoreLib\System\Collections\Concurrent
1. When mirror brings those files merge the PR.

@maryamariyan </Description>
    <Title_Description>Move Concurrent collections into shared These seem like they can be reconciled 


Usual procedure is 
1. Upgrade CoreCLR versions to have functionality of CoreFX ones. This may mean just copying over the CoreFX ones. Move to C:\git\coreclr\src\mscorlib\shared\System\Collections\Concurrent
1. Prepare a PR in CoreFX that deletes the 4 files there and instead pulls them from C:\git\corefx\src\Common\src\CoreLib\System\Collections\Concurrent
1. When mirror brings those files merge the PR.

@maryamariyan </Title_Description>
    <Label>area-System.Collections</Label>
    <Assignee>maryamariyan</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17748</IssueLabelID>
    <Title>WIP NO MERGE dummy change</Title>
    <Description>
    </Description>
    <Title_Description>WIP NO MERGE dummy change </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>24/04/2018 1:04:30 AM +00:00</CreatedAt>
    <ClosedAt>25/04/2018 4:02:06 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17745</IssueLabelID>
    <Title>Delete unused tests\arm64\fails.testlist</Title>
    <Description>The original issue #9481 was closed long time ago.</Description>
    <Title_Description>Delete unused tests\arm64\fails.testlist The original issue #9481 was closed long time ago.</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>24/04/2018 12:19:47 AM +00:00</CreatedAt>
    <ClosedAt>24/04/2018 10:42:28 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17744</IssueLabelID>
    <Title>GC test failures in checked outerloop job</Title>
    <Description>https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64/job/checked_windows_nt/9461/consoleText

Looks like these started failing after #17680.

@sywhang 

</Description>
    <Title_Description>GC test failures in checked outerloop job https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64/job/checked_windows_nt/9461/consoleText

Looks like these started failing after #17680.

@sywhang 

</Title_Description>
    <Label>test bug</Label>
    <Assignee>sywhang</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17741</IssueLabelID>
    <Title>ICorProfiler retrieve function arguments in JitCompilationStarted</Title>
    <Description>I've seen this done before but for the life of me I'm having trouble finding a function's arguments when my ICorProfiler profiler's JitCompilationStarted event is called. I've got the  but I don't have the actual arguments being passed in the function.

Is there an interface method I can call to get them?

thanks.</Description>
    <Title_Description>ICorProfiler retrieve function arguments in JitCompilationStarted I've seen this done before but for the life of me I'm having trouble finding a function's arguments when my ICorProfiler profiler's JitCompilationStarted event is called. I've got the  but I don't have the actual arguments being passed in the function.

Is there an interface method I can call to get them?

thanks.</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>23/04/2018 10:37:59 PM +00:00</CreatedAt>
    <ClosedAt>2/01/2019 10:54:14 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17740</IssueLabelID>
    <Title>[arm32] corefx System.Net.NameResolution.Pal.Tests fails</Title>
    <Description>https://ci.dot.net/job/dotnet_coreclr/job/dev_unix_test_workflow/job/jitstress/job/arm_cross_checked_ubuntu_corefx_baseline_tst_prtest/3/consoleText


</Description>
    <Title_Description>[arm32] corefx System.Net.NameResolution.Pal.Tests fails https://ci.dot.net/job/dotnet_coreclr/job/dev_unix_test_workflow/job/jitstress/job/arm_cross_checked_ubuntu_corefx_baseline_tst_prtest/3/consoleText


</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>23/04/2018 9:46:45 PM +00:00</CreatedAt>
    <ClosedAt>23/04/2018 11:47:38 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17739</IssueLabelID>
    <Title>[arm32] corefx System.Net.Http.Functional.Tests fails</Title>
    <Description>60 failures in this test suite:

https://ci.dot.net/job/dotnet_coreclr/job/dev_unix_test_workflow/job/jitstress/job/arm_cross_checked_ubuntu_corefx_baseline_tst_prtest/3/consoleText

Some seem like timeout (which is probably just too tight):

</Description>
    <Title_Description>[arm32] corefx System.Net.Http.Functional.Tests fails 60 failures in this test suite:

https://ci.dot.net/job/dotnet_coreclr/job/dev_unix_test_workflow/job/jitstress/job/arm_cross_checked_ubuntu_corefx_baseline_tst_prtest/3/consoleText

Some seem like timeout (which is probably just too tight):

</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>23/04/2018 9:44:47 PM +00:00</CreatedAt>
    <ClosedAt>23/04/2018 11:47:00 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17738</IssueLabelID>
    <Title>[arm32] Compiler optimization assumption invalid: FAILED: pMgr != 0</Title>
    <Description>In the corefx tests System.Linq.Expressions.Tests:

https://ci.dot.net/job/dotnet_coreclr/job/dev_unix_test_workflow/job/jitstress/job/arm_cross_checked_ubuntu_corefx_baseline_tst_prtest/3/consoleText


</Description>
    <Title_Description>[arm32] Compiler optimization assumption invalid: FAILED: pMgr != 0 In the corefx tests System.Linq.Expressions.Tests:

https://ci.dot.net/job/dotnet_coreclr/job/dev_unix_test_workflow/job/jitstress/job/arm_cross_checked_ubuntu_corefx_baseline_tst_prtest/3/consoleText


</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>BruceForstall</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17736</IssueLabelID>
    <Title>headers to use when porting Profiler from windows to linux</Title>
    <Description>I have a CLR profiler that supports dotnet core 2.0 on Windows. Now i wish to port it to build and work on  Linux. I think i need some guidance on what are the best practices and/or an relatively realistic example.

I had started my research based on a sample dotnet core profiler written by MS folks:
https://github.com/Microsoft/clr-samples/tree/master/ProfilingAPI/ReJITEnterLeaveHooks
(recommended starting point as is stated in this issue: https://github.com/dotnet/coreclr/issues/14786). 

This Sample Profiler uses **PAL** and uses ). what headers/Compilation flags should i use  so the types of the Profiler can be the same as in the CoreCLR. It feels like the Profiler writer has to carefully arrange those include headers but i have no clue how?  OR i guess it might be helpful if someone explains in general how the Profiling Interface piece in CLR is built if the Profiler should be doing the same?

</Description>
    <Title_Description>headers to use when porting Profiler from windows to linux I have a CLR profiler that supports dotnet core 2.0 on Windows. Now i wish to port it to build and work on  Linux. I think i need some guidance on what are the best practices and/or an relatively realistic example.

I had started my research based on a sample dotnet core profiler written by MS folks:
https://github.com/Microsoft/clr-samples/tree/master/ProfilingAPI/ReJITEnterLeaveHooks
(recommended starting point as is stated in this issue: https://github.com/dotnet/coreclr/issues/14786). 

This Sample Profiler uses **PAL** and uses ). what headers/Compilation flags should i use  so the types of the Profiler can be the same as in the CoreCLR. It feels like the Profiler writer has to carefully arrange those include headers but i have no clue how?  OR i guess it might be helpful if someone explains in general how the Profiling Interface piece in CLR is built if the Profiler should be doing the same?

</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>23/04/2018 4:28:50 PM +00:00</CreatedAt>
    <ClosedAt>24/04/2018 1:58:54 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17735</IssueLabelID>
    <Title>[Question] R2R and version bubbles</Title>
    <Description>As I understand the main motivation to create Ready To Run mode of crossgen is making native images are more independent from runtime change. What is the current state of it? Should we regenerate application native images in case of updating runtime or system libraries (of course I mean case when API isn't changed)?

Second question is about version bubbles. As I see from source code (https://github.com/dotnet/coreclr/blob/master/src/vm/jitinterface.cpp#L654) . Are there any plans to implement this concept?
What projects will needed changes to support this? Except CoreCLR I think compiler should know about bubbles. Are there any other projects?

cc @jkotas @BruceForstall @gbalykov </Description>
    <Title_Description>[Question] R2R and version bubbles As I understand the main motivation to create Ready To Run mode of crossgen is making native images are more independent from runtime change. What is the current state of it? Should we regenerate application native images in case of updating runtime or system libraries (of course I mean case when API isn't changed)?

Second question is about version bubbles. As I see from source code (https://github.com/dotnet/coreclr/blob/master/src/vm/jitinterface.cpp#L654) . Are there any plans to implement this concept?
What projects will needed changes to support this? Except CoreCLR I think compiler should know about bubbles. Are there any other projects?

cc @jkotas @BruceForstall @gbalykov </Title_Description>
    <Label>area-ReadyToRun</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>23/04/2018 4:05:10 PM +00:00</CreatedAt>
    <ClosedAt>4/05/2018 4:36:28 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17733</IssueLabelID>
    <Title>Expand GT_JCC/SETCC condition support</Title>
    <Description>Currently GT_JCC/SETCC nodes use relops as condition codes and this prevents the use of flag specific conditions (e.g. S NS P NP) and floating point conditions. Additionally the code used by GT_JTRUE and relop codegen is rather convoluted and not very easy to reuse for GT_JCC/SETCC codegen.

This changes GT_JCC/SETCC's condition to  can be removed.

Contributes to #17073</Description>
    <Title_Description>Expand GT_JCC/SETCC condition support Currently GT_JCC/SETCC nodes use relops as condition codes and this prevents the use of flag specific conditions (e.g. S NS P NP) and floating point conditions. Additionally the code used by GT_JTRUE and relop codegen is rather convoluted and not very easy to reuse for GT_JCC/SETCC codegen.

This changes GT_JCC/SETCC's condition to  can be removed.

Contributes to #17073</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>dotnet-bot</Assignee>
    <CreatedAt>23/04/2018 3:18:51 PM +00:00</CreatedAt>
    <ClosedAt>11/01/2019 12:29:43 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17732</IssueLabelID>
    <Title>Enable Invoke and GetValue for ref-returning members</Title>
    <Description>https://github.com/dotnet/corefx/issues/15960

(Attempt #2)

Returned magic object is the object pointed to by
the ref. If the ref is null NullReferenceException.

</Description>
    <Title_Description>Enable Invoke and GetValue for ref-returning members https://github.com/dotnet/corefx/issues/15960

(Attempt #2)

Returned magic object is the object pointed to by
the ref. If the ref is null NullReferenceException.

</Title_Description>
    <Label>area-System.Reflection</Label>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>26685</IssueLabelID>
    <Title>Requesting support for Linux-ARM w/ 16 FPU registers</Title>
    <Description>Hi

Our Business Units widely use ARM based CPU to develop hardware solutions for automation and energy management.

We appreciate Microsoft’s decision to support native .Net Core deployment for linux-arm target. We have positive results of self-contained deployments for Cortex-A9 based devices. It’ll really speed up development-to-deployment-to-market process.

During one of our POC projects we’ve identified that some of chips (e.q. RZ/N1D) extensively used by our BU aren’t compatible with current linux-arm runtime and generate “Illegal Instruction” exception.

Further investigation revealed very simple but critical incompatibility: this chip’s FPU includes only 16 double-precision registers. Seems like simple change of cross-compiler option from vfpv3 to vfpv3-d16 [or vfpv4-d16] to generate runtime libraries should solve this problem. 

An alternative solution would be to support linux-armel target i.e. do not use Floating Point Unit at all though the previously outlined solution would be preferable.

Would you please consider building and including runtime specific packages for linux-arm-VFPv4-d16 and/or linux-armel devices. 

</Description>
    <Title_Description>Requesting support for Linux-ARM w/ 16 FPU registers Hi

Our Business Units widely use ARM based CPU to develop hardware solutions for automation and energy management.

We appreciate Microsoft’s decision to support native .Net Core deployment for linux-arm target. We have positive results of self-contained deployments for Cortex-A9 based devices. It’ll really speed up development-to-deployment-to-market process.

During one of our POC projects we’ve identified that some of chips (e.q. RZ/N1D) extensively used by our BU aren’t compatible with current linux-arm runtime and generate “Illegal Instruction” exception.

Further investigation revealed very simple but critical incompatibility: this chip’s FPU includes only 16 double-precision registers. Seems like simple change of cross-compiler option from vfpv3 to vfpv3-d16 [or vfpv4-d16] to generate runtime libraries should solve this problem. 

An alternative solution would be to support linux-armel target i.e. do not use Floating Point Unit at all though the previously outlined solution would be preferable.

Would you please consider building and including runtime specific packages for linux-arm-VFPv4-d16 and/or linux-armel devices. 

</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>richlander</Assignee>
    <CreatedAt>23/04/2018 12:49:39 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17731</IssueLabelID>
    <Title>C++ calls.Netcore through coreclr</Title>
    <Description>Hi
https://docs.microsoft.com/en-us/dotnet/core/tutorials/netcore-hosting
In accordance with this document I call the.Netcore class library through the coreclr host when I execute it.
CreateDelegate function times error error: the given assembly name or base code is invalid.</Description>
    <Title_Description>C++ calls.Netcore through coreclr Hi
https://docs.microsoft.com/en-us/dotnet/core/tutorials/netcore-hosting
In accordance with this document I call the.Netcore class library through the coreclr host when I execute it.
CreateDelegate function times error error: the given assembly name or base code is invalid.</Title_Description>
    <Label>area-AssemblyLoader</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>23/04/2018 4:25:41 AM +00:00</CreatedAt>
    <ClosedAt>1/05/2018 3:49:21 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17724</IssueLabelID>
    <Title>Fix FakePromote assert</Title>
    <Description>This assert was firing when there was a struct with explicit layout and
two byref fields overlapping each other. The assert was checking that
the respective location on the stack was not reported yet.
To fix that I have changed the assert to fire only if the already
reported kind of reference was different from the current one. That
enables overlapping of two byref fields or two ref fields but not a
byref and ref fields.

Close #17565</Description>
    <Title_Description>Fix FakePromote assert This assert was firing when there was a struct with explicit layout and
two byref fields overlapping each other. The assert was checking that
the respective location on the stack was not reported yet.
To fix that I have changed the assert to fire only if the already
reported kind of reference was different from the current one. That
enables overlapping of two byref fields or two ref fields but not a
byref and ref fields.

Close #17565</Title_Description>
    <Label>area-CrossGen/NGEN</Label>
    <Assignee>janvorli</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17716</IssueLabelID>
    <Title>GC crash in Kestrel Libuv and Sockets FunctionalTests/netcoreapp2.1</Title>
    <Description>_From @mikeharder on April 18 2018 18:42_

Kestrel FunctionalTests are hanging frequently on CI:

# KestrelHttpServer

http://aspnetci/viewLog.html?buildId=449994&amp;tab=buildLog&amp;buildTypeId=Lite_KestrelStressTest&amp;logTab=tail

_Copied from original issue: aspnet/KestrelHttpServer#2503_</Description>
    <Title_Description>GC crash in Kestrel Libuv and Sockets FunctionalTests/netcoreapp2.1 _From @mikeharder on April 18 2018 18:42_

Kestrel FunctionalTests are hanging frequently on CI:

# KestrelHttpServer

http://aspnetci/viewLog.html?buildId=449994&amp;tab=buildLog&amp;buildTypeId=Lite_KestrelStressTest&amp;logTab=tail

_Copied from original issue: aspnet/KestrelHttpServer#2503_</Title_Description>
    <Label>area-GC</Label>
    <Assignee>jkotas</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17714</IssueLabelID>
    <Title>[release/2.1] Port Preserve pinned flag in {ReadOnly}Memory&lt;T&gt;.Slice</Title>
    <Description>Fixes https://github.com/dotnet/corefx/issues/29239 (from https://github.com/dotnet/coreclr/pull/17712)

cc @joshfree @GrabYourPitchforks @geoffkizer @stephentoub @benaadams @davidfowl  </Description>
    <Title_Description>[release/2.1] Port Preserve pinned flag in {ReadOnly}Memory&lt;T&gt;.Slice Fixes https://github.com/dotnet/corefx/issues/29239 (from https://github.com/dotnet/coreclr/pull/17712)

cc @joshfree @GrabYourPitchforks @geoffkizer @stephentoub @benaadams @davidfowl  </Title_Description>
    <Label>area-System.Memory</Label>
    <Assignee>ahsonkhan</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17712</IssueLabelID>
    <Title>Mirror changes from dotnet/corefx</Title>
    <Description>This PR contains mirrored changes from dotnet/corefx


**Please REBASE this PR when merging**</Description>
    <Title_Description>Mirror changes from dotnet/corefx This PR contains mirrored changes from dotnet/corefx


**Please REBASE this PR when merging**</Title_Description>
    <Label>
    </Label>
    <Assignee>ahsonkhan</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17711</IssueLabelID>
    <Title>Fix getting the Absolute path while looking up the TZ files</Title>
    <Description>We used to call Path.Combine and passing 2 file paths (and not really a directory paths) which always produced a wrong full path. This causes us to always go and enumerate TZ files and compare the content of each file to the current TZ data we have. So this should speed up the TZ creation on Linux as we'll not enumerate the TZ files. 

Also this will fix getting the correct Id of the TZ. for example when trying to get the Iran time zone currently we'll get the Id= "Iran" as this is the TZ file name. while after the fix we'll get the correct Id= "Asia/Tehran" </Description>
    <Title_Description>Fix getting the Absolute path while looking up the TZ files We used to call Path.Combine and passing 2 file paths (and not really a directory paths) which always produced a wrong full path. This causes us to always go and enumerate TZ files and compare the content of each file to the current TZ data we have. So this should speed up the TZ creation on Linux as we'll not enumerate the TZ files. 

Also this will fix getting the correct Id of the TZ. for example when trying to get the Iran time zone currently we'll get the Id= "Iran" as this is the TZ file name. while after the fix we'll get the correct Id= "Asia/Tehran" </Title_Description>
    <Label>area-System.Runtime</Label>
    <Assignee>tarekgh</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17709</IssueLabelID>
    <Title>Mirror changes from dotnet/corefx</Title>
    <Description>This PR contains mirrored changes from dotnet/corefx


**Please REBASE this PR when merging**</Description>
    <Title_Description>Mirror changes from dotnet/corefx This PR contains mirrored changes from dotnet/corefx


**Please REBASE this PR when merging**</Title_Description>
    <Label>
    </Label>
    <Assignee>ahsonkhan</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17706</IssueLabelID>
    <Title>[x86|Windows|Full Framework|NativeVararg] Passing an eight byte struct of long</Title>
    <Description>c#


</Description>
    <Title_Description>[x86|Windows|Full Framework|NativeVararg] Passing an eight byte struct of long c#


</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>pgavlin</Assignee>
    <CreatedAt>20/04/2018 7:08:31 PM +00:00</CreatedAt>
    <ClosedAt>21/04/2018 2:31:42 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17704</IssueLabelID>
    <Title>[x86|Windows|Full Framework| NativeVararg] Passing a double after an int/long results in bad codegen</Title>
    <Description>C#


</Description>
    <Title_Description>[x86|Windows|Full Framework| NativeVararg] Passing a double after an int/long results in bad codegen C#


</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>jashook</Assignee>
    <CreatedAt>20/04/2018 7:04:20 PM +00:00</CreatedAt>
    <ClosedAt>21/04/2018 2:31:56 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17703</IssueLabelID>
    <Title>[x64|Windows|Full Framework] Passing 32 byte struct of four doubles with native varargs results in bad codegen</Title>
    <Description>c#



Note this is may be related to #17702.
</Description>
    <Title_Description>[x64|Windows|Full Framework] Passing 32 byte struct of four doubles with native varargs results in bad codegen c#



Note this is may be related to #17702.
</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>jashook</Assignee>
    <CreatedAt>20/04/2018 6:40:07 PM +00:00</CreatedAt>
    <ClosedAt>20/04/2018 7:10:59 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17702</IssueLabelID>
    <Title>[x86|x64|Windows|Full Framework|NativeVararg] Passing 16 byte struct of two longs results in bad codegen</Title>
    <Description>C#



Note this fails on x86 as well as x64 but may be two separate issues.</Description>
    <Title_Description>[x86|x64|Windows|Full Framework|NativeVararg] Passing 16 byte struct of two longs results in bad codegen C#



Note this fails on x86 as well as x64 but may be two separate issues.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>pgavlin</Assignee>
    <CreatedAt>20/04/2018 6:30:37 PM +00:00</CreatedAt>
    <ClosedAt>1/05/2018 10:26:33 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17701</IssueLabelID>
    <Title>System.Diagnostics.StackTrace slow on .NET Core</Title>
    <Description>Consider the following program:


</Description>
    <Title_Description>System.Diagnostics.StackTrace slow on .NET Core Consider the following program:


</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>mikem8361</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17698</IssueLabelID>
    <Title>corefx test failure: Assert failure: !"You cannot use this function for arbitrary value types. You must preallocate a box object and copy the value in yourself."</Title>
    <Description>https://ci.dot.net/job/dotnet_coreclr/job/master/view/x86/job/jitstress/job/x86_checked_windows_nt_corefx_baseline/462/consoleText

many tests fail with:


Also seen on ARM.
</Description>
    <Title_Description>corefx test failure: Assert failure: !"You cannot use this function for arbitrary value types. You must preallocate a box object and copy the value in yourself." https://ci.dot.net/job/dotnet_coreclr/job/master/view/x86/job/jitstress/job/x86_checked_windows_nt_corefx_baseline/462/consoleText

many tests fail with:


Also seen on ARM.
</Title_Description>
    <Label>bug</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>20/04/2018 4:43:23 PM +00:00</CreatedAt>
    <ClosedAt>20/04/2018 5:24:34 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17695</IssueLabelID>
    <Title>Question about typeforwarding public types</Title>
    <Description>I have an executable named .


</Description>
    <Title_Description>Question about typeforwarding public types I have an executable named .


</Title_Description>
    <Label>area-TypeSystem</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>20/04/2018 7:17:36 AM +00:00</CreatedAt>
    <ClosedAt>20/04/2018 5:19:52 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17694</IssueLabelID>
    <Title>Account for copied bytes in struct copy loop when generating GT_PUTARG_STK code [ARM64]</Title>
    <Description>When generating code for a GT_PUTARG_STK where there's an HFA struct being passed on the stack we have a loop that copies the struct 16 bytes at a time with ldp/stp. However in the case where we have a var node for the struct we weren't increasing the offset of the ldp to account for the portion of the struct we've already copied. Thus a struct with size 16*_n_ would just end up having _n_ copies of its first 16 bytes.

The fix is simple: instead of hardcoding the offset to 0 when we emit the ldp we set it to be the number of bytes we've copied which is conveniently already captured for us in .

@BruceForstall @jkotas @janvorli </Description>
    <Title_Description>Account for copied bytes in struct copy loop when generating GT_PUTARG_STK code [ARM64] When generating code for a GT_PUTARG_STK where there's an HFA struct being passed on the stack we have a loop that copies the struct 16 bytes at a time with ldp/stp. However in the case where we have a var node for the struct we weren't increasing the offset of the ldp to account for the portion of the struct we've already copied. Thus a struct with size 16*_n_ would just end up having _n_ copies of its first 16 bytes.

The fix is simple: instead of hardcoding the offset to 0 when we emit the ldp we set it to be the number of bytes we've copied which is conveniently already captured for us in .

@BruceForstall @jkotas @janvorli </Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>20/04/2018 2:23:55 AM +00:00</CreatedAt>
    <ClosedAt>26/04/2018 5:40:46 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17693</IssueLabelID>
    <Title>[clrdbg] Add support for inline values</Title>
    <Description>VSCode Debugger Protocol now supports inline values for variables when debugging. It would be great if vsdbg/vsdbg-ui adds support for this.

Debugger Protocol:
[https://github.com/Microsoft/vscode-debugadapter-node/issues/78](url)
[https://github.com/Microsoft/vscode-debugadapter-node/blob/896566e0be3f48e5cf90fb715b3b3ffbfa777888/protocol/src/debugProtocol.ts#L1329-L1337](url)

VSCode Support:
[https://github.com/Microsoft/vscode/pull/16129](url)</Description>
    <Title_Description>[clrdbg] Add support for inline values VSCode Debugger Protocol now supports inline values for variables when debugging. It would be great if vsdbg/vsdbg-ui adds support for this.

Debugger Protocol:
[https://github.com/Microsoft/vscode-debugadapter-node/issues/78](url)
[https://github.com/Microsoft/vscode-debugadapter-node/blob/896566e0be3f48e5cf90fb715b3b3ffbfa777888/protocol/src/debugProtocol.ts#L1329-L1337](url)

VSCode Support:
[https://github.com/Microsoft/vscode/pull/16129](url)</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>20/04/2018 2:12:56 AM +00:00</CreatedAt>
    <ClosedAt>21/04/2018 12:53:47 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17692</IssueLabelID>
    <Title>Mscordbi uses incorrect layout for MDInternalRW.</Title>
    <Description>Mscordbi uses incorrect layout for MDInternalRW when marshaling to Target_MDInternalRW in a couple of places. Specifically for Target_RecordPool (aligned to 4 bytes on Linux rather than 8) and Target_MapSHash (don't need to skip a byte at the beginning of struct on Linux). The mismatch causes CordbModule::GetMetadataInterface to fail for dump debugging on Linux.</Description>
    <Title_Description>Mscordbi uses incorrect layout for MDInternalRW. Mscordbi uses incorrect layout for MDInternalRW when marshaling to Target_MDInternalRW in a couple of places. Specifically for Target_RecordPool (aligned to 4 bytes on Linux rather than 8) and Target_MapSHash (don't need to skip a byte at the beginning of struct on Linux). The mismatch causes CordbModule::GetMetadataInterface to fail for dump debugging on Linux.</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>mikem8361</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17691</IssueLabelID>
    <Title>Fix SSE2 SetZeroVector128 on float type</Title>
    <Description>fix https://github.com/dotnet/coreclr/issues/17689

@CarolEidt PTAL</Description>
    <Title_Description>Fix SSE2 SetZeroVector128 on float type fix https://github.com/dotnet/coreclr/issues/17689

@CarolEidt PTAL</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
    <CreatedAt>20/04/2018 12:42:24 AM +00:00</CreatedAt>
    <ClosedAt>6/08/2018 8:40:06 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17689</IssueLabelID>
    <Title>[RyuJIT] SSE2 SetZeroVector128 does not support float base type </Title>
    <Description>. </Description>
    <Title_Description>[RyuJIT] SSE2 SetZeroVector128 does not support float base type  . </Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>fiigii</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17687</IssueLabelID>
    <Title>Lower memory usage expected?</Title>
    <Description>On the reliability testing we are doing in the aspnet team I noticed a drop in memory usage around April 11-12. Is this something that could be explained by Server GC changes?

| OS | Before (MB) | After (MB) | Delta |
| -- | -- | -- | -- |
| Linux | 430 | 360 |  -27% |
| Windows | 345 | 245 | -29% |

This graph show the Windows consumption overtime. The application was the same the load constant. Only ASP.NET and the runtime were updated. (MVC + EF + Razor). CPU usage remained constant.

![image](https://user-images.githubusercontent.com/1165805/39024187-0436c0d8-43f4-11e8-82ff-6d30b7e07985.png)

If this is not expected I might be able to run the app with the version that were used and get some dumps/traces. It can also be related to changes in other repos but I am trying here first.</Description>
    <Title_Description>Lower memory usage, expected? On the reliability testing we are doing in the aspnet team I noticed a drop in memory usage around April 11-12. Is this something that could be explained by Server GC changes?

| OS | Before (MB) | After (MB) | Delta |
| -- | -- | -- | -- |
| Linux | 430 | 360 |  -27% |
| Windows | 345 | 245 | -29% |

This graph show the Windows consumption overtime. The application was the same the load constant. Only ASP.NET and the runtime were updated. (MVC + EF + Razor). CPU usage remained constant.

![image](https://user-images.githubusercontent.com/1165805/39024187-0436c0d8-43f4-11e8-82ff-6d30b7e07985.png)

If this is not expected I might be able to run the app with the version that were used and get some dumps/traces. It can also be related to changes in other repos but I am trying here first.</Title_Description>
    <Label>area-GC</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>20/04/2018 12:17:20 AM +00:00</CreatedAt>
    <ClosedAt>20/04/2018 7:14:37 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17684</IssueLabelID>
    <Title>Updating coreclr toolset</Title>
    <Description>For non-Windows builds we generally build with clang 3.9 though for arm32 we build with clang 5.0 and at least in the CI arm64 builds with clang 3.8.

Should these all be updated to something consistent and newer e.g. clang 6.0?

What is the process for making this decision and making it happen?

@RussKeldorph @janvorli @jkotas </Description>
    <Title_Description>Updating coreclr toolset For non-Windows builds we generally build with clang 3.9 though for arm32 we build with clang 5.0 and at least in the CI arm64 builds with clang 3.8.

Should these all be updated to something consistent and newer e.g. clang 6.0?

What is the process for making this decision and making it happen?

@RussKeldorph @janvorli @jkotas </Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>19/04/2018 10:33:12 PM +00:00</CreatedAt>
    <ClosedAt>11/11/2019 5:57:44 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17682</IssueLabelID>
    <Title>Make intra-build containers private</Title>
    <Description>
    </Description>
    <Title_Description>Make intra-build containers private </Title_Description>
    <Label>
    </Label>
    <Assignee>weshaggard</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17680</IssueLabelID>
    <Title>Fix GC tests that contain GC.Collect() used in wrong scope</Title>
    <Description>This same fix has been made in #17656 and #17594. I went through all the GC tests and fixed places where we observe a similar issue. Note that most of these tests don't necessarily depend on this fix since the JIT won't inline methods / extend lifetime of temps for most of these tests but wanted to fix these before we see more test failures coming from the various scenarios these tests will be running against. </Description>
    <Title_Description>Fix GC tests that contain GC.Collect() used in wrong scope This same fix has been made in #17656 and #17594. I went through all the GC tests and fixed places where we observe a similar issue. Note that most of these tests don't necessarily depend on this fix since the JIT won't inline methods / extend lifetime of temps for most of these tests but wanted to fix these before we see more test failures coming from the various scenarios these tests will be running against. </Title_Description>
    <Label>
    </Label>
    <Assignee>sywhang</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17679</IssueLabelID>
    <Title>Fatal error reporting deadlocks with GC</Title>
    <Description>Found while investigating https://github.com/aspnet/KestrelHttpServer/issues/2503

From Maoni:

This is an age old problem…managed heap corruption causes exception triggered on the GC thread which then needs to wait for GC so deadlock…looping in Noah. He did some work to accommodate I believe.

</Description>
    <Title_Description>Fatal error reporting deadlocks with GC Found while investigating https://github.com/aspnet/KestrelHttpServer/issues/2503

From Maoni:

This is an age old problem…managed heap corruption causes exception triggered on the GC thread which then needs to wait for GC so deadlock…looping in Noah. He did some work to accommodate I believe.

</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>sywhang</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17678</IssueLabelID>
    <Title>WIP Test all jitting at tier 1</Title>
    <Description>
    </Description>
    <Title_Description>WIP Test all jitting at tier 1 </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17677</IssueLabelID>
    <Title>Fix nested spin locks in thread pool etw firing</Title>
    <Description>

Nesting spin locks is not allowed moved the ETW firing outside the lock.</Description>
    <Title_Description>Fix nested spin locks in thread pool etw firing 

Nesting spin locks is not allowed moved the ETW firing outside the lock.</Title_Description>
    <Label>area-System.Threading</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17676</IssueLabelID>
    <Title>[arm] Warnings with crossgen generating S.P.C.dll</Title>
    <Description>The following warnings are seen in the build:

</Description>
    <Title_Description>[arm] Warnings with crossgen generating S.P.C.dll The following warnings are seen in the build:

</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>19/04/2018 6:20:29 PM +00:00</CreatedAt>
    <ClosedAt>19/04/2018 10:35:23 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17674</IssueLabelID>
    <Title>LSRA: Don't change register assignments for def/use conflicts</Title>
    <Description>Currently  that remains live (e.g. a lclVar) it will be unnecessarily killed. 

category:correctness
theme:register-allocator
skill-level:expert
cost:small</Description>
    <Title_Description>LSRA: Don't change register assignments for def/use conflicts Currently  that remains live (e.g. a lclVar) it will be unnecessarily killed. 

category:correctness
theme:register-allocator
skill-level:expert
cost:small</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>19/04/2018 5:20:13 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17673</IssueLabelID>
    <Title>Treat EDI as killed by MaskMove</Title>
    <Description>It should really only be a fixed reference not a kill but if the reference is changed by  it can fail to cause the value in EDI to be killed.</Description>
    <Title_Description>Treat EDI as killed by MaskMove It should really only be a fixed reference not a kill but if the reference is changed by  it can fail to cause the value in EDI to be killed.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>dotnet-bot</Assignee>
    <CreatedAt>19/04/2018 5:15:05 PM +00:00</CreatedAt>
    <ClosedAt>21/04/2018 4:10:18 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17670</IssueLabelID>
    <Title>Undoing boxing doesn't work with C# 7 pattern matching</Title>
    <Description>Short version: I was reading @stephentoub's article [*Performance Improvements in .NET Core 2.1*](https://blogs.msdn.microsoft.com/dotnet/2018/04/18/performance-improvements-in-net-core-2-1/). I noticed that his example for avoiding boxing allocations thanks to https://github.com/dotnet/coreclr/pull/14698 uses .

The two versions of the code do the same thing so I think they should have comparable performance. Especially since the pattern matching version is more readable and I suspect it's also going to be more common in new code than the other version.

How hard would it be to make this optimization work even in the pattern matching version?

If it would be too hard to perform this optimization in the JIT is there a reasonable way for the C# compiler to emit IL that would be optmized?

cc (?): @AndyAyersMS @benaadams @justinvp

category:cq
theme:importer
skill-level:expert
cost:medium</Description>
    <Title_Description>Undoing boxing doesn't work with C# 7 pattern matching Short version: I was reading @stephentoub's article [*Performance Improvements in .NET Core 2.1*](https://blogs.msdn.microsoft.com/dotnet/2018/04/18/performance-improvements-in-net-core-2-1/). I noticed that his example for avoiding boxing allocations thanks to https://github.com/dotnet/coreclr/pull/14698 uses .

The two versions of the code do the same thing so I think they should have comparable performance. Especially since the pattern matching version is more readable and I suspect it's also going to be more common in new code than the other version.

How hard would it be to make this optimization work even in the pattern matching version?

If it would be too hard to perform this optimization in the JIT is there a reasonable way for the C# compiler to emit IL that would be optmized?

cc (?): @AndyAyersMS @benaadams @justinvp

category:cq
theme:importer
skill-level:expert
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>stephentoub</Assignee>
    <CreatedAt>19/04/2018 3:44:24 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17669</IssueLabelID>
    <Title>There is something fishy going on with CLRVectoredExceptionHandler/DontCallDirectlyForceStackOverflow</Title>
    <Description>At the ISV I work for we have been getting some strange crashes from our C++ application recently with the following "signature": our process crashed because of a (recursive) stack overflow but the actual exception was an access violation and not a stack overflow.

This suggests that the guard area on the stack was committed and that extra stack space provided by the guard area also ran out. I confirmed this by looking at some minidumps with the  again
- this causes an unrecoverable access violation

I have the following questions:

1. What are you trying to achieve with committing the guard area?
Are you trying to make more space for handling the exception? What kind of handling? This might be a bit stubborn on my side but I'd think that if you reach the point on the stack when the guard area "can't slide upwards anymore" that's a stack overflow by definition and you shouldn't be doing anything other than maybe reporting and tearing down the process.
2. Do you know of any scenario where you commit the guard area but swallow/survive the exception?
I'm looking for an explanation of our "original" scenario where the stack overflow manifests in an access violation with no apparent sight of a 3rd party module/component (such as clr.dll).
3. Are there any guidelines/recommendations on living together with a mixed DLL in the same process?

I don't know if this is relevant but on all of our threads we set the stack guarantee to 5 pages (20'480).

If you'd like to have a closer look at this I can provide you with minidumps (on some private channel).

Thanks!</Description>
    <Title_Description>There is something fishy going on with CLRVectoredExceptionHandler/DontCallDirectlyForceStackOverflow At the ISV I work for we have been getting some strange crashes from our C++ application recently with the following "signature": our process crashed because of a (recursive) stack overflow but the actual exception was an access violation and not a stack overflow.

This suggests that the guard area on the stack was committed and that extra stack space provided by the guard area also ran out. I confirmed this by looking at some minidumps with the  again
- this causes an unrecoverable access violation

I have the following questions:

1. What are you trying to achieve with committing the guard area?
Are you trying to make more space for handling the exception? What kind of handling? This might be a bit stubborn on my side but I'd think that if you reach the point on the stack when the guard area "can't slide upwards anymore" that's a stack overflow by definition and you shouldn't be doing anything other than maybe reporting and tearing down the process.
2. Do you know of any scenario where you commit the guard area but swallow/survive the exception?
I'm looking for an explanation of our "original" scenario where the stack overflow manifests in an access violation with no apparent sight of a 3rd party module/component (such as clr.dll).
3. Are there any guidelines/recommendations on living together with a mixed DLL in the same process?

I don't know if this is relevant but on all of our threads we set the stack guarantee to 5 pages (20'480).

If you'd like to have a closer look at this I can provide you with minidumps (on some private channel).

Thanks!</Title_Description>
    <Label>area-ExceptionHandling</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>19/04/2018 3:03:22 PM +00:00</CreatedAt>
    <ClosedAt>9/05/2018 9:32:17 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17666</IssueLabelID>
    <Title>Azure Sphere Support</Title>
    <Description>Understanding [Azure Sphere](https://azure.microsoft.com/en-us/blog/introducing-microsoft-azure-sphere-secure-and-power-the-intelligent-edge/) has not even been released yet I was wondering if .NET Core will be supported?</Description>
    <Title_Description>Azure Sphere Support Understanding [Azure Sphere](https://azure.microsoft.com/en-us/blog/introducing-microsoft-azure-sphere-secure-and-power-the-intelligent-edge/) has not even been released yet I was wondering if .NET Core will be supported?</Title_Description>
    <Label>area-Meta</Label>
    <Assignee>richlander</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17665</IssueLabelID>
    <Title>[Arm64] Use proper lowering for TYP_SIMD8/TYP_LONG type</Title>
    <Description>Not sure if this function call (FixupIfSIMDLocal) is needed for ARM64.
@CarolEidt @sdmaclea PTAL.

Removing the FixupIfSIMDLocal() in Rationalizer  fixes the SIMD assertion error seen with JITMinOpts=1 (Ref #17111 ) for type TYP_SIMD8 below.

Assert failure(PID 9366 [0x00002496] Thread: 9366 [0x2496]): Assertion failed '(consume &gt; 1) || (regType(store-&gt;gtOp1-&gt;TypeGet()) == regType(store-&gt;TypeGet()))' in 'Arm64intrisicsTest.Program:testBinOp(refrefref)' (IL size 408)
File: /home/debayan/coreclr/src/jit/lsrabuild.cpp Line: 1383

</Description>
    <Title_Description>[Arm64] Use proper lowering for TYP_SIMD8/TYP_LONG type Not sure if this function call (FixupIfSIMDLocal) is needed for ARM64.
@CarolEidt @sdmaclea PTAL.

Removing the FixupIfSIMDLocal() in Rationalizer  fixes the SIMD assertion error seen with JITMinOpts=1 (Ref #17111 ) for type TYP_SIMD8 below.

Assert failure(PID 9366 [0x00002496] Thread: 9366 [0x2496]): Assertion failed '(consume &gt; 1) || (regType(store-&gt;gtOp1-&gt;TypeGet()) == regType(store-&gt;TypeGet()))' in 'Arm64intrisicsTest.Program:testBinOp(refrefref)' (IL size 408)
File: /home/debayan/coreclr/src/jit/lsrabuild.cpp Line: 1383

</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>CarolEidt</Assignee>
    <CreatedAt>19/04/2018 10:49:21 AM +00:00</CreatedAt>
    <ClosedAt>29/07/2019 6:27:27 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17663</IssueLabelID>
    <Title>Remove debug/checked builds</Title>
    <Description>The debug/checked builds don't publish and aren't submitted for testing currently.  To reduce resource usage during the build do not build these pipelines for now.</Description>
    <Title_Description>Remove debug/checked builds The debug/checked builds don't publish and aren't submitted for testing currently.  To reduce resource usage during the build do not build these pipelines for now.</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>mmitche</Assignee>
    <CreatedAt>19/04/2018 3:30:19 AM +00:00</CreatedAt>
    <ClosedAt>19/04/2018 7:55:55 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17661</IssueLabelID>
    <Title>MediaType.GetHashCode() throws System.ExecutionEngineException</Title>
    <Description>_From @austindrenski on April 17 2018 20:49_



_Copied from original issue: aspnet/Mvc#7673_</Description>
    <Title_Description>MediaType.GetHashCode() throws System.ExecutionEngineException _From @austindrenski on April 17 2018 20:49_



_Copied from original issue: aspnet/Mvc#7673_</Title_Description>
    <Label>
    </Label>
    <Assignee>jkotas</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17657</IssueLabelID>
    <Title>Port to 2.1: Fix ephemeral limits checks in write barrier for ARM64</Title>
    <Description>The code was incorrectly using signed conditions which doesn't work for
server GC where the high ephemeral limit is 0xffffffffffffffff and so it
was checking if the address is less than -1 which is never the case. So
the card table was never updated.</Description>
    <Title_Description>Port to 2.1: Fix ephemeral limits checks in write barrier for ARM64 The code was incorrectly using signed conditions which doesn't work for
server GC where the high ephemeral limit is 0xffffffffffffffff and so it
was checking if the address is less than -1 which is never the case. So
the card table was never updated.</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>janvorli</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17656</IssueLabelID>
    <Title>Fix GC leakwheel scenario test</Title>
    <Description>Related to #16061 - JIT may extend the lifetime of the object causing some objects to not get added to finalizer queue. This should at least stabilize the CI part but I'm not sure why calling GC.Collect(2) and GC.WaitForPendingFinalizers() 3 times instead of 2 should do any change in behavior. Will look into that part and follow up with subsequent fixes if I find anything.</Description>
    <Title_Description>Fix GC leakwheel scenario test Related to #16061 - JIT may extend the lifetime of the object causing some objects to not get added to finalizer queue. This should at least stabilize the CI part but I'm not sure why calling GC.Collect(2) and GC.WaitForPendingFinalizers() 3 times instead of 2 should do any change in behavior. Will look into that part and follow up with subsequent fixes if I find anything.</Title_Description>
    <Label>
    </Label>
    <Assignee>sywhang</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17654</IssueLabelID>
    <Title>[Arm64/Linux] #16962 Broke arm64 crosscomponent build</Title>
    <Description>@CarolEidt 
cc/ @weshaggard </Description>
    <Title_Description>[Arm64/Linux] #16962 Broke arm64 crosscomponent build @CarolEidt 
cc/ @weshaggard </Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17653</IssueLabelID>
    <Title>GCStress: force fully interruptible GC info</Title>
    <Description>Does the JIT have a stress mode that forces fully interruptible GC info?

An interesting stress mode would be:
1. GCStress=4
2. ZapDisable=1
3. force fully interruptible GC info


category:correctness
theme:testing
skill-level:beginner
cost:small</Description>
    <Title_Description>GCStress: force fully interruptible GC info Does the JIT have a stress mode that forces fully interruptible GC info?

An interesting stress mode would be:
1. GCStress=4
2. ZapDisable=1
3. force fully interruptible GC info


category:correctness
theme:testing
skill-level:beginner
cost:small</Title_Description>
    <Label>GCStress</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>18/04/2018 7:49:47 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17651</IssueLabelID>
    <Title>GCStress: instrumented instructions only force a GC once</Title>
    <Description>One possible limitation of GCStress today is that each instruction is instrumented and stressed only once. After GC is run on an instrumented instruction that instrumented instruction is replaced by its original instruction so it never triggers a GC again. This means if a hole exists at an instruction but isn't triggered by the first run of the instruction we will miss it. This was potentially the case with the JIT creating illegal byrefs fixed by https://github.com/dotnet/coreclr/pull/17524.

Possibly introduce a (super slow) mode where we don't replace the instrumented instructions by their original instructions or not immediately. Or periodically re-instrument functions.</Description>
    <Title_Description>GCStress: instrumented instructions only force a GC once One possible limitation of GCStress today is that each instruction is instrumented and stressed only once. After GC is run on an instrumented instruction that instrumented instruction is replaced by its original instruction so it never triggers a GC again. This means if a hole exists at an instruction but isn't triggered by the first run of the instruction we will miss it. This was potentially the case with the JIT creating illegal byrefs fixed by https://github.com/dotnet/coreclr/pull/17524.

Possibly introduce a (super slow) mode where we don't replace the instrumented instructions by their original instructions or not immediately. Or periodically re-instrument functions.</Title_Description>
    <Label>GCStress</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>18/04/2018 7:48:19 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17650</IssueLabelID>
    <Title>[Arm64/Linux] Enable crosscomponent build in CI</Title>
    <Description>#16962 Broke arm64 crosscomponent build.  It would be better to catch these earlier during build.  This would also provide some JIT testing as the S.P.C.dll will be crossgened</Description>
    <Title_Description>[Arm64/Linux] Enable crosscomponent build in CI #16962 Broke arm64 crosscomponent build.  It would be better to catch these earlier during build.  This would also provide some JIT testing as the S.P.C.dll will be crossgened</Title_Description>
    <Label>
    </Label>
    <Assignee>sdmaclea</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17649</IssueLabelID>
    <Title>GCStress: ensure every object moves on a GC</Title>
    <Description>At least every object that is legal to move should move.

One problem with GCStress today is that when a GC occurs most of the time (in some measurement I've done) objects don't actually move. This means that bad GC info doesn't get noticed.
</Description>
    <Title_Description>GCStress: ensure every object moves on a GC At least every object that is legal to move should move.

One problem with GCStress today is that when a GC occurs most of the time (in some measurement I've done) objects don't actually move. This means that bad GC info doesn't get noticed.
</Title_Description>
    <Label>GCStress</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>18/04/2018 6:46:13 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17647</IssueLabelID>
    <Title>GcStress: need some way to verify that all expected methods get instrumented</Title>
    <Description>In the instrumenting GC stress modes we should introduce some mechanism to verify that all the methods we expect to get instrumented actually do end up getting instrumented. Otherwise we risk losing stress coverage.

Because un-instrumented methods won't provoke additional GCs the fact that they are not instrumented tends to be hard to observe.</Description>
    <Title_Description>GcStress: need some way to verify that all expected methods get instrumented In the instrumenting GC stress modes we should introduce some mechanism to verify that all the methods we expect to get instrumented actually do end up getting instrumented. Otherwise we risk losing stress coverage.

Because un-instrumented methods won't provoke additional GCs the fact that they are not instrumented tends to be hard to observe.</Title_Description>
    <Label>GCStress</Label>
    <Assignee>AndyAyersMS</Assignee>
    <CreatedAt>18/04/2018 6:34:17 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17646</IssueLabelID>
    <Title>GcStress: handle rejitting </Title>
    <Description>Rejitted code is currently not getting instrumented for GC stress.

Since the original code is still viable we can't simply clear/clobber the  field in the MethodDescriptor on a rejit -- instead we need a way of having a code version specific set of GcCover infos for a method.

Similar issues likely apply to profiler-initiated rejitting.

cc @noahfalk 

</Description>
    <Title_Description>GcStress: handle rejitting  Rejitted code is currently not getting instrumented for GC stress.

Since the original code is still viable we can't simply clear/clobber the  field in the MethodDescriptor on a rejit -- instead we need a way of having a code version specific set of GcCover infos for a method.

Similar issues likely apply to profiler-initiated rejitting.

cc @noahfalk 

</Title_Description>
    <Label>GCStress</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17645</IssueLabelID>
    <Title>GcStress: choose strategy for instrumenting prejitted code</Title>
    <Description>GcStress currently tries to instrument NGEN precompiled methods twice: once during  (with a twist for prejitted IL stubs).

R2R precompiled methods are never instrumented currently.

Seems like we should have only one strategy and it should apply to all cases of prejitted code.

Early instrumentation during module load is nice because it avoids race conditions that can plague on-demand instrumentation. But there is an upfront cost as potentially thousands of methods need to be instrumented but only a few of them will ever be executed.

Late instrumentation is more pay for play but must be done carefully so that no thread can see a partially instrumented method.</Description>
    <Title_Description>GcStress: choose strategy for instrumenting prejitted code GcStress currently tries to instrument NGEN precompiled methods twice: once during  (with a twist for prejitted IL stubs).

R2R precompiled methods are never instrumented currently.

Seems like we should have only one strategy and it should apply to all cases of prejitted code.

Early instrumentation during module load is nice because it avoids race conditions that can plague on-demand instrumentation. But there is an upfront cost as potentially thousands of methods need to be instrumented but only a few of them will ever be executed.

Late instrumentation is more pay for play but must be done carefully so that no thread can see a partially instrumented method.</Title_Description>
    <Label>GCStress</Label>
    <Assignee>AndyAyersMS</Assignee>
    <CreatedAt>18/04/2018 6:26:24 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17644</IssueLabelID>
    <Title>port #17618 to the 2.1 branch (Disable timeout test)</Title>
    <Description>disable DevDiv_255294 in stress modes. (PR to master #17618 issue #17605) 

It is a test only change.</Description>
    <Title_Description>port #17618 to the 2.1 branch (Disable timeout test) disable DevDiv_255294 in stress modes. (PR to master #17618 issue #17605) 

It is a test only change.</Title_Description>
    <Label>disabled-test</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>18/04/2018 6:26:06 PM +00:00</CreatedAt>
    <ClosedAt>21/04/2018 2:14:21 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17641</IssueLabelID>
    <Title>Fix ephemeral limits checks in write barrier for ARM64</Title>
    <Description>The code was incorrectly using signed conditions which doesn't work for
server GC where the high ephemeral limit is 0xffffffffffffffff and so it
was checking if the address is less than -1 which is never the case. So
the card table was never updated.

Close #17640</Description>
    <Title_Description>Fix ephemeral limits checks in write barrier for ARM64 The code was incorrectly using signed conditions which doesn't work for
server GC where the high ephemeral limit is 0xffffffffffffffff and so it
was checking if the address is less than -1 which is never the case. So
the card table was never updated.

Close #17640</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>janvorli</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17640</IssueLabelID>
    <Title>Wrong check of ephemeral limits in JIT_WriteBarrier for ARM64</Title>
    <Description>The code is incorrectly using signed comparison which doesn't work for
server GC where the high ephemeral limit is 0xffffffffffffffff and so it
is checking if the address is less than -1 which is never the case. So
the card table is never updated.</Description>
    <Title_Description>Wrong check of ephemeral limits in JIT_WriteBarrier for ARM64 The code is incorrectly using signed comparison which doesn't work for
server GC where the high ephemeral limit is 0xffffffffffffffff and so it
is checking if the address is less than -1 which is never the case. So
the card table is never updated.</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>janvorli</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17639</IssueLabelID>
    <Title>Enable Invoke and GetValue for ref-returning members</Title>
    <Description>https://github.com/dotnet/corefx/issues/15960

Returned magic object is the object pointed to by
the ref. If the ref is null NullReferenceException.</Description>
    <Title_Description>Enable Invoke and GetValue for ref-returning members https://github.com/dotnet/corefx/issues/15960

Returned magic object is the object pointed to by
the ref. If the ref is null NullReferenceException.</Title_Description>
    <Label>area-System.Reflection</Label>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17637</IssueLabelID>
    <Title>Improve Intel hardware intrinsic APIs</Title>
    <Description>This PR
1. fixes https://github.com/dotnet/coreclr/issues/17058 and temporarily disables AVX MaskLoad test cases.
2. &lt;del&gt;encodes the result flags in the names of certain SSE4.2 string processing intrinsic. That provides more stable runtime behaviors and simplifies JIT implementation discussed in https://github.com/dotnet/coreclr/issues/16270&lt;/del&gt;
3. Fixes SSE4.1  return type to reflect the underlying instruction behavior closes https://github.com/dotnet/coreclr/issues/17957

@CarolEidt @tannergooding @eerhardt </Description>
    <Title_Description>Improve Intel hardware intrinsic APIs This PR
1. fixes https://github.com/dotnet/coreclr/issues/17058 and temporarily disables AVX MaskLoad test cases.
2. &lt;del&gt;encodes the result flags in the names of certain SSE4.2 string processing intrinsic. That provides more stable runtime behaviors and simplifies JIT implementation discussed in https://github.com/dotnet/coreclr/issues/16270&lt;/del&gt;
3. Fixes SSE4.1  return type to reflect the underlying instruction behavior closes https://github.com/dotnet/coreclr/issues/17957

@CarolEidt @tannergooding @eerhardt </Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
    <CreatedAt>18/04/2018 9:17:11 AM +00:00</CreatedAt>
    <ClosedAt>18/06/2018 8:17:42 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17634</IssueLabelID>
    <Title>[x86/Windows] Failure in jitstress=2 jitstressregs=3 job</Title>
    <Description>https://ci.dot.net/job/dotnet_coreclr/job/master/view/x86/job/jitstress/job/x86_checked_windows_nt_jitstress2_jitstressregs3/473/consoleText

BEGIN EXECUTION
         "D:\j\workspace\x86_checked_w---508bfa85\tests\..\bin\tests\Windows_NT.x86.Checked\Tests\Core_Root\corerun.exe" MaskMove_r.exe 
        Expected: 100
        Actual: 73294136
        END EXECUTION - FAILED
        FAILED
        Test Harness Exitcode is : 1
        
  To run the test:
  &gt; set CORE_ROOT=D:\j\workspace\x86_checked_w---508bfa85\bin\tests\Windows_NT.x86.Checked\Tests\Core_Root
  &gt; D:\j\workspace\x86_checked_w---508bfa85\bin\tests\Windows_NT.x86.Checked\JIT\HardwareIntrinsics\X86\Sse2\MaskMove_r\MaskMove_r.cmd
  
        Expected: True
        Actual:   False</Description>
    <Title_Description>[x86/Windows] Failure in jitstress=2 jitstressregs=3 job https://ci.dot.net/job/dotnet_coreclr/job/master/view/x86/job/jitstress/job/x86_checked_windows_nt_jitstress2_jitstressregs3/473/consoleText

BEGIN EXECUTION
         "D:\j\workspace\x86_checked_w---508bfa85\tests\..\bin\tests\Windows_NT.x86.Checked\Tests\Core_Root\corerun.exe" MaskMove_r.exe 
        Expected: 100
        Actual: 73294136
        END EXECUTION - FAILED
        FAILED
        Test Harness Exitcode is : 1
        
  To run the test:
  &gt; set CORE_ROOT=D:\j\workspace\x86_checked_w---508bfa85\bin\tests\Windows_NT.x86.Checked\Tests\Core_Root
  &gt; D:\j\workspace\x86_checked_w---508bfa85\bin\tests\Windows_NT.x86.Checked\JIT\HardwareIntrinsics\X86\Sse2\MaskMove_r\MaskMove_r.cmd
  
        Expected: True
        Actual:   False</Title_Description>
    <Label>JitStress</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17632</IssueLabelID>
    <Title>[x64/Windows] waitone2 test failures</Title>
    <Description>https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64/job/jitstress/job/x64_checked_windows_nt_jitstress1/491/consoleText

BEGIN EXECUTION
         "D:\j\workspace\x64_checked_w---02832afb\tests\..\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root\corerun.exe" waitone2.exe 
        Beginning test case MutexWaitOne2 at 4/16/2018 7:33:49 PM
        Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
        
        [Positive]
        Beginning scenario: PosTest1: Wait Infinite
        Beginning scenario: PosTest2: Wait some finite time
        Beginning scenario: PosTest3: Wait some finite time will quit for timeout
        ERROR!!!-004: WaitOne returns true when wait time out
        Beginning scenario: PosTest4: Wait some finite time will quit for timeout when another thread is in nondefault managed context
        Beginning scenario: PosTest5: Wait some finite time will quit for timeout when another thread is in nondefault managed context
        Beginning scenario: PosTest6: Wait infinite time when another thread is in nondefault managed context
        Beginning scenario: PosTest7: Wait infinite time when another thread is in nondefault managed context
        [Negative]
        Beginning scenario: NegTest1: AbandonedMutexException should be thrown if a thread exited without releasing a mutex
        Beginning scenario: NegTest2: ObjectDisposedException should be thrown if current instance has already been disposed
        Beginning scenario: NegTest3: Check ArgumentOutOfRangeException will be thrown if millisecondsTimeout is a negative number other than -1
        
        Ending test case at 4/16/2018 7:34:22 PM
        FAIL
        Expected: 100
        Actual: 0
        END EXECUTION - FAILED
        FAILED
        Test Harness Exitcode is : 1
        
  To run the test:
  &gt; set CORE_ROOT=D:\j\workspace\x64_checked_w---02832afb\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root
  &gt; D:\j\workspace\x64_checked_w---02832afb\bin\tests\Windows_NT.x64.Checked\baseservices\threading\mutex\misc\waitone2\waitone2.cmd
  
        Expected: True
        Actual:   False</Description>
    <Title_Description>[x64/Windows] waitone2 test failures https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64/job/jitstress/job/x64_checked_windows_nt_jitstress1/491/consoleText

BEGIN EXECUTION
         "D:\j\workspace\x64_checked_w---02832afb\tests\..\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root\corerun.exe" waitone2.exe 
        Beginning test case MutexWaitOne2 at 4/16/2018 7:33:49 PM
        Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
        
        [Positive]
        Beginning scenario: PosTest1: Wait Infinite
        Beginning scenario: PosTest2: Wait some finite time
        Beginning scenario: PosTest3: Wait some finite time will quit for timeout
        ERROR!!!-004: WaitOne returns true when wait time out
        Beginning scenario: PosTest4: Wait some finite time will quit for timeout when another thread is in nondefault managed context
        Beginning scenario: PosTest5: Wait some finite time will quit for timeout when another thread is in nondefault managed context
        Beginning scenario: PosTest6: Wait infinite time when another thread is in nondefault managed context
        Beginning scenario: PosTest7: Wait infinite time when another thread is in nondefault managed context
        [Negative]
        Beginning scenario: NegTest1: AbandonedMutexException should be thrown if a thread exited without releasing a mutex
        Beginning scenario: NegTest2: ObjectDisposedException should be thrown if current instance has already been disposed
        Beginning scenario: NegTest3: Check ArgumentOutOfRangeException will be thrown if millisecondsTimeout is a negative number other than -1
        
        Ending test case at 4/16/2018 7:34:22 PM
        FAIL
        Expected: 100
        Actual: 0
        END EXECUTION - FAILED
        FAILED
        Test Harness Exitcode is : 1
        
  To run the test:
  &gt; set CORE_ROOT=D:\j\workspace\x64_checked_w---02832afb\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root
  &gt; D:\j\workspace\x64_checked_w---02832afb\bin\tests\Windows_NT.x64.Checked\baseservices\threading\mutex\misc\waitone2\waitone2.cmd
  
        Expected: True
        Actual:   False</Title_Description>
    <Label>area-System.Threading</Label>
    <Assignee>erozenfeld</Assignee>
    <CreatedAt>18/04/2018 12:06:46 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17631</IssueLabelID>
    <Title>[x64/Windows] Failure in heapverify=1 job</Title>
    <Description>https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64/job/jitstress/job/x64_checked_windows_nt_heapverify1/73/consoleText

BEGIN EXECUTION
         "D:\j\workspace\x64_checked_w---facfb6a0\tests\..\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root\corerun.exe" unregister03.exe 
        Test Failed
        Expected: 100
        Actual: 0
        END EXECUTION - FAILED
        FAILED
        Test Harness Exitcode is : 1
        
  To run the test:
  &gt; set CORE_ROOT=D:\j\workspace\x64_checked_w---facfb6a0\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root
  &gt; D:\j\workspace\x64_checked_w---facfb6a0\bin\tests\Windows_NT.x64.Checked\baseservices\threading\threadpool\unregister\unregister03\unregister03.cmd
  
        Expected: True
        Actual:   False
</Description>
    <Title_Description>[x64/Windows] Failure in heapverify=1 job https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64/job/jitstress/job/x64_checked_windows_nt_heapverify1/73/consoleText

BEGIN EXECUTION
         "D:\j\workspace\x64_checked_w---facfb6a0\tests\..\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root\corerun.exe" unregister03.exe 
        Test Failed
        Expected: 100
        Actual: 0
        END EXECUTION - FAILED
        FAILED
        Test Harness Exitcode is : 1
        
  To run the test:
  &gt; set CORE_ROOT=D:\j\workspace\x64_checked_w---facfb6a0\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root
  &gt; D:\j\workspace\x64_checked_w---facfb6a0\bin\tests\Windows_NT.x64.Checked\baseservices\threading\threadpool\unregister\unregister03\unregister03.cmd
  
        Expected: True
        Actual:   False
</Title_Description>
    <Label>arch-x64</Label>
    <Assignee>briansull</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17630</IssueLabelID>
    <Title>Feature Request: During a profiler walk of the GC heap reference graph distinguish references that aren't backed by metadata fields</Title>
    <Description>This is a request from https://github.com/dotnet/coreclr/issues/16274#issuecomment-381434436

&gt; Well could you please add the markers for virtual references in ICorProfilerCallback? I need to know that the reference to LoaderAllocator is virtual. I have the list of classes where the reference to LoaderAllocator isn't virtual. How can I understand after CLR/CoreCLR update that I have to add the new type in the list?


FWIW I don't think that the information needs to be directly provided as an argument of the ICorProfilerCallback::ObjectReferences API (or a numbered extension of the API) but there would need to be some not too complicated and reasonably performant mechanism for a profiler to learn the information. This is part of a broader ask that the profiler wants to understand not just what references an object has but specifically how those references correlate to its fields nested fields array elements etc. Right now profilers are using heuristics because the APIs to access types and type layouts have difficulties in some cases. The implicit references created by collectible assemblies add an additional layer of complexity.</Description>
    <Title_Description>Feature Request: During a profiler walk of the GC heap reference graph, distinguish references that aren't backed by metadata fields This is a request from https://github.com/dotnet/coreclr/issues/16274#issuecomment-381434436

&gt; Well could you please add the markers for virtual references in ICorProfilerCallback? I need to know that the reference to LoaderAllocator is virtual. I have the list of classes where the reference to LoaderAllocator isn't virtual. How can I understand after CLR/CoreCLR update that I have to add the new type in the list?


FWIW I don't think that the information needs to be directly provided as an argument of the ICorProfilerCallback::ObjectReferences API (or a numbered extension of the API) but there would need to be some not too complicated and reasonably performant mechanism for a profiler to learn the information. This is part of a broader ask that the profiler wants to understand not just what references an object has but specifically how those references correlate to its fields nested fields array elements etc. Right now profilers are using heuristics because the APIs to access types and type layouts have difficulties in some cases. The implicit references created by collectible assemblies add an additional layer of complexity.</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>18/04/2018 12:00:32 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17629</IssueLabelID>
    <Title> [x64/Ubuntu] Failures in tailcallstress job</Title>
    <Description>https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64/job/jitstress/job/x64_checked_ubuntu_tailcallstress_tst/323/consoleText

FAILED   - tracing/tracevalidation/tracelogging/tracelogging/tracelogging.sh
               BEGIN EXECUTION
               /mnt/j/workspace/dotnet_coreclr/master/jitstress/x64_checked_ubuntu_tailcallstress_tst/bin/tests/Linux.x64.Checked/Tests/Core_Root/corerun tracelogging.exe
               
               Unhandled Exception: System.TypeLoadException: Could not find type Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses+ILToNativeMap
                  at FastSerialization.Deserializer.GetFactory(String fullName)
                  at FastSerialization.SerializationType.FastSerialization.IFastSerializable.FromStream(Deserializer deserializer)
                  at FastSerialization.Deserializer.ReadObjectDefinition(Tags tag StreamLabel objectLabel)
                  at FastSerialization.Deserializer.ReadObject()
                  at FastSerialization.Deserializer.ReadObjectDefinition(Tags tag StreamLabel objectLabel)
                  at FastSerialization.Deserializer.ReadObject()
                  at Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.&lt;&gt;c__DisplayClass42_0.&lt;FastSerialization.IFastSerializable.FromStream&gt;b__0()
                  at FastSerialization.DeferedRegion.FinishReadHelper(Boolean preserveStreamPosition)
                  at FastSerialization.Deserializer.ReadObjectDefinition(Tags tag StreamLabel objectLabel)
                  at FastSerialization.Deserializer.ReadObject()
                  at Microsoft.Diagnostics.Tracing.Etlx.TraceLog.FastSerialization.IFastSerializable.FromStream(Deserializer deserializer)
                  at FastSerialization.Deserializer.ReadObjectDefinition(Tags tag StreamLabel objectLabel)
                  at FastSerialization.Deserializer.GetEntryObject()
                  at Microsoft.Diagnostics.Tracing.Etlx.TraceLog.InitializeFromFile(String etlxFilePath)
                  at Tracing.Tests.Common.EventSourceTestSuite.RunTests()
                  at Tracing.Tests.TraceLogging.Main(String[] args)
               ./tracelogging.sh: line 244: 64297 Aborted                 (core dumped) $_DebuggerFullPath "$CORE_ROOT/corerun" $ExePath $CLRTestExecutionArguments
               Expected: 100
               Actual: 134
               END EXECUTION - FAILED

FAILED   - tracing/eventsourcetrace/eventsourcetrace/eventsourcetrace.sh
               BEGIN EXECUTION
               /mnt/j/workspace/dotnet_coreclr/master/jitstress/x64_checked_ubuntu_tailcallstress_tst/bin/tests/Linux.x64.Checked/Tests/Core_Root/corerun eventsourcetrace.exe
               	Start: Enable tracing.
               	End: Enable tracing.
               
               	Start: Messaging.
               	End: Messaging.
               
               	Start: Disable tracing.
               	End: Disable tracing.
               
               	Start: Processing events from file.
               
               Unhandled Exception: System.TypeLoadException: Could not find type Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses+ILToNativeMap
                  at FastSerialization.Deserializer.GetFactory(String fullName)
                  at FastSerialization.SerializationType.FastSerialization.IFastSerializable.FromStream(Deserializer deserializer)
                  at FastSerialization.Deserializer.ReadObjectDefinition(Tags tag StreamLabel objectLabel)
                  at FastSerialization.Deserializer.ReadObject()
                  at FastSerialization.Deserializer.ReadObjectDefinition(Tags tag StreamLabel objectLabel)
                  at FastSerialization.Deserializer.ReadObject()
                  at Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.&lt;&gt;c__DisplayClass42_0.&lt;FastSerialization.IFastSerializable.FromStream&gt;b__0()
                  at FastSerialization.DeferedRegion.FinishReadHelper(Boolean preserveStreamPosition)
                  at FastSerialization.Deserializer.ReadObjectDefinition(Tags tag StreamLabel objectLabel)
                  at FastSerialization.Deserializer.ReadObject()
                  at Microsoft.Diagnostics.Tracing.Etlx.TraceLog.FastSerialization.IFastSerializable.FromStream(Deserializer deserializer)
                  at FastSerialization.Deserializer.ReadObjectDefinition(Tags tag StreamLabel objectLabel)
                  at FastSerialization.Deserializer.GetEntryObject()
                  at Microsoft.Diagnostics.Tracing.Etlx.TraceLog.InitializeFromFile(String etlxFilePath)
                  at Tracing.Tests.EventSourceTrace.Main(String[] args)
               ./eventsourcetrace.sh: line 244: 64063 Aborted                 (core dumped) $_DebuggerFullPath "$CORE_ROOT/corerun" $ExePath $CLRTestExecutionArguments
               Expected: 100
               Actual: 134
               END EXECUTION - FAILED</Description>
    <Title_Description> [x64/Ubuntu] Failures in tailcallstress job https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64/job/jitstress/job/x64_checked_ubuntu_tailcallstress_tst/323/consoleText

FAILED   - tracing/tracevalidation/tracelogging/tracelogging/tracelogging.sh
               BEGIN EXECUTION
               /mnt/j/workspace/dotnet_coreclr/master/jitstress/x64_checked_ubuntu_tailcallstress_tst/bin/tests/Linux.x64.Checked/Tests/Core_Root/corerun tracelogging.exe
               
               Unhandled Exception: System.TypeLoadException: Could not find type Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses+ILToNativeMap
                  at FastSerialization.Deserializer.GetFactory(String fullName)
                  at FastSerialization.SerializationType.FastSerialization.IFastSerializable.FromStream(Deserializer deserializer)
                  at FastSerialization.Deserializer.ReadObjectDefinition(Tags tag StreamLabel objectLabel)
                  at FastSerialization.Deserializer.ReadObject()
                  at FastSerialization.Deserializer.ReadObjectDefinition(Tags tag StreamLabel objectLabel)
                  at FastSerialization.Deserializer.ReadObject()
                  at Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.&lt;&gt;c__DisplayClass42_0.&lt;FastSerialization.IFastSerializable.FromStream&gt;b__0()
                  at FastSerialization.DeferedRegion.FinishReadHelper(Boolean preserveStreamPosition)
                  at FastSerialization.Deserializer.ReadObjectDefinition(Tags tag StreamLabel objectLabel)
                  at FastSerialization.Deserializer.ReadObject()
                  at Microsoft.Diagnostics.Tracing.Etlx.TraceLog.FastSerialization.IFastSerializable.FromStream(Deserializer deserializer)
                  at FastSerialization.Deserializer.ReadObjectDefinition(Tags tag StreamLabel objectLabel)
                  at FastSerialization.Deserializer.GetEntryObject()
                  at Microsoft.Diagnostics.Tracing.Etlx.TraceLog.InitializeFromFile(String etlxFilePath)
                  at Tracing.Tests.Common.EventSourceTestSuite.RunTests()
                  at Tracing.Tests.TraceLogging.Main(String[] args)
               ./tracelogging.sh: line 244: 64297 Aborted                 (core dumped) $_DebuggerFullPath "$CORE_ROOT/corerun" $ExePath $CLRTestExecutionArguments
               Expected: 100
               Actual: 134
               END EXECUTION - FAILED

FAILED   - tracing/eventsourcetrace/eventsourcetrace/eventsourcetrace.sh
               BEGIN EXECUTION
               /mnt/j/workspace/dotnet_coreclr/master/jitstress/x64_checked_ubuntu_tailcallstress_tst/bin/tests/Linux.x64.Checked/Tests/Core_Root/corerun eventsourcetrace.exe
               	Start: Enable tracing.
               	End: Enable tracing.
               
               	Start: Messaging.
               	End: Messaging.
               
               	Start: Disable tracing.
               	End: Disable tracing.
               
               	Start: Processing events from file.
               
               Unhandled Exception: System.TypeLoadException: Could not find type Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses+ILToNativeMap
                  at FastSerialization.Deserializer.GetFactory(String fullName)
                  at FastSerialization.SerializationType.FastSerialization.IFastSerializable.FromStream(Deserializer deserializer)
                  at FastSerialization.Deserializer.ReadObjectDefinition(Tags tag StreamLabel objectLabel)
                  at FastSerialization.Deserializer.ReadObject()
                  at FastSerialization.Deserializer.ReadObjectDefinition(Tags tag StreamLabel objectLabel)
                  at FastSerialization.Deserializer.ReadObject()
                  at Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.&lt;&gt;c__DisplayClass42_0.&lt;FastSerialization.IFastSerializable.FromStream&gt;b__0()
                  at FastSerialization.DeferedRegion.FinishReadHelper(Boolean preserveStreamPosition)
                  at FastSerialization.Deserializer.ReadObjectDefinition(Tags tag StreamLabel objectLabel)
                  at FastSerialization.Deserializer.ReadObject()
                  at Microsoft.Diagnostics.Tracing.Etlx.TraceLog.FastSerialization.IFastSerializable.FromStream(Deserializer deserializer)
                  at FastSerialization.Deserializer.ReadObjectDefinition(Tags tag StreamLabel objectLabel)
                  at FastSerialization.Deserializer.GetEntryObject()
                  at Microsoft.Diagnostics.Tracing.Etlx.TraceLog.InitializeFromFile(String etlxFilePath)
                  at Tracing.Tests.EventSourceTrace.Main(String[] args)
               ./eventsourcetrace.sh: line 244: 64063 Aborted                 (core dumped) $_DebuggerFullPath "$CORE_ROOT/corerun" $ExePath $CLRTestExecutionArguments
               Expected: 100
               Actual: 134
               END EXECUTION - FAILED</Title_Description>
    <Label>arch-x64</Label>
    <Assignee>erozenfeld</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17628</IssueLabelID>
    <Title>[x64/Ubuntu] Failure in JitStress=2 JitStressRegs=4 job</Title>
    <Description>https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64/job/jitstress/job/x64_checked_ubuntu_jitstress2_jitstressregs4_tst/438/consoleText

FAILED   - baseservices/threading/waithandle/waitany/waitanyex5a/waitanyex5a.sh
               BEGIN EXECUTION
               /mnt/j/workspace/dotnet_coreclr/master/jitstress/x64_checked_ubuntu_jitstress2_jitstressregs4_tst/bin/tests/Linux.x64.Checked/Tests/Core_Root/corerun waitanyex5a.exe
               Abandoning only one Mutex in array with other WaitHandles signaling other mutexes
               Waiting...
               WaitAny did not throw AbandonedMutexExcpetion
               Test Failed
               Expected: 100
               Actual: 255
               END EXECUTION - FAILED</Description>
    <Title_Description>[x64/Ubuntu] Failure in JitStress=2 JitStressRegs=4 job https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64/job/jitstress/job/x64_checked_ubuntu_jitstress2_jitstressregs4_tst/438/consoleText

FAILED   - baseservices/threading/waithandle/waitany/waitanyex5a/waitanyex5a.sh
               BEGIN EXECUTION
               /mnt/j/workspace/dotnet_coreclr/master/jitstress/x64_checked_ubuntu_jitstress2_jitstressregs4_tst/bin/tests/Linux.x64.Checked/Tests/Core_Root/corerun waitanyex5a.exe
               Abandoning only one Mutex in array with other WaitHandles signaling other mutexes
               Waiting...
               WaitAny did not throw AbandonedMutexExcpetion
               Test Failed
               Expected: 100
               Actual: 255
               END EXECUTION - FAILED</Title_Description>
    <Label>JitStress</Label>
    <Assignee>erozenfeld</Assignee>
    <CreatedAt>17/04/2018 11:44:47 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17627</IssueLabelID>
    <Title>increase timeout for debug jobs</Title>
    <Description>Allow to get results from arm32 debug ubuntu build.

[arm_cross_debug_ubuntu_tst_prtest](https://ci.dot.net/job/dotnet_coreclr/job/master/job/arm_cross_debug_ubuntu_tst_prtest/) fails with timeout it is not a single test that hangs because it can be aborted during different tests.

Our current timeout is 420 minutes and it allows to run ~10000 tests so we need to be able to finish another 1000 test to make this green. 2 hours should be enough.</Description>
    <Title_Description>increase timeout for debug jobs Allow to get results from arm32 debug ubuntu build.

[arm_cross_debug_ubuntu_tst_prtest](https://ci.dot.net/job/dotnet_coreclr/job/master/job/arm_cross_debug_ubuntu_tst_prtest/) fails with timeout it is not a single test that hangs because it can be aborted during different tests.

Our current timeout is 420 minutes and it allows to run ~10000 tests so we need to be able to finish another 1000 test to make this green. 2 hours should be enough.</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>17/04/2018 11:27:48 PM +00:00</CreatedAt>
    <ClosedAt>18/04/2018 5:58:18 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17626</IssueLabelID>
    <Title>Cannot get light-up technique of assembly load to work with .NET Core 2.0</Title>
    <Description>First of all please let me know if this type of issue should be addressed in another repo. I did see some mention of this light-up technique here so that's why I chose this repo.

I recently learned about the light-up technique that Application Insights uses to get their assemblies loaded into any ASP.NET app. [Here](https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/platform-specific-configuration?view=aspnetcore-2.1) is a link to it.

I've implemented an IHostingStartup class in an assembly.  I'm using a target of 

The Main() entrypoint is to make the compiler happy -- apparently I cannot use that interface without having a Main entrypoint? All I do for my configuration is simply use a logger class to tell me if it gets loaded.

I could use some additional tips on troubleshooting this or if you think there's a bug. Thanks Bob
</Description>
    <Title_Description>Cannot get light-up technique of assembly load to work with .NET Core 2.0 First of all please let me know if this type of issue should be addressed in another repo. I did see some mention of this light-up technique here so that's why I chose this repo.

I recently learned about the light-up technique that Application Insights uses to get their assemblies loaded into any ASP.NET app. [Here](https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/platform-specific-configuration?view=aspnetcore-2.1) is a link to it.

I've implemented an IHostingStartup class in an assembly.  I'm using a target of 

The Main() entrypoint is to make the compiler happy -- apparently I cannot use that interface without having a Main entrypoint? All I do for my configuration is simply use a logger class to tell me if it gets loaded.

I could use some additional tips on troubleshooting this or if you think there's a bug. Thanks Bob
</Title_Description>
    <Label>question</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>17/04/2018 11:26:59 PM +00:00</CreatedAt>
    <ClosedAt>18/04/2018 3:32:43 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17625</IssueLabelID>
    <Title>[TEST] Test GC/HeapExpansion/bestfit test on ARM64</Title>
    <Description>This is just a test of whether the bestfit tests works on arm64 or not</Description>
    <Title_Description>[TEST] Test GC/HeapExpansion/bestfit test on ARM64 This is just a test of whether the bestfit tests works on arm64 or not</Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>janvorli</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17622</IssueLabelID>
    <Title>WIP Test tier 1 in CI</Title>
    <Description>
    </Description>
    <Title_Description>WIP Test tier 1 in CI </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17619</IssueLabelID>
    <Title>1.1.8 long-name DAC/SOS has incorrect version (001 expected 01)</Title>
    <Description>I ran some basic symbol validation on the recent 1.1.8 release and found that the long-name DAC/SOS has incorrect versions:

 * ..._4.6.26328.**001**.dll
 * ..._4.6.26328.**01**.dll (expected)

This was fixed in ?
Should the 1.1.8 build in particular be manually fixed by renaming the dll and republishing symbols?

/cc @lt72 @mikem8361 @leculver @weshaggard </Description>
    <Title_Description>1.1.8 long-name DAC/SOS has incorrect version (001, expected 01) I ran some basic symbol validation on the recent 1.1.8 release and found that the long-name DAC/SOS has incorrect versions:

 * ..._4.6.26328.**001**.dll
 * ..._4.6.26328.**01**.dll (expected)

This was fixed in ?
Should the 1.1.8 build in particular be manually fixed by renaming the dll and republishing symbols?

/cc @lt72 @mikem8361 @leculver @weshaggard </Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>mikem8361</Assignee>
    <CreatedAt>17/04/2018 9:14:30 PM +00:00</CreatedAt>
    <ClosedAt>22/03/2019 11:39:58 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17618</IssueLabelID>
    <Title>disable DevDiv_255294 in stress modes.</Title>
    <Description>Closes #17605.

cc @dotnet/jit-contrib </Description>
    <Title_Description>disable DevDiv_255294 in stress modes. Closes #17605.

cc @dotnet/jit-contrib </Title_Description>
    <Label>disabled-test</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>17/04/2018 9:14:25 PM +00:00</CreatedAt>
    <ClosedAt>18/04/2018 7:24:00 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17614</IssueLabelID>
    <Title>fix build.cmd generateLayout</Title>
    <Description>output before:


PTAL @tannergooding @jashook.
cc @dotnet/jit-contrib 

@tannergooding Is it a typo? Did it work in #15673?</Description>
    <Title_Description>fix build.cmd generateLayout output before:


PTAL @tannergooding @jashook.
cc @dotnet/jit-contrib 

@tannergooding Is it a typo? Did it work in #15673?</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>tannergooding</Assignee>
    <CreatedAt>17/04/2018 6:23:12 PM +00:00</CreatedAt>
    <ClosedAt>18/04/2018 6:25:58 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17613</IssueLabelID>
    <Title>Port #17594 to the 2.1 branch (Fix GC tests)</Title>
    <Description>Port #17594 to the release branch. 
Fixes #17588.</Description>
    <Title_Description>Port #17594 to the 2.1 branch (Fix GC tests) Port #17594 to the release branch. 
Fixes #17588.</Title_Description>
    <Label>test bug</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>17/04/2018 5:49:37 PM +00:00</CreatedAt>
    <ClosedAt>18/04/2018 6:25:44 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17612</IssueLabelID>
    <Title>About 10% performance regression for Perf_BigInteger tests</Title>
    <Description>Ctor_ByteArray
![capture04](https://user-images.githubusercontent.com/5897654/38886242-355e249c-422a-11e8-87a5-c2af03d8c409.PNG)

Ctor_ByteSpan
![capture05](https://user-images.githubusercontent.com/5897654/38886356-92c6bb58-422a-11e8-9819-39a0eb4424d5.PNG)

ToByteArray
![capture06](https://user-images.githubusercontent.com/5897654/38886484-efe301e8-422a-11e8-8db6-b2a38acb5bd1.PNG)

TryWriteBytes
![capture07](https://user-images.githubusercontent.com/5897654/38886552-23aa80be-422b-11e8-90fe-4a9b2dd512d7.PNG)

[Updated]:
For all of the above the corefx diff below is causing the regression increase: 
dotnet/corefx@7ec7367

Check [benchview ](https://benchview/trendline?build_selector=latest&amp;count=2000&amp;aggregate=arithmeticMean&amp;filterTail=one&amp;filterVal=100&amp;interval=INTERVAL_MIN_MAX&amp;rtids=[957]&amp;archids=[23]&amp;mpids=[1292]&amp;cfgids=[2706]&amp;testids=[642966429564297643056430464306642996429864300643086430764309]&amp;jobgroup=CoreFX&amp;jobtype=rolling&amp;branchId=42&amp;) for more detail.

cc: @kouvel @danmosemsft </Description>
    <Title_Description>About 10% performance regression for Perf_BigInteger tests Ctor_ByteArray
![capture04](https://user-images.githubusercontent.com/5897654/38886242-355e249c-422a-11e8-87a5-c2af03d8c409.PNG)

Ctor_ByteSpan
![capture05](https://user-images.githubusercontent.com/5897654/38886356-92c6bb58-422a-11e8-9819-39a0eb4424d5.PNG)

ToByteArray
![capture06](https://user-images.githubusercontent.com/5897654/38886484-efe301e8-422a-11e8-8db6-b2a38acb5bd1.PNG)

TryWriteBytes
![capture07](https://user-images.githubusercontent.com/5897654/38886552-23aa80be-422b-11e8-90fe-4a9b2dd512d7.PNG)

[Updated]:
For all of the above the corefx diff below is causing the regression increase: 
dotnet/corefx@7ec7367

Check [benchview ](https://benchview/trendline?build_selector=latest&amp;count=2000&amp;aggregate=arithmeticMean&amp;filterTail=one&amp;filterVal=100&amp;interval=INTERVAL_MIN_MAX&amp;rtids=[957]&amp;archids=[23]&amp;mpids=[1292]&amp;cfgids=[2706]&amp;testids=[642966429564297643056430464306642996429864300643086430764309]&amp;jobgroup=CoreFX&amp;jobtype=rolling&amp;branchId=42&amp;) for more detail.

cc: @kouvel @danmosemsft </Title_Description>
    <Label>area-System.Runtime</Label>
    <Assignee>kouvel</Assignee>
    <CreatedAt>17/04/2018 5:41:09 PM +00:00</CreatedAt>
    <ClosedAt>18/04/2018 1:05:14 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17610</IssueLabelID>
    <Title>[arm32/Ubuntu] Assert failure: Consistency check failed: hit privileged instruction!</Title>
    <Description>In GCStress=0xc

https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_ubuntu_gcstress0xc_tst/2/consoleText



Related to https://github.com/dotnet/coreclr/issues/17585 and/or https://github.com/dotnet/coreclr/issues/17598?

</Description>
    <Title_Description>[arm32/Ubuntu] Assert failure: Consistency check failed: hit privileged instruction! In GCStress=0xc

https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_ubuntu_gcstress0xc_tst/2/consoleText



Related to https://github.com/dotnet/coreclr/issues/17585 and/or https://github.com/dotnet/coreclr/issues/17598?

</Title_Description>
    <Label>GCStress</Label>
    <Assignee>AndyAyersMS</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17609</IssueLabelID>
    <Title>[x86/x64|Windows|Full Framework] Native vararg generates bad code.</Title>
    <Description>C#
</Description>
    <Title_Description>[x86/x64|Windows|Full Framework] Native vararg generates bad code. C#
</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>jashook</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17608</IssueLabelID>
    <Title>[1.1] Fix Debian packaging bug.</Title>
    <Description>- Fixes packaging for Debian8 and Debian9
- Further narrows down the scope of tool-runtime replacement with restored dotnetcli to only Debian9 and only the x509certififactes assembly.</Description>
    <Title_Description>[1.1] Fix Debian packaging bug. - Fixes packaging for Debian8 and Debian9
- Further narrows down the scope of tool-runtime replacement with restored dotnetcli to only Debian9 and only the x509certififactes assembly.</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>ianhays</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17605</IssueLabelID>
    <Title>[arm32/Ubuntu] Failure in R2R JitStress=1 job</Title>
    <Description>https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_r2r_jitstress1_flow/

It appears to fail with a hang in this test:


This is consistent in multiple runs e.g.:

https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_ubuntu_r2r_jitstress1_tst/3/consoleText

</Description>
    <Title_Description>[arm32/Ubuntu] Failure in R2R JitStress=1 job https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_r2r_jitstress1_flow/

It appears to fail with a hang in this test:


This is consistent in multiple runs e.g.:

https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_ubuntu_r2r_jitstress1_tst/3/consoleText

</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>sandreenko</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17604</IssueLabelID>
    <Title>Incorrect prefix appended when the native library lives in "relative" directory in Unix</Title>
    <Description>_From @luqunl on April 17 2018 6:3_

The issue is found by Jkotas:

https://github.com/dotnet/coreclr/blob/9d45401c6056a5b9c92d036e25c34ad34c03385e/src/vm/dllimport.cpp#L6054

libNameIsRelativePath is going to be true for a paths like:
XXX\YYY\library
or
\XXX\YYY\library.

On Unix we will end up trying paths like:
**lib**XXX\YYY\library.so
or
**lib**\XXX\YYY\library.so.

_Copied from original issue: dotnet/corert#5719_</Description>
    <Title_Description>Incorrect prefix appended when the native library lives in "relative" directory in Unix _From @luqunl on April 17 2018 6:3_

The issue is found by Jkotas:

https://github.com/dotnet/coreclr/blob/9d45401c6056a5b9c92d036e25c34ad34c03385e/src/vm/dllimport.cpp#L6054

libNameIsRelativePath is going to be true for a paths like:
XXX\YYY\library
or
\XXX\YYY\library.

On Unix we will end up trying paths like:
**lib**XXX\YYY\library.so
or
**lib**\XXX\YYY\library.so.

_Copied from original issue: dotnet/corert#5719_</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17603</IssueLabelID>
    <Title>About 20% performance regression for OrderBy() and OrderByThenBy() on windows</Title>
    <Description>Here are the graphs showing timings from Aug to now for these tests.

&lt;img width="1060" alt="screen shot 2018-04-16 at 11 07 19 pm" src="https://user-images.githubusercontent.com/5897654/38851560-08d96c2e-41cb-11e8-8154-4730865ce439.png"&gt;

&lt;img width="1063" alt="screen shot 2018-04-16 at 11 17 43 pm" src="https://user-images.githubusercontent.com/5897654/38851868-6f25fda2-41cc-11e8-9884-ea79f7e50ed1.png"&gt;


There was a noticeable jump in October for OrderBy() and OrderByThenBy() tests that does not seem to have been corrected since.

For Windows:
The corefx commit related to this regression is https://github.com/dotnet/corefx/commit/2b25c6c739ada3e8da8b8783e008f48f9078fb33 which in turn points to code changes are in CoreCLR. 
Here's the coreclr commit bd7493440cefe9cdfb3648de99178e208f8df5df  and here's a [github diff](https://github.com/dotnet/coreclr/commit/bd7493440cefe9cdfb3648de99178e208f8df5df) 

Refer to [benchview](https://benchview/trendline?build_selector=latest&amp;count=2000&amp;aggregate=arithmeticMean&amp;filterTail=one&amp;filterVal=100&amp;interval=INTERVAL_MIN_MAX&amp;rtids=[957]&amp;archids=[23]&amp;mpids=[1292]&amp;cfgids=[2706]&amp;testids=[6030360301603026030060319603176031860316]&amp;jobgroup=CoreFX&amp;jobtype=rolling&amp;branchId=42&amp;) for more details.

cc: @kouvel @danmosemsft

category:cq
theme:benchmarks
skill-level:expert
cost:small</Description>
    <Title_Description>About 20% performance regression for OrderBy() and OrderByThenBy() on windows Here are the graphs showing timings from Aug to now for these tests.

&lt;img width="1060" alt="screen shot 2018-04-16 at 11 07 19 pm" src="https://user-images.githubusercontent.com/5897654/38851560-08d96c2e-41cb-11e8-8154-4730865ce439.png"&gt;

&lt;img width="1063" alt="screen shot 2018-04-16 at 11 17 43 pm" src="https://user-images.githubusercontent.com/5897654/38851868-6f25fda2-41cc-11e8-9884-ea79f7e50ed1.png"&gt;


There was a noticeable jump in October for OrderBy() and OrderByThenBy() tests that does not seem to have been corrected since.

For Windows:
The corefx commit related to this regression is https://github.com/dotnet/corefx/commit/2b25c6c739ada3e8da8b8783e008f48f9078fb33 which in turn points to code changes are in CoreCLR. 
Here's the coreclr commit bd7493440cefe9cdfb3648de99178e208f8df5df  and here's a [github diff](https://github.com/dotnet/coreclr/commit/bd7493440cefe9cdfb3648de99178e208f8df5df) 

Refer to [benchview](https://benchview/trendline?build_selector=latest&amp;count=2000&amp;aggregate=arithmeticMean&amp;filterTail=one&amp;filterVal=100&amp;interval=INTERVAL_MIN_MAX&amp;rtids=[957]&amp;archids=[23]&amp;mpids=[1292]&amp;cfgids=[2706]&amp;testids=[6030360301603026030060319603176031860316]&amp;jobgroup=CoreFX&amp;jobtype=rolling&amp;branchId=42&amp;) for more details.

cc: @kouvel @danmosemsft

category:cq
theme:benchmarks
skill-level:expert
cost:small</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17602</IssueLabelID>
    <Title>Clean up FlushInstructionCache for precodes and interlocked target change operations</Title>
    <Description>Updated based on discussion below

~~Add missing FlushInstructionCache to ResetTargetInterlocked~~

~~Not sure if it's necessary considering the interlocked operation but it's there in Precode::SetTargetInterlocked so I assume it's necessary. Probably no issue anyway it's unlikely that call counting won't be done as a result of the instruction cache. No change to perf on JitBench with tiering enabled. On arm32 and arm64 executable code is not changed so no need for the flush there.~~</Description>
    <Title_Description>Clean up FlushInstructionCache for precodes and interlocked target change operations Updated based on discussion below

~~Add missing FlushInstructionCache to ResetTargetInterlocked~~

~~Not sure if it's necessary considering the interlocked operation but it's there in Precode::SetTargetInterlocked so I assume it's necessary. Probably no issue anyway it's unlikely that call counting won't be done as a result of the instruction cache. No change to perf on JitBench with tiering enabled. On arm32 and arm64 executable code is not changed so no need for the flush there.~~</Title_Description>
    <Label>area-VM</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17600</IssueLabelID>
    <Title>Bug in CodeGen::getFirstArgWithStackSlot()</Title>
    <Description>There is a typo in 
</Description>
    <Title_Description>Bug in CodeGen::getFirstArgWithStackSlot() There is a typo in 
</Title_Description>
    <Label>arch-x64</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17598</IssueLabelID>
    <Title>[arm32/Ubuntu] GCStress failures: "Consistency check failed: FAILED: !pThread-&gt;HasPendingGCStressInstructionUpdate()"</Title>
    <Description>When I run GCStress=0xc on Ubuntu arm32 the most common failure is:


which in at least one of my runs required 5 retries to pass.

This is https://github.com/dotnet/coreclr/issues/5310.
</Description>
    <Title_Description>[arm32/Ubuntu] GCStress failures: "Consistency check failed: FAILED: !pThread-&gt;HasPendingGCStressInstructionUpdate()" When I run GCStress=0xc on Ubuntu arm32 the most common failure is:


which in at least one of my runs required 5 retries to pass.

This is https://github.com/dotnet/coreclr/issues/5310.
</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>16/04/2018 10:11:14 PM +00:00</CreatedAt>
    <ClosedAt>30/05/2018 10:21:28 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17597</IssueLabelID>
    <Title>[Arm64] Add memory barrier after interlocked operations</Title>
    <Description>Port of https://github.com/dotnet/coreclr/pull/17595 to release/2.1
Fixes https://github.com/dotnet/coreclr/issues/17591

CC @sdmaclea </Description>
    <Title_Description>[Arm64] Add memory barrier after interlocked operations Port of https://github.com/dotnet/coreclr/pull/17595 to release/2.1
Fixes https://github.com/dotnet/coreclr/issues/17591

CC @sdmaclea </Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17596</IssueLabelID>
    <Title>[1.1] Add missing fed28 and deb9 requirements</Title>
    <Description>- Adds some tags necessary to produce managed components of the build for fed28 and deb9
- Makes the tool-runtime CLI override only happen on platforms where it's required.</Description>
    <Title_Description>[1.1] Add missing fed28 and deb9 requirements - Adds some tags necessary to produce managed components of the build for fed28 and deb9
- Makes the tool-runtime CLI override only happen on platforms where it's required.</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>ianhays</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17595</IssueLabelID>
    <Title>[Arm64] Add memory barrier after interlocked operations</Title>
    <Description>Fixes https://github.com/dotnet/coreclr/issues/17591</Description>
    <Title_Description>[Arm64] Add memory barrier after interlocked operations Fixes https://github.com/dotnet/coreclr/issues/17591</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17594</IssueLabelID>
    <Title>Fix GC tests.</Title>
    <Description>Jit can extend lifetime of temp objects after call to GC.Collect() so we should not have any temp in the same scope with final 





Fixes #17588.

The same problem as #15156.</Description>
    <Title_Description>Fix GC tests. Jit can extend lifetime of temp objects after call to GC.Collect() so we should not have any temp in the same scope with final 





Fixes #17588.

The same problem as #15156.</Title_Description>
    <Label>test bug</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>16/04/2018 7:26:44 PM +00:00</CreatedAt>
    <ClosedAt>17/04/2018 4:44:00 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17593</IssueLabelID>
    <Title>Mirror changes from dotnet/corefx</Title>
    <Description>This PR contains mirrored changes from dotnet/corefx


**Please REBASE this PR when merging**</Description>
    <Title_Description>Mirror changes from dotnet/corefx This PR contains mirrored changes from dotnet/corefx


**Please REBASE this PR when merging**</Title_Description>
    <Label>
    </Label>
    <Assignee>ahsonkhan</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17592</IssueLabelID>
    <Title>Handle getTailCallCopyArgsThunk returning NULL in the JIT</Title>
    <Description>This saves the JIT from hardcoding the logic on where getTailCallCopyArgsThunk is implemented</Description>
    <Title_Description>Handle getTailCallCopyArgsThunk returning NULL in the JIT This saves the JIT from hardcoding the logic on where getTailCallCopyArgsThunk is implemented</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>dotnet-bot</Assignee>
    <CreatedAt>16/04/2018 6:34:13 PM +00:00</CreatedAt>
    <ClosedAt>18/04/2018 12:06:33 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17591</IssueLabelID>
    <Title>[Arm64] Interlocked operations in the runtime need an additional memory barrier</Title>
    <Description>The issue is explained in the discussion of PR https://github.com/dotnet/coreclr/pull/17508:
- https://github.com/dotnet/coreclr/pull/17508#issuecomment-381305227
- https://github.com/dotnet/coreclr/pull/17508#issuecomment-381405138

The extra memory barrier is necessary to guarantee that the store from the interlocked operation occurs before a load following the interlocked operation.

https://github.com/dotnet/coreclr/pull/17567 fixes the issue in the JIT which was seen in https://github.com/dotnet/coreclr/issues/17178.

This issue is to track a similar change to the runtime.</Description>
    <Title_Description>[Arm64] Interlocked operations in the runtime need an additional memory barrier The issue is explained in the discussion of PR https://github.com/dotnet/coreclr/pull/17508:
- https://github.com/dotnet/coreclr/pull/17508#issuecomment-381305227
- https://github.com/dotnet/coreclr/pull/17508#issuecomment-381405138

The extra memory barrier is necessary to guarantee that the store from the interlocked operation occurs before a load following the interlocked operation.

https://github.com/dotnet/coreclr/pull/17567 fixes the issue in the JIT which was seen in https://github.com/dotnet/coreclr/issues/17178.

This issue is to track a similar change to the runtime.</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17588</IssueLabelID>
    <Title>[arm32/Ubuntu] Failures in R2R JitStressRegs3</Title>
    <Description>These may occur in the baseline but I haven't seen results there due to infrastructure issues.

https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_r2r_jitstressregs3_tst/2/consoleText

Tests:

</Description>
    <Title_Description>[arm32/Ubuntu] Failures in R2R JitStressRegs3 These may occur in the baseline but I haven't seen results there due to infrastructure issues.

https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_r2r_jitstressregs3_tst/2/consoleText

Tests:

</Title_Description>
    <Label>JitStress</Label>
    <Assignee>sandreenko</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17587</IssueLabelID>
    <Title>.NET Core assembly cannot be found when assembly loaded through dynamic IL injected-code</Title>
    <Description> I have a profiler that injects IL into some methods so that they can call into my managed assembly. Since my assembly is in the GAC it works fine for .NET Framework but when I tried it in .NET Core the assembly could not be found. Although this may be a duplicate of https://github.com/dotnet/coreclr/issues/3894 I would like to hear what you think are the best options for accomplishing this assembly load. I do not want to modify the application being profiled (I don't have control over its source) so the solution needs to be something I can do with the profiler or a simplified environment setting.
</Description>
    <Title_Description>.NET Core assembly cannot be found when assembly loaded through dynamic IL injected-code  I have a profiler that injects IL into some methods so that they can call into my managed assembly. Since my assembly is in the GAC it works fine for .NET Framework but when I tried it in .NET Core the assembly could not be found. Although this may be a duplicate of https://github.com/dotnet/coreclr/issues/3894 I would like to hear what you think are the best options for accomplishing this assembly load. I do not want to modify the application being profiled (I don't have control over its source) so the solution needs to be something I can do with the profiler or a simplified environment setting.
</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>noahfalk</Assignee>
    <CreatedAt>16/04/2018 5:50:45 PM +00:00</CreatedAt>
    <ClosedAt>18/04/2018 3:58:36 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17585</IssueLabelID>
    <Title>[arm32] Assert failure: ExecutionManager::IsManagedCode(adrRedirectedIP)</Title>
    <Description>Consistent failure in Windows arm32 corefx test System.Runtime.Tests with COMPlus_JitStress=2:

https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_corefx_jitstress2_tst/10/consoleText


</Description>
    <Title_Description>[arm32] Assert failure: ExecutionManager::IsManagedCode(adrRedirectedIP) Consistent failure in Windows arm32 corefx test System.Runtime.Tests with COMPlus_JitStress=2:

https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_corefx_jitstress2_tst/10/consoleText


</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>sandreenko</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17584</IssueLabelID>
    <Title>[arm32/Windows] Test Failed: Failure in corefx System.Net.HttpListener.Tests</Title>
    <Description>Consistent failure in Windows arm32 corefx System.Net.HttpListener.Tests with COMPlus_JitStress=2:

https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_corefx_jitstress2_tst/10/consoleText


</Description>
    <Title_Description>[arm32/Windows] Test Failed: Failure in corefx System.Net.HttpListener.Tests Consistent failure in Windows arm32 corefx System.Net.HttpListener.Tests with COMPlus_JitStress=2:

https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_corefx_jitstress2_tst/10/consoleText


</Title_Description>
    <Label>JitStress</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>16/04/2018 5:14:17 PM +00:00</CreatedAt>
    <ClosedAt>20/09/2019 6:39:04 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17583</IssueLabelID>
    <Title>Failure in corefx System.Diagnostics.StackTrace.Tests</Title>
    <Description>Consistent failure in COMPlus_JitStress=2 runs of corefx tests in System.Diagnostics.StackTrace.Tests:

https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_corefx_jitstress2_tst/10/consoleText


</Description>
    <Title_Description>Failure in corefx System.Diagnostics.StackTrace.Tests Consistent failure in COMPlus_JitStress=2 runs of corefx tests in System.Diagnostics.StackTrace.Tests:

https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_corefx_jitstress2_tst/10/consoleText


</Title_Description>
    <Label>JitStress</Label>
    <Assignee>sandreenko</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17582</IssueLabelID>
    <Title>[arm32/Windows] Hang in corefx Microsoft.Win32.SystemEvents.Tests</Title>
    <Description>Many arm32 Windows corefx jobs in the CI are hanging apparently on Microsoft.Win32.SystemEvents.Tests e.g.:

https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_corefx_baseline_tst/11/console
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_corefx_jitstress1_tst/11/console
https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_windows_nt_corefx_jitstressregs2_tst/9/console
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_corefx_jitstressregs0x1000_tst/10/console

They also show failures before the hang.

Sample output:

</Description>
    <Title_Description>[arm32/Windows] Hang in corefx Microsoft.Win32.SystemEvents.Tests Many arm32 Windows corefx jobs in the CI are hanging apparently on Microsoft.Win32.SystemEvents.Tests e.g.:

https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_corefx_baseline_tst/11/console
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_corefx_jitstress1_tst/11/console
https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_windows_nt_corefx_jitstressregs2_tst/9/console
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_corefx_jitstressregs0x1000_tst/10/console

They also show failures before the hang.

Sample output:

</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>16/04/2018 5:05:27 PM +00:00</CreatedAt>
    <ClosedAt>18/04/2018 1:24:57 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17577</IssueLabelID>
    <Title> Updating the HWIntrinsic APIs to use the unmanaged constraint</Title>
    <Description>FYI. @CarolEidt @fiigii @sdmaclea @eerhardt @jkotas 

This is mostly just for discussion right now since the actual change can't be merged until after the branch opens again.

This is a new (and unshipped API) so back-compat should not be a concern here. However there are some potential other issues with this change:
* The 
  * Examples of things not possible with a shim API include stackalloc and bypassing definite assignment rules</Description>
    <Title_Description> Updating the HWIntrinsic APIs to use the unmanaged constraint FYI. @CarolEidt @fiigii @sdmaclea @eerhardt @jkotas 

This is mostly just for discussion right now since the actual change can't be merged until after the branch opens again.

This is a new (and unshipped API) so back-compat should not be a concern here. However there are some potential other issues with this change:
* The 
  * Examples of things not possible with a shim API include stackalloc and bypassing definite assignment rules</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
    <CreatedAt>15/04/2018 6:03:38 PM +00:00</CreatedAt>
    <ClosedAt>25/05/2018 4:16:43 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17576</IssueLabelID>
    <Title>Port JIT and GC to C#</Title>
    <Description>Is it possible?</Description>
    <Title_Description>Port JIT and GC to C# Is it possible?</Title_Description>
    <Label>Design Discussion</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>15/04/2018 8:52:35 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17575</IssueLabelID>
    <Title>[Arm64] Disable SIMD in crossgen (added as part of #14633)</Title>
    <Description>Disable SIMD feature in crossgen for ARM64 for now as decided in #17543

This will let the following arm64 crossgen tests to pass. (#16541 #16542)</Description>
    <Title_Description>[Arm64] Disable SIMD in crossgen (added as part of #14633) Disable SIMD feature in crossgen for ARM64 for now as decided in #17543

This will let the following arm64 crossgen tests to pass. (#16541 #16542)</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>dotnet-bot</Assignee>
    <CreatedAt>15/04/2018 4:42:59 AM +00:00</CreatedAt>
    <ClosedAt>17/04/2018 1:45:18 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17574</IssueLabelID>
    <Title>[arm64] Assertion failed 'varDsc-&gt;lvOnFrame &amp;&amp; !varDsc-&gt;lvRegister'</Title>
    <Description>x64_arm64_altjit corefx assertion:

https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64_arm64_altjit/job/jitstress/job/x64_arm64_altjit_checked_windows_nt_corefx_baseline/157/consoleFull#-102414311f66db340-b3cd-4e23-8190-9b52cb916333



also: https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64_arm64_altjit/job/jitstress/job/x64_arm64_altjit_checked_windows_nt_corefx_jitstress2/154/
https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64_arm64_altjit/job/jitstress/job/x64_arm64_altjit_checked_windows_nt_corefx_jitstressregs3/158/
https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64_arm64_altjit/job/jitstress/job/x64_arm64_altjit_checked_windows_nt_corefx_jitstressregs4/156/
https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64_arm64_altjit/job/jitstress/job/x64_arm64_altjit_checked_windows_nt_corefx_jitstressregs8/155/

and probably others.

</Description>
    <Title_Description>[arm64] Assertion failed 'varDsc-&gt;lvOnFrame &amp;&amp; !varDsc-&gt;lvRegister' x64_arm64_altjit corefx assertion:

https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64_arm64_altjit/job/jitstress/job/x64_arm64_altjit_checked_windows_nt_corefx_baseline/157/consoleFull#-102414311f66db340-b3cd-4e23-8190-9b52cb916333



also: https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64_arm64_altjit/job/jitstress/job/x64_arm64_altjit_checked_windows_nt_corefx_jitstress2/154/
https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64_arm64_altjit/job/jitstress/job/x64_arm64_altjit_checked_windows_nt_corefx_jitstressregs3/158/
https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64_arm64_altjit/job/jitstress/job/x64_arm64_altjit_checked_windows_nt_corefx_jitstressregs4/156/
https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64_arm64_altjit/job/jitstress/job/x64_arm64_altjit_checked_windows_nt_corefx_jitstressregs8/155/

and probably others.

</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>14/04/2018 10:11:18 PM +00:00</CreatedAt>
    <ClosedAt>15/04/2018 3:49:26 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17573</IssueLabelID>
    <Title>[arm64] Assertion failed '(candidates &amp; allRegs(srcInterval-&gt;registerType)) != 0'</Title>
    <Description>x64_arm64_altjit job failures:

https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64_arm64_altjit/job/jitstress/job/x64_arm64_altjit_checked_windows_nt_jitstress1/
https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64_arm64_altjit/job/jitstress/job/x64_arm64_altjit_checked_windows_nt_jitstress2/


</Description>
    <Title_Description>[arm64] Assertion failed '(candidates &amp; allRegs(srcInterval-&gt;registerType)) != 0' x64_arm64_altjit job failures:

https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64_arm64_altjit/job/jitstress/job/x64_arm64_altjit_checked_windows_nt_jitstress1/
https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64_arm64_altjit/job/jitstress/job/x64_arm64_altjit_checked_windows_nt_jitstress2/


</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>14/04/2018 10:00:32 PM +00:00</CreatedAt>
    <ClosedAt>15/04/2018 3:50:13 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17572</IssueLabelID>
    <Title>[arm32/Ubuntu] Enable R2R jobs as periodic/cron jobs</Title>
    <Description>The Ubuntu arm32 R2R jobs exist but are not scheduled periodically. Now that they work they should be added to the set of periodic jobs.
</Description>
    <Title_Description>[arm32/Ubuntu] Enable R2R jobs as periodic/cron jobs The Ubuntu arm32 R2R jobs exist but are not scheduled periodically. Now that they work they should be added to the set of periodic jobs.
</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>BruceForstall</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17571</IssueLabelID>
    <Title>Enable `FEATURE_PREVENT_BAD_BYREFS` for all platforms and remove ifdefs</Title>
    <Description>https://github.com/dotnet/coreclr/pull/17524 introduced the  and make the code all-platform after testing all platforms and investigating the (significant number of) asm diffs.


category:correctness
theme:jit-coding-style
skill-level:intermediate
cost:small</Description>
    <Title_Description>Enable  and make the code all-platform after testing all platforms and investigating the (significant number of) asm diffs.


category:correctness
theme:jit-coding-style
skill-level:intermediate
cost:small</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>BruceForstall</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17570</IssueLabelID>
    <Title>Windows ARM32 GCStress=0xc failures in baseservices\threading\generics\WaitCallback thread tests</Title>
    <Description>The 
</Description>
    <Title_Description>Windows ARM32 GCStress=0xc failures in baseservices\threading\generics\WaitCallback thread tests The 
</Title_Description>
    <Label>GCStress</Label>
    <Assignee>echesakovMSFT</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17569</IssueLabelID>
    <Title>Don't use runtesttilstable script for Ubuntu arm jobs</Title>
    <Description>Testing in #17274 </Description>
    <Title_Description>Don't use runtesttilstable script for Ubuntu arm jobs Testing in #17274 </Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>echesakovMSFT</Assignee>
    <CreatedAt>14/04/2018 4:10:45 PM +00:00</CreatedAt>
    <ClosedAt>14/04/2018 8:30:22 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17568</IssueLabelID>
    <Title>Revisit the handling of SIMD types during crossgen</Title>
    <Description>See the comments on PR #17543.

During crossgen the JIT sets  seemed to fix that issue.

We should consider whether to add support for fixed- or known- size SIMD types during crossgen across architectures.

category:cq
theme:vector-codegen
skill-level:intermediate
cost:small</Description>
    <Title_Description>Revisit the handling of SIMD types during crossgen See the comments on PR #17543.

During crossgen the JIT sets  seemed to fix that issue.

We should consider whether to add support for fixed- or known- size SIMD types during crossgen across architectures.

category:cq
theme:vector-codegen
skill-level:intermediate
cost:small</Title_Description>
    <Label>Design Discussion</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17567</IssueLabelID>
    <Title>[Arm64] Add full barrier after locking operations</Title>
    <Description>Per discussion with @kouvel in #17508 Interlocked operations should all act as a fully ordering barrier.

Fixes #14346 because we will have have come to a consensus

@jkotas @kouvel @stephentoub @tarekgh 
</Description>
    <Title_Description>[Arm64] Add full barrier after locking operations Per discussion with @kouvel in #17508 Interlocked operations should all act as a fully ordering barrier.

Fixes #14346 because we will have have come to a consensus

@jkotas @kouvel @stephentoub @tarekgh 
</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>kouvel</Assignee>
    <CreatedAt>14/04/2018 9:52:21 AM +00:00</CreatedAt>
    <ClosedAt>15/04/2018 9:36:05 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17566</IssueLabelID>
    <Title>Suprising sliced ReadOnlySpan Equality with strings</Title>
    <Description>If a 
&lt;/details&gt;</Description>
    <Title_Description>Suprising sliced ReadOnlySpan Equality with strings If a 
&lt;/details&gt;</Title_Description>
    <Label>area-System.Memory</Label>
    <Assignee>stephentoub</Assignee>
    <CreatedAt>14/04/2018 8:09:07 AM +00:00</CreatedAt>
    <ClosedAt>20/04/2018 2:34:55 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17565</IssueLabelID>
    <Title>[Linux/arm] Crossgen SlowTailCallArgs assert failure</Title>
    <Description>Fails here [Ubuntu arm Cross Checked r2r Build and Test](https://ci.dot.net/job/dotnet_coreclr/job/master/job/arm_cross_checked_ubuntu_r2r_tst_prtest/2/consoleText) with the following output

</Description>
    <Title_Description>[Linux/arm] Crossgen SlowTailCallArgs assert failure Fails here [Ubuntu arm Cross Checked r2r Build and Test](https://ci.dot.net/job/dotnet_coreclr/job/master/job/arm_cross_checked_ubuntu_r2r_tst_prtest/2/consoleText) with the following output

</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>janvorli</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17564</IssueLabelID>
    <Title>[Arm64] Harder Acquire Release cases</Title>
    <Description>#12087 implemented the simplest volatile cases as loadAcquire and storeRelease.  There is room for a more complete set to be implemented.  Signed load cases is one example.

category:cq
theme:barriers
skill-level:expert
cost:medium</Description>
    <Title_Description>[Arm64] Harder Acquire Release cases #12087 implemented the simplest volatile cases as loadAcquire and storeRelease.  There is room for a more complete set to be implemented.  Signed load cases is one example.

category:cq
theme:barriers
skill-level:expert
cost:medium</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>14/04/2018 6:29:16 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17563</IssueLabelID>
    <Title>Optimize ThreadPool WorkStealingQueue</Title>
    <Description>While analyzing for #17508 it became apparent that the use of  to be lockless.
</Description>
    <Title_Description>Optimize ThreadPool WorkStealingQueue While analyzing for #17508 it became apparent that the use of  to be lockless.
</Title_Description>
    <Label>area-System.Threading</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>14/04/2018 6:24:35 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17561</IssueLabelID>
    <Title>[1.1] Replace tool-runtime binaries with portable linux binaries</Title>
    <Description>When we restore the portable runtime on 1.1 we should also use those portable binaries for the tool-runtime. Otherwise we can run into conflicts between the native binaries expected by the portable-cli and the tool-runtime dependencies.

Also removes some platform specific CLI usages that I tested and verified with the portable CLI instead.

@janvorli this resolves the issues you were seeing with the x509certificates dll. Our tools were using an older version of the managed dll instead of the one in your portable CLi resulting in failed attempted loads of native functions in the System.Security.Cryptography.Native .so.</Description>
    <Title_Description>[1.1] Replace tool-runtime binaries with portable linux binaries When we restore the portable runtime on 1.1 we should also use those portable binaries for the tool-runtime. Otherwise we can run into conflicts between the native binaries expected by the portable-cli and the tool-runtime dependencies.

Also removes some platform specific CLI usages that I tested and verified with the portable CLI instead.

@janvorli this resolves the issues you were seeing with the x509certificates dll. Our tools were using an older version of the managed dll instead of the one in your portable CLi resulting in failed attempted loads of native functions in the System.Security.Cryptography.Native .so.</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>ianhays</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17558</IssueLabelID>
    <Title>JitStress=2 failure in corefx System.Diagnostics.StackTrace.Tests</Title>
    <Description>We get the following failure in x64_checked_windows_nt_corefx_jitstress2 jobs (e.g. https://ci.dot.net/job/dotnet_coreclr/job/master/view/Windows_NT/job/jitstress/job/x64_checked_windows_nt_corefx_jitstress2/484/consoleText)



Two other failures from that run are the same as in #17557.</Description>
    <Title_Description>JitStress=2 failure in corefx System.Diagnostics.StackTrace.Tests We get the following failure in x64_checked_windows_nt_corefx_jitstress2 jobs (e.g. https://ci.dot.net/job/dotnet_coreclr/job/master/view/Windows_NT/job/jitstress/job/x64_checked_windows_nt_corefx_jitstress2/484/consoleText)



Two other failures from that run are the same as in #17557.</Title_Description>
    <Label>JitStress</Label>
    <Assignee>erozenfeld</Assignee>
    <CreatedAt>13/04/2018 10:48:22 PM +00:00</CreatedAt>
    <ClosedAt>17/06/2018 2:54:12 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17557</IssueLabelID>
    <Title>Failures in x64_checked_windows_nt_corefx_jitstress1 jobs</Title>
    <Description>We get the following failures in  x64_checked_windows_nt_corefx_jitstress1 jobs (e.g. https://ci.dot.net/job/dotnet_coreclr/job/master/view/Windows_NT/job/jitstress/job/x64_checked_windows_nt_corefx_jitstress1/lastBuild/consoleText)

</Description>
    <Title_Description>Failures in x64_checked_windows_nt_corefx_jitstress1 jobs We get the following failures in  x64_checked_windows_nt_corefx_jitstress1 jobs (e.g. https://ci.dot.net/job/dotnet_coreclr/job/master/view/Windows_NT/job/jitstress/job/x64_checked_windows_nt_corefx_jitstress1/lastBuild/consoleText)

</Title_Description>
    <Label>JitStress</Label>
    <Assignee>briansull</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17556</IssueLabelID>
    <Title>Fix default style argument to Double/Single/Decimal.Parse</Title>
    <Description>Contributes to https://github.com/dotnet/coreclr/issues/17553
cc: @jkotas </Description>
    <Title_Description>Fix default style argument to Double/Single/Decimal.Parse Contributes to https://github.com/dotnet/coreclr/issues/17553
cc: @jkotas </Title_Description>
    <Label>area-System.Runtime</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>13/04/2018 8:35:23 PM +00:00</CreatedAt>
    <ClosedAt>13/04/2018 11:07:35 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17555</IssueLabelID>
    <Title>WIP Test tiering in CI</Title>
    <Description>
    </Description>
    <Title_Description>WIP Test tiering in CI </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17554</IssueLabelID>
    <Title>[Perf] Span/IndexerBench/KnownSizeArray(length:1024) regression of ~277% on x86</Title>
    <Description>**[Perf] Span/IndexerBench/KnownSizeArray(length:1024) regression of ~277% on x86**

Regression can be seen in Benchview - CoreCLR/Master branch from [commit](https://github.com/dotnet/coreclr/compare/94ab205d5545699a49cc54d72e9d3d07a454f10a...dotnet:4456cc99ba0fbe3c02be3a9f54c34282caeb7218). Orange dotted line is the Release v2.0 baseline. This is affecting x86 only.

![image](https://user-images.githubusercontent.com/19602715/38752900-8f1c9aac-3f11-11e8-90ca-8393cdf46a74.png)
</Description>
    <Title_Description>[Perf] Span/IndexerBench/KnownSizeArray(length:1024) regression of ~277% on x86 **[Perf] Span/IndexerBench/KnownSizeArray(length:1024) regression of ~277% on x86**

Regression can be seen in Benchview - CoreCLR/Master branch from [commit](https://github.com/dotnet/coreclr/compare/94ab205d5545699a49cc54d72e9d3d07a454f10a...dotnet:4456cc99ba0fbe3c02be3a9f54c34282caeb7218). Orange dotted line is the Release v2.0 baseline. This is affecting x86 only.

![image](https://user-images.githubusercontent.com/19602715/38752900-8f1c9aac-3f11-11e8-90ca-8393cdf46a74.png)
</Title_Description>
    <Label>arch-x86</Label>
    <Assignee>erozenfeld</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17553</IssueLabelID>
    <Title>Default NumberStyle in float.Parse and double.Parse is Integer for Span</Title>
    <Description>The default NumberStyle in 
This appears to be the case even in the original PR from @stephentoub  in #13389 and looks to be a copy/paste error from the integer types.</Description>
    <Title_Description>Default NumberStyle in float.Parse and double.Parse is Integer for Span The default NumberStyle in 
This appears to be the case even in the original PR from @stephentoub  in #13389 and looks to be a copy/paste error from the integer types.</Title_Description>
    <Label>area-System.Runtime</Label>
    <Assignee>stephentoub</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17552</IssueLabelID>
    <Title>[Perf] SIMD/RayTracerBench regression of ~7% on x86</Title>
    <Description>**[Perf] SIMD/RayTracerBench regression of ~7% on x86**

Regression can be seen in Benchview - CoreCLR/Master branch between [commits](https://github.com/dotnet/coreclr/compare/0c9e96e1c2c484e7c80bf7f7a7765e6650cbdf73...dotnet:bd7493440cefe9cdfb3648de99178e208f8df5df). Orange dotted line is the Release v2.0 baseline.

![image](https://user-images.githubusercontent.com/19602715/38752109-e943cca6-3f0e-11e8-9f64-f5ee1acd9e90.png)
</Description>
    <Title_Description>[Perf] SIMD/RayTracerBench regression of ~7% on x86 **[Perf] SIMD/RayTracerBench regression of ~7% on x86**

Regression can be seen in Benchview - CoreCLR/Master branch between [commits](https://github.com/dotnet/coreclr/compare/0c9e96e1c2c484e7c80bf7f7a7765e6650cbdf73...dotnet:bd7493440cefe9cdfb3648de99178e208f8df5df). Orange dotted line is the Release v2.0 baseline.

![image](https://user-images.githubusercontent.com/19602715/38752109-e943cca6-3f0e-11e8-9f64-f5ee1acd9e90.png)
</Title_Description>
    <Label>arch-x86</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17551</IssueLabelID>
    <Title>Fix OpenVirtualProcess on Linux issue.</Title>
    <Description>Fix DataTargetReader::GetRemotePointerSize to work on Linux/MacOS platforms so VS's new Linux core dump support works.</Description>
    <Title_Description>Fix OpenVirtualProcess on Linux issue. Fix DataTargetReader::GetRemotePointerSize to work on Linux/MacOS platforms so VS's new Linux core dump support works.</Title_Description>
    <Label>
    </Label>
    <Assignee>mikem8361</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17550</IssueLabelID>
    <Title>[Perf] ByteMark/BenchLUDecomp regression of ~67% on x86</Title>
    <Description>**[Perf] ByteMark/BenchLUDecomp regression of ~67% on x86**

A regression of ~19% can be seen in Benchview - CoreCLR/Master branch between [commits](https://github.com/dotnet/coreclr/compare/367d9b1dd1b542f3d391d0b9111d5914602db2d9...dotnet:312e4486adc4eb8062caa67d4aa9be5411524996) and a regression of ~27% between [commits](https://github.com/dotnet/coreclr/compare/3657a8cab68cdbf9990d98ba4e078f444f5fee82...dotnet:bb36f051ca1dd5be7c998f9c26fa010c3b8c4051).

![image](https://user-images.githubusercontent.com/19602715/38751230-43d0e396-3f0c-11e8-9d9a-3fb9dbb294c2.png)


category:cq
theme:benchmarks
skill-level:expert
cost:small</Description>
    <Title_Description>[Perf] ByteMark/BenchLUDecomp regression of ~67% on x86 **[Perf] ByteMark/BenchLUDecomp regression of ~67% on x86**

A regression of ~19% can be seen in Benchview - CoreCLR/Master branch between [commits](https://github.com/dotnet/coreclr/compare/367d9b1dd1b542f3d391d0b9111d5914602db2d9...dotnet:312e4486adc4eb8062caa67d4aa9be5411524996) and a regression of ~27% between [commits](https://github.com/dotnet/coreclr/compare/3657a8cab68cdbf9990d98ba4e078f444f5fee82...dotnet:bb36f051ca1dd5be7c998f9c26fa010c3b8c4051).

![image](https://user-images.githubusercontent.com/19602715/38751230-43d0e396-3f0c-11e8-9d9a-3fb9dbb294c2.png)


category:cq
theme:benchmarks
skill-level:expert
cost:small</Title_Description>
    <Label>arch-x86</Label>
    <Assignee>AndyAyersMS</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17549</IssueLabelID>
    <Title>WIP Test tiered compilation in CI</Title>
    <Description>
    </Description>
    <Title_Description>WIP Test tiered compilation in CI </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17548</IssueLabelID>
    <Title>[Perf] ByteMark/BenchEmFloatClass improvement of ~3% on x86</Title>
    <Description>**[Perf] ByteMark/BenchEmFloatClass improvement of ~3% on x86**

Improvement can be seen in Benchview - CoreCLR/Master branch between [commits](https://github.com/dotnet/coreclr/compare/89e85cfff719bc743ad53fdc702b0379c5286087...dotnet:e45a895df6b4cc50347daafed05cefa59af511a2). Orange dotted line is the Release v2.0 baseline.

![image](https://user-images.githubusercontent.com/19602715/38750595-4892d6a2-3f0a-11e8-9bcb-33e8ccc8cb88.png)
</Description>
    <Title_Description>[Perf] ByteMark/BenchEmFloatClass improvement of ~3% on x86 **[Perf] ByteMark/BenchEmFloatClass improvement of ~3% on x86**

Improvement can be seen in Benchview - CoreCLR/Master branch between [commits](https://github.com/dotnet/coreclr/compare/89e85cfff719bc743ad53fdc702b0379c5286087...dotnet:e45a895df6b4cc50347daafed05cefa59af511a2). Orange dotted line is the Release v2.0 baseline.

![image](https://user-images.githubusercontent.com/19602715/38750595-4892d6a2-3f0a-11e8-9bcb-33e8ccc8cb88.png)
</Title_Description>
    <Label>arch-x86</Label>
    <Assignee>AndyAyersMS</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17547</IssueLabelID>
    <Title>[Perf] Benchstone/BenchI/BenchE improvement of ~5% on x86</Title>
    <Description>**[Perf] Benchstone/BenchI/AddArray improvement of ~5% on x86**

Improvement can be seen in Benchview - CoreCLR/Master branch between [commits](https://github.com/dotnet/coreclr/compare/367d9b1dd1b542f3d391d0b9111d5914602db2d9...dotnet:312e4486adc4eb8062caa67d4aa9be5411524996). Orange dotted line is the Release v2.0 baseline.

![image](https://user-images.githubusercontent.com/19602715/38750257-42b12438-3f09-11e8-802e-f46787a6c8fb.png)
</Description>
    <Title_Description>[Perf] Benchstone/BenchI/BenchE improvement of ~5% on x86 **[Perf] Benchstone/BenchI/AddArray improvement of ~5% on x86**

Improvement can be seen in Benchview - CoreCLR/Master branch between [commits](https://github.com/dotnet/coreclr/compare/367d9b1dd1b542f3d391d0b9111d5914602db2d9...dotnet:312e4486adc4eb8062caa67d4aa9be5411524996). Orange dotted line is the Release v2.0 baseline.

![image](https://user-images.githubusercontent.com/19602715/38750257-42b12438-3f09-11e8-802e-f46787a6c8fb.png)
</Title_Description>
    <Label>arch-x86</Label>
    <Assignee>erozenfeld</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17545</IssueLabelID>
    <Title>[Perf] Benchstone/BenchI/AddArray improvement of ~8% on x86</Title>
    <Description>**[Perf] Benchstone/BenchI/AddArray improvement of ~8% on x86**

Improvement can be seen in Benchview - CoreCLR/Master branch between [commits](https://github.com/dotnet/coreclr/compare/099e24486977ef4930692aa2c122f572e3d09d01...dotnet:52be8c187c9edbaaa2c8a775800bedad112bc6c6). Orange dotted line is the Release v2.0 baseline.

![image](https://user-images.githubusercontent.com/19602715/38749963-3b46b538-3f08-11e8-8bc2-c4ce538a2d2b.png)
</Description>
    <Title_Description>[Perf] Benchstone/BenchI/AddArray improvement of ~8% on x86 **[Perf] Benchstone/BenchI/AddArray improvement of ~8% on x86**

Improvement can be seen in Benchview - CoreCLR/Master branch between [commits](https://github.com/dotnet/coreclr/compare/099e24486977ef4930692aa2c122f572e3d09d01...dotnet:52be8c187c9edbaaa2c8a775800bedad112bc6c6). Orange dotted line is the Release v2.0 baseline.

![image](https://user-images.githubusercontent.com/19602715/38749963-3b46b538-3f08-11e8-8bc2-c4ce538a2d2b.png)
</Title_Description>
    <Label>arch-x86</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17544</IssueLabelID>
    <Title>[Perf] Benchstone/BenchF/BenchMrk regression of ~15% on x86</Title>
    <Description>**[Perf] Benchstone/BenchF/BenchMrk regression of ~15% on x86**

Regression can be seen in Benchview - CoreCLR/Master branch between [commits](https://github.com/dotnet/coreclr/compare/0c9e96e1c2c484e7c80bf7f7a7765e6650cbdf73...dotnet:bd7493440cefe9cdfb3648de99178e208f8df5df). Orange dotted line is the Release v2.0 baseline.

![image](https://user-images.githubusercontent.com/19602715/38749646-392b7320-3f07-11e8-963c-882cb035d3be.png)




</Description>
    <Title_Description>[Perf] Benchstone/BenchF/BenchMrk regression of ~15% on x86 **[Perf] Benchstone/BenchF/BenchMrk regression of ~15% on x86**

Regression can be seen in Benchview - CoreCLR/Master branch between [commits](https://github.com/dotnet/coreclr/compare/0c9e96e1c2c484e7c80bf7f7a7765e6650cbdf73...dotnet:bd7493440cefe9cdfb3648de99178e208f8df5df). Orange dotted line is the Release v2.0 baseline.

![image](https://user-images.githubusercontent.com/19602715/38749646-392b7320-3f07-11e8-963c-882cb035d3be.png)




</Title_Description>
    <Label>arch-x86</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17543</IssueLabelID>
    <Title>Allow TYP_SIMD normalization for GT_IND in importer (#16542)</Title>
    <Description>
Fix for #16542

Increasing the scope of the assertion to include TYP_SIMD allows the test to pass.

PTAL @sdmaclea @CarolEidt </Description>
    <Title_Description>Allow TYP_SIMD normalization for GT_IND in importer (#16542) 
Fix for #16542

Increasing the scope of the assertion to include TYP_SIMD allows the test to pass.

PTAL @sdmaclea @CarolEidt </Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>sdmaclea</Assignee>
    <CreatedAt>13/04/2018 12:29:12 PM +00:00</CreatedAt>
    <ClosedAt>15/04/2018 4:44:14 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17542</IssueLabelID>
    <Title>Update KoreanLunisolarCalendar.cs</Title>
    <Description>Corrects two issues with the conversion table for Gregorian to Korean lunisolar dates.
See: https://github.com/dotnet/coreclr/issues/17510.

**Issue 1: tables use Julian month/day instead of Gregorian month/day for entries prior to 1583.**
Lmon and Lday have been converted from Julian month and day to Gregorian month and day for years prior to 1583.  This also required a new value for MIN_GREGORIAN_DAY (now 19) so the minimum date now supported by this class is 19 Feb 0918 Gregorian. 

**Issue 2: data discrepancy in years 1586 1587 1648 1659 1692 1753 and 1754.**
Table entries for 1586 1587 1648 1659 1692 1753 and 1754 have been corrected to match [Korea Astronomy and Space Science Institute (KASI)](https://astro.kasi.re.kr:444/life/pageView/5) data.  Specifically:

- for years 1587 1648 and 1754 the first day of year has been corrected
- for years 1586 1587 1659 1692 1753 and 1754 the lengths of each month have been corrected

**Notes**
The DaysPerMonth flag uses the binary literal for ease of readability.</Description>
    <Title_Description>Update KoreanLunisolarCalendar.cs Corrects two issues with the conversion table for Gregorian to Korean lunisolar dates.
See: https://github.com/dotnet/coreclr/issues/17510.

**Issue 1: tables use Julian month/day instead of Gregorian month/day for entries prior to 1583.**
Lmon and Lday have been converted from Julian month and day to Gregorian month and day for years prior to 1583.  This also required a new value for MIN_GREGORIAN_DAY (now 19) so the minimum date now supported by this class is 19 Feb 0918 Gregorian. 

**Issue 2: data discrepancy in years 1586 1587 1648 1659 1692 1753 and 1754.**
Table entries for 1586 1587 1648 1659 1692 1753 and 1754 have been corrected to match [Korea Astronomy and Space Science Institute (KASI)](https://astro.kasi.re.kr:444/life/pageView/5) data.  Specifically:

- for years 1587 1648 and 1754 the first day of year has been corrected
- for years 1586 1587 1659 1692 1753 and 1754 the lengths of each month have been corrected

**Notes**
The DaysPerMonth flag uses the binary literal for ease of readability.</Title_Description>
    <Label>area-System.Globalization</Label>
    <Assignee>tarekgh</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17541</IssueLabelID>
    <Title>[Jit] Recognize FMA pattern and Emit Fused Multiply Add (when available)</Title>
    <Description>e.g.



Its a bit of a mine field on x86 https://en.wikipedia.org/wiki/FMA_instruction_set

&gt; The incompatibility between Intel's FMA3 and AMD's FMA4 is due to both companies changing plans without coordinating coding details with each other. AMD changed their plans from FMA3 to FMA4 while Intel changed their plans from FMA4 to FMA3 almost at the same time. The history can be summarized as follows:
&gt;
&gt; * August 2007: AMD announces the SSE5 instruction set which includes 3-operand FMA instructions. A new coding scheme (DREX) is introduced for allowing instructions to have three operands.[11]
&gt; * April 2008: Intel announces their AVX and FMA instruction sets including 4-operand FMA instructions. The coding of these instructions uses the new VEX coding scheme[12] which is more flexible than AMD's DREX scheme.
&gt; * December 2008: Intel changes the specification for their FMA instructions from 4-operand to 3-operand instructions. The VEX coding scheme is still used.[13]
&gt; * May 2009: AMD changes the specification of their FMA instructions from the 3-operand DREX form to the 4-operand VEX form compatible with the April 2008 Intel specification rather than the December 2008 Intel specification.[14]
&gt; * October 2011: AMD Bulldozer processor supports FMA4.[15]
&gt; * January 2012: AMD announces FMA3 support in future processors codenamed Trinity and Vishera; they are based on the Piledriver architecture.[16]
&gt; * May 2012: AMD Piledriver processor supports both FMA3 and FMA4.[15]
&gt; * June 2013: Intel Haswell processor supports FMA3.[17]
&gt; * February 2017 The first generation of AMD Ryzen processors officially supports FMA3 but not FMA4 according to the CPUID instruction.[18] There has been confusion regarding whether FMA4 was implemented or not on this processor due to errata in the initial patch to the GNU Binutils package that has since been rectified.[19][20] While the FMA4 instructions seem to work according to some tests they can also give wrong results.[7] Additionally the initial Ryzen CPUs could be crashed by a particular sequence of FMA3 instructions. It has since been resolved by an updated CPU microcode.[21]

category:cq
theme:basic-cq
skill-level:expert
cost:medium</Description>
    <Title_Description>[Jit] Recognize FMA pattern and Emit Fused Multiply Add (when available) e.g.



Its a bit of a mine field on x86 https://en.wikipedia.org/wiki/FMA_instruction_set

&gt; The incompatibility between Intel's FMA3 and AMD's FMA4 is due to both companies changing plans without coordinating coding details with each other. AMD changed their plans from FMA3 to FMA4 while Intel changed their plans from FMA4 to FMA3 almost at the same time. The history can be summarized as follows:
&gt;
&gt; * August 2007: AMD announces the SSE5 instruction set which includes 3-operand FMA instructions. A new coding scheme (DREX) is introduced for allowing instructions to have three operands.[11]
&gt; * April 2008: Intel announces their AVX and FMA instruction sets including 4-operand FMA instructions. The coding of these instructions uses the new VEX coding scheme[12] which is more flexible than AMD's DREX scheme.
&gt; * December 2008: Intel changes the specification for their FMA instructions from 4-operand to 3-operand instructions. The VEX coding scheme is still used.[13]
&gt; * May 2009: AMD changes the specification of their FMA instructions from the 3-operand DREX form to the 4-operand VEX form compatible with the April 2008 Intel specification rather than the December 2008 Intel specification.[14]
&gt; * October 2011: AMD Bulldozer processor supports FMA4.[15]
&gt; * January 2012: AMD announces FMA3 support in future processors codenamed Trinity and Vishera; they are based on the Piledriver architecture.[16]
&gt; * May 2012: AMD Piledriver processor supports both FMA3 and FMA4.[15]
&gt; * June 2013: Intel Haswell processor supports FMA3.[17]
&gt; * February 2017 The first generation of AMD Ryzen processors officially supports FMA3 but not FMA4 according to the CPUID instruction.[18] There has been confusion regarding whether FMA4 was implemented or not on this processor due to errata in the initial patch to the GNU Binutils package that has since been rectified.[19][20] While the FMA4 instructions seem to work according to some tests they can also give wrong results.[7] Additionally the initial Ryzen CPUs could be crashed by a particular sequence of FMA3 instructions. It has since been resolved by an updated CPU microcode.[21]

category:cq
theme:basic-cq
skill-level:expert
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>13/04/2018 8:57:42 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17540</IssueLabelID>
    <Title>Update CoreClr CoreFx PgoData to preview3-26416-01 preview3-26416-01 master-20180415-0051 respectively (master)</Title>
    <Description>/cc @dotnet/coreclr-auto-update-notify</Description>
    <Title_Description>Update CoreClr, CoreFx, PgoData to preview3-26416-01, preview3-26416-01, master-20180415-0051, respectively (master) /cc @dotnet/coreclr-auto-update-notify</Title_Description>
    <Label>area-Meta</Label>
    <Assignee>AlexGhiondea</Assignee>
    <CreatedAt>13/04/2018 8:07:31 AM +00:00</CreatedAt>
    <ClosedAt>16/04/2018 6:43:05 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17539</IssueLabelID>
    <Title>Mirror changes from dotnet/corefx</Title>
    <Description>This PR contains mirrored changes from dotnet/corefx


**Please REBASE this PR when merging**</Description>
    <Title_Description>Mirror changes from dotnet/corefx This PR contains mirrored changes from dotnet/corefx


**Please REBASE this PR when merging**</Title_Description>
    <Label>
    </Label>
    <Assignee>ahsonkhan</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17537</IssueLabelID>
    <Title>[Arm64/Windows] Simplify JIT_MemSet &amp; JIT_MemCpy</Title>
    <Description>JIT_Memset alignment code was definitly broken for some
unaligned cases

JIT_MemCpy likely had the same issue

Simplify implementation to reduce maintenance burden

@janvorli @jkotas PTAL
@dotnet/arm64-contrib FYI

This is the Windows equivalent of #17536 

Should be required to fix probable issues on windows like #17167 #17168 &amp; #17169 
</Description>
    <Title_Description>[Arm64/Windows] Simplify JIT_MemSet &amp; JIT_MemCpy JIT_Memset alignment code was definitly broken for some
unaligned cases

JIT_MemCpy likely had the same issue

Simplify implementation to reduce maintenance burden

@janvorli @jkotas PTAL
@dotnet/arm64-contrib FYI

This is the Windows equivalent of #17536 

Should be required to fix probable issues on windows like #17167 #17168 &amp; #17169 
</Title_Description>
    <Label>area-VM</Label>
    <Assignee>janvorli</Assignee>
    <CreatedAt>13/04/2018 1:31:23 AM +00:00</CreatedAt>
    <ClosedAt>13/04/2018 4:46:20 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17535</IssueLabelID>
    <Title>Insert int3 after non-returning calls at the end of basic blocks.</Title>
    <Description>This is a follow-up to #17501 that fixed #17398.

#17398 was caused by a break in implicit contract between codegen and
gc pointer reporting in fully-interruptible mode: the latter assumed that
register gc pointer liveness doesn't change across calls while #6103 introduced
codegen where it wasn't true.

#17501 changed gc pointer reporting not to expect that register gc pointer liveness
doesn't change across calls.

This change inserts int3 after non-returning calls at the end of basic blocks
so that gc pointer liveness doesn't change across calls. This is additional
insurance in case any other place in runtime is dependent on that contract.</Description>
    <Title_Description>Insert int3 after non-returning calls at the end of basic blocks. This is a follow-up to #17501 that fixed #17398.

#17398 was caused by a break in implicit contract between codegen and
gc pointer reporting in fully-interruptible mode: the latter assumed that
register gc pointer liveness doesn't change across calls while #6103 introduced
codegen where it wasn't true.

#17501 changed gc pointer reporting not to expect that register gc pointer liveness
doesn't change across calls.

This change inserts int3 after non-returning calls at the end of basic blocks
so that gc pointer liveness doesn't change across calls. This is additional
insurance in case any other place in runtime is dependent on that contract.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>dotnet-bot</Assignee>
    <CreatedAt>13/04/2018 1:08:59 AM +00:00</CreatedAt>
    <ClosedAt>13/04/2018 11:29:12 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17534</IssueLabelID>
    <Title>The crossgen tool should accept Portable PDBs as input</Title>
    <Description>On Windows crossgen only accepts Windows PDBs as input when creating the crossgen PDB (/CreatePDB option).</Description>
    <Title_Description>The crossgen tool should accept Portable PDBs as input On Windows crossgen only accepts Windows PDBs as input when creating the crossgen PDB (/CreatePDB option).</Title_Description>
    <Label>area-CrossGen/NGEN</Label>
    <Assignee>mikem8361</Assignee>
    <CreatedAt>12/04/2018 11:30:42 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17533</IssueLabelID>
    <Title>Make Windows builds always portable</Title>
    <Description>Apparently there is little or no need for a non-portable Windows build so
rather than trying to figure out which version of Windows we are building
on just ignore -PortableBuild=false.  We can add a warning or refuse to
accept the switch later if necessary but for now we need to continue
accepting it to avoid build breaks.

Fixes #14291</Description>
    <Title_Description>Make Windows builds always portable Apparently there is little or no need for a non-portable Windows build so
rather than trying to figure out which version of Windows we are building
on just ignore -PortableBuild=false.  We can add a warning or refuse to
accept the switch later if necessary but for now we need to continue
accepting it to avoid build breaks.

Fixes #14291</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>12/04/2018 11:18:37 PM +00:00</CreatedAt>
    <ClosedAt>14/04/2018 2:21:04 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17532</IssueLabelID>
    <Title>Remove CreateFromPinnedArray from Memory (moved to MemoryMarshal)</Title>
    <Description>Part of https://github.com/dotnet/corefx/issues/28954

Corefx side (remove from ref): https://github.com/dotnet/corefx/pull/29077

Related PR: https://github.com/dotnet/coreclr/pull/17500</Description>
    <Title_Description>Remove CreateFromPinnedArray from Memory (moved to MemoryMarshal) Part of https://github.com/dotnet/corefx/issues/28954

Corefx side (remove from ref): https://github.com/dotnet/corefx/pull/29077

Related PR: https://github.com/dotnet/coreclr/pull/17500</Title_Description>
    <Label>area-System.Memory</Label>
    <Assignee>ahsonkhan</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17531</IssueLabelID>
    <Title>Protect SuperPMI from crashes calling jitStartup</Title>
    <Description>When we call jitStartup we pass a JitHost interface that the JIT
calls to query for data. These queries look up in the recorded
MCH data and could fail (and throw an exception) if data is
missing which it can be for running non-matching altjit against
a collection. Protect these calls with exception handling.</Description>
    <Title_Description>Protect SuperPMI from crashes calling jitStartup When we call jitStartup we pass a JitHost interface that the JIT
calls to query for data. These queries look up in the recorded
MCH data and could fail (and throw an exception) if data is
missing which it can be for running non-matching altjit against
a collection. Protect these calls with exception handling.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>dotnet-bot</Assignee>
    <CreatedAt>12/04/2018 8:57:36 PM +00:00</CreatedAt>
    <ClosedAt>13/04/2018 9:02:10 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17530</IssueLabelID>
    <Title>Adding GetChunks which allow efficient scanning of a StringBuilder</Title>
    <Description>This change is the start of addressing the issue  CoreFX issue 

https://github.com/dotnet/corefx/issues/21248

which wants to have an efficient way of reading the characters of a StringBuilder.      However it has morphed alot since then (from a callback to an iterator model).   The API review part of this is the following issue. 

https://github.com/dotnet/corefx/issues/29770

This PR is an implementation of that spec.  In particular we implement the following new method on StringBuilder. 

The PR contains the actual implementation.    Note that ChunkEnumerable does not actually implement IEnumerable&lt;ReadOnlyMemory&lt;char&gt;&gt;.  

We considered having it return ReadOnlySpan but decided that it was too fragile in that Span can't be used across 'await' calls and can't be passed to methods that MAY be async.   ReadOnlyMemory does not have this problem (but is a bit less efficient) but does require you to convert it to a Span before accessing the characters (and notice you need to cache the span in a local variable to keep span creation out of the inner loop).    

This is not ideal but is this issue will resurface other places (whenever we want to return chunks) and so it is likely we will invest in JIT optimization to optimize away any inefficiency of using ReadOnlyMemory and converting immediately to Span (which is what would happen in the synchronous case).  
 
At this point it is ready for API review.    This amounts to signing off on using ReadOnlyMemory instead of ReadOnlySpan and the names (is 'Chunks' the right suffix?) and the fact that ChunkEnumerable does not actually implement IEnumerable&lt;ReadOnlyMemory&lt;char&gt;&gt; (It could it is just more code (which we can add later)).  

I have tests however there seems to be a chicken and egg problem in that you need to have an implementation before CoreFX can expose it (and have tests for it).    I have tested the code (all code paths are covered) but I will need to check in tests as a separate PR.  </Description>
    <Title_Description>Adding GetChunks which allow efficient scanning of a StringBuilder This change is the start of addressing the issue  CoreFX issue 

https://github.com/dotnet/corefx/issues/21248

which wants to have an efficient way of reading the characters of a StringBuilder.      However it has morphed alot since then (from a callback to an iterator model).   The API review part of this is the following issue. 

https://github.com/dotnet/corefx/issues/29770

This PR is an implementation of that spec.  In particular we implement the following new method on StringBuilder. 

The PR contains the actual implementation.    Note that ChunkEnumerable does not actually implement IEnumerable&lt;ReadOnlyMemory&lt;char&gt;&gt;.  

We considered having it return ReadOnlySpan but decided that it was too fragile in that Span can't be used across 'await' calls and can't be passed to methods that MAY be async.   ReadOnlyMemory does not have this problem (but is a bit less efficient) but does require you to convert it to a Span before accessing the characters (and notice you need to cache the span in a local variable to keep span creation out of the inner loop).    

This is not ideal but is this issue will resurface other places (whenever we want to return chunks) and so it is likely we will invest in JIT optimization to optimize away any inefficiency of using ReadOnlyMemory and converting immediately to Span (which is what would happen in the synchronous case).  
 
At this point it is ready for API review.    This amounts to signing off on using ReadOnlyMemory instead of ReadOnlySpan and the names (is 'Chunks' the right suffix?) and the fact that ChunkEnumerable does not actually implement IEnumerable&lt;ReadOnlyMemory&lt;char&gt;&gt; (It could it is just more code (which we can add later)).  

I have tests however there seems to be a chicken and egg problem in that you need to have an implementation before CoreFX can expose it (and have tests for it).    I have tested the code (all code paths are covered) but I will need to check in tests as a separate PR.  </Title_Description>
    <Label>area-System.Runtime</Label>
    <Assignee>vancem</Assignee>
    <CreatedAt>12/04/2018 3:00:40 PM +00:00</CreatedAt>
    <ClosedAt>22/05/2018 11:07:46 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17529</IssueLabelID>
    <Title>unable to run after upgrading to .net 2.0 =&gt; 2.1 [terminating with uncaught exception of type EEFileLoadException*]</Title>
    <Description># terminating with uncaught exception of type EEFileLoadException*

when in ( visual studio code [mac os x] ) I go debug --&gt;  run
It never runs everything fails with:  terminating with uncaught exception of type EEFileLoadException*

All I have done is upgraded 2.0 -&gt; 2.1   changed launch.json  to the following:

"program": "${workspaceFolder}/bin/Debug/netcoreapp2.1/NetSo.dll"

Update nuget

removed DotNetCliToolReference  as they are no longer needed   ( now part of SDK )

Run  dotnet build  ( success )

and then run  

# General

dotnet --version
2.1.300-preview2-008530


I get no other output as this seems to be more of a fail to launch issue than a code issue
especially as no code changes have taken place  and no code exceptions are thrown.   This seems more like that MACOS  wont run the new core framework.

I have attached the output from OSX  for clarity.  Any advice would be much appreciated.

[core-crash.mac.txt](https://github.com/dotnet/coreclr/files/1903405/core-crash.mac.txt)


</Description>
    <Title_Description>unable to run after upgrading to .net 2.0 =&gt; 2.1 [terminating with uncaught exception of type EEFileLoadException*] # terminating with uncaught exception of type EEFileLoadException*

when in ( visual studio code [mac os x] ) I go debug --&gt;  run
It never runs everything fails with:  terminating with uncaught exception of type EEFileLoadException*

All I have done is upgraded 2.0 -&gt; 2.1   changed launch.json  to the following:

"program": "${workspaceFolder}/bin/Debug/netcoreapp2.1/NetSo.dll"

Update nuget

removed DotNetCliToolReference  as they are no longer needed   ( now part of SDK )

Run  dotnet build  ( success )

and then run  

# General

dotnet --version
2.1.300-preview2-008530


I get no other output as this seems to be more of a fail to launch issue than a code issue
especially as no code changes have taken place  and no code exceptions are thrown.   This seems more like that MACOS  wont run the new core framework.

I have attached the output from OSX  for clarity.  Any advice would be much appreciated.

[core-crash.mac.txt](https://github.com/dotnet/coreclr/files/1903405/core-crash.mac.txt)


</Title_Description>
    <Label>area-ExceptionHandling</Label>
    <Assignee>janvorli</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17528</IssueLabelID>
    <Title>Add Path.TryGetRandomFileName()</Title>
    <Description>clr part of  https://github.com/dotnet/corefx/issues/28256
test for corefx are [ready](https://github.com/dotnet/corefx/compare/master...MarcoRossignoli:trygetrandomfilename)
cc: @JeremyKuhne @jkotas  @Anipik </Description>
    <Title_Description>Add Path.TryGetRandomFileName() clr part of  https://github.com/dotnet/corefx/issues/28256
test for corefx are [ready](https://github.com/dotnet/corefx/compare/master...MarcoRossignoli:trygetrandomfilename)
cc: @JeremyKuhne @jkotas  @Anipik </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>JeremyKuhne</Assignee>
    <CreatedAt>12/04/2018 11:19:19 AM +00:00</CreatedAt>
    <ClosedAt>19/06/2018 6:15:16 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17524</IssueLabelID>
    <Title>Avoid creating illegal byref pointers</Title>
    <Description>Byref pointers need to point within their "host" object -- thus
the alternate name "interior pointers". If the JIT creates and
reports a pointer as a "byref" but it points outside the host
object and a GC occurs that moves the host object the byref
pointer will not be updated. If a subsequent calculation puts
the byref "back" into the host object it will actually be pointing
to garbage since the host object has moved.

This occurred on ARM with array index calculations in particular
because ARM doesn't have a single-instruction "base + scale*index + offset"
addressing mode. Thus we were generating for the jaggedarr_cs_do
test case . This
optimization creates "incorrect" byrefs that don't necessarily point within
the host object.

These fixes are all-platform.

Fixes #17517.

There are many many diffs. They perhaps surprisingly overwhelmingly positive.

For AMD64 SuperPMI the diffs are a 7.6% size win for 5194 functions! This
appears to be due to less code cloning and sometimes better optimization.

For ARM32 ngen-based desktop asm diffs it is a 0.30% improvement across all
framework assemblies. A lot of the diffs seem to be because we CSE the entire
array address offset expression not just the index expression.</Description>
    <Title_Description>Avoid creating illegal byref pointers Byref pointers need to point within their "host" object -- thus
the alternate name "interior pointers". If the JIT creates and
reports a pointer as a "byref" but it points outside the host
object and a GC occurs that moves the host object the byref
pointer will not be updated. If a subsequent calculation puts
the byref "back" into the host object it will actually be pointing
to garbage since the host object has moved.

This occurred on ARM with array index calculations in particular
because ARM doesn't have a single-instruction "base + scale*index + offset"
addressing mode. Thus we were generating for the jaggedarr_cs_do
test case . This
optimization creates "incorrect" byrefs that don't necessarily point within
the host object.

These fixes are all-platform.

Fixes #17517.

There are many many diffs. They perhaps surprisingly overwhelmingly positive.

For AMD64 SuperPMI the diffs are a 7.6% size win for 5194 functions! This
appears to be due to less code cloning and sometimes better optimization.

For ARM32 ngen-based desktop asm diffs it is a 0.30% improvement across all
framework assemblies. A lot of the diffs seem to be because we CSE the entire
array address offset expression not just the index expression.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>dotnet-bot</Assignee>
    <CreatedAt>12/04/2018 3:59:00 AM +00:00</CreatedAt>
    <ClosedAt>14/04/2018 6:11:29 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17523</IssueLabelID>
    <Title>Fix random Segfaults on Ubuntu arm</Title>
    <Description>Fixes #17449 #16963

/cc @sandreenko</Description>
    <Title_Description>Fix random Segfaults on Ubuntu arm Fixes #17449 #16963

/cc @sandreenko</Title_Description>
    <Label>area-PAL</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>12/04/2018 1:33:47 AM +00:00</CreatedAt>
    <ClosedAt>14/04/2018 7:24:59 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17522</IssueLabelID>
    <Title>[WIP] test Egor's arm fix</Title>
    <Description>
    </Description>
    <Title_Description>[WIP] test Egor's arm fix </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>12/04/2018 12:43:35 AM +00:00</CreatedAt>
    <ClosedAt>16/04/2018 8:12:14 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17521</IssueLabelID>
    <Title>Preserve VASigCookieReg across PInvokeStubWorker call</Title>
    <Description>I noticed something risky in this stub. We don't ensure that VASigCookieReg is preserved (if it's a temporary register we don't know what may happen to it in the call to the PInvokeStubWorker). Let's save it in a callee-saved register so that when we come back after stub generation we still have the correct value for the VASigCookie.

@janvorli PTAL</Description>
    <Title_Description>Preserve VASigCookieReg across PInvokeStubWorker call I noticed something risky in this stub. We don't ensure that VASigCookieReg is preserved (if it's a temporary register we don't know what may happen to it in the call to the PInvokeStubWorker). Let's save it in a callee-saved register so that when we come back after stub generation we still have the correct value for the VASigCookie.

@janvorli PTAL</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>janvorli</Assignee>
    <CreatedAt>11/04/2018 10:35:01 PM +00:00</CreatedAt>
    <ClosedAt>13/04/2018 12:25:40 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17519</IssueLabelID>
    <Title>[RyuJit] Allow TYP_BYREF folding.</Title>
    <Description>Right now  has such code:
https://github.com/dotnet/coreclr/blob/b800f37c504d30c25bda3bdf148966fa91d17381/src/jit/valuenum.cpp#L1100-L1105

but there are no reasons why we can't support it it looks like we should just change this part:
https://github.com/dotnet/coreclr/blob/b800f37c504d30c25bda3bdf148966fa91d17381/src/jit/valuenum.cpp#L1812

From discussion in #17506 .



category:cq
theme:value-numbering
skill-level:intermediate
cost:small</Description>
    <Title_Description>[RyuJit] Allow TYP_BYREF folding. Right now  has such code:
https://github.com/dotnet/coreclr/blob/b800f37c504d30c25bda3bdf148966fa91d17381/src/jit/valuenum.cpp#L1100-L1105

but there are no reasons why we can't support it it looks like we should just change this part:
https://github.com/dotnet/coreclr/blob/b800f37c504d30c25bda3bdf148966fa91d17381/src/jit/valuenum.cpp#L1812

From discussion in #17506 .



category:cq
theme:value-numbering
skill-level:intermediate
cost:small</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>11/04/2018 8:59:14 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17517</IssueLabelID>
    <Title>[RyuJIT/arm32][GCStress=C] jaggedarr_cs_do.cmd failure</Title>
    <Description>https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_windows_nt_gcstress0xc_tst/18/artifact/bin/tests/Windows_NT.arm.Checked/Smarty.run.0/Smarty.0.fail.smrt/*view*/
https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_windows_nt_gcstress0xc_jitstress1_tst/16/artifact/bin/tests/Windows_NT.arm.Checked/Smarty.run.0/Smarty.0.fail.smrt/*view*/

This failure is fairly consistent. I can reproduce it locally most of the time. Note that the test is seeded with a random number which doesn't help reproducibility.
</Description>
    <Title_Description>[RyuJIT/arm32][GCStress=C] jaggedarr_cs_do.cmd failure https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_windows_nt_gcstress0xc_tst/18/artifact/bin/tests/Windows_NT.arm.Checked/Smarty.run.0/Smarty.0.fail.smrt/*view*/
https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_windows_nt_gcstress0xc_jitstress1_tst/16/artifact/bin/tests/Windows_NT.arm.Checked/Smarty.run.0/Smarty.0.fail.smrt/*view*/

This failure is fairly consistent. I can reproduce it locally most of the time. Note that the test is seeded with a random number which doesn't help reproducibility.
</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>BruceForstall</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17516</IssueLabelID>
    <Title>[1.1] Add packaging for Fedora28 and Debian9</Title>
    <Description>cc: @weshaggard @janvorli </Description>
    <Title_Description>[1.1] Add packaging for Fedora28 and Debian9 cc: @weshaggard @janvorli </Title_Description>
    <Label>
    </Label>
    <Assignee>ianhays</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17515</IssueLabelID>
    <Title>Mirror changes from dotnet/corert</Title>
    <Description>This PR contains mirrored changes from dotnet/corert


**Please REBASE this PR when merging**</Description>
    <Title_Description>Mirror changes from dotnet/corert This PR contains mirrored changes from dotnet/corert


**Please REBASE this PR when merging**</Title_Description>
    <Label>
    </Label>
    <Assignee>jkotas</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17513</IssueLabelID>
    <Title>[X86] Fix cross toolchain library paths</Title>
    <Description>	- fix internal tests building

@dotnet/arm32-contrib please review</Description>
    <Title_Description>[X86] Fix cross toolchain library paths 	- fix internal tests building

@dotnet/arm32-contrib please review</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>sergign60</Assignee>
    <CreatedAt>11/04/2018 1:11:56 PM +00:00</CreatedAt>
    <ClosedAt>17/04/2018 1:14:22 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17512</IssueLabelID>
    <Title>Use string.IsNullOrEmpty to eliminate bounds check to first char</Title>
    <Description>
    </Description>
    <Title_Description>Use string.IsNullOrEmpty to eliminate bounds check to first char </Title_Description>
    <Label>area-System.Runtime</Label>
    <Assignee>AndyAyersMS</Assignee>
    <CreatedAt>11/04/2018 11:35:35 AM +00:00</CreatedAt>
    <ClosedAt>12/04/2018 9:08:05 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17510</IssueLabelID>
    <Title>Korean Lunisolar Calendar conversion table incorrectly mixes Julian and Gregorian date information</Title>
    <Description>The [Korean Lunisolar Calendar](https://github.com/dotnet/coreclr/blob/da8b7181dbe362fbfe64c7ef72ff3a4a7db68f24/src/mscorlib/shared/System/Globalization/KoreanLunisolarCalendar.cs) uses a table of data for conversion between Korean lunisolar dates and Gregorian dates.  The table contains a mixture of Julian and Gregorian date information but should only contain Gregorian date information.

On such entry is:


This is interpreted by the code as:
Y1391-M1-D1 of Korean lunisolar calendar began on 5 Feb 1391 (Gregorian).

However Y1391-M1-D1 (lunisolar) began on 13 Feb 1391 (**Gregorian**) or 05 Feb 1391 (Julian).  The entry incorrectly uses the day and month from the Julian date and it should use day and month from the Gregorian one.

Further analysis shows that all lines in the table prior to 1582 incorrectly give the first day of the lunisolar year in the **Julian** calendar _rather than the Gregorian calendar_.  Since the conversion routine takes a Gregorian day month and year for conversion into the lunisolar day month and year any conversions to dates with a solar year before 1583 are incorrect.

The discrepancy likely arises due to the fact that many reference tables switch from using the Julian calendar to the Gregorian calendar in year 1582 (04 Oct 1582 (Julian) was followed by 15 Oct 1582 (Gregorian)).  One such table is provided by the [Korea Astronomy and Space Science In-
stitute (KASI)](https://astro.kasi.re.kr:444/life/pageView/5).  Here dates prior to Y1582-M09-D18 (lunisolar) are indexed using the Julian calendar and those after Y1582-M09-D19 (lunisolar) are indexed using the Gregorian calendar.

There are also anomalous entries in the .NET table when compared to KASI.
The first day of the year is incorrect for 1587 1648 and 1754.  Most notably the entry for 1587 gives 09 Mar 1587 (Gregorian) as the start date of lunisolar year (this is the first day Y1587-M02-D01 (lunisolar) instead of Y1587-M01-D01 (lunisolar)).  The individual month lengths differ from KASI in 1586 1587 1659 1692 1753 and 1754.

The table used in the .NET class has been corrected here:
[correct Korean lunisolar .NET table.txt](https://github.com/dotnet/coreclr/files/1898816/correct.Korean.lunisolar.NET.table.txt)

Reference data: 
[Korea Astronomy and Space Science In-
stitute (KASI)](https://astro.kasi.re.kr:444/life/pageView/5).
[VERIFICATION OF THE CALENDAR DAYS OF THE JOSEON DYNASTY](http://dx.doi.org/10.5303/JKAS.2012.45.4.85)
[KoreanLunisolarCalendar.cs](https://github.com/dotnet/coreclr/blob/da8b7181dbe362fbfe64c7ef72ff3a4a7db68f24/src/mscorlib/shared/System/Globalization/KoreanLunisolarCalendar.cs)</Description>
    <Title_Description>Korean Lunisolar Calendar conversion table incorrectly mixes Julian and Gregorian date information The [Korean Lunisolar Calendar](https://github.com/dotnet/coreclr/blob/da8b7181dbe362fbfe64c7ef72ff3a4a7db68f24/src/mscorlib/shared/System/Globalization/KoreanLunisolarCalendar.cs) uses a table of data for conversion between Korean lunisolar dates and Gregorian dates.  The table contains a mixture of Julian and Gregorian date information but should only contain Gregorian date information.

On such entry is:


This is interpreted by the code as:
Y1391-M1-D1 of Korean lunisolar calendar began on 5 Feb 1391 (Gregorian).

However Y1391-M1-D1 (lunisolar) began on 13 Feb 1391 (**Gregorian**) or 05 Feb 1391 (Julian).  The entry incorrectly uses the day and month from the Julian date and it should use day and month from the Gregorian one.

Further analysis shows that all lines in the table prior to 1582 incorrectly give the first day of the lunisolar year in the **Julian** calendar _rather than the Gregorian calendar_.  Since the conversion routine takes a Gregorian day month and year for conversion into the lunisolar day month and year any conversions to dates with a solar year before 1583 are incorrect.

The discrepancy likely arises due to the fact that many reference tables switch from using the Julian calendar to the Gregorian calendar in year 1582 (04 Oct 1582 (Julian) was followed by 15 Oct 1582 (Gregorian)).  One such table is provided by the [Korea Astronomy and Space Science In-
stitute (KASI)](https://astro.kasi.re.kr:444/life/pageView/5).  Here dates prior to Y1582-M09-D18 (lunisolar) are indexed using the Julian calendar and those after Y1582-M09-D19 (lunisolar) are indexed using the Gregorian calendar.

There are also anomalous entries in the .NET table when compared to KASI.
The first day of the year is incorrect for 1587 1648 and 1754.  Most notably the entry for 1587 gives 09 Mar 1587 (Gregorian) as the start date of lunisolar year (this is the first day Y1587-M02-D01 (lunisolar) instead of Y1587-M01-D01 (lunisolar)).  The individual month lengths differ from KASI in 1586 1587 1659 1692 1753 and 1754.

The table used in the .NET class has been corrected here:
[correct Korean lunisolar .NET table.txt](https://github.com/dotnet/coreclr/files/1898816/correct.Korean.lunisolar.NET.table.txt)

Reference data: 
[Korea Astronomy and Space Science In-
stitute (KASI)](https://astro.kasi.re.kr:444/life/pageView/5).
[VERIFICATION OF THE CALENDAR DAYS OF THE JOSEON DYNASTY](http://dx.doi.org/10.5303/JKAS.2012.45.4.85)
[KoreanLunisolarCalendar.cs](https://github.com/dotnet/coreclr/blob/da8b7181dbe362fbfe64c7ef72ff3a4a7db68f24/src/mscorlib/shared/System/Globalization/KoreanLunisolarCalendar.cs)</Title_Description>
    <Label>area-System.Globalization</Label>
    <Assignee>tarekgh</Assignee>
    <CreatedAt>11/04/2018 10:05:42 AM +00:00</CreatedAt>
    <ClosedAt>16/04/2018 6:06:08 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17508</IssueLabelID>
    <Title>[Arm64] Fix WorkStealingQueue memory ordering</Title>
    <Description>Fixes #17178

Audited and reworked WorkStealingQueue to take into account multi-threaded memory ordering issues encountered on high core count arm64 testing.

This fixes easily reproducible errors in  if this is deemed too risky for other platforms.  (I suspect arm32 needs a similar/identical patch).

@BruceForstall FYI</Description>
    <Title_Description>[Arm64] Fix WorkStealingQueue memory ordering Fixes #17178

Audited and reworked WorkStealingQueue to take into account multi-threaded memory ordering issues encountered on high core count arm64 testing.

This fixes easily reproducible errors in  if this is deemed too risky for other platforms.  (I suspect arm32 needs a similar/identical patch).

@BruceForstall FYI</Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>dotnet-bot</Assignee>
    <CreatedAt>11/04/2018 3:11:20 AM +00:00</CreatedAt>
    <ClosedAt>15/04/2018 11:28:30 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17506</IssueLabelID>
    <Title>Fix Valuenum:EvalFuncForConstantArgs</Title>
    <Description>For such tree:


The original code was added in CS 946058 with other assert fixes and looks like we were lucky not to hit this issue for several years because CoreCLR doesn't produce constants with 'TYP_BYREF' (I think).

&gt; // We don't want to fold expressions that produce TYP_BYREF 

I do not see any reasons why we should not fold them but right now this code:
https://github.com/dotnet/coreclr/blob/master/src/jit/valuenum.cpp#L1813-L1817

doesn't not expect LONG add that produces BYREF and because our VN is very fragile we do not want to change it before the release **do we want to have an issue to fix that later?**

The change will fix (some text to prevent closing this issue right after the merge) dotnet/corert#5661 after RyuJit version update.
</Description>
    <Title_Description>Fix Valuenum:EvalFuncForConstantArgs For such tree:


The original code was added in CS 946058 with other assert fixes and looks like we were lucky not to hit this issue for several years because CoreCLR doesn't produce constants with 'TYP_BYREF' (I think).

&gt; // We don't want to fold expressions that produce TYP_BYREF 

I do not see any reasons why we should not fold them but right now this code:
https://github.com/dotnet/coreclr/blob/master/src/jit/valuenum.cpp#L1813-L1817

doesn't not expect LONG add that produces BYREF and because our VN is very fragile we do not want to change it before the release **do we want to have an issue to fix that later?**

The change will fix (some text to prevent closing this issue right after the merge) dotnet/corert#5661 after RyuJit version update.
</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>10/04/2018 11:34:42 PM +00:00</CreatedAt>
    <ClosedAt>11/04/2018 8:16:23 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17505</IssueLabelID>
    <Title>Enable support DllImport a native assembly whose name contains '.'</Title>
    <Description>Currently In Windows if the name your native dll specified in DllImport contains '.' such as Test.Foo DllImport will only search for file Test.Foo and it won't search for file Test.Foo.dll

The fix is to append ".dll" if the native dll name specified in DllImport doesn't contain ".dll" .

Fix #17150</Description>
    <Title_Description>Enable support DllImport a native assembly whose name contains '.' Currently In Windows if the name your native dll specified in DllImport contains '.' such as Test.Foo DllImport will only search for file Test.Foo and it won't search for file Test.Foo.dll

The fix is to append ".dll" if the native dll name specified in DllImport doesn't contain ".dll" .

Fix #17150</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>dotnet-bot</Assignee>
    <CreatedAt>10/04/2018 11:33:55 PM +00:00</CreatedAt>
    <ClosedAt>17/04/2018 5:10:30 AM +00:00</ClosedAt>
  </IssueDetail>
</IssueDetails>