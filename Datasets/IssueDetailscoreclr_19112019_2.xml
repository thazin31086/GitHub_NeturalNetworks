<IssueDetails>
  <IssueDetail>
    <IssueLabelID>19814</IssueLabelID>
    <Title>Local test run experience is systematically degrading</Title>
    <Description>Observing recent changes to the test run infrastructure I have been impacted by the following problems:

1. Test run startup is painfully slow
    1. Python script runs very slow and seems to be very inefficient (it may take up to 2 - 3 min before actual tests start
    2. Test discovery after CoreRun is launched takes ad infinitum in comparison to experience from before couple of weeks

2. Test run info:
    1. Std out info is polluted with multiple error messages from python script
    2. There is no summary table after test run if tests fail - it was possible so far to see breakdown of failing tests per XUnit wrapper

</Description>
    <Title_Description>Local test run experience is systematically degrading Observing recent changes to the test run infrastructure I have been impacted by the following problems:

1. Test run startup is painfully slow
    1. Python script runs very slow and seems to be very inefficient (it may take up to 2 - 3 min before actual tests start
    2. Test discovery after CoreRun is launched takes ad infinitum in comparison to experience from before couple of weeks

2. Test run info:
    1. Std out info is polluted with multiple error messages from python script
    2. There is no summary table after test run if tests fail - it was possible so far to see breakdown of failing tests per XUnit wrapper

</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>3/09/2018 10:09:37 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19812</IssueLabelID>
    <Title>Fix ICU load on OpenSUSE Tumbleweed</Title>
    <Description>For some reason OpenSUSE Tumbleweed has decided to prefix the
version number in the SO name of the ICU libraries by "suse".
That prevents our ICU version detection code from working.

This change adds scanning for SO names that contain that prefix too.</Description>
    <Title_Description>Fix ICU load on OpenSUSE Tumbleweed For some reason OpenSUSE Tumbleweed has decided to prefix the
version number in the SO name of the ICU libraries by "suse".
That prevents our ICU version detection code from working.

This change adds scanning for SO names that contain that prefix too.</Title_Description>
    <Label>area-System.Globalization</Label>
    <Assignee>janvorli</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19810</IssueLabelID>
    <Title>Allow StructLayoutAttribute to specify automatic size rounding up to next power of 2 for better perf</Title>
    <Description>One of the uses is - say there is raw buffer allocated for N instances of structure which may contain generic fields say constrained with `unmanaged` or `struct` but I believe this constraint is not really important as well as it may not necessarily be related just to VT containers but to RTs too. Right now when there are such fields included in containing instance there is no way to ensure this size rounding by attaching any specific value to `Size` parameter in `StructLayoutAttribute` because size of the field (or fields) may be unknown at compile time (eg. class library).

There are two points which may get performance improvement for the example:
- when calculating structure offset from the beginning of the buffer eg. by `... * Unsafe.SizeOf&lt;T&gt;()` or `... * sizeof(T)` (for `T : unmanaged`) there will be no need for `MUL` or sequence of `LEA`s but single `SHL` will be enough (or single `LEA` if the structure size being aligned is 3 or 5 to 7 bytes).
- when calculating structure index from reference or pointer relative to the beginning of buffer (which is done eg. by `... / Unsafe.SizeOf&lt;T&gt;()` or `... / sizeof(T)` (again for `T : unmanaged`) there will be no need for `DIV` (the worst case) or `MUL` with magic numbers and shifts to compensate - just single plain `SHR`.

In my somewhat skewed benchmarks manually rounding up structure sizes shows execution time improvement up to x1.5-2.</Description>
    <Title_Description>Allow StructLayoutAttribute to specify automatic size rounding up to next power of 2 for better perf One of the uses is - say there is raw buffer allocated for N instances of structure which may contain generic fields say constrained with `unmanaged` or `struct` but I believe this constraint is not really important as well as it may not necessarily be related just to VT containers but to RTs too. Right now when there are such fields included in containing instance there is no way to ensure this size rounding by attaching any specific value to `Size` parameter in `StructLayoutAttribute` because size of the field (or fields) may be unknown at compile time (eg. class library).

There are two points which may get performance improvement for the example:
- when calculating structure offset from the beginning of the buffer eg. by `... * Unsafe.SizeOf&lt;T&gt;()` or `... * sizeof(T)` (for `T : unmanaged`) there will be no need for `MUL` or sequence of `LEA`s but single `SHL` will be enough (or single `LEA` if the structure size being aligned is 3 or 5 to 7 bytes).
- when calculating structure index from reference or pointer relative to the beginning of buffer (which is done eg. by `... / Unsafe.SizeOf&lt;T&gt;()` or `... / sizeof(T)` (again for `T : unmanaged`) there will be no need for `DIV` (the worst case) or `MUL` with magic numbers and shifts to compensate - just single plain `SHR`.

In my somewhat skewed benchmarks manually rounding up structure sizes shows execution time improvement up to x1.5-2.</Title_Description>
    <Label>area-TypeSystem</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>3/09/2018 6:29:43 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19807</IssueLabelID>
    <Title>Missing IL offset information sometimes causes bad stack traces</Title>
    <Description>The repro is here: [https://github.com/evgrud/dotnet-stack-trace-offsets-issue](https://github.com/evgrud/dotnet-stack-trace-offsets-issue)

When running it on Release (with tiered compilation disabled) you will see that the stack trace of the exception that is thrown points to the beginning of the function while the correct location is at its end.

I tested it on Windows 10 x64.

I ran it with JITDump and it seems that during `impImportCall` some of the statements aren't getting IL offsets which later during the inlining are expanded into new basic blocks without IL offsets which eventually during runtime results in a bad stack trace when an exception is thrown within those basic blocks.

I don't know if this issue should be fixed but I can suggest reporting native offsets in those cases instead of pointing to the top of the function which could be way off.

category:implementation
theme:debug-info
skill-level:intermediate
cost:small</Description>
    <Title_Description>Missing IL offset information sometimes causes bad stack traces The repro is here: [https://github.com/evgrud/dotnet-stack-trace-offsets-issue](https://github.com/evgrud/dotnet-stack-trace-offsets-issue)

When running it on Release (with tiered compilation disabled) you will see that the stack trace of the exception that is thrown points to the beginning of the function while the correct location is at its end.

I tested it on Windows 10 x64.

I ran it with JITDump and it seems that during `impImportCall` some of the statements aren't getting IL offsets which later during the inlining are expanded into new basic blocks without IL offsets which eventually during runtime results in a bad stack trace when an exception is thrown within those basic blocks.

I don't know if this issue should be fixed but I can suggest reporting native offsets in those cases instead of pointing to the top of the function which could be way off.

category:implementation
theme:debug-info
skill-level:intermediate
cost:small</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19806</IssueLabelID>
    <Title>Not consistent integer remainder behavior at the corner case</Title>
    <Description>The remainder operator under consideration is the [% operator](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/expressions#remainder-operator)

The corner case is the following:
- the left operand equals `int.MinValue`
- the right operand equals `-1`

The referenced above draft C# 6 language specification says:
&gt; If the left operand is the smallest `int` or `long` value and the right operand is `-1` a `System.OverflowException` is thrown. In no case does `x % y` throw an exception where `x / y` would not throw an exception.

The following code demonstrates not consistent behavior 
```csharp
using System;

class Program
{
    static void Main(string[] args)
    {
        Console.WriteLine(int.MinValue % -1);

        int a = int.MinValue;
        int b = -1;
        try
        {
            Console.WriteLine(a % b);
        }
        catch (OverflowException e)
        {
            Console.WriteLine(e.Message);
        }
    }
}
```

produces (copy/paste and run in [try.dot.net](https://try.dot.net/) for example) the following output
```
0
Arithmetic operation resulted in an overflow.
```

First `Console.WriteLine(int.MinValue % -1);` doesn't throw but produces zero. It's not according to the first quoted spec sentence
&gt; If the left operand is the smallest `int` or `long` value and the right operand is `-1` a `System.OverflowException` is thrown.

OK the spec might have changed but if we use variables instead of constants: `Console.WriteLine(a % b);` throws given
```csharp
int a = int.MinValue;
int b = -1;
```

Regardless of the outcome (according to the spec or not) I would expect both outcomes at least be the same.

Seems that compiler converts `int.MinValue % -1` into zero (against the spec) and .NET doesn't mirror that behavior yet.</Description>
    <Title_Description>Not consistent integer remainder behavior at the corner case The remainder operator under consideration is the [% operator](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/expressions#remainder-operator)

The corner case is the following:
- the left operand equals `int.MinValue`
- the right operand equals `-1`

The referenced above draft C# 6 language specification says:
&gt; If the left operand is the smallest `int` or `long` value and the right operand is `-1` a `System.OverflowException` is thrown. In no case does `x % y` throw an exception where `x / y` would not throw an exception.

The following code demonstrates not consistent behavior 
```csharp
using System;

class Program
{
    static void Main(string[] args)
    {
        Console.WriteLine(int.MinValue % -1);

        int a = int.MinValue;
        int b = -1;
        try
        {
            Console.WriteLine(a % b);
        }
        catch (OverflowException e)
        {
            Console.WriteLine(e.Message);
        }
    }
}
```

produces (copy/paste and run in [try.dot.net](https://try.dot.net/) for example) the following output
```
0
Arithmetic operation resulted in an overflow.
```

First `Console.WriteLine(int.MinValue % -1);` doesn't throw but produces zero. It's not according to the first quoted spec sentence
&gt; If the left operand is the smallest `int` or `long` value and the right operand is `-1` a `System.OverflowException` is thrown.

OK the spec might have changed but if we use variables instead of constants: `Console.WriteLine(a % b);` throws given
```csharp
int a = int.MinValue;
int b = -1;
```

Regardless of the outcome (according to the spec or not) I would expect both outcomes at least be the same.

Seems that compiler converts `int.MinValue % -1` into zero (against the spec) and .NET doesn't mirror that behavior yet.</Title_Description>
    <Label>tracking-external-issue</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>2/09/2018 8:36:20 PM +00:00</CreatedAt>
    <ClosedAt>3/09/2018 5:35:16 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19805</IssueLabelID>
    <Title>[arm64|Unix] segmentation fault when running any test</Title>
    <Description>Stack trace below.

```
#0  Object::ValidateInner (this=0xa bDeep=1 bVerifyNextHeader=1 bVerifySyncBlock=1) at /coreclr/src/vm/object.cpp:729
#1  0x0000007fb708e240 in OBJECTREF::OBJECTREF (this=0x7fffffcbd0 pObject=0xa) at /coreclr/src/vm/object.cpp:1403
#2  0x0000007fb730b4a8 in TransitionFrame::GetThis (this=0x7fffffcbe0) at /coreclr/src/vm/frames.h:1000
#3  PreStubWorker (pTransitionBlock=&lt;optimized out&gt; pMD=0x7f3d6c79b0) at /coreclr/src/vm/prestub.cpp:1527
#4  0x0000007fb725ffc8 in ThePreStub () at /coreclr/src/vm/contractimpl.h:210
#5  0x0000007f3d56ee44 in ?? ()
#6  0x0000007f18009180 in ?? ()
```</Description>
    <Title_Description>[arm64|Unix] segmentation fault when running any test Stack trace below.

```
#0  Object::ValidateInner (this=0xa bDeep=1 bVerifyNextHeader=1 bVerifySyncBlock=1) at /coreclr/src/vm/object.cpp:729
#1  0x0000007fb708e240 in OBJECTREF::OBJECTREF (this=0x7fffffcbd0 pObject=0xa) at /coreclr/src/vm/object.cpp:1403
#2  0x0000007fb730b4a8 in TransitionFrame::GetThis (this=0x7fffffcbe0) at /coreclr/src/vm/frames.h:1000
#3  PreStubWorker (pTransitionBlock=&lt;optimized out&gt; pMD=0x7f3d6c79b0) at /coreclr/src/vm/prestub.cpp:1527
#4  0x0000007fb725ffc8 in ThePreStub () at /coreclr/src/vm/contractimpl.h:210
#5  0x0000007f3d56ee44 in ?? ()
#6  0x0000007f18009180 in ?? ()
```</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>jashook</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19804</IssueLabelID>
    <Title>Clean CodeGen::genEmitCall</Title>
    <Description>This PR cleans `emitter::emitIns_Call` by deleting two unnecessary arguments that made it harder to read and check (`isNoGC` `isProfLeaveCB`).

Also it refactors their code a bit and extracts common parts into platform independent methods.

Found during my work on #19361.

No diffs on x86/x64.</Description>
    <Title_Description>Clean CodeGen::genEmitCall This PR cleans `emitter::emitIns_Call` by deleting two unnecessary arguments that made it harder to read and check (`isNoGC` `isProfLeaveCB`).

Also it refactors their code a bit and extracts common parts into platform independent methods.

Found during my work on #19361.

No diffs on x86/x64.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>1/09/2018 7:31:06 PM +00:00</CreatedAt>
    <ClosedAt>6/09/2018 11:03:10 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19778</IssueLabelID>
    <Title>Add 2.2 sdk/runtime to JitBench</Title>
    <Description>
    </Description>
    <Title_Description>Add 2.2 sdk/runtime to JitBench </Title_Description>
    <Label>area-TieredCompilation</Label>
    <Assignee>kouvel</Assignee>
    <CreatedAt>30/08/2018 11:25:10 PM +00:00</CreatedAt>
    <ClosedAt>19/09/2018 10:29:02 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19777</IssueLabelID>
    <Title>[local gc] Enable gc_profiling for local gc</Title>
    <Description>Fix for #11515. It turns out most of the work had been done previously and my recent PR (#19500 ) did the remaining work. So all that was left was to re-enable the definition of `GC_PROFILING` for local gc</Description>
    <Title_Description>[local gc] Enable gc_profiling for local gc Fix for #11515. It turns out most of the work had been done previously and my recent PR (#19500 ) did the remaining work. So all that was left was to re-enable the definition of `GC_PROFILING` for local gc</Title_Description>
    <Label>area-GC</Label>
    <Assignee>davmason</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19776</IssueLabelID>
    <Title>[release/2.2] Change prerelease label to be more accurate</Title>
    <Description>Not critical but better than servicing</Description>
    <Title_Description>[release/2.2] Change prerelease label to be more accurate Not critical but better than servicing</Title_Description>
    <Label>
    </Label>
    <Assignee>weshaggard</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19774</IssueLabelID>
    <Title>[local gc]  move DacNotifyGCMarkEnd and AnalyzeSurvivorsRequested to GCToEEInterface </Title>
    <Description>Fix for #17771</Description>
    <Title_Description>[local gc]  move DacNotifyGCMarkEnd and AnalyzeSurvivorsRequested to GCToEEInterface  Fix for #17771</Title_Description>
    <Label>area-GC</Label>
    <Assignee>davmason</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19773</IssueLabelID>
    <Title>Add short guide for using tiered compilation and how to provide feedback</Title>
    <Description>
    </Description>
    <Title_Description>Add short guide for using tiered compilation and how to provide feedback </Title_Description>
    <Label>area-TieredCompilation</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19770</IssueLabelID>
    <Title>Fix CoreCLR debug launch</Title>
    <Description>
    </Description>
    <Title_Description>Fix CoreCLR debug launch </Title_Description>
    <Label>
    </Label>
    <Assignee>mikem8361</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19769</IssueLabelID>
    <Title>Build error: MSB4018: System.Exception: The package ID 'runtime.gentoo.-x64.Microsoft.NETCore.Runtime.CoreCLR' contains invalid characters. Examples of valid package IDs include 'MyPackage' and 'MyPackage.Sample'. [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Runtime.CoreCLR/Microsoft.NETCore.Runtime.CoreCLR.pkgproj]</Title>
    <Description>I'm trying to build Dotnet from the release/2.2 branch on a Gentoo box but run into issues. I'm not (yet) familiar with your project structure please tell me if I'm doing something wrong or reporting this in the wrong place. For what it's worth I observe nearly identical errors with the 2.1 branch.

To avoid errors caused by stale Nuget files HOME is set to an empty directory. The top-level directory is a clean checkout of the current `release/2.2` branch from the `source-build` repository.

When I run `./build.sh` from the top-level directory of the repository eventually leads to this error output:

```
  Generating symbol file for System.Private.CoreLib.dll
  /var/tmp/dotnet/source-build/src/coreclr/bin/Product/Linux.x64.Release/crossgen /Platform_Assemblies_Paths /var/tmp/dotnet/source-build/src/coreclr/bin/Product/Linux.x64.Release /CreatePerfMap /var/tmp/dotnet/source-build/src/coreclr/bin/Product/Linux.x64.Release /var/tmp/dotnet/source-build/src/coreclr/bin/Product/Linux.x64.Release/System.Private.CoreLib.dll
  Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0
  Copyright (c) Microsoft Corporation.  All rights reserved.
  
  Successfully generated perfmap for native assembly '/var/tmp/dotnet/source-build/src/coreclr/bin/Product/Linux.x64.Release/System.Private.CoreLib.dll'.
  Generating nuget packages for Linux
  DistroRid is gentoo.-x64
  ROOTFS_DIR is 
  Running init-tools.sh
  Tools are already initialized
  Running: /var/tmp/dotnet/source-build/src/coreclr/Tools/dotnetcli/dotnet /var/tmp/dotnet/source-build/src/coreclr/Tools/run.exe /var/tmp/dotnet/source-build/src/coreclr/config.json build -Project=/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/packages.builds -MsBuildEventLogging=/l:BinClashLoggerTools/Microsoft.DotNet.Build.Tasks.dll;LogFile=binclash.log -MsBuildLog=/flp:Verbosity=normal;LogFile=/var/tmp/dotnet/source-build/src/coreclr/bin/Logs/Nuget_Release.log -BuildTarget -__IntermediatesDir=/var/tmp/dotnet/source-build/src/coreclr/bin/obj/Linux.x64.Release -__RootBinDir=/var/tmp/dotnet/source-build/src/coreclr/bin -BuildNugetPackage=false -UseSharedCompilation=false -__DoCrossArchBuild=0 -BuildArch=x64 -BuildType=Release -BuildOS=Linux -PortableBuild=false -- /p:DotNetPackageVersionPropsPath=/var/tmp/dotnet/source-build/bin/obj/x64/Release/PackageVersions.props /p:DotNetRestoreSourcePropsPath=/var/tmp/dotnet/source-build/bin/obj/x64/Release/RestoreSources.props /p:DotNetOutputBlobFeedDir=/var/tmp/dotnet/source-build/bin/obj/x64/Release/blob-feed/
  Running: /var/tmp/dotnet/source-build/src/coreclr/Tools/msbuild.sh /nologo /verbosity:minimal /clp:Summary  /l:BinClashLoggerTools/Microsoft.DotNet.Build.Tasks.dll;LogFile=binclash.log  /var/tmp/dotnet/source-build/src/coreclr/src/.nuget/packages.builds /p:__BuildType=Release /p:__BuildArch=x64 /p:__BuildOS=Linux /p:__RootBinDir=/var/tmp/dotnet/source-build/src/coreclr/bin /p:__IntermediatesDir=/var/tmp/dotnet/source-build/src/coreclr/bin/obj/Linux.x64.Release /p:__DoCrossArchBuild=0  /maxcpucount /p:RestoreDefaultOptimizationDataPackage=false /p:UsePartialNGENOptimization=false /p:PortableBuild=false  /flp:Verbosity=normal;LogFile=/var/tmp/dotnet/source-build/src/coreclr/bin/Logs/Nuget_Release.log     /p:BuildNugetPackage=false /t:Build /p:UseSharedCompilation=false /p:DotNetPackageVersionPropsPath=/var/tmp/dotnet/source-build/bin/obj/x64/Release/PackageVersions.props /p:DotNetRestoreSourcePropsPath=/var/tmp/dotnet/source-build/bin/obj/x64/Release/RestoreSources.props /p:DotNetOutputBlobFeedDir=/var/tmp/dotnet/source-build/bin/obj/x64/Release/blob-feed/
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018: The "NugetPack" task failed unexpectedly. [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Runtime.CoreCLR/Microsoft.NETCore.Runtime.CoreCLR.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018: System.Exception: The package ID 'runtime.gentoo.-x64.Microsoft.NETCore.Runtime.CoreCLR' contains invalid characters. Examples of valid package IDs include 'MyPackage' and 'MyPackage.Sample'. [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Runtime.CoreCLR/Microsoft.NETCore.Runtime.CoreCLR.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at NuGet.Packaging.Manifest.Validate(Manifest manifest) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Runtime.CoreCLR/Microsoft.NETCore.Runtime.CoreCLR.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at NuGet.Packaging.Manifest.ReadFrom(Stream stream Func`2 propertyProvider Boolean validateSchema) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Runtime.CoreCLR/Microsoft.NETCore.Runtime.CoreCLR.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.DotNet.Build.Tasks.Packaging.NuGetPack.GetManifest(String nuspecPath Func`2 nuspecPropertyProvider Boolean isPackedPackage) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Runtime.CoreCLR/Microsoft.NETCore.Runtime.CoreCLR.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.DotNet.Build.Tasks.Packaging.NuGetPack.Execute() [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Runtime.CoreCLR/Microsoft.NETCore.Runtime.CoreCLR.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.Build.BackEnd.TaskExecutionHost.Microsoft.Build.BackEnd.ITaskExecutionHost.Execute() [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Runtime.CoreCLR/Microsoft.NETCore.Runtime.CoreCLR.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.Build.BackEnd.TaskBuilder.ExecuteInstantiatedTask(ITaskExecutionHost taskExecutionHost TaskLoggingContext taskLoggingContext TaskHost taskHost ItemBucket bucket TaskExecutionMode howToExecuteTask) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Runtime.CoreCLR/Microsoft.NETCore.Runtime.CoreCLR.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018: The "NugetPack" task failed unexpectedly. [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.TestHost/Microsoft.NETCore.TestHost.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018: System.Exception: The package ID 'runtime.gentoo.-x64.Microsoft.NETCore.TestHost' contains invalid characters. Examples of valid package IDs include 'MyPackage' and 'MyPackage.Sample'. [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.TestHost/Microsoft.NETCore.TestHost.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at NuGet.Packaging.Manifest.Validate(Manifest manifest) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.TestHost/Microsoft.NETCore.TestHost.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at NuGet.Packaging.Manifest.ReadFrom(Stream stream Func`2 propertyProvider Boolean validateSchema) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.TestHost/Microsoft.NETCore.TestHost.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.DotNet.Build.Tasks.Packaging.NuGetPack.GetManifest(String nuspecPath Func`2 nuspecPropertyProvider Boolean isPackedPackage) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.TestHost/Microsoft.NETCore.TestHost.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.DotNet.Build.Tasks.Packaging.NuGetPack.Execute() [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.TestHost/Microsoft.NETCore.TestHost.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.Build.BackEnd.TaskExecutionHost.Microsoft.Build.BackEnd.ITaskExecutionHost.Execute() [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.TestHost/Microsoft.NETCore.TestHost.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.Build.BackEnd.TaskBuilder.ExecuteInstantiatedTask(ITaskExecutionHost taskExecutionHost TaskLoggingContext taskLoggingContext TaskHost taskHost ItemBucket bucket TaskExecutionMode howToExecuteTask) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.TestHost/Microsoft.NETCore.TestHost.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018: The "NugetPack" task failed unexpectedly. [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Native/Microsoft.NETCore.Native.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018: System.Exception: The package ID 'runtime.gentoo.-x64.Microsoft.NETCore.Native' contains invalid characters. Examples of valid package IDs include 'MyPackage' and 'MyPackage.Sample'. [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Native/Microsoft.NETCore.Native.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at NuGet.Packaging.Manifest.Validate(Manifest manifest) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Native/Microsoft.NETCore.Native.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at NuGet.Packaging.Manifest.ReadFrom(Stream stream Func`2 propertyProvider Boolean validateSchema) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Native/Microsoft.NETCore.Native.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.DotNet.Build.Tasks.Packaging.NuGetPack.GetManifest(String nuspecPath Func`2 nuspecPropertyProvider Boolean isPackedPackage) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Native/Microsoft.NETCore.Native.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.DotNet.Build.Tasks.Packaging.NuGetPack.Execute() [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Native/Microsoft.NETCore.Native.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.Build.BackEnd.TaskExecutionHost.Microsoft.Build.BackEnd.ITaskExecutionHost.Execute() [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Native/Microsoft.NETCore.Native.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.Build.BackEnd.TaskBuilder.ExecuteInstantiatedTask(ITaskExecutionHost taskExecutionHost TaskLoggingContext taskLoggingContext TaskHost taskHost ItemBucket bucket TaskExecutionMode howToExecuteTask) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Native/Microsoft.NETCore.Native.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018: The "NugetPack" task failed unexpectedly. [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Jit/Microsoft.NETCore.Jit.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018: System.Exception: The package ID 'runtime.gentoo.-x64.Microsoft.NETCore.Jit' contains invalid characters. Examples of valid package IDs include 'MyPackage' and 'MyPackage.Sample'. [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Jit/Microsoft.NETCore.Jit.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at NuGet.Packaging.Manifest.Validate(Manifest manifest) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Jit/Microsoft.NETCore.Jit.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at NuGet.Packaging.Manifest.ReadFrom(Stream stream Func`2 propertyProvider Boolean validateSchema) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Jit/Microsoft.NETCore.Jit.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.DotNet.Build.Tasks.Packaging.NuGetPack.GetManifest(String nuspecPath Func`2 nuspecPropertyProvider Boolean isPackedPackage) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Jit/Microsoft.NETCore.Jit.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.DotNet.Build.Tasks.Packaging.NuGetPack.Execute() [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Jit/Microsoft.NETCore.Jit.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.Build.BackEnd.TaskExecutionHost.Microsoft.Build.BackEnd.ITaskExecutionHost.Execute() [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Jit/Microsoft.NETCore.Jit.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.Build.BackEnd.TaskBuilder.ExecuteInstantiatedTask(ITaskExecutionHost taskExecutionHost TaskLoggingContext taskLoggingContext TaskHost taskHost ItemBucket bucket TaskExecutionMode howToExecuteTask) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Jit/Microsoft.NETCore.Jit.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018: The "NugetPack" task failed unexpectedly. [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.ILAsm/Microsoft.NETCore.ILAsm.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018: System.Exception: The package ID 'runtime.gentoo.-x64.Microsoft.NETCore.ILAsm' contains invalid characters. Examples of valid package IDs include 'MyPackage' and 'MyPackage.Sample'. [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.ILAsm/Microsoft.NETCore.ILAsm.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at NuGet.Packaging.Manifest.Validate(Manifest manifest) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.ILAsm/Microsoft.NETCore.ILAsm.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at NuGet.Packaging.Manifest.ReadFrom(Stream stream Func`2 propertyProvider Boolean validateSchema) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.ILAsm/Microsoft.NETCore.ILAsm.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.DotNet.Build.Tasks.Packaging.NuGetPack.GetManifest(String nuspecPath Func`2 nuspecPropertyProvider Boolean isPackedPackage) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.ILAsm/Microsoft.NETCore.ILAsm.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.DotNet.Build.Tasks.Packaging.NuGetPack.Execute() [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.ILAsm/Microsoft.NETCore.ILAsm.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.Build.BackEnd.TaskExecutionHost.Microsoft.Build.BackEnd.ITaskExecutionHost.Execute() [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.ILAsm/Microsoft.NETCore.ILAsm.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.Build.BackEnd.TaskBuilder.ExecuteInstantiatedTask(ITaskExecutionHost taskExecutionHost TaskLoggingContext taskLoggingContext TaskHost taskHost ItemBucket bucket TaskExecutionMode howToExecuteTask) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.ILAsm/Microsoft.NETCore.ILAsm.pkgproj]
    Microsoft.NETCore.Jit -&gt; /var/tmp/dotnet/source-build/bin/obj/x64/Release/blob-feed/packages/specs/Microsoft.NETCore.Jit.nuspec
    Microsoft.NETCore.ILAsm -&gt; /var/tmp/dotnet/source-build/bin/obj/x64/Release/blob-feed/packages/specs/Microsoft.NETCore.ILAsm.nuspec
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018: The "NugetPack" task failed unexpectedly. [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.ILDAsm/Microsoft.NETCore.ILDAsm.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018: System.Exception: The package ID 'runtime.gentoo.-x64.Microsoft.NETCore.ILDAsm' contains invalid characters. Examples of valid package IDs include 'MyPackage' and 'MyPackage.Sample'. [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.ILDAsm/Microsoft.NETCore.ILDAsm.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at NuGet.Packaging.Manifest.Validate(Manifest manifest) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.ILDAsm/Microsoft.NETCore.ILDAsm.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at NuGet.Packaging.Manifest.ReadFrom(Stream stream Func`2 propertyProvider Boolean validateSchema) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.ILDAsm/Microsoft.NETCore.ILDAsm.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.DotNet.Build.Tasks.Packaging.NuGetPack.GetManifest(String nuspecPath Func`2 nuspecPropertyProvider Boolean isPackedPackage) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.ILDAsm/Microsoft.NETCore.ILDAsm.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.DotNet.Build.Tasks.Packaging.NuGetPack.Execute() [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.ILDAsm/Microsoft.NETCore.ILDAsm.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.Build.BackEnd.TaskExecutionHost.Microsoft.Build.BackEnd.ITaskExecutionHost.Execute() [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.ILDAsm/Microsoft.NETCore.ILDAsm.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.Build.BackEnd.TaskBuilder.ExecuteInstantiatedTask(ITaskExecutionHost taskExecutionHost TaskLoggingContext taskLoggingContext TaskHost taskHost ItemBucket bucket TaskExecutionMode howToExecuteTask) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.ILDAsm/Microsoft.NETCore.ILDAsm.pkgproj]
    Microsoft.NETCore.Native -&gt; /var/tmp/dotnet/source-build/bin/obj/x64/Release/blob-feed/packages/specs/Microsoft.NETCore.Native.nuspec
    Microsoft.NETCore.TestHost -&gt; /var/tmp/dotnet/source-build/bin/obj/x64/Release/blob-feed/packages/specs/Microsoft.NETCore.TestHost.nuspec
    Microsoft.NETCore.Runtime.CoreCLR -&gt; /var/tmp/dotnet/source-build/bin/obj/x64/Release/blob-feed/packages/specs/Microsoft.NETCore.Runtime.CoreCLR.nuspec
    Microsoft.NETCore.ILDAsm -&gt; /var/tmp/dotnet/source-build/bin/obj/x64/Release/blob-feed/packages/specs/Microsoft.NETCore.ILDAsm.nuspec
  
  Build FAILED.
  
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018: The "NugetPack" task failed unexpectedly. [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Runtime.CoreCLR/Microsoft.NETCore.Runtime.CoreCLR.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018: System.Exception: The package ID 'runtime.gentoo.-x64.Microsoft.NETCore.Runtime.CoreCLR' contains invalid characters. Examples of valid package IDs include 'MyPackage' and 'MyPackage.Sample'. [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Runtime.CoreCLR/Microsoft.NETCore.Runtime.CoreCLR.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at NuGet.Packaging.Manifest.Validate(Manifest manifest) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Runtime.CoreCLR/Microsoft.NETCore.Runtime.CoreCLR.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at NuGet.Packaging.Manifest.ReadFrom(Stream stream Func`2 propertyProvider Boolean validateSchema) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Runtime.CoreCLR/Microsoft.NETCore.Runtime.CoreCLR.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.DotNet.Build.Tasks.Packaging.NuGetPack.GetManifest(String nuspecPath Func`2 nuspecPropertyProvider Boolean isPackedPackage) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Runtime.CoreCLR/Microsoft.NETCore.Runtime.CoreCLR.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.DotNet.Build.Tasks.Packaging.NuGetPack.Execute() [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Runtime.CoreCLR/Microsoft.NETCore.Runtime.CoreCLR.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.Build.BackEnd.TaskExecutionHost.Microsoft.Build.BackEnd.ITaskExecutionHost.Execute() [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Runtime.CoreCLR/Microsoft.NETCore.Runtime.CoreCLR.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.Build.BackEnd.TaskBuilder.ExecuteInstantiatedTask(ITaskExecutionHost taskExecutionHost TaskLoggingContext taskLoggingContext TaskHost taskHost ItemBucket bucket TaskExecutionMode howToExecuteTask) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Runtime.CoreCLR/Microsoft.NETCore.Runtime.CoreCLR.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018: The "NugetPack" task failed unexpectedly. [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.TestHost/Microsoft.NETCore.TestHost.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018: System.Exception: The package ID 'runtime.gentoo.-x64.Microsoft.NETCore.TestHost' contains invalid characters. Examples of valid package IDs include 'MyPackage' and 'MyPackage.Sample'. [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.TestHost/Microsoft.NETCore.TestHost.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at NuGet.Packaging.Manifest.Validate(Manifest manifest) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.TestHost/Microsoft.NETCore.TestHost.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at NuGet.Packaging.Manifest.ReadFrom(Stream stream Func`2 propertyProvider Boolean validateSchema) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.TestHost/Microsoft.NETCore.TestHost.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.DotNet.Build.Tasks.Packaging.NuGetPack.GetManifest(String nuspecPath Func`2 nuspecPropertyProvider Boolean isPackedPackage) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.TestHost/Microsoft.NETCore.TestHost.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.DotNet.Build.Tasks.Packaging.NuGetPack.Execute() [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.TestHost/Microsoft.NETCore.TestHost.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.Build.BackEnd.TaskExecutionHost.Microsoft.Build.BackEnd.ITaskExecutionHost.Execute() [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.TestHost/Microsoft.NETCore.TestHost.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.Build.BackEnd.TaskBuilder.ExecuteInstantiatedTask(ITaskExecutionHost taskExecutionHost TaskLoggingContext taskLoggingContext TaskHost taskHost ItemBucket bucket TaskExecutionMode howToExecuteTask) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.TestHost/Microsoft.NETCore.TestHost.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018: The "NugetPack" task failed unexpectedly. [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Native/Microsoft.NETCore.Native.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018: System.Exception: The package ID 'runtime.gentoo.-x64.Microsoft.NETCore.Native' contains invalid characters. Examples of valid package IDs include 'MyPackage' and 'MyPackage.Sample'. [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Native/Microsoft.NETCore.Native.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at NuGet.Packaging.Manifest.Validate(Manifest manifest) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Native/Microsoft.NETCore.Native.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at NuGet.Packaging.Manifest.ReadFrom(Stream stream Func`2 propertyProvider Boolean validateSchema) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Native/Microsoft.NETCore.Native.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.DotNet.Build.Tasks.Packaging.NuGetPack.GetManifest(String nuspecPath Func`2 nuspecPropertyProvider Boolean isPackedPackage) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Native/Microsoft.NETCore.Native.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.DotNet.Build.Tasks.Packaging.NuGetPack.Execute() [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Native/Microsoft.NETCore.Native.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.Build.BackEnd.TaskExecutionHost.Microsoft.Build.BackEnd.ITaskExecutionHost.Execute() [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Native/Microsoft.NETCore.Native.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.Build.BackEnd.TaskBuilder.ExecuteInstantiatedTask(ITaskExecutionHost taskExecutionHost TaskLoggingContext taskLoggingContext TaskHost taskHost ItemBucket bucket TaskExecutionMode howToExecuteTask) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Native/Microsoft.NETCore.Native.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018: The "NugetPack" task failed unexpectedly. [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Jit/Microsoft.NETCore.Jit.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018: System.Exception: The package ID 'runtime.gentoo.-x64.Microsoft.NETCore.Jit' contains invalid characters. Examples of valid package IDs include 'MyPackage' and 'MyPackage.Sample'. [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Jit/Microsoft.NETCore.Jit.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at NuGet.Packaging.Manifest.Validate(Manifest manifest) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Jit/Microsoft.NETCore.Jit.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at NuGet.Packaging.Manifest.ReadFrom(Stream stream Func`2 propertyProvider Boolean validateSchema) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Jit/Microsoft.NETCore.Jit.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.DotNet.Build.Tasks.Packaging.NuGetPack.GetManifest(String nuspecPath Func`2 nuspecPropertyProvider Boolean isPackedPackage) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Jit/Microsoft.NETCore.Jit.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.DotNet.Build.Tasks.Packaging.NuGetPack.Execute() [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Jit/Microsoft.NETCore.Jit.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.Build.BackEnd.TaskExecutionHost.Microsoft.Build.BackEnd.ITaskExecutionHost.Execute() [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Jit/Microsoft.NETCore.Jit.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.Build.BackEnd.TaskBuilder.ExecuteInstantiatedTask(ITaskExecutionHost taskExecutionHost TaskLoggingContext taskLoggingContext TaskHost taskHost ItemBucket bucket TaskExecutionMode howToExecuteTask) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Jit/Microsoft.NETCore.Jit.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018: The "NugetPack" task failed unexpectedly. [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.ILAsm/Microsoft.NETCore.ILAsm.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018: System.Exception: The package ID 'runtime.gentoo.-x64.Microsoft.NETCore.ILAsm' contains invalid characters. Examples of valid package IDs include 'MyPackage' and 'MyPackage.Sample'. [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.ILAsm/Microsoft.NETCore.ILAsm.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at NuGet.Packaging.Manifest.Validate(Manifest manifest) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.ILAsm/Microsoft.NETCore.ILAsm.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at NuGet.Packaging.Manifest.ReadFrom(Stream stream Func`2 propertyProvider Boolean validateSchema) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.ILAsm/Microsoft.NETCore.ILAsm.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.DotNet.Build.Tasks.Packaging.NuGetPack.GetManifest(String nuspecPath Func`2 nuspecPropertyProvider Boolean isPackedPackage) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.ILAsm/Microsoft.NETCore.ILAsm.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.DotNet.Build.Tasks.Packaging.NuGetPack.Execute() [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.ILAsm/Microsoft.NETCore.ILAsm.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.Build.BackEnd.TaskExecutionHost.Microsoft.Build.BackEnd.ITaskExecutionHost.Execute() [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.ILAsm/Microsoft.NETCore.ILAsm.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.Build.BackEnd.TaskBuilder.ExecuteInstantiatedTask(ITaskExecutionHost taskExecutionHost TaskLoggingContext taskLoggingContext TaskHost taskHost ItemBucket bucket TaskExecutionMode howToExecuteTask) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.ILAsm/Microsoft.NETCore.ILAsm.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018: The "NugetPack" task failed unexpectedly. [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.ILDAsm/Microsoft.NETCore.ILDAsm.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018: System.Exception: The package ID 'runtime.gentoo.-x64.Microsoft.NETCore.ILDAsm' contains invalid characters. Examples of valid package IDs include 'MyPackage' and 'MyPackage.Sample'. [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.ILDAsm/Microsoft.NETCore.ILDAsm.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at NuGet.Packaging.Manifest.Validate(Manifest manifest) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.ILDAsm/Microsoft.NETCore.ILDAsm.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at NuGet.Packaging.Manifest.ReadFrom(Stream stream Func`2 propertyProvider Boolean validateSchema) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.ILDAsm/Microsoft.NETCore.ILDAsm.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.DotNet.Build.Tasks.Packaging.NuGetPack.GetManifest(String nuspecPath Func`2 nuspecPropertyProvider Boolean isPackedPackage) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.ILDAsm/Microsoft.NETCore.ILDAsm.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.DotNet.Build.Tasks.Packaging.NuGetPack.Execute() [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.ILDAsm/Microsoft.NETCore.ILDAsm.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.Build.BackEnd.TaskExecutionHost.Microsoft.Build.BackEnd.ITaskExecutionHost.Execute() [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.ILDAsm/Microsoft.NETCore.ILDAsm.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.Build.BackEnd.TaskBuilder.ExecuteInstantiatedTask(ITaskExecutionHost taskExecutionHost TaskLoggingContext taskLoggingContext TaskHost taskHost ItemBucket bucket TaskExecutionMode howToExecuteTask) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.ILDAsm/Microsoft.NETCore.ILDAsm.pkgproj]
      0 Warning(s)
      6 Error(s)
  
  Time Elapsed 00:00:10.56
  Command execution failed with exit code 1.
  ERROR: An error occured in /var/tmp/dotnet/source-build/src/coreclr/Tools/dotnetcli/dotnet /var/tmp/dotnet/source-build/src/coreclr/Tools/run 18. Check 18 logs under /var/tmp/dotnet/source-build/src/coreclr.
  Failed to generate Nuget packages.
  
  'coreclr' failed during build.
  See '/var/tmp/dotnet/source-build/bin/logs/coreclr.log' for more information.
  'known-good' failed during build.
```

I don't understand the "Check 18 logs" bit but here's the full contents of `/var/tmp/dotnet/source-build/bin/logs/coreclr.log`:
 &lt;https://gist.github.com/eroen/d48f0c139e00198a6cb0ef728d4ac3cb&gt;</Description>
    <Title_Description>Build error: MSB4018: System.Exception: The package ID 'runtime.gentoo.-x64.Microsoft.NETCore.Runtime.CoreCLR' contains invalid characters. Examples of valid package IDs include 'MyPackage' and 'MyPackage.Sample'. [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Runtime.CoreCLR/Microsoft.NETCore.Runtime.CoreCLR.pkgproj] I'm trying to build Dotnet from the release/2.2 branch on a Gentoo box but run into issues. I'm not (yet) familiar with your project structure please tell me if I'm doing something wrong or reporting this in the wrong place. For what it's worth I observe nearly identical errors with the 2.1 branch.

To avoid errors caused by stale Nuget files HOME is set to an empty directory. The top-level directory is a clean checkout of the current `release/2.2` branch from the `source-build` repository.

When I run `./build.sh` from the top-level directory of the repository eventually leads to this error output:

```
  Generating symbol file for System.Private.CoreLib.dll
  /var/tmp/dotnet/source-build/src/coreclr/bin/Product/Linux.x64.Release/crossgen /Platform_Assemblies_Paths /var/tmp/dotnet/source-build/src/coreclr/bin/Product/Linux.x64.Release /CreatePerfMap /var/tmp/dotnet/source-build/src/coreclr/bin/Product/Linux.x64.Release /var/tmp/dotnet/source-build/src/coreclr/bin/Product/Linux.x64.Release/System.Private.CoreLib.dll
  Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0
  Copyright (c) Microsoft Corporation.  All rights reserved.
  
  Successfully generated perfmap for native assembly '/var/tmp/dotnet/source-build/src/coreclr/bin/Product/Linux.x64.Release/System.Private.CoreLib.dll'.
  Generating nuget packages for Linux
  DistroRid is gentoo.-x64
  ROOTFS_DIR is 
  Running init-tools.sh
  Tools are already initialized
  Running: /var/tmp/dotnet/source-build/src/coreclr/Tools/dotnetcli/dotnet /var/tmp/dotnet/source-build/src/coreclr/Tools/run.exe /var/tmp/dotnet/source-build/src/coreclr/config.json build -Project=/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/packages.builds -MsBuildEventLogging=/l:BinClashLoggerTools/Microsoft.DotNet.Build.Tasks.dll;LogFile=binclash.log -MsBuildLog=/flp:Verbosity=normal;LogFile=/var/tmp/dotnet/source-build/src/coreclr/bin/Logs/Nuget_Release.log -BuildTarget -__IntermediatesDir=/var/tmp/dotnet/source-build/src/coreclr/bin/obj/Linux.x64.Release -__RootBinDir=/var/tmp/dotnet/source-build/src/coreclr/bin -BuildNugetPackage=false -UseSharedCompilation=false -__DoCrossArchBuild=0 -BuildArch=x64 -BuildType=Release -BuildOS=Linux -PortableBuild=false -- /p:DotNetPackageVersionPropsPath=/var/tmp/dotnet/source-build/bin/obj/x64/Release/PackageVersions.props /p:DotNetRestoreSourcePropsPath=/var/tmp/dotnet/source-build/bin/obj/x64/Release/RestoreSources.props /p:DotNetOutputBlobFeedDir=/var/tmp/dotnet/source-build/bin/obj/x64/Release/blob-feed/
  Running: /var/tmp/dotnet/source-build/src/coreclr/Tools/msbuild.sh /nologo /verbosity:minimal /clp:Summary  /l:BinClashLoggerTools/Microsoft.DotNet.Build.Tasks.dll;LogFile=binclash.log  /var/tmp/dotnet/source-build/src/coreclr/src/.nuget/packages.builds /p:__BuildType=Release /p:__BuildArch=x64 /p:__BuildOS=Linux /p:__RootBinDir=/var/tmp/dotnet/source-build/src/coreclr/bin /p:__IntermediatesDir=/var/tmp/dotnet/source-build/src/coreclr/bin/obj/Linux.x64.Release /p:__DoCrossArchBuild=0  /maxcpucount /p:RestoreDefaultOptimizationDataPackage=false /p:UsePartialNGENOptimization=false /p:PortableBuild=false  /flp:Verbosity=normal;LogFile=/var/tmp/dotnet/source-build/src/coreclr/bin/Logs/Nuget_Release.log     /p:BuildNugetPackage=false /t:Build /p:UseSharedCompilation=false /p:DotNetPackageVersionPropsPath=/var/tmp/dotnet/source-build/bin/obj/x64/Release/PackageVersions.props /p:DotNetRestoreSourcePropsPath=/var/tmp/dotnet/source-build/bin/obj/x64/Release/RestoreSources.props /p:DotNetOutputBlobFeedDir=/var/tmp/dotnet/source-build/bin/obj/x64/Release/blob-feed/
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018: The "NugetPack" task failed unexpectedly. [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Runtime.CoreCLR/Microsoft.NETCore.Runtime.CoreCLR.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018: System.Exception: The package ID 'runtime.gentoo.-x64.Microsoft.NETCore.Runtime.CoreCLR' contains invalid characters. Examples of valid package IDs include 'MyPackage' and 'MyPackage.Sample'. [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Runtime.CoreCLR/Microsoft.NETCore.Runtime.CoreCLR.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at NuGet.Packaging.Manifest.Validate(Manifest manifest) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Runtime.CoreCLR/Microsoft.NETCore.Runtime.CoreCLR.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at NuGet.Packaging.Manifest.ReadFrom(Stream stream Func`2 propertyProvider Boolean validateSchema) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Runtime.CoreCLR/Microsoft.NETCore.Runtime.CoreCLR.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.DotNet.Build.Tasks.Packaging.NuGetPack.GetManifest(String nuspecPath Func`2 nuspecPropertyProvider Boolean isPackedPackage) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Runtime.CoreCLR/Microsoft.NETCore.Runtime.CoreCLR.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.DotNet.Build.Tasks.Packaging.NuGetPack.Execute() [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Runtime.CoreCLR/Microsoft.NETCore.Runtime.CoreCLR.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.Build.BackEnd.TaskExecutionHost.Microsoft.Build.BackEnd.ITaskExecutionHost.Execute() [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Runtime.CoreCLR/Microsoft.NETCore.Runtime.CoreCLR.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.Build.BackEnd.TaskBuilder.ExecuteInstantiatedTask(ITaskExecutionHost taskExecutionHost TaskLoggingContext taskLoggingContext TaskHost taskHost ItemBucket bucket TaskExecutionMode howToExecuteTask) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Runtime.CoreCLR/Microsoft.NETCore.Runtime.CoreCLR.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018: The "NugetPack" task failed unexpectedly. [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.TestHost/Microsoft.NETCore.TestHost.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018: System.Exception: The package ID 'runtime.gentoo.-x64.Microsoft.NETCore.TestHost' contains invalid characters. Examples of valid package IDs include 'MyPackage' and 'MyPackage.Sample'. [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.TestHost/Microsoft.NETCore.TestHost.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at NuGet.Packaging.Manifest.Validate(Manifest manifest) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.TestHost/Microsoft.NETCore.TestHost.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at NuGet.Packaging.Manifest.ReadFrom(Stream stream Func`2 propertyProvider Boolean validateSchema) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.TestHost/Microsoft.NETCore.TestHost.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.DotNet.Build.Tasks.Packaging.NuGetPack.GetManifest(String nuspecPath Func`2 nuspecPropertyProvider Boolean isPackedPackage) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.TestHost/Microsoft.NETCore.TestHost.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.DotNet.Build.Tasks.Packaging.NuGetPack.Execute() [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.TestHost/Microsoft.NETCore.TestHost.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.Build.BackEnd.TaskExecutionHost.Microsoft.Build.BackEnd.ITaskExecutionHost.Execute() [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.TestHost/Microsoft.NETCore.TestHost.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.Build.BackEnd.TaskBuilder.ExecuteInstantiatedTask(ITaskExecutionHost taskExecutionHost TaskLoggingContext taskLoggingContext TaskHost taskHost ItemBucket bucket TaskExecutionMode howToExecuteTask) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.TestHost/Microsoft.NETCore.TestHost.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018: The "NugetPack" task failed unexpectedly. [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Native/Microsoft.NETCore.Native.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018: System.Exception: The package ID 'runtime.gentoo.-x64.Microsoft.NETCore.Native' contains invalid characters. Examples of valid package IDs include 'MyPackage' and 'MyPackage.Sample'. [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Native/Microsoft.NETCore.Native.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at NuGet.Packaging.Manifest.Validate(Manifest manifest) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Native/Microsoft.NETCore.Native.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at NuGet.Packaging.Manifest.ReadFrom(Stream stream Func`2 propertyProvider Boolean validateSchema) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Native/Microsoft.NETCore.Native.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.DotNet.Build.Tasks.Packaging.NuGetPack.GetManifest(String nuspecPath Func`2 nuspecPropertyProvider Boolean isPackedPackage) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Native/Microsoft.NETCore.Native.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.DotNet.Build.Tasks.Packaging.NuGetPack.Execute() [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Native/Microsoft.NETCore.Native.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.Build.BackEnd.TaskExecutionHost.Microsoft.Build.BackEnd.ITaskExecutionHost.Execute() [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Native/Microsoft.NETCore.Native.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.Build.BackEnd.TaskBuilder.ExecuteInstantiatedTask(ITaskExecutionHost taskExecutionHost TaskLoggingContext taskLoggingContext TaskHost taskHost ItemBucket bucket TaskExecutionMode howToExecuteTask) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Native/Microsoft.NETCore.Native.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018: The "NugetPack" task failed unexpectedly. [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Jit/Microsoft.NETCore.Jit.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018: System.Exception: The package ID 'runtime.gentoo.-x64.Microsoft.NETCore.Jit' contains invalid characters. Examples of valid package IDs include 'MyPackage' and 'MyPackage.Sample'. [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Jit/Microsoft.NETCore.Jit.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at NuGet.Packaging.Manifest.Validate(Manifest manifest) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Jit/Microsoft.NETCore.Jit.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at NuGet.Packaging.Manifest.ReadFrom(Stream stream Func`2 propertyProvider Boolean validateSchema) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Jit/Microsoft.NETCore.Jit.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.DotNet.Build.Tasks.Packaging.NuGetPack.GetManifest(String nuspecPath Func`2 nuspecPropertyProvider Boolean isPackedPackage) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Jit/Microsoft.NETCore.Jit.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.DotNet.Build.Tasks.Packaging.NuGetPack.Execute() [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Jit/Microsoft.NETCore.Jit.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.Build.BackEnd.TaskExecutionHost.Microsoft.Build.BackEnd.ITaskExecutionHost.Execute() [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Jit/Microsoft.NETCore.Jit.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.Build.BackEnd.TaskBuilder.ExecuteInstantiatedTask(ITaskExecutionHost taskExecutionHost TaskLoggingContext taskLoggingContext TaskHost taskHost ItemBucket bucket TaskExecutionMode howToExecuteTask) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Jit/Microsoft.NETCore.Jit.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018: The "NugetPack" task failed unexpectedly. [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.ILAsm/Microsoft.NETCore.ILAsm.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018: System.Exception: The package ID 'runtime.gentoo.-x64.Microsoft.NETCore.ILAsm' contains invalid characters. Examples of valid package IDs include 'MyPackage' and 'MyPackage.Sample'. [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.ILAsm/Microsoft.NETCore.ILAsm.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at NuGet.Packaging.Manifest.Validate(Manifest manifest) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.ILAsm/Microsoft.NETCore.ILAsm.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at NuGet.Packaging.Manifest.ReadFrom(Stream stream Func`2 propertyProvider Boolean validateSchema) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.ILAsm/Microsoft.NETCore.ILAsm.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.DotNet.Build.Tasks.Packaging.NuGetPack.GetManifest(String nuspecPath Func`2 nuspecPropertyProvider Boolean isPackedPackage) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.ILAsm/Microsoft.NETCore.ILAsm.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.DotNet.Build.Tasks.Packaging.NuGetPack.Execute() [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.ILAsm/Microsoft.NETCore.ILAsm.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.Build.BackEnd.TaskExecutionHost.Microsoft.Build.BackEnd.ITaskExecutionHost.Execute() [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.ILAsm/Microsoft.NETCore.ILAsm.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.Build.BackEnd.TaskBuilder.ExecuteInstantiatedTask(ITaskExecutionHost taskExecutionHost TaskLoggingContext taskLoggingContext TaskHost taskHost ItemBucket bucket TaskExecutionMode howToExecuteTask) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.ILAsm/Microsoft.NETCore.ILAsm.pkgproj]
    Microsoft.NETCore.Jit -&gt; /var/tmp/dotnet/source-build/bin/obj/x64/Release/blob-feed/packages/specs/Microsoft.NETCore.Jit.nuspec
    Microsoft.NETCore.ILAsm -&gt; /var/tmp/dotnet/source-build/bin/obj/x64/Release/blob-feed/packages/specs/Microsoft.NETCore.ILAsm.nuspec
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018: The "NugetPack" task failed unexpectedly. [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.ILDAsm/Microsoft.NETCore.ILDAsm.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018: System.Exception: The package ID 'runtime.gentoo.-x64.Microsoft.NETCore.ILDAsm' contains invalid characters. Examples of valid package IDs include 'MyPackage' and 'MyPackage.Sample'. [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.ILDAsm/Microsoft.NETCore.ILDAsm.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at NuGet.Packaging.Manifest.Validate(Manifest manifest) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.ILDAsm/Microsoft.NETCore.ILDAsm.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at NuGet.Packaging.Manifest.ReadFrom(Stream stream Func`2 propertyProvider Boolean validateSchema) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.ILDAsm/Microsoft.NETCore.ILDAsm.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.DotNet.Build.Tasks.Packaging.NuGetPack.GetManifest(String nuspecPath Func`2 nuspecPropertyProvider Boolean isPackedPackage) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.ILDAsm/Microsoft.NETCore.ILDAsm.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.DotNet.Build.Tasks.Packaging.NuGetPack.Execute() [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.ILDAsm/Microsoft.NETCore.ILDAsm.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.Build.BackEnd.TaskExecutionHost.Microsoft.Build.BackEnd.ITaskExecutionHost.Execute() [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.ILDAsm/Microsoft.NETCore.ILDAsm.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.Build.BackEnd.TaskBuilder.ExecuteInstantiatedTask(ITaskExecutionHost taskExecutionHost TaskLoggingContext taskLoggingContext TaskHost taskHost ItemBucket bucket TaskExecutionMode howToExecuteTask) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.ILDAsm/Microsoft.NETCore.ILDAsm.pkgproj]
    Microsoft.NETCore.Native -&gt; /var/tmp/dotnet/source-build/bin/obj/x64/Release/blob-feed/packages/specs/Microsoft.NETCore.Native.nuspec
    Microsoft.NETCore.TestHost -&gt; /var/tmp/dotnet/source-build/bin/obj/x64/Release/blob-feed/packages/specs/Microsoft.NETCore.TestHost.nuspec
    Microsoft.NETCore.Runtime.CoreCLR -&gt; /var/tmp/dotnet/source-build/bin/obj/x64/Release/blob-feed/packages/specs/Microsoft.NETCore.Runtime.CoreCLR.nuspec
    Microsoft.NETCore.ILDAsm -&gt; /var/tmp/dotnet/source-build/bin/obj/x64/Release/blob-feed/packages/specs/Microsoft.NETCore.ILDAsm.nuspec
  
  Build FAILED.
  
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018: The "NugetPack" task failed unexpectedly. [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Runtime.CoreCLR/Microsoft.NETCore.Runtime.CoreCLR.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018: System.Exception: The package ID 'runtime.gentoo.-x64.Microsoft.NETCore.Runtime.CoreCLR' contains invalid characters. Examples of valid package IDs include 'MyPackage' and 'MyPackage.Sample'. [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Runtime.CoreCLR/Microsoft.NETCore.Runtime.CoreCLR.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at NuGet.Packaging.Manifest.Validate(Manifest manifest) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Runtime.CoreCLR/Microsoft.NETCore.Runtime.CoreCLR.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at NuGet.Packaging.Manifest.ReadFrom(Stream stream Func`2 propertyProvider Boolean validateSchema) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Runtime.CoreCLR/Microsoft.NETCore.Runtime.CoreCLR.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.DotNet.Build.Tasks.Packaging.NuGetPack.GetManifest(String nuspecPath Func`2 nuspecPropertyProvider Boolean isPackedPackage) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Runtime.CoreCLR/Microsoft.NETCore.Runtime.CoreCLR.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.DotNet.Build.Tasks.Packaging.NuGetPack.Execute() [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Runtime.CoreCLR/Microsoft.NETCore.Runtime.CoreCLR.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.Build.BackEnd.TaskExecutionHost.Microsoft.Build.BackEnd.ITaskExecutionHost.Execute() [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Runtime.CoreCLR/Microsoft.NETCore.Runtime.CoreCLR.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.Build.BackEnd.TaskBuilder.ExecuteInstantiatedTask(ITaskExecutionHost taskExecutionHost TaskLoggingContext taskLoggingContext TaskHost taskHost ItemBucket bucket TaskExecutionMode howToExecuteTask) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Runtime.CoreCLR/Microsoft.NETCore.Runtime.CoreCLR.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018: The "NugetPack" task failed unexpectedly. [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.TestHost/Microsoft.NETCore.TestHost.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018: System.Exception: The package ID 'runtime.gentoo.-x64.Microsoft.NETCore.TestHost' contains invalid characters. Examples of valid package IDs include 'MyPackage' and 'MyPackage.Sample'. [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.TestHost/Microsoft.NETCore.TestHost.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at NuGet.Packaging.Manifest.Validate(Manifest manifest) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.TestHost/Microsoft.NETCore.TestHost.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at NuGet.Packaging.Manifest.ReadFrom(Stream stream Func`2 propertyProvider Boolean validateSchema) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.TestHost/Microsoft.NETCore.TestHost.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.DotNet.Build.Tasks.Packaging.NuGetPack.GetManifest(String nuspecPath Func`2 nuspecPropertyProvider Boolean isPackedPackage) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.TestHost/Microsoft.NETCore.TestHost.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.DotNet.Build.Tasks.Packaging.NuGetPack.Execute() [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.TestHost/Microsoft.NETCore.TestHost.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.Build.BackEnd.TaskExecutionHost.Microsoft.Build.BackEnd.ITaskExecutionHost.Execute() [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.TestHost/Microsoft.NETCore.TestHost.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.Build.BackEnd.TaskBuilder.ExecuteInstantiatedTask(ITaskExecutionHost taskExecutionHost TaskLoggingContext taskLoggingContext TaskHost taskHost ItemBucket bucket TaskExecutionMode howToExecuteTask) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.TestHost/Microsoft.NETCore.TestHost.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018: The "NugetPack" task failed unexpectedly. [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Native/Microsoft.NETCore.Native.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018: System.Exception: The package ID 'runtime.gentoo.-x64.Microsoft.NETCore.Native' contains invalid characters. Examples of valid package IDs include 'MyPackage' and 'MyPackage.Sample'. [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Native/Microsoft.NETCore.Native.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at NuGet.Packaging.Manifest.Validate(Manifest manifest) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Native/Microsoft.NETCore.Native.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at NuGet.Packaging.Manifest.ReadFrom(Stream stream Func`2 propertyProvider Boolean validateSchema) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Native/Microsoft.NETCore.Native.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.DotNet.Build.Tasks.Packaging.NuGetPack.GetManifest(String nuspecPath Func`2 nuspecPropertyProvider Boolean isPackedPackage) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Native/Microsoft.NETCore.Native.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.DotNet.Build.Tasks.Packaging.NuGetPack.Execute() [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Native/Microsoft.NETCore.Native.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.Build.BackEnd.TaskExecutionHost.Microsoft.Build.BackEnd.ITaskExecutionHost.Execute() [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Native/Microsoft.NETCore.Native.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.Build.BackEnd.TaskBuilder.ExecuteInstantiatedTask(ITaskExecutionHost taskExecutionHost TaskLoggingContext taskLoggingContext TaskHost taskHost ItemBucket bucket TaskExecutionMode howToExecuteTask) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Native/Microsoft.NETCore.Native.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018: The "NugetPack" task failed unexpectedly. [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Jit/Microsoft.NETCore.Jit.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018: System.Exception: The package ID 'runtime.gentoo.-x64.Microsoft.NETCore.Jit' contains invalid characters. Examples of valid package IDs include 'MyPackage' and 'MyPackage.Sample'. [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Jit/Microsoft.NETCore.Jit.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at NuGet.Packaging.Manifest.Validate(Manifest manifest) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Jit/Microsoft.NETCore.Jit.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at NuGet.Packaging.Manifest.ReadFrom(Stream stream Func`2 propertyProvider Boolean validateSchema) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Jit/Microsoft.NETCore.Jit.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.DotNet.Build.Tasks.Packaging.NuGetPack.GetManifest(String nuspecPath Func`2 nuspecPropertyProvider Boolean isPackedPackage) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Jit/Microsoft.NETCore.Jit.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.DotNet.Build.Tasks.Packaging.NuGetPack.Execute() [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Jit/Microsoft.NETCore.Jit.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.Build.BackEnd.TaskExecutionHost.Microsoft.Build.BackEnd.ITaskExecutionHost.Execute() [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Jit/Microsoft.NETCore.Jit.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.Build.BackEnd.TaskBuilder.ExecuteInstantiatedTask(ITaskExecutionHost taskExecutionHost TaskLoggingContext taskLoggingContext TaskHost taskHost ItemBucket bucket TaskExecutionMode howToExecuteTask) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.Jit/Microsoft.NETCore.Jit.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018: The "NugetPack" task failed unexpectedly. [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.ILAsm/Microsoft.NETCore.ILAsm.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018: System.Exception: The package ID 'runtime.gentoo.-x64.Microsoft.NETCore.ILAsm' contains invalid characters. Examples of valid package IDs include 'MyPackage' and 'MyPackage.Sample'. [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.ILAsm/Microsoft.NETCore.ILAsm.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at NuGet.Packaging.Manifest.Validate(Manifest manifest) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.ILAsm/Microsoft.NETCore.ILAsm.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at NuGet.Packaging.Manifest.ReadFrom(Stream stream Func`2 propertyProvider Boolean validateSchema) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.ILAsm/Microsoft.NETCore.ILAsm.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.DotNet.Build.Tasks.Packaging.NuGetPack.GetManifest(String nuspecPath Func`2 nuspecPropertyProvider Boolean isPackedPackage) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.ILAsm/Microsoft.NETCore.ILAsm.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.DotNet.Build.Tasks.Packaging.NuGetPack.Execute() [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.ILAsm/Microsoft.NETCore.ILAsm.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.Build.BackEnd.TaskExecutionHost.Microsoft.Build.BackEnd.ITaskExecutionHost.Execute() [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.ILAsm/Microsoft.NETCore.ILAsm.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.Build.BackEnd.TaskBuilder.ExecuteInstantiatedTask(ITaskExecutionHost taskExecutionHost TaskLoggingContext taskLoggingContext TaskHost taskHost ItemBucket bucket TaskExecutionMode howToExecuteTask) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.ILAsm/Microsoft.NETCore.ILAsm.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018: The "NugetPack" task failed unexpectedly. [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.ILDAsm/Microsoft.NETCore.ILDAsm.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018: System.Exception: The package ID 'runtime.gentoo.-x64.Microsoft.NETCore.ILDAsm' contains invalid characters. Examples of valid package IDs include 'MyPackage' and 'MyPackage.Sample'. [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.ILDAsm/Microsoft.NETCore.ILDAsm.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at NuGet.Packaging.Manifest.Validate(Manifest manifest) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.ILDAsm/Microsoft.NETCore.ILDAsm.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at NuGet.Packaging.Manifest.ReadFrom(Stream stream Func`2 propertyProvider Boolean validateSchema) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.ILDAsm/Microsoft.NETCore.ILDAsm.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.DotNet.Build.Tasks.Packaging.NuGetPack.GetManifest(String nuspecPath Func`2 nuspecPropertyProvider Boolean isPackedPackage) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.ILDAsm/Microsoft.NETCore.ILDAsm.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.DotNet.Build.Tasks.Packaging.NuGetPack.Execute() [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.ILDAsm/Microsoft.NETCore.ILDAsm.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.Build.BackEnd.TaskExecutionHost.Microsoft.Build.BackEnd.ITaskExecutionHost.Execute() [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.ILDAsm/Microsoft.NETCore.ILDAsm.pkgproj]
  /var/tmp/dotnet/source-build/src/coreclr/Tools/Packaging.targets(12425): error MSB4018:    at Microsoft.Build.BackEnd.TaskBuilder.ExecuteInstantiatedTask(ITaskExecutionHost taskExecutionHost TaskLoggingContext taskLoggingContext TaskHost taskHost ItemBucket bucket TaskExecutionMode howToExecuteTask) [/var/tmp/dotnet/source-build/src/coreclr/src/.nuget/Microsoft.NETCore.ILDAsm/Microsoft.NETCore.ILDAsm.pkgproj]
      0 Warning(s)
      6 Error(s)
  
  Time Elapsed 00:00:10.56
  Command execution failed with exit code 1.
  ERROR: An error occured in /var/tmp/dotnet/source-build/src/coreclr/Tools/dotnetcli/dotnet /var/tmp/dotnet/source-build/src/coreclr/Tools/run 18. Check 18 logs under /var/tmp/dotnet/source-build/src/coreclr.
  Failed to generate Nuget packages.
  
  'coreclr' failed during build.
  See '/var/tmp/dotnet/source-build/bin/logs/coreclr.log' for more information.
  'known-good' failed during build.
```

I don't understand the "Check 18 logs" bit but here's the full contents of `/var/tmp/dotnet/source-build/bin/logs/coreclr.log`:
 &lt;https://gist.github.com/eroen/d48f0c139e00198a6cb0ef728d4ac3cb&gt;</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>30/08/2018 7:11:21 PM +00:00</CreatedAt>
    <ClosedAt>22/06/2019 8:52:49 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19766</IssueLabelID>
    <Title>Enable BSTR Marshaling Support for x-plat PInvoke</Title>
    <Description>Fix https://github.com/dotnet/coreclr/issues/19735

Workitem:
1. [Done]Enable BSTR Marshalling on PInvoke
2. [Done]Add more testing for BSTR PInvoke-- Windows compile/run OK
3. [Exclude] Test BSTR Pinvoke in Linux</Description>
    <Title_Description>Enable BSTR Marshaling Support for x-plat PInvoke Fix https://github.com/dotnet/coreclr/issues/19735

Workitem:
1. [Done]Enable BSTR Marshalling on PInvoke
2. [Done]Add more testing for BSTR PInvoke-- Windows compile/run OK
3. [Exclude] Test BSTR Pinvoke in Linux</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>luqunl</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19764</IssueLabelID>
    <Title>[TieredCompilation] Hot method when inlined never reaches tier 1</Title>
    <Description>The problem arises in application processing data with one very hot method doing 9999% of the work which is inlined into cold method. Hot method never reaches tier1 compilation due to lack of tracking of it's pseudo calls and never gets optimized. The impact on application overall performance is 5 - 7 % performance regression.

Hot method cannot be prevented from inlining as this would cause much higher performance regression.</Description>
    <Title_Description>[TieredCompilation] Hot method when inlined never reaches tier 1 The problem arises in application processing data with one very hot method doing 9999% of the work which is inlined into cold method. Hot method never reaches tier1 compilation due to lack of tracking of it's pseudo calls and never gets optimized. The impact on application overall performance is 5 - 7 % performance regression.

Hot method cannot be prevented from inlining as this would cause much higher performance regression.</Title_Description>
    <Label>area-TieredCompilation</Label>
    <Assignee>4creators</Assignee>
    <CreatedAt>30/08/2018 8:58:05 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19763</IssueLabelID>
    <Title>typo fix</Title>
    <Description>Fixing typo in DAC notes. 
To be specific 
changed `Object layout must be identical in host and targe`  to `Object layout must be identical in host and target`.</Description>
    <Title_Description>typo fix Fixing typo in DAC notes. 
To be specific 
changed `Object layout must be identical in host and targe`  to `Object layout must be identical in host and target`.</Title_Description>
    <Label>documentation</Label>
    <Assignee>sywhang</Assignee>
    <CreatedAt>30/08/2018 8:45:07 AM +00:00</CreatedAt>
    <ClosedAt>30/08/2018 10:00:03 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19762</IssueLabelID>
    <Title>Fix UNKNOWN in dump generated by createdump</Title>
    <Description>https://github.com/dotnet/coreclr/pull/19761

With the current implementation an LLDB analysis of a dump generated with the -h option leads to UNKNOWN instead of type/method names in dumpheap -stat or dumpstack commands.
This is due to missing assemblies from which the sos/mscordac plugin are extracting metadata.

With this pull request the assemblies are now part of the dump without increasing too much the size: on a dual core machine full=11GB withheap=226MB withheap(+patch)=269MB

It is especially important to decrease the size of a "usable" memory dump in the context of containers for which disk space is restricted and time during which an application does not respond to help check is limited.

Note: does not seem to be fixed on 2.1*</Description>
    <Title_Description>Fix UNKNOWN in dump generated by createdump https://github.com/dotnet/coreclr/pull/19761

With the current implementation an LLDB analysis of a dump generated with the -h option leads to UNKNOWN instead of type/method names in dumpheap -stat or dumpstack commands.
This is due to missing assemblies from which the sos/mscordac plugin are extracting metadata.

With this pull request the assemblies are now part of the dump without increasing too much the size: on a dual core machine full=11GB withheap=226MB withheap(+patch)=269MB

It is especially important to decrease the size of a "usable" memory dump in the context of containers for which disk space is restricted and time during which an application does not respond to help check is limited.

Note: does not seem to be fixed on 2.1*</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>mikem8361</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19760</IssueLabelID>
    <Title>Basic implementation for testing of COM activation of a .NET class</Title>
    <Description>This represents a partial implementation for dotnet/core-setup#4476

It current contains the following:
* minimal SPCL API implementation - only for RegFree COM scenario
* implementation of a host library for testing of activation scenarios
  - Note the `CoreShim` library is analogous to the `CoreRun` exe and only for testing 
* basic unit test of the SPCL API
* simple e2e test using RegFree COM

cc @jkotas @jeffschwMSFT @luqunl </Description>
    <Title_Description>Basic implementation for testing of COM activation of a .NET class This represents a partial implementation for dotnet/core-setup#4476

It current contains the following:
* minimal SPCL API implementation - only for RegFree COM scenario
* implementation of a host library for testing of activation scenarios
  - Note the `CoreShim` library is analogous to the `CoreRun` exe and only for testing 
* basic unit test of the SPCL API
* simple e2e test using RegFree COM

cc @jkotas @jeffschwMSFT @luqunl </Title_Description>
    <Label>area-Interop</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>30/08/2018 4:26:58 AM +00:00</CreatedAt>
    <ClosedAt>11/09/2018 12:24:50 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19759</IssueLabelID>
    <Title>[TieredCompilation] Miscellaneous regressions with tiering need investigation</Title>
    <Description>- [x] JitBench Word2Vec benchmark’s "first search" numbers regressed significantly (350%)
  - Perhaps a case of cold method with hot loops (https://github.com/dotnet/coreclr/issues/19751)
  - Duplicate of https://github.com/dotnet/coreclr/issues/19751 until that is fixed tiering should be turned off for this test
- [x] Word2Vec's "training" is also slower but to a much lesser degree perhaps a combination of the above and https://github.com/dotnet/coreclr/issues/19752 until that is fixed tiering should be turned off for this test
  - Duplicate of https://github.com/dotnet/coreclr/issues/19751
- [x] JitBench CscRoslynSource benchark
  - Project compilation completes while there is still tier 0 activity occurring so call counting and tier 1 transitions don't happen
  - There's lots of room for throughput improvement with tier 1 JIT perhaps it needs better heuristics to determine when to transition
  - No regressions in first or subsequent iterations as of https://github.com/dotnet/coreclr/pull/18610
  - Tracking potential improvements separately
- [x] Potential code locality issues - see https://github.com/dotnet/coreclr/pull/19121#issuecomment-408014042 and https://github.com/dotnet/coreclr/pull/19121#issuecomment-409925789
  - Code locality issues are unconfirmed tracking potential improvements separately</Description>
    <Title_Description>[TieredCompilation] Miscellaneous regressions with tiering need investigation - [x] JitBench Word2Vec benchmark’s "first search" numbers regressed significantly (350%)
  - Perhaps a case of cold method with hot loops (https://github.com/dotnet/coreclr/issues/19751)
  - Duplicate of https://github.com/dotnet/coreclr/issues/19751 until that is fixed tiering should be turned off for this test
- [x] Word2Vec's "training" is also slower but to a much lesser degree perhaps a combination of the above and https://github.com/dotnet/coreclr/issues/19752 until that is fixed tiering should be turned off for this test
  - Duplicate of https://github.com/dotnet/coreclr/issues/19751
- [x] JitBench CscRoslynSource benchark
  - Project compilation completes while there is still tier 0 activity occurring so call counting and tier 1 transitions don't happen
  - There's lots of room for throughput improvement with tier 1 JIT perhaps it needs better heuristics to determine when to transition
  - No regressions in first or subsequent iterations as of https://github.com/dotnet/coreclr/pull/18610
  - Tracking potential improvements separately
- [x] Potential code locality issues - see https://github.com/dotnet/coreclr/pull/19121#issuecomment-408014042 and https://github.com/dotnet/coreclr/pull/19121#issuecomment-409925789
  - Code locality issues are unconfirmed tracking potential improvements separately</Title_Description>
    <Label>area-TieredCompilation</Label>
    <Assignee>kouvel</Assignee>
    <CreatedAt>30/08/2018 3:12:54 AM +00:00</CreatedAt>
    <ClosedAt>20/12/2018 6:23:33 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19758</IssueLabelID>
    <Title>API Proposal: Expose TheadPool.UnsafeQueueCustomWorkItem and IThreadPoolWorkItem</Title>
    <Description>When looking at a memory dump it would be great if we could see data about work items in the various queues. Some of the things that would be interesting to see per work item
- A display name (HttpRequest/TaskContinuation) that can be provided by the caller
- An elapsed time to know how long an item was in the queue

This sort of info might help when looking at dumps trying to diagnose issues with the thread pool.

To enable this and other optimized scheduling scenarios we should expose an interface that would allow customization of the underlying work item.

Proposal:

```C#
public interface IThreadPoolWorkItem
{
    void Execute();
}

public class ThreadPool
{
    public static void UnsafeQueueUserWorkItem(IThreadPoolWorkItem workItem bool preferLocal);
}
```

These are advanced APIs and as such there's no overload that captures the `ExecutionContext` (I'm not sure how it could anyways)

cc @stephentoub @kouvel @vancem </Description>
    <Title_Description>API Proposal: Expose TheadPool.UnsafeQueueCustomWorkItem and IThreadPoolWorkItem When looking at a memory dump it would be great if we could see data about work items in the various queues. Some of the things that would be interesting to see per work item
- A display name (HttpRequest/TaskContinuation) that can be provided by the caller
- An elapsed time to know how long an item was in the queue

This sort of info might help when looking at dumps trying to diagnose issues with the thread pool.

To enable this and other optimized scheduling scenarios we should expose an interface that would allow customization of the underlying work item.

Proposal:

```C#
public interface IThreadPoolWorkItem
{
    void Execute();
}

public class ThreadPool
{
    public static void UnsafeQueueUserWorkItem(IThreadPoolWorkItem workItem bool preferLocal);
}
```

These are advanced APIs and as such there's no overload that captures the `ExecutionContext` (I'm not sure how it could anyways)

cc @stephentoub @kouvel @vancem </Title_Description>
    <Label>area-System.Threading</Label>
    <Assignee>stephentoub</Assignee>
    <CreatedAt>30/08/2018 3:03:00 AM +00:00</CreatedAt>
    <ClosedAt>26/09/2018 3:47:51 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19757</IssueLabelID>
    <Title>[TieredCompilation] Background jitting at tier 1 may cause temporary noticeable slowdown in throughput</Title>
    <Description>Background jitting at tier 1 may cause a substantial slowdown in throughput of other threads despite there being enough CPU power to handle all scheduled parallel work without context-switching due to time slicing though for a relatively short duration.

Don't have a repro at the moment but shouldn't be too difficult to create one. There was a scenario where an ASP.NET server saw ~7x slowdown in 2 consecutive requests (out of over 1000) after about 1.5 minutes of serving requests from startup. That coincided with a significant amount of tier 1 jitting.

Any small amount of tier 0 activity (tier 0 jitting or pregenerated code lookup) is treated as "startup-like work" and tiered compilation delays call counting and tier 1 transitions as long as such work is happening even occasionally. At some point when such startup-like work stops for a sufficiently long duration the now-long list of pending methods to call-count and transition to tier 1 is processed and the overhead of call counting and background tier 1 jitting becomes noticeable in the decrease in throughput. The overhead of call counting is understandable (and by design at the moment) but background tier 1 jitting also contributes significantly to the degradation in throughput though both are temporary. A suspicion was that there are frequently taken locks in the type system that get in the way of each thread making optimal progress.

The issue is much more noticeable by disabling the call counting delay (`COMPlus_TieredCompilation_Tier1CallCountingDelayMs=0`).</Description>
    <Title_Description>[TieredCompilation] Background jitting at tier 1 may cause temporary noticeable slowdown in throughput Background jitting at tier 1 may cause a substantial slowdown in throughput of other threads despite there being enough CPU power to handle all scheduled parallel work without context-switching due to time slicing though for a relatively short duration.

Don't have a repro at the moment but shouldn't be too difficult to create one. There was a scenario where an ASP.NET server saw ~7x slowdown in 2 consecutive requests (out of over 1000) after about 1.5 minutes of serving requests from startup. That coincided with a significant amount of tier 1 jitting.

Any small amount of tier 0 activity (tier 0 jitting or pregenerated code lookup) is treated as "startup-like work" and tiered compilation delays call counting and tier 1 transitions as long as such work is happening even occasionally. At some point when such startup-like work stops for a sufficiently long duration the now-long list of pending methods to call-count and transition to tier 1 is processed and the overhead of call counting and background tier 1 jitting becomes noticeable in the decrease in throughput. The overhead of call counting is understandable (and by design at the moment) but background tier 1 jitting also contributes significantly to the degradation in throughput though both are temporary. A suspicion was that there are frequently taken locks in the type system that get in the way of each thread making optimal progress.

The issue is much more noticeable by disabling the call counting delay (`COMPlus_TieredCompilation_Tier1CallCountingDelayMs=0`).</Title_Description>
    <Label>area-TieredCompilation</Label>
    <Assignee>kouvel</Assignee>
    <CreatedAt>30/08/2018 2:54:28 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19756</IssueLabelID>
    <Title>Update existing COM test assets (native/managed) to share CLSIDs with…</Title>
    <Description>… other projects.</Description>
    <Title_Description>Update existing COM test assets (native/managed) to share CLSIDs with… … other projects.</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>30/08/2018 1:29:46 AM +00:00</CreatedAt>
    <ClosedAt>30/08/2018 10:01:13 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19755</IssueLabelID>
    <Title>Unify assembly name creation</Title>
    <Description>
    </Description>
    <Title_Description>Unify assembly name creation </Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>30/08/2018 1:26:08 AM +00:00</CreatedAt>
    <ClosedAt>12/10/2018 5:31:35 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19754</IssueLabelID>
    <Title>Fire a runtime event when ThreadPool is being starved</Title>
    <Description>Thread pool starvation is a pretty common problem when working with code that uses the thread pool extensively. When exhaustion happens the application falls apart at the hinges because the scheduled work items just don't fire:

- Timer callbacks don't run
- Task continuations may not complete

etc.

There are a couple of situations where I think a diagnostic event can help:
- New work items are being enqueued at a rate faster than work items are being completed
- All threads are blocked but there's more work to be done (you've hit the max configured threads)

There's more scenarios but I don't precisely know enough about how the thread pool metrics and thread injection works to articulate it. Any other ideas would be welcome.

cc @brianrob @vancem @stephentoub @kouvel @geoffkizer </Description>
    <Title_Description>Fire a runtime event when ThreadPool is being starved Thread pool starvation is a pretty common problem when working with code that uses the thread pool extensively. When exhaustion happens the application falls apart at the hinges because the scheduled work items just don't fire:

- Timer callbacks don't run
- Task continuations may not complete

etc.

There are a couple of situations where I think a diagnostic event can help:
- New work items are being enqueued at a rate faster than work items are being completed
- All threads are blocked but there's more work to be done (you've hit the max configured threads)

There's more scenarios but I don't precisely know enough about how the thread pool metrics and thread injection works to articulate it. Any other ideas would be welcome.

cc @brianrob @vancem @stephentoub @kouvel @geoffkizer </Title_Description>
    <Label>area-System.Threading</Label>
    <Assignee>stephentoub</Assignee>
    <CreatedAt>30/08/2018 1:02:55 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19752</IssueLabelID>
    <Title>[TieredCompilation] Virtual calls may be slower with tiering</Title>
    <Description>With tiering there is an extra precode that calls would have to go through in some cases. If the processor does not compensate for the extra indirection virtual calls are slower (normal calls are too but that overhead is more easily compensated for with inlining).

See https://github.com/dotnet/coreclr/issues/18361 for an example where virtual call overhead is significant in the measurement.

Considerations:
- For virtual calls I had prototyped using the virtual slot with an indirect call instead of the precode and it eliminated the regression in the test case above. It looks like this would also close most of the steady-state perf gap in JitBench benchmarks between tiering and full-opt JIT alone. The idea seems promising it should be completed.
- For normal calls I had prototyped using an indirect call instead of jumping over a trampoline. There were marginal improvements during startup when with tier 0 JIT there would be more calls than at steady-state but nothing significant since R2R'ed code also does some inlining. Without R2R it may be more interesting.</Description>
    <Title_Description>[TieredCompilation] Virtual calls may be slower with tiering With tiering there is an extra precode that calls would have to go through in some cases. If the processor does not compensate for the extra indirection virtual calls are slower (normal calls are too but that overhead is more easily compensated for with inlining).

See https://github.com/dotnet/coreclr/issues/18361 for an example where virtual call overhead is significant in the measurement.

Considerations:
- For virtual calls I had prototyped using the virtual slot with an indirect call instead of the precode and it eliminated the regression in the test case above. It looks like this would also close most of the steady-state perf gap in JitBench benchmarks between tiering and full-opt JIT alone. The idea seems promising it should be completed.
- For normal calls I had prototyped using an indirect call instead of jumping over a trampoline. There were marginal improvements during startup when with tier 0 JIT there would be more calls than at steady-state but nothing significant since R2R'ed code also does some inlining. Without R2R it may be more interesting.</Title_Description>
    <Label>area-TieredCompilation</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19751</IssueLabelID>
    <Title>[TieredCompilation] Cold methods with hot loops may run slower with tiering</Title>
    <Description>```c#
internal static class Program
{
    private const int HistoryCount = 8;
    private const int InnerIterationCount = 256;
    private static readonly TimeSpan s_ts500ms = TimeSpan.FromMilliseconds(500);

    private static void Main()
    {
        var sw = new Stopwatch();
        var history = new Queue&lt;double&gt;(HistoryCount);
        var list = new List&lt;int&gt;(InnerIterationCount);
        for (int outerIteration = -1; outerIteration &lt; HistoryCount; ++outerIteration)
        {
            var duration = s_ts500ms;
            int iterations = 0;
            TimeSpan elapsed;
            sw.Restart();
            do
            {
                // ---
                list.Clear();
                for (int innerIteration = 0; innerIteration &lt; InnerIterationCount; ++innerIteration)
                    list.Add(innerIteration);
                // ---
                ++iterations;
            } while ((iterations &amp; 0xf) != 0 || (elapsed = sw.Elapsed) &lt; duration);

            if (outerIteration &lt; 0)
                continue;

            var iterationsPerMs = iterations / elapsed.TotalMilliseconds;
            if (history.Count &gt;= HistoryCount)
                history.Dequeue();
            history.Enqueue(iterationsPerMs);
            Console.WriteLine($"{iterationsPerMs10:0.00} {history.Average()10:0.00}");
        }
    }
}
```

Average iterations per ms with tiering disabled: `2775.05`
Tiering enabled: `2045.84`

A comparison of PerfView profiles shows that some inlining is not happening:
```
Name                                                                               	Inc %	     Inc	Exc %	   Exc
 test!Program.Main()                                                               	 97.7	   4485	 29.9	 1375
+ system.private.corelib!System.Collections.Generic.List`1[System.Int32].Add(Int32)	 66.9	   3072	 66.8	 3069
```

The JITStats summary shows that the only JIT trigger for `Main` is `FG` (foreground) which when tiering is enabled is tier 0 (minopts) which does not do inlining. There is no `TC` trigger to indicate tier 1 for `Main`.

A workaround is to move the iteration code into a separate method:
```c#
internal static class Program
{
    private const int HistoryCount = 8;
    private const int InnerIterationCount = 256;
    private static readonly TimeSpan s_ts500ms = TimeSpan.FromMilliseconds(500);

    private static void Main()
    {
        var sw = new Stopwatch();
        var history = new Queue&lt;double&gt;(HistoryCount);
        var list = new List&lt;int&gt;(InnerIterationCount);
        for (int outerIteration = -1; outerIteration &lt; HistoryCount; ++outerIteration)
        {
            var duration = s_ts500ms;
            int iterations = 0;
            TimeSpan elapsed;
            sw.Restart();
            do
            {
                // ---
                RunIteration(list);
                // ---
                ++iterations;
            } while ((iterations &amp; 0xf) != 0 || (elapsed = sw.Elapsed) &lt; duration);

            if (outerIteration &lt; 0)
                continue;

            var iterationsPerMs = iterations / elapsed.TotalMilliseconds;
            if (history.Count &gt;= HistoryCount)
                history.Dequeue();
            history.Enqueue(iterationsPerMs);
            Console.WriteLine($"{iterationsPerMs10:0.00} {history.Average()10:0.00}");
        }
    }

    private static void RunIteration(List&lt;int&gt; list)
    {
        list.Clear();
        for (int innerIteration = 0; innerIteration &lt; InnerIterationCount; ++innerIteration)
            list.Add(innerIteration);
    }
}
```

Average iterations per ms with tiering disabled: `2775.55`
Tiering enabled: `2728.70`

The PerfView profile now shows most of the time spent is exclusively in `RunIteration` as expected:
```
Name                                                                                	Inc %	     Inc	Exc %	   Exc	    First	      Last
 test!Program.Main()                                                                	 98.0	   4490	  0.5	    22	1567.832	 6074.464
+ test!Program.RunIteration(class System.Collections.Generic.List`1)                	 97.0	   4443	 93.5	 4283	1568.696	 6074.464
|+ system.private.corelib!System.Collections.Generic.List`1[System.Int32].Add(Int32)	  3.5	     159	  3.5	   159	1569.678	 1792.351
```

`List.Add` is still showing up and that must be when `RunIteration` was at tier 0 as the JITStats summary shows:

Start (msec) | JitTime   msec | IL Size | Native Size | Method Name | Trigger
-- | -- | -- | -- | -- | --
1568.151 | 0.1 | 30 | 74 | Program.RunIteration(class   System.Collections.Generic.List`1) | FG
1791.821 | 0.6 | 30 | 78 | Program.RunIteration(class   System.Collections.Generic.List`1) | TC

The last sample in `List.Add` in the profile was at `1792.351`. The tier 1 JIT for `RunIteration` was initiated at `1791.821` and would have completed at around `1792.421`.

Other workarounds:
- For benchmarks where each iteration of the benchmark is very short (a few milliseconds or less) use something like BenchmarkDotNet where tiering would occur during the piloting or warmup phases and would not affect the measured phase. If each iteration of the benchmark takes longer the number of warmup iterations may be increased to allow enough time for tiering to occur before measurement begins.
- Disable tier 0 JIT (in environment `COMPlus_TieredCompilation_DisableTier0Jit=1` or in project file `&lt;DisableTier0Jit&gt;true&lt;/DisableTier0Jit&gt;`). In this mode methods that don't have pregenerated code would be optimized initially. It may be useful as a global workaround for a suite of benchmarks where there may be several instances of cold methods with hot loops. For apps it would avoid the worst-case situations where a cold method jitted at tier 0 contains a hot loop that runs for a long time. It would still be possible to be running a long-running hot loop in a cold method that has not yet been jitted at tier 1 but it would be running optimized pregenerated code so the perf may be reasonable and the issue may not be as severe.
- Attribute methods expected to contain hot code with `MethodImplOptions.AggressiveOptimization`. In the first example above that would be:
  ```c#
    [MethodImpl(MethodImplOptions.AggressiveOptimization)]
    private static void Main()
    {
        ...
    }
  ```
- Turn off tiered compilation (in environment `COMPlus_TieredCompilation=0` or in project file `&lt;TieredCompilation&gt;false&lt;/TieredCompilation&gt;`) for such types of benchmarks

Considerations:
- Consider optimizing loops at tier 0 or methods containing loops. Data needs to be collected on how this would affect startup performance.
- Longer-term: A proper fix would probably involve at least some portions of what OSR involves</Description>
    <Title_Description>[TieredCompilation] Cold methods with hot loops may run slower with tiering ```c#
internal static class Program
{
    private const int HistoryCount = 8;
    private const int InnerIterationCount = 256;
    private static readonly TimeSpan s_ts500ms = TimeSpan.FromMilliseconds(500);

    private static void Main()
    {
        var sw = new Stopwatch();
        var history = new Queue&lt;double&gt;(HistoryCount);
        var list = new List&lt;int&gt;(InnerIterationCount);
        for (int outerIteration = -1; outerIteration &lt; HistoryCount; ++outerIteration)
        {
            var duration = s_ts500ms;
            int iterations = 0;
            TimeSpan elapsed;
            sw.Restart();
            do
            {
                // ---
                list.Clear();
                for (int innerIteration = 0; innerIteration &lt; InnerIterationCount; ++innerIteration)
                    list.Add(innerIteration);
                // ---
                ++iterations;
            } while ((iterations &amp; 0xf) != 0 || (elapsed = sw.Elapsed) &lt; duration);

            if (outerIteration &lt; 0)
                continue;

            var iterationsPerMs = iterations / elapsed.TotalMilliseconds;
            if (history.Count &gt;= HistoryCount)
                history.Dequeue();
            history.Enqueue(iterationsPerMs);
            Console.WriteLine($"{iterationsPerMs10:0.00} {history.Average()10:0.00}");
        }
    }
}
```

Average iterations per ms with tiering disabled: `2775.05`
Tiering enabled: `2045.84`

A comparison of PerfView profiles shows that some inlining is not happening:
```
Name                                                                               	Inc %	     Inc	Exc %	   Exc
 test!Program.Main()                                                               	 97.7	   4485	 29.9	 1375
+ system.private.corelib!System.Collections.Generic.List`1[System.Int32].Add(Int32)	 66.9	   3072	 66.8	 3069
```

The JITStats summary shows that the only JIT trigger for `Main` is `FG` (foreground) which when tiering is enabled is tier 0 (minopts) which does not do inlining. There is no `TC` trigger to indicate tier 1 for `Main`.

A workaround is to move the iteration code into a separate method:
```c#
internal static class Program
{
    private const int HistoryCount = 8;
    private const int InnerIterationCount = 256;
    private static readonly TimeSpan s_ts500ms = TimeSpan.FromMilliseconds(500);

    private static void Main()
    {
        var sw = new Stopwatch();
        var history = new Queue&lt;double&gt;(HistoryCount);
        var list = new List&lt;int&gt;(InnerIterationCount);
        for (int outerIteration = -1; outerIteration &lt; HistoryCount; ++outerIteration)
        {
            var duration = s_ts500ms;
            int iterations = 0;
            TimeSpan elapsed;
            sw.Restart();
            do
            {
                // ---
                RunIteration(list);
                // ---
                ++iterations;
            } while ((iterations &amp; 0xf) != 0 || (elapsed = sw.Elapsed) &lt; duration);

            if (outerIteration &lt; 0)
                continue;

            var iterationsPerMs = iterations / elapsed.TotalMilliseconds;
            if (history.Count &gt;= HistoryCount)
                history.Dequeue();
            history.Enqueue(iterationsPerMs);
            Console.WriteLine($"{iterationsPerMs10:0.00} {history.Average()10:0.00}");
        }
    }

    private static void RunIteration(List&lt;int&gt; list)
    {
        list.Clear();
        for (int innerIteration = 0; innerIteration &lt; InnerIterationCount; ++innerIteration)
            list.Add(innerIteration);
    }
}
```

Average iterations per ms with tiering disabled: `2775.55`
Tiering enabled: `2728.70`

The PerfView profile now shows most of the time spent is exclusively in `RunIteration` as expected:
```
Name                                                                                	Inc %	     Inc	Exc %	   Exc	    First	      Last
 test!Program.Main()                                                                	 98.0	   4490	  0.5	    22	1567.832	 6074.464
+ test!Program.RunIteration(class System.Collections.Generic.List`1)                	 97.0	   4443	 93.5	 4283	1568.696	 6074.464
|+ system.private.corelib!System.Collections.Generic.List`1[System.Int32].Add(Int32)	  3.5	     159	  3.5	   159	1569.678	 1792.351
```

`List.Add` is still showing up and that must be when `RunIteration` was at tier 0 as the JITStats summary shows:

Start (msec) | JitTime   msec | IL Size | Native Size | Method Name | Trigger
-- | -- | -- | -- | -- | --
1568.151 | 0.1 | 30 | 74 | Program.RunIteration(class   System.Collections.Generic.List`1) | FG
1791.821 | 0.6 | 30 | 78 | Program.RunIteration(class   System.Collections.Generic.List`1) | TC

The last sample in `List.Add` in the profile was at `1792.351`. The tier 1 JIT for `RunIteration` was initiated at `1791.821` and would have completed at around `1792.421`.

Other workarounds:
- For benchmarks where each iteration of the benchmark is very short (a few milliseconds or less) use something like BenchmarkDotNet where tiering would occur during the piloting or warmup phases and would not affect the measured phase. If each iteration of the benchmark takes longer the number of warmup iterations may be increased to allow enough time for tiering to occur before measurement begins.
- Disable tier 0 JIT (in environment `COMPlus_TieredCompilation_DisableTier0Jit=1` or in project file `&lt;DisableTier0Jit&gt;true&lt;/DisableTier0Jit&gt;`). In this mode methods that don't have pregenerated code would be optimized initially. It may be useful as a global workaround for a suite of benchmarks where there may be several instances of cold methods with hot loops. For apps it would avoid the worst-case situations where a cold method jitted at tier 0 contains a hot loop that runs for a long time. It would still be possible to be running a long-running hot loop in a cold method that has not yet been jitted at tier 1 but it would be running optimized pregenerated code so the perf may be reasonable and the issue may not be as severe.
- Attribute methods expected to contain hot code with `MethodImplOptions.AggressiveOptimization`. In the first example above that would be:
  ```c#
    [MethodImpl(MethodImplOptions.AggressiveOptimization)]
    private static void Main()
    {
        ...
    }
  ```
- Turn off tiered compilation (in environment `COMPlus_TieredCompilation=0` or in project file `&lt;TieredCompilation&gt;false&lt;/TieredCompilation&gt;`) for such types of benchmarks

Considerations:
- Consider optimizing loops at tier 0 or methods containing loops. Data needs to be collected on how this would affect startup performance.
- Longer-term: A proper fix would probably involve at least some portions of what OSR involves</Title_Description>
    <Label>area-TieredCompilation</Label>
    <Assignee>kouvel</Assignee>
    <CreatedAt>29/08/2018 11:57:43 PM +00:00</CreatedAt>
    <ClosedAt>3/04/2019 1:51:45 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19750</IssueLabelID>
    <Title>Enable IJW Native calling managed</Title>
    <Description>Enables filling in the vtable stubs that IJW native code needs to call into managed code. This change restores some of the code that was removed with the ```FEATURE_MIXED_MODE``` removal. However that code included quite a bit of infrastructure for maintaining vtable thunks that could enter different AppDomains. That's not necessary on core so all of that code isn't coming back. This change only addresses loading an IJW assembly when the runtime has already been loaded. Activating the runtime and fixing vtables at that time will be handled separately.</Description>
    <Title_Description>Enable IJW Native calling managed Enables filling in the vtable stubs that IJW native code needs to call into managed code. This change restores some of the code that was removed with the ```FEATURE_MIXED_MODE``` removal. However that code included quite a bit of infrastructure for maintaining vtable thunks that could enter different AppDomains. That's not necessary on core so all of that code isn't coming back. This change only addresses loading an IJW assembly when the runtime has already been loaded. Activating the runtime and fixing vtables at that time will be handled separately.</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>morganbr</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19746</IssueLabelID>
    <Title>Update the emitter to support 2-byte VEX prefix</Title>
    <Description>Currently the emitter only supports the 3-byte VEX prefix (outside a few specially handled instructions).
For normal floating-point arithmetic (or most 128-bit hardware intrinsics) this incurs an extra 1-byte per instruction.

It may be beneficial (for codegen size and potentially throughput) to update the emitter to also support the 2-byte VEX prefix.</Description>
    <Title_Description>Update the emitter to support 2-byte VEX prefix Currently the emitter only supports the 3-byte VEX prefix (outside a few specially handled instructions).
For normal floating-point arithmetic (or most 128-bit hardware intrinsics) this incurs an extra 1-byte per instruction.

It may be beneficial (for codegen size and potentially throughput) to update the emitter to also support the 2-byte VEX prefix.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>fiigii</Assignee>
    <CreatedAt>29/08/2018 11:02:22 PM +00:00</CreatedAt>
    <ClosedAt>11/12/2018 1:41:22 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19744</IssueLabelID>
    <Title>fix merge conflict in build-test.sh</Title>
    <Description>This method was renamed in #19430 but  #19213 did not notice this merge conflict.</Description>
    <Title_Description>fix merge conflict in build-test.sh This method was renamed in #19430 but  #19213 did not notice this merge conflict.</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>29/08/2018 10:12:47 PM +00:00</CreatedAt>
    <ClosedAt>30/08/2018 2:54:43 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19741</IssueLabelID>
    <Title>[Arm64] JIT/Regression/JitBlue/GitHub_19397 fails</Title>
    <Description>
    </Description>
    <Title_Description>[Arm64] JIT/Regression/JitBlue/GitHub_19397 fails </Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19739</IssueLabelID>
    <Title>Remove workaround from floatdouble and floatsingle after the /fp:fast bugs are resolved</Title>
    <Description>https://github.com/dotnet/coreclr/pull/19725 added workarounds to `floatdouble.cpp` and `floatsingle.cpp` to ensure that `ceil` and `floor` return the appropriate values when compiled with MSVC.

This is tracked internally in the DevDiv bug database as workitem 673062 and 673060.</Description>
    <Title_Description>Remove workaround from floatdouble and floatsingle after the /fp:fast bugs are resolved https://github.com/dotnet/coreclr/pull/19725 added workarounds to `floatdouble.cpp` and `floatsingle.cpp` to ensure that `ceil` and `floor` return the appropriate values when compiled with MSVC.

This is tracked internally in the DevDiv bug database as workitem 673062 and 673060.</Title_Description>
    <Label>area-VM</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>29/08/2018 6:07:09 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19735</IssueLabelID>
    <Title>Add support for MarshalAs(UnmanagedType.BSTR) on UNIX systems</Title>
    <Description>Although Marshal.StringToBStr et al. works fine on Mac. The following code
```
delegate void Callback([MarshalAs(UnmanagedType.BStr)]string s);

        [DllImport("libTestDynLib.dylib")]
        static extern void MyTest([MarshalAs(UnmanagedType.BStr)]string s Callback c);

        static void Main(string[] args)
        {
            MyTest("This is a test" s =&gt;
            {
                Console.WriteLine(s);
            });
        }
```
Is failing on Mac:
System.Runtime.InteropServices.MarshalDirectiveException: "Cannot marshal 'parameter #1': Invalid managed/unmanaged type combination (String parameters and return types must be paired with LPStr LPWStr or LPTStr)."
  at TestBSTR.Program.MyTest(String s Callback c)\n   at TestBSTR.Program.Main(String[] args) in /Users/odhanson/Projects/MyGuidTest/TestBSTR/Program.cs:15

Seems like (for looking at the code) this has only been implemented for windows (as part of COM support).

We are currently in the process of porting a FX application to Core that has extensive interop with existing native libraries (that are cross platform). The BSTR is used extensively and we would definitely need support for this type of marshaling.</Description>
    <Title_Description>Add support for MarshalAs(UnmanagedType.BSTR) on UNIX systems Although Marshal.StringToBStr et al. works fine on Mac. The following code
```
delegate void Callback([MarshalAs(UnmanagedType.BStr)]string s);

        [DllImport("libTestDynLib.dylib")]
        static extern void MyTest([MarshalAs(UnmanagedType.BStr)]string s Callback c);

        static void Main(string[] args)
        {
            MyTest("This is a test" s =&gt;
            {
                Console.WriteLine(s);
            });
        }
```
Is failing on Mac:
System.Runtime.InteropServices.MarshalDirectiveException: "Cannot marshal 'parameter #1': Invalid managed/unmanaged type combination (String parameters and return types must be paired with LPStr LPWStr or LPTStr)."
  at TestBSTR.Program.MyTest(String s Callback c)\n   at TestBSTR.Program.Main(String[] args) in /Users/odhanson/Projects/MyGuidTest/TestBSTR/Program.cs:15

Seems like (for looking at the code) this has only been implemented for windows (as part of COM support).

We are currently in the process of porting a FX application to Core that has extensive interop with existing native libraries (that are cross platform). The BSTR is used extensively and we would definitely need support for this type of marshaling.</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>richlander</Assignee>
    <CreatedAt>29/08/2018 2:17:08 PM +00:00</CreatedAt>
    <ClosedAt>6/12/2018 11:29:59 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19734</IssueLabelID>
    <Title>Question hosting a coreclr runtime with unix apis resolving packages from ".deps.json" file?</Title>
    <Description>From my understanding the unix hosting apis of the coreclr are low-level primitives that lack that ability to use the runtimeconfig.json file or the .deps.json file (which core-setup does).

So in order to run an application from the hosting APIs I must have deployed my app in it's entirety to a folder (NuGet packages and all) for the coreclr to find all the assemblies required to run my program. I could use ```APP_PATHS``` but that is problematic because of the following.

I am building an embedded system. I will have multiple deployed .NET applications on my machine. To reduce disk size I will create a store manifest (```dotnet store```) to keep commonly used libs in a single shared location.

When I publish my applications with the shared manifest there will be many missing libs in the published directory (which is expected).

This wouldn't be an issue if I was using the ```dotnet``` command since it handles resolving dynamic dependencies from a package cache but I am self-hosting the coreclr.

This shared package store is layed out like a NuGet package cache. The traditional ```dotnet``` command (core-setup) knows how to find these assemblies (assuming from the ".deps.json" file) and build a proper coreclr instance that can find all the referenced assemblies.

But what do I do if I self-host? Should I manually parse the .deps.json file and build the ```APP_PATHS``` myself? Same thing for the ```NATIVE_DLL_SEARCH_DIRECTORIES```? If I build the ```NATIVE_DLL_SEARCH_DIRECTORIES``` myself will I have to handle finding the proper "runtime/{rid}/native" to import (```ubuntu.18.04-x64``` &gt; ```ubuntu-x64``` &gt; ```linux-x64``` &gt; ```linux```)?</Description>
    <Title_Description>Question, hosting a coreclr runtime with unix apis, resolving packages from ".deps.json" file? From my understanding the unix hosting apis of the coreclr are low-level primitives that lack that ability to use the runtimeconfig.json file or the .deps.json file (which core-setup does).

So in order to run an application from the hosting APIs I must have deployed my app in it's entirety to a folder (NuGet packages and all) for the coreclr to find all the assemblies required to run my program. I could use ```APP_PATHS``` but that is problematic because of the following.

I am building an embedded system. I will have multiple deployed .NET applications on my machine. To reduce disk size I will create a store manifest (```dotnet store```) to keep commonly used libs in a single shared location.

When I publish my applications with the shared manifest there will be many missing libs in the published directory (which is expected).

This wouldn't be an issue if I was using the ```dotnet``` command since it handles resolving dynamic dependencies from a package cache but I am self-hosting the coreclr.

This shared package store is layed out like a NuGet package cache. The traditional ```dotnet``` command (core-setup) knows how to find these assemblies (assuming from the ".deps.json" file) and build a proper coreclr instance that can find all the referenced assemblies.

But what do I do if I self-host? Should I manually parse the .deps.json file and build the ```APP_PATHS``` myself? Same thing for the ```NATIVE_DLL_SEARCH_DIRECTORIES```? If I build the ```NATIVE_DLL_SEARCH_DIRECTORIES``` myself will I have to handle finding the proper "runtime/{rid}/native" to import (```ubuntu.18.04-x64``` &gt; ```ubuntu-x64``` &gt; ```linux-x64``` &gt; ```linux```)?</Title_Description>
    <Label>question</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>29/08/2018 12:54:20 PM +00:00</CreatedAt>
    <ClosedAt>29/08/2018 2:30:55 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19733</IssueLabelID>
    <Title>Strange codegen with struct forwarding implementation to another struct</Title>
    <Description>### Info

Setup: Runtime=.NET Core 2.1.3 (CoreCLR 4.6.26725.06 CoreFX 4.6.26725.05) 64bit RyuJIT
Code for repro is at this commit (I haven't reduced it to a minimal repro yet): https://github.com/Porges/Fastre/commit/3a2f805801556282bb341798edef9206af162256 (the `Accepts` method is what I am looking at and the structs are `Vector128Impl` and `Vector256Impl`.)

### Description

I have two structs `T1` and `T2` that implement an interface. These are used via the `default(T1).Func(...)` method to get nice inlined code in a generic function.

The `T2` struct implements all of its methods by forwarding to the `T1` struct so at the moment the behaviour is the same. I would expect the codegen to be the same in both cases if everything in `T2` inlines successfully (which it appears to). However I'm seeing oddities.

The codegen for `T1` looks fine:

```asm
M00_L06 |  
  | movzx   ecxbyte ptr [rax]
  | mov     ecxecx
  | movzx   edxbyte ptr [rax+1]
  | mov     edxedx
  | movzx   r8dbyte ptr [rax+2]
  | mov     r8dr8d
  | movzx   r9dbyte ptr [rax+3]
  | mov     r9dr9d
  | movzx   r10dbyte ptr [rax+4]
  | mov     r10dr10d
  | movzx   r11dbyte ptr [rax+5]
  | mov     r11dr11d
  | movzx   ebxbyte ptr [rax+6]
  | mov     ebxebx
  | shl     rcx4
  | add     rcxrbp
  | shl     rdx4
  | add     rdxrbp
  | shl     r84
  | add     r8rbp
  | shl     r94
  | add     r9rbp
  | shl     r104
  | add     r10rbp
  | shl     r114
  | add     r11rbp
  | shl     rbx4
  | add     rbxrbp
  | vmovdqu xmm0xmmword ptr [rcx]
  | vmovdqu xmm1xmmword ptr [rdx]
  | vmovdqu xmm2xmmword ptr [r8]
  | vmovdqu xmm3xmmword ptr [r9]
  | vmovdqu xmm4xmmword ptr [r10]
  | vmovdqu xmm5xmmword ptr [r11]
  | vmovdqu xmm7xmmword ptr [rbx]
  | vpshufb xmm0xmm0xmm6
  | vpshufb xmm1xmm2xmm1
  | vpshufb xmm2xmm4xmm3
  | vpshufb xmm3xmm7xmm5
  | vpshufb xmm0xmm1xmm0
  | vpshufb xmm1xmm3xmm2
  | vpshufb xmm6xmm1xmm0
  | add     rax7
  | lea     rcx[rax+6]
  | cmp     rcxrdi
  | jb      M00_L05
```

However with `T2` it looks like it's doing something very strange:

```asm
M00_L06 |
  | movzx   ecxbyte ptr [rax]
  | mov     ecxecx
  | movzx   edxbyte ptr [rax+1]
  | mov     edxedx
  | movzx   r8dbyte ptr [rax+2]
  | mov     r8dr8d
  | movzx   r9dbyte ptr [rax+3]
  | mov     r9dr9d
  | movzx   r10dbyte ptr [rax+4]
  | mov     r10dr10d
  | movzx   r11dbyte ptr [rax+5]
  | mov     r11dr11d
  | movzx   ebxbyte ptr [rax+6]
  | mov     ebxebx
  | mov     byte ptr [rsp+240h]0
  | lea     r14[rsp+240h]
  | mov     byte ptr [r14]0
  | shl     rcx4
  | add     rcxrbp
  | mov     byte ptr [rsp+238h]0
  | lea     r14[rsp+238h]
  | mov     byte ptr [r14]0
  | shl     rdx4
  | add     rdxrbp
  | mov     byte ptr [rsp+230h]0
  | lea     r14[rsp+230h]
  | mov     byte ptr [r14]0
  | shl     r84
  | add     r8rbp
  | mov     byte ptr [rsp+228h]0
  | lea     r14[rsp+228h]
  | mov     byte ptr [r14]0
  | shl     r94
  | add     r9rbp
  | mov     byte ptr [rsp+220h]0
  | lea     r14[rsp+220h]
  | mov     byte ptr [r14]0
  | shl     r104
  | add     r10rbp
  | mov     byte ptr [rsp+218h]0
  | lea     r14[rsp+218h]
  | mov     byte ptr [r14]0
  | shl     r114
  | add     r11rbp
  | mov     byte ptr [rsp+210h]0
  | lea     r14[rsp+210h]
  | mov     byte ptr [r14]0
  | shl     rbx4
  | add     rbxrbp
  | mov     byte ptr [rsp+208h]0
  | lea     r14[rsp+208h]
  | mov     byte ptr [r14]0
  | vmovdqu xmm0xmmword ptr [rcx]
  | mov     byte ptr [rsp+200h]0
  | lea     rcx[rsp+200h]
  | mov     byte ptr [rcx]0
  | vmovdqu xmm1xmmword ptr [rdx]
  | mov     byte ptr [rsp+1F8h]0
  | lea     rcx[rsp+1F8h]
  | mov     byte ptr [rcx]0
  | vmovdqu xmm2xmmword ptr [r8]
  | mov     byte ptr [rsp+1F0h]0
  | lea     rcx[rsp+1F0h]
  | mov     byte ptr [rcx]0
  | vmovdqu xmm3xmmword ptr [r9]
  | mov     byte ptr [rsp+1E8h]0
  | lea     rcx[rsp+1E8h]
  | mov     byte ptr [rcx]0
  | vmovdqu xmm4xmmword ptr [r10]
  | mov     byte ptr [rsp+1E0h]0
  | lea     rcx[rsp+1E0h]
  | mov     byte ptr [rcx]0
  | vmovdqu xmm5xmmword ptr [r11]
  | mov     byte ptr [rsp+1D8h]0
  | lea     rcx[rsp+1D8h]
  | mov     byte ptr [rcx]0
  | vmovdqu xmm7xmmword ptr [rbx]
  | vmovapd xmmword ptr [rsp+1C0h]xmm0
  | vmovapd xmmword ptr [rsp+1B0h]xmm6
  | mov     byte ptr [rsp+1D0h]0
  | lea     rcx[rsp+1D0h]
  | mov     byte ptr [rcx]0
  | vmovapd xmm0xmmword ptr [rsp+1C0h]
  | vmovapd xmm6xmmword ptr [rsp+1B0h]
  | vpshufb xmm0xmm0xmm6
  | vmovapd xmmword ptr [rsp+190h]xmm2
  | vmovapd xmmword ptr [rsp+180h]xmm1
  | mov     byte ptr [rsp+1A8h]0
  | lea     rcx[rsp+1A8h]
  | mov     byte ptr [rcx]0
  | vmovapd xmm1xmmword ptr [rsp+190h]
  | vmovapd xmm2xmmword ptr [rsp+180h]
  | vpshufb xmm1xmm1xmm2
  | vmovapd xmmword ptr [rsp+160h]xmm4
  | vmovapd xmmword ptr [rsp+150h]xmm3
  | mov     byte ptr [rsp+178h]0
  | lea     rcx[rsp+178h]
  | mov     byte ptr [rcx]0
  | vmovapd xmm2xmmword ptr [rsp+160h]
  | vmovapd xmm3xmmword ptr [rsp+150h]
  | vpshufb xmm2xmm2xmm3
  | vmovapd xmmword ptr [rsp+130h]xmm7
  | vmovapd xmmword ptr [rsp+120h]xmm5
  | mov     byte ptr [rsp+148h]0
  | lea     rcx[rsp+148h]
  | mov     byte ptr [rcx]0
  | vmovapd xmm3xmmword ptr [rsp+130h]
  | vmovapd xmm4xmmword ptr [rsp+120h]
  | vpshufb xmm3xmm3xmm4
  | vmovapd xmmword ptr [rsp+100h]xmm1
  | vmovapd xmmword ptr [rsp+0F0h]xmm0
  | mov     byte ptr [rsp+118h]0
  | lea     rcx[rsp+118h]
  | mov     byte ptr [rcx]0
  | vmovapd xmm0xmmword ptr [rsp+100h]
  | vmovapd xmm1xmmword ptr [rsp+0F0h]
  | vpshufb xmm0xmm0xmm1
  | vmovapd xmmword ptr [rsp+0D0h]xmm3
  | vmovapd xmmword ptr [rsp+0C0h]xmm2
  | mov     byte ptr [rsp+0E8h]0
  | lea     rcx[rsp+0E8h]
  | mov     byte ptr [rcx]0
  | vmovapd xmm1xmmword ptr [rsp+0D0h]
  | vmovapd xmm2xmmword ptr [rsp+0C0h]
  | vpshufb xmm1xmm1xmm2
  | vmovapd xmmword ptr [rsp+0A0h]xmm1
  | vmovapd xmmword ptr [rsp+90h]xmm0
  | mov     byte ptr [rsp+0B8h]0
  | lea     rcx[rsp+0B8h]
  | mov     byte ptr [rcx]0
  | vmovapd xmm0xmmword ptr [rsp+0A0h]
  | vmovapd xmm1xmmword ptr [rsp+90h]
  | vpshufb xmm6xmm0xmm1
  | add     rax7
  | lea     rcx[rax+6]
  | cmp     rcxrdi
  | jb      M00_L05
```

You can see more of the disassembly here: https://gist.github.com/Porges/334ca424055be72470a67bc6eefe43a8

category:cq
theme:structs
skill-level:expert
cost:large</Description>
    <Title_Description>Strange codegen with struct forwarding implementation to another struct ### Info

Setup: Runtime=.NET Core 2.1.3 (CoreCLR 4.6.26725.06 CoreFX 4.6.26725.05) 64bit RyuJIT
Code for repro is at this commit (I haven't reduced it to a minimal repro yet): https://github.com/Porges/Fastre/commit/3a2f805801556282bb341798edef9206af162256 (the `Accepts` method is what I am looking at and the structs are `Vector128Impl` and `Vector256Impl`.)

### Description

I have two structs `T1` and `T2` that implement an interface. These are used via the `default(T1).Func(...)` method to get nice inlined code in a generic function.

The `T2` struct implements all of its methods by forwarding to the `T1` struct so at the moment the behaviour is the same. I would expect the codegen to be the same in both cases if everything in `T2` inlines successfully (which it appears to). However I'm seeing oddities.

The codegen for `T1` looks fine:

```asm
M00_L06 |  
  | movzx   ecxbyte ptr [rax]
  | mov     ecxecx
  | movzx   edxbyte ptr [rax+1]
  | mov     edxedx
  | movzx   r8dbyte ptr [rax+2]
  | mov     r8dr8d
  | movzx   r9dbyte ptr [rax+3]
  | mov     r9dr9d
  | movzx   r10dbyte ptr [rax+4]
  | mov     r10dr10d
  | movzx   r11dbyte ptr [rax+5]
  | mov     r11dr11d
  | movzx   ebxbyte ptr [rax+6]
  | mov     ebxebx
  | shl     rcx4
  | add     rcxrbp
  | shl     rdx4
  | add     rdxrbp
  | shl     r84
  | add     r8rbp
  | shl     r94
  | add     r9rbp
  | shl     r104
  | add     r10rbp
  | shl     r114
  | add     r11rbp
  | shl     rbx4
  | add     rbxrbp
  | vmovdqu xmm0xmmword ptr [rcx]
  | vmovdqu xmm1xmmword ptr [rdx]
  | vmovdqu xmm2xmmword ptr [r8]
  | vmovdqu xmm3xmmword ptr [r9]
  | vmovdqu xmm4xmmword ptr [r10]
  | vmovdqu xmm5xmmword ptr [r11]
  | vmovdqu xmm7xmmword ptr [rbx]
  | vpshufb xmm0xmm0xmm6
  | vpshufb xmm1xmm2xmm1
  | vpshufb xmm2xmm4xmm3
  | vpshufb xmm3xmm7xmm5
  | vpshufb xmm0xmm1xmm0
  | vpshufb xmm1xmm3xmm2
  | vpshufb xmm6xmm1xmm0
  | add     rax7
  | lea     rcx[rax+6]
  | cmp     rcxrdi
  | jb      M00_L05
```

However with `T2` it looks like it's doing something very strange:

```asm
M00_L06 |
  | movzx   ecxbyte ptr [rax]
  | mov     ecxecx
  | movzx   edxbyte ptr [rax+1]
  | mov     edxedx
  | movzx   r8dbyte ptr [rax+2]
  | mov     r8dr8d
  | movzx   r9dbyte ptr [rax+3]
  | mov     r9dr9d
  | movzx   r10dbyte ptr [rax+4]
  | mov     r10dr10d
  | movzx   r11dbyte ptr [rax+5]
  | mov     r11dr11d
  | movzx   ebxbyte ptr [rax+6]
  | mov     ebxebx
  | mov     byte ptr [rsp+240h]0
  | lea     r14[rsp+240h]
  | mov     byte ptr [r14]0
  | shl     rcx4
  | add     rcxrbp
  | mov     byte ptr [rsp+238h]0
  | lea     r14[rsp+238h]
  | mov     byte ptr [r14]0
  | shl     rdx4
  | add     rdxrbp
  | mov     byte ptr [rsp+230h]0
  | lea     r14[rsp+230h]
  | mov     byte ptr [r14]0
  | shl     r84
  | add     r8rbp
  | mov     byte ptr [rsp+228h]0
  | lea     r14[rsp+228h]
  | mov     byte ptr [r14]0
  | shl     r94
  | add     r9rbp
  | mov     byte ptr [rsp+220h]0
  | lea     r14[rsp+220h]
  | mov     byte ptr [r14]0
  | shl     r104
  | add     r10rbp
  | mov     byte ptr [rsp+218h]0
  | lea     r14[rsp+218h]
  | mov     byte ptr [r14]0
  | shl     r114
  | add     r11rbp
  | mov     byte ptr [rsp+210h]0
  | lea     r14[rsp+210h]
  | mov     byte ptr [r14]0
  | shl     rbx4
  | add     rbxrbp
  | mov     byte ptr [rsp+208h]0
  | lea     r14[rsp+208h]
  | mov     byte ptr [r14]0
  | vmovdqu xmm0xmmword ptr [rcx]
  | mov     byte ptr [rsp+200h]0
  | lea     rcx[rsp+200h]
  | mov     byte ptr [rcx]0
  | vmovdqu xmm1xmmword ptr [rdx]
  | mov     byte ptr [rsp+1F8h]0
  | lea     rcx[rsp+1F8h]
  | mov     byte ptr [rcx]0
  | vmovdqu xmm2xmmword ptr [r8]
  | mov     byte ptr [rsp+1F0h]0
  | lea     rcx[rsp+1F0h]
  | mov     byte ptr [rcx]0
  | vmovdqu xmm3xmmword ptr [r9]
  | mov     byte ptr [rsp+1E8h]0
  | lea     rcx[rsp+1E8h]
  | mov     byte ptr [rcx]0
  | vmovdqu xmm4xmmword ptr [r10]
  | mov     byte ptr [rsp+1E0h]0
  | lea     rcx[rsp+1E0h]
  | mov     byte ptr [rcx]0
  | vmovdqu xmm5xmmword ptr [r11]
  | mov     byte ptr [rsp+1D8h]0
  | lea     rcx[rsp+1D8h]
  | mov     byte ptr [rcx]0
  | vmovdqu xmm7xmmword ptr [rbx]
  | vmovapd xmmword ptr [rsp+1C0h]xmm0
  | vmovapd xmmword ptr [rsp+1B0h]xmm6
  | mov     byte ptr [rsp+1D0h]0
  | lea     rcx[rsp+1D0h]
  | mov     byte ptr [rcx]0
  | vmovapd xmm0xmmword ptr [rsp+1C0h]
  | vmovapd xmm6xmmword ptr [rsp+1B0h]
  | vpshufb xmm0xmm0xmm6
  | vmovapd xmmword ptr [rsp+190h]xmm2
  | vmovapd xmmword ptr [rsp+180h]xmm1
  | mov     byte ptr [rsp+1A8h]0
  | lea     rcx[rsp+1A8h]
  | mov     byte ptr [rcx]0
  | vmovapd xmm1xmmword ptr [rsp+190h]
  | vmovapd xmm2xmmword ptr [rsp+180h]
  | vpshufb xmm1xmm1xmm2
  | vmovapd xmmword ptr [rsp+160h]xmm4
  | vmovapd xmmword ptr [rsp+150h]xmm3
  | mov     byte ptr [rsp+178h]0
  | lea     rcx[rsp+178h]
  | mov     byte ptr [rcx]0
  | vmovapd xmm2xmmword ptr [rsp+160h]
  | vmovapd xmm3xmmword ptr [rsp+150h]
  | vpshufb xmm2xmm2xmm3
  | vmovapd xmmword ptr [rsp+130h]xmm7
  | vmovapd xmmword ptr [rsp+120h]xmm5
  | mov     byte ptr [rsp+148h]0
  | lea     rcx[rsp+148h]
  | mov     byte ptr [rcx]0
  | vmovapd xmm3xmmword ptr [rsp+130h]
  | vmovapd xmm4xmmword ptr [rsp+120h]
  | vpshufb xmm3xmm3xmm4
  | vmovapd xmmword ptr [rsp+100h]xmm1
  | vmovapd xmmword ptr [rsp+0F0h]xmm0
  | mov     byte ptr [rsp+118h]0
  | lea     rcx[rsp+118h]
  | mov     byte ptr [rcx]0
  | vmovapd xmm0xmmword ptr [rsp+100h]
  | vmovapd xmm1xmmword ptr [rsp+0F0h]
  | vpshufb xmm0xmm0xmm1
  | vmovapd xmmword ptr [rsp+0D0h]xmm3
  | vmovapd xmmword ptr [rsp+0C0h]xmm2
  | mov     byte ptr [rsp+0E8h]0
  | lea     rcx[rsp+0E8h]
  | mov     byte ptr [rcx]0
  | vmovapd xmm1xmmword ptr [rsp+0D0h]
  | vmovapd xmm2xmmword ptr [rsp+0C0h]
  | vpshufb xmm1xmm1xmm2
  | vmovapd xmmword ptr [rsp+0A0h]xmm1
  | vmovapd xmmword ptr [rsp+90h]xmm0
  | mov     byte ptr [rsp+0B8h]0
  | lea     rcx[rsp+0B8h]
  | mov     byte ptr [rcx]0
  | vmovapd xmm0xmmword ptr [rsp+0A0h]
  | vmovapd xmm1xmmword ptr [rsp+90h]
  | vpshufb xmm6xmm0xmm1
  | add     rax7
  | lea     rcx[rax+6]
  | cmp     rcxrdi
  | jb      M00_L05
```

You can see more of the disassembly here: https://gist.github.com/Porges/334ca424055be72470a67bc6eefe43a8

category:cq
theme:structs
skill-level:expert
cost:large</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
    <CreatedAt>29/08/2018 9:45:13 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19731</IssueLabelID>
    <Title>Test failure: Interop_IJW._ManagedCallingNative_ManagedCallingNative_ManagedCallingNative_/_ManagedCallingNative_ManagedCallingNative_ManagedCallingNative_cmd</Title>
    <Description>Opened on behalf of @Sunny-pu

The test `Interop_IJW._ManagedCallingNative_ManagedCallingNative_ManagedCallingNative_/_ManagedCallingNative_ManagedCallingNative_ManagedCallingNative_cmd` has failed.


    Unhandled Exception: System.DllNotFoundException: Unable to load shared library 'kernel32.dll' or one of its dependencies. In order to help diagnose loading problems consider setting the DYLD_PRINT_LIBRARIES environment variable: dlopen(libkernel32.dll 1): image not found
       at ManagedCallingNative.ManagedCallingNative.LoadLibraryEx(String lpFileName IntPtr hReservedNull Int32 dwFlags)
       at ManagedCallingNative.ManagedCallingNative.Main(String[] args)
    /Users/dotnet-bot/dotnetbuild/work/e617ae5c-d07f-4bdb-bb60-bf8d42adec7c/Work/9bddec5f-6560-458e-8d2f-357577529060/Unzip/ManagedCallingNative/ManagedCallingNative/ManagedCallingNative.sh: line 244: 37549 Abort trap: 6           $_DebuggerFullPath \"$CORE_ROOT/corerun\" $ExePath $CLRTestExecutionArguments
    
    
    Return code:      1
    Raw output file:      /Users/dotnet-bot/dotnetbuild/work/e617ae5c-d07f-4bdb-bb60-bf8d42adec7c/Work/9bddec5f-6560-458e-8d2f-357577529060/Unzip/Reports\\Interop.IJW\\ManagedCallingNative\\ManagedCallingNative\\ManagedCallingNative.output.txt
    Raw output:
    BEGIN EXECUTION
    /Users/dotnet-bot/dotnetbuild/work/e617ae5c-d07f-4bdb-bb60-bf8d42adec7c/Payload/corerun ManagedCallingNative.exe
    Expected: 100
    Actual: 134
    END EXECUTION - FAILED
    Test Harness Exitcode is : 1
    
    To run the test:
    &gt; set CORE_ROOT=/Users/dotnet-bot/dotnetbuild/work/e617ae5c-d07f-4bdb-bb60-bf8d42adec7c/Payload
    &gt; /Users/dotnet-bot/dotnetbuild/work/e617ae5c-d07f-4bdb-bb60-bf8d42adec7c/Work/9bddec5f-6560-458e-8d2f-357577529060/Unzip/ManagedCallingNative/ManagedCallingNative/ManagedCallingNative.sh
    
    Expected: True
    Actual:   False

        Stack Trace:

           at Interop_IJW._ManagedCallingNative_ManagedCallingNative_ManagedCallingNative_._ManagedCallingNative_ManagedCallingNative_ManagedCallingNative_cmd() in E:\A\_work\80\s\bin\tests\Windows_NT.x64.Release\TestWrappers\Interop.IJW\Interop.IJW.XUnitWrapper.cs:line 111
Build : 3.0 - 20180829.01 (Core Tests)
Failing configurations:
- osx.1013.amd64-x64
  - 
- osx.1012.amd64-x64
  - 
- windows.10.arm64-arm
  - 
- Windows.81.Amd64-x64
  - 
- Windows.7.Amd64-x64
  - 
- Windows.10.Amd64.Core-x64
  - 
- Windows.10.Nano.Amd64-x64
  - 
- Windows.10.Amd64-x64
  - 
- Alpine.36.Amd64-x64
  - 
- sles.12.amd64-x64
  - 
- opensuse.423.amd64-x64
  - 
- ubuntu.1804.amd64-x64
  - 
- ubuntu.1604.amd64-x64
  - 
- ubuntu.1404.amd64-x64
  - 
- redhat.73.amd64-x64
  - 
- fedora.28.amd64-x64
  - 
- fedora.27.amd64-x64
  - 
- debian.82.amd64-x64
  - 
- redhat.69.amd64-x64
  - 
Details: https://mc.dot.net/#/product/netcore/30/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fcli~2F/build/20180829.01/workItem/Interop.IJW.XUnitWrapper/analysis/xunit/Interop_IJW._ManagedCallingNative_ManagedCallingNative_ManagedCallingNative_~2F_ManagedCallingNative_ManagedCallingNative_ManagedCallingNative_cmd</Description>
    <Title_Description>Test failure: Interop_IJW._ManagedCallingNative_ManagedCallingNative_ManagedCallingNative_/_ManagedCallingNative_ManagedCallingNative_ManagedCallingNative_cmd Opened on behalf of @Sunny-pu

The test `Interop_IJW._ManagedCallingNative_ManagedCallingNative_ManagedCallingNative_/_ManagedCallingNative_ManagedCallingNative_ManagedCallingNative_cmd` has failed.


    Unhandled Exception: System.DllNotFoundException: Unable to load shared library 'kernel32.dll' or one of its dependencies. In order to help diagnose loading problems consider setting the DYLD_PRINT_LIBRARIES environment variable: dlopen(libkernel32.dll 1): image not found
       at ManagedCallingNative.ManagedCallingNative.LoadLibraryEx(String lpFileName IntPtr hReservedNull Int32 dwFlags)
       at ManagedCallingNative.ManagedCallingNative.Main(String[] args)
    /Users/dotnet-bot/dotnetbuild/work/e617ae5c-d07f-4bdb-bb60-bf8d42adec7c/Work/9bddec5f-6560-458e-8d2f-357577529060/Unzip/ManagedCallingNative/ManagedCallingNative/ManagedCallingNative.sh: line 244: 37549 Abort trap: 6           $_DebuggerFullPath \"$CORE_ROOT/corerun\" $ExePath $CLRTestExecutionArguments
    
    
    Return code:      1
    Raw output file:      /Users/dotnet-bot/dotnetbuild/work/e617ae5c-d07f-4bdb-bb60-bf8d42adec7c/Work/9bddec5f-6560-458e-8d2f-357577529060/Unzip/Reports\\Interop.IJW\\ManagedCallingNative\\ManagedCallingNative\\ManagedCallingNative.output.txt
    Raw output:
    BEGIN EXECUTION
    /Users/dotnet-bot/dotnetbuild/work/e617ae5c-d07f-4bdb-bb60-bf8d42adec7c/Payload/corerun ManagedCallingNative.exe
    Expected: 100
    Actual: 134
    END EXECUTION - FAILED
    Test Harness Exitcode is : 1
    
    To run the test:
    &gt; set CORE_ROOT=/Users/dotnet-bot/dotnetbuild/work/e617ae5c-d07f-4bdb-bb60-bf8d42adec7c/Payload
    &gt; /Users/dotnet-bot/dotnetbuild/work/e617ae5c-d07f-4bdb-bb60-bf8d42adec7c/Work/9bddec5f-6560-458e-8d2f-357577529060/Unzip/ManagedCallingNative/ManagedCallingNative/ManagedCallingNative.sh
    
    Expected: True
    Actual:   False

        Stack Trace:

           at Interop_IJW._ManagedCallingNative_ManagedCallingNative_ManagedCallingNative_._ManagedCallingNative_ManagedCallingNative_ManagedCallingNative_cmd() in E:\A\_work\80\s\bin\tests\Windows_NT.x64.Release\TestWrappers\Interop.IJW\Interop.IJW.XUnitWrapper.cs:line 111
Build : 3.0 - 20180829.01 (Core Tests)
Failing configurations:
- osx.1013.amd64-x64
  - 
- osx.1012.amd64-x64
  - 
- windows.10.arm64-arm
  - 
- Windows.81.Amd64-x64
  - 
- Windows.7.Amd64-x64
  - 
- Windows.10.Amd64.Core-x64
  - 
- Windows.10.Nano.Amd64-x64
  - 
- Windows.10.Amd64-x64
  - 
- Alpine.36.Amd64-x64
  - 
- sles.12.amd64-x64
  - 
- opensuse.423.amd64-x64
  - 
- ubuntu.1804.amd64-x64
  - 
- ubuntu.1604.amd64-x64
  - 
- ubuntu.1404.amd64-x64
  - 
- redhat.73.amd64-x64
  - 
- fedora.28.amd64-x64
  - 
- fedora.27.amd64-x64
  - 
- debian.82.amd64-x64
  - 
- redhat.69.amd64-x64
  - 
Details: https://mc.dot.net/#/product/netcore/30/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fcli~2F/build/20180829.01/workItem/Interop.IJW.XUnitWrapper/analysis/xunit/Interop_IJW._ManagedCallingNative_ManagedCallingNative_ManagedCallingNative_~2F_ManagedCallingNative_ManagedCallingNative_ManagedCallingNative_cmd</Title_Description>
    <Label>test-run-uwp-coreclr</Label>
    <Assignee>morganbr</Assignee>
    <CreatedAt>29/08/2018 5:59:00 AM +00:00</CreatedAt>
    <ClosedAt>29/08/2018 11:26:34 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19728</IssueLabelID>
    <Title>Update BuildTools CoreClr CoreFx CoreSetup PgoData to preview1-03130-04 preview1-26830-04 preview1-26830-04 preview1-26830-01 master-20180830-0102 respectively (master)</Title>
    <Description>/cc @dotnet/coreclr-auto-update-notify</Description>
    <Title_Description>Update BuildTools, CoreClr, CoreFx, CoreSetup, PgoData to preview1-03130-04, preview1-26830-04, preview1-26830-04, preview1-26830-01, master-20180830-0102, respectively (master) /cc @dotnet/coreclr-auto-update-notify</Title_Description>
    <Label>
    </Label>
    <Assignee>ViktorHofer</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19724</IssueLabelID>
    <Title>R2RDump - Expand diffing functionality</Title>
    <Description>Presently R2RDump's diffing capabilities are limited to some summary statistics.
This issue tracks ensuring we generate rich and meaningful diff information specifically to be used for driving CQ of the cross-platform AOT compiler during bringup
</Description>
    <Title_Description>R2RDump - Expand diffing functionality Presently R2RDump's diffing capabilities are limited to some summary statistics.
This issue tracks ensuring we generate rich and meaningful diff information specifically to be used for driving CQ of the cross-platform AOT compiler during bringup
</Title_Description>
    <Label>area-R2RDump</Label>
    <Assignee>nattress</Assignee>
    <CreatedAt>28/08/2018 11:22:14 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19723</IssueLabelID>
    <Title>WIP NO-MERGE Dummy change to test dev/unix_test_workflow branch</Title>
    <Description>
    </Description>
    <Title_Description>WIP NO-MERGE Dummy change to test dev/unix_test_workflow branch </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>28/08/2018 11:16:32 PM +00:00</CreatedAt>
    <ClosedAt>12/09/2018 7:57:10 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19722</IssueLabelID>
    <Title>Missing includes in coreclr/src/debug/createdump/</Title>
    <Description>Attempting to bootstrap (with buildbootstrapcli.sh) fails with the following:

```
Scanning dependencies of target createdump_lib
[  0%] Building CXX object src/debug/createdump/CMakeFiles/createdump_lib.dir/createdump.cpp.o
[  0%] Building CXX object src/palrt/CMakeFiles/palrt.dir/coguid.cpp.o
[  0%] Building CXX object src/palrt/CMakeFiles/palrt.dir/comem.cpp.o
In file included from /var/tmp/dotnet/gentoo-x64/coreclr/src/debug/createdump/createdump.cpp:5:
In file included from /var/tmp/dotnet/gentoo-x64/coreclr/src/debug/createdump/createdump.h:60:
/var/tmp/dotnet/gentoo-x64/coreclr/src/debug/createdump/crashinfo.h:36:17: error: implicit instantiation of undefined template 'std::__1::basic_string&lt;char std::__1::char_traits&lt;char&gt; std::__1::allocator&lt;char&gt; &gt;'
    std::string m_coreclrPath;                      // the path of the coreclr module or empty if none
                ^
/usr/include/c++/v1/iosfwd:193:32: note: template is declared here
    class _LIBCPP_TEMPLATE_VIS basic_string;
                               ^
In file included from /var/tmp/dotnet/gentoo-x64/coreclr/src/debug/createdump/createdump.cpp:5:
In file included from /var/tmp/dotnet/gentoo-x64/coreclr/src/debug/createdump/createdump.h:60:
/var/tmp/dotnet/gentoo-x64/coreclr/src/debug/createdump/crashinfo.h:38:39: error: implicit instantiation of undefined template 'std::__1::array&lt;unsigned long 34&gt;'
    std::array&lt;elf_aux_val_t AT_MAX&gt; m_auxvValues; // auxv values
                                      ^
/usr/include/c++/v1/__tuple:223:64: note[  0%] Building CXX object src/palrt/CMakeFiles/palrt.dir/decarith.cpp.o
: template is declared here
template &lt;class _Tp size_t _Size&gt; struct _LIBCPP_TEMPLATE_VIS array;
                                                               ^
2 errors generated.
make[2]: *** [src/debug/createdump/CMakeFiles/createdump_lib.dir/build.make:63: src/debug/createdump/CMakeFiles/createdump_lib.dir/createdump.cpp.o] Error 1
make[1]: *** [CMakeFiles/Makefile2:61814: src/debug/createdump/CMakeFiles/createdump_lib.dir/all] Error 2
make[1]: *** Waiting for unfinished jobs....
```

Including `&lt;string&gt;` and `&lt;array&gt;` in `coreclr/src/debug/createdump/crashinfo.h` fixes this but I'm guessing your preferred style puts that elsewhere seeing as this file doesn't include any of the other headers it obviously requires.</Description>
    <Title_Description>Missing includes in coreclr/src/debug/createdump/ Attempting to bootstrap (with buildbootstrapcli.sh) fails with the following:

```
Scanning dependencies of target createdump_lib
[  0%] Building CXX object src/debug/createdump/CMakeFiles/createdump_lib.dir/createdump.cpp.o
[  0%] Building CXX object src/palrt/CMakeFiles/palrt.dir/coguid.cpp.o
[  0%] Building CXX object src/palrt/CMakeFiles/palrt.dir/comem.cpp.o
In file included from /var/tmp/dotnet/gentoo-x64/coreclr/src/debug/createdump/createdump.cpp:5:
In file included from /var/tmp/dotnet/gentoo-x64/coreclr/src/debug/createdump/createdump.h:60:
/var/tmp/dotnet/gentoo-x64/coreclr/src/debug/createdump/crashinfo.h:36:17: error: implicit instantiation of undefined template 'std::__1::basic_string&lt;char std::__1::char_traits&lt;char&gt; std::__1::allocator&lt;char&gt; &gt;'
    std::string m_coreclrPath;                      // the path of the coreclr module or empty if none
                ^
/usr/include/c++/v1/iosfwd:193:32: note: template is declared here
    class _LIBCPP_TEMPLATE_VIS basic_string;
                               ^
In file included from /var/tmp/dotnet/gentoo-x64/coreclr/src/debug/createdump/createdump.cpp:5:
In file included from /var/tmp/dotnet/gentoo-x64/coreclr/src/debug/createdump/createdump.h:60:
/var/tmp/dotnet/gentoo-x64/coreclr/src/debug/createdump/crashinfo.h:38:39: error: implicit instantiation of undefined template 'std::__1::array&lt;unsigned long 34&gt;'
    std::array&lt;elf_aux_val_t AT_MAX&gt; m_auxvValues; // auxv values
                                      ^
/usr/include/c++/v1/__tuple:223:64: note[  0%] Building CXX object src/palrt/CMakeFiles/palrt.dir/decarith.cpp.o
: template is declared here
template &lt;class _Tp size_t _Size&gt; struct _LIBCPP_TEMPLATE_VIS array;
                                                               ^
2 errors generated.
make[2]: *** [src/debug/createdump/CMakeFiles/createdump_lib.dir/build.make:63: src/debug/createdump/CMakeFiles/createdump_lib.dir/createdump.cpp.o] Error 1
make[1]: *** [CMakeFiles/Makefile2:61814: src/debug/createdump/CMakeFiles/createdump_lib.dir/all] Error 2
make[1]: *** Waiting for unfinished jobs....
```

Including `&lt;string&gt;` and `&lt;array&gt;` in `coreclr/src/debug/createdump/crashinfo.h` fixes this but I'm guessing your preferred style puts that elsewhere seeing as this file doesn't include any of the other headers it obviously requires.</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>mikem8361</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>26625</IssueLabelID>
    <Title>ReadyToRunCodegenNodeFactory cleanup / refactor</Title>
    <Description>* This class has gotten very big and contains several groups of unrelated functionality;
* Usefulness of deriving from NodeFactory is questionable it seems we're using just a fraction of its functionality and overlaps in the various helper names cause repeated aliasing issues;
* If it turns out to be possible to cleanly separate ReadyToRunCodegenNodeFactory from NodeFactory we should either split it into several classes or at least make it a partial class living in several files:
    * CorInfoImpl utility functions for constructing the various helper cells and signatures;
    * Token collection and lookup engine;
* R2R header table collection management.</Description>
    <Title_Description>ReadyToRunCodegenNodeFactory cleanup / refactor * This class has gotten very big and contains several groups of unrelated functionality;
* Usefulness of deriving from NodeFactory is questionable it seems we're using just a fraction of its functionality and overlaps in the various helper names cause repeated aliasing issues;
* If it turns out to be possible to cleanly separate ReadyToRunCodegenNodeFactory from NodeFactory we should either split it into several classes or at least make it a partial class living in several files:
    * CorInfoImpl utility functions for constructing the various helper cells and signatures;
    * Token collection and lookup engine;
* R2R header table collection management.</Title_Description>
    <Label>area-crossgen2</Label>
    <Assignee>MichalStrehovsky</Assignee>
    <CreatedAt>28/08/2018 11:06:44 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>26624</IssueLabelID>
    <Title>Multi-module compilation</Title>
    <Description>* Command-line specifies a number of "input files" that get all compiled into a single output R2R PE executable;
* Today architecture will need minor tweaks as we won't have a pre-existing MSIL to start off;
* All input files will be part of the CompilationModuleGroup without any singled-out assembly;
* This is expected to require additional CoreCLR runtime changes to work properly end-to-end;
* This will require a 2-level MethodEntrypointTable to cater for method tables for the individual modules and perhaps a new R2R component module table;
* Alternatively we might want to keep the pre-existing functionality untouched and just add a completely new entrypoint table format specific to the multi-module build.</Description>
    <Title_Description>Multi-module compilation * Command-line specifies a number of "input files" that get all compiled into a single output R2R PE executable;
* Today architecture will need minor tweaks as we won't have a pre-existing MSIL to start off;
* All input files will be part of the CompilationModuleGroup without any singled-out assembly;
* This is expected to require additional CoreCLR runtime changes to work properly end-to-end;
* This will require a 2-level MethodEntrypointTable to cater for method tables for the individual modules and perhaps a new R2R component module table;
* Alternatively we might want to keep the pre-existing functionality untouched and just add a completely new entrypoint table format specific to the multi-module build.</Title_Description>
    <Label>area-crossgen2</Label>
    <Assignee>Dotnet-GitSync-Bot</Assignee>
    <CreatedAt>28/08/2018 11:04:09 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>26623</IssueLabelID>
    <Title>Investigate ILCompiler R2R Self-Hosting</Title>
    <Description>* Once CQ allows try building ILCompiler in R2R mode
* This should provide a compilation perf improvement (less jitting) and a sizable CQ indicator local to this repository</Description>
    <Title_Description>Investigate ILCompiler R2R Self-Hosting * Once CQ allows try building ILCompiler in R2R mode
* This should provide a compilation perf improvement (less jitting) and a sizable CQ indicator local to this repository</Title_Description>
    <Label>area-crossgen2</Label>
    <Assignee>nattress</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19721</IssueLabelID>
    <Title>R2RDump - Implement fixup signature parsing</Title>
    <Description>The various fixups supported in the ready-to-run format use signatures to represent types / methods. Parsing the signatures in a ready-to-run image will allow us to add richer symbolic information to the disassembly emitted by r2rdump. This will also make diffing images generated by Crossgen vs ILCompiler easier.</Description>
    <Title_Description>R2RDump - Implement fixup signature parsing The various fixups supported in the ready-to-run format use signatures to represent types / methods. Parsing the signatures in a ready-to-run image will allow us to add richer symbolic information to the disassembly emitted by r2rdump. This will also make diffing images generated by Crossgen vs ILCompiler easier.</Title_Description>
    <Label>area-R2RDump</Label>
    <Assignee>nattress</Assignee>
    <CreatedAt>28/08/2018 9:49:44 PM +00:00</CreatedAt>
    <ClosedAt>14/09/2018 11:27:39 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19717</IssueLabelID>
    <Title>disable NETClientPrimitives test for all platforms.</Title>
    <Description>As it was before.

Fixes R2R jobs like https://ci.dot.net/job/dotnet_coreclr/job/master/job/x86_checked_windows_nt_r2r/.


</Description>
    <Title_Description>disable NETClientPrimitives test for all platforms. As it was before.

Fixes R2R jobs like https://ci.dot.net/job/dotnet_coreclr/job/master/job/x86_checked_windows_nt_r2r/.


</Title_Description>
    <Label>disabled-test</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>28/08/2018 8:00:59 PM +00:00</CreatedAt>
    <ClosedAt>28/08/2018 10:24:10 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19715</IssueLabelID>
    <Title>[Windows/arm64] build break: C4723 potential divide by 0</Title>
    <Description>Apparently this changed with VS 15.8.
```
f:\gh\coreclr10\src\vm\ngenhash.inl(809): error C2220: warning treated as error - no 'object' file generated [F:\gh\coreclr10\bin\obj\Windows_NT.arm64.Checked\src\vm\crossgen\cee_crossgen.vcxproj]
f:\gh\coreclr10\src\vm\ngenhash.inl(809): warning C4723: potential divide by 0 [F:\gh\coreclr10\bin\obj\Windows_NT.arm64.Checked\src\vm\crossgen\cee_crossgen.vcxproj]
```
</Description>
    <Title_Description>[Windows/arm64] build break: C4723 potential divide by 0 Apparently this changed with VS 15.8.
```
f:\gh\coreclr10\src\vm\ngenhash.inl(809): error C2220: warning treated as error - no 'object' file generated [F:\gh\coreclr10\bin\obj\Windows_NT.arm64.Checked\src\vm\crossgen\cee_crossgen.vcxproj]
f:\gh\coreclr10\src\vm\ngenhash.inl(809): warning C4723: potential divide by 0 [F:\gh\coreclr10\bin\obj\Windows_NT.arm64.Checked\src\vm\crossgen\cee_crossgen.vcxproj]
```
</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>28/08/2018 7:00:24 PM +00:00</CreatedAt>
    <ClosedAt>28/08/2018 10:39:02 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19710</IssueLabelID>
    <Title>COMPlus_JitStdOutFile on Linux - part of the output still goes to StdOut</Title>
    <Description>**Steps to reproduce:**

Set the following environment variable
```
echesako@echesako2:~/git$ set | grep COMPlus
COMPlus_JitStdOutFile=System.Private.CoreLib.dll.dasm
COMPlus_NgenDump='*'
```
and run crossgen
```
echesako@echesako2:~/git$ coreclr/bin/Product/Linux.x64.Checked/crossgen /Platform_Assemblies_Paths coreclr/bin/Product/Linux.x64.Checked/IL coreclr/bin/Product/Linux.x64.Checked/IL/System.Private.CoreLib.dll &gt; StdOut.txt
```


Part of JIT output got redirected to JitStdOutFile (i.e. System.Private.CoreLib.dll.dasm)
```
echesako@echesako2:~/git$ head System.Private.CoreLib.dll.dasm

lvaSetClass: setting class for V00 to (00007F3F71CB6AB0) &lt;&gt;f__AnonymousType0`1[__Canon]
IL Code SizeInstr    7   3 Basic Block count   1 Local Variable NumRef count   2  1 for method &lt;&gt;f__AnonymousType0`1[__Canon][System.__Canon]:get_message():ref:this

    [ 0]   0 (0x000)
    [ 1]   1 (0x001)  0A000001
    [ 1]   6 (0x006)
*************** In fgRemoveEmptyTry()
No EH in this method nothing to remove.
```
but most of the JIT output still goes to StdOut
```
echesako@echesako2:~/git$ head StdOut.txt
Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0
Copyright (c) Microsoft Corporation.  All rights reserved.

****** START compiling &lt;&gt;f__AnonymousType0`1[__Canon][System.__Canon]:get_message():ref:this (MethodHash=42b060b5)
Generating code for Unix x64
OPTIONS: compCodeOpt = BLENDED_CODE
OPTIONS: compDbgCode = false
OPTIONS: compDbgInfo = true
OPTIONS: compDbgEnC  = false
OPTIONS: compProcedureSplitting   = true
```
</Description>
    <Title_Description>COMPlus_JitStdOutFile on Linux - part of the output still goes to StdOut **Steps to reproduce:**

Set the following environment variable
```
echesako@echesako2:~/git$ set | grep COMPlus
COMPlus_JitStdOutFile=System.Private.CoreLib.dll.dasm
COMPlus_NgenDump='*'
```
and run crossgen
```
echesako@echesako2:~/git$ coreclr/bin/Product/Linux.x64.Checked/crossgen /Platform_Assemblies_Paths coreclr/bin/Product/Linux.x64.Checked/IL coreclr/bin/Product/Linux.x64.Checked/IL/System.Private.CoreLib.dll &gt; StdOut.txt
```


Part of JIT output got redirected to JitStdOutFile (i.e. System.Private.CoreLib.dll.dasm)
```
echesako@echesako2:~/git$ head System.Private.CoreLib.dll.dasm

lvaSetClass: setting class for V00 to (00007F3F71CB6AB0) &lt;&gt;f__AnonymousType0`1[__Canon]
IL Code SizeInstr    7   3 Basic Block count   1 Local Variable NumRef count   2  1 for method &lt;&gt;f__AnonymousType0`1[__Canon][System.__Canon]:get_message():ref:this

    [ 0]   0 (0x000)
    [ 1]   1 (0x001)  0A000001
    [ 1]   6 (0x006)
*************** In fgRemoveEmptyTry()
No EH in this method nothing to remove.
```
but most of the JIT output still goes to StdOut
```
echesako@echesako2:~/git$ head StdOut.txt
Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0
Copyright (c) Microsoft Corporation.  All rights reserved.

****** START compiling &lt;&gt;f__AnonymousType0`1[__Canon][System.__Canon]:get_message():ref:this (MethodHash=42b060b5)
Generating code for Unix x64
OPTIONS: compCodeOpt = BLENDED_CODE
OPTIONS: compDbgCode = false
OPTIONS: compDbgInfo = true
OPTIONS: compDbgEnC  = false
OPTIONS: compProcedureSplitting   = true
```
</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>echesakovMSFT</Assignee>
    <CreatedAt>28/08/2018 4:11:42 PM +00:00</CreatedAt>
    <ClosedAt>19/09/2018 11:37:59 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19706</IssueLabelID>
    <Title>Char.GetUnicodeCategory returns wrong category for certain Latin-1 characters</Title>
    <Description>In a nutshell there are certain characters where `CharUnicodeInfo.GetUnicodeCategory` returns the correct value but `Char.GetUnicodeCategory` returns the wrong value. One such character is U+00B6 PILCROW SIGN where `CharUnicodeInfo` returns _OtherPunctuation_ (which is correct) and where `Char` returns _OtherSymbol_ (which is incorrect). This also affects the behavior of dependent methods like `Char.IsPunctuation` and `Char.IsLower`.

[MSDN says](https://docs.microsoft.com/en-us/dotnet/api/system.char.getunicodecategory) this behavior is intentional to preserve back-compat but it is extraordinarily confusing to have two methods with the same name have different behavior.  

One solution would be to update `Char.GetUnicodeCategory` to stay in sync with `CharUnicodeInfo.GetUnicodeCategory`. This is a breaking change but it's the type of breaking change that is normally allowed in side-by-side major version updates.

An alternative is to mark `Char.GetUnicodeCategory` `Char.IsPunctuation` `Char.IsLower` etc. as obsolete and to direct users to call into `CharUnicodeInfo` instead. This preserves existing behavior and provides a migration story to get developers on to the APIs which provide correct results.</Description>
    <Title_Description>Char.GetUnicodeCategory returns wrong category for certain Latin-1 characters In a nutshell there are certain characters where `CharUnicodeInfo.GetUnicodeCategory` returns the correct value but `Char.GetUnicodeCategory` returns the wrong value. One such character is U+00B6 PILCROW SIGN where `CharUnicodeInfo` returns _OtherPunctuation_ (which is correct) and where `Char` returns _OtherSymbol_ (which is incorrect). This also affects the behavior of dependent methods like `Char.IsPunctuation` and `Char.IsLower`.

[MSDN says](https://docs.microsoft.com/en-us/dotnet/api/system.char.getunicodecategory) this behavior is intentional to preserve back-compat but it is extraordinarily confusing to have two methods with the same name have different behavior.  

One solution would be to update `Char.GetUnicodeCategory` to stay in sync with `CharUnicodeInfo.GetUnicodeCategory`. This is a breaking change but it's the type of breaking change that is normally allowed in side-by-side major version updates.

An alternative is to mark `Char.GetUnicodeCategory` `Char.IsPunctuation` `Char.IsLower` etc. as obsolete and to direct users to call into `CharUnicodeInfo` instead. This preserves existing behavior and provides a migration story to get developers on to the APIs which provide correct results.</Title_Description>
    <Label>area-System.Globalization</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>28/08/2018 12:05:24 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19705</IssueLabelID>
    <Title>[Windows|x86|x64] Incorrect comparison of short</Title>
    <Description>Example code:

```
C#

void TestEchoShort()
{
   short ret = echo_short(8);
   Debug.Assert(ret == 8); // Fails
}


C:

short echo_short(_int8 arg ...)
{
   return arg;
}
```

/cc @BruceForstall </Description>
    <Title_Description>[Windows|x86|x64] Incorrect comparison of short Example code:

```
C#

void TestEchoShort()
{
   short ret = echo_short(8);
   Debug.Assert(ret == 8); // Fails
}


C:

short echo_short(_int8 arg ...)
{
   return arg;
}
```

/cc @BruceForstall </Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>erozenfeld</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19704</IssueLabelID>
    <Title>CrossGen produces spurious "Error" logging on what it later reports as successful compilation</Title>
    <Description>From this log: https://devdiv.visualstudio.com/0bdbc590-a062-4c3f-b0f6-9383f67865ee/_apis/build/builds/1980843/logs/8

```
2018-08-27T11:42:26.3776644Z          Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0
2018-08-27T11:42:26.3822938Z          Copyright (c) Microsoft Corporation.  All rights reserved.
2018-08-27T11:42:26.3869273Z          
2018-08-27T11:42:26.3912527Z          Error 2147500037 (Exception from HRESULT: 0x80004005 (E_FAIL)) while compiling method BuildServerConnection.CreateMonitorDisconnectTask
2018-08-27T11:42:26.3958431Z          Error 2147500037 (Exception from HRESULT: 0x80004005 (E_FAIL)) while compiling method BuildRequest.WriteAsync
2018-08-27T11:42:26.4003208Z          Error 2147500037 (Exception from HRESULT: 0x80004005 (E_FAIL)) while compiling method BuildResponse.WriteAsync
2018-08-27T11:42:26.4048083Z          Error 2147500037 (Exception from HRESULT: 0x80004005 (E_FAIL)) while compiling method BuildProtocolConstants.ReadAllAsync
2018-08-27T11:42:26.4100353Z          Native image /data/agent/_work/_temp/tmpRZTXCg.tmp generated successfully.
```
(This was from compiling csc.dll)

Some thoughts here:
- If four errors have been written out to the console succeeding with no special "-force' or other args like this is very confusing
- MSBuild and other systems tend to promote std. out with "error" in the string to actual errors
- E_FAIL is not super useful to anyone reading this log.

@eerhardt FYI
</Description>
    <Title_Description>CrossGen produces spurious "Error" logging on what it later reports as successful compilation From this log: https://devdiv.visualstudio.com/0bdbc590-a062-4c3f-b0f6-9383f67865ee/_apis/build/builds/1980843/logs/8

```
2018-08-27T11:42:26.3776644Z          Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0
2018-08-27T11:42:26.3822938Z          Copyright (c) Microsoft Corporation.  All rights reserved.
2018-08-27T11:42:26.3869273Z          
2018-08-27T11:42:26.3912527Z          Error 2147500037 (Exception from HRESULT: 0x80004005 (E_FAIL)) while compiling method BuildServerConnection.CreateMonitorDisconnectTask
2018-08-27T11:42:26.3958431Z          Error 2147500037 (Exception from HRESULT: 0x80004005 (E_FAIL)) while compiling method BuildRequest.WriteAsync
2018-08-27T11:42:26.4003208Z          Error 2147500037 (Exception from HRESULT: 0x80004005 (E_FAIL)) while compiling method BuildResponse.WriteAsync
2018-08-27T11:42:26.4048083Z          Error 2147500037 (Exception from HRESULT: 0x80004005 (E_FAIL)) while compiling method BuildProtocolConstants.ReadAllAsync
2018-08-27T11:42:26.4100353Z          Native image /data/agent/_work/_temp/tmpRZTXCg.tmp generated successfully.
```
(This was from compiling csc.dll)

Some thoughts here:
- If four errors have been written out to the console succeeding with no special "-force' or other args like this is very confusing
- MSBuild and other systems tend to promote std. out with "error" in the string to actual errors
- E_FAIL is not super useful to anyone reading this log.

@eerhardt FYI
</Title_Description>
    <Label>area-CrossGen/NGEN</Label>
    <Assignee>zacharycmontoya</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19703</IssueLabelID>
    <Title>Delete code that tracks stack level in morph.</Title>
    <Description>The responsibilities of the old code that tracked stack level were:
1) Set `fgPtrArgCntMax` and check that we can encode it (in `fgCheckArgCnt`);
2) Set ` call-&gt;fgArgInfo-&gt;SetStkSizeBytes`;
3) Set `AddCodeDsc-&gt;acdStkLvl`;
4) Set `setFramePointerRequired`;
now we do it all in `StackLevelSetter` when we have the finalized correct information about the stack levels.

No windows x86/x64 CoreCLR libraries diffs.
There are few spmi diffs: 30 functions were optimized to have an esp based frame.
There were cases were we forced an ebp based frame because of the calls that were later marked as useless and were deleted. Now such cases recieve esp based frames.
For example:
Old code:
```
; Total bytes of code 12 prolog size 3 for method *
; ebp based frame
G_M65471_IG01:
       push     ebp
       mov      ebp esp

G_M65471_IG02:
       cmp      byte  ptr [ecx+29] 0
       je       SHORT G_M65471_IG03
       mov      eax gword ptr [ecx+24]
       mov      eax dword ptr [eax]

G_M65471_IG03:
       xor      eax eax

G_M65471_IG04:
       pop      ebp
       ret 

```
new code:
```
; Total bytes of code 8 prolog size 0 for method *
; esp based frame
G_M65471_IG01:
				   
						

G_M65471_IG02:
       cmp      byte  ptr [ecx+29] 0
       je       SHORT G_M65471_IG03
       mov      eax gword ptr [ecx+24]
       mov      eax dword ptr [eax]

G_M65471_IG03:
       xor      eax eax

G_M65471_IG04:
				   
       ret 

```
Fixes #16411.</Description>
    <Title_Description>Delete code that tracks stack level in morph. The responsibilities of the old code that tracked stack level were:
1) Set `fgPtrArgCntMax` and check that we can encode it (in `fgCheckArgCnt`);
2) Set ` call-&gt;fgArgInfo-&gt;SetStkSizeBytes`;
3) Set `AddCodeDsc-&gt;acdStkLvl`;
4) Set `setFramePointerRequired`;
now we do it all in `StackLevelSetter` when we have the finalized correct information about the stack levels.

No windows x86/x64 CoreCLR libraries diffs.
There are few spmi diffs: 30 functions were optimized to have an esp based frame.
There were cases were we forced an ebp based frame because of the calls that were later marked as useless and were deleted. Now such cases recieve esp based frames.
For example:
Old code:
```
; Total bytes of code 12 prolog size 3 for method *
; ebp based frame
G_M65471_IG01:
       push     ebp
       mov      ebp esp

G_M65471_IG02:
       cmp      byte  ptr [ecx+29] 0
       je       SHORT G_M65471_IG03
       mov      eax gword ptr [ecx+24]
       mov      eax dword ptr [eax]

G_M65471_IG03:
       xor      eax eax

G_M65471_IG04:
       pop      ebp
       ret 

```
new code:
```
; Total bytes of code 8 prolog size 0 for method *
; esp based frame
G_M65471_IG01:
				   
						

G_M65471_IG02:
       cmp      byte  ptr [ecx+29] 0
       je       SHORT G_M65471_IG03
       mov      eax gword ptr [ecx+24]
       mov      eax dword ptr [eax]

G_M65471_IG03:
       xor      eax eax

G_M65471_IG04:
				   
       ret 

```
Fixes #16411.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>27/08/2018 11:47:03 PM +00:00</CreatedAt>
    <ClosedAt>30/08/2018 2:55:25 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19699</IssueLabelID>
    <Title>Implement PCLMULQDQ intrinsic</Title>
    <Description>I will submit a PR to implement all the PCLMULQDQ intrinsic.

cc @CarolEidt @tannergooding @eerhardt </Description>
    <Title_Description>Implement PCLMULQDQ intrinsic I will submit a PR to implement all the PCLMULQDQ intrinsic.

cc @CarolEidt @tannergooding @eerhardt </Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
    <CreatedAt>27/08/2018 10:20:51 PM +00:00</CreatedAt>
    <ClosedAt>10/09/2018 7:55:38 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19698</IssueLabelID>
    <Title>System.AccessViolationException while formatting stacktrace</Title>
    <Description>Reported by @BrennanConroy 

We’re getting this exception in a test occasionally. 

```
Unhandled Exception: System.AccessViolationException: Attempted to read or write protected memory. This is often an indication that other memory is corrupt.
    at System.Reflection.Internal.MemoryBlock.PeekCompressedInteger(Int32 offset Int32&amp; numberOfBytesRead)
    at System.Reflection.Metadata.Ecma335.BlobHeap.GetMemoryBlock(BlobHandle handle)
    at System.Reflection.Metadata.MethodDebugInformation.GetSequencePoints()
    at System.Diagnostics.StackTraceSymbols.GetSourceLineInfoWithoutCasAssert(String assemblyPath IntPtr loadedPeAddress Int32 loadedPeSize IntPtr inMemoryPdbAddress Int32 inMemoryPdbSize Int32 methodToken Int32 ilOffset String&amp; sourceFile Int32&amp; sourceLine Int32&amp; sourceColumn)
    at System.Diagnostics.StackFrameHelper.InitializeSourceInfo(Int32 iSkip Boolean fNeedFileInfo Exception exception)
    at System.Diagnostics.StackTrace.CaptureStackTrace(Int32 iSkip Boolean fNeedFileInfo Thread targetThread Exception e)
    at System.Diagnostics.StackTrace..ctor(Exception e Boolean fNeedFileInfo)
    at System.Environment.GetStackTrace(Exception e Boolean needFileInfo)
    at System.Exception.GetStackTrace(Boolean needFileInfo)
    at System.Exception.ToString(Boolean needFileLineInfo Boolean needMessage)
    at System.Exception.ToString()
```</Description>
    <Title_Description>System.AccessViolationException while formatting stacktrace Reported by @BrennanConroy 

We’re getting this exception in a test occasionally. 

```
Unhandled Exception: System.AccessViolationException: Attempted to read or write protected memory. This is often an indication that other memory is corrupt.
    at System.Reflection.Internal.MemoryBlock.PeekCompressedInteger(Int32 offset Int32&amp; numberOfBytesRead)
    at System.Reflection.Metadata.Ecma335.BlobHeap.GetMemoryBlock(BlobHandle handle)
    at System.Reflection.Metadata.MethodDebugInformation.GetSequencePoints()
    at System.Diagnostics.StackTraceSymbols.GetSourceLineInfoWithoutCasAssert(String assemblyPath IntPtr loadedPeAddress Int32 loadedPeSize IntPtr inMemoryPdbAddress Int32 inMemoryPdbSize Int32 methodToken Int32 ilOffset String&amp; sourceFile Int32&amp; sourceLine Int32&amp; sourceColumn)
    at System.Diagnostics.StackFrameHelper.InitializeSourceInfo(Int32 iSkip Boolean fNeedFileInfo Exception exception)
    at System.Diagnostics.StackTrace.CaptureStackTrace(Int32 iSkip Boolean fNeedFileInfo Thread targetThread Exception e)
    at System.Diagnostics.StackTrace..ctor(Exception e Boolean fNeedFileInfo)
    at System.Environment.GetStackTrace(Exception e Boolean needFileInfo)
    at System.Exception.GetStackTrace(Boolean needFileInfo)
    at System.Exception.ToString(Boolean needFileLineInfo Boolean needMessage)
    at System.Exception.ToString()
```</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>mikem8361</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19696</IssueLabelID>
    <Title>[arm64] Remove interpreter fallback</Title>
    <Description>Remove old code:
```
#elif defined(_TARGET_ARM64_)
    // TODO-ARM64-NYI: remove this after the JIT no longer asserts during startup
    //
    // When we are bringing up the new Arm64 JIT we set COMPlus_ContinueOnAssert=1
    // We only want to hit one assert then we will fall back to the interpreter.
    //
    bool interpreterFallback = (JitConfig.InterpreterFallback() != 0);

    if (interpreterFallback)
    {
        fatal(CORJIT_SKIPPED);
    }
#endif

```</Description>
    <Title_Description>[arm64] Remove interpreter fallback Remove old code:
```
#elif defined(_TARGET_ARM64_)
    // TODO-ARM64-NYI: remove this after the JIT no longer asserts during startup
    //
    // When we are bringing up the new Arm64 JIT we set COMPlus_ContinueOnAssert=1
    // We only want to hit one assert then we will fall back to the interpreter.
    //
    bool interpreterFallback = (JitConfig.InterpreterFallback() != 0);

    if (interpreterFallback)
    {
        fatal(CORJIT_SKIPPED);
    }
#endif

```</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>BruceForstall</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19694</IssueLabelID>
    <Title>Fix JitDump label output to be multi-thread safe</Title>
    <Description>We emit labels using a global static `Compiler::s_compMethodsCount` e.g.:
```
printf("G_M%03u_IG%02u" Compiler::s_compMethodsCount id-&gt;idAddr()-&gt;iiaIGlabel-&gt;igNum);
```

That’s dangerous if two JITs are running at the same time and generating JitDumps. We should change to using a Compiler member and then change:
```
#ifdef DEBUG
    /* Give the function a unique number */

    if (opts.disAsm || opts.dspEmit || verbose)
    {
        s_compMethodsCount = ~info.compMethodHash() &amp; 0xffff;
    }
    else
    {
        s_compMethodsCount++;
    }
#endif
```
To:
```
#ifdef DEBUG
    /* Give the function a unique number */

    if (opts.disAsm || opts.dspEmit || verbose)
    {
        compMethodNumber = ~info.compMethodHash() &amp; 0xffff;
    }
    else
    {
        compMethodNumber = s_compMethodsCount;
        s_compMethodsCount++;
    }
#endif
```
And the calls to:
```
printf("G_M%03u_IG%02u" compMethodNumber id-&gt;idAddr()-&gt;iiaIGlabel-&gt;igNum);
```

Some places we access `s_compMethodsCount` currently might not have a `Compiler` pointer so it might be a little more work than this.

category:implementation
theme:debug-dumps
skill-level:beginner
cost:small</Description>
    <Title_Description>Fix JitDump label output to be multi-thread safe We emit labels using a global static `Compiler::s_compMethodsCount` e.g.:
```
printf("G_M%03u_IG%02u" Compiler::s_compMethodsCount id-&gt;idAddr()-&gt;iiaIGlabel-&gt;igNum);
```

That’s dangerous if two JITs are running at the same time and generating JitDumps. We should change to using a Compiler member and then change:
```
#ifdef DEBUG
    /* Give the function a unique number */

    if (opts.disAsm || opts.dspEmit || verbose)
    {
        s_compMethodsCount = ~info.compMethodHash() &amp; 0xffff;
    }
    else
    {
        s_compMethodsCount++;
    }
#endif
```
To:
```
#ifdef DEBUG
    /* Give the function a unique number */

    if (opts.disAsm || opts.dspEmit || verbose)
    {
        compMethodNumber = ~info.compMethodHash() &amp; 0xffff;
    }
    else
    {
        compMethodNumber = s_compMethodsCount;
        s_compMethodsCount++;
    }
#endif
```
And the calls to:
```
printf("G_M%03u_IG%02u" compMethodNumber id-&gt;idAddr()-&gt;iiaIGlabel-&gt;igNum);
```

Some places we access `s_compMethodsCount` currently might not have a `Compiler` pointer so it might be a little more work than this.

category:implementation
theme:debug-dumps
skill-level:beginner
cost:small</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>27/08/2018 8:28:00 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19691</IssueLabelID>
    <Title>Enable tiered compilation</Title>
    <Description>This is a port of several changes that went into master after 2.2 forked including dependencies for and enabling tiered compilation by default in 2.2. Quick summary of commits is below see the commit descriptions and PRs for more info.
- Commit 1 - Fix nested spin locks in thread pool etw firing (#17677)
  - Fixes a lock nesting issue when there is an ETW listener which can occur without tiering but is almost deterministic with tiering enabled because the first event that is fired typically hits this code path
- Commit 2 - Don't close the JIT func info file on shutdown (#18060)
  - Fixes a crash during shutdown that only occurs when JIT logging is enabled (typically in the coreclr tests and CI). More frequent with tiering enabled because of different JIT timing and background jitting.
- Commit 3 - Apply tiering's call counting delay more broadly (#18610)
  - Fixes a perf issue when tiering is enabled in server first-request scenarios where there is a significant gap between process startup and first request
- Commit 4 - Changes only affect debug builds - Eliminate arm64 contract asserts (#19015)
  - Fixes some incorrect asserts that trigger more frequently with tiering
- Commit 5 - Use 16 bytes to spill SIMD12 (#19237)
  - Fixes a crash in corefx System.Numerics.Tests.Vector3Tests.Vector3EqualsTest. Occurs with minopt JIT or with tiering.
- Commit 6 - Fix an apartment state issue (partial port of #19384)
  - This is a partial port of this PR (only the portion that addresses issue #17822)
  - This is a breaking change though a minor one that we have concluded is an acceptable risk to take for 2.2
  - Fixes a behavioral difference that can be seen more easily tiering enabled in APIs on the `Thread` class relevant to apartment state. The issue can also be seen in some cases when tiering is disabled.
- Commit 7 - Enable Tiered Compilation by default (#19525)
  - Enables tiering by default can be disabled through environment or through .csproj/.json when using dotnet
  - Removes deprecated config variable (EXPERIMENTAL_TieredCompilation) that was previously exposed in 2.1 along with the current config variable (TieredCompilation) along with miscellaneous test fixes
- Commit 8 - Changes only affect tests - Fix tiered compilation option for case-sensitive systems (#19567)
  - Fixes tiering environment variable casing for non-Windows platforms
- Commit 9 - Disable tiered compilation on arm64
  - There is an open issue that may be partly related to minopts on arm64 (https://github.com/dotnet/coreclr/issues/18895). Disabling tiering by default on arm64 to limit exposing new issues.

This change would be followed up with https://github.com/dotnet/corefx/pull/31822
- Adds tests for Commit 6 - Fix an apartment state issue (partial port of #19384)
  - Changes only affect tests

Closes https://github.com/dotnet/coreclr/issues/18973</Description>
    <Title_Description>Enable tiered compilation This is a port of several changes that went into master after 2.2 forked including dependencies for and enabling tiered compilation by default in 2.2. Quick summary of commits is below see the commit descriptions and PRs for more info.
- Commit 1 - Fix nested spin locks in thread pool etw firing (#17677)
  - Fixes a lock nesting issue when there is an ETW listener which can occur without tiering but is almost deterministic with tiering enabled because the first event that is fired typically hits this code path
- Commit 2 - Don't close the JIT func info file on shutdown (#18060)
  - Fixes a crash during shutdown that only occurs when JIT logging is enabled (typically in the coreclr tests and CI). More frequent with tiering enabled because of different JIT timing and background jitting.
- Commit 3 - Apply tiering's call counting delay more broadly (#18610)
  - Fixes a perf issue when tiering is enabled in server first-request scenarios where there is a significant gap between process startup and first request
- Commit 4 - Changes only affect debug builds - Eliminate arm64 contract asserts (#19015)
  - Fixes some incorrect asserts that trigger more frequently with tiering
- Commit 5 - Use 16 bytes to spill SIMD12 (#19237)
  - Fixes a crash in corefx System.Numerics.Tests.Vector3Tests.Vector3EqualsTest. Occurs with minopt JIT or with tiering.
- Commit 6 - Fix an apartment state issue (partial port of #19384)
  - This is a partial port of this PR (only the portion that addresses issue #17822)
  - This is a breaking change though a minor one that we have concluded is an acceptable risk to take for 2.2
  - Fixes a behavioral difference that can be seen more easily tiering enabled in APIs on the `Thread` class relevant to apartment state. The issue can also be seen in some cases when tiering is disabled.
- Commit 7 - Enable Tiered Compilation by default (#19525)
  - Enables tiering by default can be disabled through environment or through .csproj/.json when using dotnet
  - Removes deprecated config variable (EXPERIMENTAL_TieredCompilation) that was previously exposed in 2.1 along with the current config variable (TieredCompilation) along with miscellaneous test fixes
- Commit 8 - Changes only affect tests - Fix tiered compilation option for case-sensitive systems (#19567)
  - Fixes tiering environment variable casing for non-Windows platforms
- Commit 9 - Disable tiered compilation on arm64
  - There is an open issue that may be partly related to minopts on arm64 (https://github.com/dotnet/coreclr/issues/18895). Disabling tiering by default on arm64 to limit exposing new issues.

This change would be followed up with https://github.com/dotnet/corefx/pull/31822
- Adds tests for Commit 6 - Fix an apartment state issue (partial port of #19384)
  - Changes only affect tests

Closes https://github.com/dotnet/coreclr/issues/18973</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19690</IssueLabelID>
    <Title>Automate CoreCLR's CoreFX CI Test Infrastructure</Title>
    <Description># CoreFX Tests in CoreCLR CI

## Current State
A suite of CoreFX tests are executed on top of CI builds of CoreCLR during PRs.  Currently these tests are manually built and uploaded to an Azure Blob Storage container and downloaded during the CI pipeline.  The cadence of building and uploading the binaries is completely manual with almost no visibility as to what commit from dotnet/corefx was used to build the tests.  While this works it is inconvenient for maintenance and unfriendly for developers who may want to pull down the same test binaries that are running in the CI for their PR.

## Goals
* Automate the cataloging (upload and versioning) of CoreFX test binaries.
* Simplify the retrieval of a specific version of the CoreFX test binaries.
* Hook into the automation that already updates the CoreFX version in [coreclr/dependencies.props](https://github.com/dotnet/coreclr/blob/master/dependencies.props) via [maestro-bot](https://github.com/dotnet/versions).

This issue is for unifying discussions as this may require changes in dotnet/coreclr and dotnet/corefx.

CC - @A-And @adityamandaleeka 

[WIP]</Description>
    <Title_Description>Automate CoreCLR's CoreFX CI Test Infrastructure # CoreFX Tests in CoreCLR CI

## Current State
A suite of CoreFX tests are executed on top of CI builds of CoreCLR during PRs.  Currently these tests are manually built and uploaded to an Azure Blob Storage container and downloaded during the CI pipeline.  The cadence of building and uploading the binaries is completely manual with almost no visibility as to what commit from dotnet/corefx was used to build the tests.  While this works it is inconvenient for maintenance and unfriendly for developers who may want to pull down the same test binaries that are running in the CI for their PR.

## Goals
* Automate the cataloging (upload and versioning) of CoreFX test binaries.
* Simplify the retrieval of a specific version of the CoreFX test binaries.
* Hook into the automation that already updates the CoreFX version in [coreclr/dependencies.props](https://github.com/dotnet/coreclr/blob/master/dependencies.props) via [maestro-bot](https://github.com/dotnet/versions).

This issue is for unifying discussions as this may require changes in dotnet/coreclr and dotnet/corefx.

CC - @A-And @adityamandaleeka 

[WIP]</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>davmason</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19689</IssueLabelID>
    <Title>Hardware intrinsic throw ArgumentOutOfRangeException with IMM parameter name</Title>
    <Description>Now some hardware intrinsic can throw `ArgumentOutOfRangeException` from the IMM arguments.
```csharp
 Avx.Compare(Avx.SetZeroVector256&lt;float&gt;() Avx.SetZeroVector256&lt;float&gt;() (FloatComparisonMode)100);
```
```
Unhandled Exception: System.ArgumentOutOfRangeException: Specified argument was out of the range of valid values.
   at System.Runtime.Intrinsics.X86.Avx.Compare(Vector256`1 left Vector256`1 right FloatComparisonMode mode)
   at SseTest.Program.Main(String[] args) in D:\workspace\tests\testIntrinsic\Program.cs:line 14
```

We may need to bring the IMM parameter name in the exception object.

Logged from the conversation https://github.com/dotnet/coreclr/pull/19392#discussion_r213050260

@tannergooding @CarolEidt 

category:implementation
theme:intrinsics
skill-level:beginner
cost:small</Description>
    <Title_Description>Hardware intrinsic throw ArgumentOutOfRangeException with IMM parameter name Now some hardware intrinsic can throw `ArgumentOutOfRangeException` from the IMM arguments.
```csharp
 Avx.Compare(Avx.SetZeroVector256&lt;float&gt;() Avx.SetZeroVector256&lt;float&gt;() (FloatComparisonMode)100);
```
```
Unhandled Exception: System.ArgumentOutOfRangeException: Specified argument was out of the range of valid values.
   at System.Runtime.Intrinsics.X86.Avx.Compare(Vector256`1 left Vector256`1 right FloatComparisonMode mode)
   at SseTest.Program.Main(String[] args) in D:\workspace\tests\testIntrinsic\Program.cs:line 14
```

We may need to bring the IMM parameter name in the exception object.

Logged from the conversation https://github.com/dotnet/coreclr/pull/19392#discussion_r213050260

@tannergooding @CarolEidt 

category:implementation
theme:intrinsics
skill-level:beginner
cost:small</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
    <CreatedAt>27/08/2018 5:48:17 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19688</IssueLabelID>
    <Title>Update NetPerf File ThreadID to 64-bits</Title>
    <Description>The current value is 32-bits which will truncate the full value on OSX.</Description>
    <Title_Description>Update NetPerf File ThreadID to 64-bits The current value is 32-bits which will truncate the full value on OSX.</Title_Description>
    <Label>area-Tracing</Label>
    <Assignee>noahfalk</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19684</IssueLabelID>
    <Title>Test failure: JIT_jit64._mcc_interop_mcc_i83_mcc_i83_/_mcc_interop_mcc_i83_mcc_i83_cmd</Title>
    <Description>Opened on behalf of @Sunny-pu

The test `JIT_jit64._mcc_interop_mcc_i83_mcc_i83_/_mcc_interop_mcc_i83_mcc_i83_cmd` has failed.


    
    Return code:      1
    Raw output file:      C:\\dotnetbuild\\work\\31155d77-0bf1-45a2-a51e-dc457ed07fe5\\Work\\21104909-527d-4766-99e3-8be351afd714\\Unzip\\Reports\\JIT.jit64\\mcc\\interop\\mcc_i83\\mcc_i83.output.txt
    Raw output:
    BEGIN EXECUTION\r
     \"C:\\dotnetbuild\\work\\31155d77-0bf1-45a2-a51e-dc457ed07fe5\\Payload\\corerun.exe\" mcc_i83.exe \r
    Expected: 100\r
    Actual: -1073741819\r
    END EXECUTION - FAILED\r
    FAILED\r
    Test Harness Exitcode is : 1\r
    
    To run the test:
    &gt; set CORE_ROOT=C:\\dotnetbuild\\work\\31155d77-0bf1-45a2-a51e-dc457ed07fe5\\Payload
    &gt; C:\\dotnetbuild\\work\\31155d77-0bf1-45a2-a51e-dc457ed07fe5\\Work\\21104909-527d-4766-99e3-8be351afd714\\Unzip\\mcc\\interop\\mcc_i83\\mcc_i83.cmd
    \r
    Expected: True\r
    Actual:   False

        Stack Trace:

           at JIT_jit64._mcc_interop_mcc_i83_mcc_i83_._mcc_interop_mcc_i83_mcc_i83_cmd() in E:\A\_work\105\s\bin\tests\Windows_NT.arm.Release\TestWrappers\JIT.jit64\JIT.jit64.XUnitWrapper.cs:line 23349
Build : 3.0 - 20180827.01 (Core Tests)
Failing configurations:
- windows.10.arm64-arm
  - 
Details: 
https://mc.dot.net/#/product/netcore/30/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fcli~2F/build/20180827.01/workItem/JIT.jit64.XUnitWrapper/analysis/xunit/JIT_jit64._mcc_interop_mcc_i83_mcc_i83_~2F_mcc_interop_mcc_i83_mcc_i83_cmd</Description>
    <Title_Description>Test failure: JIT_jit64._mcc_interop_mcc_i83_mcc_i83_/_mcc_interop_mcc_i83_mcc_i83_cmd Opened on behalf of @Sunny-pu

The test `JIT_jit64._mcc_interop_mcc_i83_mcc_i83_/_mcc_interop_mcc_i83_mcc_i83_cmd` has failed.


    
    Return code:      1
    Raw output file:      C:\\dotnetbuild\\work\\31155d77-0bf1-45a2-a51e-dc457ed07fe5\\Work\\21104909-527d-4766-99e3-8be351afd714\\Unzip\\Reports\\JIT.jit64\\mcc\\interop\\mcc_i83\\mcc_i83.output.txt
    Raw output:
    BEGIN EXECUTION\r
     \"C:\\dotnetbuild\\work\\31155d77-0bf1-45a2-a51e-dc457ed07fe5\\Payload\\corerun.exe\" mcc_i83.exe \r
    Expected: 100\r
    Actual: -1073741819\r
    END EXECUTION - FAILED\r
    FAILED\r
    Test Harness Exitcode is : 1\r
    
    To run the test:
    &gt; set CORE_ROOT=C:\\dotnetbuild\\work\\31155d77-0bf1-45a2-a51e-dc457ed07fe5\\Payload
    &gt; C:\\dotnetbuild\\work\\31155d77-0bf1-45a2-a51e-dc457ed07fe5\\Work\\21104909-527d-4766-99e3-8be351afd714\\Unzip\\mcc\\interop\\mcc_i83\\mcc_i83.cmd
    \r
    Expected: True\r
    Actual:   False

        Stack Trace:

           at JIT_jit64._mcc_interop_mcc_i83_mcc_i83_._mcc_interop_mcc_i83_mcc_i83_cmd() in E:\A\_work\105\s\bin\tests\Windows_NT.arm.Release\TestWrappers\JIT.jit64\JIT.jit64.XUnitWrapper.cs:line 23349
Build : 3.0 - 20180827.01 (Core Tests)
Failing configurations:
- windows.10.arm64-arm
  - 
Details: 
https://mc.dot.net/#/product/netcore/30/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fcli~2F/build/20180827.01/workItem/JIT.jit64.XUnitWrapper/analysis/xunit/JIT_jit64._mcc_interop_mcc_i83_mcc_i83_~2F_mcc_interop_mcc_i83_mcc_i83_cmd</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>jashook</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19683</IssueLabelID>
    <Title>Test failure: baseservices_varargs._varargsupport_r_varargsupport_r_/_varargsupport_r_varargsupport_r_cmd</Title>
    <Description>Opened on behalf of @Sunny-pu

The test `baseservices_varargs._varargsupport_r_varargsupport_r_/_varargsupport_r_varargsupport_r_cmd` has failed.


    
    Return code:      1
    Raw output file:      C:\\dotnetbuild\\work\\31155d77-0bf1-45a2-a51e-dc457ed07fe5\\Work\\00d13fb9-5edc-43da-9ceb-c7260abf98d0\\Unzip\\Reports\\baseservices.varargs\\varargsupport_r\\varargsupport_r.output.txt
    Raw output:
    BEGIN EXECUTION\r
     \"C:\\dotnetbuild\\work\\31155d77-0bf1-45a2-a51e-dc457ed07fe5\\Payload\\corerun.exe\" varargsupport_r.exe \r
    Blah Blah\r
    Test failed as InvalidProgramException was not raised.\r
    Expected: 100\r
    Actual: 0\r
    END EXECUTION - FAILED\r
    FAILED\r
    Test Harness Exitcode is : 1\r
    
    To run the test:
    &gt; set CORE_ROOT=C:\\dotnetbuild\\work\\31155d77-0bf1-45a2-a51e-dc457ed07fe5\\Payload
    &gt; C:\\dotnetbuild\\work\\31155d77-0bf1-45a2-a51e-dc457ed07fe5\\Work\\00d13fb9-5edc-43da-9ceb-c7260abf98d0\\Unzip\\varargsupport_r\\varargsupport_r.cmd
    \r
    Expected: True\r
    Actual:   False

        Stack Trace:

           at baseservices_varargs._varargsupport_r_varargsupport_r_._varargsupport_r_varargsupport_r_cmd() in E:\A\_work\105\s\bin\tests\Windows_NT.arm.Release\TestWrappers\baseservices.varargs\baseservices.varargs.XUnitWrapper.cs:line 179
Build : 3.0 - 20180827.01 (Core Tests)
Failing configurations:
- windows.10.arm64-arm
  - 
Details: https://mc.dot.net/#/product/netcore/30/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fcli~2F/build/20180827.01/workItem/baseservices.varargs.XUnitWrapper/analysis/xunit/baseservices_varargs._varargsupport_r_varargsupport_r_~2F_varargsupport_r_varargsupport_r_cmd</Description>
    <Title_Description>Test failure: baseservices_varargs._varargsupport_r_varargsupport_r_/_varargsupport_r_varargsupport_r_cmd Opened on behalf of @Sunny-pu

The test `baseservices_varargs._varargsupport_r_varargsupport_r_/_varargsupport_r_varargsupport_r_cmd` has failed.


    
    Return code:      1
    Raw output file:      C:\\dotnetbuild\\work\\31155d77-0bf1-45a2-a51e-dc457ed07fe5\\Work\\00d13fb9-5edc-43da-9ceb-c7260abf98d0\\Unzip\\Reports\\baseservices.varargs\\varargsupport_r\\varargsupport_r.output.txt
    Raw output:
    BEGIN EXECUTION\r
     \"C:\\dotnetbuild\\work\\31155d77-0bf1-45a2-a51e-dc457ed07fe5\\Payload\\corerun.exe\" varargsupport_r.exe \r
    Blah Blah\r
    Test failed as InvalidProgramException was not raised.\r
    Expected: 100\r
    Actual: 0\r
    END EXECUTION - FAILED\r
    FAILED\r
    Test Harness Exitcode is : 1\r
    
    To run the test:
    &gt; set CORE_ROOT=C:\\dotnetbuild\\work\\31155d77-0bf1-45a2-a51e-dc457ed07fe5\\Payload
    &gt; C:\\dotnetbuild\\work\\31155d77-0bf1-45a2-a51e-dc457ed07fe5\\Work\\00d13fb9-5edc-43da-9ceb-c7260abf98d0\\Unzip\\varargsupport_r\\varargsupport_r.cmd
    \r
    Expected: True\r
    Actual:   False

        Stack Trace:

           at baseservices_varargs._varargsupport_r_varargsupport_r_._varargsupport_r_varargsupport_r_cmd() in E:\A\_work\105\s\bin\tests\Windows_NT.arm.Release\TestWrappers\baseservices.varargs\baseservices.varargs.XUnitWrapper.cs:line 179
Build : 3.0 - 20180827.01 (Core Tests)
Failing configurations:
- windows.10.arm64-arm
  - 
Details: https://mc.dot.net/#/product/netcore/30/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fcli~2F/build/20180827.01/workItem/baseservices.varargs.XUnitWrapper/analysis/xunit/baseservices_varargs._varargsupport_r_varargsupport_r_~2F_varargsupport_r_varargsupport_r_cmd</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>jashook</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19682</IssueLabelID>
    <Title>Hang when running with pseudo.</Title>
    <Description>https://www.yoctoproject.org/software-item/pseudo/

This tool allows users to to act as root.

I am using official binaries of v2.1.401 SDK.

Simple running ```dotnet --version``` will deadlock.

I don't have the symbols for the coreclr but here is the dump with the pseudo symbols.

```
Thread 4 (LWP 750):
#0  __lll_lock_wait () at ../sysdeps/unix/sysv/linux/x86_64/lowlevellock.S:135
No locals.
#1  0x000000369ee09a85 in __GI___pthread_mutex_lock (mutex=mutex@entry=0x7ff11fe391c0 &lt;pseudo_mutex&gt;) at /usr/src/debug/glibc/2.27-r0/git/nptl/pthread_mutex_lock.c:78
        type = 0
        __PRETTY_FUNCTION__ = "__pthread_mutex_lock"
        id = &lt;optimized out&gt;
#2  0x00007ff11fbfc46e in pseudo_getlock () at /usr/src/debug/pseudo/1.9.0+gitAUTOINC+fddbe854c9-r0/git/pseudo_wrappers.c:232
No locals.
#3  0x00007ff11fc041c2 in close (fd=12) at /usr/src/debug/pseudo/1.9.0+gitAUTOINC+fddbe854c9-r0/git/pseudo_wrapfuncs.c:1833
        saved = {__val = {0 0 0 0 0 0 0 7771196 0 7771152 140671453228688 8 140721121120655 1 7771112 234593781177}}
        rc = -1
        save_errno = &lt;optimized out&gt;
#4  0x00007ff11f346f2b in ?? () from /opt/medxchange/2.5/sysroots/corei7-64-poky-linux/usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.3/libcoreclr.so
No symbol table info available.
#5  0x00007ff11f345999 in ?? () from /opt/medxchange/2.5/sysroots/corei7-64-poky-linux/usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.3/libcoreclr.so
No symbol table info available.
#6  0x000000369ee07477 in start_thread (arg=0x7ff09ffff700) at /usr/src/debug/glibc/2.27-r0/git/nptl/pthread_create.c:463
        pd = 0x7ff09ffff700
        now = &lt;optimized out&gt;
        unwind_buf = {cancel_jmp_buf = {{jmp_buf = {140671453230848 -5511970289552424946 140721121120654 140721121120655 8396800 140721121120824 5503596409520685070 -5481810962224349170} mask_was_saved = 0}} priv = {pad = {0x0 0x0 0x0 0x0} data = {prev = 0x0 cleanup = 0x0 canceltype = 0}}}
        not_first_call = &lt;optimized out&gt;
#7  0x000000369eaf208f in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:95
No locals.

Thread 3 (LWP 749):
#0  0x000000369eae3f68 in __libc_openat64 (fd=-100 file=0x62f270 "/tmp/clr-debug-pipe-747-4947-in" oflag=0) at /usr/src/debug/glibc/2.27-r0/git/sysdeps/unix/sysv/linux/openat64.c:45
        resultvar = 18446744073709551104
        sc_cancel_oldtype = 0
        mode = 0
#1  0x00007ff11fbfb300 in wrap_openat (dirfd=dirfd@entry=-100 path=0x62f270 "/tmp/clr-debug-pipe-747-4947-in" flags=flags@entry=0) at /usr/src/debug/pseudo/1.9.0+gitAUTOINC+fddbe854c9-r0/git/ports/linux/guts/openat.c:72
        rc = -1
        ap = {{gp_offset = 24 fp_offset = 0 overflow_arg_area = 0x7ff0a4a24630 reg_save_area = 0x7ff0a4a245c0}}
        mode = 0
        buf = {st_dev = 0 st_ino = 1535339371 st_nlink = 770153037 st_mode = 1535339371 st_uid = 0 st_gid = 770153037 __pad0 = 0 st_rdev = 1535339371 st_size = 770153037 st_blksize = 0 st_blocks = 0 st_atim = {tv_sec = 0 tv_nsec = 0} st_mtim = {tv_sec = 6484592 tv_nsec = 0} st_ctim = {tv_sec = 140671530980960 tv_nsec = 7744512} __glibc_reserved = {6484592 4096 140673596637077}}
        existed = 1
        save_errno = &lt;optimized out&gt;
#2  0x00007ff11fbfb4da in wrap_open (path=&lt;optimized out&gt; flags=flags@entry=0) at /usr/src/debug/pseudo/1.9.0+gitAUTOINC+fddbe854c9-r0/git/ports/linux/guts/open.c:10
        ap = {{gp_offset = 16 fp_offset = 32753 overflow_arg_area = 0x7ff0a4a24690 reg_save_area = 0x7ff0a4a24650}}
#3  0x00007ff11fc1004c in open (path=&lt;optimized out&gt; flags=0) at /usr/src/debug/pseudo/1.9.0+gitAUTOINC+fddbe854c9-r0/git/pseudo_wrapfuncs.c:9534
        saved = {__val = {0 &lt;repeats 16 times&gt;}}
        ap = {{gp_offset = 16 fp_offset = 0 overflow_arg_area = 0x7ff0a4a247b0 reg_save_area = 0x7ff0a4a24740}}
        mode = 0
        rc = -1
        save_errno = &lt;optimized out&gt;
        __func__ = "open"
#4  0x00007ff11f249d9f in ?? () from /opt/medxchange/2.5/sysroots/corei7-64-poky-linux/usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.3/libcoreclr.so
No symbol table info available.
#5  0x00007ff11f242a78 in ?? () from /opt/medxchange/2.5/sysroots/corei7-64-poky-linux/usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.3/libcoreclr.so
No symbol table info available.
#6  0x00007ff11f241929 in ?? () from /opt/medxchange/2.5/sysroots/corei7-64-poky-linux/usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.3/libcoreclr.so
No symbol table info available.
#7  0x00007ff11f345a62 in ?? () from /opt/medxchange/2.5/sysroots/corei7-64-poky-linux/usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.3/libcoreclr.so
No symbol table info available.
#8  0x000000369ee07477 in start_thread (arg=0x7ff0a4a25700) at /usr/src/debug/glibc/2.27-r0/git/nptl/pthread_create.c:463
        pd = 0x7ff0a4a25700
        now = &lt;optimized out&gt;
        unwind_buf = {cancel_jmp_buf = {{jmp_buf = {140671530981120 -5511970289552424946 140721121120094 140721121120095 8396800 140721121120264 5503615886123630606 -5481810962224349170} mask_was_saved = 0}} priv = {pad = {0x0 0x0 0x0 0x0} data = {prev = 0x0 cleanup = 0x0 canceltype = 0}}}
        not_first_call = &lt;optimized out&gt;
#9  0x000000369eaf208f in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:95
No locals.

Thread 2 (LWP 748):
#0  0x000000369eae82b9 in __GI___poll (fds=0x7ff0a5245e28 nfds=1 timeout=-1) at /usr/src/debug/glibc/2.27-r0/git/sysdeps/unix/sysv/linux/poll.c:29
        resultvar = 18446744073709551100
        sc_cancel_oldtype = 0
#1  0x00007ff11f33d403 in ?? () from /opt/medxchange/2.5/sysroots/corei7-64-poky-linux/usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.3/libcoreclr.so
No symbol table info available.
#2  0x00007ff11f33c963 in ?? () from /opt/medxchange/2.5/sysroots/corei7-64-poky-linux/usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.3/libcoreclr.so
No symbol table info available.
#3  0x00007ff11f345a62 in ?? () from /opt/medxchange/2.5/sysroots/corei7-64-poky-linux/usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.3/libcoreclr.so
No symbol table info available.
#4  0x000000369ee07477 in start_thread (arg=0x7ff0a5246700) at /usr/src/debug/glibc/2.27-r0/git/nptl/pthread_create.c:463
        pd = 0x7ff0a5246700
        now = &lt;optimized out&gt;
        unwind_buf = {cancel_jmp_buf = {{jmp_buf = {140671539504896 -5511970289552424946 140721121120862 140721121120863 8396800 140721121121032 5503616933558779918 -5481810962224349170} mask_was_saved = 0}} priv = {pad = {0x0 0x0 0x0 0x0} data = {prev = 0x0 cleanup = 0x0 canceltype = 0}}}
        not_first_call = &lt;optimized out&gt;
#5  0x000000369eaf208f in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:95
No locals.

Thread 1 (LWP 747):
#0  __lll_lock_wait () at ../sysdeps/unix/sysv/linux/x86_64/lowlevellock.S:135
No locals.
#1  0x000000369ee09a85 in __GI___pthread_mutex_lock (mutex=mutex@entry=0x7ff11fe391c0 &lt;pseudo_mutex&gt;) at /usr/src/debug/glibc/2.27-r0/git/nptl/pthread_mutex_lock.c:78
        type = 0
        __PRETTY_FUNCTION__ = "__pthread_mutex_lock"
        id = &lt;optimized out&gt;
#2  0x00007ff11fbfc46e in pseudo_getlock () at /usr/src/debug/pseudo/1.9.0+gitAUTOINC+fddbe854c9-r0/git/pseudo_wrappers.c:232
No locals.
#3  0x00007ff11fc07a4a in fopen64 (path=0x7ffc306fd0b0 "/proc/747/stat" mode=0x7ff11f3cd913 "r") at /usr/src/debug/pseudo/1.9.0+gitAUTOINC+fddbe854c9-r0/git/pseudo_wrapfuncs.c:4067
        saved = {__val = {0 3904960854615930675 8458434531088821347 747 0 140721121120904 6367331215889861981 6435167007366008321 0 0 0 0 0 0 0 0}}
        rc = 0x0
        save_errno = &lt;optimized out&gt;
        __func__ = "fopen64"
#4  0x00007ff11f342e88 in ?? () from /opt/medxchange/2.5/sysroots/corei7-64-poky-linux/usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.3/libcoreclr.so
No symbol table info available.
#5  0x00007ff11f342d4d in ?? () from /opt/medxchange/2.5/sysroots/corei7-64-poky-linux/usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.3/libcoreclr.so
No symbol table info available.
#6  0x00007ff11f21d7d4 in ?? () from /opt/medxchange/2.5/sysroots/corei7-64-poky-linux/usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.3/libcoreclr.so
No symbol table info available.
#7  0x00007ff11efe058b in ?? () from /opt/medxchange/2.5/sysroots/corei7-64-poky-linux/usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.3/libcoreclr.so
No symbol table info available.
#8  0x00007ff11efdfb95 in ?? () from /opt/medxchange/2.5/sysroots/corei7-64-poky-linux/usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.3/libcoreclr.so
No symbol table info available.
#9  0x00007ff11efdfa1a in ?? () from /opt/medxchange/2.5/sysroots/corei7-64-poky-linux/usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.3/libcoreclr.so
No symbol table info available.
#10 0x00007ff11ef28919 in ?? () from /opt/medxchange/2.5/sysroots/corei7-64-poky-linux/usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.3/libcoreclr.so
No symbol table info available.
#11 0x00007ff11ef03aad in coreclr_initialize () from /opt/medxchange/2.5/sysroots/corei7-64-poky-linux/usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.3/libcoreclr.so
No symbol table info available.
#12 0x00007ff11f6db780 in ?? () from /opt/medxchange/2.5/sysroots/corei7-64-poky-linux/usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.3/libhostpolicy.so
No symbol table info available.
#13 0x00007ff11f6cdcfb in ?? () from /opt/medxchange/2.5/sysroots/corei7-64-poky-linux/usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.3/libhostpolicy.so
No symbol table info available.
#14 0x00007ff11f6ceb4c in corehost_main () from /opt/medxchange/2.5/sysroots/corei7-64-poky-linux/usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.3/libhostpolicy.so
No symbol table info available.
#15 0x00007ff11f981cbf in ?? () from /opt/medxchange/2.5/sysroots/corei7-64-poky-linux/usr/share/dotnet/host/fxr/2.1.3/libhostfxr.so
No symbol table info available.
#16 0x00007ff11f98d36c in ?? () from /opt/medxchange/2.5/sysroots/corei7-64-poky-linux/usr/share/dotnet/host/fxr/2.1.3/libhostfxr.so
No symbol table info available.
#17 0x00007ff11f98e4c5 in ?? () from /opt/medxchange/2.5/sysroots/corei7-64-poky-linux/usr/share/dotnet/host/fxr/2.1.3/libhostfxr.so
No symbol table info available.
#18 0x00007ff11f98e5a9 in ?? () from /opt/medxchange/2.5/sysroots/corei7-64-poky-linux/usr/share/dotnet/host/fxr/2.1.3/libhostfxr.so
No symbol table info available.
#19 0x00007ff11f98e155 in ?? () from /opt/medxchange/2.5/sysroots/corei7-64-poky-linux/usr/share/dotnet/host/fxr/2.1.3/libhostfxr.so
No symbol table info available.
#20 0x00007ff11f98d9aa in ?? () from /opt/medxchange/2.5/sysroots/corei7-64-poky-linux/usr/share/dotnet/host/fxr/2.1.3/libhostfxr.so
No symbol table info available.
#21 0x00007ff11f981f0c in hostfxr_main_startupinfo () from /opt/medxchange/2.5/sysroots/corei7-64-poky-linux/usr/share/dotnet/host/fxr/2.1.3/libhostfxr.so
No symbol table info available.
#22 0x000000000040ac74 in ?? ()
No symbol table info available.
#23 0x000000000040af05 in ?? ()
No symbol table info available.
#24 0x000000369ea21a57 in __libc_start_main (main=0x40ae60 argc=2 argv=0x7ffc306ff078 init=&lt;optimized out&gt; fini=&lt;optimized out&gt; rtld_fini=&lt;optimized out&gt; stack_end=0x7ffc306ff068) at /usr/src/debug/glibc/2.27-r0/git/csu/libc-start.c:308
        result = &lt;optimized out&gt;
        unwind_buf = {cancel_jmp_buf = {{jmp_buf = {0 -5511969730755788786 4229675 140721121128560 0 0 5510696093563256846 -5481811493393104882} mask_was_saved = 0}} priv = {pad = {0x0 0x0 0x7ffc306ff090 0x369e826110} data = {prev = 0x0 cleanup = 0x0 canceltype = 812642448}}}
        not_first_call = &lt;optimized out&gt;
#25 0x0000000000408a54 in _start ()
No symbol table info available.
```

This tool is vital for Yocto since it ensures a clean operating system with no host contamination.</Description>
    <Title_Description>Hang when running with pseudo. https://www.yoctoproject.org/software-item/pseudo/

This tool allows users to to act as root.

I am using official binaries of v2.1.401 SDK.

Simple running ```dotnet --version``` will deadlock.

I don't have the symbols for the coreclr but here is the dump with the pseudo symbols.

```
Thread 4 (LWP 750):
#0  __lll_lock_wait () at ../sysdeps/unix/sysv/linux/x86_64/lowlevellock.S:135
No locals.
#1  0x000000369ee09a85 in __GI___pthread_mutex_lock (mutex=mutex@entry=0x7ff11fe391c0 &lt;pseudo_mutex&gt;) at /usr/src/debug/glibc/2.27-r0/git/nptl/pthread_mutex_lock.c:78
        type = 0
        __PRETTY_FUNCTION__ = "__pthread_mutex_lock"
        id = &lt;optimized out&gt;
#2  0x00007ff11fbfc46e in pseudo_getlock () at /usr/src/debug/pseudo/1.9.0+gitAUTOINC+fddbe854c9-r0/git/pseudo_wrappers.c:232
No locals.
#3  0x00007ff11fc041c2 in close (fd=12) at /usr/src/debug/pseudo/1.9.0+gitAUTOINC+fddbe854c9-r0/git/pseudo_wrapfuncs.c:1833
        saved = {__val = {0 0 0 0 0 0 0 7771196 0 7771152 140671453228688 8 140721121120655 1 7771112 234593781177}}
        rc = -1
        save_errno = &lt;optimized out&gt;
#4  0x00007ff11f346f2b in ?? () from /opt/medxchange/2.5/sysroots/corei7-64-poky-linux/usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.3/libcoreclr.so
No symbol table info available.
#5  0x00007ff11f345999 in ?? () from /opt/medxchange/2.5/sysroots/corei7-64-poky-linux/usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.3/libcoreclr.so
No symbol table info available.
#6  0x000000369ee07477 in start_thread (arg=0x7ff09ffff700) at /usr/src/debug/glibc/2.27-r0/git/nptl/pthread_create.c:463
        pd = 0x7ff09ffff700
        now = &lt;optimized out&gt;
        unwind_buf = {cancel_jmp_buf = {{jmp_buf = {140671453230848 -5511970289552424946 140721121120654 140721121120655 8396800 140721121120824 5503596409520685070 -5481810962224349170} mask_was_saved = 0}} priv = {pad = {0x0 0x0 0x0 0x0} data = {prev = 0x0 cleanup = 0x0 canceltype = 0}}}
        not_first_call = &lt;optimized out&gt;
#7  0x000000369eaf208f in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:95
No locals.

Thread 3 (LWP 749):
#0  0x000000369eae3f68 in __libc_openat64 (fd=-100 file=0x62f270 "/tmp/clr-debug-pipe-747-4947-in" oflag=0) at /usr/src/debug/glibc/2.27-r0/git/sysdeps/unix/sysv/linux/openat64.c:45
        resultvar = 18446744073709551104
        sc_cancel_oldtype = 0
        mode = 0
#1  0x00007ff11fbfb300 in wrap_openat (dirfd=dirfd@entry=-100 path=0x62f270 "/tmp/clr-debug-pipe-747-4947-in" flags=flags@entry=0) at /usr/src/debug/pseudo/1.9.0+gitAUTOINC+fddbe854c9-r0/git/ports/linux/guts/openat.c:72
        rc = -1
        ap = {{gp_offset = 24 fp_offset = 0 overflow_arg_area = 0x7ff0a4a24630 reg_save_area = 0x7ff0a4a245c0}}
        mode = 0
        buf = {st_dev = 0 st_ino = 1535339371 st_nlink = 770153037 st_mode = 1535339371 st_uid = 0 st_gid = 770153037 __pad0 = 0 st_rdev = 1535339371 st_size = 770153037 st_blksize = 0 st_blocks = 0 st_atim = {tv_sec = 0 tv_nsec = 0} st_mtim = {tv_sec = 6484592 tv_nsec = 0} st_ctim = {tv_sec = 140671530980960 tv_nsec = 7744512} __glibc_reserved = {6484592 4096 140673596637077}}
        existed = 1
        save_errno = &lt;optimized out&gt;
#2  0x00007ff11fbfb4da in wrap_open (path=&lt;optimized out&gt; flags=flags@entry=0) at /usr/src/debug/pseudo/1.9.0+gitAUTOINC+fddbe854c9-r0/git/ports/linux/guts/open.c:10
        ap = {{gp_offset = 16 fp_offset = 32753 overflow_arg_area = 0x7ff0a4a24690 reg_save_area = 0x7ff0a4a24650}}
#3  0x00007ff11fc1004c in open (path=&lt;optimized out&gt; flags=0) at /usr/src/debug/pseudo/1.9.0+gitAUTOINC+fddbe854c9-r0/git/pseudo_wrapfuncs.c:9534
        saved = {__val = {0 &lt;repeats 16 times&gt;}}
        ap = {{gp_offset = 16 fp_offset = 0 overflow_arg_area = 0x7ff0a4a247b0 reg_save_area = 0x7ff0a4a24740}}
        mode = 0
        rc = -1
        save_errno = &lt;optimized out&gt;
        __func__ = "open"
#4  0x00007ff11f249d9f in ?? () from /opt/medxchange/2.5/sysroots/corei7-64-poky-linux/usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.3/libcoreclr.so
No symbol table info available.
#5  0x00007ff11f242a78 in ?? () from /opt/medxchange/2.5/sysroots/corei7-64-poky-linux/usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.3/libcoreclr.so
No symbol table info available.
#6  0x00007ff11f241929 in ?? () from /opt/medxchange/2.5/sysroots/corei7-64-poky-linux/usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.3/libcoreclr.so
No symbol table info available.
#7  0x00007ff11f345a62 in ?? () from /opt/medxchange/2.5/sysroots/corei7-64-poky-linux/usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.3/libcoreclr.so
No symbol table info available.
#8  0x000000369ee07477 in start_thread (arg=0x7ff0a4a25700) at /usr/src/debug/glibc/2.27-r0/git/nptl/pthread_create.c:463
        pd = 0x7ff0a4a25700
        now = &lt;optimized out&gt;
        unwind_buf = {cancel_jmp_buf = {{jmp_buf = {140671530981120 -5511970289552424946 140721121120094 140721121120095 8396800 140721121120264 5503615886123630606 -5481810962224349170} mask_was_saved = 0}} priv = {pad = {0x0 0x0 0x0 0x0} data = {prev = 0x0 cleanup = 0x0 canceltype = 0}}}
        not_first_call = &lt;optimized out&gt;
#9  0x000000369eaf208f in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:95
No locals.

Thread 2 (LWP 748):
#0  0x000000369eae82b9 in __GI___poll (fds=0x7ff0a5245e28 nfds=1 timeout=-1) at /usr/src/debug/glibc/2.27-r0/git/sysdeps/unix/sysv/linux/poll.c:29
        resultvar = 18446744073709551100
        sc_cancel_oldtype = 0
#1  0x00007ff11f33d403 in ?? () from /opt/medxchange/2.5/sysroots/corei7-64-poky-linux/usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.3/libcoreclr.so
No symbol table info available.
#2  0x00007ff11f33c963 in ?? () from /opt/medxchange/2.5/sysroots/corei7-64-poky-linux/usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.3/libcoreclr.so
No symbol table info available.
#3  0x00007ff11f345a62 in ?? () from /opt/medxchange/2.5/sysroots/corei7-64-poky-linux/usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.3/libcoreclr.so
No symbol table info available.
#4  0x000000369ee07477 in start_thread (arg=0x7ff0a5246700) at /usr/src/debug/glibc/2.27-r0/git/nptl/pthread_create.c:463
        pd = 0x7ff0a5246700
        now = &lt;optimized out&gt;
        unwind_buf = {cancel_jmp_buf = {{jmp_buf = {140671539504896 -5511970289552424946 140721121120862 140721121120863 8396800 140721121121032 5503616933558779918 -5481810962224349170} mask_was_saved = 0}} priv = {pad = {0x0 0x0 0x0 0x0} data = {prev = 0x0 cleanup = 0x0 canceltype = 0}}}
        not_first_call = &lt;optimized out&gt;
#5  0x000000369eaf208f in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:95
No locals.

Thread 1 (LWP 747):
#0  __lll_lock_wait () at ../sysdeps/unix/sysv/linux/x86_64/lowlevellock.S:135
No locals.
#1  0x000000369ee09a85 in __GI___pthread_mutex_lock (mutex=mutex@entry=0x7ff11fe391c0 &lt;pseudo_mutex&gt;) at /usr/src/debug/glibc/2.27-r0/git/nptl/pthread_mutex_lock.c:78
        type = 0
        __PRETTY_FUNCTION__ = "__pthread_mutex_lock"
        id = &lt;optimized out&gt;
#2  0x00007ff11fbfc46e in pseudo_getlock () at /usr/src/debug/pseudo/1.9.0+gitAUTOINC+fddbe854c9-r0/git/pseudo_wrappers.c:232
No locals.
#3  0x00007ff11fc07a4a in fopen64 (path=0x7ffc306fd0b0 "/proc/747/stat" mode=0x7ff11f3cd913 "r") at /usr/src/debug/pseudo/1.9.0+gitAUTOINC+fddbe854c9-r0/git/pseudo_wrapfuncs.c:4067
        saved = {__val = {0 3904960854615930675 8458434531088821347 747 0 140721121120904 6367331215889861981 6435167007366008321 0 0 0 0 0 0 0 0}}
        rc = 0x0
        save_errno = &lt;optimized out&gt;
        __func__ = "fopen64"
#4  0x00007ff11f342e88 in ?? () from /opt/medxchange/2.5/sysroots/corei7-64-poky-linux/usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.3/libcoreclr.so
No symbol table info available.
#5  0x00007ff11f342d4d in ?? () from /opt/medxchange/2.5/sysroots/corei7-64-poky-linux/usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.3/libcoreclr.so
No symbol table info available.
#6  0x00007ff11f21d7d4 in ?? () from /opt/medxchange/2.5/sysroots/corei7-64-poky-linux/usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.3/libcoreclr.so
No symbol table info available.
#7  0x00007ff11efe058b in ?? () from /opt/medxchange/2.5/sysroots/corei7-64-poky-linux/usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.3/libcoreclr.so
No symbol table info available.
#8  0x00007ff11efdfb95 in ?? () from /opt/medxchange/2.5/sysroots/corei7-64-poky-linux/usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.3/libcoreclr.so
No symbol table info available.
#9  0x00007ff11efdfa1a in ?? () from /opt/medxchange/2.5/sysroots/corei7-64-poky-linux/usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.3/libcoreclr.so
No symbol table info available.
#10 0x00007ff11ef28919 in ?? () from /opt/medxchange/2.5/sysroots/corei7-64-poky-linux/usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.3/libcoreclr.so
No symbol table info available.
#11 0x00007ff11ef03aad in coreclr_initialize () from /opt/medxchange/2.5/sysroots/corei7-64-poky-linux/usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.3/libcoreclr.so
No symbol table info available.
#12 0x00007ff11f6db780 in ?? () from /opt/medxchange/2.5/sysroots/corei7-64-poky-linux/usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.3/libhostpolicy.so
No symbol table info available.
#13 0x00007ff11f6cdcfb in ?? () from /opt/medxchange/2.5/sysroots/corei7-64-poky-linux/usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.3/libhostpolicy.so
No symbol table info available.
#14 0x00007ff11f6ceb4c in corehost_main () from /opt/medxchange/2.5/sysroots/corei7-64-poky-linux/usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.3/libhostpolicy.so
No symbol table info available.
#15 0x00007ff11f981cbf in ?? () from /opt/medxchange/2.5/sysroots/corei7-64-poky-linux/usr/share/dotnet/host/fxr/2.1.3/libhostfxr.so
No symbol table info available.
#16 0x00007ff11f98d36c in ?? () from /opt/medxchange/2.5/sysroots/corei7-64-poky-linux/usr/share/dotnet/host/fxr/2.1.3/libhostfxr.so
No symbol table info available.
#17 0x00007ff11f98e4c5 in ?? () from /opt/medxchange/2.5/sysroots/corei7-64-poky-linux/usr/share/dotnet/host/fxr/2.1.3/libhostfxr.so
No symbol table info available.
#18 0x00007ff11f98e5a9 in ?? () from /opt/medxchange/2.5/sysroots/corei7-64-poky-linux/usr/share/dotnet/host/fxr/2.1.3/libhostfxr.so
No symbol table info available.
#19 0x00007ff11f98e155 in ?? () from /opt/medxchange/2.5/sysroots/corei7-64-poky-linux/usr/share/dotnet/host/fxr/2.1.3/libhostfxr.so
No symbol table info available.
#20 0x00007ff11f98d9aa in ?? () from /opt/medxchange/2.5/sysroots/corei7-64-poky-linux/usr/share/dotnet/host/fxr/2.1.3/libhostfxr.so
No symbol table info available.
#21 0x00007ff11f981f0c in hostfxr_main_startupinfo () from /opt/medxchange/2.5/sysroots/corei7-64-poky-linux/usr/share/dotnet/host/fxr/2.1.3/libhostfxr.so
No symbol table info available.
#22 0x000000000040ac74 in ?? ()
No symbol table info available.
#23 0x000000000040af05 in ?? ()
No symbol table info available.
#24 0x000000369ea21a57 in __libc_start_main (main=0x40ae60 argc=2 argv=0x7ffc306ff078 init=&lt;optimized out&gt; fini=&lt;optimized out&gt; rtld_fini=&lt;optimized out&gt; stack_end=0x7ffc306ff068) at /usr/src/debug/glibc/2.27-r0/git/csu/libc-start.c:308
        result = &lt;optimized out&gt;
        unwind_buf = {cancel_jmp_buf = {{jmp_buf = {0 -5511969730755788786 4229675 140721121128560 0 0 5510696093563256846 -5481811493393104882} mask_was_saved = 0}} priv = {pad = {0x0 0x0 0x7ffc306ff090 0x369e826110} data = {prev = 0x0 cleanup = 0x0 canceltype = 812642448}}}
        not_first_call = &lt;optimized out&gt;
#25 0x0000000000408a54 in _start ()
No symbol table info available.
```

This tool is vital for Yocto since it ensures a clean operating system with no host contamination.</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>mikem8361</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19681</IssueLabelID>
    <Title>re-enable com for local gc</Title>
    <Description>This codepath is only used when a profiler or ETW walks the heap so an interface call for every COM object:
1. Should only affect COM objects which is usually a very small portion of overall objects
2. Shouldn't be a hot path item
3. Even if it was walking the heap is very slow already and only done for diagnostics so not performance critical

So I think an interface call is fine here.</Description>
    <Title_Description>re-enable com for local gc This codepath is only used when a profiler or ETW walks the heap so an interface call for every COM object:
1. Should only affect COM objects which is usually a very small portion of overall objects
2. Shouldn't be a hot path item
3. Even if it was walking the heap is very slow already and only done for diagnostics so not performance critical

So I think an interface call is fine here.</Title_Description>
    <Label>area-GC</Label>
    <Assignee>davmason</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19680</IssueLabelID>
    <Title>Segfault in ECall::GetQCallImpl on local build.</Title>
    <Description>```
&gt; dotnet console new

Configuring...
--------------
A command is running to populate your local package cache to improve restore speed and enable offline access. This command takes up to one minute to complete and only runs once.
Decompressing 100% 7085 ms
Segmentation fault (core dumped)
```

Some information about my build:

* I need to remove lttng-ust from the coreclr (because of #15693) so I am compiling it with ```-DFEATURE_EVENT_TRACE=0```
* I am using tag ```v2.1.3``` with some minor patches for cross-compilation (see them [here](https://github.com/qmlnet/coreclr/commits/yocto-v2.1.401)).


```
Thread 5 (LWP 21256):
#0  0x00000037ee60d20c in futex_wait_cancelable (private=&lt;optimized out&gt; expected=0 futex_word=0x69c3c8) at /usr/src/debug/glibc/2.27-r0/git/sysdeps/unix/sysv/linux/futex-internal.h:88
        __ret = -512
        oldtype = 0
        err = &lt;optimized out&gt;
#1  __pthread_cond_wait_common (abstime=0x0 mutex=0x69c378 cond=0x69c3a0) at /usr/src/debug/glibc/2.27-r0/git/nptl/pthread_cond_wait.c:502
        spin = 0
        buffer = {__routine = 0x37ee60cfc0 &lt;__condvar_cleanup_waiting&gt; __arg = 0x7f1cf0f0c450 __canceltype = -252656544 __prev = 0x0}
        cbuffer = {wseq = 2 cond = 0x69c3a0 mutex = 0x69c378 private = 0}
        err = &lt;optimized out&gt;
        g = 0
        flags = &lt;optimized out&gt;
        signals = &lt;optimized out&gt;
        result = 0
        seq = 1
#2  __pthread_cond_wait (cond=0x69c3a0 mutex=0x69c378) at /usr/src/debug/glibc/2.27-r0/git/nptl/pthread_cond_wait.c:655
No locals.
#3  0x00007f1d6cedb06f in CorUnix::CPalSynchronizationManager::ThreadNativeWait (ptnwdNativeWaitData=0x69c378 dwTimeout=4294967295 ptwrWakeupReason=0x7f1cf0f0c58c pdwSignaledObject=0x7f1cf0f0c588) at /usr/src/debug/coreclr/2.1.401-r0/git/src/pal/src/synchmgr/synchmanager.cpp:479
        palErr = 0
        iRet = 0
        iWaitRet = 0
        tsAbsTmo = {tv_sec = 10422974624 tv_nsec = 6500016}
#4  0x00007f1d6cedadbe in CorUnix::CPalSynchronizationManager::BlockThread (this=0x632e70 pthrCurrent=0x69c140 dwTimeout=4294967295 fAlertable=false fIsSleep=false ptwrWakeupReason=0x7f1cf0f0c6e8 pdwSignaledObject=0x7f1cf0f0c6fc) at /usr/src/debug/coreclr/2.1.401-r0/git/src/pal/src/synchmgr/synchmanager.cpp:302
        palErr = 0
        twrWakeupReason = CorUnix::WaitFailed
        pdwWaitState = 0x68bea0
        dwWaitState = 0
        dwSigObjIdx = 0
        fRaceAlerted = false
        fEarlyDeath = false
#5  0x00007f1d6cee24f2 in CorUnix::InternalWaitForMultipleObjectsEx (pThread=0x69c140 nCount=1 lpHandles=0x7f1d6d3f8b18 &lt;FinalizerThread::MHandles+8&gt; bWaitAll=0 dwMilliseconds=4294967295 bAlertable=0 bPrioritize=0) at /usr/src/debug/coreclr/2.1.401-r0/git/src/pal/src/synchmgr/wait.cpp:636
        twrWakeupReason = 2595471104
        dwRet = 4294967295
        palErr = 0
        i = 1
        iSignaledObjCount = 0
        iSignaledObjIndex = -1
        fWAll = false
        fNeedToBlock = true
        fAbandoned = false
        wtWaitType = CorUnix::SingleObject
        pIPalObjStackArray = {0x65a4c0 0x0 &lt;repeats 15 times&gt;}
        pISyncStackArray = {0x0 &lt;repeats 16 times&gt;}
        ppIPalObjs = 0x7f1cf0f0c780
        ppISyncWaitCtrlrs = 0x7f1cf0f0c700
#6  0x00007f1d6cee28d3 in WaitForMultipleObjectsEx (nCount=1 lpHandles=0x7f1d6d3f8b18 &lt;FinalizerThread::MHandles+8&gt; bWaitAll=0 dwMilliseconds=4294967295 bAlertable=0) at /usr/src/debug/coreclr/2.1.401-r0/git/src/pal/src/synchmgr/wait.cpp:202
        dwRet = 0
        pThread = 0x69c140
#7  0x00007f1d6ca3dcd0 in FinalizerThread::WaitForFinalizerEvent (event=0x691e10) at /usr/src/debug/coreclr/2.1.401-r0/git/src/vm/finalizerthread.cpp:462
        uiEventIndexOffsetForWait = 1
        cEventsForWait = 1
#8  0x00007f1d6ca3de35 in FinalizerThread::FinalizerThreadWorker (args=0x7f1cf0f0ccb8) at /usr/src/debug/coreclr/2.1.401-r0/git/src/vm/finalizerthread.cpp:564
        bPriorityBoosted = 0
#9  0x00007f1d6c9a958c in ManagedThreadBase_DispatchInner (pCallState=0x7f1cf0f0ccb8) at /usr/src/debug/coreclr/2.1.401-r0/git/src/vm/threads.cpp:8850
        pThread = 0x65aba0
#10 0x00007f1d6c9ac87e in ManagedThreadBase_DispatchMiddle (pCallState=0x7f1cf0f0ccb8) at /usr/src/debug/coreclr/2.1.401-r0/git/src/vm/threads.cpp:8901
        cleanup = {m_pEntryFrame = 0x7f1cf0f0cc68 m_pThread = 0x65aba0}
        __autoCleanupTry = {m_refState = @0x7f1cf0f0cac0}
        __state = {&lt;Exception::HandlerState&gt; = {m_dwFlags = 0 m_pExceptionPtr = 0x0} m_pThread = 0x65aba0 m_pFrame = 0x7f1cf0f0cc68 m_fPreemptiveGCDisabled = 1}
        __pExceptionRaw = 0x7f1cf0f0ca90
#11 0x00007f1d6c9ac71d in ManagedThreadBase_DispatchOuter(ManagedThreadCallState*)::$_8::operator()(ManagedThreadBase_DispatchOuter(ManagedThreadCallState*)::TryArgs*) const::{lambda(Param*)#1}::operator()(Param*) const (this=0x7f1cf0f0cb98 pParam=0x7f1cf0f0cc50) at /usr/src/debug/coreclr/2.1.401-r0/git/src/vm/threads.cpp:9139
No locals.
#12 0x00007f1d6c9ac523 in ManagedThreadBase_DispatchOuter(ManagedThreadCallState*)::$_8::operator()(ManagedThreadBase_DispatchOuter(ManagedThreadCallState*)::TryArgs*) const (this=0x7f1cf0f0cc28 pArgs=0x7f1cf0f0cc30) at /usr/src/debug/coreclr/2.1.401-r0/git/src/vm/threads.cpp:9141
        __exceptionHolder = {&lt;NativeExceptionHolderBase&gt; = {_vptr$NativeExceptionHolderBase = 0x7f1d6d39ce88 &lt;vtable for NativeExceptionHolder&lt;ManagedThreadBase_DispatchOuter(ManagedThreadCallState*)::$_8::operator()(ManagedThreadBase_DispatchOuter(ManagedThreadCallState*)::TryArgs*) const::{lambda(PAL_SEHException&amp;)#1}&gt;+16&gt; m_head = 0x7f1ce8000b60 m_next = 0x0} m_exceptionFilter = 0x7f1cf0f0cb80}
        __param = 0x7f1cf0f0cc50
        tryBlock = {&lt;No data fields&gt;}
        isFinally = false
        finallyBlock = {&lt;No data fields&gt;}
        disposition = -1
        exceptionFilter = {disposition = @0x7f1cf0f0cb94 __param = @0x7f1cf0f0cba0}
        ex = @0x65aba0: {static NoTargetFrameSp = 18446744073709551615 ExceptionPointers = {ExceptionRecord = 0x7f1d6d39ce30 &lt;vtable for Thread+16&gt; ContextRecord = 0x21220} TargetFrameSp = 139762278124648 RecordsOnStack = false}
#13 0x00007f1d6c9a9241 in ManagedThreadBase_DispatchOuter (pCallState=0x7f1cf0f0ccb8) at /usr/src/debug/coreclr/2.1.401-r0/git/src/vm/threads.cpp:9178
        __param = 0x7f1cf0f0cc30
        tryBlock = {&lt;No data fields&gt;}
        isFinally = true
        finallyBlock = {fHadException = @0x7f1cf0f0cc2c catchFrame = @0x7f1cf0f0cc60}
        pThread = 0x65aba0
        pFrame = 0xffffffffffffffff
        catchFrame = {m_gsCookie = 7663686 m_frame = {&lt;Frame&gt; = {&lt;FrameBase&gt; = {_vptr$FrameBase = 0x7f1d6d394b08 &lt;vtable for DebuggerU2MCatchHandlerFrame+16&gt;} m_Next = 0xffffffffffffffff} &lt;No data fields&gt;}}
        param = {&lt;NotifyOfCHFFilterWrapperParam&gt; = {pFrame = 0x7f1cf0f0cc68} m_pCallState = 0x7f1cf0f0ccb8}
        args = {pTryParam = 0x7f1cf0f0cc50 pThread = 0x65aba0 pfHadException = 0x7f1cf0f0cc2c pFrame = 0xffffffffffffffff}
        fHadException = 1
#14 0x00007f1d6c9a915c in ManagedThreadBase_NoADTransition (pTarget=0x7f1d6ca3ddd0 &lt;FinalizerThread::FinalizerThreadWorker(void*)&gt; filterType=FinalizerThread) at /usr/src/debug/coreclr/2.1.401-r0/git/src/vm/threads.cpp:9223
        pAppDomain = 0x67dbd0
        CallState = {pAppDomainId = {m_dwId = 0} pUnsafeAppDomain = 0x67dbd0 bDomainIsAsID = 0 pTarget = 0x7f1d6ca3ddd0 &lt;FinalizerThread::FinalizerThreadWorker(void*)&gt; args = 0x7f1cf0f0ccb8 filterType = FinalizerThread flags = MTCSF_NormalBase}
#15 0x00007f1d6c9a947a in ManagedThreadBase::FinalizerBase (pTarget=0x7f1d6ca3ddd0 &lt;FinalizerThread::FinalizerThreadWorker(void*)&gt;) at /usr/src/debug/coreclr/2.1.401-r0/git/src/vm/threads.cpp:9249
No locals.
#16 0x00007f1d6ca3e1d4 in FinalizerThread::FinalizerThreadStart (args=0x0) at /usr/src/debug/coreclr/2.1.401-r0/git/src/vm/finalizerthread.cpp:764
        ex = &lt;error reading variable&gt;
#17 0x00007f1d6c99fd73 in Thread::intermediateThreadProc (arg=0x68be80) at /usr/src/debug/coreclr/2.1.401-r0/git/src/vm/threads.cpp:2254
        param = 0x68be80
        ThreadFcnPtr = 0x7f1d6ca3e130 &lt;FinalizerThread::FinalizerThreadStart(void*)&gt;
        args = 0x0
#18 0x00007f1d6ceebde2 in CorUnix::CPalThread::ThreadEntry (pvParam=0x69c140) at /usr/src/debug/coreclr/2.1.401-r0/git/src/pal/src/thread/thread.cpp:1682
        palError = 0
        pThread = 0x69c140
        pfnStartRoutine = 0x7f1d6c99fce0 &lt;Thread::intermediateThreadProc(void*)&gt;
        pvPar = 0x68be80
        retValue = 0
#19 0x00000037ee607477 in start_thread (arg=0x7f1cf0f0d700) at /usr/src/debug/glibc/2.27-r0/git/nptl/pthread_create.c:463
        pd = 0x7f1cf0f0d700
        now = &lt;optimized out&gt;
        unwind_buf = {cancel_jmp_buf = {{jmp_buf = {139762278127360 -3143376522215987051 140733185703518 140733185703519 8396800 140733185703840 3051639910372173973 -3166127887795525483} mask_was_saved = 0}} priv = {pad = {0x0 0x0 0x0 0x0} data = {prev = 0x0 cleanup = 0x0 canceltype = 0}}}
        not_first_call = &lt;optimized out&gt;
#20 0x00000037ee2f208f in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:95
No locals.

Thread 4 (LWP 21254):
#0  0x00000037ee610f36 in __libc_open64 (file=0x671160 "/tmp/clr-debug-pipe-21252-766367-in" oflag=0) at /usr/src/debug/glibc/2.27-r0/git/sysdeps/unix/sysv/linux/open64.c:47
        resultvar = 18446744073709551104
        sc_cancel_oldtype = 0
        mode = 0
#1  0x00007f1d6cd5ea6a in TwoWayPipe::WaitForConnection (this=0x671150) at /usr/src/debug/coreclr/2.1.401-r0/git/src/debug/debug-pal/unix/twowaypipe.cpp:90
No locals.
#2  0x00007f1d6cd52a40 in DbgTransportSession::TransportWorker (this=0x671070) at /usr/src/debug/coreclr/2.1.401-r0/git/src/debug/ee/../shared/dbgtransportsession.cpp:1320
        pid = 21252
        eStatus = SCS_Success
        sSendHeader = {m_eType = {m_data = 6644544} m_cbDataBlock = {m_data = 0} m_dwId = {m_data = 4063944384} m_dwReplyId = {m_data = 32540} m_dwLastSeenId = {m_data = 1827304880} m_dwReserved = {m_data = 32541} TypeSpecificData = {VersionInfo = {m_dwMajorVersion = {m_data = 4287281663} m_dwMinorVersion = {m_data = 1}} SessionReject = {m_eReason = {m_data = (DbgTransportSession::RR_AlreadyAttached | unknown: 4287281662)} m_dwMajorVersion = {m_data = 1} m_dwMinorVersion = {m_data = 4294967295}} MemoryAccess = {m_pbLeftSideBuffer = {m_data = 0x1ff8ab9ff &lt;error: Cannot access memory at address 0x1ff8ab9ff&gt;} m_cbLeftSideBuffer = {m_data = 4294967295} m_hrResult = {m_data = -1}} Event = {m_eIPCEventType = {m_data = (IPCET_DebugEvent | IPCET_Max | unknown: 4287281660)} m_eType = {m_data = 1}}} m_sMustBeZero = "\002\000\000\000\000\000\000"}
        sReceiveHeader = {m_eType = {m_data = 1833031432} m_cbDataBlock = {m_data = 32541} m_dwId = {m_data = 1833031432} m_dwReplyId = {m_data = 32541} m_dwLastSeenId = {m_data = 6644544} m_dwReserved = {m_data = 0} TypeSpecificData = {VersionInfo = {m_dwMajorVersion = {m_data = 4063944304} m_dwMinorVersion = {m_data = 32540}} SessionReject = {m_eReason = {m_data = (unknown: 4063944304)} m_dwMajorVersion = {m_data = 32540} m_dwMinorVersion = {m_data = 1827301129}} MemoryAccess = {m_pbLeftSideBuffer = {m_data = 0x7f1cf23ade70 "\300\336:\362\034\177"} m_cbLeftSideBuffer = {m_data = 1827301129} m_hrResult = {m_data = 32541}} Event = {m_eIPCEventType = {m_data = (unknown: 4063944304)} m_eType = {m_data = 32540}}} m_sMustBeZero = "@ce\000\000\000\000"}
#3  0x00007f1d6cd511d5 in DbgTransportSession::TransportWorkerStatic (pvContext=0x671070) at /usr/src/debug/coreclr/2.1.401-r0/git/src/debug/ee/../shared/dbgtransportsession.cpp:1236
No locals.
#4  0x00007f1d6ceebde2 in CorUnix::CPalThread::ThreadEntry (pvParam=0x656340) at /usr/src/debug/coreclr/2.1.401-r0/git/src/pal/src/thread/thread.cpp:1682
        palError = 0
        pThread = 0x656340
        pfnStartRoutine = 0x7f1d6cd511c0 &lt;DbgTransportSession::TransportWorkerStatic(void*)&gt;
        pvPar = 0x671070
        retValue = 0
#5  0x00000037ee607477 in start_thread (arg=0x7f1cf23ae700) at /usr/src/debug/glibc/2.27-r0/git/nptl/pthread_create.c:463
        pd = 0x7f1cf23ae700
        now = &lt;optimized out&gt;
        unwind_buf = {cancel_jmp_buf = {{jmp_buf = {139762299758336 -3143376522215987051 140733185702398 140733185702399 8396800 140733185702720 3051645872323651733 -3166127887795525483} mask_was_saved = 0}} priv = {pad = {0x0 0x0 0x0 0x0} data = {prev = 0x0 cleanup = 0x0 canceltype = 0}}}
        not_first_call = &lt;optimized out&gt;
#6  0x00000037ee2f208f in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:95
No locals.

Thread 3 (LWP 21255):
#0  0x00000037ee60d20c in futex_wait_cancelable (private=&lt;optimized out&gt; expected=0 futex_word=0x68ff78) at /usr/src/debug/glibc/2.27-r0/git/sysdeps/unix/sysv/linux/futex-internal.h:88
        __ret = -512
        oldtype = 0
        err = &lt;optimized out&gt;
#1  __pthread_cond_wait_common (abstime=0x0 mutex=0x68ff28 cond=0x68ff50) at /usr/src/debug/glibc/2.27-r0/git/nptl/pthread_cond_wait.c:502
        spin = 0
        buffer = {__routine = 0x37ee60cfc0 &lt;__condvar_cleanup_waiting&gt; __arg = 0x7f1cf1bac8c0 __canceltype = -239417136 __prev = 0x0}
        cbuffer = {wseq = 0 cond = 0x68ff50 mutex = 0x68ff28 private = 0}
        err = &lt;optimized out&gt;
        g = 0
        flags = &lt;optimized out&gt;
        signals = &lt;optimized out&gt;
        result = 0
        seq = 0
#2  __pthread_cond_wait (cond=0x68ff50 mutex=0x68ff28) at /usr/src/debug/glibc/2.27-r0/git/nptl/pthread_cond_wait.c:655
No locals.
#3  0x00007f1d6cedb06f in CorUnix::CPalSynchronizationManager::ThreadNativeWait (ptnwdNativeWaitData=0x68ff28 dwTimeout=4294967295 ptwrWakeupReason=0x7f1cf1bac9fc pdwSignaledObject=0x7f1cf1bac9f8) at /usr/src/debug/coreclr/2.1.401-r0/git/src/pal/src/synchmgr/synchmanager.cpp:479
        palErr = 0
        iRet = 0
        iWaitRet = 0
        tsAbsTmo = {tv_sec = 10422974624 tv_nsec = 6500016}
#4  0x00007f1d6cedadbe in CorUnix::CPalSynchronizationManager::BlockThread (this=0x632e70 pthrCurrent=0x68fcf0 dwTimeout=4294967295 fAlertable=false fIsSleep=false ptwrWakeupReason=0x7f1cf1bacb58 pdwSignaledObject=0x7f1cf1bacb6c) at /usr/src/debug/coreclr/2.1.401-r0/git/src/pal/src/synchmgr/synchmanager.cpp:302
        palErr = 0
        twrWakeupReason = CorUnix::WaitFailed
        pdwWaitState = 0x675960
        dwWaitState = 0
        dwSigObjIdx = 0
        fRaceAlerted = false
        fEarlyDeath = false
#5  0x00007f1d6cee24f2 in CorUnix::InternalWaitForMultipleObjectsEx (pThread=0x68fcf0 nCount=3 lpHandles=0x7f1cf1bacdf0 bWaitAll=0 dwMilliseconds=4294967295 bAlertable=0 bPrioritize=0) at /usr/src/debug/coreclr/2.1.401-r0/git/src/pal/src/synchmgr/wait.cpp:636
        twrWakeupReason = CorUnix::WaitSucceeded
        dwRet = 4294967295
        palErr = 0
        i = 3
        iSignaledObjCount = 0
        iSignaledObjIndex = -1
        fWAll = false
        fNeedToBlock = true
        fAbandoned = false
        wtWaitType = CorUnix::MultipleObjectsWaitOne
        pIPalObjStackArray = {0x67f340 0x68edd0 0x63c9f0 0x0 &lt;repeats 13 times&gt;}
        pISyncStackArray = {0x0 &lt;repeats 16 times&gt;}
        ppIPalObjs = 0x7f1cf1bacbf0
        ppISyncWaitCtrlrs = 0x7f1cf1bacb70
#6  0x00007f1d6cee28d3 in WaitForMultipleObjectsEx (nCount=3 lpHandles=0x7f1cf1bacdf0 bWaitAll=0 dwMilliseconds=4294967295 bAlertable=0) at /usr/src/debug/coreclr/2.1.401-r0/git/src/pal/src/synchmgr/wait.cpp:202
        dwRet = 6566912
        pThread = 0x68fcf0
#7  0x00007f1d6cd4ea0c in DebuggerRCThread::MainLoop (this=0x78c230) at /usr/src/debug/coreclr/2.1.401-r0/git/src/debug/ee/rcthread.cpp:1234
        dwWaitResult = 1825694302
        cantStopHolder = {m_acquired = 1}
        rghWaitSet = {0x48 0x50 0x44 0x7f1d6cd1d98a &lt;BaseHolder&lt;Debugger* FunctionBase&lt;Debugger* &amp;Debugger::AcquireDebuggerLock &amp;Debugger::ReleaseDebuggerLock (HolderStackValidation)2&gt; 0ul &amp;(int CompareDefault&lt;Debugger*&gt;(Debugger* Debugger*)) (HolderStackValidation)2&gt;::Release()+42&gt;}
        cWaitCount = 3
        dwWaitTimeout = 4294967295
        debugLockHolderSuspended = {&lt;BaseHolder&lt;Debugger* FunctionBase&lt;Debugger* &amp;Debugger::AcquireDebuggerLock &amp;Debugger::ReleaseDebuggerLock HSV_ValidateNormalStackReq&gt; 0 &amp;CompareDefault HSV_ValidateNormalStackReq&gt;&gt; = {&lt;FunctionBase&lt;Debugger* &amp;Debugger::AcquireDebuggerLock &amp;Debugger::ReleaseDebuggerLock HSV_ValidateNormalStackReq&gt;&gt; = {&lt;HolderBase&lt;Debugger*&gt;&gt; = {m_value = 0x643400} &lt;No data fields&gt;} m_acquired = 0} &lt;No data fields&gt;}
#8  0x00007f1d6cd4e87c in DebuggerRCThread::ThreadProc (this=0x78c230) at /usr/src/debug/coreclr/2.1.401-r0/git/src/debug/ee/rcthread.cpp:1037
        caHolder = {&lt;No data fields&gt;}
        debugLockHolder = {&lt;BaseHolder&lt;Debugger* FunctionBase&lt;Debugger* &amp;Debugger::AcquireDebuggerLock &amp;Debugger::ReleaseDebuggerLock HSV_ValidateNormalStackReq&gt; 0 &amp;CompareDefault HSV_ValidateNormalStackReq&gt;&gt; = {&lt;FunctionBase&lt;Debugger* &amp;Debugger::AcquireDebuggerLock &amp;Debugger::ReleaseDebuggerLock HSV_ValidateNormalStackReq&gt;&gt; = {&lt;HolderBase&lt;Debugger*&gt;&gt; = {m_value = 0x643400} &lt;No data fields&gt;} m_acquired = 0} &lt;No data fields&gt;}
#9  0x00007f1d6cd4e463 in DebuggerRCThread::ThreadProcStatic () at /usr/src/debug/coreclr/2.1.401-r0/git/src/debug/ee/rcthread.cpp:1633
        fSuccess = 1
        t = 0x78c230
#10 0x00007f1d6ceebde2 in CorUnix::CPalThread::ThreadEntry (pvParam=0x68fcf0) at /usr/src/debug/coreclr/2.1.401-r0/git/src/pal/src/thread/thread.cpp:1682
        palError = 0
        pThread = 0x68fcf0
        pfnStartRoutine = 0x7f1d6cd4e3c0 &lt;DebuggerRCThread::ThreadProcStatic(void*)&gt;
        pvPar = 0x0
        retValue = 0
#11 0x00000037ee607477 in start_thread (arg=0x7f1cf1bad700) at /usr/src/debug/glibc/2.27-r0/git/nptl/pthread_create.c:463
        pd = 0x7f1cf1bad700
        now = &lt;optimized out&gt;
        unwind_buf = {cancel_jmp_buf = {{jmp_buf = {139762291365632 -3143376522215987051 140733185703118 140733185703119 8396800 140733185703440 3051638175205386389 -3166127887795525483} mask_was_saved = 0}} priv = {pad = {0x0 0x0 0x0 0x0} data = {prev = 0x0 cleanup = 0x0 canceltype = 0}}}
        not_first_call = &lt;optimized out&gt;
#12 0x00000037ee2f208f in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:95
No locals.

Thread 2 (LWP 21253):
#0  0x00000037ee2e82b9 in __GI___poll (fds=0x7f1cf2bced30 nfds=1 timeout=-1) at /usr/src/debug/glibc/2.27-r0/git/sysdeps/unix/sysv/linux/poll.c:29
        resultvar = 18446744073709551100
        sc_cancel_oldtype = 0
#1  0x00007f1d6cedd75d in CorUnix::CPalSynchronizationManager::ReadBytesFromProcessPipe (this=0x632e70 iTimeout=-1 pRecvBuf=0x7f1cf2bceda7 "" iBytes=1) at /usr/src/debug/coreclr/2.1.401-r0/git/src/pal/src/synchmgr/synchmanager.cpp:2209
        iErrno = 0
        Poll = {fd = 6 events = 1 revents = 0}
        iRet = -1
        iConsecutiveEintrs = 0
        iBytesRead = 0
        pPos = 0x7f1cf2bceda7 ""
#2  0x00007f1d6cedd282 in CorUnix::CPalSynchronizationManager::ReadCmdFromProcessPipe (this=0x632e70 iPollTimeout=-1 pswcWorkerCmd=0x7f1cf2bceeb4 pshridMarshaledData=0x7f1cf2bceea8 pdwData=0x7f1cf2bceea4) at /usr/src/debug/coreclr/2.1.401-r0/git/src/pal/src/synchmgr/synchmanager.cpp:1987
        iRet = 0
        byVal = 0 '\000'
        swcWorkerCmd = CorUnix::CPalSynchronizationManager::SynchWorkerCmdNop
#3  0x00007f1d6cedcd96 in CorUnix::CPalSynchronizationManager::WorkerThread (pArg=0x632e70) at /usr/src/debug/coreclr/2.1.401-r0/git/src/pal/src/synchmgr/synchmanager.cpp:1690
        lProcessCount = 0
        palErr = 0
        fShuttingDown = false
        fWorkerIsDone = false
        iPollTimeout = -1
        swcCmd = CorUnix::CPalSynchronizationManager::SynchWorkerCmdDelegatedObjectSignaling
        twrWakeUpReason = 4287284239
        shridMarshaledData = 0x657040
        dwData = 0
        pSynchManager = 0x632e70
        pthrWorker = 0x657040
        iRet = 32541
        ptnwdWorkerThreadNativeData = 0xc
#4  0x00007f1d6ceebde2 in CorUnix::CPalThread::ThreadEntry (pvParam=0x657040) at /usr/src/debug/coreclr/2.1.401-r0/git/src/pal/src/thread/thread.cpp:1682
        palError = 0
        pThread = 0x657040
        pfnStartRoutine = 0x7f1d6cedcd30 &lt;CorUnix::CPalSynchronizationManager::WorkerThread(void*)&gt;
        pvPar = 0x632e70
        retValue = 0
#5  0x00000037ee607477 in start_thread (arg=0x7f1cf2bcf700) at /usr/src/debug/glibc/2.27-r0/git/nptl/pthread_create.c:463
        pd = 0x7f1cf2bcf700
        now = &lt;optimized out&gt;
        unwind_buf = {cancel_jmp_buf = {{jmp_buf = {139762308282112 -3143376522215987051 140733185704974 140733185704975 8396800 140733185705296 3051644824888502421 -3166127887795525483} mask_was_saved = 0}} priv = {pad = {0x0 0x0 0x0 0x0} data = {prev = 0x0 cleanup = 0x0 canceltype = 0}}}
        not_first_call = &lt;optimized out&gt;
#6  0x00000037ee2f208f in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:95
No locals.

Thread 1 (LWP 21252):
#0  0x00007f1d6cbd6bea in ECall::GetQCallImpl (pMD=0x7f1cf33028b8) at /usr/src/debug/coreclr/2.1.401-r0/git/src/vm/ecall.cpp:585
        id = 0
        cur = 0x0
#1  0x00007f1d6cbc64ef in NDirect::NDirectLink (pMD=0x7f1cf33028b8) at /usr/src/debug/coreclr/2.1.401-r0/git/src/vm/dllimport.cpp:6310
        pvTarget = 0x0
        errorTracker = {static const_priorityNotFound = 10 static const_priorityAccessDenied = 20 static const_priorityCouldNotLoad = 99999 m_hr = -7693872 m_priorityOfLastError = 32766 m_message = {&lt;SBuffer&gt; = {m_size = 1824498714 m_allocation = 32541 m_flags = 4287273784 {m_buffer = 0x7ffeff8a9b38 "p\311~" m_asStr = 0x7ffeff8a9b38 u&lt;error reading variable&gt;}} static MINIMUM_GUESS = 20 static s_EmptyBuffer = "\000" static s_ACP = 65001 static s_IsANSIMultibyte = 1 static s_defaultLCID = 0x0 static s_Empty = 0x7f1d6d3f2350 &lt;s_EmptySpace&gt;}}
        fSuccess = 32541
        hmod = 0x7ffeff8a99b0
#2  0x00007f1d6cbc6423 in NDirect::GetStubForILStub (pNMD=0x7f1cf33028b8 ppStubMD=0x7ffeff8a9d20 dwStubFlags=0) at /usr/src/debug/coreclr/2.1.401-r0/git/src/vm/dllimport.cpp:5336
        pStub = 139762315046800
#3  0x00007f1d6cbc6944 in GetStubForInteropMethod (pMD=0x7f1cf33028b8 dwStubFlags=0 ppStubMD=0x0) at /usr/src/debug/coreclr/2.1.401-r0/git/src/vm/dllimport.cpp:5476
        pNMD = 0x7f1cf33028b8
        pStub = 0
        pStubMD = 0x7f1cf3302ba8
#4  0x00007f1d6cbf524f in MethodDesc::DoPrestub (this=0x7f1cf33028b8 pDispatchingMT=0x0) at /usr/src/debug/coreclr/2.1.401-r0/git/src/vm/prestub.cpp:1816
        pStub = 0x0
        pCode = 0
        pThread = 0x698cd0
        pMT = 0x7f1cf3302ae8
        fCanBackpatchPrestub = 1
        fEligibleForCallCounting = 0
        pTieredCompilationManager = 0x0
        fEligibleForTieredCompilation = 0
        fWasPromotedToTier1 = 0
        fIsPointingToPrestub = 1
#5  0x00007f1d6cbf4c29 in PreStubWorker (pTransitionBlock=0x7ffeff8aa058 pMD=0x7f1cf33028b8) at /usr/src/debug/coreclr/2.1.401-r0/git/src/vm/prestub.cpp:1548
        pDispatchingMT = 0x0
        __gcHolder = {&lt;GCHolderBase&gt; = {m_Thread = 0x698cd0 m_WasCoop = 1} &lt;No data fields&gt;}
        __pException = 0x7f1ccc105d60
        CURRENT_THREAD = 0x698cd0
        CURRENT_THREAD_AVAILABLE = true
        __pUnCException = 0x0
        __fExceptionCatched = false
        __pThread = 0x698cd0
        __pUnCEntryFrame = 0x7ffeff8a9f68
        CURRENT_THREAD = 0x698cd0
        CURRENT_THREAD_AVAILABLE = true
        frame = {m_gsCookie = 7663686 m_frame = {&lt;FramedMethodFrame&gt; = {&lt;TransitionFrame&gt; = {&lt;Frame&gt; = {&lt;FrameBase&gt; = {_vptr$FrameBase = 0x7f1d6d393a30 &lt;vtable for PrestubMethodFrame+16&gt;} m_Next = 0x7ffeff8aaa08} &lt;No data fields&gt;} m_pTransitionBlock = 140733185695832 m_pMD = 0x7f1cf33028b8} &lt;No data fields&gt;}}
        pPFrame = 0x7ffeff8a9f68
        exCopy = {static NoTargetFrameSp = 18446744073709551615 ExceptionPointers = {ExceptionRecord = 0x0 ContextRecord = 0x0} TargetFrameSp = 18446744073709551615 RecordsOnStack = false}
        __pThread = 0x698cd0
        hasCaughtException = false
        ex = @0x7f1cf3301398: {static NoTargetFrameSp = 18446744073709551615 ExceptionPointers = {ExceptionRecord = 0x1800000200 ContextRecord = 0x1000901f5400e} TargetFrameSp = 139762312623752 RecordsOnStack = 112}
        __dwLastError = 2
        pbRetVal = 0
#6  0x00007f1d6cb2a4f4 in ThePreStub () at /usr/src/debug/coreclr/2.1.401-r0/git/src/vm/assembly.hpp:495
No symbol table info available.
#7  0x00007f1cf3242f41 in ?? ()
No symbol table info available.
#8  0x00007f1cf3242f20 in ?? ()
No symbol table info available.
#9  0x00007f1ccc105cf8 in ?? ()
No symbol table info available.
#10 0x00007f1ccc105860 in ?? ()
No symbol table info available.
#11 0x00007f1ccc105d78 in ?? ()
No symbol table info available.
#12 0x00007ffeff8aa130 in ?? ()
No symbol table info available.
#13 0x00007f1cf3242dff in ?? ()
No symbol table info available.
#14 0x1f5eb6d09ab3bf00 in ?? ()
No symbol table info available.
#15 0x0000000000000000 in ?? ()
No symbol table info available.
warning: RTTI symbol not found for class 'NativeExceptionHolder&lt;ManagedThreadBase_DispatchOuter(ManagedThreadCallState*)::$_8::operator()(ManagedThreadBase_DispatchOuter(ManagedThreadCallState*)::TryArgs*) const::{lambda(PAL_SEHException&amp;)#1}&gt;'
```

I've read in other issues that this can be caused by a mix-match between ```System.Private.CoreLib.dll``` and ```libcoreclr.so``` but I am confident I have deployed both.

Any guidance would be greatly appreciated.</Description>
    <Title_Description>Segfault in ECall::GetQCallImpl on local build. ```
&gt; dotnet console new

Configuring...
--------------
A command is running to populate your local package cache to improve restore speed and enable offline access. This command takes up to one minute to complete and only runs once.
Decompressing 100% 7085 ms
Segmentation fault (core dumped)
```

Some information about my build:

* I need to remove lttng-ust from the coreclr (because of #15693) so I am compiling it with ```-DFEATURE_EVENT_TRACE=0```
* I am using tag ```v2.1.3``` with some minor patches for cross-compilation (see them [here](https://github.com/qmlnet/coreclr/commits/yocto-v2.1.401)).


```
Thread 5 (LWP 21256):
#0  0x00000037ee60d20c in futex_wait_cancelable (private=&lt;optimized out&gt; expected=0 futex_word=0x69c3c8) at /usr/src/debug/glibc/2.27-r0/git/sysdeps/unix/sysv/linux/futex-internal.h:88
        __ret = -512
        oldtype = 0
        err = &lt;optimized out&gt;
#1  __pthread_cond_wait_common (abstime=0x0 mutex=0x69c378 cond=0x69c3a0) at /usr/src/debug/glibc/2.27-r0/git/nptl/pthread_cond_wait.c:502
        spin = 0
        buffer = {__routine = 0x37ee60cfc0 &lt;__condvar_cleanup_waiting&gt; __arg = 0x7f1cf0f0c450 __canceltype = -252656544 __prev = 0x0}
        cbuffer = {wseq = 2 cond = 0x69c3a0 mutex = 0x69c378 private = 0}
        err = &lt;optimized out&gt;
        g = 0
        flags = &lt;optimized out&gt;
        signals = &lt;optimized out&gt;
        result = 0
        seq = 1
#2  __pthread_cond_wait (cond=0x69c3a0 mutex=0x69c378) at /usr/src/debug/glibc/2.27-r0/git/nptl/pthread_cond_wait.c:655
No locals.
#3  0x00007f1d6cedb06f in CorUnix::CPalSynchronizationManager::ThreadNativeWait (ptnwdNativeWaitData=0x69c378 dwTimeout=4294967295 ptwrWakeupReason=0x7f1cf0f0c58c pdwSignaledObject=0x7f1cf0f0c588) at /usr/src/debug/coreclr/2.1.401-r0/git/src/pal/src/synchmgr/synchmanager.cpp:479
        palErr = 0
        iRet = 0
        iWaitRet = 0
        tsAbsTmo = {tv_sec = 10422974624 tv_nsec = 6500016}
#4  0x00007f1d6cedadbe in CorUnix::CPalSynchronizationManager::BlockThread (this=0x632e70 pthrCurrent=0x69c140 dwTimeout=4294967295 fAlertable=false fIsSleep=false ptwrWakeupReason=0x7f1cf0f0c6e8 pdwSignaledObject=0x7f1cf0f0c6fc) at /usr/src/debug/coreclr/2.1.401-r0/git/src/pal/src/synchmgr/synchmanager.cpp:302
        palErr = 0
        twrWakeupReason = CorUnix::WaitFailed
        pdwWaitState = 0x68bea0
        dwWaitState = 0
        dwSigObjIdx = 0
        fRaceAlerted = false
        fEarlyDeath = false
#5  0x00007f1d6cee24f2 in CorUnix::InternalWaitForMultipleObjectsEx (pThread=0x69c140 nCount=1 lpHandles=0x7f1d6d3f8b18 &lt;FinalizerThread::MHandles+8&gt; bWaitAll=0 dwMilliseconds=4294967295 bAlertable=0 bPrioritize=0) at /usr/src/debug/coreclr/2.1.401-r0/git/src/pal/src/synchmgr/wait.cpp:636
        twrWakeupReason = 2595471104
        dwRet = 4294967295
        palErr = 0
        i = 1
        iSignaledObjCount = 0
        iSignaledObjIndex = -1
        fWAll = false
        fNeedToBlock = true
        fAbandoned = false
        wtWaitType = CorUnix::SingleObject
        pIPalObjStackArray = {0x65a4c0 0x0 &lt;repeats 15 times&gt;}
        pISyncStackArray = {0x0 &lt;repeats 16 times&gt;}
        ppIPalObjs = 0x7f1cf0f0c780
        ppISyncWaitCtrlrs = 0x7f1cf0f0c700
#6  0x00007f1d6cee28d3 in WaitForMultipleObjectsEx (nCount=1 lpHandles=0x7f1d6d3f8b18 &lt;FinalizerThread::MHandles+8&gt; bWaitAll=0 dwMilliseconds=4294967295 bAlertable=0) at /usr/src/debug/coreclr/2.1.401-r0/git/src/pal/src/synchmgr/wait.cpp:202
        dwRet = 0
        pThread = 0x69c140
#7  0x00007f1d6ca3dcd0 in FinalizerThread::WaitForFinalizerEvent (event=0x691e10) at /usr/src/debug/coreclr/2.1.401-r0/git/src/vm/finalizerthread.cpp:462
        uiEventIndexOffsetForWait = 1
        cEventsForWait = 1
#8  0x00007f1d6ca3de35 in FinalizerThread::FinalizerThreadWorker (args=0x7f1cf0f0ccb8) at /usr/src/debug/coreclr/2.1.401-r0/git/src/vm/finalizerthread.cpp:564
        bPriorityBoosted = 0
#9  0x00007f1d6c9a958c in ManagedThreadBase_DispatchInner (pCallState=0x7f1cf0f0ccb8) at /usr/src/debug/coreclr/2.1.401-r0/git/src/vm/threads.cpp:8850
        pThread = 0x65aba0
#10 0x00007f1d6c9ac87e in ManagedThreadBase_DispatchMiddle (pCallState=0x7f1cf0f0ccb8) at /usr/src/debug/coreclr/2.1.401-r0/git/src/vm/threads.cpp:8901
        cleanup = {m_pEntryFrame = 0x7f1cf0f0cc68 m_pThread = 0x65aba0}
        __autoCleanupTry = {m_refState = @0x7f1cf0f0cac0}
        __state = {&lt;Exception::HandlerState&gt; = {m_dwFlags = 0 m_pExceptionPtr = 0x0} m_pThread = 0x65aba0 m_pFrame = 0x7f1cf0f0cc68 m_fPreemptiveGCDisabled = 1}
        __pExceptionRaw = 0x7f1cf0f0ca90
#11 0x00007f1d6c9ac71d in ManagedThreadBase_DispatchOuter(ManagedThreadCallState*)::$_8::operator()(ManagedThreadBase_DispatchOuter(ManagedThreadCallState*)::TryArgs*) const::{lambda(Param*)#1}::operator()(Param*) const (this=0x7f1cf0f0cb98 pParam=0x7f1cf0f0cc50) at /usr/src/debug/coreclr/2.1.401-r0/git/src/vm/threads.cpp:9139
No locals.
#12 0x00007f1d6c9ac523 in ManagedThreadBase_DispatchOuter(ManagedThreadCallState*)::$_8::operator()(ManagedThreadBase_DispatchOuter(ManagedThreadCallState*)::TryArgs*) const (this=0x7f1cf0f0cc28 pArgs=0x7f1cf0f0cc30) at /usr/src/debug/coreclr/2.1.401-r0/git/src/vm/threads.cpp:9141
        __exceptionHolder = {&lt;NativeExceptionHolderBase&gt; = {_vptr$NativeExceptionHolderBase = 0x7f1d6d39ce88 &lt;vtable for NativeExceptionHolder&lt;ManagedThreadBase_DispatchOuter(ManagedThreadCallState*)::$_8::operator()(ManagedThreadBase_DispatchOuter(ManagedThreadCallState*)::TryArgs*) const::{lambda(PAL_SEHException&amp;)#1}&gt;+16&gt; m_head = 0x7f1ce8000b60 m_next = 0x0} m_exceptionFilter = 0x7f1cf0f0cb80}
        __param = 0x7f1cf0f0cc50
        tryBlock = {&lt;No data fields&gt;}
        isFinally = false
        finallyBlock = {&lt;No data fields&gt;}
        disposition = -1
        exceptionFilter = {disposition = @0x7f1cf0f0cb94 __param = @0x7f1cf0f0cba0}
        ex = @0x65aba0: {static NoTargetFrameSp = 18446744073709551615 ExceptionPointers = {ExceptionRecord = 0x7f1d6d39ce30 &lt;vtable for Thread+16&gt; ContextRecord = 0x21220} TargetFrameSp = 139762278124648 RecordsOnStack = false}
#13 0x00007f1d6c9a9241 in ManagedThreadBase_DispatchOuter (pCallState=0x7f1cf0f0ccb8) at /usr/src/debug/coreclr/2.1.401-r0/git/src/vm/threads.cpp:9178
        __param = 0x7f1cf0f0cc30
        tryBlock = {&lt;No data fields&gt;}
        isFinally = true
        finallyBlock = {fHadException = @0x7f1cf0f0cc2c catchFrame = @0x7f1cf0f0cc60}
        pThread = 0x65aba0
        pFrame = 0xffffffffffffffff
        catchFrame = {m_gsCookie = 7663686 m_frame = {&lt;Frame&gt; = {&lt;FrameBase&gt; = {_vptr$FrameBase = 0x7f1d6d394b08 &lt;vtable for DebuggerU2MCatchHandlerFrame+16&gt;} m_Next = 0xffffffffffffffff} &lt;No data fields&gt;}}
        param = {&lt;NotifyOfCHFFilterWrapperParam&gt; = {pFrame = 0x7f1cf0f0cc68} m_pCallState = 0x7f1cf0f0ccb8}
        args = {pTryParam = 0x7f1cf0f0cc50 pThread = 0x65aba0 pfHadException = 0x7f1cf0f0cc2c pFrame = 0xffffffffffffffff}
        fHadException = 1
#14 0x00007f1d6c9a915c in ManagedThreadBase_NoADTransition (pTarget=0x7f1d6ca3ddd0 &lt;FinalizerThread::FinalizerThreadWorker(void*)&gt; filterType=FinalizerThread) at /usr/src/debug/coreclr/2.1.401-r0/git/src/vm/threads.cpp:9223
        pAppDomain = 0x67dbd0
        CallState = {pAppDomainId = {m_dwId = 0} pUnsafeAppDomain = 0x67dbd0 bDomainIsAsID = 0 pTarget = 0x7f1d6ca3ddd0 &lt;FinalizerThread::FinalizerThreadWorker(void*)&gt; args = 0x7f1cf0f0ccb8 filterType = FinalizerThread flags = MTCSF_NormalBase}
#15 0x00007f1d6c9a947a in ManagedThreadBase::FinalizerBase (pTarget=0x7f1d6ca3ddd0 &lt;FinalizerThread::FinalizerThreadWorker(void*)&gt;) at /usr/src/debug/coreclr/2.1.401-r0/git/src/vm/threads.cpp:9249
No locals.
#16 0x00007f1d6ca3e1d4 in FinalizerThread::FinalizerThreadStart (args=0x0) at /usr/src/debug/coreclr/2.1.401-r0/git/src/vm/finalizerthread.cpp:764
        ex = &lt;error reading variable&gt;
#17 0x00007f1d6c99fd73 in Thread::intermediateThreadProc (arg=0x68be80) at /usr/src/debug/coreclr/2.1.401-r0/git/src/vm/threads.cpp:2254
        param = 0x68be80
        ThreadFcnPtr = 0x7f1d6ca3e130 &lt;FinalizerThread::FinalizerThreadStart(void*)&gt;
        args = 0x0
#18 0x00007f1d6ceebde2 in CorUnix::CPalThread::ThreadEntry (pvParam=0x69c140) at /usr/src/debug/coreclr/2.1.401-r0/git/src/pal/src/thread/thread.cpp:1682
        palError = 0
        pThread = 0x69c140
        pfnStartRoutine = 0x7f1d6c99fce0 &lt;Thread::intermediateThreadProc(void*)&gt;
        pvPar = 0x68be80
        retValue = 0
#19 0x00000037ee607477 in start_thread (arg=0x7f1cf0f0d700) at /usr/src/debug/glibc/2.27-r0/git/nptl/pthread_create.c:463
        pd = 0x7f1cf0f0d700
        now = &lt;optimized out&gt;
        unwind_buf = {cancel_jmp_buf = {{jmp_buf = {139762278127360 -3143376522215987051 140733185703518 140733185703519 8396800 140733185703840 3051639910372173973 -3166127887795525483} mask_was_saved = 0}} priv = {pad = {0x0 0x0 0x0 0x0} data = {prev = 0x0 cleanup = 0x0 canceltype = 0}}}
        not_first_call = &lt;optimized out&gt;
#20 0x00000037ee2f208f in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:95
No locals.

Thread 4 (LWP 21254):
#0  0x00000037ee610f36 in __libc_open64 (file=0x671160 "/tmp/clr-debug-pipe-21252-766367-in" oflag=0) at /usr/src/debug/glibc/2.27-r0/git/sysdeps/unix/sysv/linux/open64.c:47
        resultvar = 18446744073709551104
        sc_cancel_oldtype = 0
        mode = 0
#1  0x00007f1d6cd5ea6a in TwoWayPipe::WaitForConnection (this=0x671150) at /usr/src/debug/coreclr/2.1.401-r0/git/src/debug/debug-pal/unix/twowaypipe.cpp:90
No locals.
#2  0x00007f1d6cd52a40 in DbgTransportSession::TransportWorker (this=0x671070) at /usr/src/debug/coreclr/2.1.401-r0/git/src/debug/ee/../shared/dbgtransportsession.cpp:1320
        pid = 21252
        eStatus = SCS_Success
        sSendHeader = {m_eType = {m_data = 6644544} m_cbDataBlock = {m_data = 0} m_dwId = {m_data = 4063944384} m_dwReplyId = {m_data = 32540} m_dwLastSeenId = {m_data = 1827304880} m_dwReserved = {m_data = 32541} TypeSpecificData = {VersionInfo = {m_dwMajorVersion = {m_data = 4287281663} m_dwMinorVersion = {m_data = 1}} SessionReject = {m_eReason = {m_data = (DbgTransportSession::RR_AlreadyAttached | unknown: 4287281662)} m_dwMajorVersion = {m_data = 1} m_dwMinorVersion = {m_data = 4294967295}} MemoryAccess = {m_pbLeftSideBuffer = {m_data = 0x1ff8ab9ff &lt;error: Cannot access memory at address 0x1ff8ab9ff&gt;} m_cbLeftSideBuffer = {m_data = 4294967295} m_hrResult = {m_data = -1}} Event = {m_eIPCEventType = {m_data = (IPCET_DebugEvent | IPCET_Max | unknown: 4287281660)} m_eType = {m_data = 1}}} m_sMustBeZero = "\002\000\000\000\000\000\000"}
        sReceiveHeader = {m_eType = {m_data = 1833031432} m_cbDataBlock = {m_data = 32541} m_dwId = {m_data = 1833031432} m_dwReplyId = {m_data = 32541} m_dwLastSeenId = {m_data = 6644544} m_dwReserved = {m_data = 0} TypeSpecificData = {VersionInfo = {m_dwMajorVersion = {m_data = 4063944304} m_dwMinorVersion = {m_data = 32540}} SessionReject = {m_eReason = {m_data = (unknown: 4063944304)} m_dwMajorVersion = {m_data = 32540} m_dwMinorVersion = {m_data = 1827301129}} MemoryAccess = {m_pbLeftSideBuffer = {m_data = 0x7f1cf23ade70 "\300\336:\362\034\177"} m_cbLeftSideBuffer = {m_data = 1827301129} m_hrResult = {m_data = 32541}} Event = {m_eIPCEventType = {m_data = (unknown: 4063944304)} m_eType = {m_data = 32540}}} m_sMustBeZero = "@ce\000\000\000\000"}
#3  0x00007f1d6cd511d5 in DbgTransportSession::TransportWorkerStatic (pvContext=0x671070) at /usr/src/debug/coreclr/2.1.401-r0/git/src/debug/ee/../shared/dbgtransportsession.cpp:1236
No locals.
#4  0x00007f1d6ceebde2 in CorUnix::CPalThread::ThreadEntry (pvParam=0x656340) at /usr/src/debug/coreclr/2.1.401-r0/git/src/pal/src/thread/thread.cpp:1682
        palError = 0
        pThread = 0x656340
        pfnStartRoutine = 0x7f1d6cd511c0 &lt;DbgTransportSession::TransportWorkerStatic(void*)&gt;
        pvPar = 0x671070
        retValue = 0
#5  0x00000037ee607477 in start_thread (arg=0x7f1cf23ae700) at /usr/src/debug/glibc/2.27-r0/git/nptl/pthread_create.c:463
        pd = 0x7f1cf23ae700
        now = &lt;optimized out&gt;
        unwind_buf = {cancel_jmp_buf = {{jmp_buf = {139762299758336 -3143376522215987051 140733185702398 140733185702399 8396800 140733185702720 3051645872323651733 -3166127887795525483} mask_was_saved = 0}} priv = {pad = {0x0 0x0 0x0 0x0} data = {prev = 0x0 cleanup = 0x0 canceltype = 0}}}
        not_first_call = &lt;optimized out&gt;
#6  0x00000037ee2f208f in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:95
No locals.

Thread 3 (LWP 21255):
#0  0x00000037ee60d20c in futex_wait_cancelable (private=&lt;optimized out&gt; expected=0 futex_word=0x68ff78) at /usr/src/debug/glibc/2.27-r0/git/sysdeps/unix/sysv/linux/futex-internal.h:88
        __ret = -512
        oldtype = 0
        err = &lt;optimized out&gt;
#1  __pthread_cond_wait_common (abstime=0x0 mutex=0x68ff28 cond=0x68ff50) at /usr/src/debug/glibc/2.27-r0/git/nptl/pthread_cond_wait.c:502
        spin = 0
        buffer = {__routine = 0x37ee60cfc0 &lt;__condvar_cleanup_waiting&gt; __arg = 0x7f1cf1bac8c0 __canceltype = -239417136 __prev = 0x0}
        cbuffer = {wseq = 0 cond = 0x68ff50 mutex = 0x68ff28 private = 0}
        err = &lt;optimized out&gt;
        g = 0
        flags = &lt;optimized out&gt;
        signals = &lt;optimized out&gt;
        result = 0
        seq = 0
#2  __pthread_cond_wait (cond=0x68ff50 mutex=0x68ff28) at /usr/src/debug/glibc/2.27-r0/git/nptl/pthread_cond_wait.c:655
No locals.
#3  0x00007f1d6cedb06f in CorUnix::CPalSynchronizationManager::ThreadNativeWait (ptnwdNativeWaitData=0x68ff28 dwTimeout=4294967295 ptwrWakeupReason=0x7f1cf1bac9fc pdwSignaledObject=0x7f1cf1bac9f8) at /usr/src/debug/coreclr/2.1.401-r0/git/src/pal/src/synchmgr/synchmanager.cpp:479
        palErr = 0
        iRet = 0
        iWaitRet = 0
        tsAbsTmo = {tv_sec = 10422974624 tv_nsec = 6500016}
#4  0x00007f1d6cedadbe in CorUnix::CPalSynchronizationManager::BlockThread (this=0x632e70 pthrCurrent=0x68fcf0 dwTimeout=4294967295 fAlertable=false fIsSleep=false ptwrWakeupReason=0x7f1cf1bacb58 pdwSignaledObject=0x7f1cf1bacb6c) at /usr/src/debug/coreclr/2.1.401-r0/git/src/pal/src/synchmgr/synchmanager.cpp:302
        palErr = 0
        twrWakeupReason = CorUnix::WaitFailed
        pdwWaitState = 0x675960
        dwWaitState = 0
        dwSigObjIdx = 0
        fRaceAlerted = false
        fEarlyDeath = false
#5  0x00007f1d6cee24f2 in CorUnix::InternalWaitForMultipleObjectsEx (pThread=0x68fcf0 nCount=3 lpHandles=0x7f1cf1bacdf0 bWaitAll=0 dwMilliseconds=4294967295 bAlertable=0 bPrioritize=0) at /usr/src/debug/coreclr/2.1.401-r0/git/src/pal/src/synchmgr/wait.cpp:636
        twrWakeupReason = CorUnix::WaitSucceeded
        dwRet = 4294967295
        palErr = 0
        i = 3
        iSignaledObjCount = 0
        iSignaledObjIndex = -1
        fWAll = false
        fNeedToBlock = true
        fAbandoned = false
        wtWaitType = CorUnix::MultipleObjectsWaitOne
        pIPalObjStackArray = {0x67f340 0x68edd0 0x63c9f0 0x0 &lt;repeats 13 times&gt;}
        pISyncStackArray = {0x0 &lt;repeats 16 times&gt;}
        ppIPalObjs = 0x7f1cf1bacbf0
        ppISyncWaitCtrlrs = 0x7f1cf1bacb70
#6  0x00007f1d6cee28d3 in WaitForMultipleObjectsEx (nCount=3 lpHandles=0x7f1cf1bacdf0 bWaitAll=0 dwMilliseconds=4294967295 bAlertable=0) at /usr/src/debug/coreclr/2.1.401-r0/git/src/pal/src/synchmgr/wait.cpp:202
        dwRet = 6566912
        pThread = 0x68fcf0
#7  0x00007f1d6cd4ea0c in DebuggerRCThread::MainLoop (this=0x78c230) at /usr/src/debug/coreclr/2.1.401-r0/git/src/debug/ee/rcthread.cpp:1234
        dwWaitResult = 1825694302
        cantStopHolder = {m_acquired = 1}
        rghWaitSet = {0x48 0x50 0x44 0x7f1d6cd1d98a &lt;BaseHolder&lt;Debugger* FunctionBase&lt;Debugger* &amp;Debugger::AcquireDebuggerLock &amp;Debugger::ReleaseDebuggerLock (HolderStackValidation)2&gt; 0ul &amp;(int CompareDefault&lt;Debugger*&gt;(Debugger* Debugger*)) (HolderStackValidation)2&gt;::Release()+42&gt;}
        cWaitCount = 3
        dwWaitTimeout = 4294967295
        debugLockHolderSuspended = {&lt;BaseHolder&lt;Debugger* FunctionBase&lt;Debugger* &amp;Debugger::AcquireDebuggerLock &amp;Debugger::ReleaseDebuggerLock HSV_ValidateNormalStackReq&gt; 0 &amp;CompareDefault HSV_ValidateNormalStackReq&gt;&gt; = {&lt;FunctionBase&lt;Debugger* &amp;Debugger::AcquireDebuggerLock &amp;Debugger::ReleaseDebuggerLock HSV_ValidateNormalStackReq&gt;&gt; = {&lt;HolderBase&lt;Debugger*&gt;&gt; = {m_value = 0x643400} &lt;No data fields&gt;} m_acquired = 0} &lt;No data fields&gt;}
#8  0x00007f1d6cd4e87c in DebuggerRCThread::ThreadProc (this=0x78c230) at /usr/src/debug/coreclr/2.1.401-r0/git/src/debug/ee/rcthread.cpp:1037
        caHolder = {&lt;No data fields&gt;}
        debugLockHolder = {&lt;BaseHolder&lt;Debugger* FunctionBase&lt;Debugger* &amp;Debugger::AcquireDebuggerLock &amp;Debugger::ReleaseDebuggerLock HSV_ValidateNormalStackReq&gt; 0 &amp;CompareDefault HSV_ValidateNormalStackReq&gt;&gt; = {&lt;FunctionBase&lt;Debugger* &amp;Debugger::AcquireDebuggerLock &amp;Debugger::ReleaseDebuggerLock HSV_ValidateNormalStackReq&gt;&gt; = {&lt;HolderBase&lt;Debugger*&gt;&gt; = {m_value = 0x643400} &lt;No data fields&gt;} m_acquired = 0} &lt;No data fields&gt;}
#9  0x00007f1d6cd4e463 in DebuggerRCThread::ThreadProcStatic () at /usr/src/debug/coreclr/2.1.401-r0/git/src/debug/ee/rcthread.cpp:1633
        fSuccess = 1
        t = 0x78c230
#10 0x00007f1d6ceebde2 in CorUnix::CPalThread::ThreadEntry (pvParam=0x68fcf0) at /usr/src/debug/coreclr/2.1.401-r0/git/src/pal/src/thread/thread.cpp:1682
        palError = 0
        pThread = 0x68fcf0
        pfnStartRoutine = 0x7f1d6cd4e3c0 &lt;DebuggerRCThread::ThreadProcStatic(void*)&gt;
        pvPar = 0x0
        retValue = 0
#11 0x00000037ee607477 in start_thread (arg=0x7f1cf1bad700) at /usr/src/debug/glibc/2.27-r0/git/nptl/pthread_create.c:463
        pd = 0x7f1cf1bad700
        now = &lt;optimized out&gt;
        unwind_buf = {cancel_jmp_buf = {{jmp_buf = {139762291365632 -3143376522215987051 140733185703118 140733185703119 8396800 140733185703440 3051638175205386389 -3166127887795525483} mask_was_saved = 0}} priv = {pad = {0x0 0x0 0x0 0x0} data = {prev = 0x0 cleanup = 0x0 canceltype = 0}}}
        not_first_call = &lt;optimized out&gt;
#12 0x00000037ee2f208f in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:95
No locals.

Thread 2 (LWP 21253):
#0  0x00000037ee2e82b9 in __GI___poll (fds=0x7f1cf2bced30 nfds=1 timeout=-1) at /usr/src/debug/glibc/2.27-r0/git/sysdeps/unix/sysv/linux/poll.c:29
        resultvar = 18446744073709551100
        sc_cancel_oldtype = 0
#1  0x00007f1d6cedd75d in CorUnix::CPalSynchronizationManager::ReadBytesFromProcessPipe (this=0x632e70 iTimeout=-1 pRecvBuf=0x7f1cf2bceda7 "" iBytes=1) at /usr/src/debug/coreclr/2.1.401-r0/git/src/pal/src/synchmgr/synchmanager.cpp:2209
        iErrno = 0
        Poll = {fd = 6 events = 1 revents = 0}
        iRet = -1
        iConsecutiveEintrs = 0
        iBytesRead = 0
        pPos = 0x7f1cf2bceda7 ""
#2  0x00007f1d6cedd282 in CorUnix::CPalSynchronizationManager::ReadCmdFromProcessPipe (this=0x632e70 iPollTimeout=-1 pswcWorkerCmd=0x7f1cf2bceeb4 pshridMarshaledData=0x7f1cf2bceea8 pdwData=0x7f1cf2bceea4) at /usr/src/debug/coreclr/2.1.401-r0/git/src/pal/src/synchmgr/synchmanager.cpp:1987
        iRet = 0
        byVal = 0 '\000'
        swcWorkerCmd = CorUnix::CPalSynchronizationManager::SynchWorkerCmdNop
#3  0x00007f1d6cedcd96 in CorUnix::CPalSynchronizationManager::WorkerThread (pArg=0x632e70) at /usr/src/debug/coreclr/2.1.401-r0/git/src/pal/src/synchmgr/synchmanager.cpp:1690
        lProcessCount = 0
        palErr = 0
        fShuttingDown = false
        fWorkerIsDone = false
        iPollTimeout = -1
        swcCmd = CorUnix::CPalSynchronizationManager::SynchWorkerCmdDelegatedObjectSignaling
        twrWakeUpReason = 4287284239
        shridMarshaledData = 0x657040
        dwData = 0
        pSynchManager = 0x632e70
        pthrWorker = 0x657040
        iRet = 32541
        ptnwdWorkerThreadNativeData = 0xc
#4  0x00007f1d6ceebde2 in CorUnix::CPalThread::ThreadEntry (pvParam=0x657040) at /usr/src/debug/coreclr/2.1.401-r0/git/src/pal/src/thread/thread.cpp:1682
        palError = 0
        pThread = 0x657040
        pfnStartRoutine = 0x7f1d6cedcd30 &lt;CorUnix::CPalSynchronizationManager::WorkerThread(void*)&gt;
        pvPar = 0x632e70
        retValue = 0
#5  0x00000037ee607477 in start_thread (arg=0x7f1cf2bcf700) at /usr/src/debug/glibc/2.27-r0/git/nptl/pthread_create.c:463
        pd = 0x7f1cf2bcf700
        now = &lt;optimized out&gt;
        unwind_buf = {cancel_jmp_buf = {{jmp_buf = {139762308282112 -3143376522215987051 140733185704974 140733185704975 8396800 140733185705296 3051644824888502421 -3166127887795525483} mask_was_saved = 0}} priv = {pad = {0x0 0x0 0x0 0x0} data = {prev = 0x0 cleanup = 0x0 canceltype = 0}}}
        not_first_call = &lt;optimized out&gt;
#6  0x00000037ee2f208f in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:95
No locals.

Thread 1 (LWP 21252):
#0  0x00007f1d6cbd6bea in ECall::GetQCallImpl (pMD=0x7f1cf33028b8) at /usr/src/debug/coreclr/2.1.401-r0/git/src/vm/ecall.cpp:585
        id = 0
        cur = 0x0
#1  0x00007f1d6cbc64ef in NDirect::NDirectLink (pMD=0x7f1cf33028b8) at /usr/src/debug/coreclr/2.1.401-r0/git/src/vm/dllimport.cpp:6310
        pvTarget = 0x0
        errorTracker = {static const_priorityNotFound = 10 static const_priorityAccessDenied = 20 static const_priorityCouldNotLoad = 99999 m_hr = -7693872 m_priorityOfLastError = 32766 m_message = {&lt;SBuffer&gt; = {m_size = 1824498714 m_allocation = 32541 m_flags = 4287273784 {m_buffer = 0x7ffeff8a9b38 "p\311~" m_asStr = 0x7ffeff8a9b38 u&lt;error reading variable&gt;}} static MINIMUM_GUESS = 20 static s_EmptyBuffer = "\000" static s_ACP = 65001 static s_IsANSIMultibyte = 1 static s_defaultLCID = 0x0 static s_Empty = 0x7f1d6d3f2350 &lt;s_EmptySpace&gt;}}
        fSuccess = 32541
        hmod = 0x7ffeff8a99b0
#2  0x00007f1d6cbc6423 in NDirect::GetStubForILStub (pNMD=0x7f1cf33028b8 ppStubMD=0x7ffeff8a9d20 dwStubFlags=0) at /usr/src/debug/coreclr/2.1.401-r0/git/src/vm/dllimport.cpp:5336
        pStub = 139762315046800
#3  0x00007f1d6cbc6944 in GetStubForInteropMethod (pMD=0x7f1cf33028b8 dwStubFlags=0 ppStubMD=0x0) at /usr/src/debug/coreclr/2.1.401-r0/git/src/vm/dllimport.cpp:5476
        pNMD = 0x7f1cf33028b8
        pStub = 0
        pStubMD = 0x7f1cf3302ba8
#4  0x00007f1d6cbf524f in MethodDesc::DoPrestub (this=0x7f1cf33028b8 pDispatchingMT=0x0) at /usr/src/debug/coreclr/2.1.401-r0/git/src/vm/prestub.cpp:1816
        pStub = 0x0
        pCode = 0
        pThread = 0x698cd0
        pMT = 0x7f1cf3302ae8
        fCanBackpatchPrestub = 1
        fEligibleForCallCounting = 0
        pTieredCompilationManager = 0x0
        fEligibleForTieredCompilation = 0
        fWasPromotedToTier1 = 0
        fIsPointingToPrestub = 1
#5  0x00007f1d6cbf4c29 in PreStubWorker (pTransitionBlock=0x7ffeff8aa058 pMD=0x7f1cf33028b8) at /usr/src/debug/coreclr/2.1.401-r0/git/src/vm/prestub.cpp:1548
        pDispatchingMT = 0x0
        __gcHolder = {&lt;GCHolderBase&gt; = {m_Thread = 0x698cd0 m_WasCoop = 1} &lt;No data fields&gt;}
        __pException = 0x7f1ccc105d60
        CURRENT_THREAD = 0x698cd0
        CURRENT_THREAD_AVAILABLE = true
        __pUnCException = 0x0
        __fExceptionCatched = false
        __pThread = 0x698cd0
        __pUnCEntryFrame = 0x7ffeff8a9f68
        CURRENT_THREAD = 0x698cd0
        CURRENT_THREAD_AVAILABLE = true
        frame = {m_gsCookie = 7663686 m_frame = {&lt;FramedMethodFrame&gt; = {&lt;TransitionFrame&gt; = {&lt;Frame&gt; = {&lt;FrameBase&gt; = {_vptr$FrameBase = 0x7f1d6d393a30 &lt;vtable for PrestubMethodFrame+16&gt;} m_Next = 0x7ffeff8aaa08} &lt;No data fields&gt;} m_pTransitionBlock = 140733185695832 m_pMD = 0x7f1cf33028b8} &lt;No data fields&gt;}}
        pPFrame = 0x7ffeff8a9f68
        exCopy = {static NoTargetFrameSp = 18446744073709551615 ExceptionPointers = {ExceptionRecord = 0x0 ContextRecord = 0x0} TargetFrameSp = 18446744073709551615 RecordsOnStack = false}
        __pThread = 0x698cd0
        hasCaughtException = false
        ex = @0x7f1cf3301398: {static NoTargetFrameSp = 18446744073709551615 ExceptionPointers = {ExceptionRecord = 0x1800000200 ContextRecord = 0x1000901f5400e} TargetFrameSp = 139762312623752 RecordsOnStack = 112}
        __dwLastError = 2
        pbRetVal = 0
#6  0x00007f1d6cb2a4f4 in ThePreStub () at /usr/src/debug/coreclr/2.1.401-r0/git/src/vm/assembly.hpp:495
No symbol table info available.
#7  0x00007f1cf3242f41 in ?? ()
No symbol table info available.
#8  0x00007f1cf3242f20 in ?? ()
No symbol table info available.
#9  0x00007f1ccc105cf8 in ?? ()
No symbol table info available.
#10 0x00007f1ccc105860 in ?? ()
No symbol table info available.
#11 0x00007f1ccc105d78 in ?? ()
No symbol table info available.
#12 0x00007ffeff8aa130 in ?? ()
No symbol table info available.
#13 0x00007f1cf3242dff in ?? ()
No symbol table info available.
#14 0x1f5eb6d09ab3bf00 in ?? ()
No symbol table info available.
#15 0x0000000000000000 in ?? ()
No symbol table info available.
warning: RTTI symbol not found for class 'NativeExceptionHolder&lt;ManagedThreadBase_DispatchOuter(ManagedThreadCallState*)::$_8::operator()(ManagedThreadBase_DispatchOuter(ManagedThreadCallState*)::TryArgs*) const::{lambda(PAL_SEHException&amp;)#1}&gt;'
```

I've read in other issues that this can be caused by a mix-match between ```System.Private.CoreLib.dll``` and ```libcoreclr.so``` but I am confident I have deployed both.

Any guidance would be greatly appreciated.</Title_Description>
    <Label>area-Tracing</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>26/08/2018 11:55:59 PM +00:00</CreatedAt>
    <ClosedAt>26/02/2019 10:39:33 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19679</IssueLabelID>
    <Title>System.Runtime.TieredCompilation configuration knob does not work to turn off tiered compilation</Title>
    <Description>I can't seem to get this configuration knob working. I am using my issue reported in #19599 as a test for whether tiered compilation is enabled or not. The following PowerShell session illustrates my confusion:
```
D:\temp\test&gt; cat .\test.csproj
&lt;Project Sdk="Microsoft.NET.Sdk"&gt;

  &lt;PropertyGroup&gt;
    &lt;OutputType&gt;Exe&lt;/OutputType&gt;
    &lt;TargetFramework&gt;netcoreapp2.1&lt;/TargetFramework&gt;
    &lt;TieredCompilation&gt;false&lt;/TieredCompilation&gt;
  &lt;/PropertyGroup&gt;

&lt;/Project&gt;

D:\temp\test&gt; cat .\Program.cs
struct S0
{
    public byte F0;
}

public class Program
{
    static S0 s_2;
    static long s_5;
    public static void Main()
    {
        s_2.F0 = 128;
        M7(s_2);
        System.Console.WriteLine(s_5);
    }

    static void M7(S0 arg0)
    {
        s_5 = System.Threading.Volatile.Read(ref arg0.F0);
    }
}

D:\temp\test&gt; dotnet publish -c Debug; dotnet publish -c Release
D:\temp\test&gt; cat .\bin\Release\netcoreapp2.1\publish\test.runtimeconfig.json
{
  "runtimeOptions": {
    "tfm": "netcoreapp2.1"
    "framework": {
      "name": "Microsoft.NETCore.App"
      "version": "2.1.0"
    }
    "configProperties": {
      "System.Runtime.TieredCompilation": false
    }
  }
}

D:\temp\test&gt; CoreRun.exe .\bin\Debug\netcoreapp2.1\publish\test.dll
128
D:\temp\test&gt; CoreRun.exe .\bin\Release\netcoreapp2.1\publish\test.dll
128
D:\temp\test&gt; $env:COMPlus_TieredCompilation="0"
D:\temp\test&gt; CoreRun.exe .\bin\Debug\netcoreapp2.1\publish\test.dll
128
D:\temp\test&gt; CoreRun.exe .\bin\Release\netcoreapp2.1\publish\test.dll
4294967168
```
The CoreRun used here is compiled from current master (5d2ae2f) and the dotnet CLI is 2.1.400.

Is this a bug or is there some other way to turn off tiered compilation for an app without requiring the COMPlus_TieredCompilation environment variable to be set correctly before running the app?</Description>
    <Title_Description>System.Runtime.TieredCompilation configuration knob does not work to turn off tiered compilation I can't seem to get this configuration knob working. I am using my issue reported in #19599 as a test for whether tiered compilation is enabled or not. The following PowerShell session illustrates my confusion:
```
D:\temp\test&gt; cat .\test.csproj
&lt;Project Sdk="Microsoft.NET.Sdk"&gt;

  &lt;PropertyGroup&gt;
    &lt;OutputType&gt;Exe&lt;/OutputType&gt;
    &lt;TargetFramework&gt;netcoreapp2.1&lt;/TargetFramework&gt;
    &lt;TieredCompilation&gt;false&lt;/TieredCompilation&gt;
  &lt;/PropertyGroup&gt;

&lt;/Project&gt;

D:\temp\test&gt; cat .\Program.cs
struct S0
{
    public byte F0;
}

public class Program
{
    static S0 s_2;
    static long s_5;
    public static void Main()
    {
        s_2.F0 = 128;
        M7(s_2);
        System.Console.WriteLine(s_5);
    }

    static void M7(S0 arg0)
    {
        s_5 = System.Threading.Volatile.Read(ref arg0.F0);
    }
}

D:\temp\test&gt; dotnet publish -c Debug; dotnet publish -c Release
D:\temp\test&gt; cat .\bin\Release\netcoreapp2.1\publish\test.runtimeconfig.json
{
  "runtimeOptions": {
    "tfm": "netcoreapp2.1"
    "framework": {
      "name": "Microsoft.NETCore.App"
      "version": "2.1.0"
    }
    "configProperties": {
      "System.Runtime.TieredCompilation": false
    }
  }
}

D:\temp\test&gt; CoreRun.exe .\bin\Debug\netcoreapp2.1\publish\test.dll
128
D:\temp\test&gt; CoreRun.exe .\bin\Release\netcoreapp2.1\publish\test.dll
128
D:\temp\test&gt; $env:COMPlus_TieredCompilation="0"
D:\temp\test&gt; CoreRun.exe .\bin\Debug\netcoreapp2.1\publish\test.dll
128
D:\temp\test&gt; CoreRun.exe .\bin\Release\netcoreapp2.1\publish\test.dll
4294967168
```
The CoreRun used here is compiled from current master (5d2ae2f) and the dotnet CLI is 2.1.400.

Is this a bug or is there some other way to turn off tiered compilation for an app without requiring the COMPlus_TieredCompilation environment variable to be set correctly before running the app?</Title_Description>
    <Label>area-TieredCompilation</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>26/08/2018 8:09:45 PM +00:00</CreatedAt>
    <ClosedAt>27/08/2018 6:56:21 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19676</IssueLabelID>
    <Title>PInvoke function that returns a struct</Title>
    <Description>One of my customers encountered a problem today that doesn't appear with .NET Framework/Mono.

For some reason in this function (ENet.cs line 747):
```csharp
[DllImport(nativeLibrary CallingConvention = CallingConvention.Cdecl)]
internal static extern Address enet_peer_get_address(IntPtr peer);
```
marshaling is not possible of an `ENetAddress` struct (ENet.cs line 64) which internally contained in `Address` (ENet.cs line 90):
```csharp
[StructLayout(LayoutKind.Sequential)]
public struct ENetAddress {
	[MarshalAs(UnmanagedType.ByValArray SizeConst = 16)]
	public byte[] host;
	public ushort port;
}
```
look at `Peer.Address` (ENet.cs line 515).

The runtime throws this exception:
&gt; Unhandled Exception: System.Runtime.InteropServices.MarshalDirectiveException: Method's type signature is not PInvoke compatible.
   at ENet.Native.enet_peer_get_address(IntPtr peer)
   at ENet.Peer.get_Address() in E:\TestENetServer\ENet.cs:line 517
   at TestENetServer.Program.Main(String[] args) in E:\TestENetServer\Program.cs:line 25

Here's an example of projects - [ENetCSharpTest.zip](https://github.com/dotnet/coreclr/files/2321643/ENetCSharpTest.zip)
Simple run the server and then the client and you will catch an exception.

Here's repository with a complete source code including the native library - https://github.com/nxrighthere/ENet-CSharp</Description>
    <Title_Description>PInvoke function that returns a struct One of my customers encountered a problem today that doesn't appear with .NET Framework/Mono.

For some reason in this function (ENet.cs line 747):
```csharp
[DllImport(nativeLibrary CallingConvention = CallingConvention.Cdecl)]
internal static extern Address enet_peer_get_address(IntPtr peer);
```
marshaling is not possible of an `ENetAddress` struct (ENet.cs line 64) which internally contained in `Address` (ENet.cs line 90):
```csharp
[StructLayout(LayoutKind.Sequential)]
public struct ENetAddress {
	[MarshalAs(UnmanagedType.ByValArray SizeConst = 16)]
	public byte[] host;
	public ushort port;
}
```
look at `Peer.Address` (ENet.cs line 515).

The runtime throws this exception:
&gt; Unhandled Exception: System.Runtime.InteropServices.MarshalDirectiveException: Method's type signature is not PInvoke compatible.
   at ENet.Native.enet_peer_get_address(IntPtr peer)
   at ENet.Peer.get_Address() in E:\TestENetServer\ENet.cs:line 517
   at TestENetServer.Program.Main(String[] args) in E:\TestENetServer\Program.cs:line 25

Here's an example of projects - [ENetCSharpTest.zip](https://github.com/dotnet/coreclr/files/2321643/ENetCSharpTest.zip)
Simple run the server and then the client and you will catch an exception.

Here's repository with a complete source code including the native library - https://github.com/nxrighthere/ENet-CSharp</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jkoritzinsky</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19674</IssueLabelID>
    <Title>Memory Corruption using System.Numerics.Vector3</Title>
    <Description>I've discovered a memory corruption bug which seems to affect `Vector3`s passed to functions.  This minimal test case crashes consistently for me on Windows 10 (x64 running on a Ryden CPU) using .NET Core 2.1.301.  The same test does not crash for me on MacOS with the same version of .NET Core.

```cs
using System.Numerics;
namespace NumericCorruption {
  class Program {
    static void Main(string[] args) {
      var vec0 = new Vector3(0 0 0);
      Test(vec0);
    }
    static void Test(Vector3 vec0) {
      //vec0.X = -vec0.X; // Uncommenting this line will cause an access violation on the `new` line
      vec0.X = 0; // Uncommenting this line will cause a null reference exception (?!) on the `new` line
      new Vector3(vec0.X vec0.Y vec0.Z);
    }
  }
}
```

As indicated some degree of control is possible so this may have security implications in some regard.  It also only appears to occur when the Vector3 is passed to another function; if you perform the same operations inside a given function everything works as expected.  Also this only seems to occur when you *assign* one of the vector components; accessing components is fine as is assigning whole vectors.</Description>
    <Title_Description>Memory Corruption using System.Numerics.Vector3 I've discovered a memory corruption bug which seems to affect `Vector3`s passed to functions.  This minimal test case crashes consistently for me on Windows 10 (x64 running on a Ryden CPU) using .NET Core 2.1.301.  The same test does not crash for me on MacOS with the same version of .NET Core.

```cs
using System.Numerics;
namespace NumericCorruption {
  class Program {
    static void Main(string[] args) {
      var vec0 = new Vector3(0 0 0);
      Test(vec0);
    }
    static void Test(Vector3 vec0) {
      //vec0.X = -vec0.X; // Uncommenting this line will cause an access violation on the `new` line
      vec0.X = 0; // Uncommenting this line will cause a null reference exception (?!) on the `new` line
      new Vector3(vec0.X vec0.Y vec0.Z);
    }
  }
}
```

As indicated some degree of control is possible so this may have security implications in some regard.  It also only appears to occur when the Vector3 is passed to another function; if you perform the same operations inside a given function everything works as expected.  Also this only seems to occur when you *assign* one of the vector components; accessing components is fine as is assigning whole vectors.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19672</IssueLabelID>
    <Title>StringComparison.Ordinal same as not specified calls?</Title>
    <Description>Should `string.IndexOf(... StringComparison.Ordinal)` go via SpanHelpers rather than  `CompareInfo.Invariant.IndexOf`?</Description>
    <Title_Description>StringComparison.Ordinal same as not specified calls? Should `string.IndexOf(... StringComparison.Ordinal)` go via SpanHelpers rather than  `CompareInfo.Invariant.IndexOf`?</Title_Description>
    <Label>area-System.Runtime</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>25/08/2018 12:42:17 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19668</IssueLabelID>
    <Title>Consistency check failed: File has not had execution verified</Title>
    <Description>The three following assemblies when PMI-d on Linux/arm hit the same assertion

**System.Security.Cryptography.Encoding.dll** 

```
ubuntu@tegra-ubuntu:~$ $CORE_ROOT/corerun /mnt/echesakov/jitutils/bin/pmi.dll PREPALL-QUIET $CORE_ROOT/System.Security.Cryptography.Encoding.dll

Assert failure(PID 6645 [0x000019f5] Thread: 6645 [0x19f5]): Consistency check failed: File has not had execution verifiedFAILED: m_bDisableActivationCheck || CheckLoadLevel(FILE_ACTIVE)
         FAILED: pDomainFile-&gt;CheckActivated()
                /opt/code/src/vm/ceeload.cpp line: 13830
         FAILED: GetModule()-&gt;CheckActivated()
                /opt/code/src/vm/methodtable.cpp line: 9358
         FAILED: CheckActivated()
                /opt/code/src/vm/methodtable.cpp line: 3699
    File: /opt/code/src/vm/domainfile.cpp Line: 390
    Image: /mnt/echesakov/PR19619/bin/tests/Linux.arm.Checked/Tests/Core_Root/corerun

Aborted
```

**System.Security.Cryptography.OpenSsl.dll**
```
ubuntu@tegra-ubuntu:~$ $CORE_ROOT/corerun /mnt/echesakov/jitutils/bin/pmi.dll PREPALL-QUIET $CORE_ROOT/System.Security.Cryptography.OpenSsl.dll

Assert failure(PID 7778 [0x00001e62] Thread: 7778 [0x1e62]): Consistency check failed: File has not had execution verifiedFAILED: m_bDisableActivationCheck || CheckLoadLevel(FILE_ACTIVE)
         FAILED: pDomainFile-&gt;CheckActivated()
                /opt/code/src/vm/ceeload.cpp line: 13830
         FAILED: GetModule()-&gt;CheckActivated()
                /opt/code/src/vm/methodtable.cpp line: 9358
         FAILED: CheckActivated()
                /opt/code/src/vm/methodtable.cpp line: 3699
    File: /opt/code/src/vm/domainfile.cpp Line: 390
    Image: /mnt/echesakov/PR19619/bin/tests/Linux.arm.Checked/Tests/Core_Root/corerun

Aborted
```

**System.Security.Cryptography.Algorithms.dll** (reproducible under COMPlus_TieredCompilation=0 only)

```
ubuntu@tegra-ubuntu:~$ COMPlus_TieredCompilation=0 $CORE_ROOT/corerun /mnt/echesakov/jitutils/bin/pmi.dll PREPALL-QUIET $CORE_ROOT/System.Security.Cryptography.Algorithms.dll

Assert failure(PID 9067 [0x0000236b] Thread: 9067 [0x236b]): Consistency check failed: File has not had execution verifiedFAILED: m_bDisableActivationCheck || CheckLoadLevel(FILE_ACTIVE)
         FAILED: pDomainFile-&gt;CheckActivated()
                /opt/code/src/vm/ceeload.cpp line: 13830
         FAILED: GetModule()-&gt;CheckActivated()
                /opt/code/src/vm/methodtable.cpp line: 9358
         FAILED: CheckActivated()
                /opt/code/src/vm/methodtable.cpp line: 3699
    File: /opt/code/src/vm/domainfile.cpp Line: 390
    Image: /mnt/echesakov/PR19619/bin/tests/Linux.arm.Checked/Tests/Core_Root/corerun

Aborted
```
To reproduce - build https://github.com/dotnet/jitutils first and then run the command 

`$CORE_ROOT/corerun $JitUtils/bin/pmi.dll PREPALL-QUIET $CORE_ROOT/System.Security.Cryptography.OpenSsl.dll`

**Updated:** Also reproduces on Linux/arm64</Description>
    <Title_Description>Consistency check failed: File has not had execution verified The three following assemblies when PMI-d on Linux/arm hit the same assertion

**System.Security.Cryptography.Encoding.dll** 

```
ubuntu@tegra-ubuntu:~$ $CORE_ROOT/corerun /mnt/echesakov/jitutils/bin/pmi.dll PREPALL-QUIET $CORE_ROOT/System.Security.Cryptography.Encoding.dll

Assert failure(PID 6645 [0x000019f5] Thread: 6645 [0x19f5]): Consistency check failed: File has not had execution verifiedFAILED: m_bDisableActivationCheck || CheckLoadLevel(FILE_ACTIVE)
         FAILED: pDomainFile-&gt;CheckActivated()
                /opt/code/src/vm/ceeload.cpp line: 13830
         FAILED: GetModule()-&gt;CheckActivated()
                /opt/code/src/vm/methodtable.cpp line: 9358
         FAILED: CheckActivated()
                /opt/code/src/vm/methodtable.cpp line: 3699
    File: /opt/code/src/vm/domainfile.cpp Line: 390
    Image: /mnt/echesakov/PR19619/bin/tests/Linux.arm.Checked/Tests/Core_Root/corerun

Aborted
```

**System.Security.Cryptography.OpenSsl.dll**
```
ubuntu@tegra-ubuntu:~$ $CORE_ROOT/corerun /mnt/echesakov/jitutils/bin/pmi.dll PREPALL-QUIET $CORE_ROOT/System.Security.Cryptography.OpenSsl.dll

Assert failure(PID 7778 [0x00001e62] Thread: 7778 [0x1e62]): Consistency check failed: File has not had execution verifiedFAILED: m_bDisableActivationCheck || CheckLoadLevel(FILE_ACTIVE)
         FAILED: pDomainFile-&gt;CheckActivated()
                /opt/code/src/vm/ceeload.cpp line: 13830
         FAILED: GetModule()-&gt;CheckActivated()
                /opt/code/src/vm/methodtable.cpp line: 9358
         FAILED: CheckActivated()
                /opt/code/src/vm/methodtable.cpp line: 3699
    File: /opt/code/src/vm/domainfile.cpp Line: 390
    Image: /mnt/echesakov/PR19619/bin/tests/Linux.arm.Checked/Tests/Core_Root/corerun

Aborted
```

**System.Security.Cryptography.Algorithms.dll** (reproducible under COMPlus_TieredCompilation=0 only)

```
ubuntu@tegra-ubuntu:~$ COMPlus_TieredCompilation=0 $CORE_ROOT/corerun /mnt/echesakov/jitutils/bin/pmi.dll PREPALL-QUIET $CORE_ROOT/System.Security.Cryptography.Algorithms.dll

Assert failure(PID 9067 [0x0000236b] Thread: 9067 [0x236b]): Consistency check failed: File has not had execution verifiedFAILED: m_bDisableActivationCheck || CheckLoadLevel(FILE_ACTIVE)
         FAILED: pDomainFile-&gt;CheckActivated()
                /opt/code/src/vm/ceeload.cpp line: 13830
         FAILED: GetModule()-&gt;CheckActivated()
                /opt/code/src/vm/methodtable.cpp line: 9358
         FAILED: CheckActivated()
                /opt/code/src/vm/methodtable.cpp line: 3699
    File: /opt/code/src/vm/domainfile.cpp Line: 390
    Image: /mnt/echesakov/PR19619/bin/tests/Linux.arm.Checked/Tests/Core_Root/corerun

Aborted
```
To reproduce - build https://github.com/dotnet/jitutils first and then run the command 

`$CORE_ROOT/corerun $JitUtils/bin/pmi.dll PREPALL-QUIET $CORE_ROOT/System.Security.Cryptography.OpenSsl.dll`

**Updated:** Also reproduces on Linux/arm64</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>AndyAyersMS</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19667</IssueLabelID>
    <Title>[WIP] Enable tiered compilation</Title>
    <Description>
    </Description>
    <Title_Description>[WIP] Enable tiered compilation </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19666</IssueLabelID>
    <Title>[WIP] Test CI</Title>
    <Description>
    </Description>
    <Title_Description>[WIP] Test CI </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19661</IssueLabelID>
    <Title>R2RDump ARM and ARM64 UnwindCodes</Title>
    <Description>R2RDump can parse UnwindInfo headers for ARM and ARM64 but not UnwindCodes yet. 

This can be implemented based on https://github.com/dotnet/coreclr/blob/master/src/jit/unwindarm.cpp and https://github.com/dotnet/coreclr/blob/master/src/jit/unwindarm64.cpp</Description>
    <Title_Description>R2RDump ARM and ARM64 UnwindCodes R2RDump can parse UnwindInfo headers for ARM and ARM64 but not UnwindCodes yet. 

This can be implemented based on https://github.com/dotnet/coreclr/blob/master/src/jit/unwindarm.cpp and https://github.com/dotnet/coreclr/blob/master/src/jit/unwindarm64.cpp</Title_Description>
    <Label>area-R2RDump</Label>
    <Assignee>nattress</Assignee>
    <CreatedAt>24/08/2018 8:28:44 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19659</IssueLabelID>
    <Title>Fix FileStream in WinRT build</Title>
    <Description>
    </Description>
    <Title_Description>Fix FileStream in WinRT build </Title_Description>
    <Label>area-System.IO</Label>
    <Assignee>JeremyKuhne</Assignee>
    <CreatedAt>24/08/2018 6:50:33 PM +00:00</CreatedAt>
    <ClosedAt>25/08/2018 12:25:55 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19657</IssueLabelID>
    <Title>Unify the Interop xplatform.h file with the common coreclr test platformdefines.h </Title>
    <Description>@luqunl 

See #19576</Description>
    <Title_Description>Unify the Interop xplatform.h file with the common coreclr test platformdefines.h  @luqunl 

See #19576</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>24/08/2018 6:23:20 PM +00:00</CreatedAt>
    <ClosedAt>18/01/2019 12:58:35 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19655</IssueLabelID>
    <Title>Zeroing stack by rep stosb instead of rep stosd</Title>
    <Description>Intel improved the performance of `rep stosb` and `rep movsb` (not `rep stosd/q`/``rep movsd/q``)since Sandy Bridge (indicated by CPUID “enhanced strings”) and will continue to improve them in the future.

![image](https://user-images.githubusercontent.com/1263030/44600424-1c7dc800-a78e-11e8-8832-163032da1f99.png)

So we should consistently use `rep stosb` instead of `rep stosd\q` (actually `genCodeForStoreBlk` is using `rep stosb` now) which won't be slower than `rep stosd/q` and even faster on some platforms.

related to https://github.com/dotnet/coreclr/issues/19076
</Description>
    <Title_Description>Zeroing stack by rep stosb instead of rep stosd Intel improved the performance of `rep stosb` and `rep movsb` (not `rep stosd/q`/``rep movsd/q``)since Sandy Bridge (indicated by CPUID “enhanced strings”) and will continue to improve them in the future.

![image](https://user-images.githubusercontent.com/1263030/44600424-1c7dc800-a78e-11e8-8832-163032da1f99.png)

So we should consistently use `rep stosb` instead of `rep stosd\q` (actually `genCodeForStoreBlk` is using `rep stosb` now) which won't be slower than `rep stosd/q` and even faster on some platforms.

related to https://github.com/dotnet/coreclr/issues/19076
</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>tannergooding</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19654</IssueLabelID>
    <Title>P/Invoke custom marshaler sometimes fails type cast</Title>
    <Description>I'm trying to track down why [my upgrade](https://github.com/AArnott/Nerdbank.GitVersioning/pull/210) of libgit2sharp to 0.25.2 led to nerdbank.gitversioning to fail (reliably) on a seemingly random set of projects across multiple repos.

In [the failure](https://github.com/AArnott/Nerdbank.GitVersioning/issues/215) [a type check](https://github.com/libgit2/libgit2sharp/blob/5199c83d37f7baf5a775eacaffd66322b1d90ef1/LibGit2Sharp/Core/FilePathMarshaler.cs#L67) fails after passing through [a very clearly type constraining method](https://github.com/libgit2/libgit2sharp/blob/5199c83d37f7baf5a775eacaffd66322b1d90ef1/LibGit2Sharp/Core/NativeMethods.cs#L1395-L1398). Considering that perhaps it's a matter of assembly double-loading I checked. The managed debugger reports the assembly is loaded once and that the AssemblyLoadContext is the same at both points of the callstack leading up to the failure. 

This repros only on .NET Core (2.1) and does so on Windows and Linux (I didn't test Mac). This same code works fine within MSBuild running on the .NET Framework.

[The repro](https://github.com/AArnott/Nerdbank.GitVersioning/issues/215#issuecomment-415785686) is super reliable and relatively simple. @rainersigwald also has [a great repro](https://github.com/AArnott/Nerdbank.GitVersioning/issues/215#issuecomment-415774717).</Description>
    <Title_Description>P/Invoke custom marshaler sometimes fails type cast I'm trying to track down why [my upgrade](https://github.com/AArnott/Nerdbank.GitVersioning/pull/210) of libgit2sharp to 0.25.2 led to nerdbank.gitversioning to fail (reliably) on a seemingly random set of projects across multiple repos.

In [the failure](https://github.com/AArnott/Nerdbank.GitVersioning/issues/215) [a type check](https://github.com/libgit2/libgit2sharp/blob/5199c83d37f7baf5a775eacaffd66322b1d90ef1/LibGit2Sharp/Core/FilePathMarshaler.cs#L67) fails after passing through [a very clearly type constraining method](https://github.com/libgit2/libgit2sharp/blob/5199c83d37f7baf5a775eacaffd66322b1d90ef1/LibGit2Sharp/Core/NativeMethods.cs#L1395-L1398). Considering that perhaps it's a matter of assembly double-loading I checked. The managed debugger reports the assembly is loaded once and that the AssemblyLoadContext is the same at both points of the callstack leading up to the failure. 

This repros only on .NET Core (2.1) and does so on Windows and Linux (I didn't test Mac). This same code works fine within MSBuild running on the .NET Framework.

[The repro](https://github.com/AArnott/Nerdbank.GitVersioning/issues/215#issuecomment-415785686) is super reliable and relatively simple. @rainersigwald also has [a great repro](https://github.com/AArnott/Nerdbank.GitVersioning/issues/215#issuecomment-415774717).</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>24/08/2018 6:05:02 PM +00:00</CreatedAt>
    <ClosedAt>15/01/2019 3:47:19 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19652</IssueLabelID>
    <Title>[release/2.1] Arm stepping fix</Title>
    <Description>#### Description

A bit ago @chsienki and @davidwrighton made some fixes to debugging that ended up in master after the release/2.2 branch was created. In particular the castings from `PISNTR` to `PCODE` were not preserving the thumb bit causing stepping in ARM debugging to break. Issue #19255 is requesting to port these fixes to 2.1 for servicing.

This PR ports the following PR's from master to 2.1 as requested:
- #17617
- #17879
- #17990
- #18129
- #18247
#### Customer Impact

Currently our debugging experience in ARM is not working as expected. In some scenarios stepping will fall into incorrect locations sometimes during testing we find breakpoints that will fire up twice. Some customers have asked us to address this (issue #19255).
#### Regression?

Not a regression.		 
#### Risk

The risk taken from this change should be fairly low. Mostly castings were fixed that were fixed which only turn the thumb bit for ARM (while having no change in other architectures) appropriately on code paths used by the debugger in the VM. </Description>
    <Title_Description>[release/2.1] Arm stepping fix #### Description

A bit ago @chsienki and @davidwrighton made some fixes to debugging that ended up in master after the release/2.2 branch was created. In particular the castings from `PISNTR` to `PCODE` were not preserving the thumb bit causing stepping in ARM debugging to break. Issue #19255 is requesting to port these fixes to 2.1 for servicing.

This PR ports the following PR's from master to 2.1 as requested:
- #17617
- #17879
- #17990
- #18129
- #18247
#### Customer Impact

Currently our debugging experience in ARM is not working as expected. In some scenarios stepping will fall into incorrect locations sometimes during testing we find breakpoints that will fire up twice. Some customers have asked us to address this (issue #19255).
#### Regression?

Not a regression.		 
#### Risk

The risk taken from this change should be fairly low. Mostly castings were fixed that were fixed which only turn the thumb bit for ARM (while having no change in other architectures) appropriately on code paths used by the debugger in the VM. </Title_Description>
    <Label>Servicing-approved</Label>
    <Assignee>hoyosjs</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19651</IssueLabelID>
    <Title>x64 JIT stack-spilled call parameter lifetime bug</Title>
    <Description>In the x64 JIT (FileVer output for clrjit.dll: `--a-- W32 DLL ENU 4.7.3130.0 shp 1224336 06-05-2018 clrjit.dll`) the GC info for stack-spilled method call parameters is incorrect (lifetime ends too early) when followed by a parameter that is the result of an inline array access when in debug mode.

Repro code:

    public void Repro(int p1 object p2 object p3 object p4 object[] p5)
    {
        // Incorrect GC Info generated for this call
        ReproHelper(p1 p2 p3 p4 p5[p1]);
    }

    public void ReproHelper(int p1 object p2 object p3 object p4 object p5)
    {
        Console.WriteLine(p1);
        Console.WriteLine(p2);
        Console.WriteLine(p3);
        Console.WriteLine(p4);
        Console.WriteLine(p5);
    }

The generated assembly for the call to `ReproHelper()` in the `Repro()` method with associated GC info is as follows:

    Untracked: +rbp+38 +rbp+30

    ...
    +28 488b4d30        mov     rcxqword ptr [rbp+30h]
        +rcx
    +2c 48894c2420      mov     qword ptr [rsp+20h]rcx
        +sp+20
    +31 8b4d18          mov     ecxdword ptr [rbp+18h]
        -rcx
    +34 488b5538        mov     rdxqword ptr [rbp+38h]
        +rdx
    +38 483b4a08        cmp     rcxqword ptr [rdx+8]
    +3c 7205            jb      +43
    +3e e85d1eaa5f      call    clr!JIT_RngChkFail
        -sp+20
    +43 488d54ca10      lea     rdx[rdx+rcx*8+10h]
        -rdx +rdx(interior)
    +48 488b0a          mov     rcxqword ptr [rdx]
        +rcx
    +4b 48894c2428      mov     qword ptr [rsp+28h]rcx
        +sp+28
    +50 488b4d10        mov     rcxqword ptr [rbp+10h]
    +54 8b5518          mov     edxdword ptr [rbp+18h]
        -rdx(interior)
    +57 4c8b4520        mov     r8qword ptr [rbp+20h]
        +r8
    +5b 4c8b4d28        mov     r9qword ptr [rbp+28h]
        +r9
    +5f e8b4f6ffff      call    ReproHelper(Int32 System.Object System.Object System.Object System.Object)
        -sp+28 -r9 -r8 -rcx
    ...

Parameter 4 to `ReproHelper()` is loaded onto the stack at `+2c` and this stack entry is correctly marked as live in the GC info (`+sp+20`).

However after the array index range check is performed prior to loading parameter 5 onto the stack parameter 4's stack entry is incorrectly marked as dead at `+43` (`-sp+20`).

If a GC occurs between this point and the eventual call to `ReproHelper()` at `+5f` and that GC results in the object being passed as parameter 4 being relocated the stack entry at `rsp+20` will not be updated with the object's new address and `ReproHelper()` will be passed an invalid object address for parameter 4.</Description>
    <Title_Description>x64 JIT stack-spilled call parameter lifetime bug In the x64 JIT (FileVer output for clrjit.dll: `--a-- W32 DLL ENU 4.7.3130.0 shp 1224336 06-05-2018 clrjit.dll`) the GC info for stack-spilled method call parameters is incorrect (lifetime ends too early) when followed by a parameter that is the result of an inline array access when in debug mode.

Repro code:

    public void Repro(int p1 object p2 object p3 object p4 object[] p5)
    {
        // Incorrect GC Info generated for this call
        ReproHelper(p1 p2 p3 p4 p5[p1]);
    }

    public void ReproHelper(int p1 object p2 object p3 object p4 object p5)
    {
        Console.WriteLine(p1);
        Console.WriteLine(p2);
        Console.WriteLine(p3);
        Console.WriteLine(p4);
        Console.WriteLine(p5);
    }

The generated assembly for the call to `ReproHelper()` in the `Repro()` method with associated GC info is as follows:

    Untracked: +rbp+38 +rbp+30

    ...
    +28 488b4d30        mov     rcxqword ptr [rbp+30h]
        +rcx
    +2c 48894c2420      mov     qword ptr [rsp+20h]rcx
        +sp+20
    +31 8b4d18          mov     ecxdword ptr [rbp+18h]
        -rcx
    +34 488b5538        mov     rdxqword ptr [rbp+38h]
        +rdx
    +38 483b4a08        cmp     rcxqword ptr [rdx+8]
    +3c 7205            jb      +43
    +3e e85d1eaa5f      call    clr!JIT_RngChkFail
        -sp+20
    +43 488d54ca10      lea     rdx[rdx+rcx*8+10h]
        -rdx +rdx(interior)
    +48 488b0a          mov     rcxqword ptr [rdx]
        +rcx
    +4b 48894c2428      mov     qword ptr [rsp+28h]rcx
        +sp+28
    +50 488b4d10        mov     rcxqword ptr [rbp+10h]
    +54 8b5518          mov     edxdword ptr [rbp+18h]
        -rdx(interior)
    +57 4c8b4520        mov     r8qword ptr [rbp+20h]
        +r8
    +5b 4c8b4d28        mov     r9qword ptr [rbp+28h]
        +r9
    +5f e8b4f6ffff      call    ReproHelper(Int32 System.Object System.Object System.Object System.Object)
        -sp+28 -r9 -r8 -rcx
    ...

Parameter 4 to `ReproHelper()` is loaded onto the stack at `+2c` and this stack entry is correctly marked as live in the GC info (`+sp+20`).

However after the array index range check is performed prior to loading parameter 5 onto the stack parameter 4's stack entry is incorrectly marked as dead at `+43` (`-sp+20`).

If a GC occurs between this point and the eventual call to `ReproHelper()` at `+5f` and that GC results in the object being passed as parameter 4 being relocated the stack entry at `rsp+20` will not be updated with the object's new address and `ReproHelper()` will be passed an invalid object address for parameter 4.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>briansull</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19650</IssueLabelID>
    <Title>[release/2.1] Determine memory load based on cgroup usage.</Title>
    <Description>Port #19518 to 2.1

CC @janvorli </Description>
    <Title_Description>[release/2.1] Determine memory load based on cgroup usage. Port #19518 to 2.1

CC @janvorli </Title_Description>
    <Label>Servicing-approved</Label>
    <Assignee>janvorli</Assignee>
    <CreatedAt>24/08/2018 7:22:09 AM +00:00</CreatedAt>
    <ClosedAt>31/08/2018 4:51:25 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19649</IssueLabelID>
    <Title>Test failure: baseservices_threading._generics_WaitCallback_thread07_thread07_/_generics_WaitCallback_thread07_thread07_cmd</Title>
    <Description>Opened on behalf of @Sunny-pu

The test `baseservices_threading._generics_WaitCallback_thread07_thread07_/_generics_WaitCallback_thread07_thread07_cmd` has failed.


    Unhandled Exception: System.IO.FileNotFoundException: Could not load file or assembly 'System.Console Version=4.1.1.0 Culture=neutral PublicKeyToken=b03f5f7f11d50a3a'. The system cannot find the file specified.
    
    /home/helixbot/dotnetbuild/work/f079d896-e097-4e55-a032-9f5058b6d014/Work/4c4b8101-cb8e-49f3-8b01-707b8eaa4799/Unzip/generics/WaitCallback/thread07/thread07.sh: line 244: 98133 Aborted                 (core dumped) $_DebuggerFullPath \"$CORE_ROOT/corerun\" $ExePath $CLRTestExecutionArguments
    
    
    Return code:      1
    Raw output file:      /home/helixbot/dotnetbuild/work/f079d896-e097-4e55-a032-9f5058b6d014/Work/4c4b8101-cb8e-49f3-8b01-707b8eaa4799/Unzip/Reports\\baseservices.threading\\generics\\WaitCallback\\thread07\\thread07.output.txt
    Raw output:
    BEGIN EXECUTION
    /home/helixbot/dotnetbuild/work/f079d896-e097-4e55-a032-9f5058b6d014/Payload/corerun thread07.exe
    Expected: 100
    Actual: 134
    END EXECUTION - FAILED
    Test Harness Exitcode is : 1
    
    To run the test:
    &gt; set CORE_ROOT=/home/helixbot/dotnetbuild/work/f079d896-e097-4e55-a032-9f5058b6d014/Payload
    &gt; /home/helixbot/dotnetbuild/work/f079d896-e097-4e55-a032-9f5058b6d014/Work/4c4b8101-cb8e-49f3-8b01-707b8eaa4799/Unzip/generics/WaitCallback/thread07/thread07.sh
    
    Expected: True
    Actual:   False

        Stack Trace:

           at baseservices_threading._generics_WaitCallback_thread07_thread07_._generics_WaitCallback_thread07_thread07_cmd() in E:\A\_work\3\s\bin\tests\Windows_NT.x64.Release\TestWrappers\baseservices.threading\baseservices.threading.XUnitWrapper.cs:line 10191
Build : 3.0 - 20180824.01 (Ready-To-Run Tests)
Failing configurations:
- opensuse.423.amd64
  - x64

Details: https://mc.dot.net/#/product/netcore/30/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fr2r~2Fcli~2F/build/20180824.01/workItem/baseservices.threading.XUnitWrapper/analysis/xunit/baseservices_threading._generics_WaitCallback_thread07_thread07_~2F_generics_WaitCallback_thread07_thread07_cmd</Description>
    <Title_Description>Test failure: baseservices_threading._generics_WaitCallback_thread07_thread07_/_generics_WaitCallback_thread07_thread07_cmd Opened on behalf of @Sunny-pu

The test `baseservices_threading._generics_WaitCallback_thread07_thread07_/_generics_WaitCallback_thread07_thread07_cmd` has failed.


    Unhandled Exception: System.IO.FileNotFoundException: Could not load file or assembly 'System.Console Version=4.1.1.0 Culture=neutral PublicKeyToken=b03f5f7f11d50a3a'. The system cannot find the file specified.
    
    /home/helixbot/dotnetbuild/work/f079d896-e097-4e55-a032-9f5058b6d014/Work/4c4b8101-cb8e-49f3-8b01-707b8eaa4799/Unzip/generics/WaitCallback/thread07/thread07.sh: line 244: 98133 Aborted                 (core dumped) $_DebuggerFullPath \"$CORE_ROOT/corerun\" $ExePath $CLRTestExecutionArguments
    
    
    Return code:      1
    Raw output file:      /home/helixbot/dotnetbuild/work/f079d896-e097-4e55-a032-9f5058b6d014/Work/4c4b8101-cb8e-49f3-8b01-707b8eaa4799/Unzip/Reports\\baseservices.threading\\generics\\WaitCallback\\thread07\\thread07.output.txt
    Raw output:
    BEGIN EXECUTION
    /home/helixbot/dotnetbuild/work/f079d896-e097-4e55-a032-9f5058b6d014/Payload/corerun thread07.exe
    Expected: 100
    Actual: 134
    END EXECUTION - FAILED
    Test Harness Exitcode is : 1
    
    To run the test:
    &gt; set CORE_ROOT=/home/helixbot/dotnetbuild/work/f079d896-e097-4e55-a032-9f5058b6d014/Payload
    &gt; /home/helixbot/dotnetbuild/work/f079d896-e097-4e55-a032-9f5058b6d014/Work/4c4b8101-cb8e-49f3-8b01-707b8eaa4799/Unzip/generics/WaitCallback/thread07/thread07.sh
    
    Expected: True
    Actual:   False

        Stack Trace:

           at baseservices_threading._generics_WaitCallback_thread07_thread07_._generics_WaitCallback_thread07_thread07_cmd() in E:\A\_work\3\s\bin\tests\Windows_NT.x64.Release\TestWrappers\baseservices.threading\baseservices.threading.XUnitWrapper.cs:line 10191
Build : 3.0 - 20180824.01 (Ready-To-Run Tests)
Failing configurations:
- opensuse.423.amd64
  - x64

Details: https://mc.dot.net/#/product/netcore/30/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fr2r~2Fcli~2F/build/20180824.01/workItem/baseservices.threading.XUnitWrapper/analysis/xunit/baseservices_threading._generics_WaitCallback_thread07_thread07_~2F_generics_WaitCallback_thread07_thread07_cmd</Title_Description>
    <Label>test-run-uwp-coreclr</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>24/08/2018 6:33:34 AM +00:00</CreatedAt>
    <ClosedAt>11/01/2019 10:14:59 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19648</IssueLabelID>
    <Title>arm Ubuntu machines not processing jobs correctly</Title>
    <Description>Looks like all arm32 Ubuntu jobs are failing with something like:
```
21:06:32  &gt; git rev-list 656c77eeacf722e97a06e56d8d34b9c0cc6e746c # timeout=10
21:06:33 
Unable to access upstream artifacts area /jenkins/jobs/dotnet_coreclr/jobs/master/jobs/x86_checked_windows_nt_innerloop_bld_prtest/builds/4648/archive. Does source project archive artifacts?
21:06:33 ERROR: Failed to copy artifacts from dotnet_coreclr/master/x86_checked_windows_nt_innerloop_bld_prtest with filter: **
21:06:33 [xUnit] [INFO] - Starting to record.
```
https://ci.dot.net/job/dotnet_coreclr/job/master/job/arm_cross_checked_ubuntu_innerloop_tst_prtest/3721/consoleFull

root job: https://ci.dot.net/job/dotnet_coreclr/job/master/job/arm_cross_checked_ubuntu_innerloop_flow_prtest/

@dotnet/dnceng @mmitche @jashook @RussKeldorph @MattGal </Description>
    <Title_Description>arm Ubuntu machines not processing jobs correctly Looks like all arm32 Ubuntu jobs are failing with something like:
```
21:06:32  &gt; git rev-list 656c77eeacf722e97a06e56d8d34b9c0cc6e746c # timeout=10
21:06:33 
Unable to access upstream artifacts area /jenkins/jobs/dotnet_coreclr/jobs/master/jobs/x86_checked_windows_nt_innerloop_bld_prtest/builds/4648/archive. Does source project archive artifacts?
21:06:33 ERROR: Failed to copy artifacts from dotnet_coreclr/master/x86_checked_windows_nt_innerloop_bld_prtest with filter: **
21:06:33 [xUnit] [INFO] - Starting to record.
```
https://ci.dot.net/job/dotnet_coreclr/job/master/job/arm_cross_checked_ubuntu_innerloop_tst_prtest/3721/consoleFull

root job: https://ci.dot.net/job/dotnet_coreclr/job/master/job/arm_cross_checked_ubuntu_innerloop_flow_prtest/

@dotnet/dnceng @mmitche @jashook @RussKeldorph @MattGal </Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>24/08/2018 4:34:51 AM +00:00</CreatedAt>
    <ClosedAt>24/08/2018 5:35:42 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19646</IssueLabelID>
    <Title>[NO MERGE] Add assert ImmedValNeedsReloc in optCreateAssertion</Title>
    <Description>**NO MERGE** This is for testing ONLY</Description>
    <Title_Description>[NO MERGE] Add assert ImmedValNeedsReloc in optCreateAssertion **NO MERGE** This is for testing ONLY</Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>echesakovMSFT</Assignee>
    <CreatedAt>24/08/2018 2:10:05 AM +00:00</CreatedAt>
    <ClosedAt>29/08/2018 1:26:45 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19643</IssueLabelID>
    <Title>[WIP]In Win X64 Return value calling convention diffs between member function and static function…</Title>
    <Description>Partial fix : https://github.com/dotnet/coreclr/issues/19474
</Description>
    <Title_Description>[WIP]In Win X64, Return value calling convention diffs between member function and static function… Partial fix : https://github.com/dotnet/coreclr/issues/19474
</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>luqunl</Assignee>
    <CreatedAt>24/08/2018 12:19:22 AM +00:00</CreatedAt>
    <ClosedAt>9/03/2019 3:52:06 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19642</IssueLabelID>
    <Title>R2RDump - List of bugs when running R2RDump on CoreFX binaries</Title>
    <Description>There's an IndexOutOfRangeException when dumping an ARM ReadyToRun System.Private.Corelib.
It happens in R2RDump.NibbleReader.ReadNibble() when decoding fixups.
It also happens in GcTransitions.cs where the slotId is greater than the number of untracked slots</Description>
    <Title_Description>R2RDump - List of bugs when running R2RDump on CoreFX binaries There's an IndexOutOfRangeException when dumping an ARM ReadyToRun System.Private.Corelib.
It happens in R2RDump.NibbleReader.ReadNibble() when decoding fixups.
It also happens in GcTransitions.cs where the slotId is greater than the number of untracked slots</Title_Description>
    <Label>area-R2RDump</Label>
    <Assignee>acmyu</Assignee>
    <CreatedAt>23/08/2018 11:34:25 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19641</IssueLabelID>
    <Title>AppVerifier reports CoInitialize leak in coreclr</Title>
    <Description>Sometimes we get `CoInitialize leak` reported in coreclr while running AspNetCoreModule tests with AppVerifier.

CoreClr is being hosted inside iisexpress process in this case. It's doesn't happen in all the tests so I'm not sure it's something wrong we do or issues with coreclr.

Dump: `\\pkrymets\exchange\coinit\coinit2.cab `

Some details from the dump:

```
    Description3 = 0x000000d5`6deffc60 "CoInitialize Stacks.!list -t ntdll!_LIST_ENTRY.Flink -x "dps poi(" -a "-8) l 0n32" 000001E3E2896FE8"
          Param4 = 0x000001e3`f48d9fe8
    Description4 = 0x000000d5`6deffb90 "CoUninitialize Stacks. use above cmd with 000001E3F48D9FE8"

```

**&gt; !list -t ntdll!_LIST_ENTRY.Flink -x "dps poi(" -a "-8) l 0n32" 000001E3E2896FE8**
```
000001e3`e94fff00  00007ff8`479c9055 combase!_CoInitializeEx+0x1d9 [onecore\com\combase\class\compobj.cxx @ 3872]
000001e3`e94fff08  00007ff8`479c8c26 combase!CoInitializeEx+0x36 [onecore\com\combase\class\compobj.cxx @ 3905]
000001e3`e94fff10  00007ff8`2f61e7bf vfbasics!AVrfpCoInitializeEx+0x2f [onecore\base\avrf\vrfcommon\threadpool.c @ 3974]
000001e3`e94fff18  00007fff`cddd3bc3 coreclr!Thread::SetApartment+0xcb [e:\a\_work\104\s\src\vm\threads.cpp @ 5279]
000001e3`e94fff20  00007fff`cddd3e6e coreclr!EnsureComStarted+0x6a [e:\a\_work\104\s\src\vm\interoputil.cpp @ 2395]
000001e3`e94fff28  00007fff`cdeb1c56 coreclr!GetStubForInteropMethod+0x112 [e:\a\_work\104\s\src\vm\dllimport.cpp @ 5489]
000001e3`e94fff30  00007fff`cde526ef coreclr!MethodDesc::DoPrestub+0xb3f [e:\a\_work\104\s\src\vm\prestub.cpp @ 1843]
000001e3`e94fff38  00007fff`cde51a5a coreclr!PreStubWorker+0x37a [e:\a\_work\104\s\src\vm\prestub.cpp @ 1575]
000001e3`e94fff40  00007fff`cdf2dd05 coreclr!ThePreStub+0x55 [E:\A\_work\104\s\src\vm\amd64\ThePreStubAMD64.asm @ 22]
000001e3`e94fff48  00007fff`6e447685
000001e3`e94fff50  00000000`00000000
000001e3`e94fff58  00000000`00000000
000001e3`e94fff60  00000000`00000000
000001e3`e94fff68  00000000`00000000
000001e3`e94fff70  00000000`00000000
000001e3`e94fff78  00000000`00000000
000001e3`e94fff80  00000000`00000000
000001e3`e94fff88  00000000`00000000
000001e3`e94fff90  00000000`00000000
000001e3`e94fff98  00000000`00000000
000001e3`e94fffa0  00000000`00000000
000001e3`e94fffa8  00000000`00000000
000001e3`e94fffb0  00000000`00000000
000001e3`e94fffb8  00000000`00000000
000001e3`e94fffc0  00000000`00000000
000001e3`e94fffc8  00000000`00000000
000001e3`e94fffd0  00000000`00000000
000001e3`e94fffd8  00000000`00000000
000001e3`e94fffe0  00000000`00000000
000001e3`e94fffe8  00000000`00000000
000001e3`e94ffff0  00000000`00000000
000001e3`e94ffff8  00000000`00000000

000001e3`ee623f00  00007ff8`479c9055 combase!_CoInitializeEx+0x1d9 [onecore\com\combase\class\compobj.cxx @ 3872]
000001e3`ee623f08  00007ff8`2f61e8f5 vfbasics!AVrfpRoInitialize+0x25 [onecore\base\avrf\vrfcommon\threadpool.c @ 4070]
000001e3`ee623f10  00007fff`cddd3cd6 coreclr!Thread::SetApartment+0x1de [e:\a\_work\104\s\src\vm\threads.cpp @ 5346]
000001e3`ee623f18  00007fff`cddd3e6e coreclr!EnsureComStarted+0x6a [e:\a\_work\104\s\src\vm\interoputil.cpp @ 2395]
000001e3`ee623f20  00007fff`cdeb1c56 coreclr!GetStubForInteropMethod+0x112 [e:\a\_work\104\s\src\vm\dllimport.cpp @ 5489]
000001e3`ee623f28  00007fff`cde526ef coreclr!MethodDesc::DoPrestub+0xb3f [e:\a\_work\104\s\src\vm\prestub.cpp @ 1843]
000001e3`ee623f30  00007fff`cde51a5a coreclr!PreStubWorker+0x37a [e:\a\_work\104\s\src\vm\prestub.cpp @ 1575]
000001e3`ee623f38  00007fff`cdf2dd05 coreclr!ThePreStub+0x55 [E:\A\_work\104\s\src\vm\amd64\ThePreStubAMD64.asm @ 22]
000001e3`ee623f40  00007fff`6e447685
000001e3`ee623f48  00000000`00000000
000001e3`ee623f50  00000000`00000000
000001e3`ee623f58  00000000`00000000
000001e3`ee623f60  00000000`00000000
000001e3`ee623f68  00000000`00000000
000001e3`ee623f70  00000000`00000000
000001e3`ee623f78  00000000`00000000
000001e3`ee623f80  00000000`00000000
000001e3`ee623f88  00000000`00000000
000001e3`ee623f90  00000000`00000000
000001e3`ee623f98  00000000`00000000
000001e3`ee623fa0  00000000`00000000
000001e3`ee623fa8  00000000`00000000
000001e3`ee623fb0  00000000`00000000
000001e3`ee623fb8  00000000`00000000
000001e3`ee623fc0  00000000`00000000
000001e3`ee623fc8  00000000`00000000
000001e3`ee623fd0  00000000`00000000
000001e3`ee623fd8  00000000`00000000
000001e3`ee623fe0  00000000`00000000
000001e3`ee623fe8  00000000`00000000
000001e3`ee623ff0  00000000`00000000
000001e3`ee623ff8  00000000`00000000

```
**&gt;  !list -t ntdll!_LIST_ENTRY.Flink -x "dps poi(" -a "-8) l 0n32" 000001E3F48D9FE8**
```
000001e3`f48d7f00  00007ff8`2f61e97f vfbasics!AVrfpRoUninitialize+0x1f [onecore\base\avrf\vrfcommon\threadpool.c @ 4118]
000001e3`f48d7f08  00007fff`cddd3cea coreclr!Thread::SetApartment+0x1f2 [e:\a\_work\104\s\src\vm\threads.cpp @ 5359]
000001e3`f48d7f10  00007fff`cddd3e6e coreclr!EnsureComStarted+0x6a [e:\a\_work\104\s\src\vm\interoputil.cpp @ 2395]
000001e3`f48d7f18  00007fff`cdeb1c56 coreclr!GetStubForInteropMethod+0x112 [e:\a\_work\104\s\src\vm\dllimport.cpp @ 5489]
000001e3`f48d7f20  00007fff`cde526ef coreclr!MethodDesc::DoPrestub+0xb3f [e:\a\_work\104\s\src\vm\prestub.cpp @ 1843]
000001e3`f48d7f28  00007fff`cde51a5a coreclr!PreStubWorker+0x37a [e:\a\_work\104\s\src\vm\prestub.cpp @ 1575]
000001e3`f48d7f30  00007fff`cdf2dd05 coreclr!ThePreStub+0x55 [E:\A\_work\104\s\src\vm\amd64\ThePreStubAMD64.asm @ 22]
000001e3`f48d7f38  00007fff`6e447685
000001e3`f48d7f40  00000000`00000000
000001e3`f48d7f48  00000000`00000000
000001e3`f48d7f50  00000000`00000000
000001e3`f48d7f58  00000000`00000000
000001e3`f48d7f60  00000000`00000000
000001e3`f48d7f68  00000000`00000000
000001e3`f48d7f70  00000000`00000000
000001e3`f48d7f78  00000000`00000000
000001e3`f48d7f80  00000000`00000000
000001e3`f48d7f88  00000000`00000000
000001e3`f48d7f90  00000000`00000000
000001e3`f48d7f98  00000000`00000000
000001e3`f48d7fa0  00000000`00000000
000001e3`f48d7fa8  00000000`00000000
000001e3`f48d7fb0  00000000`00000000
000001e3`f48d7fb8  00000000`00000000
000001e3`f48d7fc0  00000000`00000000
000001e3`f48d7fc8  00000000`00000000
000001e3`f48d7fd0  00000000`00000000
000001e3`f48d7fd8  00000000`00000000
000001e3`f48d7fe0  00000000`00000000
000001e3`f48d7fe8  00000000`00000000
000001e3`f48d7ff0  00000000`00000000
000001e3`f48d7ff8  00000000`00000000
```

```
    Loaded symbol image file: coreclr.dll
    Image path: C:\Users\pakrymet\.dotnet\x64\shared\Microsoft.NETCore.App\2.2.0-preview1-26618-02\coreclr.dll
    Image name: coreclr.dll
    Browse all global symbols  functions  data
    Timestamp:        Sat Jun 16 04:11:02 2018 (5B24F046)
    CheckSum:         005B2F47
    ImageSize:        005C3000
    File version:     4.6.26616.3
    Product version:  4.6.26616.3
    File flags:       8 (Mask 3F) Private
    File OS:          4 Unknown Win32
    File type:        0.0 Unknown
    File date:        00000000.00000000
    Translations:     0409.04b0
    Information from resource tables:
        CompanyName:      Microsoft Corporation
        ProductName:      Microsoft® .NET Core
        InternalName:     CoreCLR.dll
        OriginalFilename: CoreCLR.dll
        ProductVersion:   4.6.26616.03 @BuiltBy: dlab14-DDVSOWINAGE101 @Branch: master @SrcCode: https://github.com/dotnet/coreclr/tree/45da72ca0f1493f793e30f39a7da0e59acb8bdbc
        FileVersion:      4.6.26616.03 @BuiltBy: dlab14-DDVSOWINAGE101 @Branch: master @SrcCode: https://github.com/dotnet/coreclr/tree/45da72ca0f1493f793e30f39a7da0e59acb8bdbc
        PrivateBuild:     FX_VER_PRIVATEBUILD_STR
        FileDescription:  Microsoft .NET Runtime
        LegalCopyright:   © Microsoft Corporation.  All rights reserved.
        Comments:         Flavor=Retail
```</Description>
    <Title_Description>AppVerifier reports CoInitialize leak in coreclr Sometimes we get `CoInitialize leak` reported in coreclr while running AspNetCoreModule tests with AppVerifier.

CoreClr is being hosted inside iisexpress process in this case. It's doesn't happen in all the tests so I'm not sure it's something wrong we do or issues with coreclr.

Dump: `\\pkrymets\exchange\coinit\coinit2.cab `

Some details from the dump:

```
    Description3 = 0x000000d5`6deffc60 "CoInitialize Stacks.!list -t ntdll!_LIST_ENTRY.Flink -x "dps poi(" -a "-8) l 0n32" 000001E3E2896FE8"
          Param4 = 0x000001e3`f48d9fe8
    Description4 = 0x000000d5`6deffb90 "CoUninitialize Stacks. use above cmd with 000001E3F48D9FE8"

```

**&gt; !list -t ntdll!_LIST_ENTRY.Flink -x "dps poi(" -a "-8) l 0n32" 000001E3E2896FE8**
```
000001e3`e94fff00  00007ff8`479c9055 combase!_CoInitializeEx+0x1d9 [onecore\com\combase\class\compobj.cxx @ 3872]
000001e3`e94fff08  00007ff8`479c8c26 combase!CoInitializeEx+0x36 [onecore\com\combase\class\compobj.cxx @ 3905]
000001e3`e94fff10  00007ff8`2f61e7bf vfbasics!AVrfpCoInitializeEx+0x2f [onecore\base\avrf\vrfcommon\threadpool.c @ 3974]
000001e3`e94fff18  00007fff`cddd3bc3 coreclr!Thread::SetApartment+0xcb [e:\a\_work\104\s\src\vm\threads.cpp @ 5279]
000001e3`e94fff20  00007fff`cddd3e6e coreclr!EnsureComStarted+0x6a [e:\a\_work\104\s\src\vm\interoputil.cpp @ 2395]
000001e3`e94fff28  00007fff`cdeb1c56 coreclr!GetStubForInteropMethod+0x112 [e:\a\_work\104\s\src\vm\dllimport.cpp @ 5489]
000001e3`e94fff30  00007fff`cde526ef coreclr!MethodDesc::DoPrestub+0xb3f [e:\a\_work\104\s\src\vm\prestub.cpp @ 1843]
000001e3`e94fff38  00007fff`cde51a5a coreclr!PreStubWorker+0x37a [e:\a\_work\104\s\src\vm\prestub.cpp @ 1575]
000001e3`e94fff40  00007fff`cdf2dd05 coreclr!ThePreStub+0x55 [E:\A\_work\104\s\src\vm\amd64\ThePreStubAMD64.asm @ 22]
000001e3`e94fff48  00007fff`6e447685
000001e3`e94fff50  00000000`00000000
000001e3`e94fff58  00000000`00000000
000001e3`e94fff60  00000000`00000000
000001e3`e94fff68  00000000`00000000
000001e3`e94fff70  00000000`00000000
000001e3`e94fff78  00000000`00000000
000001e3`e94fff80  00000000`00000000
000001e3`e94fff88  00000000`00000000
000001e3`e94fff90  00000000`00000000
000001e3`e94fff98  00000000`00000000
000001e3`e94fffa0  00000000`00000000
000001e3`e94fffa8  00000000`00000000
000001e3`e94fffb0  00000000`00000000
000001e3`e94fffb8  00000000`00000000
000001e3`e94fffc0  00000000`00000000
000001e3`e94fffc8  00000000`00000000
000001e3`e94fffd0  00000000`00000000
000001e3`e94fffd8  00000000`00000000
000001e3`e94fffe0  00000000`00000000
000001e3`e94fffe8  00000000`00000000
000001e3`e94ffff0  00000000`00000000
000001e3`e94ffff8  00000000`00000000

000001e3`ee623f00  00007ff8`479c9055 combase!_CoInitializeEx+0x1d9 [onecore\com\combase\class\compobj.cxx @ 3872]
000001e3`ee623f08  00007ff8`2f61e8f5 vfbasics!AVrfpRoInitialize+0x25 [onecore\base\avrf\vrfcommon\threadpool.c @ 4070]
000001e3`ee623f10  00007fff`cddd3cd6 coreclr!Thread::SetApartment+0x1de [e:\a\_work\104\s\src\vm\threads.cpp @ 5346]
000001e3`ee623f18  00007fff`cddd3e6e coreclr!EnsureComStarted+0x6a [e:\a\_work\104\s\src\vm\interoputil.cpp @ 2395]
000001e3`ee623f20  00007fff`cdeb1c56 coreclr!GetStubForInteropMethod+0x112 [e:\a\_work\104\s\src\vm\dllimport.cpp @ 5489]
000001e3`ee623f28  00007fff`cde526ef coreclr!MethodDesc::DoPrestub+0xb3f [e:\a\_work\104\s\src\vm\prestub.cpp @ 1843]
000001e3`ee623f30  00007fff`cde51a5a coreclr!PreStubWorker+0x37a [e:\a\_work\104\s\src\vm\prestub.cpp @ 1575]
000001e3`ee623f38  00007fff`cdf2dd05 coreclr!ThePreStub+0x55 [E:\A\_work\104\s\src\vm\amd64\ThePreStubAMD64.asm @ 22]
000001e3`ee623f40  00007fff`6e447685
000001e3`ee623f48  00000000`00000000
000001e3`ee623f50  00000000`00000000
000001e3`ee623f58  00000000`00000000
000001e3`ee623f60  00000000`00000000
000001e3`ee623f68  00000000`00000000
000001e3`ee623f70  00000000`00000000
000001e3`ee623f78  00000000`00000000
000001e3`ee623f80  00000000`00000000
000001e3`ee623f88  00000000`00000000
000001e3`ee623f90  00000000`00000000
000001e3`ee623f98  00000000`00000000
000001e3`ee623fa0  00000000`00000000
000001e3`ee623fa8  00000000`00000000
000001e3`ee623fb0  00000000`00000000
000001e3`ee623fb8  00000000`00000000
000001e3`ee623fc0  00000000`00000000
000001e3`ee623fc8  00000000`00000000
000001e3`ee623fd0  00000000`00000000
000001e3`ee623fd8  00000000`00000000
000001e3`ee623fe0  00000000`00000000
000001e3`ee623fe8  00000000`00000000
000001e3`ee623ff0  00000000`00000000
000001e3`ee623ff8  00000000`00000000

```
**&gt;  !list -t ntdll!_LIST_ENTRY.Flink -x "dps poi(" -a "-8) l 0n32" 000001E3F48D9FE8**
```
000001e3`f48d7f00  00007ff8`2f61e97f vfbasics!AVrfpRoUninitialize+0x1f [onecore\base\avrf\vrfcommon\threadpool.c @ 4118]
000001e3`f48d7f08  00007fff`cddd3cea coreclr!Thread::SetApartment+0x1f2 [e:\a\_work\104\s\src\vm\threads.cpp @ 5359]
000001e3`f48d7f10  00007fff`cddd3e6e coreclr!EnsureComStarted+0x6a [e:\a\_work\104\s\src\vm\interoputil.cpp @ 2395]
000001e3`f48d7f18  00007fff`cdeb1c56 coreclr!GetStubForInteropMethod+0x112 [e:\a\_work\104\s\src\vm\dllimport.cpp @ 5489]
000001e3`f48d7f20  00007fff`cde526ef coreclr!MethodDesc::DoPrestub+0xb3f [e:\a\_work\104\s\src\vm\prestub.cpp @ 1843]
000001e3`f48d7f28  00007fff`cde51a5a coreclr!PreStubWorker+0x37a [e:\a\_work\104\s\src\vm\prestub.cpp @ 1575]
000001e3`f48d7f30  00007fff`cdf2dd05 coreclr!ThePreStub+0x55 [E:\A\_work\104\s\src\vm\amd64\ThePreStubAMD64.asm @ 22]
000001e3`f48d7f38  00007fff`6e447685
000001e3`f48d7f40  00000000`00000000
000001e3`f48d7f48  00000000`00000000
000001e3`f48d7f50  00000000`00000000
000001e3`f48d7f58  00000000`00000000
000001e3`f48d7f60  00000000`00000000
000001e3`f48d7f68  00000000`00000000
000001e3`f48d7f70  00000000`00000000
000001e3`f48d7f78  00000000`00000000
000001e3`f48d7f80  00000000`00000000
000001e3`f48d7f88  00000000`00000000
000001e3`f48d7f90  00000000`00000000
000001e3`f48d7f98  00000000`00000000
000001e3`f48d7fa0  00000000`00000000
000001e3`f48d7fa8  00000000`00000000
000001e3`f48d7fb0  00000000`00000000
000001e3`f48d7fb8  00000000`00000000
000001e3`f48d7fc0  00000000`00000000
000001e3`f48d7fc8  00000000`00000000
000001e3`f48d7fd0  00000000`00000000
000001e3`f48d7fd8  00000000`00000000
000001e3`f48d7fe0  00000000`00000000
000001e3`f48d7fe8  00000000`00000000
000001e3`f48d7ff0  00000000`00000000
000001e3`f48d7ff8  00000000`00000000
```

```
    Loaded symbol image file: coreclr.dll
    Image path: C:\Users\pakrymet\.dotnet\x64\shared\Microsoft.NETCore.App\2.2.0-preview1-26618-02\coreclr.dll
    Image name: coreclr.dll
    Browse all global symbols  functions  data
    Timestamp:        Sat Jun 16 04:11:02 2018 (5B24F046)
    CheckSum:         005B2F47
    ImageSize:        005C3000
    File version:     4.6.26616.3
    Product version:  4.6.26616.3
    File flags:       8 (Mask 3F) Private
    File OS:          4 Unknown Win32
    File type:        0.0 Unknown
    File date:        00000000.00000000
    Translations:     0409.04b0
    Information from resource tables:
        CompanyName:      Microsoft Corporation
        ProductName:      Microsoft® .NET Core
        InternalName:     CoreCLR.dll
        OriginalFilename: CoreCLR.dll
        ProductVersion:   4.6.26616.03 @BuiltBy: dlab14-DDVSOWINAGE101 @Branch: master @SrcCode: https://github.com/dotnet/coreclr/tree/45da72ca0f1493f793e30f39a7da0e59acb8bdbc
        FileVersion:      4.6.26616.03 @BuiltBy: dlab14-DDVSOWINAGE101 @Branch: master @SrcCode: https://github.com/dotnet/coreclr/tree/45da72ca0f1493f793e30f39a7da0e59acb8bdbc
        PrivateBuild:     FX_VER_PRIVATEBUILD_STR
        FileDescription:  Microsoft .NET Runtime
        LegalCopyright:   © Microsoft Corporation.  All rights reserved.
        Comments:         Flavor=Retail
```</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>23/08/2018 10:44:50 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19640</IssueLabelID>
    <Title>Workaround to remove unnecessary bounds checks when using {ReadOnly}Span.IsEmpty</Title>
    <Description>Workaround for https://github.com/dotnet/coreclr/issues/19620

```C#
public static bool IsFirstSpace(ReadOnlySpan&lt;byte&gt; buffer)
{
    if (buffer.IsEmpty || buffer[0] != ' ')
        return false;
    return true;
}
```

Disassembly for before/after:
![image](https://user-images.githubusercontent.com/6527137/44555124-90fe2b80-a6e8-11e8-882a-c2504ed34924.png)


cc @AndyAyersMS @benaadams @GrabYourPitchforks @mikedn  
</Description>
    <Title_Description>Workaround to remove unnecessary bounds checks when using {ReadOnly}Span.IsEmpty Workaround for https://github.com/dotnet/coreclr/issues/19620

```C#
public static bool IsFirstSpace(ReadOnlySpan&lt;byte&gt; buffer)
{
    if (buffer.IsEmpty || buffer[0] != ' ')
        return false;
    return true;
}
```

Disassembly for before/after:
![image](https://user-images.githubusercontent.com/6527137/44555124-90fe2b80-a6e8-11e8-882a-c2504ed34924.png)


cc @AndyAyersMS @benaadams @GrabYourPitchforks @mikedn  
</Title_Description>
    <Label>area-System.Memory</Label>
    <Assignee>ahsonkhan</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19637</IssueLabelID>
    <Title>R2RDump CoreDisTools fails to decode on ARM</Title>
    <Description>Right now disasm works on all architectures except Arm. The TargetArch used by CoreDisTools is Target_Thumb but it reads an invalid assembly code and fails to decode it.

This does not happen in all cases. CoreDisTools worked for an Arm image generated for https://github.com/dotnet/coreclr/blob/master/tests/src/readytorun/r2rdump/files/GcInfoTransitions.cs but not for the other tests in https://github.com/dotnet/coreclr/tree/master/tests/src/readytorun/r2rdump/files</Description>
    <Title_Description>R2RDump CoreDisTools fails to decode on ARM Right now disasm works on all architectures except Arm. The TargetArch used by CoreDisTools is Target_Thumb but it reads an invalid assembly code and fails to decode it.

This does not happen in all cases. CoreDisTools worked for an Arm image generated for https://github.com/dotnet/coreclr/blob/master/tests/src/readytorun/r2rdump/files/GcInfoTransitions.cs but not for the other tests in https://github.com/dotnet/coreclr/tree/master/tests/src/readytorun/r2rdump/files</Title_Description>
    <Label>area-R2RDump</Label>
    <Assignee>acmyu</Assignee>
    <CreatedAt>23/08/2018 9:48:22 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19632</IssueLabelID>
    <Title>How do we debug this MissingMethodException ?</Title>
    <Description>Hello 
We are trying to update Sql Ops Studio to use a new set of SMO binaries (NetStandard) but one of our services crashes on startup with a MissingMethodException:
```
0:000&gt; !DumpObj /d 000001bd800ff478
Name:        System.MissingMethodException
MethodTable: 00007ff957466f78
EEClass:     00007ff956b301d0
Size:        168(0xa8) bytes
File:        C:\sqlops-windows\resources\app\extensions\mssql\sqltoolsservice\Windows\1.5.0-alpha.29\System.Private.CoreLib.dll
Fields:
              MT    Field   Offset                 Type VT     Attr            Value Name
00007ff95745f7c0  4000274        8        System.String  0 instance 0000000000000000 _className
00007ff9574640e0  4000275       10 ...ection.MethodBase  0 instance 0000000000000000 _exceptionMethod
00007ff95745f7c0  4000276       18        System.String  0 instance 000001bd80101f28 _message
00007ff9574327a8  4000277       20 ...tions.IDictionary  0 instance 0000000000000000 _data
00007ff957462d30  4000278       28     System.Exception  0 instance 0000000000000000 _innerException
00007ff95745f7c0  4000279       30        System.String  0 instance 0000000000000000 _helpURL
00007ff957460420  400027a       38        System.Object  0 instance 0000000000000000 _stackTrace
00007ff957460420  400027b       40        System.Object  0 instance 0000000000000000 _watsonBuckets
00007ff95745f7c0  400027c       48        System.String  0 instance 0000000000000000 _stackTraceString
00007ff95745f7c0  400027d       50        System.String  0 instance 0000000000000000 _remoteStackTraceString
00007ff957461978  400027e       78         System.Int32  1 instance                0 _remoteStackIndex
00007ff957460420  400027f       58        System.Object  0 instance 0000000000000000 _dynamicMethods
00007ff957461978  4000280       7c         System.Int32  1 instance      -2146233069 _HResult
00007ff95745f7c0  4000281       60        System.String  0 instance 0000000000000000 _source
00007ff957476dd8  4000282       68        System.IntPtr  1 instance                0 _xptrs
00007ff957461978  4000283       80         System.Int32  1 instance       -532462766 _xcode
00007ff9574783b8  4000284       70       System.UIntPtr  1 instance                0 _ipForWatsonBuckets
00007ff957460420  4000273       78        System.Object  0   shared           static s_EDILock
                                 &gt;&gt; Domain:Value  000001bde655ce70:NotInit  &lt;&lt;
00007ff95745f7c0  4000337       88        System.String  0 instance 0000000000000000 ClassName
00007ff95745f7c0  4000338       90        System.String  0 instance 0000000000000000 MemberName
00007ff9574463b0  4000339       98        System.Byte[]  0 instance 0000000000000000 Signature
0:000&gt; !DumpObj /d 000001bd80101f28
Name:        System.String
MethodTable: 00007ff95745f7c0
EEClass:     00007ff956b2ad30
Size:        302(0x12e) bytes
File:        C:\sqlops-windows\resources\app\extensions\mssql\sqltoolsservice\Windows\1.5.0-alpha.29\System.Private.CoreLib.dll
String:      Method not found: 'Void Microsoft.SqlServer.Management.Sdk.Sfc.ISqlSmoObjectInitialize.InitializeFromDataReader(System.Data.IDataReader)'.
Fields:
              MT    Field   Offset                 Type VT     Attr            Value Name
00007ff957461978  400026c        8         System.Int32  1 instance              138 _stringLength
00007ff957461518  400026d        c          System.Char  1 instance               4d _firstChar
00007ff95745f7c0  400026e       70        System.String  0   shared           static Empty
                                 &gt;&gt; Domain:Value  000001bde655ce70:NotInit  &lt;&lt;
```

It appears to omit ClassName/MemberName/Signature properties from the exception so I can't tell if there's a particular concrete class that is supposedly not implementing this member of the interface or if the method is missing from the interface itself somehow. 

The exception is thrown during dynamic extension loading via System.Composition and is aggregated into a ReflectionTypeLoadException as one of its LoaderExceptions:
```
0:000&gt; k
 # Child-SP          RetAddr           Call Site
00 00000022`1af7d0b0 00007ff9`577525b0 KERNELBASE!RaiseException+0x68 [minkernel\kernelbase\xcpt.c @ 922]
01 00000022`1af7d190 00007ff9`578feb5f coreclr!RaiseTheExceptionInternalOnly+0x2fc [e:\a\_work\31\s\src\vm\excep.cpp @ 2996]
02 00000022`1af7d2d0 00007ff9`578fec05 coreclr!RaiseTheException+0xb3 [e:\a\_work\31\s\src\vm\excep.cpp @ 2830]
03 (Inline Function) --------`-------- coreclr!RealCOMPlusThrowWorker+0x29 [e:\a\_work\31\s\src\vm\excep.cpp @ 3085]
04 00000022`1af7d310 00007ff9`578fec14 coreclr!RealCOMPlusThrow+0xa5 [e:\a\_work\31\s\src\vm\excep.cpp @ 3122]
05 00000022`1af7d380 00007ff9`578a41b8 coreclr!RealCOMPlusThrow+0xc [e:\a\_work\31\s\src\vm\excep.cpp @ 3145]
06 00000022`1af7d3b0 00007ff9`577c343c coreclr!GetTypesInner+0xe0d18 [e:\a\_work\31\s\src\vm\commodule.cpp @ 1110]
07 00000022`1af7d650 00007ff9`570f74d2 coreclr!COMModule::GetTypes+0xbc [e:\a\_work\31\s\src\vm\commodule.cpp @ 995]
08 00000022`1af7d7c0 00007ff8`f7d0f0e3 System_Private_CoreLib!System.Reflection.RuntimeAssembly.get_DefinedTypes()+0x62 [E:\A\_work\31\s\src\mscorlib\src\System\Reflection\RuntimeAssembly.cs @ 197]
09 00000022`1af7d810 00007ff9`5fe4eada System_Composition_TypedParts!System.Composition.Hosting.ContainerConfiguration+&lt;&gt;c.&lt;WithAssemblies&gt;b__16_0(System.Reflection.Assembly)+0x13 [E:\A\_work\500\s\corefx\src\System.Composition.TypedParts\src\System\Composition\Hosting\ContainerConfiguration.cs @ 203]
0a 00000022`1af7d850 00007ff8`f7d0eeda System_Linq!System.Linq.Enumerable+SelectManySingleSelectorIterator`2[[System.__Canon System.Private.CoreLib][System.__Canon System.Private.CoreLib]].MoveNext()+0xaa [E:\A\_work\20\s\corefx\src\System.Linq\src\System\Linq\SelectMany.cs @ 204]
0b 00000022`1af7d8a0 00007ff8`f7d0e8c4 System_Composition_TypedParts!System.Composition.TypedParts.TypedPartExportDescriptorProvider..ctor(System.Collections.Generic.IEnumerable`1&lt;System.Type&gt; System.Composition.Convention.AttributedModelProvider)+0x10a [E:\A\_work\500\s\corefx\src\System.Composition.TypedParts\src\System\Composition\TypedParts\TypedPartExportDescriptorProvider.cs @ 24]
0c 00000022`1af7d910 00007ff8`f7d0d75e System_Composition_TypedParts!System.Composition.Hosting.ContainerConfiguration.CreateContainer()+0xc4 [E:\A\_work\500\s\corefx\src\System.Composition.TypedParts\src\System\Composition\Hosting\ContainerConfiguration.cs @ 40]
0d 00000022`1af7d980 00007ff8`f7d0d673 Microsoft_SqlTools_Hosting!Microsoft.SqlTools.Extensibility.ExtensionStore..ctor(System.Type System.Func`2&lt;System.Composition.Convention.ConventionBuilderSystem.Composition.Hosting.ContainerConfiguration&gt;)+0x3e*** ERROR: Module load completed but symbols could not be loaded for C:\sqlops-windows\resources\app\extensions\mssql\sqltoolsservice\Windows\1.5.0-alpha.29\Microsoft.SqlTools.Hosting.dll
```

I tried setting a breakpoint on MemberLoader:ThrowMissingMethodException but the optimized native code doesn't lend itself to debugging. I didn't find anything more useful than what is already in the message.
</Description>
    <Title_Description>How do we debug this MissingMethodException ? Hello 
We are trying to update Sql Ops Studio to use a new set of SMO binaries (NetStandard) but one of our services crashes on startup with a MissingMethodException:
```
0:000&gt; !DumpObj /d 000001bd800ff478
Name:        System.MissingMethodException
MethodTable: 00007ff957466f78
EEClass:     00007ff956b301d0
Size:        168(0xa8) bytes
File:        C:\sqlops-windows\resources\app\extensions\mssql\sqltoolsservice\Windows\1.5.0-alpha.29\System.Private.CoreLib.dll
Fields:
              MT    Field   Offset                 Type VT     Attr            Value Name
00007ff95745f7c0  4000274        8        System.String  0 instance 0000000000000000 _className
00007ff9574640e0  4000275       10 ...ection.MethodBase  0 instance 0000000000000000 _exceptionMethod
00007ff95745f7c0  4000276       18        System.String  0 instance 000001bd80101f28 _message
00007ff9574327a8  4000277       20 ...tions.IDictionary  0 instance 0000000000000000 _data
00007ff957462d30  4000278       28     System.Exception  0 instance 0000000000000000 _innerException
00007ff95745f7c0  4000279       30        System.String  0 instance 0000000000000000 _helpURL
00007ff957460420  400027a       38        System.Object  0 instance 0000000000000000 _stackTrace
00007ff957460420  400027b       40        System.Object  0 instance 0000000000000000 _watsonBuckets
00007ff95745f7c0  400027c       48        System.String  0 instance 0000000000000000 _stackTraceString
00007ff95745f7c0  400027d       50        System.String  0 instance 0000000000000000 _remoteStackTraceString
00007ff957461978  400027e       78         System.Int32  1 instance                0 _remoteStackIndex
00007ff957460420  400027f       58        System.Object  0 instance 0000000000000000 _dynamicMethods
00007ff957461978  4000280       7c         System.Int32  1 instance      -2146233069 _HResult
00007ff95745f7c0  4000281       60        System.String  0 instance 0000000000000000 _source
00007ff957476dd8  4000282       68        System.IntPtr  1 instance                0 _xptrs
00007ff957461978  4000283       80         System.Int32  1 instance       -532462766 _xcode
00007ff9574783b8  4000284       70       System.UIntPtr  1 instance                0 _ipForWatsonBuckets
00007ff957460420  4000273       78        System.Object  0   shared           static s_EDILock
                                 &gt;&gt; Domain:Value  000001bde655ce70:NotInit  &lt;&lt;
00007ff95745f7c0  4000337       88        System.String  0 instance 0000000000000000 ClassName
00007ff95745f7c0  4000338       90        System.String  0 instance 0000000000000000 MemberName
00007ff9574463b0  4000339       98        System.Byte[]  0 instance 0000000000000000 Signature
0:000&gt; !DumpObj /d 000001bd80101f28
Name:        System.String
MethodTable: 00007ff95745f7c0
EEClass:     00007ff956b2ad30
Size:        302(0x12e) bytes
File:        C:\sqlops-windows\resources\app\extensions\mssql\sqltoolsservice\Windows\1.5.0-alpha.29\System.Private.CoreLib.dll
String:      Method not found: 'Void Microsoft.SqlServer.Management.Sdk.Sfc.ISqlSmoObjectInitialize.InitializeFromDataReader(System.Data.IDataReader)'.
Fields:
              MT    Field   Offset                 Type VT     Attr            Value Name
00007ff957461978  400026c        8         System.Int32  1 instance              138 _stringLength
00007ff957461518  400026d        c          System.Char  1 instance               4d _firstChar
00007ff95745f7c0  400026e       70        System.String  0   shared           static Empty
                                 &gt;&gt; Domain:Value  000001bde655ce70:NotInit  &lt;&lt;
```

It appears to omit ClassName/MemberName/Signature properties from the exception so I can't tell if there's a particular concrete class that is supposedly not implementing this member of the interface or if the method is missing from the interface itself somehow. 

The exception is thrown during dynamic extension loading via System.Composition and is aggregated into a ReflectionTypeLoadException as one of its LoaderExceptions:
```
0:000&gt; k
 # Child-SP          RetAddr           Call Site
00 00000022`1af7d0b0 00007ff9`577525b0 KERNELBASE!RaiseException+0x68 [minkernel\kernelbase\xcpt.c @ 922]
01 00000022`1af7d190 00007ff9`578feb5f coreclr!RaiseTheExceptionInternalOnly+0x2fc [e:\a\_work\31\s\src\vm\excep.cpp @ 2996]
02 00000022`1af7d2d0 00007ff9`578fec05 coreclr!RaiseTheException+0xb3 [e:\a\_work\31\s\src\vm\excep.cpp @ 2830]
03 (Inline Function) --------`-------- coreclr!RealCOMPlusThrowWorker+0x29 [e:\a\_work\31\s\src\vm\excep.cpp @ 3085]
04 00000022`1af7d310 00007ff9`578fec14 coreclr!RealCOMPlusThrow+0xa5 [e:\a\_work\31\s\src\vm\excep.cpp @ 3122]
05 00000022`1af7d380 00007ff9`578a41b8 coreclr!RealCOMPlusThrow+0xc [e:\a\_work\31\s\src\vm\excep.cpp @ 3145]
06 00000022`1af7d3b0 00007ff9`577c343c coreclr!GetTypesInner+0xe0d18 [e:\a\_work\31\s\src\vm\commodule.cpp @ 1110]
07 00000022`1af7d650 00007ff9`570f74d2 coreclr!COMModule::GetTypes+0xbc [e:\a\_work\31\s\src\vm\commodule.cpp @ 995]
08 00000022`1af7d7c0 00007ff8`f7d0f0e3 System_Private_CoreLib!System.Reflection.RuntimeAssembly.get_DefinedTypes()+0x62 [E:\A\_work\31\s\src\mscorlib\src\System\Reflection\RuntimeAssembly.cs @ 197]
09 00000022`1af7d810 00007ff9`5fe4eada System_Composition_TypedParts!System.Composition.Hosting.ContainerConfiguration+&lt;&gt;c.&lt;WithAssemblies&gt;b__16_0(System.Reflection.Assembly)+0x13 [E:\A\_work\500\s\corefx\src\System.Composition.TypedParts\src\System\Composition\Hosting\ContainerConfiguration.cs @ 203]
0a 00000022`1af7d850 00007ff8`f7d0eeda System_Linq!System.Linq.Enumerable+SelectManySingleSelectorIterator`2[[System.__Canon System.Private.CoreLib][System.__Canon System.Private.CoreLib]].MoveNext()+0xaa [E:\A\_work\20\s\corefx\src\System.Linq\src\System\Linq\SelectMany.cs @ 204]
0b 00000022`1af7d8a0 00007ff8`f7d0e8c4 System_Composition_TypedParts!System.Composition.TypedParts.TypedPartExportDescriptorProvider..ctor(System.Collections.Generic.IEnumerable`1&lt;System.Type&gt; System.Composition.Convention.AttributedModelProvider)+0x10a [E:\A\_work\500\s\corefx\src\System.Composition.TypedParts\src\System\Composition\TypedParts\TypedPartExportDescriptorProvider.cs @ 24]
0c 00000022`1af7d910 00007ff8`f7d0d75e System_Composition_TypedParts!System.Composition.Hosting.ContainerConfiguration.CreateContainer()+0xc4 [E:\A\_work\500\s\corefx\src\System.Composition.TypedParts\src\System\Composition\Hosting\ContainerConfiguration.cs @ 40]
0d 00000022`1af7d980 00007ff8`f7d0d673 Microsoft_SqlTools_Hosting!Microsoft.SqlTools.Extensibility.ExtensionStore..ctor(System.Type System.Func`2&lt;System.Composition.Convention.ConventionBuilderSystem.Composition.Hosting.ContainerConfiguration&gt;)+0x3e*** ERROR: Module load completed but symbols could not be loaded for C:\sqlops-windows\resources\app\extensions\mssql\sqltoolsservice\Windows\1.5.0-alpha.29\Microsoft.SqlTools.Hosting.dll
```

I tried setting a breakpoint on MemberLoader:ThrowMissingMethodException but the optimized native code doesn't lend itself to debugging. I didn't find anything more useful than what is already in the message.
</Title_Description>
    <Label>area-AssemblyLoader</Label>
    <Assignee>vitek-karas</Assignee>
    <CreatedAt>23/08/2018 5:27:26 PM +00:00</CreatedAt>
    <ClosedAt>21/09/2018 8:38:14 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19630</IssueLabelID>
    <Title>WIP NO-MERGE dummy change to test dev/unix_test_workflow</Title>
    <Description>
    </Description>
    <Title_Description>WIP NO-MERGE dummy change to test dev/unix_test_workflow </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>23/08/2018 4:38:49 PM +00:00</CreatedAt>
    <ClosedAt>28/08/2018 10:54:29 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19628</IssueLabelID>
    <Title>Sub-optimal code when the operation "% 1" on integers is met</Title>
    <Description>Currently the CLR gives result "0" (which seems correct) for "remainder of 1" operation on integers.

&gt; The formula `a % b` will always return a value on the range `(-b b)` exclusive (it can never return `b` or `-b`) keeping the sign of the dividend. For integer division the remainder operator satisfies the rule `a % b = a - (a / b) * b`. This is not to be confused with canonical modulus which satisfies a similar rule but with floored division and returns values on the range `[0 b)`. C# does not have an operator for canonical modulus. However the behavior is the same for positive dividends.

For `b = 1` the resulting range is obviously `(-1; 1)` ==&gt; just plain `0`.

However it looks like there is some space for improvements in JIT codegen since JIT does not seem to fold the result of evaluation to zero constant which prohibits further optimizations - see the repro code below.

To my understanding **ALL** `% 1` operations can be folded to just use constant values with maybe notable exception when the memory read and/or write is required to observe some side effects (eg. volatile variables). For signed integers obtained directly or indirectly (thru implicit type convertion to `Int32`) the code looks quite verbose given that the result is known ahead. It's better for `UInt32` and `UInt64` where `AND r/m 0` is issued but of these `AND [m] 0` only makes sense when again side effects are to be observed. I don't see any reason for `AND r 0` - this loads CPU scheduler much more than `XOR r r`.

Understanding that `% 1` does not often occur in the code here's real case when it may appear (happened to me). Say there is ring buffer with `N` items and that `N` is provided externally - either thru `static readonly` field (resolve during runtime) or thru `const` definition (resolve during compile time). To calculate the slot index for current or next item the `% N` opration is used. Since in degenerate case that `N` can be set to `1` there is desire to reduce all related calculations when there's just one slot for everything. At the moment additional checks placed manually are required and that provides more IL which reduces inlineability for methods.

------------------------------

The repro code:
```
static sbyte i8 = sbyte.MinValue;
static byte u8 = byte.MaxValue;
static short i16 = short.MinValue;
static ushort u16 = ushort.MaxValue;
static int i32 = int.MinValue;
static uint u32 = uint.MaxValue;
static long i64 = long.MinValue;
static ulong u64 = ulong.MaxValue;

static void Main(string[] args)
{
    // Test with m.loc.
    i8 %= (sbyte)1;
    i16 %= (short)1;
    i32 %= (int)1;
    i64 %= (long)1;

    // Test with r.loc.
    Console.WriteLine((sbyte)(i8 + i8) % (sbyte)1);
    Console.WriteLine((short)(i16 + i16) % (short)1);
    Console.WriteLine((int)(i32 + i32) % (int)1);
    Console.WriteLine((long)(i64 + i64) % (long)1);

    // Test with m.loc.
    u8 %= (byte)1;
    u16 %= (ushort)1;
    u32 %= (uint)1;
    u64 %= (ulong)1;

    // Test with r.loc.
    Console.WriteLine((byte)(u8 + u8) % (byte)1);
    Console.WriteLine((ushort)(u16 + u16) % (ushort)1);
    Console.WriteLine((uint)(u32 + u32) % (uint)1);
    Console.WriteLine((ulong)(u64 + u64) % (ulong)1);
}
```
-----------------
The disasm:
```
--- ...\Program2.cs ---
    i8 %= (sbyte)1;
000007FE749F1450  sub         rsp28h  
000007FE749F1454  mov         rcx7FE748D4B30h  
000007FE749F145E  mov         edx1  
000007FE749F1463  call        000007FED44D04F0  

    // Test with m.loc.
    i8 %= (sbyte)1;
000007FE749F1468  movsx       rcxbyte ptr [7FE748D4B84h]  
000007FE749F1470  mov         eaxecx  
000007FE749F1472  sar         eax1Fh  
000007FE749F1475  and         eax0  
000007FE749F1478  add         eaxecx  
000007FE749F147A  and         eax0FFFFFFFFh  
000007FE749F147D  sub         ecxeax  
000007FE749F147F  movsx       rcxcl  
000007FE749F1483  mov         byte ptr [7FE748D4B84h]cl  

    i16 %= (short)1;
000007FE749F1489  movsx       rcxword ptr [7FE748D4B80h]  
000007FE749F1491  mov         eaxecx  
000007FE749F1493  sar         eax1Fh  
000007FE749F1496  and         eax0  
000007FE749F1499  add         eaxecx  
000007FE749F149B  and         eax0FFFFFFFFh  
000007FE749F149E  sub         ecxeax  
000007FE749F14A0  movsx       rcxcx  
000007FE749F14A4  mov         word ptr [7FE748D4B80h]cx  

    i32 %= (int)1;
000007FE749F14AB  mov         ecxdword ptr [7FE748D4B78h]  
000007FE749F14B1  mov         eaxecx  
000007FE749F14B3  sar         eax1Fh  
000007FE749F14B6  and         eax0  
000007FE749F14B9  add         eaxecx  
000007FE749F14BB  and         eax0FFFFFFFFh  
000007FE749F14BE  sub         ecxeax  
000007FE749F14C0  mov         dword ptr [7FE748D4B78h]ecx  

    i64 %= (long)1;
000007FE749F14C6  mov         rcxqword ptr [7FE748D4B68h]  
000007FE749F14CD  mov         raxrcx  
000007FE749F14D0  sar         rax3Fh  
000007FE749F14D4  and         rax0  
000007FE749F14D8  add         raxrcx  
000007FE749F14DB  and         rax0FFFFFFFFFFFFFFFFh  
000007FE749F14DF  sub         rcxrax  
000007FE749F14E2  mov         qword ptr [7FE748D4B68h]rcx  

    // Test with r.loc.
    Console.WriteLine((sbyte)(i8 + i8) % (sbyte)1);
000007FE749F14E9  movsx       rcxbyte ptr [7FE748D4B84h]  
000007FE749F14F1  add         ecxecx  
000007FE749F14F3  movsx       rcxcl  
000007FE749F14F7  mov         eaxecx  
000007FE749F14F9  sar         eax1Fh  
000007FE749F14FC  and         eax0  
000007FE749F14FF  add         eaxecx  
000007FE749F1501  and         eax0FFFFFFFFh  
000007FE749F1504  sub         ecxeax  
000007FE749F1506  call        000007FE749F12D0  

    Console.WriteLine((short)(i16 + i16) % (short)1);
000007FE749F150B  movsx       rcxword ptr [7FE748D4B80h]  
000007FE749F1513  add         ecxecx  
000007FE749F1515  movsx       rcxcx  
000007FE749F1519  mov         eaxecx  
000007FE749F151B  sar         eax1Fh  
000007FE749F151E  and         eax0  
000007FE749F1521  add         eaxecx  
000007FE749F1523  and         eax0FFFFFFFFh  
000007FE749F1526  sub         ecxeax  
000007FE749F1528  call        000007FE749F12D0  

    Console.WriteLine((int)(i32 + i32) % (int)1);
000007FE749F152D  mov         ecxdword ptr [7FE748D4B78h]  
000007FE749F1533  add         ecxecx  
000007FE749F1535  mov         eaxecx  
000007FE749F1537  sar         eax1Fh  
000007FE749F153A  and         eax0  
000007FE749F153D  add         eaxecx  
000007FE749F153F  and         eax0FFFFFFFFh  
000007FE749F1542  sub         ecxeax  
000007FE749F1544  call        000007FE749F12D0  

    Console.WriteLine((long)(i64 + i64) % (long)1);
000007FE749F1549  mov         rcxqword ptr [7FE748D4B68h]  
000007FE749F1550  add         rcxrcx  
000007FE749F1553  mov         raxrcx  
000007FE749F1556  sar         rax3Fh  
000007FE749F155A  and         rax0  
000007FE749F155E  add         raxrcx  
000007FE749F1561  and         rax0FFFFFFFFFFFFFFFFh  
000007FE749F1565  sub         rcxrax  
000007FE749F1568  call        000007FE749F12E0  

    // Test with m.loc.
    u8 %= (byte)1;
000007FE749F156D  movzx       ecxbyte ptr [7FE748D4B85h]  
000007FE749F1574  mov         eaxecx  
000007FE749F1576  sar         eax1Fh  
000007FE749F1579  and         eax0  
000007FE749F157C  add         eaxecx  
000007FE749F157E  and         eax0FFFFFFFFh  
000007FE749F1581  sub         ecxeax  
000007FE749F1583  movzx       ecxcl  
000007FE749F1586  mov         byte ptr [7FE748D4B85h]cl  

    u16 %= (ushort)1;
000007FE749F158C  movzx       ecxword ptr [7FE748D4B82h]  
000007FE749F1593  mov         eaxecx  
000007FE749F1595  sar         eax1Fh  
000007FE749F1598  and         eax0  
000007FE749F159B  add         eaxecx  
000007FE749F159D  and         eax0FFFFFFFFh  
000007FE749F15A0  sub         ecxeax  
000007FE749F15A2  movzx       ecxcx  
000007FE749F15A5  mov         word ptr [7FE748D4B82h]cx  

    u32 %= (uint)1;
000007FE749F15AC  and         dword ptr [7FE748D4B7Ch]0  

    u64 %= (ulong)1;
000007FE749F15B3  and         qword ptr [7FE748D4B70h]0  

    // Test with r.loc.
    Console.WriteLine((byte)(u8 + u8) % (byte)1);
000007FE749F15BB  movzx       ecxbyte ptr [7FE748D4B85h]  
000007FE749F15C2  add         ecxecx  
000007FE749F15C4  movzx       ecxcl  
000007FE749F15C7  mov         eaxecx  
000007FE749F15C9  sar         eax1Fh  
000007FE749F15CC  and         eax0  
000007FE749F15CF  add         eaxecx  
000007FE749F15D1  and         eax0FFFFFFFFh  
000007FE749F15D4  sub         ecxeax  
000007FE749F15D6  call        000007FE749F12D0  

    Console.WriteLine((ushort)(u16 + u16) % (ushort)1);
000007FE749F15DB  movzx       ecxword ptr [7FE748D4B82h]  
000007FE749F15E2  add         ecxecx  
000007FE749F15E4  movzx       ecxcx  
000007FE749F15E7  mov         eaxecx  
000007FE749F15E9  sar         eax1Fh  
000007FE749F15EC  and         eax0  
000007FE749F15EF  add         eaxecx  
000007FE749F15F1  and         eax0FFFFFFFFh  
000007FE749F15F4  sub         ecxeax  
000007FE749F15F6  call        000007FE749F12D0  

    Console.WriteLine((uint)(u32 + u32) % (uint)1);
000007FE749F15FB  mov         ecxdword ptr [7FE748D4B7Ch]  
000007FE749F1601  add         ecxecx  
000007FE749F1603  and         ecx0  
000007FE749F1606  call        000007FE749F12D8  

    Console.WriteLine((ulong)(u64 + u64) % (ulong)1);
000007FE749F160B  mov         rcxqword ptr [7FE748D4B70h]  
000007FE749F1612  add         rcxrcx  
000007FE749F1615  and         rcx0  
000007FE749F1619  call        000007FE749F12E8  

000007FE749F161E  nop  
000007FE749F161F  add         rsp28h  
000007FE749F1623  ret  
--- No source file -------------------------------------------------------------
```

category:cq
theme:optimization
skill-level:beginner
cost:small</Description>
    <Title_Description>Sub-optimal code when the operation "% 1" on integers is met Currently the CLR gives result "0" (which seems correct) for "remainder of 1" operation on integers.

&gt; The formula `a % b` will always return a value on the range `(-b b)` exclusive (it can never return `b` or `-b`) keeping the sign of the dividend. For integer division the remainder operator satisfies the rule `a % b = a - (a / b) * b`. This is not to be confused with canonical modulus which satisfies a similar rule but with floored division and returns values on the range `[0 b)`. C# does not have an operator for canonical modulus. However the behavior is the same for positive dividends.

For `b = 1` the resulting range is obviously `(-1; 1)` ==&gt; just plain `0`.

However it looks like there is some space for improvements in JIT codegen since JIT does not seem to fold the result of evaluation to zero constant which prohibits further optimizations - see the repro code below.

To my understanding **ALL** `% 1` operations can be folded to just use constant values with maybe notable exception when the memory read and/or write is required to observe some side effects (eg. volatile variables). For signed integers obtained directly or indirectly (thru implicit type convertion to `Int32`) the code looks quite verbose given that the result is known ahead. It's better for `UInt32` and `UInt64` where `AND r/m 0` is issued but of these `AND [m] 0` only makes sense when again side effects are to be observed. I don't see any reason for `AND r 0` - this loads CPU scheduler much more than `XOR r r`.

Understanding that `% 1` does not often occur in the code here's real case when it may appear (happened to me). Say there is ring buffer with `N` items and that `N` is provided externally - either thru `static readonly` field (resolve during runtime) or thru `const` definition (resolve during compile time). To calculate the slot index for current or next item the `% N` opration is used. Since in degenerate case that `N` can be set to `1` there is desire to reduce all related calculations when there's just one slot for everything. At the moment additional checks placed manually are required and that provides more IL which reduces inlineability for methods.

------------------------------

The repro code:
```
static sbyte i8 = sbyte.MinValue;
static byte u8 = byte.MaxValue;
static short i16 = short.MinValue;
static ushort u16 = ushort.MaxValue;
static int i32 = int.MinValue;
static uint u32 = uint.MaxValue;
static long i64 = long.MinValue;
static ulong u64 = ulong.MaxValue;

static void Main(string[] args)
{
    // Test with m.loc.
    i8 %= (sbyte)1;
    i16 %= (short)1;
    i32 %= (int)1;
    i64 %= (long)1;

    // Test with r.loc.
    Console.WriteLine((sbyte)(i8 + i8) % (sbyte)1);
    Console.WriteLine((short)(i16 + i16) % (short)1);
    Console.WriteLine((int)(i32 + i32) % (int)1);
    Console.WriteLine((long)(i64 + i64) % (long)1);

    // Test with m.loc.
    u8 %= (byte)1;
    u16 %= (ushort)1;
    u32 %= (uint)1;
    u64 %= (ulong)1;

    // Test with r.loc.
    Console.WriteLine((byte)(u8 + u8) % (byte)1);
    Console.WriteLine((ushort)(u16 + u16) % (ushort)1);
    Console.WriteLine((uint)(u32 + u32) % (uint)1);
    Console.WriteLine((ulong)(u64 + u64) % (ulong)1);
}
```
-----------------
The disasm:
```
--- ...\Program2.cs ---
    i8 %= (sbyte)1;
000007FE749F1450  sub         rsp28h  
000007FE749F1454  mov         rcx7FE748D4B30h  
000007FE749F145E  mov         edx1  
000007FE749F1463  call        000007FED44D04F0  

    // Test with m.loc.
    i8 %= (sbyte)1;
000007FE749F1468  movsx       rcxbyte ptr [7FE748D4B84h]  
000007FE749F1470  mov         eaxecx  
000007FE749F1472  sar         eax1Fh  
000007FE749F1475  and         eax0  
000007FE749F1478  add         eaxecx  
000007FE749F147A  and         eax0FFFFFFFFh  
000007FE749F147D  sub         ecxeax  
000007FE749F147F  movsx       rcxcl  
000007FE749F1483  mov         byte ptr [7FE748D4B84h]cl  

    i16 %= (short)1;
000007FE749F1489  movsx       rcxword ptr [7FE748D4B80h]  
000007FE749F1491  mov         eaxecx  
000007FE749F1493  sar         eax1Fh  
000007FE749F1496  and         eax0  
000007FE749F1499  add         eaxecx  
000007FE749F149B  and         eax0FFFFFFFFh  
000007FE749F149E  sub         ecxeax  
000007FE749F14A0  movsx       rcxcx  
000007FE749F14A4  mov         word ptr [7FE748D4B80h]cx  

    i32 %= (int)1;
000007FE749F14AB  mov         ecxdword ptr [7FE748D4B78h]  
000007FE749F14B1  mov         eaxecx  
000007FE749F14B3  sar         eax1Fh  
000007FE749F14B6  and         eax0  
000007FE749F14B9  add         eaxecx  
000007FE749F14BB  and         eax0FFFFFFFFh  
000007FE749F14BE  sub         ecxeax  
000007FE749F14C0  mov         dword ptr [7FE748D4B78h]ecx  

    i64 %= (long)1;
000007FE749F14C6  mov         rcxqword ptr [7FE748D4B68h]  
000007FE749F14CD  mov         raxrcx  
000007FE749F14D0  sar         rax3Fh  
000007FE749F14D4  and         rax0  
000007FE749F14D8  add         raxrcx  
000007FE749F14DB  and         rax0FFFFFFFFFFFFFFFFh  
000007FE749F14DF  sub         rcxrax  
000007FE749F14E2  mov         qword ptr [7FE748D4B68h]rcx  

    // Test with r.loc.
    Console.WriteLine((sbyte)(i8 + i8) % (sbyte)1);
000007FE749F14E9  movsx       rcxbyte ptr [7FE748D4B84h]  
000007FE749F14F1  add         ecxecx  
000007FE749F14F3  movsx       rcxcl  
000007FE749F14F7  mov         eaxecx  
000007FE749F14F9  sar         eax1Fh  
000007FE749F14FC  and         eax0  
000007FE749F14FF  add         eaxecx  
000007FE749F1501  and         eax0FFFFFFFFh  
000007FE749F1504  sub         ecxeax  
000007FE749F1506  call        000007FE749F12D0  

    Console.WriteLine((short)(i16 + i16) % (short)1);
000007FE749F150B  movsx       rcxword ptr [7FE748D4B80h]  
000007FE749F1513  add         ecxecx  
000007FE749F1515  movsx       rcxcx  
000007FE749F1519  mov         eaxecx  
000007FE749F151B  sar         eax1Fh  
000007FE749F151E  and         eax0  
000007FE749F1521  add         eaxecx  
000007FE749F1523  and         eax0FFFFFFFFh  
000007FE749F1526  sub         ecxeax  
000007FE749F1528  call        000007FE749F12D0  

    Console.WriteLine((int)(i32 + i32) % (int)1);
000007FE749F152D  mov         ecxdword ptr [7FE748D4B78h]  
000007FE749F1533  add         ecxecx  
000007FE749F1535  mov         eaxecx  
000007FE749F1537  sar         eax1Fh  
000007FE749F153A  and         eax0  
000007FE749F153D  add         eaxecx  
000007FE749F153F  and         eax0FFFFFFFFh  
000007FE749F1542  sub         ecxeax  
000007FE749F1544  call        000007FE749F12D0  

    Console.WriteLine((long)(i64 + i64) % (long)1);
000007FE749F1549  mov         rcxqword ptr [7FE748D4B68h]  
000007FE749F1550  add         rcxrcx  
000007FE749F1553  mov         raxrcx  
000007FE749F1556  sar         rax3Fh  
000007FE749F155A  and         rax0  
000007FE749F155E  add         raxrcx  
000007FE749F1561  and         rax0FFFFFFFFFFFFFFFFh  
000007FE749F1565  sub         rcxrax  
000007FE749F1568  call        000007FE749F12E0  

    // Test with m.loc.
    u8 %= (byte)1;
000007FE749F156D  movzx       ecxbyte ptr [7FE748D4B85h]  
000007FE749F1574  mov         eaxecx  
000007FE749F1576  sar         eax1Fh  
000007FE749F1579  and         eax0  
000007FE749F157C  add         eaxecx  
000007FE749F157E  and         eax0FFFFFFFFh  
000007FE749F1581  sub         ecxeax  
000007FE749F1583  movzx       ecxcl  
000007FE749F1586  mov         byte ptr [7FE748D4B85h]cl  

    u16 %= (ushort)1;
000007FE749F158C  movzx       ecxword ptr [7FE748D4B82h]  
000007FE749F1593  mov         eaxecx  
000007FE749F1595  sar         eax1Fh  
000007FE749F1598  and         eax0  
000007FE749F159B  add         eaxecx  
000007FE749F159D  and         eax0FFFFFFFFh  
000007FE749F15A0  sub         ecxeax  
000007FE749F15A2  movzx       ecxcx  
000007FE749F15A5  mov         word ptr [7FE748D4B82h]cx  

    u32 %= (uint)1;
000007FE749F15AC  and         dword ptr [7FE748D4B7Ch]0  

    u64 %= (ulong)1;
000007FE749F15B3  and         qword ptr [7FE748D4B70h]0  

    // Test with r.loc.
    Console.WriteLine((byte)(u8 + u8) % (byte)1);
000007FE749F15BB  movzx       ecxbyte ptr [7FE748D4B85h]  
000007FE749F15C2  add         ecxecx  
000007FE749F15C4  movzx       ecxcl  
000007FE749F15C7  mov         eaxecx  
000007FE749F15C9  sar         eax1Fh  
000007FE749F15CC  and         eax0  
000007FE749F15CF  add         eaxecx  
000007FE749F15D1  and         eax0FFFFFFFFh  
000007FE749F15D4  sub         ecxeax  
000007FE749F15D6  call        000007FE749F12D0  

    Console.WriteLine((ushort)(u16 + u16) % (ushort)1);
000007FE749F15DB  movzx       ecxword ptr [7FE748D4B82h]  
000007FE749F15E2  add         ecxecx  
000007FE749F15E4  movzx       ecxcx  
000007FE749F15E7  mov         eaxecx  
000007FE749F15E9  sar         eax1Fh  
000007FE749F15EC  and         eax0  
000007FE749F15EF  add         eaxecx  
000007FE749F15F1  and         eax0FFFFFFFFh  
000007FE749F15F4  sub         ecxeax  
000007FE749F15F6  call        000007FE749F12D0  

    Console.WriteLine((uint)(u32 + u32) % (uint)1);
000007FE749F15FB  mov         ecxdword ptr [7FE748D4B7Ch]  
000007FE749F1601  add         ecxecx  
000007FE749F1603  and         ecx0  
000007FE749F1606  call        000007FE749F12D8  

    Console.WriteLine((ulong)(u64 + u64) % (ulong)1);
000007FE749F160B  mov         rcxqword ptr [7FE748D4B70h]  
000007FE749F1612  add         rcxrcx  
000007FE749F1615  and         rcx0  
000007FE749F1619  call        000007FE749F12E8  

000007FE749F161E  nop  
000007FE749F161F  add         rsp28h  
000007FE749F1623  ret  
--- No source file -------------------------------------------------------------
```

category:cq
theme:optimization
skill-level:beginner
cost:small</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>23/08/2018 2:47:10 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19624</IssueLabelID>
    <Title>Rewrite deleted tests when corefx Avx.PermuteVar signature changes are absorbed</Title>
    <Description>This issue tracks reenabling and adding missing `Vector128&lt;T&gt;` tests for `Avx.PermuteVar` intrinsics. Relevant changes are in:

1. Coreclr - #19582 
2. Corefx - https://github.com/dotnet/corefx/pull/31864</Description>
    <Title_Description>Rewrite deleted tests when corefx Avx.PermuteVar signature changes are absorbed This issue tracks reenabling and adding missing `Vector128&lt;T&gt;` tests for `Avx.PermuteVar` intrinsics. Relevant changes are in:

1. Coreclr - #19582 
2. Corefx - https://github.com/dotnet/corefx/pull/31864</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>4creators</Assignee>
    <CreatedAt>23/08/2018 10:59:23 AM +00:00</CreatedAt>
    <ClosedAt>17/01/2019 7:10:52 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19623</IssueLabelID>
    <Title>Fix FreeBSD build</Title>
    <Description>
    </Description>
    <Title_Description>Fix FreeBSD build </Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>wfurt</Assignee>
    <CreatedAt>23/08/2018 9:20:55 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19622</IssueLabelID>
    <Title>GetFunctionEnter3Info does not return correct argument address on Unix</Title>
    <Description>This is an issue I found while investigating an issue reported in this thread: https://github.com/dotnet/coreclr/issues/18977

See also: https://github.com/dotnet/docs/issues/6728

On Linux GetFunctionEnter3Info does not return the correct argument addresses (It returns correct numRanges and totalArgumentSize). I've successfully verified this issue on x64 (Ubuntu) but I have yet tried to repro this on other architectures (arm). 

The sample profilee is a very simple program with one function call. 
```
    class Program
    { 
        static int foo(int a int b int c string d)
        {
            return a + b + c + d.Length;
        }

        static void Main(string[] args)
        {
            Console.Write("foo: {0:d}\n" foo(0xaa 0xbb 0xcc "bar"));
        }
    }
}
```

I put a breakpoint on ProfilingGetFunctionEnter3Info in the runtime right before it returns. On Windows WinDbg shows the following when I inspect the memory address pointed by ```pArgumentInfo-&gt;ranges[0].startAddress```:

```
00000055`585be2b0 aa 00 00 00 00 00 00 00 bb  .........
00000055`585be2b9 00 00 00 00 00 00 00 cc 00  .........
00000055`585be2c2 00 00 00 00 00 00 80 0e 13  .........
00000055`585be2cb a7 6d 01 00 00 00 00 00 00
```
As shown the memory indeed contains the arguments that was passed to the function foo. 

In Linux lldb shows me the following:
```
(lldb) frame variable
(FunctionID) functionId = 140735268410280
(COR_PRF_ELT_INFO) eltInfo = 140737488337952
(COR_PRF_FRAME_INFO *) pFrameInfo = 0x00007fffffffb8f0
(ULONG *) pcbArgumentInfo = 0x00007fffffffb8ec
(COR_PRF_FUNCTION_ARGUMENT_INFO *) pArgumentInfo = 0x00000000013a9120
(COR_PRF_ELT_INFO_INTERNAL *) pELTInfo = 0x00007fffffffbc20
(MethodDesc *) pMethodDesc = 0x00007fff7bae53a8

(lldb) x/20x 0x00000000013a9120
0x013a9120: 0x00000004 0x00000014 0xffffbf50 0x00007fff
0x013a9130: 0x00000004 0xcccccccc 0xffffbf58 0x00007fff
0x013a9140: 0x00000004 0xcccccccc 0xffffbf60 0x00007fff
0x013a9150: 0x00000004 0xcccccccc 0xffffbf68 0x00007fff
0x013a9160: 0x00000008 0xcccccccc 0xcccccccc 0xcccccccc

(lldb) x/20x 0x00007fffffffbf50
0x7fffffffbf50: 0x85af6e00 0xffc21e02 0x00000000 0x00000000
0x7fffffffbf60: 0xf58eedb3 0x00007fff 0x54021b68 0x00007fff
0x7fffffffbf70: 0xffffe480 0x00000001 0x54021b50 0x00007fff
0x7fffffffbf80: 0x85af6e00 0xffc21e02 0xffffe060 0x00007fff
0x7fffffffbf90: 0xffffbfb0 0x00007fff 0xf5bbfc83 0x00007fff
```

As shown above the argument address (0x00007fffffffbf50) is does not contain the function arguments (0xaa 0xbb 0xcc "bar")

</Description>
    <Title_Description>GetFunctionEnter3Info does not return correct argument address on Unix This is an issue I found while investigating an issue reported in this thread: https://github.com/dotnet/coreclr/issues/18977

See also: https://github.com/dotnet/docs/issues/6728

On Linux GetFunctionEnter3Info does not return the correct argument addresses (It returns correct numRanges and totalArgumentSize). I've successfully verified this issue on x64 (Ubuntu) but I have yet tried to repro this on other architectures (arm). 

The sample profilee is a very simple program with one function call. 
```
    class Program
    { 
        static int foo(int a int b int c string d)
        {
            return a + b + c + d.Length;
        }

        static void Main(string[] args)
        {
            Console.Write("foo: {0:d}\n" foo(0xaa 0xbb 0xcc "bar"));
        }
    }
}
```

I put a breakpoint on ProfilingGetFunctionEnter3Info in the runtime right before it returns. On Windows WinDbg shows the following when I inspect the memory address pointed by ```pArgumentInfo-&gt;ranges[0].startAddress```:

```
00000055`585be2b0 aa 00 00 00 00 00 00 00 bb  .........
00000055`585be2b9 00 00 00 00 00 00 00 cc 00  .........
00000055`585be2c2 00 00 00 00 00 00 80 0e 13  .........
00000055`585be2cb a7 6d 01 00 00 00 00 00 00
```
As shown the memory indeed contains the arguments that was passed to the function foo. 

In Linux lldb shows me the following:
```
(lldb) frame variable
(FunctionID) functionId = 140735268410280
(COR_PRF_ELT_INFO) eltInfo = 140737488337952
(COR_PRF_FRAME_INFO *) pFrameInfo = 0x00007fffffffb8f0
(ULONG *) pcbArgumentInfo = 0x00007fffffffb8ec
(COR_PRF_FUNCTION_ARGUMENT_INFO *) pArgumentInfo = 0x00000000013a9120
(COR_PRF_ELT_INFO_INTERNAL *) pELTInfo = 0x00007fffffffbc20
(MethodDesc *) pMethodDesc = 0x00007fff7bae53a8

(lldb) x/20x 0x00000000013a9120
0x013a9120: 0x00000004 0x00000014 0xffffbf50 0x00007fff
0x013a9130: 0x00000004 0xcccccccc 0xffffbf58 0x00007fff
0x013a9140: 0x00000004 0xcccccccc 0xffffbf60 0x00007fff
0x013a9150: 0x00000004 0xcccccccc 0xffffbf68 0x00007fff
0x013a9160: 0x00000008 0xcccccccc 0xcccccccc 0xcccccccc

(lldb) x/20x 0x00007fffffffbf50
0x7fffffffbf50: 0x85af6e00 0xffc21e02 0x00000000 0x00000000
0x7fffffffbf60: 0xf58eedb3 0x00007fff 0x54021b68 0x00007fff
0x7fffffffbf70: 0xffffe480 0x00000001 0x54021b50 0x00007fff
0x7fffffffbf80: 0x85af6e00 0xffc21e02 0xffffe060 0x00007fff
0x7fffffffbf90: 0xffffbfb0 0x00007fff 0xf5bbfc83 0x00007fff
```

As shown above the argument address (0x00007fffffffbf50) is does not contain the function arguments (0xaa 0xbb 0xcc "bar")

</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>davmason</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19620</IssueLabelID>
    <Title>Extra bounds checks are being generated in common span usage pattern</Title>
    <Description>I would expect the following code to have no bounds checks within the disassembly beyond the explicit length check when accessing the data via the indexer:

```C#
public static bool IsFirstSpace(ReadOnlySpan&lt;byte&gt; buffer)
{
    if (buffer.Length &lt; 1 || buffer[0] != ' ')
        return false;
    return true;
}
```
However I am seeing an extra comparison and jump instruction:

```text
00007FFEC26EC790  sub         rsp28h  
00007FFEC26EC794  mov         raxqword ptr [rcx]  
00007FFEC26EC797  mov         edxdword ptr [rcx+8]  
00007FFEC26EC79A  test        edxedx  
00007FFEC26EC79C  jle         00007FFEC26EC7A8  
00007FFEC26EC79E  cmp         edx0  
00007FFEC26EC7A1  jbe         00007FFEC26EC7B9  
00007FFEC26EC7A3  cmp         byte ptr [rax]20h  
00007FFEC26EC7A6  je          00007FFEC26EC7AF  
00007FFEC26EC7A8  xor         eaxeax  
00007FFEC26EC7AA  add         rsp28h  
00007FFEC26EC7AE  ret  
00007FFEC26EC7AF  mov         eax1  
00007FFEC26EC7B4  add         rsp28h  
00007FFEC26EC7B8  ret  
00007FFEC26EC7B9  call        00007FFF214A56F0  
00007FFEC26EC7BE  int         3  
```

Workarounds like casting to uint etc. do not help:
```C#
public static bool IsFirstSpace(ReadOnlySpan&lt;byte&gt; buffer)
{
    if ((uint)buffer.Length &gt;= 1u &amp;&amp; buffer[0] == ' ')
        return true;
    return false;
}

public static bool IsFirstSpace(ReadOnlySpan&lt;byte&gt; buffer)
{
    if (!buffer.IsEmpty &amp;&amp; buffer[0] == ' ')
        return true;
    return false;
}
```

[SharpLab Link](https://sharplab.io/#v2:C4LghgzgtgPgAgBgARwIwG4CwAoOBmFAJiQGEkBvHJalAtANiQCMB7FgGyQEkIAxASwBOEYAGUADmADGAUwAUAJRlgAJgHkAduwCeEsBoA8TbcBkA+ZgFcAZtZmCAlBSo1X/a0jlMbdwQDoAGRkNAHNgAAskAyRUJBgYK1t7AG0EAF0kAEIAXiQAcnyHF1cSlAB2JGswdggZLGxS6jgK4EFLOuKkAF8cLqA=)

Version: Microsoft.NETCore.App 3.0.0-preview1-26809-04

cc @AndyAyersMS @benaadams @GrabYourPitchforks 

category:cq
theme:range-check
skill-level:expert
cost:large</Description>
    <Title_Description>Extra bounds checks are being generated in common span usage pattern I would expect the following code to have no bounds checks within the disassembly beyond the explicit length check when accessing the data via the indexer:

```C#
public static bool IsFirstSpace(ReadOnlySpan&lt;byte&gt; buffer)
{
    if (buffer.Length &lt; 1 || buffer[0] != ' ')
        return false;
    return true;
}
```
However I am seeing an extra comparison and jump instruction:

```text
00007FFEC26EC790  sub         rsp28h  
00007FFEC26EC794  mov         raxqword ptr [rcx]  
00007FFEC26EC797  mov         edxdword ptr [rcx+8]  
00007FFEC26EC79A  test        edxedx  
00007FFEC26EC79C  jle         00007FFEC26EC7A8  
00007FFEC26EC79E  cmp         edx0  
00007FFEC26EC7A1  jbe         00007FFEC26EC7B9  
00007FFEC26EC7A3  cmp         byte ptr [rax]20h  
00007FFEC26EC7A6  je          00007FFEC26EC7AF  
00007FFEC26EC7A8  xor         eaxeax  
00007FFEC26EC7AA  add         rsp28h  
00007FFEC26EC7AE  ret  
00007FFEC26EC7AF  mov         eax1  
00007FFEC26EC7B4  add         rsp28h  
00007FFEC26EC7B8  ret  
00007FFEC26EC7B9  call        00007FFF214A56F0  
00007FFEC26EC7BE  int         3  
```

Workarounds like casting to uint etc. do not help:
```C#
public static bool IsFirstSpace(ReadOnlySpan&lt;byte&gt; buffer)
{
    if ((uint)buffer.Length &gt;= 1u &amp;&amp; buffer[0] == ' ')
        return true;
    return false;
}

public static bool IsFirstSpace(ReadOnlySpan&lt;byte&gt; buffer)
{
    if (!buffer.IsEmpty &amp;&amp; buffer[0] == ' ')
        return true;
    return false;
}
```

[SharpLab Link](https://sharplab.io/#v2:C4LghgzgtgPgAgBgARwIwG4CwAoOBmFAJiQGEkBvHJalAtANiQCMB7FgGyQEkIAxASwBOEYAGUADmADGAUwAUAJRlgAJgHkAduwCeEsBoA8TbcBkA+ZgFcAZtZmCAlBSo1X/a0jlMbdwQDoAGRkNAHNgAAskAyRUJBgYK1t7AG0EAF0kAEIAXiQAcnyHF1cSlAB2JGswdggZLGxS6jgK4EFLOuKkAF8cLqA=)

Version: Microsoft.NETCore.App 3.0.0-preview1-26809-04

cc @AndyAyersMS @benaadams @GrabYourPitchforks 

category:cq
theme:range-check
skill-level:expert
cost:large</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>ahsonkhan</Assignee>
    <CreatedAt>23/08/2018 3:36:40 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19616</IssueLabelID>
    <Title>R2RDump - List of sections not yet parsed</Title>
    <Description>- [ ] `READYTORUN_SECTION_EXCEPTION_INFO`
- [x] `READYTORUN_SECTION_DEBUG_INFO`
- [ ] `READYTORUN_SECTION_DELAYLOAD_METHODCALL_THUNKS`
- [ ] `READYTORUN_SECTION_INLINING_INFO`
- [ ] `READYTORUN_SECTION_PROFILEDATA_INFO`
- [ ] `READYTORUN_SECTION_IMPORT_SECTIONS` is not yet parsed correctly</Description>
    <Title_Description>R2RDump - List of sections not yet parsed - [ ] `READYTORUN_SECTION_EXCEPTION_INFO`
- [x] `READYTORUN_SECTION_DEBUG_INFO`
- [ ] `READYTORUN_SECTION_DELAYLOAD_METHODCALL_THUNKS`
- [ ] `READYTORUN_SECTION_INLINING_INFO`
- [ ] `READYTORUN_SECTION_PROFILEDATA_INFO`
- [ ] `READYTORUN_SECTION_IMPORT_SECTIONS` is not yet parsed correctly</Title_Description>
    <Label>area-R2RDump</Label>
    <Assignee>nattress</Assignee>
    <CreatedAt>22/08/2018 10:41:16 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19615</IssueLabelID>
    <Title>Enable cron jobs Linux/arm64</Title>
    <Description>
    </Description>
    <Title_Description>Enable cron jobs Linux/arm64 </Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>BruceForstall</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19614</IssueLabelID>
    <Title>[Windows|Arm64] init-tools.cmd supports native dotnet cli</Title>
    <Description>https://github.com/dotnet/coreclr/pull/19213 Adds support for init-tools.cmd for arm64 using the x86 toolset. Once packages are produced for windows arm64 use the native dotnetcli.</Description>
    <Title_Description>[Windows|Arm64] init-tools.cmd supports native dotnet cli https://github.com/dotnet/coreclr/pull/19213 Adds support for init-tools.cmd for arm64 using the x86 toolset. Once packages are produced for windows arm64 use the native dotnetcli.</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>jashook</Assignee>
    <CreatedAt>22/08/2018 9:41:26 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19613</IssueLabelID>
    <Title>[WIP] add test for #18988</Title>
    <Description>This PR is for test purpose only.</Description>
    <Title_Description>[WIP] add test for #18988 This PR is for test purpose only.</Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>22/08/2018 9:24:51 PM +00:00</CreatedAt>
    <ClosedAt>18/09/2018 5:38:57 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19611</IssueLabelID>
    <Title>Documentation for EventPipe</Title>
    <Description>We should have a walk through and some documentation on how to use EventPipe.</Description>
    <Title_Description>Documentation for EventPipe We should have a walk through and some documentation on how to use EventPipe.</Title_Description>
    <Label>EventPipe</Label>
    <Assignee>brianrob</Assignee>
    <CreatedAt>22/08/2018 8:52:23 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19608</IssueLabelID>
    <Title>Fix terminology in netci file</Title>
    <Description>
    </Description>
    <Title_Description>Fix terminology in netci file </Title_Description>
    <Label>area-Meta</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19607</IssueLabelID>
    <Title>Fix AsyncLocal&lt;class&gt; changed event to not be raised multiple times for one change in value (#17767)</Title>
    <Description>Port of https://github.com/dotnet/coreclr/pull/17767 to 2.2

- Functional fix for https://github.com/dotnet/coreclr/issues/17758
- This was a regression in 2.1 fixing for 2.2</Description>
    <Title_Description>Fix AsyncLocal&lt;class&gt; changed event to not be raised multiple times for one change in value (#17767) Port of https://github.com/dotnet/coreclr/pull/17767 to 2.2

- Functional fix for https://github.com/dotnet/coreclr/issues/17758
- This was a regression in 2.1 fixing for 2.2</Title_Description>
    <Label>area-System.Threading</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19606</IssueLabelID>
    <Title>Fix a PAL spin lock issue</Title>
    <Description>Fixes https://github.com/dotnet/coreclr/issues/18486
- Lock release needs to be at least volatile

master PR: https://github.com/dotnet/coreclr/pull/19604</Description>
    <Title_Description>Fix a PAL spin lock issue Fixes https://github.com/dotnet/coreclr/issues/18486
- Lock release needs to be at least volatile

master PR: https://github.com/dotnet/coreclr/pull/19604</Title_Description>
    <Label>Servicing-approved</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19605</IssueLabelID>
    <Title>Fix a PAL spin lock issue</Title>
    <Description>Fix for https://github.com/dotnet/coreclr/issues/18486
- Lock release needs to be at least volatile

master PR: https://github.com/dotnet/coreclr/pull/19604</Description>
    <Title_Description>Fix a PAL spin lock issue Fix for https://github.com/dotnet/coreclr/issues/18486
- Lock release needs to be at least volatile

master PR: https://github.com/dotnet/coreclr/pull/19604</Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19604</IssueLabelID>
    <Title>Fix a PAL spin lock issue</Title>
    <Description>Fix for https://github.com/dotnet/coreclr/issues/18486
- Lock release needs to be at least volatile</Description>
    <Title_Description>Fix a PAL spin lock issue Fix for https://github.com/dotnet/coreclr/issues/18486
- Lock release needs to be at least volatile</Title_Description>
    <Label>area-PAL</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19603</IssueLabelID>
    <Title>[WIP] Enable tiered compilation</Title>
    <Description>
    </Description>
    <Title_Description>[WIP] Enable tiered compilation </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19602</IssueLabelID>
    <Title>[WIP] Test CI</Title>
    <Description>
    </Description>
    <Title_Description>[WIP] Test CI </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19601</IssueLabelID>
    <Title>RyuJIT: Incorrect 4-byte immediate emitted for shift causes access violation</Title>
    <Description>In debug RyuJIT seems to try to emit a 4-byte immediate on a `shl` instruction for the following case:
```csharp
public class Program
{
    static ushort s_2;
    static short[] s_5 = new short[]{1};
    static ulong s_8;
    public static void Main()
    {
        var vr2 = s_5[0];
        M9();
    }

    static void M9()
    {
        s_8 &lt;&lt;= (0 &amp; s_2) + 186;
    }
}
```

According to the JIT this is the disassembly:
```asm
G_M23195_IG03:
       90                   nop
       48C1255C29EEFFBA000000 shl      qword ptr [reloc classVar[0x391252c0]] 186
       90                   nop
```
Of course shifts do not have a 4-byte immediate form and VS knows better:
```asm
00007FFE51C915DE 90                   nop  
00007FFE51C915DF 48 C1 25 06 36 EE FF BA shl         qword ptr [7FFE51B74BEDh]0BAh  
00007FFE51C915E7 00 00                add         byte ptr [rax]al  
00007FFE51C915E9 00 90 48 8D 65 30    add         byte ptr [rax+30658D48h]dl  
```

This access violates depending on the value of `rax`.</Description>
    <Title_Description>RyuJIT: Incorrect 4-byte immediate emitted for shift causes access violation In debug RyuJIT seems to try to emit a 4-byte immediate on a `shl` instruction for the following case:
```csharp
public class Program
{
    static ushort s_2;
    static short[] s_5 = new short[]{1};
    static ulong s_8;
    public static void Main()
    {
        var vr2 = s_5[0];
        M9();
    }

    static void M9()
    {
        s_8 &lt;&lt;= (0 &amp; s_2) + 186;
    }
}
```

According to the JIT this is the disassembly:
```asm
G_M23195_IG03:
       90                   nop
       48C1255C29EEFFBA000000 shl      qword ptr [reloc classVar[0x391252c0]] 186
       90                   nop
```
Of course shifts do not have a 4-byte immediate form and VS knows better:
```asm
00007FFE51C915DE 90                   nop  
00007FFE51C915DF 48 C1 25 06 36 EE FF BA shl         qword ptr [7FFE51B74BEDh]0BAh  
00007FFE51C915E7 00 00                add         byte ptr [rax]al  
00007FFE51C915E9 00 90 48 8D 65 30    add         byte ptr [rax+30658D48h]dl  
```

This access violates depending on the value of `rax`.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>22/08/2018 2:07:26 PM +00:00</CreatedAt>
    <ClosedAt>24/08/2018 3:04:42 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19599</IssueLabelID>
    <Title>RyuJIT: Missing zeroing of upper bits for small struct used in Volatile.Read</Title>
    <Description>The example is:
```csharp
// Debug: Outputs 128 (0x80)
// Release: Outputs 4294967168 (0xFFFFFF80)
struct S0
{
    public byte F0;
}

public class Program
{
    static S0 s_2;
    static long s_5;
    public static void Main()
    {
        s_2.F0 = 128;
        M7(s_2);
        System.Console.WriteLine(s_5);
    }

    static void M7(S0 arg0)
    {
        s_5 = System.Threading.Volatile.Read(ref arg0.F0);
    }
}
```

It produces for the call in `Main`:
```asm
       48B978298897D6010000 mov      rcx 0x1D697882978
       488B09               mov      rcx gword ptr [rcx]
       C6410880             mov      byte  ptr [rcx+8] 128
       48B978298897D6010000 mov      rcx 0x1D697882978
       488B09               mov      rcx gword ptr [rcx]
       480FBE4908           movsx    rcx byte  ptr [rcx+8]   ; sign extended
       E8BFFBFFFF           call     Program:M7(struct)
```

and for `M7`:
```asm
; Assembly listing for method Program:M7(struct)
; Emitting BLENDED_CODE for X64 CPU with AVX
; optimized code
; rsp based frame
; partially interruptible
; Final local variable assignments
;
;* V00 arg0         [V00    ] (  0  0   )  struct ( 8) zero-ref    ld-addr-op
;# V01 OutArgs      [V01    ] (  1  1   )  lclBlk ( 0) [rsp+0x00]
;  V02 tmp1         [V02T00] (  2  2   )   ubyte  -&gt;  rcx         V00.F0(offs=0x00) P-INDEP
;
; Lcl frame size = 0

G_M23190_IG01:
       0F1F440000           nop

G_M23190_IG02:
       8BC1                 mov      eax ecx
       4889054A2AEEFF       mov      qword ptr [reloc classVar[0x4bc55298]] rax

G_M23190_IG03:
       C3                   ret

; Total bytes of code 15 prolog size 5 for method Program:M7(struct)
```</Description>
    <Title_Description>RyuJIT: Missing zeroing of upper bits for small struct used in Volatile.Read The example is:
```csharp
// Debug: Outputs 128 (0x80)
// Release: Outputs 4294967168 (0xFFFFFF80)
struct S0
{
    public byte F0;
}

public class Program
{
    static S0 s_2;
    static long s_5;
    public static void Main()
    {
        s_2.F0 = 128;
        M7(s_2);
        System.Console.WriteLine(s_5);
    }

    static void M7(S0 arg0)
    {
        s_5 = System.Threading.Volatile.Read(ref arg0.F0);
    }
}
```

It produces for the call in `Main`:
```asm
       48B978298897D6010000 mov      rcx 0x1D697882978
       488B09               mov      rcx gword ptr [rcx]
       C6410880             mov      byte  ptr [rcx+8] 128
       48B978298897D6010000 mov      rcx 0x1D697882978
       488B09               mov      rcx gword ptr [rcx]
       480FBE4908           movsx    rcx byte  ptr [rcx+8]   ; sign extended
       E8BFFBFFFF           call     Program:M7(struct)
```

and for `M7`:
```asm
; Assembly listing for method Program:M7(struct)
; Emitting BLENDED_CODE for X64 CPU with AVX
; optimized code
; rsp based frame
; partially interruptible
; Final local variable assignments
;
;* V00 arg0         [V00    ] (  0  0   )  struct ( 8) zero-ref    ld-addr-op
;# V01 OutArgs      [V01    ] (  1  1   )  lclBlk ( 0) [rsp+0x00]
;  V02 tmp1         [V02T00] (  2  2   )   ubyte  -&gt;  rcx         V00.F0(offs=0x00) P-INDEP
;
; Lcl frame size = 0

G_M23190_IG01:
       0F1F440000           nop

G_M23190_IG02:
       8BC1                 mov      eax ecx
       4889054A2AEEFF       mov      qword ptr [reloc classVar[0x4bc55298]] rax

G_M23190_IG03:
       C3                   ret

; Total bytes of code 15 prolog size 5 for method Program:M7(struct)
```</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>22/08/2018 12:16:41 PM +00:00</CreatedAt>
    <ClosedAt>21/12/2018 12:10:28 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19597</IssueLabelID>
    <Title>Enable eventpipe without restart dotnet process</Title>
    <Description>Is it any way to enable eventpipe diagnostics without restart dotnet process?
Performance problems with   my application do not start immediately but in around several days after launch.

Now for starting EventPipe diagnostics I need to enter next commands
export COMPlus_EnableEventPipe=1
export COMPlus_EventPipeConfig=Microsoft-DotNETCore-SampleProfiler:1:5

and restart dotnet process.

dotnet --info
Host (useful for support):
  Version: 2.1.2
  Commit:  811c3ce6c0
.NET Core SDKs installed:
  No SDKs were found.
.NET Core runtimes installed:
  Microsoft.NETCore.App 2.1.2 [/usr/share/dotnet/shared/Microsoft.NETCore.App]
To install additional .NET Core runtimes or SDKs:
  https://aka.ms/dotnet-download

</Description>
    <Title_Description>Enable eventpipe without restart dotnet process Is it any way to enable eventpipe diagnostics without restart dotnet process?
Performance problems with   my application do not start immediately but in around several days after launch.

Now for starting EventPipe diagnostics I need to enter next commands
export COMPlus_EnableEventPipe=1
export COMPlus_EventPipeConfig=Microsoft-DotNETCore-SampleProfiler:1:5

and restart dotnet process.

dotnet --info
Host (useful for support):
  Version: 2.1.2
  Commit:  811c3ce6c0
.NET Core SDKs installed:
  No SDKs were found.
.NET Core runtimes installed:
  Microsoft.NETCore.App 2.1.2 [/usr/share/dotnet/shared/Microsoft.NETCore.App]
To install additional .NET Core runtimes or SDKs:
  https://aka.ms/dotnet-download

</Title_Description>
    <Label>EventPipe</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>22/08/2018 10:34:20 AM +00:00</CreatedAt>
    <ClosedAt>15/04/2019 5:47:21 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19596</IssueLabelID>
    <Title>Consider implementing Ryu algorithm for double.ToString() </Title>
    <Description>***Introduction***
A few months ago a new string formatting algorithm for floating point numbers was presented It is called 
Ryu and the benchmarks show it to be roughly ~3 times faster than the previously fastest algorithm Grisu3 (which was implemented in #14478 for 2.1).

The float version uses mainly ulong arithmetics + table lookups the double version uses mainly uint128 arithmetics + table lookups. 
The double version might be an interesting use case for the intrinsic code as e.g. 128bit shifts are SSE2.

As far as I see the fallback to the Dragon4 algorithm should not be necessary anymore with that algorithm and they claim it to be output-identical to grisu3 otherwise.

***References***
https://dl.acm.org/citation.cfm?id=3192369
https://pldi18.sigplan.org/event/pldi-2018-papers-ry-fast-float-to-string-conversion
https://github.com/ulfjack/ryu

Tags:
@mazong1123 Might be of interest for you as you did the Grisu3 implementation
@tannergooding I think you were looking for algorithms which might be worthwhile for intrinsic implementations
@danmosemsft For reference of https://github.com/dotnet/corefx/issues/31847

***Performance***

I did an experimental port of the current c implementation for the float datatype (https://github.com/ulfjack/ryu/blob/master/ryu/f2s.c)  to c# (purely mechanical just to get it working) and ran a few benchmarks myself and that naive conversion in C# was **~50%** faster than the current grisu3 algorithm. Assuming I didn't make any bad shortcuts in my benchmark I'd say a closer look might be worth it.


My naive conversion is below:

&lt;details&gt;

```csharp

// Copyright 2018 Ulf Adams
//
// The contents of this file may be used under the terms of the Apache License
// Version 2.0.
//
//    (See accompanying file LICENSE-Apache or copy at
//     http://www.apache.org/licenses/LICENSE-2.0)
//
// Alternatively the contents of this file may be used under the terms of
// the Boost Software License Version 1.0.
//    (See accompanying file LICENSE-Boost or copy at
//     https://www.boost.org/LICENSE_1_0.txt)
//
// Unless required by applicable law or agreed to in writing this software
// is distributed on an "AS IS" BASIS WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND either express or implied.


// purely mechanical conversion of C to C#
https://github.com/ulfjack/ryu/blob/master/ryu/f2s.c

using System;
using System.Runtime.CompilerServices;

namespace RyuFloat
{
    public class RyuFloatToString
    {
        private const int FLOAT_MANTISSA_BITS = 23;
        private const int FLOAT_EXPONENT_BITS = 8;

        private const int FLOAT_POW5_INV_BITCOUNT = 59;

        private static readonly ulong[] FLOAT_POW5_INV_SPLIT =
        {
            576460752303423489ul 461168601842738791ul 368934881474191033ul 295147905179352826ul
            472236648286964522ul 377789318629571618ul 302231454903657294ul 483570327845851670ul
            386856262276681336ul 309485009821345069ul 495176015714152110ul 396140812571321688ul
            316912650057057351ul 507060240091291761ul 405648192073033409ul 324518553658426727ul
            519229685853482763ul 415383748682786211ul 332306998946228969ul 531691198313966350ul
            425352958651173080ul 340282366920938464ul 544451787073501542ul 435561429658801234ul
            348449143727040987ul 557518629963265579ul 446014903970612463ul 356811923176489971ul
            570899077082383953ul 456719261665907162ul 365375409332725730ul
        };

        private const int FLOAT_POW5_BITCOUNT = 61;

        private static readonly ulong[] FLOAT_POW5_SPLIT =
        {
            1152921504606846976ul 1441151880758558720ul 1801439850948198400ul 2251799813685248000ul
            1407374883553280000ul 1759218604441600000ul 2199023255552000000ul 1374389534720000000ul
            1717986918400000000ul 2147483648000000000ul 1342177280000000000ul 1677721600000000000ul
            2097152000000000000ul 1310720000000000000ul 1638400000000000000ul 2048000000000000000ul
            1280000000000000000ul 1600000000000000000ul 2000000000000000000ul 1250000000000000000ul
            1562500000000000000ul 1953125000000000000ul 1220703125000000000ul 1525878906250000000ul
            1907348632812500000ul 1192092895507812500ul 1490116119384765625ul 1862645149230957031ul
            1164153218269348144ul 1455191522836685180ul 1818989403545856475ul 2273736754432320594ul
            1421085471520200371ul 1776356839400250464ul 2220446049250313080ul 1387778780781445675ul
            1734723475976807094ul 2168404344971008868ul 1355252715606880542ul 1694065894508600678ul
            2117582368135750847ul 1323488980084844279ul 1654361225106055349ul 2067951531382569187ul
            1292469707114105741ul 1615587133892632177ul 2019483917365790221ul
        };

        private static uint pow5Factor(uint value)
        {
            uint count = 0;
            for (;;)
            {
                uint q = value / 5;
                uint r = value % 5;
                if (r != 0) break;

                value = q;
                ++count;
            }

            return count;
        }

        private static bool multipleOfPowerOf5(uint value uint p)
        {
            return pow5Factor(value) &gt;= p;
        }

        private static bool multipleOfPowerOf2(uint value uint p)
        {
            // return __builtin_ctz(value) &gt;= p;
            return (value &amp; ((1u &lt;&lt; (int) p) - 1)) == 0;
        }

        private static uint mulShift(uint m ulong factor int shift)
        {
            // The casts here help MSVC to avoid calls to the __allmul library
            // function.
            uint factorLo = (uint) factor;
            uint factorHi = (uint) (factor &gt;&gt; 32);
            ulong bits0 = (ulong) m * factorLo;
            ulong bits1 = (ulong) m * factorHi;

            ulong sum = (bits0 &gt;&gt; 32) + bits1;
            ulong shiftedSum = sum &gt;&gt; (shift - 32);
            return (uint) shiftedSum;
        }

        // Returns e == 0 ? 1 : ceil(log_2(5^e)).
        private static uint pow5bits(int e)
        {
            // This approximation works up to the point that the multiplication overflows at e = 3529.
            // If the multiplication were done in 64 bits it would fail at 5^4004 which is just greater
            // than 2^9297.

            return (((uint) e * 1217359) &gt;&gt; 19) + 1;
        }

        // Returns floor(log_10(2^e)).
        private static int log10Pow2(int e)
        {
            // The first value this approximation fails for is 2^1651 which is just greater than 10^297.
            return (int) (((uint) e * 78913) &gt;&gt; 18);
        }

        // Returns floor(log_10(5^e)).
        private static int log10Pow5(int e)
        {
            // The first value this approximation fails for is 5^2621 which is just greater than 10^1832.
            return (int) (((uint) e * 732923) &gt;&gt; 20);
        }

        private static uint mulPow5InvDivPow2(uint m uint q int j)
        {
            return mulShift(m FLOAT_POW5_INV_SPLIT[q] j);
        }

        private static uint mulPow5divPow2(uint m uint i int j)
        {
            return mulShift(m FLOAT_POW5_SPLIT[i] j);
        }

        private static uint decimalLength(uint v)
        {
            // Function precondition: v is not a 10-digit number.
            // (9 digits are sufficient for round-tripping.)
            if (v &gt;= 100000000) return 9;

            if (v &gt;= 10000000) return 8;

            if (v &gt;= 1000000) return 7;

            if (v &gt;= 100000) return 6;

            if (v &gt;= 10000) return 5;

            if (v &gt;= 1000) return 4;

            if (v &gt;= 100) return 3;

            if (v &gt;= 10) return 2;

            return 1;
        }

        // A floating decimal representing m * 10^e.
        private struct floating_decimal_32
        {
            public uint mantissa;
            public int exponent;
        }

        private static floating_decimal_32 f2d(uint ieeeMantissa uint ieeeExponent)
        {
            uint bias = (1u &lt;&lt; (FLOAT_EXPONENT_BITS - 1)) - 1;

            int e2;
            uint m2;
            if (ieeeExponent == 0)
            {
                // We subtract 2 so that the bounds computation has 2 additional bits.
                e2 = (int) (1 - bias - FLOAT_MANTISSA_BITS - 2);
                m2 = ieeeMantissa;
            }
            else
            {
                e2 = (int) (ieeeExponent - bias - FLOAT_MANTISSA_BITS - 2);
                m2 = (1u &lt;&lt; FLOAT_MANTISSA_BITS) | ieeeMantissa;
            }

            bool even = (m2 &amp; 1) == 0;
            bool acceptBounds = even;


            // Step 2: Determine the interval of legal decimal representations.
            uint mv = 4 * m2;
            uint mp = 4 * m2 + 2;
            // Implicit bool -&gt; int conversion. True is 1 false is 0.
            bool mmShift = ieeeMantissa != 0 || ieeeExponent &lt;= 1;
            uint mm = (uint) (4 * m2 - 1 - (mmShift ? 1 : 0));

            // Step 3: Convert to a decimal power base using 64-bit arithmetic.
            uint vr vp vm;
            int e10;
            bool vmIsTrailingZeros = false;
            bool vrIsTrailingZeros = false;
            byte lastRemovedDigit = 0;
            if (e2 &gt;= 0)
            {
                uint q = (uint) log10Pow2(e2);
                e10 = (int) q;
                int k = (int) (FLOAT_POW5_INV_BITCOUNT + pow5bits((int) q) - 1);
                int i = (int) (-e2 + q + k);
                vr = mulPow5InvDivPow2(mv q i);
                vp = mulPow5InvDivPow2(mp q i);
                vm = mulPow5InvDivPow2(mm q i);
                if (q != 0 &amp;&amp; (vp - 1) / 10 &lt;= vm / 10)
                {
                    // We need to know one removed digit even if we are not going to loop below. We could use
                    // q = X - 1 above except that would require 33 bits for the result and we've found that
                    // 32-bit arithmetic is faster even on 64-bit machines.
                    int l = (int) (FLOAT_POW5_INV_BITCOUNT + pow5bits((int) (q - 1)) - 1);
                    lastRemovedDigit = (byte) mulPow5InvDivPow2(mv q - 1 (int) (-e2 + q - 1 + l) % 10);
                }

                if (q &lt;= 9)
                {
                    // The largest power of 5 that fits in 24 bits is 5^10 but q &lt;= 9 seems to be safe as well.
                    // Only one of mp mv and mm can be a multiple of 5 if any.
                    if (mv % 5 == 0)
                        vrIsTrailingZeros = multipleOfPowerOf5(mv q);
                    else if (acceptBounds)
                        vmIsTrailingZeros = multipleOfPowerOf5(mm q);
                    else
                        vp -= (uint) (multipleOfPowerOf5(mp q) ? 1 : 0);
                }
            }
            else
            {
                uint q = (uint) log10Pow5(-e2);
                e10 = (int) q + e2;
                int i = (int) (-e2 - q);
                int k = (int) (pow5bits(i) - FLOAT_POW5_BITCOUNT);
                int j = (int) (q - k);
                vr = mulPow5divPow2(mv (uint) i j);
                vp = mulPow5divPow2(mp (uint) i j);
                vm = mulPow5divPow2(mm (uint) i j);
                if (q != 0 &amp;&amp; (vp - 1) / 10 &lt;= vm / 10)
                {
                    j = (int) (q - 1 - (pow5bits(i + 1) - FLOAT_POW5_BITCOUNT));
                    lastRemovedDigit = (byte) (mulPow5divPow2(mv (uint) i + 1 j) % 10);
                }

                if (q &lt;= 1)
                {
                    // {vrvpvm} is trailing zeros if {mvmpmm} has at least q trailing 0 bits.
                    // mv = 4 * m2 so it always has at least two trailing 0 bits.
                    vrIsTrailingZeros = true;
                    if (acceptBounds)
                        vmIsTrailingZeros = mmShift;
                    else
                        --vp;
                }
                else if (q &lt; 31)
                {
                    // TODO(ulfjack): Use a tighter bound here.
                    vrIsTrailingZeros = multipleOfPowerOf2(mv q - 1);
                }
            }

            // Step 4: Find the shortest decimal representation in the interval of legal representations.
            uint removed = 0;
            uint output;
            if (vmIsTrailingZeros || vrIsTrailingZeros)
            {
                // General case which happens rarely (~4.0%).
                while (vp / 10 &gt; vm / 10)
                {
                    vmIsTrailingZeros &amp;= vm - vm / 10 * 10 == 0;
                    vrIsTrailingZeros &amp;= lastRemovedDigit == 0;
                    lastRemovedDigit = (byte) (vr % 10);
                    vr /= 10;
                    vp /= 10;
                    vm /= 10;
                    ++removed;
                }

                if (vmIsTrailingZeros)
                    while (vm % 10 == 0)
                    {
                        vrIsTrailingZeros &amp;= lastRemovedDigit == 0;
                        lastRemovedDigit = (byte) (vr % 10);
                        vr /= 10;
                        vp /= 10;
                        vm /= 10;
                        ++removed;
                    }

                if (vrIsTrailingZeros &amp;&amp; lastRemovedDigit == 5 &amp;&amp; vr % 2 == 0) lastRemovedDigit = 4;

                // We need to take vr + 1 if vr is outside bounds or we need to round up.
                output = (uint) (vr +
                                 (vr == vm &amp;&amp; (!acceptBounds || !vmIsTrailingZeros) || lastRemovedDigit &gt;= 5
                                     ? 1
                                     : 0));
            }
            else
            {
                // Specialized for the common case (~96.0%). Percentages below are relative to this.
                // Loop iterations below (approximately):
                // 0: 13.6% 1: 70.7% 2: 14.1% 3: 1.39% 4: 0.14% 5+: 0.01%
                while (vp / 10 &gt; vm / 10)
                {
                    lastRemovedDigit = (byte) (vr % 10);
                    vr /= 10;
                    vp /= 10;
                    vm /= 10;
                    ++removed;
                }

                // We need to take vr + 1 if vr is outside bounds or we need to round up.
                output = (uint) (vr + (vr == vm || lastRemovedDigit &gt;= 5 ? 1 : 0));
            }

            int exp = (int) (e10 + removed);


            floating_decimal_32 fd;
            fd.exponent = exp;
            fd.mantissa = output;
            return fd;
        }

        private static int to_chars(floating_decimal_32 v bool sign Span&lt;char&gt; result)
        {
            // Step 5: Print the decimal representation.
            int index = 0;
            if (sign) result[index++] = '-';

            uint output = v.mantissa;
            uint olength = decimalLength(output);

            // Print the decimal digits.
            // The following code is equivalent to:
            for (uint i = 0; i &lt; olength - 1; ++i)
            {
                uint c = output % 10;
                output /= 10;
                result[(int) (index + olength - i)] = (char) ('0' + c);
            }

            result[index] = (char) ('0' + output % 10);

            if (olength &gt; 1)
            {
                result[index + 1] = '.';
                index += (int) (olength + 1);
            }
            else
            {
                index++;
            }

            // Print the exponent.
            result[index++] = 'E';
            int exp = (int) (v.exponent + olength - 1);

            if (exp &lt; 0)
            {
                result[index++] = '-';
                exp = -exp;
            }

            if (exp &gt;= 100) result[index++] = (char) ('0' + exp / 100);

            if (exp &gt;= 10) result[index++] = (char) ('0' + exp / 10 % 10);

            result[index++] = (char) ('0' + exp % 10);


            return index;
        }

        private static int f2s_buffered_n(float f Span&lt;char&gt; result)
        {
            // Step 1: Decode the floating-point number and unify normalized and subnormal cases.
            uint bits = float_to_bits(f);


            // Decode bits into sign mantissa and exponent.
            bool ieeeSign = ((bits &gt;&gt; (FLOAT_MANTISSA_BITS + FLOAT_EXPONENT_BITS)) &amp; 1) != 0;
            uint ieeeMantissa = bits &amp; ((1u &lt;&lt; FLOAT_MANTISSA_BITS) - 1);
            uint ieeeExponent = (bits &gt;&gt; FLOAT_MANTISSA_BITS) &amp; ((1u &lt;&lt; FLOAT_EXPONENT_BITS) - 1);

            // Case distinction; exit early for the easy cases.
            if (ieeeExponent == (1u &lt;&lt; FLOAT_EXPONENT_BITS) - 1u || ieeeExponent == 0 &amp;&amp; ieeeMantissa == 0)
                return copy_special_str(result ieeeSign ieeeExponent == 0 ieeeMantissa == 0);

            floating_decimal_32 v = f2d(ieeeMantissa ieeeExponent);
            return to_chars(v ieeeSign result);
        }

        private static int copy_special_str(Span&lt;char&gt; result bool sign bool exponent bool mantissa)
        {
            if (mantissa)
            {
                result[0] = 'N';
                result[1] = 'a';
                result[2] = 'N';
                return 3;
            }

            if (sign) result[0] = '-';

            if (exponent)
            {
                result[1] = 'I';
                result[2] = 'n';
                result[3] = 'f';
                result[4] = 'i';
                result[5] = 'n';
                result[6] = 'i';
                result[7] = 't';
                result[8] = 'y';
                return 9;
            }

            result[1] = '0';
            result[2] = 'E';
            result[3] = '0';
            return 4;
        }

        public static string f2s(float f)
        {
            Span&lt;char&gt; result = stackalloc char[16];
            int index = f2s_buffered_n(f result);
            return result.Slice(0 index).ToString();
        }

        private static uint float_to_bits(float f)
        {
            uint bits = 0;
            bits = Unsafe.As&lt;float uint&gt;(ref f);
            return bits;
        }
    }
}

```
&lt;/details&gt;
</Description>
    <Title_Description>Consider implementing Ryu algorithm for double.ToString()  ***Introduction***
A few months ago a new string formatting algorithm for floating point numbers was presented It is called 
Ryu and the benchmarks show it to be roughly ~3 times faster than the previously fastest algorithm Grisu3 (which was implemented in #14478 for 2.1).

The float version uses mainly ulong arithmetics + table lookups the double version uses mainly uint128 arithmetics + table lookups. 
The double version might be an interesting use case for the intrinsic code as e.g. 128bit shifts are SSE2.

As far as I see the fallback to the Dragon4 algorithm should not be necessary anymore with that algorithm and they claim it to be output-identical to grisu3 otherwise.

***References***
https://dl.acm.org/citation.cfm?id=3192369
https://pldi18.sigplan.org/event/pldi-2018-papers-ry-fast-float-to-string-conversion
https://github.com/ulfjack/ryu

Tags:
@mazong1123 Might be of interest for you as you did the Grisu3 implementation
@tannergooding I think you were looking for algorithms which might be worthwhile for intrinsic implementations
@danmosemsft For reference of https://github.com/dotnet/corefx/issues/31847

***Performance***

I did an experimental port of the current c implementation for the float datatype (https://github.com/ulfjack/ryu/blob/master/ryu/f2s.c)  to c# (purely mechanical just to get it working) and ran a few benchmarks myself and that naive conversion in C# was **~50%** faster than the current grisu3 algorithm. Assuming I didn't make any bad shortcuts in my benchmark I'd say a closer look might be worth it.


My naive conversion is below:

&lt;details&gt;

```csharp

// Copyright 2018 Ulf Adams
//
// The contents of this file may be used under the terms of the Apache License
// Version 2.0.
//
//    (See accompanying file LICENSE-Apache or copy at
//     http://www.apache.org/licenses/LICENSE-2.0)
//
// Alternatively the contents of this file may be used under the terms of
// the Boost Software License Version 1.0.
//    (See accompanying file LICENSE-Boost or copy at
//     https://www.boost.org/LICENSE_1_0.txt)
//
// Unless required by applicable law or agreed to in writing this software
// is distributed on an "AS IS" BASIS WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND either express or implied.


// purely mechanical conversion of C to C#
https://github.com/ulfjack/ryu/blob/master/ryu/f2s.c

using System;
using System.Runtime.CompilerServices;

namespace RyuFloat
{
    public class RyuFloatToString
    {
        private const int FLOAT_MANTISSA_BITS = 23;
        private const int FLOAT_EXPONENT_BITS = 8;

        private const int FLOAT_POW5_INV_BITCOUNT = 59;

        private static readonly ulong[] FLOAT_POW5_INV_SPLIT =
        {
            576460752303423489ul 461168601842738791ul 368934881474191033ul 295147905179352826ul
            472236648286964522ul 377789318629571618ul 302231454903657294ul 483570327845851670ul
            386856262276681336ul 309485009821345069ul 495176015714152110ul 396140812571321688ul
            316912650057057351ul 507060240091291761ul 405648192073033409ul 324518553658426727ul
            519229685853482763ul 415383748682786211ul 332306998946228969ul 531691198313966350ul
            425352958651173080ul 340282366920938464ul 544451787073501542ul 435561429658801234ul
            348449143727040987ul 557518629963265579ul 446014903970612463ul 356811923176489971ul
            570899077082383953ul 456719261665907162ul 365375409332725730ul
        };

        private const int FLOAT_POW5_BITCOUNT = 61;

        private static readonly ulong[] FLOAT_POW5_SPLIT =
        {
            1152921504606846976ul 1441151880758558720ul 1801439850948198400ul 2251799813685248000ul
            1407374883553280000ul 1759218604441600000ul 2199023255552000000ul 1374389534720000000ul
            1717986918400000000ul 2147483648000000000ul 1342177280000000000ul 1677721600000000000ul
            2097152000000000000ul 1310720000000000000ul 1638400000000000000ul 2048000000000000000ul
            1280000000000000000ul 1600000000000000000ul 2000000000000000000ul 1250000000000000000ul
            1562500000000000000ul 1953125000000000000ul 1220703125000000000ul 1525878906250000000ul
            1907348632812500000ul 1192092895507812500ul 1490116119384765625ul 1862645149230957031ul
            1164153218269348144ul 1455191522836685180ul 1818989403545856475ul 2273736754432320594ul
            1421085471520200371ul 1776356839400250464ul 2220446049250313080ul 1387778780781445675ul
            1734723475976807094ul 2168404344971008868ul 1355252715606880542ul 1694065894508600678ul
            2117582368135750847ul 1323488980084844279ul 1654361225106055349ul 2067951531382569187ul
            1292469707114105741ul 1615587133892632177ul 2019483917365790221ul
        };

        private static uint pow5Factor(uint value)
        {
            uint count = 0;
            for (;;)
            {
                uint q = value / 5;
                uint r = value % 5;
                if (r != 0) break;

                value = q;
                ++count;
            }

            return count;
        }

        private static bool multipleOfPowerOf5(uint value uint p)
        {
            return pow5Factor(value) &gt;= p;
        }

        private static bool multipleOfPowerOf2(uint value uint p)
        {
            // return __builtin_ctz(value) &gt;= p;
            return (value &amp; ((1u &lt;&lt; (int) p) - 1)) == 0;
        }

        private static uint mulShift(uint m ulong factor int shift)
        {
            // The casts here help MSVC to avoid calls to the __allmul library
            // function.
            uint factorLo = (uint) factor;
            uint factorHi = (uint) (factor &gt;&gt; 32);
            ulong bits0 = (ulong) m * factorLo;
            ulong bits1 = (ulong) m * factorHi;

            ulong sum = (bits0 &gt;&gt; 32) + bits1;
            ulong shiftedSum = sum &gt;&gt; (shift - 32);
            return (uint) shiftedSum;
        }

        // Returns e == 0 ? 1 : ceil(log_2(5^e)).
        private static uint pow5bits(int e)
        {
            // This approximation works up to the point that the multiplication overflows at e = 3529.
            // If the multiplication were done in 64 bits it would fail at 5^4004 which is just greater
            // than 2^9297.

            return (((uint) e * 1217359) &gt;&gt; 19) + 1;
        }

        // Returns floor(log_10(2^e)).
        private static int log10Pow2(int e)
        {
            // The first value this approximation fails for is 2^1651 which is just greater than 10^297.
            return (int) (((uint) e * 78913) &gt;&gt; 18);
        }

        // Returns floor(log_10(5^e)).
        private static int log10Pow5(int e)
        {
            // The first value this approximation fails for is 5^2621 which is just greater than 10^1832.
            return (int) (((uint) e * 732923) &gt;&gt; 20);
        }

        private static uint mulPow5InvDivPow2(uint m uint q int j)
        {
            return mulShift(m FLOAT_POW5_INV_SPLIT[q] j);
        }

        private static uint mulPow5divPow2(uint m uint i int j)
        {
            return mulShift(m FLOAT_POW5_SPLIT[i] j);
        }

        private static uint decimalLength(uint v)
        {
            // Function precondition: v is not a 10-digit number.
            // (9 digits are sufficient for round-tripping.)
            if (v &gt;= 100000000) return 9;

            if (v &gt;= 10000000) return 8;

            if (v &gt;= 1000000) return 7;

            if (v &gt;= 100000) return 6;

            if (v &gt;= 10000) return 5;

            if (v &gt;= 1000) return 4;

            if (v &gt;= 100) return 3;

            if (v &gt;= 10) return 2;

            return 1;
        }

        // A floating decimal representing m * 10^e.
        private struct floating_decimal_32
        {
            public uint mantissa;
            public int exponent;
        }

        private static floating_decimal_32 f2d(uint ieeeMantissa uint ieeeExponent)
        {
            uint bias = (1u &lt;&lt; (FLOAT_EXPONENT_BITS - 1)) - 1;

            int e2;
            uint m2;
            if (ieeeExponent == 0)
            {
                // We subtract 2 so that the bounds computation has 2 additional bits.
                e2 = (int) (1 - bias - FLOAT_MANTISSA_BITS - 2);
                m2 = ieeeMantissa;
            }
            else
            {
                e2 = (int) (ieeeExponent - bias - FLOAT_MANTISSA_BITS - 2);
                m2 = (1u &lt;&lt; FLOAT_MANTISSA_BITS) | ieeeMantissa;
            }

            bool even = (m2 &amp; 1) == 0;
            bool acceptBounds = even;


            // Step 2: Determine the interval of legal decimal representations.
            uint mv = 4 * m2;
            uint mp = 4 * m2 + 2;
            // Implicit bool -&gt; int conversion. True is 1 false is 0.
            bool mmShift = ieeeMantissa != 0 || ieeeExponent &lt;= 1;
            uint mm = (uint) (4 * m2 - 1 - (mmShift ? 1 : 0));

            // Step 3: Convert to a decimal power base using 64-bit arithmetic.
            uint vr vp vm;
            int e10;
            bool vmIsTrailingZeros = false;
            bool vrIsTrailingZeros = false;
            byte lastRemovedDigit = 0;
            if (e2 &gt;= 0)
            {
                uint q = (uint) log10Pow2(e2);
                e10 = (int) q;
                int k = (int) (FLOAT_POW5_INV_BITCOUNT + pow5bits((int) q) - 1);
                int i = (int) (-e2 + q + k);
                vr = mulPow5InvDivPow2(mv q i);
                vp = mulPow5InvDivPow2(mp q i);
                vm = mulPow5InvDivPow2(mm q i);
                if (q != 0 &amp;&amp; (vp - 1) / 10 &lt;= vm / 10)
                {
                    // We need to know one removed digit even if we are not going to loop below. We could use
                    // q = X - 1 above except that would require 33 bits for the result and we've found that
                    // 32-bit arithmetic is faster even on 64-bit machines.
                    int l = (int) (FLOAT_POW5_INV_BITCOUNT + pow5bits((int) (q - 1)) - 1);
                    lastRemovedDigit = (byte) mulPow5InvDivPow2(mv q - 1 (int) (-e2 + q - 1 + l) % 10);
                }

                if (q &lt;= 9)
                {
                    // The largest power of 5 that fits in 24 bits is 5^10 but q &lt;= 9 seems to be safe as well.
                    // Only one of mp mv and mm can be a multiple of 5 if any.
                    if (mv % 5 == 0)
                        vrIsTrailingZeros = multipleOfPowerOf5(mv q);
                    else if (acceptBounds)
                        vmIsTrailingZeros = multipleOfPowerOf5(mm q);
                    else
                        vp -= (uint) (multipleOfPowerOf5(mp q) ? 1 : 0);
                }
            }
            else
            {
                uint q = (uint) log10Pow5(-e2);
                e10 = (int) q + e2;
                int i = (int) (-e2 - q);
                int k = (int) (pow5bits(i) - FLOAT_POW5_BITCOUNT);
                int j = (int) (q - k);
                vr = mulPow5divPow2(mv (uint) i j);
                vp = mulPow5divPow2(mp (uint) i j);
                vm = mulPow5divPow2(mm (uint) i j);
                if (q != 0 &amp;&amp; (vp - 1) / 10 &lt;= vm / 10)
                {
                    j = (int) (q - 1 - (pow5bits(i + 1) - FLOAT_POW5_BITCOUNT));
                    lastRemovedDigit = (byte) (mulPow5divPow2(mv (uint) i + 1 j) % 10);
                }

                if (q &lt;= 1)
                {
                    // {vrvpvm} is trailing zeros if {mvmpmm} has at least q trailing 0 bits.
                    // mv = 4 * m2 so it always has at least two trailing 0 bits.
                    vrIsTrailingZeros = true;
                    if (acceptBounds)
                        vmIsTrailingZeros = mmShift;
                    else
                        --vp;
                }
                else if (q &lt; 31)
                {
                    // TODO(ulfjack): Use a tighter bound here.
                    vrIsTrailingZeros = multipleOfPowerOf2(mv q - 1);
                }
            }

            // Step 4: Find the shortest decimal representation in the interval of legal representations.
            uint removed = 0;
            uint output;
            if (vmIsTrailingZeros || vrIsTrailingZeros)
            {
                // General case which happens rarely (~4.0%).
                while (vp / 10 &gt; vm / 10)
                {
                    vmIsTrailingZeros &amp;= vm - vm / 10 * 10 == 0;
                    vrIsTrailingZeros &amp;= lastRemovedDigit == 0;
                    lastRemovedDigit = (byte) (vr % 10);
                    vr /= 10;
                    vp /= 10;
                    vm /= 10;
                    ++removed;
                }

                if (vmIsTrailingZeros)
                    while (vm % 10 == 0)
                    {
                        vrIsTrailingZeros &amp;= lastRemovedDigit == 0;
                        lastRemovedDigit = (byte) (vr % 10);
                        vr /= 10;
                        vp /= 10;
                        vm /= 10;
                        ++removed;
                    }

                if (vrIsTrailingZeros &amp;&amp; lastRemovedDigit == 5 &amp;&amp; vr % 2 == 0) lastRemovedDigit = 4;

                // We need to take vr + 1 if vr is outside bounds or we need to round up.
                output = (uint) (vr +
                                 (vr == vm &amp;&amp; (!acceptBounds || !vmIsTrailingZeros) || lastRemovedDigit &gt;= 5
                                     ? 1
                                     : 0));
            }
            else
            {
                // Specialized for the common case (~96.0%). Percentages below are relative to this.
                // Loop iterations below (approximately):
                // 0: 13.6% 1: 70.7% 2: 14.1% 3: 1.39% 4: 0.14% 5+: 0.01%
                while (vp / 10 &gt; vm / 10)
                {
                    lastRemovedDigit = (byte) (vr % 10);
                    vr /= 10;
                    vp /= 10;
                    vm /= 10;
                    ++removed;
                }

                // We need to take vr + 1 if vr is outside bounds or we need to round up.
                output = (uint) (vr + (vr == vm || lastRemovedDigit &gt;= 5 ? 1 : 0));
            }

            int exp = (int) (e10 + removed);


            floating_decimal_32 fd;
            fd.exponent = exp;
            fd.mantissa = output;
            return fd;
        }

        private static int to_chars(floating_decimal_32 v bool sign Span&lt;char&gt; result)
        {
            // Step 5: Print the decimal representation.
            int index = 0;
            if (sign) result[index++] = '-';

            uint output = v.mantissa;
            uint olength = decimalLength(output);

            // Print the decimal digits.
            // The following code is equivalent to:
            for (uint i = 0; i &lt; olength - 1; ++i)
            {
                uint c = output % 10;
                output /= 10;
                result[(int) (index + olength - i)] = (char) ('0' + c);
            }

            result[index] = (char) ('0' + output % 10);

            if (olength &gt; 1)
            {
                result[index + 1] = '.';
                index += (int) (olength + 1);
            }
            else
            {
                index++;
            }

            // Print the exponent.
            result[index++] = 'E';
            int exp = (int) (v.exponent + olength - 1);

            if (exp &lt; 0)
            {
                result[index++] = '-';
                exp = -exp;
            }

            if (exp &gt;= 100) result[index++] = (char) ('0' + exp / 100);

            if (exp &gt;= 10) result[index++] = (char) ('0' + exp / 10 % 10);

            result[index++] = (char) ('0' + exp % 10);


            return index;
        }

        private static int f2s_buffered_n(float f Span&lt;char&gt; result)
        {
            // Step 1: Decode the floating-point number and unify normalized and subnormal cases.
            uint bits = float_to_bits(f);


            // Decode bits into sign mantissa and exponent.
            bool ieeeSign = ((bits &gt;&gt; (FLOAT_MANTISSA_BITS + FLOAT_EXPONENT_BITS)) &amp; 1) != 0;
            uint ieeeMantissa = bits &amp; ((1u &lt;&lt; FLOAT_MANTISSA_BITS) - 1);
            uint ieeeExponent = (bits &gt;&gt; FLOAT_MANTISSA_BITS) &amp; ((1u &lt;&lt; FLOAT_EXPONENT_BITS) - 1);

            // Case distinction; exit early for the easy cases.
            if (ieeeExponent == (1u &lt;&lt; FLOAT_EXPONENT_BITS) - 1u || ieeeExponent == 0 &amp;&amp; ieeeMantissa == 0)
                return copy_special_str(result ieeeSign ieeeExponent == 0 ieeeMantissa == 0);

            floating_decimal_32 v = f2d(ieeeMantissa ieeeExponent);
            return to_chars(v ieeeSign result);
        }

        private static int copy_special_str(Span&lt;char&gt; result bool sign bool exponent bool mantissa)
        {
            if (mantissa)
            {
                result[0] = 'N';
                result[1] = 'a';
                result[2] = 'N';
                return 3;
            }

            if (sign) result[0] = '-';

            if (exponent)
            {
                result[1] = 'I';
                result[2] = 'n';
                result[3] = 'f';
                result[4] = 'i';
                result[5] = 'n';
                result[6] = 'i';
                result[7] = 't';
                result[8] = 'y';
                return 9;
            }

            result[1] = '0';
            result[2] = 'E';
            result[3] = '0';
            return 4;
        }

        public static string f2s(float f)
        {
            Span&lt;char&gt; result = stackalloc char[16];
            int index = f2s_buffered_n(f result);
            return result.Slice(0 index).ToString();
        }

        private static uint float_to_bits(float f)
        {
            uint bits = 0;
            bits = Unsafe.As&lt;float uint&gt;(ref f);
            return bits;
        }
    }
}

```
&lt;/details&gt;
</Title_Description>
    <Label>area-System.Runtime</Label>
    <Assignee>mazong1123</Assignee>
    <CreatedAt>22/08/2018 7:45:31 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19595</IssueLabelID>
    <Title>[WIP] Enable tiering</Title>
    <Description>
    </Description>
    <Title_Description>[WIP] Enable tiering </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19594</IssueLabelID>
    <Title>Newly implementd partial loop-unrolling support for RyuJIT </Title>
    <Description>This will replace PR : https://github.com/dotnet/coreclr/pull/18016</Description>
    <Title_Description>Newly implementd partial loop-unrolling support for RyuJIT  This will replace PR : https://github.com/dotnet/coreclr/pull/18016</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
    <CreatedAt>22/08/2018 4:40:28 AM +00:00</CreatedAt>
    <ClosedAt>7/11/2019 1:20:52 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19592</IssueLabelID>
    <Title>R2RDump - Invalid Machine type in the COFF header for Linux images</Title>
    <Description>Right now for ReadyToRun images created on Linux R2RDump isn't able to read the Machine type (Amd64 arm etc.). When I use dumpbin /HEADERS for Linux native images the machine type is also unknown

It tries to read the machine type from the CoffHeader using the PEReader but gets a large number instead of a valid machine type. The R2RReader currently writes a warning and sets the machine to Amd64
</Description>
    <Title_Description>R2RDump - Invalid Machine type in the COFF header for Linux images Right now for ReadyToRun images created on Linux R2RDump isn't able to read the Machine type (Amd64 arm etc.). When I use dumpbin /HEADERS for Linux native images the machine type is also unknown

It tries to read the machine type from the CoffHeader using the PEReader but gets a large number instead of a valid machine type. The R2RReader currently writes a warning and sets the machine to Amd64
</Title_Description>
    <Label>area-ReadyToRun</Label>
    <Assignee>acmyu</Assignee>
    <CreatedAt>22/08/2018 1:07:39 AM +00:00</CreatedAt>
    <ClosedAt>23/08/2018 10:02:04 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19591</IssueLabelID>
    <Title>Update RyuJIT overview and LSRA doc</Title>
    <Description>A number of changes have been made to the register allocator in particular #16517 and the documentation needs to be updated accordingly.

category:documentation
theme:ir
skill-level:expert
cost:medium</Description>
    <Title_Description>Update RyuJIT overview and LSRA doc A number of changes have been made to the register allocator in particular #16517 and the documentation needs to be updated accordingly.

category:documentation
theme:ir
skill-level:expert
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19587</IssueLabelID>
    <Title>[Win/x64] Visual Studio 2017 15.9.0 prerelease 1 fails to build coreclr repo</Title>
    <Description>Hitting reproducible build errors which indicate wrong environment for ml64.exe invocations - tool seems of the path at the moment of invocation or in general path is set for tools in build environment is wrong:

```cli
10&gt;C:\Program Files (x86)\Microsoft Visual Studio\Preview\Community\Common7\IDE\VC\VCTargets\BuildCustomizations\masm.targets(695):
 error MSB3721: The command "ml64.exe /c /nologo /Zi /Fo"cee_wks.dir\Checked\AsmHelpers.obj" /D"_AMD64_" /D"_WIN64" /D"AMD64"
 /D"BIT64=1" /D"FEATURE_DEFAULT_INTERFACES=1" /D"_TARGET_AMD64_=1" /D"_TARGET_64BIT_=1" /D"DBG_TARGET_64BIT=1" 
/D"DBG_TARGET_AMD64=1" /D"DBG_TARGET_WIN64=1" /D"_BLD_CLR" /D"DEBUGGING_SUPPORTED" /D"PROFILING_SUPPORTED" /D"WIN32" 
/D"_WIN32" /D"WINVER=0x0602" /D"_WIN32_WINNT=0x0602" /D"WIN32_LEAN_AND_MEAN=1" /D"_CRT_SECURE_NO_WARNINGS" 
/D"EnC_SUPPORTED" /D"FEATURE_APPDOMAIN_RESOURCE_MONITORING" /D"FEATURE_APPX" /D"FEATURE_ARRAYSTUB_AS_IL" 
/D"FEATURE_MULTICASTSTUB_AS_IL" /D"FEATURE_CODE_VERSIONING" /D"FEATURE_COLLECTIBLE_TYPES" /D"FEATURE_CLASSIC_COMINTEROP" 
/D"FEATURE_COMINTEROP" /D"FEATURE_COMINTEROP_APARTMENT_SUPPORT" /D"FEATURE_COMINTEROP_UNMANAGED_ACTIVATION" 
/D"FEATURE_COMINTEROP_WINRT_MANAGED_ACTIVATION" /D"FEATURE_CORECLR" /D"FEATURE_CORESYSTEM" 
/D"FEATURE_CORRUPTING_EXCEPTIONS" /D"FEATURE_EVENT_TRACE=1" /D"FEATURE_PERFTRACING=1" /D"FEATURE_HIJACK" 
/D"FEATURE_ICASTABLE" /D"FEATURE_INTEROP_DEBUGGING" /D"FEATURE_ISYM_READER" /D"FEATURE_JUMPSTAMP"
 /D"FEATURE_LOADER_OPTIMIZATION" /D"FEATURE_MANAGED_ETW" /D"FEATURE_MANAGED_ETW_CHANNELS" /D"FEATURE_MULTICOREJIT"
 /D"FEATURE_PREJIT" /D"FEATURE_PROFAPI_ATTACH_DETACH" /D"FEATURE_READYTORUN" /D"FEATURE_REJIT" /D"FEATURE_STANDALONE_SN" 
/D"FEATURE_STRONGNAME_DELAY_SIGNING_ALLOWED" /D"FEATURE_STRONGNAME_MIGRATION" /D"FEATURE_SVR_GC" 
/D"FEATURE_SYMDIFF" /D"FEATURE_TIERED_COMPILATION" /D"UNIX_AMD64_ABI_ITF" /D"FEATURE_USE_ASM_GC_WRITE_BARRIERS" 
/D"FEATURE_USE_SOFTWARE_WRITE_WATCH_FOR_GC_HEAP" /D"FEATURE_VERSIONING_LOG" /D"FEATURE_WIN32_REGISTRY" 
/D"FEATURE_LEGACYNETCF_DBG_HOST_CONTROL" /D"FEATURE_WINDOWSPHONE" /D"FEATURE_WINMD_RESILIENT" /D"_SECURE_SCL=0" 
/D"UNICODE" /D"_UNICODE" /D"FEATURE_STANDALONE_GC" /D"DEBUG" /D"_DEBUG" /D"_DBG" /D"URTBLDENV_FRIENDLY=Checked" 
/D"BUILDENV_CHECKED=1" /D"WRITE_BARRIER_CHECK=1" /D"DEBUG" /D"_DEBUG" /D"_DBG" /D"URTBLDENV_FRIENDLY=Checked" 
/D"BUILDENV_CHECKED=1" /D"_AMD64_" /D"_WIN64" /D"AMD64" /D"BIT64=1" /D"FEATURE_DEFAULT_INTERFACES=1" 
/D"_TARGET_AMD64_=1" /D"_TARGET_64BIT_=1" /D"DBG_TARGET_64BIT=1" /D"DBG_TARGET_AMD64=1" /D"DBG_TARGET_WIN64=1" 
/D"_BLD_CLR" /D"DEBUGGING_SUPPORTED" /D"PROFILING_SUPPORTED" /D"WIN32" /D"_WIN32" /D"WINVER=0x0602" 
/D"_WIN32_WINNT=0x0602" /D"WIN32_LEAN_AND_MEAN=1" /D"_CRT_SECURE_NO_WARNINGS" /D"EnC_SUPPORTED" 
/D"FEATURE_APPDOMAIN_RESOURCE_MONITORING" /D"FEATURE_APPX" /D"FEATURE_ARRAYSTUB_AS_IL" /D"FEATURE_MULTICASTSTUB_AS_IL" 
/D"FEATURE_CODE_VERSIONING" /D"FEATURE_COLLECTIBLE_TYPES" /D"FEATURE_CLASSIC_COMINTEROP" /D"FEATURE_COMINTEROP" 
/D"FEATURE_COMINTEROP_APARTMENT_SUPPORT" /D"FEATURE_COMINTEROP_UNMANAGED_ACTIVATION" 
/D"FEATURE_COMINTEROP_WINRT_MANAGED_ACTIVATION" /D"FEATURE_CORECLR" /D"FEATURE_CORESYSTEM" 
/D"FEATURE_CORRUPTING_EXCEPTIONS" /D"FEATURE_EVENT_TRACE=1" /D"FEATURE_PERFTRACING=1" /D"FEATURE_HIJACK" 
/D"FEATURE_ICASTABLE" /D"FEATURE_INTEROP_DEBUGGING" /D"FEATURE_ISYM_READER" /D"FEATURE_JUMPSTAMP" 
/D"FEATURE_LOADER_OPTIMIZATION" /D"FEATURE_MANAGED_ETW" /D"FEATURE_MANAGED_ETW_CHANNELS" /D"FEATURE_MULTICOREJIT" 
/D"FEATURE_PREJIT" /D"FEATURE_PROFAPI_ATTACH_DETACH" /D"FEATURE_READYTORUN" /D"FEATURE_REJIT" /D"FEATURE_STANDALONE_SN" 
/D"FEATURE_STRONGNAME_DELAY_SIGNING_ALLOWED" /D"FEATURE_STRONGNAME_MIGRATION" /D"FEATURE_SVR_GC" 
/D"FEATURE_SYMDIFF" /D"FEATURE_TIERED_COMPILATION" /D"UNIX_AMD64_ABI_ITF" /D"FEATURE_USE_ASM_GC_WRITE_BARRIERS" 
/D"FEATURE_USE_SOFTWARE_WRITE_WATCH_FOR_GC_HEAP" /D"FEATURE_VERSIONING_LOG" /D"FEATURE_WIN32_REGISTRY" 
/D"FEATURE_LEGACYNETCF_DBG_HOST_CONTROL" /D"FEATURE_WINDOWSPHONE" /D"FEATURE_WINMD_RESILIENT" /D"_SECURE_SCL=0" 
/D"UNICODE" /D"_UNICODE" /D"FEATURE_STANDALONE_GC" /D"WRITE_BARRIER_CHECK=1" /D"CMAKE_INTDIR="Checked"" /I 
"E:\src\ms\dotnet\coreclr-sse2\bin\obj\Windows_NT.x64.Checked\src\vm\wks" /I "E:\src\ms\dotnet\coreclr-sse2\src\vm\wks" 
/I "E:\src\ms\dotnet\coreclr-sse2\src\vm" /I "E:\src\ms\dotnet\coreclr-sse2\src\pal\prebuilt\inc" /I "E:\src\ms\dotnet\coreclr-sse2\bin\obj" 
/I "E:\src\ms\dotnet\coreclr-sse2\src\inc" /I "E:\src\ms\dotnet\coreclr-sse2\src\strongname\inc" /I "E:\src\ms\dotnet\coreclr-sse2\src\inc\winrt" 
/I "E:\src\ms\dotnet\coreclr-sse2\src\debug\inc" /I "E:\src\ms\dotnet\coreclr-sse2\src\debug\inc\amd64" 
/I "E:\src\ms\dotnet\coreclr-sse2\src\debug\inc\dump" /I "E:\src\ms\dotnet\coreclr-sse2\src\md\inc"
 /I "E:\src\ms\dotnet\coreclr-sse2\src\classlibnative\bcltype" /I "E:\src\ms\dotnet\coreclr-sse2\src\classlibnative\cryptography" 
/I "E:\src\ms\dotnet\coreclr-sse2\src\classlibnative\inc" /I "E:\src\ms\dotnet\coreclr-sse2\bin\obj\Windows_NT.x64.Checked\src\inc"
 /I "E:\src\ms\dotnet\coreclr-sse2\bin\obj\Windows_NT.x64.Checked\src\inc\etw" /I "E:\src\ms\dotnet\coreclr-sse2\src\vm\amd64" /W3 /errorReport:prompt  /ZH:SHA_256 /Ta"E:\src\ms\dotnet\coreclr-sse2\src\vm\amd64\AsmHelpers.asm"" exited with code 1. 
[E:\src\ms\dotnet\coreclr-sse2\bin\obj\Windows_NT.x64.Checked\src\vm\wks\cee_wks.vcxproj]

```</Description>
    <Title_Description>[Win/x64] Visual Studio 2017 15.9.0 prerelease 1 fails to build coreclr repo Hitting reproducible build errors which indicate wrong environment for ml64.exe invocations - tool seems of the path at the moment of invocation or in general path is set for tools in build environment is wrong:

```cli
10&gt;C:\Program Files (x86)\Microsoft Visual Studio\Preview\Community\Common7\IDE\VC\VCTargets\BuildCustomizations\masm.targets(695):
 error MSB3721: The command "ml64.exe /c /nologo /Zi /Fo"cee_wks.dir\Checked\AsmHelpers.obj" /D"_AMD64_" /D"_WIN64" /D"AMD64"
 /D"BIT64=1" /D"FEATURE_DEFAULT_INTERFACES=1" /D"_TARGET_AMD64_=1" /D"_TARGET_64BIT_=1" /D"DBG_TARGET_64BIT=1" 
/D"DBG_TARGET_AMD64=1" /D"DBG_TARGET_WIN64=1" /D"_BLD_CLR" /D"DEBUGGING_SUPPORTED" /D"PROFILING_SUPPORTED" /D"WIN32" 
/D"_WIN32" /D"WINVER=0x0602" /D"_WIN32_WINNT=0x0602" /D"WIN32_LEAN_AND_MEAN=1" /D"_CRT_SECURE_NO_WARNINGS" 
/D"EnC_SUPPORTED" /D"FEATURE_APPDOMAIN_RESOURCE_MONITORING" /D"FEATURE_APPX" /D"FEATURE_ARRAYSTUB_AS_IL" 
/D"FEATURE_MULTICASTSTUB_AS_IL" /D"FEATURE_CODE_VERSIONING" /D"FEATURE_COLLECTIBLE_TYPES" /D"FEATURE_CLASSIC_COMINTEROP" 
/D"FEATURE_COMINTEROP" /D"FEATURE_COMINTEROP_APARTMENT_SUPPORT" /D"FEATURE_COMINTEROP_UNMANAGED_ACTIVATION" 
/D"FEATURE_COMINTEROP_WINRT_MANAGED_ACTIVATION" /D"FEATURE_CORECLR" /D"FEATURE_CORESYSTEM" 
/D"FEATURE_CORRUPTING_EXCEPTIONS" /D"FEATURE_EVENT_TRACE=1" /D"FEATURE_PERFTRACING=1" /D"FEATURE_HIJACK" 
/D"FEATURE_ICASTABLE" /D"FEATURE_INTEROP_DEBUGGING" /D"FEATURE_ISYM_READER" /D"FEATURE_JUMPSTAMP"
 /D"FEATURE_LOADER_OPTIMIZATION" /D"FEATURE_MANAGED_ETW" /D"FEATURE_MANAGED_ETW_CHANNELS" /D"FEATURE_MULTICOREJIT"
 /D"FEATURE_PREJIT" /D"FEATURE_PROFAPI_ATTACH_DETACH" /D"FEATURE_READYTORUN" /D"FEATURE_REJIT" /D"FEATURE_STANDALONE_SN" 
/D"FEATURE_STRONGNAME_DELAY_SIGNING_ALLOWED" /D"FEATURE_STRONGNAME_MIGRATION" /D"FEATURE_SVR_GC" 
/D"FEATURE_SYMDIFF" /D"FEATURE_TIERED_COMPILATION" /D"UNIX_AMD64_ABI_ITF" /D"FEATURE_USE_ASM_GC_WRITE_BARRIERS" 
/D"FEATURE_USE_SOFTWARE_WRITE_WATCH_FOR_GC_HEAP" /D"FEATURE_VERSIONING_LOG" /D"FEATURE_WIN32_REGISTRY" 
/D"FEATURE_LEGACYNETCF_DBG_HOST_CONTROL" /D"FEATURE_WINDOWSPHONE" /D"FEATURE_WINMD_RESILIENT" /D"_SECURE_SCL=0" 
/D"UNICODE" /D"_UNICODE" /D"FEATURE_STANDALONE_GC" /D"DEBUG" /D"_DEBUG" /D"_DBG" /D"URTBLDENV_FRIENDLY=Checked" 
/D"BUILDENV_CHECKED=1" /D"WRITE_BARRIER_CHECK=1" /D"DEBUG" /D"_DEBUG" /D"_DBG" /D"URTBLDENV_FRIENDLY=Checked" 
/D"BUILDENV_CHECKED=1" /D"_AMD64_" /D"_WIN64" /D"AMD64" /D"BIT64=1" /D"FEATURE_DEFAULT_INTERFACES=1" 
/D"_TARGET_AMD64_=1" /D"_TARGET_64BIT_=1" /D"DBG_TARGET_64BIT=1" /D"DBG_TARGET_AMD64=1" /D"DBG_TARGET_WIN64=1" 
/D"_BLD_CLR" /D"DEBUGGING_SUPPORTED" /D"PROFILING_SUPPORTED" /D"WIN32" /D"_WIN32" /D"WINVER=0x0602" 
/D"_WIN32_WINNT=0x0602" /D"WIN32_LEAN_AND_MEAN=1" /D"_CRT_SECURE_NO_WARNINGS" /D"EnC_SUPPORTED" 
/D"FEATURE_APPDOMAIN_RESOURCE_MONITORING" /D"FEATURE_APPX" /D"FEATURE_ARRAYSTUB_AS_IL" /D"FEATURE_MULTICASTSTUB_AS_IL" 
/D"FEATURE_CODE_VERSIONING" /D"FEATURE_COLLECTIBLE_TYPES" /D"FEATURE_CLASSIC_COMINTEROP" /D"FEATURE_COMINTEROP" 
/D"FEATURE_COMINTEROP_APARTMENT_SUPPORT" /D"FEATURE_COMINTEROP_UNMANAGED_ACTIVATION" 
/D"FEATURE_COMINTEROP_WINRT_MANAGED_ACTIVATION" /D"FEATURE_CORECLR" /D"FEATURE_CORESYSTEM" 
/D"FEATURE_CORRUPTING_EXCEPTIONS" /D"FEATURE_EVENT_TRACE=1" /D"FEATURE_PERFTRACING=1" /D"FEATURE_HIJACK" 
/D"FEATURE_ICASTABLE" /D"FEATURE_INTEROP_DEBUGGING" /D"FEATURE_ISYM_READER" /D"FEATURE_JUMPSTAMP" 
/D"FEATURE_LOADER_OPTIMIZATION" /D"FEATURE_MANAGED_ETW" /D"FEATURE_MANAGED_ETW_CHANNELS" /D"FEATURE_MULTICOREJIT" 
/D"FEATURE_PREJIT" /D"FEATURE_PROFAPI_ATTACH_DETACH" /D"FEATURE_READYTORUN" /D"FEATURE_REJIT" /D"FEATURE_STANDALONE_SN" 
/D"FEATURE_STRONGNAME_DELAY_SIGNING_ALLOWED" /D"FEATURE_STRONGNAME_MIGRATION" /D"FEATURE_SVR_GC" 
/D"FEATURE_SYMDIFF" /D"FEATURE_TIERED_COMPILATION" /D"UNIX_AMD64_ABI_ITF" /D"FEATURE_USE_ASM_GC_WRITE_BARRIERS" 
/D"FEATURE_USE_SOFTWARE_WRITE_WATCH_FOR_GC_HEAP" /D"FEATURE_VERSIONING_LOG" /D"FEATURE_WIN32_REGISTRY" 
/D"FEATURE_LEGACYNETCF_DBG_HOST_CONTROL" /D"FEATURE_WINDOWSPHONE" /D"FEATURE_WINMD_RESILIENT" /D"_SECURE_SCL=0" 
/D"UNICODE" /D"_UNICODE" /D"FEATURE_STANDALONE_GC" /D"WRITE_BARRIER_CHECK=1" /D"CMAKE_INTDIR="Checked"" /I 
"E:\src\ms\dotnet\coreclr-sse2\bin\obj\Windows_NT.x64.Checked\src\vm\wks" /I "E:\src\ms\dotnet\coreclr-sse2\src\vm\wks" 
/I "E:\src\ms\dotnet\coreclr-sse2\src\vm" /I "E:\src\ms\dotnet\coreclr-sse2\src\pal\prebuilt\inc" /I "E:\src\ms\dotnet\coreclr-sse2\bin\obj" 
/I "E:\src\ms\dotnet\coreclr-sse2\src\inc" /I "E:\src\ms\dotnet\coreclr-sse2\src\strongname\inc" /I "E:\src\ms\dotnet\coreclr-sse2\src\inc\winrt" 
/I "E:\src\ms\dotnet\coreclr-sse2\src\debug\inc" /I "E:\src\ms\dotnet\coreclr-sse2\src\debug\inc\amd64" 
/I "E:\src\ms\dotnet\coreclr-sse2\src\debug\inc\dump" /I "E:\src\ms\dotnet\coreclr-sse2\src\md\inc"
 /I "E:\src\ms\dotnet\coreclr-sse2\src\classlibnative\bcltype" /I "E:\src\ms\dotnet\coreclr-sse2\src\classlibnative\cryptography" 
/I "E:\src\ms\dotnet\coreclr-sse2\src\classlibnative\inc" /I "E:\src\ms\dotnet\coreclr-sse2\bin\obj\Windows_NT.x64.Checked\src\inc"
 /I "E:\src\ms\dotnet\coreclr-sse2\bin\obj\Windows_NT.x64.Checked\src\inc\etw" /I "E:\src\ms\dotnet\coreclr-sse2\src\vm\amd64" /W3 /errorReport:prompt  /ZH:SHA_256 /Ta"E:\src\ms\dotnet\coreclr-sse2\src\vm\amd64\AsmHelpers.asm"" exited with code 1. 
[E:\src\ms\dotnet\coreclr-sse2\bin\obj\Windows_NT.x64.Checked\src\vm\wks\cee_wks.vcxproj]

```</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>21/08/2018 8:57:00 PM +00:00</CreatedAt>
    <ClosedAt>25/08/2018 8:57:49 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19584</IssueLabelID>
    <Title>Fix JitBench</Title>
    <Description>Fixes https://github.com/dotnet/coreclr/issues/19569
- I believe the issue was that JitBench (which was a netstandard1.6 project) was running against a netcoreapp3.0 layout with corerun (layout built using build + recent packages by runtests.cmd) and XmlDocument is in a different place now
- Copied the unofficial project and replaced the official one
- Switched to netcoreapp3.0 along with other miscellaneous fixes to get it working
- I haven't figured out yet how to get one project that builds with the test build and works with dotnet. TargetFramework would have to be different anyway if running with dotnet runtime 2.1. So the unofficial project is still there for use with dotnet.</Description>
    <Title_Description>Fix JitBench Fixes https://github.com/dotnet/coreclr/issues/19569
- I believe the issue was that JitBench (which was a netstandard1.6 project) was running against a netcoreapp3.0 layout with corerun (layout built using build + recent packages by runtests.cmd) and XmlDocument is in a different place now
- Copied the unofficial project and replaced the official one
- Switched to netcoreapp3.0 along with other miscellaneous fixes to get it working
- I haven't figured out yet how to get one project that builds with the test build and works with dotnet. TargetFramework would have to be different anyway if running with dotnet runtime 2.1. So the unofficial project is still there for use with dotnet.</Title_Description>
    <Label>area-Meta</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19583</IssueLabelID>
    <Title>RyuJIT: Incorrect ordering around Interlocked.Exchange and Interlocked.CompareExchange</Title>
    <Description>Example:
```csharp
// Debug: Outputs 0
// Release: Outputs 1
public class Program
{
    static long s_1;
    static int s_3;
    public static void Main()
    {
        int vr16 = s_3;
        int vr19 = System.Threading.Interlocked.Exchange(ref s_3 1);
        s_1 = vr16;
        System.Console.WriteLine(s_1);
    }
}
```
It also reproduces if `Exchange(ref s_3 1)` is replaced by `CompareExchange(ref s_3 1 s_3)`.

[Quoting @mikedn](https://github.com/dotnet/coreclr/issues/18770#issuecomment-414626759):
&gt; a quick look at the dump shows that the load from s_3 moved past exchange quite early possibly as early as import time.
```
Importing BB01 (PC=000) of 'Program:Main()'
    [ 0]   0 (0x000) ldsfld 04000002
    [ 1]   5 (0x005) ldsflda 04000002
    [ 2]  10 (0x00a) ldc.i4.1 1
    [ 3]  11 (0x00b) call 0A000006
In Compiler::impImportCall: opcode is call kind=0 callRetType is int structSize is 0

    [ 2]  16 (0x010) pop

               [000007] ------------              *  STMT      void  (IL 0x000...  ???)
               [000005] ------------              |  /--*  NOP       void  
               [000006] -A--G-------              \--*  COMMA     void  
               [000003] ------------                 |  /--*  CNS_INT   int    1
               [000004] -A--G-------                 \--*  XCHG      int   
               [000002] ------------                    \--*  CNS_INT(h) long   0x7ffb4ffb4598 static Fseq[s_3]

    [ 1]  17 (0x011) conv.i8
    [ 1]  18 (0x012) stsfld 04000001

               [000011] ------------              *  STMT      void  (IL   ???...  ???)
               [000008] ----G-------              |  /--*  CAST      long &lt;- int
               [000001] ----G-------              |  |  \--*  FIELD     int    s_3
               [000010] -A--G-------              \--*  ASG       long  
               [000009] ----G--N----                 \--*  FIELD     long   s_1
```</Description>
    <Title_Description>RyuJIT: Incorrect ordering around Interlocked.Exchange and Interlocked.CompareExchange Example:
```csharp
// Debug: Outputs 0
// Release: Outputs 1
public class Program
{
    static long s_1;
    static int s_3;
    public static void Main()
    {
        int vr16 = s_3;
        int vr19 = System.Threading.Interlocked.Exchange(ref s_3 1);
        s_1 = vr16;
        System.Console.WriteLine(s_1);
    }
}
```
It also reproduces if `Exchange(ref s_3 1)` is replaced by `CompareExchange(ref s_3 1 s_3)`.

[Quoting @mikedn](https://github.com/dotnet/coreclr/issues/18770#issuecomment-414626759):
&gt; a quick look at the dump shows that the load from s_3 moved past exchange quite early possibly as early as import time.
```
Importing BB01 (PC=000) of 'Program:Main()'
    [ 0]   0 (0x000) ldsfld 04000002
    [ 1]   5 (0x005) ldsflda 04000002
    [ 2]  10 (0x00a) ldc.i4.1 1
    [ 3]  11 (0x00b) call 0A000006
In Compiler::impImportCall: opcode is call kind=0 callRetType is int structSize is 0

    [ 2]  16 (0x010) pop

               [000007] ------------              *  STMT      void  (IL 0x000...  ???)
               [000005] ------------              |  /--*  NOP       void  
               [000006] -A--G-------              \--*  COMMA     void  
               [000003] ------------                 |  /--*  CNS_INT   int    1
               [000004] -A--G-------                 \--*  XCHG      int   
               [000002] ------------                    \--*  CNS_INT(h) long   0x7ffb4ffb4598 static Fseq[s_3]

    [ 1]  17 (0x011) conv.i8
    [ 1]  18 (0x012) stsfld 04000001

               [000011] ------------              *  STMT      void  (IL   ???...  ???)
               [000008] ----G-------              |  /--*  CAST      long &lt;- int
               [000001] ----G-------              |  |  \--*  FIELD     int    s_3
               [000010] -A--G-------              \--*  ASG       long  
               [000009] ----G--N----                 \--*  FIELD     long   s_1
```</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>21/08/2018 10:50:22 AM +00:00</CreatedAt>
    <ClosedAt>24/01/2019 7:59:48 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19578</IssueLabelID>
    <Title>csc.dll code 139 error when building project on .NET Core 2.1.302 Ubuntu 16.04 ARM64</Title>
    <Description>I have downloaded .NET Core SDK for linux ARM64 on my Jetson TX2 running ubuntu 16.04.

```
nvidia@tegra-ubuntu:~$ dotnet --info
.NET Core SDK (reflecting any global.json):
 Version:   2.1.302
 Commit:    9048955601

Runtime Environment:
 OS Name:     ubuntu
 OS Version:  16.04
 OS Platform: Linux
 RID:         ubuntu.16.04-arm64
 Base Path:   /usr/share/dotnet/sdk/2.1.302/

Host (useful for support):
  Version: 2.1.2
  Commit:  811c3ce6c0

.NET Core SDKs installed:
  2.1.302 [/usr/share/dotnet/sdk]

.NET Core runtimes installed:
  Microsoft.NETCore.App 2.1.2 [/usr/share/dotnet/shared/Microsoft.NETCore.App]

To install additional .NET Core runtimes or SDKs:
  https://aka.ms/dotnet-download
nvidia@tegra-ubuntu:~$ 

```

However I am unable to run any dotnet application (even the hello world example) on my Jetson TX2.


```
nvidia@tegra-ubuntu:~$ dotnet new console -o myApp --force
The template "Console Application" was created successfully.

Processing post-creation actions...
Running 'dotnet restore' on myApp/myApp.csproj...
  Restoring packages for /home/nvidia/myApp/myApp.csproj...
  Generating MSBuild file /home/nvidia/myApp/obj/myApp.csproj.nuget.g.props.
  Generating MSBuild file /home/nvidia/myApp/obj/myApp.csproj.nuget.g.targets.
  Restore completed in 1.58 sec for /home/nvidia/myApp/myApp.csproj.

Restore succeeded.
```
```
nvidia@tegra-ubuntu:~/myApp$ dotnet run
/usr/share/dotnet/sdk/2.1.302/Roslyn/Microsoft.CSharp.Core.targets(525): error MSB6006: "csc.dll" exited with code 139. [/home/nvidia/myApp/myApp.csproj]

The build failed. Please fix the build errors and run again.
```


I wish to build iotedge for Jetson TX2 and dotnet Core 2.1 is a dependency for the same.

This is my binary log file. I had to rename it with a .zip extension to upload here.
just rename the file from msbuild.binlog.zip to msbuild.binlog

[msbuild.binlog.zip](https://github.com/dotnet/roslyn/files/2296720/msbuild.binlog.zip)


https://github.com/dotnet/roslyn/issues/29194</Description>
    <Title_Description>csc.dll code 139 error when building project on .NET Core 2.1.302 Ubuntu 16.04 ARM64 I have downloaded .NET Core SDK for linux ARM64 on my Jetson TX2 running ubuntu 16.04.

```
nvidia@tegra-ubuntu:~$ dotnet --info
.NET Core SDK (reflecting any global.json):
 Version:   2.1.302
 Commit:    9048955601

Runtime Environment:
 OS Name:     ubuntu
 OS Version:  16.04
 OS Platform: Linux
 RID:         ubuntu.16.04-arm64
 Base Path:   /usr/share/dotnet/sdk/2.1.302/

Host (useful for support):
  Version: 2.1.2
  Commit:  811c3ce6c0

.NET Core SDKs installed:
  2.1.302 [/usr/share/dotnet/sdk]

.NET Core runtimes installed:
  Microsoft.NETCore.App 2.1.2 [/usr/share/dotnet/shared/Microsoft.NETCore.App]

To install additional .NET Core runtimes or SDKs:
  https://aka.ms/dotnet-download
nvidia@tegra-ubuntu:~$ 

```

However I am unable to run any dotnet application (even the hello world example) on my Jetson TX2.


```
nvidia@tegra-ubuntu:~$ dotnet new console -o myApp --force
The template "Console Application" was created successfully.

Processing post-creation actions...
Running 'dotnet restore' on myApp/myApp.csproj...
  Restoring packages for /home/nvidia/myApp/myApp.csproj...
  Generating MSBuild file /home/nvidia/myApp/obj/myApp.csproj.nuget.g.props.
  Generating MSBuild file /home/nvidia/myApp/obj/myApp.csproj.nuget.g.targets.
  Restore completed in 1.58 sec for /home/nvidia/myApp/myApp.csproj.

Restore succeeded.
```
```
nvidia@tegra-ubuntu:~/myApp$ dotnet run
/usr/share/dotnet/sdk/2.1.302/Roslyn/Microsoft.CSharp.Core.targets(525): error MSB6006: "csc.dll" exited with code 139. [/home/nvidia/myApp/myApp.csproj]

The build failed. Please fix the build errors and run again.
```


I wish to build iotedge for Jetson TX2 and dotnet Core 2.1 is a dependency for the same.

This is my binary log file. I had to rename it with a .zip extension to upload here.
just rename the file from msbuild.binlog.zip to msbuild.binlog

[msbuild.binlog.zip](https://github.com/dotnet/roslyn/files/2296720/msbuild.binlog.zip)


https://github.com/dotnet/roslyn/issues/29194</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>jashook</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19574</IssueLabelID>
    <Title>IBC Optimization changes broke some CoreCLR official builds</Title>
    <Description>Appears to be a side-effect of https://github.com/dotnet/coreclr/pull/19046  
@adiaaida please see me if I am mistaken or you need any assistance investigating.

Opened on behalf of @MattGal



Warnings: 1
Status Message: failed

Build : 3.0 - 20180821.01 (Product Build)
Failing configurations:
- Windows
  - PortableBuild-Checked-arm
  - PortableBuild-Checked-arm64
  - PortableBuild-Checked-x64
  - PortableBuild-Debug-arm
  - PortableBuild-Debug-arm64
  - PortableBuild-Debug-x64
  - PortableBuild-Release-arm
  - PortableBuild-Release-arm64
[Mission Control Build Info](https://mc.dot.net/#/product/netcore/30/source/official~2Fcoreclr~2Fmaster~2F/type/build~2Fproduct~2F/build/20180821.01/workItem/Orchestration/analysis/external/Link)</Description>
    <Title_Description>IBC Optimization changes broke some CoreCLR official builds Appears to be a side-effect of https://github.com/dotnet/coreclr/pull/19046  
@adiaaida please see me if I am mistaken or you need any assistance investigating.

Opened on behalf of @MattGal



Warnings: 1
Status Message: failed

Build : 3.0 - 20180821.01 (Product Build)
Failing configurations:
- Windows
  - PortableBuild-Checked-arm
  - PortableBuild-Checked-arm64
  - PortableBuild-Checked-x64
  - PortableBuild-Debug-arm
  - PortableBuild-Debug-arm64
  - PortableBuild-Debug-x64
  - PortableBuild-Release-arm
  - PortableBuild-Release-arm64
[Mission Control Build Info](https://mc.dot.net/#/product/netcore/30/source/official~2Fcoreclr~2Fmaster~2F/type/build~2Fproduct~2F/build/20180821.01/workItem/Orchestration/analysis/external/Link)</Title_Description>
    <Label>blocking-official-build</Label>
    <Assignee>MattGal</Assignee>
    <CreatedAt>21/08/2018 12:49:39 AM +00:00</CreatedAt>
    <ClosedAt>21/08/2018 5:30:29 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19573</IssueLabelID>
    <Title>roundUp roundDn cleanup</Title>
    <Description>This PR overloads `roundUp`/`roundDn` functions under `_HOST_64BIT_` and removes all the castings of return values and passed arguments (becoming unnecessary after the change).

I wonder if we need `roundDn` at all? Its "refCount" is zero right now.</Description>
    <Title_Description>roundUp roundDn cleanup This PR overloads `roundUp`/`roundDn` functions under `_HOST_64BIT_` and removes all the castings of return values and passed arguments (becoming unnecessary after the change).

I wonder if we need `roundDn` at all? Its "refCount" is zero right now.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>echesakovMSFT</Assignee>
    <CreatedAt>21/08/2018 12:48:57 AM +00:00</CreatedAt>
    <ClosedAt>21/08/2018 5:56:37 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19570</IssueLabelID>
    <Title>Fix dbgshim's &gt; 1000 module bug (issue #19538) (#19553)</Title>
    <Description>Fix dbgshim's &gt; 1000 module bug (issue #19538)

Cap cbNeeded on second EnumProcessModules call. Change the allocations
to HMODULE to make sure they are aligned properly.</Description>
    <Title_Description>Fix dbgshim's &gt; 1000 module bug (issue #19538) (#19553) Fix dbgshim's &gt; 1000 module bug (issue #19538)

Cap cbNeeded on second EnumProcessModules call. Change the allocations
to HMODULE to make sure they are aligned properly.</Title_Description>
    <Label>
    </Label>
    <Assignee>mikem8361</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19569</IssueLabelID>
    <Title>CoreClr Performance Scenarios broke after PR #19479</Title>
    <Description>After https://github.com/dotnet/coreclr/pull/19479 the performance scenarios started failing with the following error:
```log
Unhandled Exception: System.AggregateException: One or more errors occurred. (Could not load file or assembly 'System.Xml.XPath.XmlDocument Version=4.0.2.0 Culture=neutral PublicKeyToken=b03f5f7f11d50a3a'. The system cannot find the file specified.) ---&gt; System.IO.FileNotFoundException: Could not load file or assembly 'System.Xml.XPath.XmlDocument Version=4.0.2.0 Culture=neutral PublicKeyToken=b03f5f7f11d50a3a'. The system cannot find the file specified.
   at JitBench.Benchmark.RetargetProjects(DotNetInstallation dotNetInstall String rootDir IEnumerable`1 projectFileRelativePaths)
   at JitBench.BuildHelloWorldBenchmark.SetupHelloWorldProject(DotNetInstallation dotNetInstall String intermediateOutputDir Boolean useExistingSetup ITestOutputHelper output)
   at JitBench.BuildHelloWorldBenchmark.Setup(DotNetInstallation dotNetInstall String intermediateOutputDir Boolean useExistingSetup ITestOutputHelper output)
   at JitBench.TestRun.SetupBenchmarks(ITestOutputHelper output)
   --- End of inner exception stack trace ---
   at System.Threading.Tasks.Task.Wait(Int32 millisecondsTimeout CancellationToken cancellationToken)
   at JitBench.TestRun.Run(ITestOutputHelper output)
   at JitBench.Program.Main(String[] args)
```

/cc @noahfalk @AndyAyersMS </Description>
    <Title_Description>CoreClr Performance Scenarios broke after PR #19479 After https://github.com/dotnet/coreclr/pull/19479 the performance scenarios started failing with the following error:
```log
Unhandled Exception: System.AggregateException: One or more errors occurred. (Could not load file or assembly 'System.Xml.XPath.XmlDocument Version=4.0.2.0 Culture=neutral PublicKeyToken=b03f5f7f11d50a3a'. The system cannot find the file specified.) ---&gt; System.IO.FileNotFoundException: Could not load file or assembly 'System.Xml.XPath.XmlDocument Version=4.0.2.0 Culture=neutral PublicKeyToken=b03f5f7f11d50a3a'. The system cannot find the file specified.
   at JitBench.Benchmark.RetargetProjects(DotNetInstallation dotNetInstall String rootDir IEnumerable`1 projectFileRelativePaths)
   at JitBench.BuildHelloWorldBenchmark.SetupHelloWorldProject(DotNetInstallation dotNetInstall String intermediateOutputDir Boolean useExistingSetup ITestOutputHelper output)
   at JitBench.BuildHelloWorldBenchmark.Setup(DotNetInstallation dotNetInstall String intermediateOutputDir Boolean useExistingSetup ITestOutputHelper output)
   at JitBench.TestRun.SetupBenchmarks(ITestOutputHelper output)
   --- End of inner exception stack trace ---
   at System.Threading.Tasks.Task.Wait(Int32 millisecondsTimeout CancellationToken cancellationToken)
   at JitBench.TestRun.Run(ITestOutputHelper output)
   at JitBench.Program.Main(String[] args)
```

/cc @noahfalk @AndyAyersMS </Title_Description>
    <Label>tenet-performance</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19568</IssueLabelID>
    <Title>[Ubuntu 16.04] PR #19525 might have introduced a regression on the CQ benchmarks</Title>
    <Description>The range of changes that are captured for the run that started showing the regression are these: https://github.com/dotnet/coreclr/compare/a81d9103d23f714a0bd3efb900321b0b9f383311...dotnet:0fc981abe7b9ca6898f157bc247edad265d4088b

This is an example of a single regression of ~24%
![capture](https://user-images.githubusercontent.com/12551699/44367867-d7a01b80-a485-11e8-90ef-76fa39ade628.PNG)

/cc @AndyAyersMS @noahfalk @kouvel </Description>
    <Title_Description>[Ubuntu 16.04] PR #19525 might have introduced a regression on the CQ benchmarks The range of changes that are captured for the run that started showing the regression are these: https://github.com/dotnet/coreclr/compare/a81d9103d23f714a0bd3efb900321b0b9f383311...dotnet:0fc981abe7b9ca6898f157bc247edad265d4088b

This is an example of a single regression of ~24%
![capture](https://user-images.githubusercontent.com/12551699/44367867-d7a01b80-a485-11e8-90ef-76fa39ade628.PNG)

/cc @AndyAyersMS @noahfalk @kouvel </Title_Description>
    <Label>tenet-performance</Label>
    <Assignee>jorive</Assignee>
    <CreatedAt>20/08/2018 9:41:25 PM +00:00</CreatedAt>
    <ClosedAt>22/08/2018 5:30:43 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19567</IssueLabelID>
    <Title>Fix tiered compilation option for case-sensitive systems</Title>
    <Description>
    </Description>
    <Title_Description>Fix tiered compilation option for case-sensitive systems </Title_Description>
    <Label>area-TieredCompilation</Label>
    <Assignee>jorive</Assignee>
    <CreatedAt>20/08/2018 9:32:39 PM +00:00</CreatedAt>
    <ClosedAt>21/08/2018 1:38:31 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19566</IssueLabelID>
    <Title>Interop request: Support exported symbols</Title>
    <Description>_From @MV10 on August 19 2018 17:5_

Request: Define a new attribute which maps a managed variable to an exported symbol exactly as we get today using `[DllImport]` for functions. 

Right now I'm facing the need to read data (defined constants and live variables) from Windows Linux and OSX native libraries. At the moment I'm not sure how to accomplish the same thing in Linux and OSX (I've just started down this rabbit-hole) but it definitely feels like the type of "it just works" magic that .NET ought to handle for us because this gets ugly fast.

This is the Win32 way (although in my case I think I can skip `LoadLibrary` and `FreeLibrary` and just use `GetModuleHandle` since pinvoke will have already loaded it):

https://limbioliong.wordpress.com/2011/11/11/accessing-exported-data-from-a-dll-in-managed-code/

I suppose I'll have to target each OS with `#if` blocks based on Runtime Identifier build constants once I figure out how it works on the other platforms.

(On a related note I noticed in #24444 the OP asks about _data_ and interfaces but it seems the data portion of the question was overlooked.)

_Copied from original issue: dotnet/corefx#31836_</Description>
    <Title_Description>Interop request: Support exported symbols _From @MV10 on August 19 2018 17:5_

Request: Define a new attribute which maps a managed variable to an exported symbol exactly as we get today using `[DllImport]` for functions. 

Right now I'm facing the need to read data (defined constants and live variables) from Windows Linux and OSX native libraries. At the moment I'm not sure how to accomplish the same thing in Linux and OSX (I've just started down this rabbit-hole) but it definitely feels like the type of "it just works" magic that .NET ought to handle for us because this gets ugly fast.

This is the Win32 way (although in my case I think I can skip `LoadLibrary` and `FreeLibrary` and just use `GetModuleHandle` since pinvoke will have already loaded it):

https://limbioliong.wordpress.com/2011/11/11/accessing-exported-data-from-a-dll-in-managed-code/

I suppose I'll have to target each OS with `#if` blocks based on Runtime Identifier build constants once I figure out how it works on the other platforms.

(On a related note I noticed in #24444 the OP asks about _data_ and interfaces but it seems the data portion of the question was overlooked.)

_Copied from original issue: dotnet/corefx#31836_</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>20/08/2018 7:29:46 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19565</IssueLabelID>
    <Title>Add no-tiering CI jobs for testing with tiering enabled</Title>
    <Description>This ports the following PRs to 2.2:
- https://github.com/dotnet/coreclr/pull/18828
- https://github.com/dotnet/coreclr/pull/18864
- https://github.com/dotnet/coreclr/pull/18953
- https://github.com/dotnet/coreclr/pull/19123

See the individual commit descriptions for more info. It looks like the changes need to be merged before the CI jobs can be kicked off for testing them with tiering enabled.</Description>
    <Title_Description>Add no-tiering CI jobs for testing with tiering enabled This ports the following PRs to 2.2:
- https://github.com/dotnet/coreclr/pull/18828
- https://github.com/dotnet/coreclr/pull/18864
- https://github.com/dotnet/coreclr/pull/18953
- https://github.com/dotnet/coreclr/pull/19123

See the individual commit descriptions for more info. It looks like the changes need to be merged before the CI jobs can be kicked off for testing them with tiering enabled.</Title_Description>
    <Label>area-Meta</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19564</IssueLabelID>
    <Title>R2RDump with x86 disassembler architecture fails to disassemble R2R images</Title>
    <Description>On my x64 machine I generated a R2R image with crossgen then tried to disassemble with two different R2RDump builds. The x64 version of the tools will disassemble correctly but the x86 version of the tools will fail with an AV. This has been replaced with an exception for the time being but the behavior needs to be fixed

## x64 CoreDisTools disassembling an x64 R2R image
1. dotnet build --runtime win-x64
2. E:\git\dotnet\coreclr\bin\Product\Windows_NT.x64.Debug\netcoreapp2.0\win-x64\R2RDump.exe --in MultipleRuntimeFunctions.ni.dll --disasm

```
MultipleRuntimeFunctions.MultipleRuntimeFunctions.MethodWithMultipleRuntimeFunctions()
Id: 0
StartAddress: 0x00002800
Size: 36 bytes
UnwindRVA: 0x0000289C
    2800: 55                    push    rbp
    2801: 48 83 ec 10           sub     rsp 16
    2805: 48 8d 6c 24 10        lea     rbp [rsp + 16]
    280a: 48 89 65 f0           mov     qword ptr [rbp - 16] rsp
    280e: 90                    nop
    280f: 90                    nop
    2810: 90                    nop
    2811: 90                    nop
    2812: eb 00                 jmp     0
    2814: 48 8b cc              mov     rcx rsp
    2817: e8 08 00 00 00        call    8
    281c: 90                    nop
    281d: 90                    nop
    281e: 48 8d 65 00           lea     rsp [rbp]
    2822: 5d                    pop     rbp
    2823: c3                    ret
```

## x86 CoreDisTools disassembling an x86 R2R image
1. dotnet build --runtime win-x86
2. E:\git\dotnet\coreclr\bin\Product\Windows_NT.x64.Debug\netcoreapp2.0\win-x86\R2RDump.exe --in MultipleRuntimeFunctions.ni.dll --disasm

```
MultipleRuntimeFunctions.MultipleRuntimeFunctions.MethodWithMultipleRuntimeFunctions()
Id: 0
StartAddress: 0x00002800
Size: 36 bytes
UnwindRVA: 0x0000289C
[AV thrown here]
```

In the meantime this AV has been replaced with the following exception:
```
Error: System.ArgumentException: The architecture of input file MultipleRuntimeFunctions.ni.dll is Amd64 and does not match the architecture of the disassembler tools X86
```
</Description>
    <Title_Description>R2RDump with x86 disassembler architecture fails to disassemble R2R images On my x64 machine I generated a R2R image with crossgen then tried to disassemble with two different R2RDump builds. The x64 version of the tools will disassemble correctly but the x86 version of the tools will fail with an AV. This has been replaced with an exception for the time being but the behavior needs to be fixed

## x64 CoreDisTools disassembling an x64 R2R image
1. dotnet build --runtime win-x64
2. E:\git\dotnet\coreclr\bin\Product\Windows_NT.x64.Debug\netcoreapp2.0\win-x64\R2RDump.exe --in MultipleRuntimeFunctions.ni.dll --disasm

```
MultipleRuntimeFunctions.MultipleRuntimeFunctions.MethodWithMultipleRuntimeFunctions()
Id: 0
StartAddress: 0x00002800
Size: 36 bytes
UnwindRVA: 0x0000289C
    2800: 55                    push    rbp
    2801: 48 83 ec 10           sub     rsp 16
    2805: 48 8d 6c 24 10        lea     rbp [rsp + 16]
    280a: 48 89 65 f0           mov     qword ptr [rbp - 16] rsp
    280e: 90                    nop
    280f: 90                    nop
    2810: 90                    nop
    2811: 90                    nop
    2812: eb 00                 jmp     0
    2814: 48 8b cc              mov     rcx rsp
    2817: e8 08 00 00 00        call    8
    281c: 90                    nop
    281d: 90                    nop
    281e: 48 8d 65 00           lea     rsp [rbp]
    2822: 5d                    pop     rbp
    2823: c3                    ret
```

## x86 CoreDisTools disassembling an x86 R2R image
1. dotnet build --runtime win-x86
2. E:\git\dotnet\coreclr\bin\Product\Windows_NT.x64.Debug\netcoreapp2.0\win-x86\R2RDump.exe --in MultipleRuntimeFunctions.ni.dll --disasm

```
MultipleRuntimeFunctions.MultipleRuntimeFunctions.MethodWithMultipleRuntimeFunctions()
Id: 0
StartAddress: 0x00002800
Size: 36 bytes
UnwindRVA: 0x0000289C
[AV thrown here]
```

In the meantime this AV has been replaced with the following exception:
```
Error: System.ArgumentException: The architecture of input file MultipleRuntimeFunctions.ni.dll is Amd64 and does not match the architecture of the disassembler tools X86
```
</Title_Description>
    <Label>area-R2RDump</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>20/08/2018 4:51:40 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19560</IssueLabelID>
    <Title>Clean up register preservation requirements for Enter callback</Title>
    <Description>#19023 


I'm still testing this so adding NO_MERGE tag even if CI suggests it is good.

@BruceForstall - PTAL
cc @sergign60 </Description>
    <Title_Description>Clean up register preservation requirements for Enter callback #19023 


I'm still testing this so adding NO_MERGE tag even if CI suggests it is good.

@BruceForstall - PTAL
cc @sergign60 </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>echesakovMSFT</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19558</IssueLabelID>
    <Title>RyuJIT: Mishandling of subrange assertion for rewritten call parameter</Title>
    <Description>The example is:
```csharp
// Debug: Outputs -1
// Release: Outputs 1
struct S0
{
    public uint F1;
    public long F2;
    public ulong F3;
    public ushort F5;
    public bool F7;
    public S0(uint f1): this()
    {
        F1 = f1;
    }
}

public class Program
{
    static S0[] s_7 = new S0[]{new S0(0)};
    public static void Main()
    {
        M9(0);
    }

    static ushort M9(short arg1)
    {
        long var0 = 0;
        try
        {
            System.GC.KeepAlive(var0);
        }
        finally
        {
            var vr12 = new ulong[]{0 2271009908085114245UL};
            S0[] vr18 = new S0[]{new S0(32768)};
            uint vr19 = vr18[0].F1;
            arg1 = (short)vr19;
            arg1 %= -32767;
            System.GC.KeepAlive(s_7[0]);
            System.GC.KeepAlive(s_7[0]);
        }

        System.Console.WriteLine(arg1);
        return s_7[0].F5;
    }
}
```
(remember to set `COMPlus_TieredCompilation` to 0 in release) (edit: updated example).

@mikedn has analyzed it here: https://github.com/dotnet/coreclr/issues/18867#issuecomment-413246494</Description>
    <Title_Description>RyuJIT: Mishandling of subrange assertion for rewritten call parameter The example is:
```csharp
// Debug: Outputs -1
// Release: Outputs 1
struct S0
{
    public uint F1;
    public long F2;
    public ulong F3;
    public ushort F5;
    public bool F7;
    public S0(uint f1): this()
    {
        F1 = f1;
    }
}

public class Program
{
    static S0[] s_7 = new S0[]{new S0(0)};
    public static void Main()
    {
        M9(0);
    }

    static ushort M9(short arg1)
    {
        long var0 = 0;
        try
        {
            System.GC.KeepAlive(var0);
        }
        finally
        {
            var vr12 = new ulong[]{0 2271009908085114245UL};
            S0[] vr18 = new S0[]{new S0(32768)};
            uint vr19 = vr18[0].F1;
            arg1 = (short)vr19;
            arg1 %= -32767;
            System.GC.KeepAlive(s_7[0]);
            System.GC.KeepAlive(s_7[0]);
        }

        System.Console.WriteLine(arg1);
        return s_7[0].F5;
    }
}
```
(remember to set `COMPlus_TieredCompilation` to 0 in release) (edit: updated example).

@mikedn has analyzed it here: https://github.com/dotnet/coreclr/issues/18867#issuecomment-413246494</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>mikedn</Assignee>
    <CreatedAt>19/08/2018 9:13:13 PM +00:00</CreatedAt>
    <ClosedAt>5/12/2018 10:26:56 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19555</IssueLabelID>
    <Title>lzcnt tzcnt popcnt false dependency not handled in CoreCLR</Title>
    <Description>Hi
Following my successful foray into the brave world of CoreCLR architecture specific intrinsics I think I stumbled upon a relatively known bug/deficiency in most intel CPUs (I have no knowledge on how this affects AMD CPUs if at all) that is now affecting perf on CoreCLR.

It appears that when I write a tight / unrolled loop with any of the intrinsics mentioned in the issue name:
* `lzcnt` (`LeadingZeroCount()`)
* `tzcnt` (`TrailingZeroCount()`)
* last but certainly not least popcnt (`popcnt` (`PopCount()`)

CoreCLR generates seemingly very good code when inspecting the JIT output however that code hits a rather known Intel false dependency bug that has been covered quite extensively:
*  [GCC mailing list](https://gcc.gnu.org/bugzilla/show_bug.cgi?id=62011)
* [This disturbingly detailed explanation and insight into the underlying implementation](https://stackoverflow.com/questions/21390165/why-does-breaking-the-output-dependency-of-lzcnt-matter)
* [Dan Luu's post about popcnt](https://danluu.com/assembly-intrinsics/) (Near the end of the post)

The gist of the matter is that most in-production Intel CPUs from Sandy-Bridge and onward up to and including Skylake (for `popcnt`) and not-including Skylake (for `lzcnt` `tzcnt`) introduce a dependency on the DESTINATION register for those instructions.

So a loop written in c# as:
```csharp
for (var i = 0; i &lt; n; i+=4 bits += 4)
    index += PopCount(bits[0]) + PopCount(bits[1]) + PopCount(bits[2]) + PopCount(bits[3]);}
```
Get's compiled/jitted down to (copy-pasted from CoreCLR JITDump):
```asm
G_M2736_IG05:        ; func=00 offs=000069H size=0030H gcrefRegs=00000000 {} byrefRegs=00000000 {} byref isz
IN001e: 000069 F34C0FB816           popcnt   r10 qword ptr [rsi]
IN001f: 00006E 4903D2               add      rdx r10
IN0020: 000071 F34C0FB85608         popcnt   r10 qword ptr [rsi+8]
IN0021: 000077 4903D2               add      rdx r10
IN0022: 00007A F34C0FB85610         popcnt   r10 qword ptr [rsi+16]
IN0023: 000080 4903D2               add      rdx r10
IN0024: 000083 F34C0FB85618         popcnt   r10 qword ptr [rsi+24]
IN0025: 000089 4903D2               add      rdx r10
IN0026: 00008C 4183C104             add      r9d 4
IN0027: 000090 4883C620             add      rsi 32
IN0028: 000094 453BC8               cmp      r9d r8d
IN0029: 000097 7CD0                 jl       SHORT G_M2736_IG05
```

As you can easily read/see each `popcnt` instruction in this unrolled loop (and also between loop iterations) is writing its output into `r10` thus according to the described errata/cpu bug is causing the next `popcnt` to stall before it can proceed with actual execution.

Given that the CPU can in theory execute two such `popcnt` instruction in parallel this false dependency seems to have been messing around with various people's code perf for a long time.

I think I even found an inadvertent "complaint" about this inside this [CoreCLR issue](https://github.com/dotnet/coreclr/issues/15506#issuecomment-353674452) where @Tornhoof and @fiigii  are trying to make a popcnt loop / unrolled loop perform faster but aren't achieving substantial speedup.

It seems like modern compilers such as GCC can and do alleviate the impact of this issue by [clearing the bottom 32 bits of each destination preemptively before emitting the `popcnt`instruction](https://godbolt.org/z/pSr6iu) copy pasted to here for completeness...:

```asm
.L3:
        xor     edx edx
        xor     ecx ecx
        popcnt  rcx QWORD PTR [rdi]
        popcnt  rdx QWORD PTR [rdi+8]
        add     rdx rcx
        xor     ecx ecx
        popcnt  rcx QWORD PTR [rdi+16]
        add     rdx rcx
        xor     ecx ecx
        popcnt  rcx QWORD PTR [rdi+24]
        add     rdi 32
        add     rdx rcx
        add     eax edx
        cmp     rdi rsi
        jne     .L3
```

Would this be something that CoreCLR JIT could dynamically detect (according to CPU model/family) and insert into the instruction stream?
</Description>
    <Title_Description>lzcnt, tzcnt, popcnt false dependency not handled in CoreCLR Hi
Following my successful foray into the brave world of CoreCLR architecture specific intrinsics I think I stumbled upon a relatively known bug/deficiency in most intel CPUs (I have no knowledge on how this affects AMD CPUs if at all) that is now affecting perf on CoreCLR.

It appears that when I write a tight / unrolled loop with any of the intrinsics mentioned in the issue name:
* `lzcnt` (`LeadingZeroCount()`)
* `tzcnt` (`TrailingZeroCount()`)
* last but certainly not least popcnt (`popcnt` (`PopCount()`)

CoreCLR generates seemingly very good code when inspecting the JIT output however that code hits a rather known Intel false dependency bug that has been covered quite extensively:
*  [GCC mailing list](https://gcc.gnu.org/bugzilla/show_bug.cgi?id=62011)
* [This disturbingly detailed explanation and insight into the underlying implementation](https://stackoverflow.com/questions/21390165/why-does-breaking-the-output-dependency-of-lzcnt-matter)
* [Dan Luu's post about popcnt](https://danluu.com/assembly-intrinsics/) (Near the end of the post)

The gist of the matter is that most in-production Intel CPUs from Sandy-Bridge and onward up to and including Skylake (for `popcnt`) and not-including Skylake (for `lzcnt` `tzcnt`) introduce a dependency on the DESTINATION register for those instructions.

So a loop written in c# as:
```csharp
for (var i = 0; i &lt; n; i+=4 bits += 4)
    index += PopCount(bits[0]) + PopCount(bits[1]) + PopCount(bits[2]) + PopCount(bits[3]);}
```
Get's compiled/jitted down to (copy-pasted from CoreCLR JITDump):
```asm
G_M2736_IG05:        ; func=00 offs=000069H size=0030H gcrefRegs=00000000 {} byrefRegs=00000000 {} byref isz
IN001e: 000069 F34C0FB816           popcnt   r10 qword ptr [rsi]
IN001f: 00006E 4903D2               add      rdx r10
IN0020: 000071 F34C0FB85608         popcnt   r10 qword ptr [rsi+8]
IN0021: 000077 4903D2               add      rdx r10
IN0022: 00007A F34C0FB85610         popcnt   r10 qword ptr [rsi+16]
IN0023: 000080 4903D2               add      rdx r10
IN0024: 000083 F34C0FB85618         popcnt   r10 qword ptr [rsi+24]
IN0025: 000089 4903D2               add      rdx r10
IN0026: 00008C 4183C104             add      r9d 4
IN0027: 000090 4883C620             add      rsi 32
IN0028: 000094 453BC8               cmp      r9d r8d
IN0029: 000097 7CD0                 jl       SHORT G_M2736_IG05
```

As you can easily read/see each `popcnt` instruction in this unrolled loop (and also between loop iterations) is writing its output into `r10` thus according to the described errata/cpu bug is causing the next `popcnt` to stall before it can proceed with actual execution.

Given that the CPU can in theory execute two such `popcnt` instruction in parallel this false dependency seems to have been messing around with various people's code perf for a long time.

I think I even found an inadvertent "complaint" about this inside this [CoreCLR issue](https://github.com/dotnet/coreclr/issues/15506#issuecomment-353674452) where @Tornhoof and @fiigii  are trying to make a popcnt loop / unrolled loop perform faster but aren't achieving substantial speedup.

It seems like modern compilers such as GCC can and do alleviate the impact of this issue by [clearing the bottom 32 bits of each destination preemptively before emitting the `popcnt`instruction](https://godbolt.org/z/pSr6iu) copy pasted to here for completeness...:

```asm
.L3:
        xor     edx edx
        xor     ecx ecx
        popcnt  rcx QWORD PTR [rdi]
        popcnt  rdx QWORD PTR [rdi+8]
        add     rdx rcx
        xor     ecx ecx
        popcnt  rcx QWORD PTR [rdi+16]
        add     rdx rcx
        xor     ecx ecx
        popcnt  rcx QWORD PTR [rdi+24]
        add     rdi 32
        add     rdx rcx
        add     eax edx
        cmp     rdi rsi
        jne     .L3
```

Would this be something that CoreCLR JIT could dynamically detect (according to CPU model/family) and insert into the instruction stream?
</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>fiigii</Assignee>
    <CreatedAt>19/08/2018 7:02:59 AM +00:00</CreatedAt>
    <ClosedAt>31/08/2018 5:21:37 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19553</IssueLabelID>
    <Title>Fix dbgshim's &gt; 1000 module bug (issue #19538)</Title>
    <Description>
    </Description>
    <Title_Description>Fix dbgshim's &gt; 1000 module bug (issue #19538) </Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>mikem8361</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19550</IssueLabelID>
    <Title>Codegen for Hardware Intrinsics arithmetic operations memory operands is poor</Title>
    <Description>Majority of hardware intrinsics arithmetic operations support using memory address as one of it's operands. It allows to write more efficient code which would bypass memory bottlenecks. Unfortunately jit does not fold memory loads into one of arithmetic operation operands and generates code for separate loads or stores.

The following example illustrates the problem (expression was specifically written to hint jit that second subtraction operand should not be loaded but folded into memory operand):

```C#
StoreScalar(rf + 2 Subtract(iVec LoadAlignedVector128(((double*)(items + j)) + 2))); 
```
```asm
;StoreScalar(rf + 2 Subtract(iVec LoadAlignedVector128(((double*)(items + j)) + 2)));                  
00007ffd`19ab4180 4983c310        add     r11 10h  
00007ffd`19ab4184 c4c1792813      vmovapd xmm2 xmmword ptr [r11]   
00007ffd`19ab4189 c4e1715cd2      vsubpd  xmm2 xmm1 xmm2  
00007ffd`19ab418e 4983c210        add     r1010h   
00007ffd`19ab4192 c4c17b1112      vmovsd  qword ptr [r10] xmm2
```
This code has two problems: (i) inefficient memory address calculation (ii) memory operands not folded into one of `vsubpd` operands. There are some possible optimizations.

1. Fold last `vsubpd` operand into memory address.
```asm
;StoreScalar(rf + 2 Subtract(iVec LoadAlignedVector128(((double*)(items + j)) + 2)));
00007ffd`19ab4180 4983c310        add     r11 10h    
00007ffd`19ab4189 c4e1715cd2      vsubpd  xmm2 xmm1 xmmword ptr [r11]  
00007ffd`19ab418e 4983c210        add     r1010h   
00007ffd`19ab4192 c4c17b1112      vmovsd  qword ptr [r10] xmm2
```
2. Improve addressing of operands - this particular problem is tracked by #19521

```asm
;StoreScalar(rf + 2 Subtract(iVec LoadAlignedVector128(((double*)(items + j)) + 2)));                    
00007ffd`19ab4189 c4e1715cd2      vsubpd  xmm2 xmm1 xmmword ptr [r11 + 10h]  
00007ffd`19ab4192 c4c17b1112      vmovsd  qword ptr [r10 + 10h] xmm2
``` 
By applying these optimizations the above code should be roughly 2.5 x faster.

There are several solutions to the memory operand handling. 

The simplest one is to give control to developers and provide overloads which would allow to pass memory pointers besides `Vector128&lt;T&gt;` or `Vector256&lt;T&gt;`. 

```C#
Vector128&lt;double&gt; Sse2.Add(Vector128&lt;double&gt; left Vector128&lt;double&gt; right);
Vector128&lt;double&gt; Sse2.Add(Vector128&lt;double&gt; left double* right);

Vector128&lt;double&gt; Sse2.Divide(Vector128&lt;double&gt; left Vector128&lt;double&gt; right);
Vector128&lt;double&gt; Sse2.Divide(Vector128&lt;double&gt; left double* right);

Vector128&lt;double&gt; Sse2.Multiply(Vector128&lt;double&gt; left Vector128&lt;double&gt; right);
Vector128&lt;double&gt; Sse2.Multiply(Vector128&lt;double&gt; left double* right);

Vector128&lt;double&gt; Sse2.Subtract(Vector128&lt;double&gt; left Vector128&lt;double&gt; right);
Vector128&lt;double&gt; Sse2.Subtract(Vector128&lt;double&gt; left double* right);
```
For `Vector128&lt;T&gt;` marked as blittable type it should be possible to have even better self documenting overloads (providing C# would support pointers to generic blittable types).

```C#
Vector128&lt;double&gt; Sse2.Add(Vector128&lt;double&gt; left Vector128&lt;double&gt; right);
Vector128&lt;double&gt; Sse2.Add(Vector128&lt;double&gt; left Vector128&lt;double&gt;* right);
```
More complex and very inefficient form developer perspective is to provide jit support for folding loads and `Unsafe.Read&lt;T&gt;` reads into memory operands. Unfortunately the burden to write more code would make use of intrinsics even more harder and some developers would not even know how to use that support without digging into docs. 

IMHO the best solution would be to expand API surface as this would be self documenting enhancement. Furthermore from my experience managing data flow through memory avoiding memory wall while using HW intrinsics is one of the most difficult parts of the coding with them.

cc @AndyAyersMS  @CarolEidt @eerhardt @fiigii @tannergooding </Description>
    <Title_Description>Codegen for Hardware Intrinsics arithmetic operations memory operands is poor Majority of hardware intrinsics arithmetic operations support using memory address as one of it's operands. It allows to write more efficient code which would bypass memory bottlenecks. Unfortunately jit does not fold memory loads into one of arithmetic operation operands and generates code for separate loads or stores.

The following example illustrates the problem (expression was specifically written to hint jit that second subtraction operand should not be loaded but folded into memory operand):

```C#
StoreScalar(rf + 2 Subtract(iVec LoadAlignedVector128(((double*)(items + j)) + 2))); 
```
```asm
;StoreScalar(rf + 2 Subtract(iVec LoadAlignedVector128(((double*)(items + j)) + 2)));                  
00007ffd`19ab4180 4983c310        add     r11 10h  
00007ffd`19ab4184 c4c1792813      vmovapd xmm2 xmmword ptr [r11]   
00007ffd`19ab4189 c4e1715cd2      vsubpd  xmm2 xmm1 xmm2  
00007ffd`19ab418e 4983c210        add     r1010h   
00007ffd`19ab4192 c4c17b1112      vmovsd  qword ptr [r10] xmm2
```
This code has two problems: (i) inefficient memory address calculation (ii) memory operands not folded into one of `vsubpd` operands. There are some possible optimizations.

1. Fold last `vsubpd` operand into memory address.
```asm
;StoreScalar(rf + 2 Subtract(iVec LoadAlignedVector128(((double*)(items + j)) + 2)));
00007ffd`19ab4180 4983c310        add     r11 10h    
00007ffd`19ab4189 c4e1715cd2      vsubpd  xmm2 xmm1 xmmword ptr [r11]  
00007ffd`19ab418e 4983c210        add     r1010h   
00007ffd`19ab4192 c4c17b1112      vmovsd  qword ptr [r10] xmm2
```
2. Improve addressing of operands - this particular problem is tracked by #19521

```asm
;StoreScalar(rf + 2 Subtract(iVec LoadAlignedVector128(((double*)(items + j)) + 2)));                    
00007ffd`19ab4189 c4e1715cd2      vsubpd  xmm2 xmm1 xmmword ptr [r11 + 10h]  
00007ffd`19ab4192 c4c17b1112      vmovsd  qword ptr [r10 + 10h] xmm2
``` 
By applying these optimizations the above code should be roughly 2.5 x faster.

There are several solutions to the memory operand handling. 

The simplest one is to give control to developers and provide overloads which would allow to pass memory pointers besides `Vector128&lt;T&gt;` or `Vector256&lt;T&gt;`. 

```C#
Vector128&lt;double&gt; Sse2.Add(Vector128&lt;double&gt; left Vector128&lt;double&gt; right);
Vector128&lt;double&gt; Sse2.Add(Vector128&lt;double&gt; left double* right);

Vector128&lt;double&gt; Sse2.Divide(Vector128&lt;double&gt; left Vector128&lt;double&gt; right);
Vector128&lt;double&gt; Sse2.Divide(Vector128&lt;double&gt; left double* right);

Vector128&lt;double&gt; Sse2.Multiply(Vector128&lt;double&gt; left Vector128&lt;double&gt; right);
Vector128&lt;double&gt; Sse2.Multiply(Vector128&lt;double&gt; left double* right);

Vector128&lt;double&gt; Sse2.Subtract(Vector128&lt;double&gt; left Vector128&lt;double&gt; right);
Vector128&lt;double&gt; Sse2.Subtract(Vector128&lt;double&gt; left double* right);
```
For `Vector128&lt;T&gt;` marked as blittable type it should be possible to have even better self documenting overloads (providing C# would support pointers to generic blittable types).

```C#
Vector128&lt;double&gt; Sse2.Add(Vector128&lt;double&gt; left Vector128&lt;double&gt; right);
Vector128&lt;double&gt; Sse2.Add(Vector128&lt;double&gt; left Vector128&lt;double&gt;* right);
```
More complex and very inefficient form developer perspective is to provide jit support for folding loads and `Unsafe.Read&lt;T&gt;` reads into memory operands. Unfortunately the burden to write more code would make use of intrinsics even more harder and some developers would not even know how to use that support without digging into docs. 

IMHO the best solution would be to expand API surface as this would be self documenting enhancement. Furthermore from my experience managing data flow through memory avoiding memory wall while using HW intrinsics is one of the most difficult parts of the coding with them.

cc @AndyAyersMS  @CarolEidt @eerhardt @fiigii @tannergooding </Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19549</IssueLabelID>
    <Title>Set BUILDTOOLS_SOURCE to local buildtools package dir results in build error</Title>
    <Description>It seems building coreclr with using locally built buildtools packages fail. I spent couple of hours trying to find the cause I thought it was related with changes I made in buildtools but that also happens when building buildtools from master. I wonder that nobody else hit this therefore I'm not entirely sure if I'm the only one hitting this?

Repro:

```
cd buildtools
.\build.cmd
cd ../coreclr
set BUILDTOOLS_SOURCE=C:\git\buildtools\bin\packages
.\build.cmd
```

Error:

```
             0x11802e8 // vtable AppDomainLoaderAllocator
             0x1129f08 // vtable AssemblyLoaderAllocator
         The system cannot find the path specified.
    60&gt;C:\Program Files (x86)\Microsoft Visual Studio\Preview\Enterprise\Common7\IDE\VC\VCTargets\Microsoft.CppCommon.targets(2095): error MSB6006: "cmd.exe" exited with code 3. [C:\git\coreclr2\bin\obj\Windows_NT.x64.Debug\src\dlls\mscoree\coreclr\inject_debug_resources.vcxproj]
    60&gt;Done Building Project "C:\git\coreclr2\bin\obj\Windows_NT.x64.Debug\src\dlls\mscoree\coreclr\inject_debug_resources.vcxproj" (default targets) -- FAILED.
     3&gt;Done Building Project "C:\git\coreclr2\bin\obj\Windows_NT.x64.Debug\ALL_BUILD.vcxproj" (default targets) -- FAILED.
     1&gt;Done Building Project "C:\git\coreclr2\bin\obj\Windows_NT.x64.Debug\install.vcxproj" (default targets) -- FAILED.
```</Description>
    <Title_Description>Set BUILDTOOLS_SOURCE to local buildtools package dir results in build error It seems building coreclr with using locally built buildtools packages fail. I spent couple of hours trying to find the cause I thought it was related with changes I made in buildtools but that also happens when building buildtools from master. I wonder that nobody else hit this therefore I'm not entirely sure if I'm the only one hitting this?

Repro:

```
cd buildtools
.\build.cmd
cd ../coreclr
set BUILDTOOLS_SOURCE=C:\git\buildtools\bin\packages
.\build.cmd
```

Error:

```
             0x11802e8 // vtable AppDomainLoaderAllocator
             0x1129f08 // vtable AssemblyLoaderAllocator
         The system cannot find the path specified.
    60&gt;C:\Program Files (x86)\Microsoft Visual Studio\Preview\Enterprise\Common7\IDE\VC\VCTargets\Microsoft.CppCommon.targets(2095): error MSB6006: "cmd.exe" exited with code 3. [C:\git\coreclr2\bin\obj\Windows_NT.x64.Debug\src\dlls\mscoree\coreclr\inject_debug_resources.vcxproj]
    60&gt;Done Building Project "C:\git\coreclr2\bin\obj\Windows_NT.x64.Debug\src\dlls\mscoree\coreclr\inject_debug_resources.vcxproj" (default targets) -- FAILED.
     3&gt;Done Building Project "C:\git\coreclr2\bin\obj\Windows_NT.x64.Debug\ALL_BUILD.vcxproj" (default targets) -- FAILED.
     1&gt;Done Building Project "C:\git\coreclr2\bin\obj\Windows_NT.x64.Debug\install.vcxproj" (default targets) -- FAILED.
```</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>ViktorHofer</Assignee>
    <CreatedAt>18/08/2018 12:17:36 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19548</IssueLabelID>
    <Title>Fix issues with calling convention in tests.</Title>
    <Description>Fixes #19540 

cc @BruceForstall </Description>
    <Title_Description>Fix issues with calling convention in tests. Fixes #19540 

cc @BruceForstall </Title_Description>
    <Label>test bug</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>18/08/2018 7:20:54 AM +00:00</CreatedAt>
    <ClosedAt>20/08/2018 7:00:56 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19545</IssueLabelID>
    <Title>[WIP] Use target_ssize_t for Lowering::CastInfo::typeMin typeMax typeMask</Title>
    <Description>
    </Description>
    <Title_Description>[WIP] Use target_ssize_t for Lowering::CastInfo::typeMin typeMax typeMask </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>echesakovMSFT</Assignee>
    <CreatedAt>18/08/2018 1:22:55 AM +00:00</CreatedAt>
    <ClosedAt>7/09/2018 4:16:44 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19544</IssueLabelID>
    <Title>Use target_ssize_t imm in CodeGen CodeGenInterface</Title>
    <Description>In order to get rid off compilation warnings in cross-bitness compilation scenario `CodeGen` and `CodeGenInterface` should stop using `size_t` for immediate value argument.</Description>
    <Title_Description>Use target_ssize_t imm in CodeGen CodeGenInterface In order to get rid off compilation warnings in cross-bitness compilation scenario `CodeGen` and `CodeGenInterface` should stop using `size_t` for immediate value argument.</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>echesakovMSFT</Assignee>
    <CreatedAt>18/08/2018 1:15:41 AM +00:00</CreatedAt>
    <ClosedAt>21/08/2018 3:19:09 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19542</IssueLabelID>
    <Title>Enable mixed mode assembly loading</Title>
    <Description>Selectively brings back the deleted code to support mixed mode assembly loading a managed-&gt;native calls. Code for native-&gt;managed and activation will be in future changes. Also includes a simple test case.

Contributes to https://github.com/dotnet/coreclr/issues/18013</Description>
    <Title_Description>Enable mixed mode assembly loading Selectively brings back the deleted code to support mixed mode assembly loading a managed-&gt;native calls. Code for native-&gt;managed and activation will be in future changes. Also includes a simple test case.

Contributes to https://github.com/dotnet/coreclr/issues/18013</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>morganbr</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19540</IssueLabelID>
    <Title>Windows x86 tests failing due to missing native dll entrypoints</Title>
    <Description>Windows test runs are failing due to native components having missing entrypoints. There are 4 test failures. E.g.

https://ci.dot.net/job/dotnet_coreclr/job/master/view/x86/job/x86_checked_windows_nt/5151/

```
12:31:43 
      Interop_RefCharArray._RefCharArrayTest_RefCharArrayTest_._RefCharArrayTest_RefCharArrayTest_cmd [FAIL]
12:31:43         
12:31:43   Unhandled Exception: System.EntryPointNotFoundException: Unable to find an entry point named 'DoCallBack_MarshalRefCharArray_Cdecl' in DLL 'RefCharArrayNative'.
12:31:43            at Test.DoCallBack_MarshalRefCharArray_Cdecl(CdeclCallBack caller)
12:31:43            at Test.Main() in D:\j\workspace\x86_checked_w---7d119cc3\tests\src\Interop\RefCharArray\RefCharArrayTest.cs:line 262
12:31:43   
12:31:43   
12:31:43   Return code:      1
12:31:43   Raw output file:      D:\j\workspace\x86_checked_w---7d119cc3\bin\tests\Windows_NT.x86.Checked\Reports\Interop.RefCharArray\RefCharArrayTest\RefCharArrayTest.output.txt
12:31:43   Raw output:
12:31:43   BEGIN EXECUTION
12:31:43          "D:\j\workspace\x86_checked_w---7d119cc3\tests\..\bin\tests\Windows_NT.x86.Checked\Tests\Core_Root\corerun.exe" RefCharArrayTest.exe 
12:31:43         Beginning scenario: PinvokeCdecl
12:31:43         Beginning scenario: PinvokeStdCall
12:31:43         Expected: 100
12:31:43         Actual: -532462766
12:31:43         END EXECUTION - FAILED
12:31:43         FAILED
12:31:43         Test Harness Exitcode is : 1
12:31:43         
12:31:43   To run the test:
12:31:43   &gt; set CORE_ROOT=D:\j\workspace\x86_checked_w---7d119cc3\bin\tests\Windows_NT.x86.Checked\Tests\Core_Root
12:31:43   &gt; D:\j\workspace\x86_checked_w---7d119cc3\bin\tests\Windows_NT.x86.Checked\Interop\RefCharArray\RefCharArrayTest\RefCharArrayTest.cmd
12:31:43   
12:31:43         Expected: True
12:31:43         Actual:   False
12:31:43         Stack Trace:
12:31:43           D:\j\workspace\x86_checked_w---7d119cc3\bin\tests\Windows_NT.x86.Checked\TestWrappers\Interop.RefCharArray\Interop.RefCharArray.XUnitWrapper.cs(1090): at Interop_RefCharArray._RefCharArrayTest_RefCharArrayTest_._RefCharArrayTest_RefCharArrayTest_cmd()
```

This appears to be due to the build changes in https://github.com/dotnet/coreclr/pull/19430.

</Description>
    <Title_Description>Windows x86 tests failing due to missing native dll entrypoints Windows test runs are failing due to native components having missing entrypoints. There are 4 test failures. E.g.

https://ci.dot.net/job/dotnet_coreclr/job/master/view/x86/job/x86_checked_windows_nt/5151/

```
12:31:43 
      Interop_RefCharArray._RefCharArrayTest_RefCharArrayTest_._RefCharArrayTest_RefCharArrayTest_cmd [FAIL]
12:31:43         
12:31:43   Unhandled Exception: System.EntryPointNotFoundException: Unable to find an entry point named 'DoCallBack_MarshalRefCharArray_Cdecl' in DLL 'RefCharArrayNative'.
12:31:43            at Test.DoCallBack_MarshalRefCharArray_Cdecl(CdeclCallBack caller)
12:31:43            at Test.Main() in D:\j\workspace\x86_checked_w---7d119cc3\tests\src\Interop\RefCharArray\RefCharArrayTest.cs:line 262
12:31:43   
12:31:43   
12:31:43   Return code:      1
12:31:43   Raw output file:      D:\j\workspace\x86_checked_w---7d119cc3\bin\tests\Windows_NT.x86.Checked\Reports\Interop.RefCharArray\RefCharArrayTest\RefCharArrayTest.output.txt
12:31:43   Raw output:
12:31:43   BEGIN EXECUTION
12:31:43          "D:\j\workspace\x86_checked_w---7d119cc3\tests\..\bin\tests\Windows_NT.x86.Checked\Tests\Core_Root\corerun.exe" RefCharArrayTest.exe 
12:31:43         Beginning scenario: PinvokeCdecl
12:31:43         Beginning scenario: PinvokeStdCall
12:31:43         Expected: 100
12:31:43         Actual: -532462766
12:31:43         END EXECUTION - FAILED
12:31:43         FAILED
12:31:43         Test Harness Exitcode is : 1
12:31:43         
12:31:43   To run the test:
12:31:43   &gt; set CORE_ROOT=D:\j\workspace\x86_checked_w---7d119cc3\bin\tests\Windows_NT.x86.Checked\Tests\Core_Root
12:31:43   &gt; D:\j\workspace\x86_checked_w---7d119cc3\bin\tests\Windows_NT.x86.Checked\Interop\RefCharArray\RefCharArrayTest\RefCharArrayTest.cmd
12:31:43   
12:31:43         Expected: True
12:31:43         Actual:   False
12:31:43         Stack Trace:
12:31:43           D:\j\workspace\x86_checked_w---7d119cc3\bin\tests\Windows_NT.x86.Checked\TestWrappers\Interop.RefCharArray\Interop.RefCharArray.XUnitWrapper.cs(1090): at Interop_RefCharArray._RefCharArrayTest_RefCharArrayTest_._RefCharArrayTest_RefCharArrayTest_cmd()
```

This appears to be due to the build changes in https://github.com/dotnet/coreclr/pull/19430.

</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19539</IssueLabelID>
    <Title> Free the alternate signal stack if this PAL's thread allocated it.</Title>
    <Description>Pass the CPalThread instance through to EnsureSignalAlternateStack and save the altstack pointer allocated.   And in FreeSignalAlternateStack use this pointer to ensure that only the proper PAL frees the stack.</Description>
    <Title_Description> Free the alternate signal stack if this PAL's thread allocated it. Pass the CPalThread instance through to EnsureSignalAlternateStack and save the altstack pointer allocated.   And in FreeSignalAlternateStack use this pointer to ensure that only the proper PAL frees the stack.</Title_Description>
    <Label>
    </Label>
    <Assignee>mikem8361</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19538</IssueLabelID>
    <Title>dbgshim.dll!EnumerateCLRs may crash with &gt;1000 modules</Title>
    <Description>[EnumerateCLRs](https://github.com/dotnet/coreclr/blob/0f0320e58fd006a02cdecf7ae45426f54da333e5/src/dlls/dbgshim/dbgshim.cpp#L1095) may crash when inspecting a process with &gt;1000 modules. The issue is that the behavior of [EnumProcessModules](https://docs.microsoft.com/en-us/windows/desktop/api/psapi/nf-psapi-enumprocessmodules#remarks) in the case that more modules are loaded than there is space in the provided buffer is to return TRUE and set cbNeeded to the size to allocate. But this code assumes that cbNeeded will always be &lt;= the size of `modules`.

Here is the relevant code:

```C++
    // These shouldn't be freed
    HMODULE modules[1000];
    DWORD cbNeeded;
    if(!EnumProcessModules(hProcess modules sizeof(modules) &amp;cbNeeded))
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    //
    // count the number of coreclr.dll entries
    //
    DWORD count = 0;
    DWORD countModules = cbNeeded/sizeof(HMODULE);
    for(DWORD i = 0; i &lt; countModules; i++)
    {
```</Description>
    <Title_Description>dbgshim.dll!EnumerateCLRs may crash with &gt;1000 modules [EnumerateCLRs](https://github.com/dotnet/coreclr/blob/0f0320e58fd006a02cdecf7ae45426f54da333e5/src/dlls/dbgshim/dbgshim.cpp#L1095) may crash when inspecting a process with &gt;1000 modules. The issue is that the behavior of [EnumProcessModules](https://docs.microsoft.com/en-us/windows/desktop/api/psapi/nf-psapi-enumprocessmodules#remarks) in the case that more modules are loaded than there is space in the provided buffer is to return TRUE and set cbNeeded to the size to allocate. But this code assumes that cbNeeded will always be &lt;= the size of `modules`.

Here is the relevant code:

```C++
    // These shouldn't be freed
    HMODULE modules[1000];
    DWORD cbNeeded;
    if(!EnumProcessModules(hProcess modules sizeof(modules) &amp;cbNeeded))
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    //
    // count the number of coreclr.dll entries
    //
    DWORD count = 0;
    DWORD countModules = cbNeeded/sizeof(HMODULE);
    for(DWORD i = 0; i &lt; countModules; i++)
    {
```</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>mikem8361</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19537</IssueLabelID>
    <Title>[Ubuntu/arm32] Assertion failed '(regSet.rsMaskResvd &amp; RBM_OPT_RSVD) != 0'</Title>
    <Description>In corefx testing System.Numerics.Vectors.Tests:

```
Running tests in /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs3_tst/_/fx/bin/tests/System.Numerics.Vectors.Tests/netcoreapp-Linux-Release-arm
timeout --kill-after=30s 20m ./RunTests.sh /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs3_tst/_/fx/bin/testhost/netcoreapp-Linux-Release-arm

----- start 19:59:38 =============== To repro directly: =====================================================
pushd .
#!/usr/bin/env bash export COMPlus_TieredCompilation=0 export COMPlus_JitStressRegs=3
chmod +x /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs3_tst/_/fx/bin/testhost/netcoreapp-Linux-Release-arm/dotnet
/ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs3_tst/_/fx/bin/testhost/netcoreapp-Linux-Release-arm/dotnet xunit.console.netcore.exe System.Numerics.Vectors.Tests.dll  -xml testResults.xml -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonlinuxtests  -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing
popd
===========================================================================================================
/ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs3_tst/_/fx/bin/tests/System.Numerics.Vectors.Tests/netcoreapp-Linux-Release-arm /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs3_tst/_/fx/bin/tests/System.Numerics.Vectors.Tests/netcoreapp-Linux-Release-arm
xUnit.net console test runner (32-bit .NET Core)
Copyright (C) 2014 Outercurve Foundation.

Discovering: System.Numerics.Vectors.Tests
Discovered:  System.Numerics.Vectors.Tests
Starting:    System.Numerics.Vectors.Tests

Assert failure(PID 7386 [0x00001cda] Thread: 7399 [0x1ce7]): Assertion failed '(regSet.rsMaskResvd &amp; RBM_OPT_RSVD) != 0' in 'System.Numerics.Matrix4x4:op_Multiply(structstruct):struct' (IL size 1626)

    File: /mnt/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs3/src/jit/codegen.h Line: 140
    Image: /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs3_tst/_/fx/bin/testhost/netcoreapp-Linux-Release-arm/dotnet


Assert failure(PID 7386 [0x00001cda] Thread: 7399 [0x1ce7]): Assertion failed '(regSet.rsMaskResvd &amp; RBM_OPT_RSVD) != 0' in 'System.Numerics.Matrix4x4:op_Multiply(structstruct):struct' (IL size 1626)

    File: /mnt/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs3/src/jit/codegen.h Line: 140
    Image: /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs3_tst/_/fx/bin/testhost/netcoreapp-Linux-Release-arm/dotnet

./RunTests.sh: line 128:  7386 Aborted                 $RUNTIME_PATH/dotnet xunit.console.netcore.exe System.Numerics.Vectors.Tests.dll -xml testResults.xml -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonlinuxtests -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing
/ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs3_tst/_/fx/bin/tests/System.Numerics.Vectors.Tests/netcoreapp-Linux-Release-arm
----- end 19:59:56 ----- exit code 134 ----------------------------------------------------------
```

Happens for various JitStressRegs stress modes (list may not be exhaustive):

https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstressregs3_tst/20/
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstressregs4_flow/20/
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_tieredcompilation_flow/8/
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstressregs1_flow/21/
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_flow/22/

This is a recent regression.

@dotnet/arm32-contrib @CarolEidt </Description>
    <Title_Description>[Ubuntu/arm32] Assertion failed '(regSet.rsMaskResvd &amp; RBM_OPT_RSVD) != 0' In corefx testing System.Numerics.Vectors.Tests:

```
Running tests in /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs3_tst/_/fx/bin/tests/System.Numerics.Vectors.Tests/netcoreapp-Linux-Release-arm
timeout --kill-after=30s 20m ./RunTests.sh /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs3_tst/_/fx/bin/testhost/netcoreapp-Linux-Release-arm

----- start 19:59:38 =============== To repro directly: =====================================================
pushd .
#!/usr/bin/env bash export COMPlus_TieredCompilation=0 export COMPlus_JitStressRegs=3
chmod +x /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs3_tst/_/fx/bin/testhost/netcoreapp-Linux-Release-arm/dotnet
/ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs3_tst/_/fx/bin/testhost/netcoreapp-Linux-Release-arm/dotnet xunit.console.netcore.exe System.Numerics.Vectors.Tests.dll  -xml testResults.xml -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonlinuxtests  -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing
popd
===========================================================================================================
/ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs3_tst/_/fx/bin/tests/System.Numerics.Vectors.Tests/netcoreapp-Linux-Release-arm /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs3_tst/_/fx/bin/tests/System.Numerics.Vectors.Tests/netcoreapp-Linux-Release-arm
xUnit.net console test runner (32-bit .NET Core)
Copyright (C) 2014 Outercurve Foundation.

Discovering: System.Numerics.Vectors.Tests
Discovered:  System.Numerics.Vectors.Tests
Starting:    System.Numerics.Vectors.Tests

Assert failure(PID 7386 [0x00001cda] Thread: 7399 [0x1ce7]): Assertion failed '(regSet.rsMaskResvd &amp; RBM_OPT_RSVD) != 0' in 'System.Numerics.Matrix4x4:op_Multiply(structstruct):struct' (IL size 1626)

    File: /mnt/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs3/src/jit/codegen.h Line: 140
    Image: /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs3_tst/_/fx/bin/testhost/netcoreapp-Linux-Release-arm/dotnet


Assert failure(PID 7386 [0x00001cda] Thread: 7399 [0x1ce7]): Assertion failed '(regSet.rsMaskResvd &amp; RBM_OPT_RSVD) != 0' in 'System.Numerics.Matrix4x4:op_Multiply(structstruct):struct' (IL size 1626)

    File: /mnt/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs3/src/jit/codegen.h Line: 140
    Image: /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs3_tst/_/fx/bin/testhost/netcoreapp-Linux-Release-arm/dotnet

./RunTests.sh: line 128:  7386 Aborted                 $RUNTIME_PATH/dotnet xunit.console.netcore.exe System.Numerics.Vectors.Tests.dll -xml testResults.xml -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonlinuxtests -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing
/ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs3_tst/_/fx/bin/tests/System.Numerics.Vectors.Tests/netcoreapp-Linux-Release-arm
----- end 19:59:56 ----- exit code 134 ----------------------------------------------------------
```

Happens for various JitStressRegs stress modes (list may not be exhaustive):

https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstressregs3_tst/20/
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstressregs4_flow/20/
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_tieredcompilation_flow/8/
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstressregs1_flow/21/
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_flow/22/

This is a recent regression.

@dotnet/arm32-contrib @CarolEidt </Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>BruceForstall</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19536</IssueLabelID>
    <Title>Fix wrong sprinf_s format string in gtGetArgMsg getGetLateArgMsg on ARM32</Title>
    <Description>One liner that fixes typo in `Compiler::gtGetArgMsg` and `Compiler::gtGetLateArgMsg` for arguments passed on stack</Description>
    <Title_Description>Fix wrong sprinf_s format string in gtGetArgMsg getGetLateArgMsg on ARM32 One liner that fixes typo in `Compiler::gtGetArgMsg` and `Compiler::gtGetLateArgMsg` for arguments passed on stack</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>echesakovMSFT</Assignee>
    <CreatedAt>17/08/2018 10:13:10 PM +00:00</CreatedAt>
    <ClosedAt>19/08/2018 1:03:07 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19535</IssueLabelID>
    <Title>[NO MERGE] Test Linux Binaries</Title>
    <Description>The updated binaries were a commit behind. Connected to https://github.com/dotnet/coreclr/pull/19393 </Description>
    <Title_Description>[NO MERGE] Test Linux Binaries The updated binaries were a commit behind. Connected to https://github.com/dotnet/coreclr/pull/19393 </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>A-And</Assignee>
    <CreatedAt>17/08/2018 9:25:50 PM +00:00</CreatedAt>
    <ClosedAt>23/08/2018 8:48:13 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19529</IssueLabelID>
    <Title>Create New Minimal Start From Scratch CoreClr</Title>
    <Description>How to create new minimal start from scratch CoreClr?</Description>
    <Title_Description>Create New Minimal Start From Scratch CoreClr How to create new minimal start from scratch CoreClr?</Title_Description>
    <Label>question</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>17/08/2018 5:30:50 AM +00:00</CreatedAt>
    <ClosedAt>21/08/2018 4:02:34 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19527</IssueLabelID>
    <Title>Remove tests previously ported to CoreFX repo</Title>
    <Description>Ported tests in dotnet/corefx#30690

cc @luqunl </Description>
    <Title_Description>Remove tests previously ported to CoreFX repo Ported tests in dotnet/corefx#30690

cc @luqunl </Title_Description>
    <Label>area-Interop</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>17/08/2018 1:04:09 AM +00:00</CreatedAt>
    <ClosedAt>17/08/2018 6:09:32 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19526</IssueLabelID>
    <Title>Only register signals and create alt exception stack in coreclr</Title>
    <Description>Only register signals and create alt exception stack in coreclr. (#19309)

There was a couple of places where the DAC (IsValidObject GetAppDomainForObject)
assumed that a NULL target/debuggee address would throw an exception that would
be caught by try/catch. Any other invalid address is handled with a software
exception throwed by the read memory functions. In general it is a better overall
design not to have any of the DBI/DAC etc. code depend on hardware exceptions
being caught. On Linux the C++ runtime sometimes can't handle it. There is a
slight risk that there are other places in the DAC that make the NULL address
assumption but testing so far has found any.

Added PAL_SetInitializeDLLFlags as a fallback to allow the PAL_InitializeDLL flags
to be set for a PAL instance for the DAC where we could still register h/w signals
but not the altstack switching to reduce this risk. The flags can't be build time
conditional because we only build one coreclrpal.a library that all the modules
used. Having a PAL_InitializeWithFlags function doesn't really help either because of
the PAL_RegisterModule call to PAL_IntializeDLL and the LoadLibrary dance/protocol
that uses it to call the loading module's DLLMain.

Add PAL_SetInitializeFlags; remove flags from PAL_INITIALIZE and PAL_INITIALIZE_DLL
default. Add PAL_InitializeWithFlags() to allowing the default to be overriden.</Description>
    <Title_Description>Only register signals and create alt exception stack in coreclr Only register signals and create alt exception stack in coreclr. (#19309)

There was a couple of places where the DAC (IsValidObject GetAppDomainForObject)
assumed that a NULL target/debuggee address would throw an exception that would
be caught by try/catch. Any other invalid address is handled with a software
exception throwed by the read memory functions. In general it is a better overall
design not to have any of the DBI/DAC etc. code depend on hardware exceptions
being caught. On Linux the C++ runtime sometimes can't handle it. There is a
slight risk that there are other places in the DAC that make the NULL address
assumption but testing so far has found any.

Added PAL_SetInitializeDLLFlags as a fallback to allow the PAL_InitializeDLL flags
to be set for a PAL instance for the DAC where we could still register h/w signals
but not the altstack switching to reduce this risk. The flags can't be build time
conditional because we only build one coreclrpal.a library that all the modules
used. Having a PAL_InitializeWithFlags function doesn't really help either because of
the PAL_RegisterModule call to PAL_IntializeDLL and the LoadLibrary dance/protocol
that uses it to call the loading module's DLLMain.

Add PAL_SetInitializeFlags; remove flags from PAL_INITIALIZE and PAL_INITIALIZE_DLL
default. Add PAL_InitializeWithFlags() to allowing the default to be overriden.</Title_Description>
    <Label>
    </Label>
    <Assignee>mikem8361</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19525</IssueLabelID>
    <Title>Enable Tiered Compilation by default</Title>
    <Description>1) Changes the default state of the tiered compilation feature check to be ON BY DEFAULT
2) Removed comments about the source about this being a work in progress. Although it will surely continue to evolve and improve remaining issues would be better tracked in our issue tracking system with the same default presumption as other runtime features - assume it works unless noted otherwise.
3) Adjusts a number of tests and automated scripts that made assumptions that the default setting of this feature is off.
4) Stop accepting the deprecated env var COMPLUS_EXPERIMENTAL_TieredCompilation. I'm not aware it has any remaining usage but if so we're going to find out.
5) Adjust config names for JitBench</Description>
    <Title_Description>Enable Tiered Compilation by default 1) Changes the default state of the tiered compilation feature check to be ON BY DEFAULT
2) Removed comments about the source about this being a work in progress. Although it will surely continue to evolve and improve remaining issues would be better tracked in our issue tracking system with the same default presumption as other runtime features - assume it works unless noted otherwise.
3) Adjusts a number of tests and automated scripts that made assumptions that the default setting of this feature is off.
4) Stop accepting the deprecated env var COMPLUS_EXPERIMENTAL_TieredCompilation. I'm not aware it has any remaining usage but if so we're going to find out.
5) Adjust config names for JitBench</Title_Description>
    <Label>area-VM</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19523</IssueLabelID>
    <Title>[WIP] Test with tiering</Title>
    <Description>
    </Description>
    <Title_Description>[WIP] Test with tiering </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19522</IssueLabelID>
    <Title>Codegen for `StoreVector128` followed by return is "poor"</Title>
    <Description>As per the comment here: https://github.com/dotnet/corefx/pull/31779/files#r210759586

The `SSE` implementation of `Matrix4x4.Transpose` is doing:
```csharp
Sse.Store(&amp;matrix.M11 Sse.MoveLowToHigh(l12 l34));
Sse.Store(&amp;matrix.M21 Sse.MoveHighToLow(l34 l12));
Sse.Store(&amp;matrix.M31 Sse.MoveLowToHigh(h12 h34));
Sse.Store(&amp;matrix.M41 Sse.MoveHighToLow(h34 h12));

return matrix;
```

Which leads to the following codegen:
```asm
vmovlhps xmm2 xmm4 xmm5
vmovups  xmmword ptr [r10] xmm2
vmovhlps xmm2 xmm5 xmm4
vmovups  xmmword ptr [rax] xmm2
vmovlhps xmm2 xmm0 xmm1
vmovups  xmmword ptr [r8] xmm2
vmovhlps xmm0 xmm1 xmm0
vmovups  xmmword ptr [r9] xmm0

vmovdqu  xmm0 qword ptr [rdx]
vmovdqu  qword ptr [rcx] xmm0
vmovdqu  xmm0 qword ptr [rdx+16]
vmovdqu  qword ptr [rcx+16] xmm0
vmovdqu  xmm0 qword ptr [rdx+32]
vmovdqu  qword ptr [rcx+32] xmm0
vmovdqu  xmm0 qword ptr [rdx+48]
vmovdqu  qword ptr [rcx+48] xmm0

mov      rax rcx
```

Ideally we should be generating the following instead:
```asm
vmovlhps xmm2 xmm4 xmm5
vmovups  xmmword ptr [rcx] xmm2
vmovhlps xmm2 xmm5 xmm4
vmovups  xmmword ptr [rcx+16] xmm2
vmovlhps xmm2 xmm0 xmm1
vmovups  xmmword ptr [rcx+32] xmm2
vmovhlps xmm0 xmm1 xmm0
vmovups  xmmword ptr [rcx+48] xmm0

mov      rax rcx
```

category:cq
theme:vector-codegen
skill-level:intermediate
cost:medium</Description>
    <Title_Description>Codegen for `StoreVector128` followed by return is "poor" As per the comment here: https://github.com/dotnet/corefx/pull/31779/files#r210759586

The `SSE` implementation of `Matrix4x4.Transpose` is doing:
```csharp
Sse.Store(&amp;matrix.M11 Sse.MoveLowToHigh(l12 l34));
Sse.Store(&amp;matrix.M21 Sse.MoveHighToLow(l34 l12));
Sse.Store(&amp;matrix.M31 Sse.MoveLowToHigh(h12 h34));
Sse.Store(&amp;matrix.M41 Sse.MoveHighToLow(h34 h12));

return matrix;
```

Which leads to the following codegen:
```asm
vmovlhps xmm2 xmm4 xmm5
vmovups  xmmword ptr [r10] xmm2
vmovhlps xmm2 xmm5 xmm4
vmovups  xmmword ptr [rax] xmm2
vmovlhps xmm2 xmm0 xmm1
vmovups  xmmword ptr [r8] xmm2
vmovhlps xmm0 xmm1 xmm0
vmovups  xmmword ptr [r9] xmm0

vmovdqu  xmm0 qword ptr [rdx]
vmovdqu  qword ptr [rcx] xmm0
vmovdqu  xmm0 qword ptr [rdx+16]
vmovdqu  qword ptr [rcx+16] xmm0
vmovdqu  xmm0 qword ptr [rdx+32]
vmovdqu  qword ptr [rcx+32] xmm0
vmovdqu  xmm0 qword ptr [rdx+48]
vmovdqu  qword ptr [rcx+48] xmm0

mov      rax rcx
```

Ideally we should be generating the following instead:
```asm
vmovlhps xmm2 xmm4 xmm5
vmovups  xmmword ptr [rcx] xmm2
vmovhlps xmm2 xmm5 xmm4
vmovups  xmmword ptr [rcx+16] xmm2
vmovlhps xmm2 xmm0 xmm1
vmovups  xmmword ptr [rcx+32] xmm2
vmovhlps xmm0 xmm1 xmm0
vmovups  xmmword ptr [rcx+48] xmm0

mov      rax rcx
```

category:cq
theme:vector-codegen
skill-level:intermediate
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>fiigii</Assignee>
    <CreatedAt>16/08/2018 10:41:09 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19521</IssueLabelID>
    <Title>Codegen for `LoadVector128` for a field of a struct is "poor"</Title>
    <Description>As per the comment here: https://github.com/dotnet/corefx/pull/31779/files#r210758497

The `SSE` implementation of `Matrix4x4.Transpose` is doing:
```csharp
var row1 = Sse.LoadVector128(&amp;matrix.M11);
var row2 = Sse.LoadVector128(&amp;matrix.M21);
var row3 = Sse.LoadVector128(&amp;matrix.M31);
var row4 = Sse.LoadVector128(&amp;matrix.M41);
```

Which leads to the following codegen:
```asm
mov      rax rdx
vmovups  xmm0 xmmword ptr [rax]
lea      rax bword ptr [rdx+16]
mov      r8 rax
vmovups  xmm1 xmmword ptr [r8]
lea      r8 bword ptr [rdx+32]
mov      r9 r8
vmovups  xmm2 xmmword ptr [r9]
lea      r9 bword ptr [rdx+48]
mov      r10 r9
vmovups  xmm3 xmmword ptr [r10]
```

Ideally we should be generating the following instead:
```asm
vmovups  xmm0 xmmword ptr [rdx]
vmovups  xmm1 xmmword ptr [rdx+16]
vmovups  xmm2 xmmword ptr [rdx+32]
vmovups  xmm3 xmmword ptr [rdx+48]
```</Description>
    <Title_Description>Codegen for `LoadVector128` for a field of a struct is "poor" As per the comment here: https://github.com/dotnet/corefx/pull/31779/files#r210758497

The `SSE` implementation of `Matrix4x4.Transpose` is doing:
```csharp
var row1 = Sse.LoadVector128(&amp;matrix.M11);
var row2 = Sse.LoadVector128(&amp;matrix.M21);
var row3 = Sse.LoadVector128(&amp;matrix.M31);
var row4 = Sse.LoadVector128(&amp;matrix.M41);
```

Which leads to the following codegen:
```asm
mov      rax rdx
vmovups  xmm0 xmmword ptr [rax]
lea      rax bword ptr [rdx+16]
mov      r8 rax
vmovups  xmm1 xmmword ptr [r8]
lea      r8 bword ptr [rdx+32]
mov      r9 r8
vmovups  xmm2 xmmword ptr [r9]
lea      r9 bword ptr [rdx+48]
mov      r10 r9
vmovups  xmm3 xmmword ptr [r10]
```

Ideally we should be generating the following instead:
```asm
vmovups  xmm0 xmmword ptr [rdx]
vmovups  xmm1 xmmword ptr [rdx+16]
vmovups  xmm2 xmmword ptr [rdx+32]
vmovups  xmm3 xmmword ptr [rdx+48]
```</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19519</IssueLabelID>
    <Title>Add a flag to enable/disable hw intrinsics</Title>
    <Description>This could potentially be a a `COMPlus_EnableHWIntrinsics` flag that is exposed in Release. It would be set to 1 by default and could be set to 0 to disable them. It would need to imply `COMPlus_FeatureSIMD` as the JIT relies on that flag for much of the code that supports the vector types.</Description>
    <Title_Description>Add a flag to enable/disable hw intrinsics This could potentially be a a `COMPlus_EnableHWIntrinsics` flag that is exposed in Release. It would be set to 1 by default and could be set to 0 to disable them. It would need to imply `COMPlus_FeatureSIMD` as the JIT relies on that flag for much of the code that supports the vector types.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
    <CreatedAt>16/08/2018 5:13:26 PM +00:00</CreatedAt>
    <ClosedAt>31/10/2018 3:46:41 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19517</IssueLabelID>
    <Title>C# Wpf Image Memory with High Resolution images(7680 X 2180) </Title>
    <Description>Problem:- WPF image holds memory. when I select an image from the directory and displayed to the image after click on destroy-image-button image is destroyed but memory is still on hold as per TaskManager and after done the same operation many times application will crash outof memory exception.. this issue is with High Resolution images(7680 X 2180)

An unhandled exception of type 'System.OutOfMemoryException' occurred in PresentationCore.dll

{The function evaluation was disabled because of an out of memory exception.}

Code &amp; Steps:-

I just simply select the image from the directory and displayed to the WPF image

    private void ImgDisplay_Click(object sender RoutedEventArgs e)
    {
        image.Source = new BitmapImage(new Uri(filePath));
    }

    private void ImgDistry_Click(object sender RoutedEventArgs e)
    {
        image.Source = null;
    }

    private void ImgSelect_Click(object sender RoutedEventArgs e)
    {
        OpenFileDialog openFileDialog1 = new OpenFileDialog();
        openFileDialog1.ShowDialog();
        filePath = openFileDialog1.FileName;
    }

&lt;Window x:Class="WpfApplication4.MainWindow"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" 
    Title="MainWindow" Background="Transparent" MaxHeight="1080" MaxWidth="1920"&gt;
&lt;Grid&gt;
    &lt;Grid.RowDefinitions&gt;
        &lt;RowDefinition Height="Auto"&gt;&lt;/RowDefinition&gt;
        &lt;RowDefinition Height="*"&gt;&lt;/RowDefinition&gt;
        &lt;RowDefinition Height="Auto"&gt;&lt;/RowDefinition&gt;
    &lt;/Grid.RowDefinitions&gt;
    &lt;Grid Margin="5"&gt;
        &lt;Grid.ColumnDefinitions&gt;
            &lt;ColumnDefinition Width="Auto"&gt;&lt;/ColumnDefinition&gt;
            &lt;ColumnDefinition Width="Auto"&gt;&lt;/ColumnDefinition&gt;
            &lt;ColumnDefinition Width="Auto"&gt;&lt;/ColumnDefinition&gt;
        &lt;/Grid.ColumnDefinitions&gt;
        &lt;Button Height="40" Width="120" Background="Green" Name="ImgDisplay" Foreground="White" Content="Display Image" Click="ImgDisplay_Click" /&gt;
        &lt;Button Margin="100100" Grid.Column="1" Height="40" Width="120" Name="ImgDistry" Content="Distroy Image" Background="Red" Foreground="White" Click="ImgDistry_Click" /&gt;
        &lt;Button Grid.Column="2" Height="40" Width="120" x:Name="ImgDistry_Copy" Content="Select Image" Background="Yellow" Foreground="Black" Click="ImgSelect_Click" /&gt;
    &lt;/Grid&gt;
    &lt;ScrollViewer Grid.Row="1"&gt;
        &lt;Image Name="image"/&gt;
    &lt;/ScrollViewer&gt;
&lt;/Grid&gt;
After select image from the directory

![6](https://user-images.githubusercontent.com/3060341/44206873-d6ff4080-a178-11e8-97b7-1f53f56c1007.png)
![7](https://user-images.githubusercontent.com/3060341/44206874-d6ff4080-a178-11e8-83af-cf1bb1d0f417.png)
![8](https://user-images.githubusercontent.com/3060341/44206875-d797d700-a178-11e8-899b-cafec48707df.png)


After doing 2-3 time same operation select image then destroy.. memory is increasing after each operation

Memory 
High Resolution images that i used you can download from here https://www.dropbox.com/s/fiodfaedwabtkgg/1.png?dl=0 https://www.dropbox.com/s/2bk0qm1clx4bgq1/2.png?dl=0 https://www.dropbox.com/s/6evtsqmqthu60mu/3.png?dl=0 https://www.dropbox.com/s/6p3o36wcires2jn/4.png?dl=0 https://www.dropbox.com/s/k5t1y9apcj4oee4/5.png?dl=0</Description>
    <Title_Description>C# Wpf Image Memory with High Resolution images(7680 X 2180)  Problem:- WPF image holds memory. when I select an image from the directory and displayed to the image after click on destroy-image-button image is destroyed but memory is still on hold as per TaskManager and after done the same operation many times application will crash outof memory exception.. this issue is with High Resolution images(7680 X 2180)

An unhandled exception of type 'System.OutOfMemoryException' occurred in PresentationCore.dll

{The function evaluation was disabled because of an out of memory exception.}

Code &amp; Steps:-

I just simply select the image from the directory and displayed to the WPF image

    private void ImgDisplay_Click(object sender RoutedEventArgs e)
    {
        image.Source = new BitmapImage(new Uri(filePath));
    }

    private void ImgDistry_Click(object sender RoutedEventArgs e)
    {
        image.Source = null;
    }

    private void ImgSelect_Click(object sender RoutedEventArgs e)
    {
        OpenFileDialog openFileDialog1 = new OpenFileDialog();
        openFileDialog1.ShowDialog();
        filePath = openFileDialog1.FileName;
    }

&lt;Window x:Class="WpfApplication4.MainWindow"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" 
    Title="MainWindow" Background="Transparent" MaxHeight="1080" MaxWidth="1920"&gt;
&lt;Grid&gt;
    &lt;Grid.RowDefinitions&gt;
        &lt;RowDefinition Height="Auto"&gt;&lt;/RowDefinition&gt;
        &lt;RowDefinition Height="*"&gt;&lt;/RowDefinition&gt;
        &lt;RowDefinition Height="Auto"&gt;&lt;/RowDefinition&gt;
    &lt;/Grid.RowDefinitions&gt;
    &lt;Grid Margin="5"&gt;
        &lt;Grid.ColumnDefinitions&gt;
            &lt;ColumnDefinition Width="Auto"&gt;&lt;/ColumnDefinition&gt;
            &lt;ColumnDefinition Width="Auto"&gt;&lt;/ColumnDefinition&gt;
            &lt;ColumnDefinition Width="Auto"&gt;&lt;/ColumnDefinition&gt;
        &lt;/Grid.ColumnDefinitions&gt;
        &lt;Button Height="40" Width="120" Background="Green" Name="ImgDisplay" Foreground="White" Content="Display Image" Click="ImgDisplay_Click" /&gt;
        &lt;Button Margin="100100" Grid.Column="1" Height="40" Width="120" Name="ImgDistry" Content="Distroy Image" Background="Red" Foreground="White" Click="ImgDistry_Click" /&gt;
        &lt;Button Grid.Column="2" Height="40" Width="120" x:Name="ImgDistry_Copy" Content="Select Image" Background="Yellow" Foreground="Black" Click="ImgSelect_Click" /&gt;
    &lt;/Grid&gt;
    &lt;ScrollViewer Grid.Row="1"&gt;
        &lt;Image Name="image"/&gt;
    &lt;/ScrollViewer&gt;
&lt;/Grid&gt;
After select image from the directory

![6](https://user-images.githubusercontent.com/3060341/44206873-d6ff4080-a178-11e8-97b7-1f53f56c1007.png)
![7](https://user-images.githubusercontent.com/3060341/44206874-d6ff4080-a178-11e8-83af-cf1bb1d0f417.png)
![8](https://user-images.githubusercontent.com/3060341/44206875-d797d700-a178-11e8-899b-cafec48707df.png)


After doing 2-3 time same operation select image then destroy.. memory is increasing after each operation

Memory 
High Resolution images that i used you can download from here https://www.dropbox.com/s/fiodfaedwabtkgg/1.png?dl=0 https://www.dropbox.com/s/2bk0qm1clx4bgq1/2.png?dl=0 https://www.dropbox.com/s/6evtsqmqthu60mu/3.png?dl=0 https://www.dropbox.com/s/6p3o36wcires2jn/4.png?dl=0 https://www.dropbox.com/s/k5t1y9apcj4oee4/5.png?dl=0</Title_Description>
    <Label>question</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>16/08/2018 11:52:02 AM +00:00</CreatedAt>
    <ClosedAt>17/08/2018 2:33:32 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19515</IssueLabelID>
    <Title>Test failure: baseservices_threading._waithandle_waitany_waitanyex2_waitanyex2_/_waithandle_waitany_waitanyex2_waitanyex2_cmd</Title>
    <Description>Opened on behalf of @Sunny-pu

The test `baseservices_threading._waithandle_waitany_waitanyex2_waitanyex2_/_waithandle_waitany_waitanyex2_waitanyex2_cmd` has failed.


    
    Return code:      1
    Raw output file:      C:\\dotnetbuild\\work\\524acbd1-5cfb-4adc-80ec-d2cfa306e357\\Work\\457012a7-5afe-4a4f-9d87-581100372ea8\\Unzip\\Reports\\baseservices.threading\\waithandle\\waitany\\waitanyex2\\waitanyex2.output.txt
    Raw output:
    BEGIN EXECUTION\r
            1 file(s) copied.\r
    \" C:\\dotnetbuild\\work\\524acbd1-5cfb-4adc-80ec-d2cfa306e357\\Payload\\crossgen.exe\" /Platform_Assemblies_Paths C:\\dotnetbuild\\work\\524acbd1-5cfb-4adc-80ec-d2cfa306e357\\Payload;C:\\dotnetbuild\\work\\524acbd1-5cfb-4adc-80ec-d2cfa306e357\\Work\\457012a7-5afe-4a4f-9d87-581100372ea8\\Unzip\\waithandle\\waitany\\waitanyex2\\IL;C:\\dotnetbuild\\work\\524acbd1-5cfb-4adc-80ec-d2cfa306e357\\Work\\457012a7-5afe-4a4f-9d87-581100372ea8\\Unzip\\waithandle\\waitany\\waitanyex2 /in waitanyex2.org /out waitanyex2.exe\r
    Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0\r
    Copyright (c) Microsoft Corporation.  All rights reserved.\r
    \r
    Native image waitanyex2.exe generated successfully.\r
     \"C:\\dotnetbuild\\work\\524acbd1-5cfb-4adc-80ec-d2cfa306e357\\Payload\\corerun.exe\" waitanyex2.exe \r
    Name created: 7e4acc81-1909-4e61-bdea-8c2706c913fd\r
    Testing Mutex and non-Mutex and signaling the other element\r
    Acquire the Mutex\r
    Holding the Mutex\r
    Waiting...\r
    WaitAny did not throw AbandonedMutexException. Result: 1\r
    Test Failed\r
    Expected: 100\r
    Actual: -1\r
    END EXECUTION - FAILED\r
    FAILED\r
    Test Harness Exitcode is : 1\r
    
    To run the test:
    &gt; set CORE_ROOT=C:\\dotnetbuild\\work\\524acbd1-5cfb-4adc-80ec-d2cfa306e357\\Payload
    &gt; C:\\dotnetbuild\\work\\524acbd1-5cfb-4adc-80ec-d2cfa306e357\\Work\\457012a7-5afe-4a4f-9d87-581100372ea8\\Unzip\\waithandle\\waitany\\waitanyex2\\waitanyex2.cmd
    \r
    Expected: True\r
    Actual:   False

        Stack Trace:

           at baseservices_threading._waithandle_waitany_waitanyex2_waitanyex2_._waithandle_waitany_waitanyex2_waitanyex2_cmd() in E:\A\_work\4\s\bin\tests\Windows_NT.arm.Release\TestWrappers\baseservices.threading\baseservices.threading.XUnitWrapper.cs:line 28809
Build : 3.0 - 20180816.01 (Ready-To-Run Tests)
Failing configurations:
- windows.10.arm64
  - arm

Details: https://mc.dot.net/#/product/netcore/30/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fr2r~2Fcli~2F/build/20180816.01/workItem/baseservices.threading.XUnitWrapper/analysis/xunit/baseservices_threading._waithandle_waitany_waitanyex2_waitanyex2_~2F_waithandle_waitany_waitanyex2_waitanyex2_cmd</Description>
    <Title_Description>Test failure: baseservices_threading._waithandle_waitany_waitanyex2_waitanyex2_/_waithandle_waitany_waitanyex2_waitanyex2_cmd Opened on behalf of @Sunny-pu

The test `baseservices_threading._waithandle_waitany_waitanyex2_waitanyex2_/_waithandle_waitany_waitanyex2_waitanyex2_cmd` has failed.


    
    Return code:      1
    Raw output file:      C:\\dotnetbuild\\work\\524acbd1-5cfb-4adc-80ec-d2cfa306e357\\Work\\457012a7-5afe-4a4f-9d87-581100372ea8\\Unzip\\Reports\\baseservices.threading\\waithandle\\waitany\\waitanyex2\\waitanyex2.output.txt
    Raw output:
    BEGIN EXECUTION\r
            1 file(s) copied.\r
    \" C:\\dotnetbuild\\work\\524acbd1-5cfb-4adc-80ec-d2cfa306e357\\Payload\\crossgen.exe\" /Platform_Assemblies_Paths C:\\dotnetbuild\\work\\524acbd1-5cfb-4adc-80ec-d2cfa306e357\\Payload;C:\\dotnetbuild\\work\\524acbd1-5cfb-4adc-80ec-d2cfa306e357\\Work\\457012a7-5afe-4a4f-9d87-581100372ea8\\Unzip\\waithandle\\waitany\\waitanyex2\\IL;C:\\dotnetbuild\\work\\524acbd1-5cfb-4adc-80ec-d2cfa306e357\\Work\\457012a7-5afe-4a4f-9d87-581100372ea8\\Unzip\\waithandle\\waitany\\waitanyex2 /in waitanyex2.org /out waitanyex2.exe\r
    Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0\r
    Copyright (c) Microsoft Corporation.  All rights reserved.\r
    \r
    Native image waitanyex2.exe generated successfully.\r
     \"C:\\dotnetbuild\\work\\524acbd1-5cfb-4adc-80ec-d2cfa306e357\\Payload\\corerun.exe\" waitanyex2.exe \r
    Name created: 7e4acc81-1909-4e61-bdea-8c2706c913fd\r
    Testing Mutex and non-Mutex and signaling the other element\r
    Acquire the Mutex\r
    Holding the Mutex\r
    Waiting...\r
    WaitAny did not throw AbandonedMutexException. Result: 1\r
    Test Failed\r
    Expected: 100\r
    Actual: -1\r
    END EXECUTION - FAILED\r
    FAILED\r
    Test Harness Exitcode is : 1\r
    
    To run the test:
    &gt; set CORE_ROOT=C:\\dotnetbuild\\work\\524acbd1-5cfb-4adc-80ec-d2cfa306e357\\Payload
    &gt; C:\\dotnetbuild\\work\\524acbd1-5cfb-4adc-80ec-d2cfa306e357\\Work\\457012a7-5afe-4a4f-9d87-581100372ea8\\Unzip\\waithandle\\waitany\\waitanyex2\\waitanyex2.cmd
    \r
    Expected: True\r
    Actual:   False

        Stack Trace:

           at baseservices_threading._waithandle_waitany_waitanyex2_waitanyex2_._waithandle_waitany_waitanyex2_waitanyex2_cmd() in E:\A\_work\4\s\bin\tests\Windows_NT.arm.Release\TestWrappers\baseservices.threading\baseservices.threading.XUnitWrapper.cs:line 28809
Build : 3.0 - 20180816.01 (Ready-To-Run Tests)
Failing configurations:
- windows.10.arm64
  - arm

Details: https://mc.dot.net/#/product/netcore/30/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fr2r~2Fcli~2F/build/20180816.01/workItem/baseservices.threading.XUnitWrapper/analysis/xunit/baseservices_threading._waithandle_waitany_waitanyex2_waitanyex2_~2F_waithandle_waitany_waitanyex2_waitanyex2_cmd</Title_Description>
    <Label>area-System.Threading</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>16/08/2018 3:46:06 AM +00:00</CreatedAt>
    <ClosedAt>26/07/2019 1:05:00 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19509</IssueLabelID>
    <Title>[WIP] Test with tiering enabled</Title>
    <Description>
    </Description>
    <Title_Description>[WIP] Test with tiering enabled </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19508</IssueLabelID>
    <Title>Make file handle checks accurate on Windows</Title>
    <Description>We can actually check the async state of a handle on Windows so check directly when we have the API available. It is faster and more reliable as the state is literally a flag on the handle.

Also allow all filetypes through when explicitly using extended syntax `\\?\` . This unblocks a number of advanced customer scenarios.

Fixes https://github.com/dotnet/corefx/issues/187.
</Description>
    <Title_Description>Make file handle checks accurate on Windows We can actually check the async state of a handle on Windows so check directly when we have the API available. It is faster and more reliable as the state is literally a flag on the handle.

Also allow all filetypes through when explicitly using extended syntax `\\?\` . This unblocks a number of advanced customer scenarios.

Fixes https://github.com/dotnet/corefx/issues/187.
</Title_Description>
    <Label>area-System.IO</Label>
    <Assignee>JeremyKuhne</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19507</IssueLabelID>
    <Title>Add Public API Marshal.IsTypeVisibleFromCom and Marshal.GetEndComSlot</Title>
    <Description>Fix https://github.com/dotnet/corefx/issues/30393 and https://github.com/dotnet/corefx/issues/30849

There is another corefx PR</Description>
    <Title_Description>Add Public API Marshal.IsTypeVisibleFromCom and Marshal.GetEndComSlot Fix https://github.com/dotnet/corefx/issues/30393 and https://github.com/dotnet/corefx/issues/30849

There is another corefx PR</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>luqunl</Assignee>
    <CreatedAt>15/08/2018 8:48:49 PM +00:00</CreatedAt>
    <ClosedAt>15/08/2018 10:52:29 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19505</IssueLabelID>
    <Title>Revert "Temporarily flag a SIMD test as optimization-sensitive (#19163)"</Title>
    <Description>This reverts commit 855ddf52c7b05994cf6728b9169fa6cdc694a537 (PR https://github.com/dotnet/coreclr/pull/19163). Issue https://github.com/dotnet/coreclr/issues/19124 was fixed by PR https://github.com/dotnet/coreclr/pull/19234 so re-enabling the test in minopts and with tiering.</Description>
    <Title_Description>Revert "Temporarily flag a SIMD test as optimization-sensitive (#19163)" This reverts commit 855ddf52c7b05994cf6728b9169fa6cdc694a537 (PR https://github.com/dotnet/coreclr/pull/19163). Issue https://github.com/dotnet/coreclr/issues/19124 was fixed by PR https://github.com/dotnet/coreclr/pull/19234 so re-enabling the test in minopts and with tiering.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19503</IssueLabelID>
    <Title>[automated] Merge branch 'release/2.1' =&gt; 'release/2.2'</Title>
    <Description>I detected changes in the release/2.1 branch which have not been merged yet to release/2.2.
I'm a robot and am configured to help you automatically keep release/2.2 up to date so
I've opened this PR.

This PR merges commits made on release/2.1 by the following committers:

* @wtgodbe
* @dotnet-maestro-bot
* @mmitche

## Instructions for merging

This PR will not be auto-merged. When pull request checks pass please complete this PR
by creating a merge commit *not* a squash or rebase commit.

&lt;img alt="merge button instructions" src="https://i.imgur.com/GepcNJV.png" width="300" /&gt;

You can also do this on command line:
```
git checkout release/2.2
git pull
git fetch --force https://github.com/dotnet-maestro-bot/coreclr merge/release/2.1-to-release/2.2:merge/release/2.1-to-release/2.2
git merge merge/release/2.1-to-release/2.2
git push
```

## Instructions for resolving conflicts

:warning: If there are merge conflicts you will need to resolve them manually before merging.
You can do this [using GitHub](https://help.github.com/articles/resolving-a-merge-conflict-on-github/)
or using the [command line](https://help.github.com/articles/resolving-a-merge-conflict-using-the-command-line/).

Maintainers of this repo have permission to the branch 'merge/release/2.1-to-release/2.2' on https://github.com/dotnet-maestro-bot/coreclr.
You can push changes to this branch to resolve conflicts or other issues in this pull request. The bot will attempt
to update this branch as more changes are discovered on release/2.1.

Please contact ASP.NET Core Engineering if you have questions or issues.
Also if this PR was generated incorrectly help us fix it. See https://github.com/aspnet/BuildTools/blob/master/scripts/GitHubMergeBranches.ps1.</Description>
    <Title_Description>[automated] Merge branch 'release/2.1' =&gt; 'release/2.2' I detected changes in the release/2.1 branch which have not been merged yet to release/2.2.
I'm a robot and am configured to help you automatically keep release/2.2 up to date so
I've opened this PR.

This PR merges commits made on release/2.1 by the following committers:

* @wtgodbe
* @dotnet-maestro-bot
* @mmitche

## Instructions for merging

This PR will not be auto-merged. When pull request checks pass please complete this PR
by creating a merge commit *not* a squash or rebase commit.

&lt;img alt="merge button instructions" src="https://i.imgur.com/GepcNJV.png" width="300" /&gt;

You can also do this on command line:
```
git checkout release/2.2
git pull
git fetch --force https://github.com/dotnet-maestro-bot/coreclr merge/release/2.1-to-release/2.2:merge/release/2.1-to-release/2.2
git merge merge/release/2.1-to-release/2.2
git push
```

## Instructions for resolving conflicts

:warning: If there are merge conflicts you will need to resolve them manually before merging.
You can do this [using GitHub](https://help.github.com/articles/resolving-a-merge-conflict-on-github/)
or using the [command line](https://help.github.com/articles/resolving-a-merge-conflict-using-the-command-line/).

Maintainers of this repo have permission to the branch 'merge/release/2.1-to-release/2.2' on https://github.com/dotnet-maestro-bot/coreclr.
You can push changes to this branch to resolve conflicts or other issues in this pull request. The bot will attempt
to update this branch as more changes are discovered on release/2.1.

Please contact ASP.NET Core Engineering if you have questions or issues.
Also if this PR was generated incorrectly help us fix it. See https://github.com/aspnet/BuildTools/blob/master/scripts/GitHubMergeBranches.ps1.</Title_Description>
    <Label>
    </Label>
    <Assignee>wtgodbe</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19502</IssueLabelID>
    <Title>Switch CoreLib to R2R on all platforms</Title>
    <Description>
    </Description>
    <Title_Description>Switch CoreLib to R2R on all platforms </Title_Description>
    <Label>area-ReadyToRun</Label>
    <Assignee>fadimounir</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19500</IssueLabelID>
    <Title>Remove NumaNodeInfo CPUGroupInfo AppDomain SystemDomain and EEConfig stubs from local gc</Title>
    <Description>Everything except EEConfig is moved to the interface. EEConfig is only used for STRESS_HEAP which is disabled for local gc so my plan is to delete EEConfig for now and fix it at the same time as STRESS_HEAP.</Description>
    <Title_Description>Remove NumaNodeInfo, CPUGroupInfo, AppDomain, SystemDomain, and EEConfig stubs from local gc Everything except EEConfig is moved to the interface. EEConfig is only used for STRESS_HEAP which is disabled for local gc so my plan is to delete EEConfig for now and fix it at the same time as STRESS_HEAP.</Title_Description>
    <Label>area-GC</Label>
    <Assignee>davmason</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19499</IssueLabelID>
    <Title>Consider reordering the instrsxarch.h encodings to save space</Title>
    <Description>The `instrsxarch.h` encodings are currently ordered as follows:
* R/M[reg]
* R/Micon
* regR/M
* eaxi32
* register

This ordering appears to have been done in order to save space as not all instructions require all encodings However with the addition of `HardwareIntrinsics` a large number of INST3 encodings were added and often only one or two of the encodings are used.

It may be beneficial to consider reordering these encodings in order to save additional space. Looking briefly at the encodings I see the following:

encoding | # entries | # bad_code
-- | -- | --
R/M[reg] | 527 | 366
R/Micon | 444 | 390
regR/M | 421 | 56
eaxi32 | 21 | 10
register | 9 | 1


category:implementation
theme:emitter
skill-level:beginner
cost:medium</Description>
    <Title_Description>Consider reordering the instrsxarch.h encodings to save space The `instrsxarch.h` encodings are currently ordered as follows:
* R/M[reg]
* R/Micon
* regR/M
* eaxi32
* register

This ordering appears to have been done in order to save space as not all instructions require all encodings However with the addition of `HardwareIntrinsics` a large number of INST3 encodings were added and often only one or two of the encodings are used.

It may be beneficial to consider reordering these encodings in order to save additional space. Looking briefly at the encodings I see the following:

encoding | # entries | # bad_code
-- | -- | --
R/M[reg] | 527 | 366
R/Micon | 444 | 390
regR/M | 421 | 56
eaxi32 | 21 | 10
register | 9 | 1


category:implementation
theme:emitter
skill-level:beginner
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
    <CreatedAt>15/08/2018 2:23:31 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19498</IssueLabelID>
    <Title>Refactor instrsxarch.h to contain a `flags` field</Title>
    <Description>Currently the `instrsxarch.h` macros define a number of pieces of information for each instruction:
* id
* name
* update mode
* encodings
* flags
  * is floating point
  * reads flags
  * writes flags

The `flags` are currently listed separately and combined later:
```cpp
// ...
#define INST5(id nm fp um rf wf mr mi rm a4 rr)
// ...
INST5(push    "push"          0 IUM_RD 0 0 0x0030FE 0x000068 BAD_CODE BAD_CODE 0x000050)
```
and
```cpp
const BYTE          CodeGenInterface::instInfo[] =
{
    // ...
    #define INST5(id nm fp um rf wf mr mi rm a4 rr ) (INST_USE_FL*rf|INST_DEF_FL*wf|INST_FP*fp)
    // ...
};
```

I propose we refactor this so that all flags are listed together under a single macro parameter. This would help facilitate the ability to insert additional flags as necessary:
```cpp
#define INST5(id nm um flags mr mi rm a4 rr)
INST5(push    "push"          IUM_RD INS_FLAGS_None        0x0030FE 0x000068 BAD_CODE BAD_CODE 0x000050)
INST5(inc     "inc"           IUM_RW INS_FLAGS_WritesFlags 0x0000FE BAD_CODE BAD_CODE BAD_CODE 0x000040)
```
and
```
const insFlags          CodeGenInterface::instInfo[] =
{
    // ...
    #define INST5(id nm um flags mr mi rm a4 rr ) static_cast&lt;insFlags&gt;(flags)
    // ...
};
```</Description>
    <Title_Description>Refactor instrsxarch.h to contain a `flags` field Currently the `instrsxarch.h` macros define a number of pieces of information for each instruction:
* id
* name
* update mode
* encodings
* flags
  * is floating point
  * reads flags
  * writes flags

The `flags` are currently listed separately and combined later:
```cpp
// ...
#define INST5(id nm fp um rf wf mr mi rm a4 rr)
// ...
INST5(push    "push"          0 IUM_RD 0 0 0x0030FE 0x000068 BAD_CODE BAD_CODE 0x000050)
```
and
```cpp
const BYTE          CodeGenInterface::instInfo[] =
{
    // ...
    #define INST5(id nm fp um rf wf mr mi rm a4 rr ) (INST_USE_FL*rf|INST_DEF_FL*wf|INST_FP*fp)
    // ...
};
```

I propose we refactor this so that all flags are listed together under a single macro parameter. This would help facilitate the ability to insert additional flags as necessary:
```cpp
#define INST5(id nm um flags mr mi rm a4 rr)
INST5(push    "push"          IUM_RD INS_FLAGS_None        0x0030FE 0x000068 BAD_CODE BAD_CODE 0x000050)
INST5(inc     "inc"           IUM_RW INS_FLAGS_WritesFlags 0x0000FE BAD_CODE BAD_CODE BAD_CODE 0x000040)
```
and
```
const insFlags          CodeGenInterface::instInfo[] =
{
    // ...
    #define INST5(id nm um flags mr mi rm a4 rr ) static_cast&lt;insFlags&gt;(flags)
    // ...
};
```</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
    <CreatedAt>15/08/2018 1:56:51 AM +00:00</CreatedAt>
    <ClosedAt>28/08/2018 2:53:54 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19495</IssueLabelID>
    <Title>Update debugging and createdump docs</Title>
    <Description>
    </Description>
    <Title_Description>Update debugging and createdump docs </Title_Description>
    <Label>
    </Label>
    <Assignee>mikem8361</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19492</IssueLabelID>
    <Title>Unsafe.Unbox is not available inside mscorlib</Title>
    <Description>I am wondering why `Unsafe.Unbox` is not part of CoreCLR - I see it is available in CoreFX: https://github.com/dotnet/corefx/pull/31133/files 
I wrote a small roslyn script https://gist.github.com/EgorBo/41d91a4d0b6ccb90096dd7cc0857dfa0 and it found lots of places where I believe we could utilize `ref Unsafe.Unbox&lt;T&gt;` instead of unboxing and wondering if it makes sense or not e.g. https://github.com/dotnet/coreclr/blob/master/src/System.Private.CoreLib/shared/System/Guid.cs#L1048
![image](https://user-images.githubusercontent.com/523221/44123805-a870ef4e-a032-11e8-93a7-47f98ef7dd89.png)

</Description>
    <Title_Description>Unsafe.Unbox is not available inside mscorlib I am wondering why `Unsafe.Unbox` is not part of CoreCLR - I see it is available in CoreFX: https://github.com/dotnet/corefx/pull/31133/files 
I wrote a small roslyn script https://gist.github.com/EgorBo/41d91a4d0b6ccb90096dd7cc0857dfa0 and it found lots of places where I believe we could utilize `ref Unsafe.Unbox&lt;T&gt;` instead of unboxing and wondering if it makes sense or not e.g. https://github.com/dotnet/coreclr/blob/master/src/System.Private.CoreLib/shared/System/Guid.cs#L1048
![image](https://user-images.githubusercontent.com/523221/44123805-a870ef4e-a032-11e8-93a7-47f98ef7dd89.png)

</Title_Description>
    <Label>area-Meta</Label>
    <Assignee>benaadams</Assignee>
    <CreatedAt>14/08/2018 10:02:32 PM +00:00</CreatedAt>
    <ClosedAt>15/08/2018 1:37:15 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19490</IssueLabelID>
    <Title>Add an empty console application to measure startup of the runtime.</Title>
    <Description>
    </Description>
    <Title_Description>Add an empty console application to measure startup of the runtime. </Title_Description>
    <Label>tenet-performance-benchmarks</Label>
    <Assignee>jorive</Assignee>
    <CreatedAt>14/08/2018 9:01:44 PM +00:00</CreatedAt>
    <ClosedAt>16/08/2018 6:25:32 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19488</IssueLabelID>
    <Title>Disable a regex test that is failing with minopts</Title>
    <Description>See dotnet/coreclr#18912. This test would always fail once tiered compilation is enabled by default in CoreFX test runs in the CoreCLR repo.</Description>
    <Title_Description>Disable a regex test that is failing with minopts See dotnet/coreclr#18912. This test would always fail once tiered compilation is enabled by default in CoreFX test runs in the CoreCLR repo.</Title_Description>
    <Label>disabled-test</Label>
    <Assignee>kouvel</Assignee>
    <CreatedAt>14/08/2018 8:25:33 PM +00:00</CreatedAt>
    <ClosedAt>16/08/2018 6:23:48 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19483</IssueLabelID>
    <Title>Disable constant folding in JIT resulting in NaN infinities etc</Title>
    <Description>As it was discussed and agreed in #19395 JIT should not statically evaluate expressions resulting in NaNs infinities or any cases left implementation-defined by IEEE754. 

category:correctness
theme:optimization
skill-level:beginner
cost:small</Description>
    <Title_Description>Disable constant folding in JIT resulting in NaN, infinities etc As it was discussed and agreed in #19395 JIT should not statically evaluate expressions resulting in NaNs infinities or any cases left implementation-defined by IEEE754. 

category:correctness
theme:optimization
skill-level:beginner
cost:small</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>echesakovMSFT</Assignee>
    <CreatedAt>14/08/2018 6:04:06 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19481</IssueLabelID>
    <Title>Build CoreCLR on FreeBSD11</Title>
    <Description>Hi
I am trying to use the instructions for FreeBSD to build CoreCLR on FreeBSD11 with llvm3.8
During Build the runtime step (build.sh) I got this error:
`[ 99%] Linking CXX shared library libcoreclr.so Killed *** [all] Error code 137 make: stopped in /usr/home/git/coreclr/bin/obj/FreeBSD.x64.Debug 1 error make: stopped in /usr/home/git/coreclr/bin/obj/FreeBSD.x64.Debug Failed to build CoreCLR component.`

![image](https://user-images.githubusercontent.com/24319588/44094619-f82549e2-9fd6-11e8-88ec-e5e6f40395a9.png)
</Description>
    <Title_Description>Build CoreCLR on FreeBSD11 Hi
I am trying to use the instructions for FreeBSD to build CoreCLR on FreeBSD11 with llvm3.8
During Build the runtime step (build.sh) I got this error:
`[ 99%] Linking CXX shared library libcoreclr.so Killed *** [all] Error code 137 make: stopped in /usr/home/git/coreclr/bin/obj/FreeBSD.x64.Debug 1 error make: stopped in /usr/home/git/coreclr/bin/obj/FreeBSD.x64.Debug Failed to build CoreCLR component.`

![image](https://user-images.githubusercontent.com/24319588/44094619-f82549e2-9fd6-11e8-88ec-e5e6f40395a9.png)
</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>14/08/2018 1:26:41 PM +00:00</CreatedAt>
    <ClosedAt>1/12/2018 1:18:39 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19480</IssueLabelID>
    <Title>Chinese Lunisolar Calendar conversion table discrepancy for the years 2057 2089 and 2097</Title>
    <Description>The [Chinese Lunisolar Calendar](https://github.com/dotnet/coreclr/blob/master/src/System.Private.CoreLib/shared/System/Globalization/ChineseLunisolarCalendar.cs) uses a table of data for conversion between Chinese lunisolar dates and Gregorian dates. There appears to be a discrepancy for the table entry for the _days in months_ for the lunar years which started in the Gregorian years 2057 2089 and 2097 when compared with other sources. These are:

- output from Calendrical Calculations (4th edition section 19) which implements the Chinese lunisolar calendar rules used by the [Purple Mountain Observatory](http://english.pmo.cas.cn/) as also detailed [here](http://aa.usno.navy.mil/publications/docs/c15_usb_online.pdf)
- footnote on [tables](http://www.hko.gov.hk/gts/time/conversion.htm) published by the Hong Kong Observatory which state their tables are out by one day for the new moons on 28 September 2057 4 September 2089 and 7 August 2097 (which matches exactly with the same discrepancy between the .NET tables and output from Calendrical Calculations)

Year | Days in month | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13
-- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | --
2057 | .NET | 29 | 30 | 30 | 29 | 30 | 29 | 30 | **30** | **29** | 29 | 30 | 29 | 0
2057 | CC    | 29 | 30 | 30 | 29 | 30 | 29 | 30 | **29** | **30** | 29 | 30 | 29 | 0
2089 | .NET | 30 | 30 | 29 | 30 | 29 | 29 | **30** | **29** | 29 | 30 | 30 | 29 | 0
2089 | CC    | 30 | 30 | 29 | 30 | 29 | 29 | **29** | **30** | 29 | 30 | 30 | 29 | 0
2097 | .NET | 30 | 29 | 30 | 29 | 29 | **30** | **29** | 29 | 30 | 30 | 29 | 30 | 0
2097 | CC    | 30 | 29 | 30 | 29 | 29 | **29** | **30** | 29 | 30 | 30 | 29 | 30 | 0

Existing table entries:
```
2057    */{ 0  2  4  27424 }/*    29    30    30    29    30    29    30    30    29    29    30    29    0  354
2089    */{ 0  2  10  53856 }/*   30    30    29    30    29    29    30    29    29    30    30    29    0  354
2097    */{ 0  2  12  42192 }/*   30    29    30    29    29    30    29    29    30    30    29    30    0  354
```
Suggested updated table entries based on Calendrical Calculations:
```
2057    */{ 0  2  4  27296 }/*    29    30    30    29    30    29    30    29    30    29    30    29    0  354
2089    */{ 0  2  10  53600 }/*   30    30    29    30    29    29    29    30    29    30    30    29    0  354
2097    */{ 0  2  12  41680 }/*   30    29    30    29    29    29    30    29    30    30    29    30    0  354
```


</Description>
    <Title_Description>Chinese Lunisolar Calendar conversion table discrepancy for the years 2057, 2089, and 2097 The [Chinese Lunisolar Calendar](https://github.com/dotnet/coreclr/blob/master/src/System.Private.CoreLib/shared/System/Globalization/ChineseLunisolarCalendar.cs) uses a table of data for conversion between Chinese lunisolar dates and Gregorian dates. There appears to be a discrepancy for the table entry for the _days in months_ for the lunar years which started in the Gregorian years 2057 2089 and 2097 when compared with other sources. These are:

- output from Calendrical Calculations (4th edition section 19) which implements the Chinese lunisolar calendar rules used by the [Purple Mountain Observatory](http://english.pmo.cas.cn/) as also detailed [here](http://aa.usno.navy.mil/publications/docs/c15_usb_online.pdf)
- footnote on [tables](http://www.hko.gov.hk/gts/time/conversion.htm) published by the Hong Kong Observatory which state their tables are out by one day for the new moons on 28 September 2057 4 September 2089 and 7 August 2097 (which matches exactly with the same discrepancy between the .NET tables and output from Calendrical Calculations)

Year | Days in month | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13
-- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | --
2057 | .NET | 29 | 30 | 30 | 29 | 30 | 29 | 30 | **30** | **29** | 29 | 30 | 29 | 0
2057 | CC    | 29 | 30 | 30 | 29 | 30 | 29 | 30 | **29** | **30** | 29 | 30 | 29 | 0
2089 | .NET | 30 | 30 | 29 | 30 | 29 | 29 | **30** | **29** | 29 | 30 | 30 | 29 | 0
2089 | CC    | 30 | 30 | 29 | 30 | 29 | 29 | **29** | **30** | 29 | 30 | 30 | 29 | 0
2097 | .NET | 30 | 29 | 30 | 29 | 29 | **30** | **29** | 29 | 30 | 30 | 29 | 30 | 0
2097 | CC    | 30 | 29 | 30 | 29 | 29 | **29** | **30** | 29 | 30 | 30 | 29 | 30 | 0

Existing table entries:
```
2057    */{ 0  2  4  27424 }/*    29    30    30    29    30    29    30    30    29    29    30    29    0  354
2089    */{ 0  2  10  53856 }/*   30    30    29    30    29    29    30    29    29    30    30    29    0  354
2097    */{ 0  2  12  42192 }/*   30    29    30    29    29    30    29    29    30    30    29    30    0  354
```
Suggested updated table entries based on Calendrical Calculations:
```
2057    */{ 0  2  4  27296 }/*    29    30    30    29    30    29    30    29    30    29    30    29    0  354
2089    */{ 0  2  10  53600 }/*   30    30    29    30    29    29    29    30    29    30    30    29    0  354
2097    */{ 0  2  12  41680 }/*   30    29    30    29    29    29    30    29    30    30    29    30    0  354
```


</Title_Description>
    <Label>area-System.Globalization</Label>
    <Assignee>elyoh</Assignee>
    <CreatedAt>14/08/2018 9:19:35 AM +00:00</CreatedAt>
    <ClosedAt>13/09/2018 9:58:28 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19479</IssueLabelID>
    <Title>Some JitBench fixes</Title>
    <Description>- Fixed `dotnet run` from the `unofficial_dotnet` folder after `Directory.Build.targets` was added to `coreclr/tests/src`. This file is auto-imported and was adding dependencies and properties for targets that were not necessary. Added files to the root JitBench folder to override.
- Updated JitBench to be able to run against netcoreapp3.0. I haven't changed the default yet could consider doing so once there are no pending perf issues being looked into.
  - Added a `RetargetProjects()` function to the setup steps to replace `TargetFramework` and `RuntimeFrameworkVersion` values in the relevant `.csproj` files to run against the expected runtime. This reduces some dependency on other repos containing the actual perf projects such that we don't have to update every repo to support environment variables to set those values.
- Disabled tiering for the `MinOpts` config</Description>
    <Title_Description>Some JitBench fixes - Fixed `dotnet run` from the `unofficial_dotnet` folder after `Directory.Build.targets` was added to `coreclr/tests/src`. This file is auto-imported and was adding dependencies and properties for targets that were not necessary. Added files to the root JitBench folder to override.
- Updated JitBench to be able to run against netcoreapp3.0. I haven't changed the default yet could consider doing so once there are no pending perf issues being looked into.
  - Added a `RetargetProjects()` function to the setup steps to replace `TargetFramework` and `RuntimeFrameworkVersion` values in the relevant `.csproj` files to run against the expected runtime. This reduces some dependency on other repos containing the actual perf projects such that we don't have to update every repo to support environment variables to set those values.
- Disabled tiering for the `MinOpts` config</Title_Description>
    <Label>area-Meta</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19478</IssueLabelID>
    <Title> [Test Failure] ApartmentState_NoAttributePresent_STA_Windows_Core</Title>
    <Description>From the new binary test run
` System.Threading.Threads.Tests.ThreadTests.ApartmentState_NoAttributePresent_STA_Windows_Core `
is failing with 
From the CI run:

```
17:52:47  System.Threading.Threads.Tests.ThreadTests.ApartmentState_NoAttributePresent_STA_Windows_Core [FAIL]
17:52:47       System.Diagnostics.RemoteExecutorTestBase+RemoteInvokeHandle+RemoteExecutionException : Remote process failed with an unhandled exception.
17:52:47       Stack Trace:
17:52:47          
17:52:47          Child exception:
17:52:47            System.InvalidOperationException: Failed to set the specified COM apartment state.
17:52:47          E:\A\_work\36\s\corefx\src\System.Threading.Thread\src\System\Threading\Thread.cs(2330): at System.Threading.Thread.SetApartmentState(ApartmentState state)
17:52:47          D:\j\workspace\windows-TGrou---74aa877a\src\System.Threading.Thread\tests\ThreadTests.cs(2050): at System.Threading.Threads.Tests.ThreadTests.&lt;&gt;c.&lt;ApartmentState_NoAttributePresent_STA_Windows_Core&gt;b__6_0()
17:52:47          
17:52:47          Child process:
17:52:47            System.Threading.Thread.Tests Version=4.1.1.0 Culture=neutral PublicKeyToken=9d77cc7ad39b68eb System.Threading.Threads.Tests.ThreadTests+&lt;&gt;c Void &lt;ApartmentState_NoAttributePresent_STA_Windows_Core&gt;b__6_0()
```</Description>
    <Title_Description> [Test Failure] ApartmentState_NoAttributePresent_STA_Windows_Core From the new binary test run
` System.Threading.Threads.Tests.ThreadTests.ApartmentState_NoAttributePresent_STA_Windows_Core `
is failing with 
From the CI run:

```
17:52:47  System.Threading.Threads.Tests.ThreadTests.ApartmentState_NoAttributePresent_STA_Windows_Core [FAIL]
17:52:47       System.Diagnostics.RemoteExecutorTestBase+RemoteInvokeHandle+RemoteExecutionException : Remote process failed with an unhandled exception.
17:52:47       Stack Trace:
17:52:47          
17:52:47          Child exception:
17:52:47            System.InvalidOperationException: Failed to set the specified COM apartment state.
17:52:47          E:\A\_work\36\s\corefx\src\System.Threading.Thread\src\System\Threading\Thread.cs(2330): at System.Threading.Thread.SetApartmentState(ApartmentState state)
17:52:47          D:\j\workspace\windows-TGrou---74aa877a\src\System.Threading.Thread\tests\ThreadTests.cs(2050): at System.Threading.Threads.Tests.ThreadTests.&lt;&gt;c.&lt;ApartmentState_NoAttributePresent_STA_Windows_Core&gt;b__6_0()
17:52:47          
17:52:47          Child process:
17:52:47            System.Threading.Thread.Tests Version=4.1.1.0 Culture=neutral PublicKeyToken=9d77cc7ad39b68eb System.Threading.Threads.Tests.ThreadTests+&lt;&gt;c Void &lt;ApartmentState_NoAttributePresent_STA_Windows_Core&gt;b__6_0()
```</Title_Description>
    <Label>arch-x64</Label>
    <Assignee>A-And</Assignee>
    <CreatedAt>14/08/2018 3:42:21 AM +00:00</CreatedAt>
    <ClosedAt>14/08/2018 4:19:27 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19476</IssueLabelID>
    <Title>Code review feedback for the alternate stack changes (PR #19309).</Title>
    <Description>Renamed PAL_InitializeFlags to PAL_InitializeWithFlags. Combined PAL_INITIALIZE_ENSURE_ALT_SIGNAL_STACK and PAL_INITIALIZE_REGISTER_SIGNALS flags.

Also fixed SOS plugin for core dumps.</Description>
    <Title_Description>Code review feedback for the alternate stack changes (PR #19309). Renamed PAL_InitializeFlags to PAL_InitializeWithFlags. Combined PAL_INITIALIZE_ENSURE_ALT_SIGNAL_STACK and PAL_INITIALIZE_REGISTER_SIGNALS flags.

Also fixed SOS plugin for core dumps.</Title_Description>
    <Label>
    </Label>
    <Assignee>mikem8361</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19474</IssueLabelID>
    <Title>Unexpected results returning struct with floats in RCW</Title>
    <Description>In trying to wrap [`ID2D1RenderTarget::GetSize`](https://msdn.microsoft.com/en-us/library/windows/desktop/dd316823(v=vs.85).aspx) which returns [`D2D_SIZE_F`] the expected way it would corrupt the stack.

Flipping it to an out parameter made it work but I'm unclear as to why. Discussing with @davidwrighton there might be a bug here. I was unable to create the same scenario via straight `[DllImport]`s against a sample project. I'll see if I can get a smaller repro together.

In `d2d1.h` it is defined as:

``` C++
STDMETHOD_(D2D1_SIZE_F GetSize)(
    ) CONST PURE;
```

Which expands to:

``` C++
virtual __declspec(nothrow) D2D1_SIZE_F __stdcall GetSize() const = 0;
```

The struct is:

``` C++
typedef struct D2D_SIZE_F
{
    FLOAT width;
    FLOAT height;
} D2D_SIZE_F;
```

I wrapped this [here](https://github.com/JeremyKuhne/WInterop/blob/e41811b230bd332b9ead669542339e7d982d487a/src/WInterop.DirectX/Direct2d/IRenderTarget.cs#L436-L437) (`SizeF` is from System.Drawing):

``` C#
[PreserveSig]
void GetSize(out SizeF size);

// Doesn't Work:
// [PreserveSig]
// SizeF GetSize();
```

In the WInterop project I have a test `Direct2dTests.RenderTarget.GetSize()` that exercises it. One can also look at this by tweaking the Direct2dDemo project (i.e. call the method) which runs on .NET Core and sets up a render target that you can use.

As stated I'll try and get a smaller COM repro together for this.

</Description>
    <Title_Description>Unexpected results returning struct with floats in RCW In trying to wrap [`ID2D1RenderTarget::GetSize`](https://msdn.microsoft.com/en-us/library/windows/desktop/dd316823(v=vs.85).aspx) which returns [`D2D_SIZE_F`] the expected way it would corrupt the stack.

Flipping it to an out parameter made it work but I'm unclear as to why. Discussing with @davidwrighton there might be a bug here. I was unable to create the same scenario via straight `[DllImport]`s against a sample project. I'll see if I can get a smaller repro together.

In `d2d1.h` it is defined as:

``` C++
STDMETHOD_(D2D1_SIZE_F GetSize)(
    ) CONST PURE;
```

Which expands to:

``` C++
virtual __declspec(nothrow) D2D1_SIZE_F __stdcall GetSize() const = 0;
```

The struct is:

``` C++
typedef struct D2D_SIZE_F
{
    FLOAT width;
    FLOAT height;
} D2D_SIZE_F;
```

I wrapped this [here](https://github.com/JeremyKuhne/WInterop/blob/e41811b230bd332b9ead669542339e7d982d487a/src/WInterop.DirectX/Direct2d/IRenderTarget.cs#L436-L437) (`SizeF` is from System.Drawing):

``` C#
[PreserveSig]
void GetSize(out SizeF size);

// Doesn't Work:
// [PreserveSig]
// SizeF GetSize();
```

In the WInterop project I have a test `Direct2dTests.RenderTarget.GetSize()` that exercises it. One can also look at this by tweaking the Direct2dDemo project (i.e. call the method) which runs on .NET Core and sets up a render target that you can use.

As stated I'll try and get a smaller COM repro together for this.

</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>davidwrighton</Assignee>
    <CreatedAt>14/08/2018 12:27:01 AM +00:00</CreatedAt>
    <ClosedAt>29/03/2019 4:49:56 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19467</IssueLabelID>
    <Title>Use 64bit Upper/Lower casing in TextInfo</Title>
    <Description>Tracking issue for https://github.com/dotnet/coreclr/pull/19436#discussion_r209666239</Description>
    <Title_Description>Use 64bit Upper/Lower casing in TextInfo Tracking issue for https://github.com/dotnet/coreclr/pull/19436#discussion_r209666239</Title_Description>
    <Label>area-System.Runtime</Label>
    <Assignee>vancem</Assignee>
    <CreatedAt>13/08/2018 10:12:35 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19465</IssueLabelID>
    <Title>disable tests\src\JIT\Methodical\fp\exgen\10w5d_cs_do</Title>
    <Description>in stress modes. The issue is #18988</Description>
    <Title_Description>disable tests\src\JIT\Methodical\fp\exgen\10w5d_cs_do in stress modes. The issue is #18988</Title_Description>
    <Label>disabled-test</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>13/08/2018 10:00:33 PM +00:00</CreatedAt>
    <ClosedAt>13/08/2018 11:16:50 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19464</IssueLabelID>
    <Title>[Windows/arm64] GCStress=c assert: Consistency check failed</Title>
    <Description>Windows arm64 GCStress=c failure in b163200

In the CI I only saw it with JitStress=1 (https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm64/job/jitstress/job/arm64_cross_checked_windows_nt_gcstress0xc_jitstress1_tst/32/) because of other failures and the CI deleting logs quickly. But I can repro with just GCStress=c locally.

I had to set `_NT_SYMBOL_PATH=C:\brucefo\core_root\Windows_NT.arm64.Checked.2018-08-13` to get a good stack trace.

```
Running: C:\brucefo\tests\Windows_NT.arm.Checked.2018-07-13\JIT\Regression\CLR-x86-JIT\v2.1\DDB\b163200\b163200\b163200.cmd -coreroot C:\brucefo\core_root\Windows_NT.arm64.Checked.2018-08-13
     in: C:\brucefo\tests\Windows_NT.arm.Checked.2018-07-13\JIT\Regression\CLR-x86-JIT\v2.1\DDB\b163200\b163200\

Assert failure(PID 8700 [0x000021fc] Thread: 7028 [0x1b74]): Consistency check failed: AV in clr at this callstack:
------
CORECLR! WKS::gc_heap::mark_object_simple + 0x308 (0x00007fff`ec71e978)
CORECLR! WKS::GCHeap::Promote + 0x150 (0x00007fff`ec702ff0)
CORECLR! PinObject + 0xE4 (0x00007fff`ec765134)
CORECLR! ScanConsecutiveHandlesWithoutUserData + 0x80 (0x00007fff`ec77b230)
CORECLR! BlockScanBlocksWithoutUserData + 0x40 (0x00007fff`ec77aad0)
CORECLR! SegmentScanByTypeChain + 0xA8 (0x00007fff`ec77b2f8)
CORECLR! TableScanHandles + 0xBC (0x00007fff`ec77b64c)
CORECLR! HndScanHandlesForGC + 0x1A8 (0x00007fff`ec775bd0)
CORECLR! Ref_TracePinningRoots + 0x134 (0x00007fff`ec76714c)
CORECLR! GCScan::GcScanHandles + 0x90 (0x00007fff`ec779698)
CORECLR! WKS::gc_heap::mark_phase + 0x37C (0x00007fff`ec71ee9c)
CORECLR! WKS::gc_heap::gc1 + 0x234 (0x00007fff`ec716fac)
CORECLR! WKS::gc_heap::garbage_collect + 0x544 (0x00007fff`ec716d2c)
CORECLR! WKS::GCHeap::GarbageCollectGeneration + 0x3C0 (0x00007fff`ec701ce8)
CORECLR! WKS::GCHeap::GarbageCollect + 0x10C (0x00007fff`ec7018cc)
CORECLR! WKS::GCHeap::StressHeap + 0x6BC (0x00007fff`ec70489c)
CORECLR! ExternalMethodFixupWorker + 0x8A8 (0x00007fff`ec197458)
CORECLR! DelayLoad_MethodCall + 0x58 (0x00007fff`ebe31b04)
SYSTEM.PRIVATE.CORELIB! System.Globalization.TimeSpanFormat..cctor()$##600301A + 0x70 (0x00007fff`eb8fb760)
-----
.AV on tid=0x1b74 (7028) cxr=0000005F03779180 exr=0000005F03779510
FAILED: false

CORECLR! CHECK::Trigger + 0x2DC (0x00007fff`ebe528fc)
CORECLR! CLRVectoredExceptionHandlerPhase3 + 0x39C (0x00007fff`ebf246c4)
CORECLR! CLRVectoredExceptionHandlerPhase2 + 0x70 (0x00007fff`ebf240e8)
CORECLR! CLRVectoredExceptionHandler + 0x180 (0x00007fff`ebf24050)
CORECLR! CLRVectoredExceptionHandlerShim + 0x124 (0x00007fff`ebf248b4)
NTDLL! wcstok_s + 0x28F94 (0x00007ff8`1ca254d4)
NTDLL! RtlPcToFileHeader + 0x208 (0x00007ff8`1c9a9c28)
NTDLL! KiUserExceptionDispatcher + 0x24 (0x00007ff8`1c974bb4)
CORECLR! WKS::gc_heap::mark_object_simple + 0x308 (0x00007fff`ec71e978)
CORECLR! WKS::GCHeap::Promote + 0x150 (0x00007fff`ec702ff0)
    File: f:\gh\coreclr11\src\vm\excep.cpp Line: 7831
    Image: C:\brucefo\core_root\Windows_NT.arm64.Checked.2018-08-13\CoreRun.exe

FAILED
BEGIN EXECUTION
 "C:\brucefo\core_root\Windows_NT.arm64.Checked.2018-08-13\corerun.exe" b163200.exe
Expected: 100
Actual: 123456789
END EXECUTION - FAILED
FAILED
```
</Description>
    <Title_Description>[Windows/arm64] GCStress=c assert: Consistency check failed Windows arm64 GCStress=c failure in b163200

In the CI I only saw it with JitStress=1 (https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm64/job/jitstress/job/arm64_cross_checked_windows_nt_gcstress0xc_jitstress1_tst/32/) because of other failures and the CI deleting logs quickly. But I can repro with just GCStress=c locally.

I had to set `_NT_SYMBOL_PATH=C:\brucefo\core_root\Windows_NT.arm64.Checked.2018-08-13` to get a good stack trace.

```
Running: C:\brucefo\tests\Windows_NT.arm.Checked.2018-07-13\JIT\Regression\CLR-x86-JIT\v2.1\DDB\b163200\b163200\b163200.cmd -coreroot C:\brucefo\core_root\Windows_NT.arm64.Checked.2018-08-13
     in: C:\brucefo\tests\Windows_NT.arm.Checked.2018-07-13\JIT\Regression\CLR-x86-JIT\v2.1\DDB\b163200\b163200\

Assert failure(PID 8700 [0x000021fc] Thread: 7028 [0x1b74]): Consistency check failed: AV in clr at this callstack:
------
CORECLR! WKS::gc_heap::mark_object_simple + 0x308 (0x00007fff`ec71e978)
CORECLR! WKS::GCHeap::Promote + 0x150 (0x00007fff`ec702ff0)
CORECLR! PinObject + 0xE4 (0x00007fff`ec765134)
CORECLR! ScanConsecutiveHandlesWithoutUserData + 0x80 (0x00007fff`ec77b230)
CORECLR! BlockScanBlocksWithoutUserData + 0x40 (0x00007fff`ec77aad0)
CORECLR! SegmentScanByTypeChain + 0xA8 (0x00007fff`ec77b2f8)
CORECLR! TableScanHandles + 0xBC (0x00007fff`ec77b64c)
CORECLR! HndScanHandlesForGC + 0x1A8 (0x00007fff`ec775bd0)
CORECLR! Ref_TracePinningRoots + 0x134 (0x00007fff`ec76714c)
CORECLR! GCScan::GcScanHandles + 0x90 (0x00007fff`ec779698)
CORECLR! WKS::gc_heap::mark_phase + 0x37C (0x00007fff`ec71ee9c)
CORECLR! WKS::gc_heap::gc1 + 0x234 (0x00007fff`ec716fac)
CORECLR! WKS::gc_heap::garbage_collect + 0x544 (0x00007fff`ec716d2c)
CORECLR! WKS::GCHeap::GarbageCollectGeneration + 0x3C0 (0x00007fff`ec701ce8)
CORECLR! WKS::GCHeap::GarbageCollect + 0x10C (0x00007fff`ec7018cc)
CORECLR! WKS::GCHeap::StressHeap + 0x6BC (0x00007fff`ec70489c)
CORECLR! ExternalMethodFixupWorker + 0x8A8 (0x00007fff`ec197458)
CORECLR! DelayLoad_MethodCall + 0x58 (0x00007fff`ebe31b04)
SYSTEM.PRIVATE.CORELIB! System.Globalization.TimeSpanFormat..cctor()$##600301A + 0x70 (0x00007fff`eb8fb760)
-----
.AV on tid=0x1b74 (7028) cxr=0000005F03779180 exr=0000005F03779510
FAILED: false

CORECLR! CHECK::Trigger + 0x2DC (0x00007fff`ebe528fc)
CORECLR! CLRVectoredExceptionHandlerPhase3 + 0x39C (0x00007fff`ebf246c4)
CORECLR! CLRVectoredExceptionHandlerPhase2 + 0x70 (0x00007fff`ebf240e8)
CORECLR! CLRVectoredExceptionHandler + 0x180 (0x00007fff`ebf24050)
CORECLR! CLRVectoredExceptionHandlerShim + 0x124 (0x00007fff`ebf248b4)
NTDLL! wcstok_s + 0x28F94 (0x00007ff8`1ca254d4)
NTDLL! RtlPcToFileHeader + 0x208 (0x00007ff8`1c9a9c28)
NTDLL! KiUserExceptionDispatcher + 0x24 (0x00007ff8`1c974bb4)
CORECLR! WKS::gc_heap::mark_object_simple + 0x308 (0x00007fff`ec71e978)
CORECLR! WKS::GCHeap::Promote + 0x150 (0x00007fff`ec702ff0)
    File: f:\gh\coreclr11\src\vm\excep.cpp Line: 7831
    Image: C:\brucefo\core_root\Windows_NT.arm64.Checked.2018-08-13\CoreRun.exe

FAILED
BEGIN EXECUTION
 "C:\brucefo\core_root\Windows_NT.arm64.Checked.2018-08-13\corerun.exe" b163200.exe
Expected: 100
Actual: 123456789
END EXECUTION - FAILED
FAILED
```
</Title_Description>
    <Label>GCStress</Label>
    <Assignee>AndyAyersMS</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19462</IssueLabelID>
    <Title>[Windows/arm32] Failures in HeapVerify job</Title>
    <Description>https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_heapverify1_flow/

```
Tests.lst=servermodel.cmd_5535   Smrt00000001  # GC\Scenarios\ServerModel\servermodel\servermodel.cmd  CATS: EXPECTED_PASS
Tests.lst=494226.cmd_9689   Smrt00000001  # GC\Regressions\v2.0-rtm\494226\494226\494226.cmd  CATS: EXPECTED_PASS
Tests.lst=GetAllocatedBytesForCurrentThread.cmd_11542   Smrt00000001  # GC\API\GC\GetAllocatedBytesForCurrentThread\GetAllocatedBytesForCurrentThread.cmd  CATS: EXPECTED_PASS;NEW
```

Failures are all timeouts (&gt;600s)
</Description>
    <Title_Description>[Windows/arm32] Failures in HeapVerify job https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_heapverify1_flow/

```
Tests.lst=servermodel.cmd_5535   Smrt00000001  # GC\Scenarios\ServerModel\servermodel\servermodel.cmd  CATS: EXPECTED_PASS
Tests.lst=494226.cmd_9689   Smrt00000001  # GC\Regressions\v2.0-rtm\494226\494226\494226.cmd  CATS: EXPECTED_PASS
Tests.lst=GetAllocatedBytesForCurrentThread.cmd_11542   Smrt00000001  # GC\API\GC\GetAllocatedBytesForCurrentThread\GetAllocatedBytesForCurrentThread.cmd  CATS: EXPECTED_PASS;NEW
```

Failures are all timeouts (&gt;600s)
</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>13/08/2018 9:05:44 PM +00:00</CreatedAt>
    <ClosedAt>13/08/2018 11:53:23 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19460</IssueLabelID>
    <Title>[Windows/arm32] corefx TieredCompilation failure in System.Threading.Threads.Tests</Title>
    <Description>https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_corefx_tieredcompilation_flow/

```
System.Threading.Threads.Tests.ThreadTests.ApartmentState_NoAttributePresent_DefaultState_Windows [FAIL]
09:30:48       System.Diagnostics.RemoteExecutorTestBase+RemoteInvokeHandle+RemoteExecutionException : Remote process failed with an unhandled exception.
09:30:48       Stack Trace:
09:30:49          
09:30:49          Child exception:
09:30:49            Xunit.Sdk.ThrowsException: Assert.Throws() Failure
09:30:49          Expected: typeof(System.InvalidOperationException)
09:30:49          Actual:   (No exception was thrown)
09:30:49          D:\j\workspace\arm_cross_che---01d3a54f\_\fx\src\System.Threading.Thread\tests\ThreadTests.cs(1920): at System.Threading.Threads.Tests.ThreadTests.&lt;&gt;c.&lt;ApartmentState_NoAttributePresent_DefaultState_Windows&gt;b__5_0()
09:30:49          
09:30:49          Child process:
09:30:49            System.Threading.Thread.Tests Version=4.1.1.0 Culture=neutral PublicKeyToken=9d77cc7ad39b68eb System.Threading.Threads.Tests.ThreadTests+&lt;&gt;c Void &lt;ApartmentState_NoAttributePresent_DefaultState_Windows&gt;b__5_0()
```

@kouvel @noahfalk </Description>
    <Title_Description>[Windows/arm32] corefx TieredCompilation failure in System.Threading.Threads.Tests https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_corefx_tieredcompilation_flow/

```
System.Threading.Threads.Tests.ThreadTests.ApartmentState_NoAttributePresent_DefaultState_Windows [FAIL]
09:30:48       System.Diagnostics.RemoteExecutorTestBase+RemoteInvokeHandle+RemoteExecutionException : Remote process failed with an unhandled exception.
09:30:48       Stack Trace:
09:30:49          
09:30:49          Child exception:
09:30:49            Xunit.Sdk.ThrowsException: Assert.Throws() Failure
09:30:49          Expected: typeof(System.InvalidOperationException)
09:30:49          Actual:   (No exception was thrown)
09:30:49          D:\j\workspace\arm_cross_che---01d3a54f\_\fx\src\System.Threading.Thread\tests\ThreadTests.cs(1920): at System.Threading.Threads.Tests.ThreadTests.&lt;&gt;c.&lt;ApartmentState_NoAttributePresent_DefaultState_Windows&gt;b__5_0()
09:30:49          
09:30:49          Child process:
09:30:49            System.Threading.Thread.Tests Version=4.1.1.0 Culture=neutral PublicKeyToken=9d77cc7ad39b68eb System.Threading.Threads.Tests.ThreadTests+&lt;&gt;c Void &lt;ApartmentState_NoAttributePresent_DefaultState_Windows&gt;b__5_0()
```

@kouvel @noahfalk </Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>13/08/2018 8:02:35 PM +00:00</CreatedAt>
    <ClosedAt>13/08/2018 8:15:43 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19457</IssueLabelID>
    <Title>[Windows/arm32] corefx System.Linq.Expressions.Tests failures</Title>
    <Description>https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_corefx_jitstress1_tst/30/consoleFull

```
20:06:07    System.Linq.Expressions.Tests.ConvertCheckedTests.ConvertCheckedNullableDecimalToDoubleTest(useInterpreter: False) [FAIL]
20:06:07       Assert.Equal() Failure
20:06:07       Expected: -7.92281624958176E+28
20:06:07       Actual:   -7.92281625142643E+28
20:06:07       Stack Trace:
20:06:08          D:\j\workspace\arm_cross_che---9e928575\_\fx\src\System.Linq.Expressions\tests\Convert\ConvertCheckedTests.cs(89100): at System.Linq.Expressions.Tests.ConvertCheckedTests.VerifyCheckedNullableDecimalToDouble(Nullable`1 value Boolean useInterpreter)
20:06:08          D:\j\workspace\arm_cross_che---9e928575\_\fx\src\System.Linq.Expressions\tests\Convert\ConvertCheckedTests.cs(12970): at System.Linq.Expressions.Tests.ConvertCheckedTests.ConvertCheckedNullableDecimalToDoubleTest(Boolean useInterpreter)
20:06:08    System.Linq.Expressions.Tests.ConvertCheckedTests.ConvertCheckedNullableDecimalToDoubleTest(useInterpreter: True) [FAIL]
20:06:08       Assert.Equal() Failure
20:06:08       Expected: -7.92281624958176E+28
20:06:08       Actual:   -7.92281625142643E+28
20:06:08       Stack Trace:
20:06:08          D:\j\workspace\arm_cross_che---9e928575\_\fx\src\System.Linq.Expressions\tests\Convert\ConvertCheckedTests.cs(89100): at System.Linq.Expressions.Tests.ConvertCheckedTests.VerifyCheckedNullableDecimalToDouble(Nullable`1 value Boolean useInterpreter)
20:06:08          D:\j\workspace\arm_cross_che---9e928575\_\fx\src\System.Linq.Expressions\tests\Convert\ConvertCheckedTests.cs(12970): at System.Linq.Expressions.Tests.ConvertCheckedTests.ConvertCheckedNullableDecimalToDoubleTest(Boolean useInterpreter)
20:06:08    System.Linq.Expressions.Tests.ConvertTests.ConvertNullableDecimalToFloatTest(useInterpreter: False) [FAIL]
20:06:08       Assert.Equal() Failure
20:06:08       Expected: 4.502148E+18
20:06:08       Actual:   0
20:06:08       Stack Trace:
20:06:08             at System.Linq.Expressions.Tests.ConvertTests.VerifyNullableDecimalToFloat(Nullable`1 value Boolean useInterpreter)
20:06:08          D:\j\workspace\arm_cross_che---9e928575\_\fx\src\System.Linq.Expressions\tests\Convert\ConvertTests.cs(13160): at System.Linq.Expressions.Tests.ConvertTests.ConvertNullableDecimalToFloatTest(Boolean useInterpreter)
20:06:08    System.Linq.Expressions.Tests.ConvertTests.ConvertNullableDecimalToFloatTest(useInterpreter: True) [FAIL]
20:06:08       Assert.Equal() Failure
20:06:08       Expected: 1.47574E+19
20:06:08       Actual:   0
```
</Description>
    <Title_Description>[Windows/arm32] corefx System.Linq.Expressions.Tests failures https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_corefx_jitstress1_tst/30/consoleFull

```
20:06:07    System.Linq.Expressions.Tests.ConvertCheckedTests.ConvertCheckedNullableDecimalToDoubleTest(useInterpreter: False) [FAIL]
20:06:07       Assert.Equal() Failure
20:06:07       Expected: -7.92281624958176E+28
20:06:07       Actual:   -7.92281625142643E+28
20:06:07       Stack Trace:
20:06:08          D:\j\workspace\arm_cross_che---9e928575\_\fx\src\System.Linq.Expressions\tests\Convert\ConvertCheckedTests.cs(89100): at System.Linq.Expressions.Tests.ConvertCheckedTests.VerifyCheckedNullableDecimalToDouble(Nullable`1 value Boolean useInterpreter)
20:06:08          D:\j\workspace\arm_cross_che---9e928575\_\fx\src\System.Linq.Expressions\tests\Convert\ConvertCheckedTests.cs(12970): at System.Linq.Expressions.Tests.ConvertCheckedTests.ConvertCheckedNullableDecimalToDoubleTest(Boolean useInterpreter)
20:06:08    System.Linq.Expressions.Tests.ConvertCheckedTests.ConvertCheckedNullableDecimalToDoubleTest(useInterpreter: True) [FAIL]
20:06:08       Assert.Equal() Failure
20:06:08       Expected: -7.92281624958176E+28
20:06:08       Actual:   -7.92281625142643E+28
20:06:08       Stack Trace:
20:06:08          D:\j\workspace\arm_cross_che---9e928575\_\fx\src\System.Linq.Expressions\tests\Convert\ConvertCheckedTests.cs(89100): at System.Linq.Expressions.Tests.ConvertCheckedTests.VerifyCheckedNullableDecimalToDouble(Nullable`1 value Boolean useInterpreter)
20:06:08          D:\j\workspace\arm_cross_che---9e928575\_\fx\src\System.Linq.Expressions\tests\Convert\ConvertCheckedTests.cs(12970): at System.Linq.Expressions.Tests.ConvertCheckedTests.ConvertCheckedNullableDecimalToDoubleTest(Boolean useInterpreter)
20:06:08    System.Linq.Expressions.Tests.ConvertTests.ConvertNullableDecimalToFloatTest(useInterpreter: False) [FAIL]
20:06:08       Assert.Equal() Failure
20:06:08       Expected: 4.502148E+18
20:06:08       Actual:   0
20:06:08       Stack Trace:
20:06:08             at System.Linq.Expressions.Tests.ConvertTests.VerifyNullableDecimalToFloat(Nullable`1 value Boolean useInterpreter)
20:06:08          D:\j\workspace\arm_cross_che---9e928575\_\fx\src\System.Linq.Expressions\tests\Convert\ConvertTests.cs(13160): at System.Linq.Expressions.Tests.ConvertTests.ConvertNullableDecimalToFloatTest(Boolean useInterpreter)
20:06:08    System.Linq.Expressions.Tests.ConvertTests.ConvertNullableDecimalToFloatTest(useInterpreter: True) [FAIL]
20:06:08       Assert.Equal() Failure
20:06:08       Expected: 1.47574E+19
20:06:08       Actual:   0
```
</Title_Description>
    <Label>JitStress</Label>
    <Assignee>sandreenko</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19455</IssueLabelID>
    <Title>[dev/unix_test_workflow][NO MERGE] Dummy change</Title>
    <Description>
    </Description>
    <Title_Description>[dev/unix_test_workflow][NO MERGE] Dummy change </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>echesakovMSFT</Assignee>
    <CreatedAt>13/08/2018 6:26:08 PM +00:00</CreatedAt>
    <ClosedAt>17/08/2018 4:58:17 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19454</IssueLabelID>
    <Title>System.AccessViolationException with Span</Title>
    <Description>Following code crashes with System.AccessViolationException when compiled in Release mode with "Optimize code". I tried that on Windows 64bit with .NET Core 2.1.302. Older version of .NET Core and Debug does not cause this exception.

Note that this code alone does not make any sense. It was isolated from larger code base. It might be an issue with JIT since the code in for cycle does not even execute it is called with 0.
```
using System;

namespace AccessViolationExceptionTest
{
    class Program
    {
        static void Main()
        {
		MyReader r = new MyReader();
		r.ReadBytesInner(0);
	        Console.WriteLine("Everything OK");
        }
    }

	public struct MyStruct
	{
		public Span&lt;byte&gt; Span1
		{
			get { return Span&lt;byte&gt;.Empty; }
		}
	}

	public struct MyReader
	{
		public void ReadBytesInner(int batch)
		{
			MyStruct value = new MyStruct();
			for (int i = 0; i &lt; batch; i++)
			{
				value.Span1[i] = 0;
			}
		}
	}
}
```</Description>
    <Title_Description>System.AccessViolationException with Span Following code crashes with System.AccessViolationException when compiled in Release mode with "Optimize code". I tried that on Windows 64bit with .NET Core 2.1.302. Older version of .NET Core and Debug does not cause this exception.

Note that this code alone does not make any sense. It was isolated from larger code base. It might be an issue with JIT since the code in for cycle does not even execute it is called with 0.
```
using System;

namespace AccessViolationExceptionTest
{
    class Program
    {
        static void Main()
        {
		MyReader r = new MyReader();
		r.ReadBytesInner(0);
	        Console.WriteLine("Everything OK");
        }
    }

	public struct MyStruct
	{
		public Span&lt;byte&gt; Span1
		{
			get { return Span&lt;byte&gt;.Empty; }
		}
	}

	public struct MyReader
	{
		public void ReadBytesInner(int batch)
		{
			MyStruct value = new MyStruct();
			for (int i = 0; i &lt; batch; i++)
			{
				value.Span1[i] = 0;
			}
		}
	}
}
```</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19453</IssueLabelID>
    <Title>[NO MERGE] Dummy PR</Title>
    <Description>**NO MERGE** **NO MERGE** **NO MERGE** </Description>
    <Title_Description>[NO MERGE] Dummy PR **NO MERGE** **NO MERGE** **NO MERGE** </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>echesakovMSFT</Assignee>
    <CreatedAt>13/08/2018 6:22:03 PM +00:00</CreatedAt>
    <ClosedAt>13/08/2018 8:49:57 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19451</IssueLabelID>
    <Title>[release/2.1] Sign api-ms-win-core-xstate-l2-1-0.dll</Title>
    <Description>This file is only catalog signed in RS4.  Sign during the build. To achieve this copy the CRT binaries locally rather than referencing from the UCRT location directly.</Description>
    <Title_Description>[release/2.1] Sign api-ms-win-core-xstate-l2-1-0.dll This file is only catalog signed in RS4.  Sign during the build. To achieve this copy the CRT binaries locally rather than referencing from the UCRT location directly.</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>mmitche</Assignee>
    <CreatedAt>13/08/2018 6:19:16 PM +00:00</CreatedAt>
    <ClosedAt>13/08/2018 8:58:43 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19450</IssueLabelID>
    <Title>Japanese Lunisolar Calendar conversion table discrepancy for the year 1962</Title>
    <Description>The [Japanese Lunisolar Calendar](https://github.com/dotnet/coreclr/blob/master/src/System.Private.CoreLib/shared/System/Globalization/JapaneseLunisolarCalendar.cs) uses a table of data for conversion between Japanese lunisolar dates and Gregorian dates.  There appears* to be a discrepancy for the table entry for the _days in months_ for lunar months 6 and 7 of the lunar year which started in the Gregorian year 1962 when compared with two other sources.  These are:
- output from Calendrical Calculations (4th edition section 19.9) which provides algorithms for accurate dates for the period 1860 to at least 2100
- [Rekijitsu taikan : Meiji kaireki 1873-nen--2100-nen shinkyūreki kanshi kyūsei rokuyō taishō](http://www.worldcat.org/title/rekijitsu-taikan/oclc/675252389?referer=di&amp;ht=edition ()) which provides accurate tables of dates in this calendar over the period years 1873 to 2100 (with the exception of 1947)

*there isn't a source given for the existing table data - is it still known / available for cross check?

**Comparison of table data**

Days in month for 1962  | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13
-- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | --
.NET | 29 | 30 | 29 | 29 | 30 | **30** | **29** | 30 | 29 | 30 | 30 | 29 | 0
Calendrical Calculations / Rekijitsu taikan | 29 | 30 | 29 | 29 | 30 | **29** | **30** | 30 | 29 | 30 | 30 | 29 | 0

Assuming the output of Calendrical Calculations algorithms is correct then the current table entry for 1962:
`1962    */{    0        2        5         19808    }/*    29    30    29    29    30    30    29    30    29    30    30    29    0    354`
should be changed to
`1962    */{    0        2        5         19296    }/*    29    30    29    29    30    29    30    30    29    30    30    29    0    354`

At the same time it would also be a _trivial_ matter to extend the table to support dates for all the Japanese calendar eras currently supported by .NET (Meiji Taisho Showa and Heisei).  Given the recent updates to the Japanese and Japanese Lunisolar calendars relating to the new Japanese calendar era this might be an appropriate time to do that.

I would be happy to submit PR to address these.

</Description>
    <Title_Description>Japanese Lunisolar Calendar conversion table discrepancy for the year 1962 The [Japanese Lunisolar Calendar](https://github.com/dotnet/coreclr/blob/master/src/System.Private.CoreLib/shared/System/Globalization/JapaneseLunisolarCalendar.cs) uses a table of data for conversion between Japanese lunisolar dates and Gregorian dates.  There appears* to be a discrepancy for the table entry for the _days in months_ for lunar months 6 and 7 of the lunar year which started in the Gregorian year 1962 when compared with two other sources.  These are:
- output from Calendrical Calculations (4th edition section 19.9) which provides algorithms for accurate dates for the period 1860 to at least 2100
- [Rekijitsu taikan : Meiji kaireki 1873-nen--2100-nen shinkyūreki kanshi kyūsei rokuyō taishō](http://www.worldcat.org/title/rekijitsu-taikan/oclc/675252389?referer=di&amp;ht=edition ()) which provides accurate tables of dates in this calendar over the period years 1873 to 2100 (with the exception of 1947)

*there isn't a source given for the existing table data - is it still known / available for cross check?

**Comparison of table data**

Days in month for 1962  | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13
-- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | --
.NET | 29 | 30 | 29 | 29 | 30 | **30** | **29** | 30 | 29 | 30 | 30 | 29 | 0
Calendrical Calculations / Rekijitsu taikan | 29 | 30 | 29 | 29 | 30 | **29** | **30** | 30 | 29 | 30 | 30 | 29 | 0

Assuming the output of Calendrical Calculations algorithms is correct then the current table entry for 1962:
`1962    */{    0        2        5         19808    }/*    29    30    29    29    30    30    29    30    29    30    30    29    0    354`
should be changed to
`1962    */{    0        2        5         19296    }/*    29    30    29    29    30    29    30    30    29    30    30    29    0    354`

At the same time it would also be a _trivial_ matter to extend the table to support dates for all the Japanese calendar eras currently supported by .NET (Meiji Taisho Showa and Heisei).  Given the recent updates to the Japanese and Japanese Lunisolar calendars relating to the new Japanese calendar era this might be an appropriate time to do that.

I would be happy to submit PR to address these.

</Title_Description>
    <Label>area-System.Globalization</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>13/08/2018 5:47:23 PM +00:00</CreatedAt>
    <ClosedAt>16/08/2018 1:28:14 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19448</IssueLabelID>
    <Title>[Ubuntu/arm32] JitStressRegs=8 CoreFX test failures</Title>
    <Description>https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstressregs8_tst/17/consoleFull

Many or every test fails with:
```
21:08:53 Unhandled Exception: System.NotSupportedException: Stream does not support seeking.
21:08:53    at System.IO.FileStream.get_Length()
21:08:53    at Internal.IO.File.ReadAllBytes(String path)
21:08:53    at System.TimeZoneInfo.TryLoadTzFile(String tzFilePath Byte[]&amp; rawData String&amp; id)
21:08:53    at System.TimeZoneInfo.TryGetLocalTzFile(Byte[]&amp; rawData String&amp; id)
21:08:53    at System.TimeZoneInfo.GetLocalTimeZoneFromTzFile()
21:08:53    at System.TimeZoneInfo.GetLocalTimeZone(CachedData cachedData)
21:08:53    at System.TimeZoneInfo.CachedData.CreateLocal()
21:08:53    at System.DateTime.get_Now()
21:08:53    at Xunit.Sdk.TestAssemblyRunner`1.RunAsync()
21:08:53    at Xunit.Sdk.XunitTestFrameworkExecutor.RunTestCases(IEnumerable`1 testCases IMessageSink executionMessageSink ITestFrameworkExecutionOptions executionOptions)
21:08:53    at System.Runtime.CompilerServices.AsyncMethodBuilderCore.&lt;&gt;c.&lt;ThrowAsync&gt;b__7_1(Object state)
21:08:53    at System.Threading.QueueUserWorkItemCallbackDefaultContext.&lt;&gt;c.&lt;.cctor&gt;b__5_0(Object state)
21:08:53    at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext ContextCallback callback Object state)
21:08:53 --- End of stack trace from previous location where exception was thrown ---
21:08:53    at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext ContextCallback callback Object state)
21:08:53    at System.Threading.QueueUserWorkItemCallbackDefaultContext.ExecuteWorkItem()
21:08:53    at System.Threading.ThreadPoolWorkQueue.Dispatch()
21:08:53    at System.Threading._ThreadPoolWaitCallback.PerformWaitCallback()
21:08:53 ./RunTests.sh: line 128: 32432 Aborted                 $RUNTIME_PATH/dotnet xunit.console.netcore.exe XsltCompiler.Tests.dll -xml testResults.xml -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonlinuxtests -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing
```

Related to https://github.com/dotnet/coreclr/issues/19029?

Even if fixed the job will probably fail with https://github.com/dotnet/coreclr/issues/19447.

@dotnet/arm32-contrib @CarolEidt </Description>
    <Title_Description>[Ubuntu/arm32] JitStressRegs=8 CoreFX test failures https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstressregs8_tst/17/consoleFull

Many or every test fails with:
```
21:08:53 Unhandled Exception: System.NotSupportedException: Stream does not support seeking.
21:08:53    at System.IO.FileStream.get_Length()
21:08:53    at Internal.IO.File.ReadAllBytes(String path)
21:08:53    at System.TimeZoneInfo.TryLoadTzFile(String tzFilePath Byte[]&amp; rawData String&amp; id)
21:08:53    at System.TimeZoneInfo.TryGetLocalTzFile(Byte[]&amp; rawData String&amp; id)
21:08:53    at System.TimeZoneInfo.GetLocalTimeZoneFromTzFile()
21:08:53    at System.TimeZoneInfo.GetLocalTimeZone(CachedData cachedData)
21:08:53    at System.TimeZoneInfo.CachedData.CreateLocal()
21:08:53    at System.DateTime.get_Now()
21:08:53    at Xunit.Sdk.TestAssemblyRunner`1.RunAsync()
21:08:53    at Xunit.Sdk.XunitTestFrameworkExecutor.RunTestCases(IEnumerable`1 testCases IMessageSink executionMessageSink ITestFrameworkExecutionOptions executionOptions)
21:08:53    at System.Runtime.CompilerServices.AsyncMethodBuilderCore.&lt;&gt;c.&lt;ThrowAsync&gt;b__7_1(Object state)
21:08:53    at System.Threading.QueueUserWorkItemCallbackDefaultContext.&lt;&gt;c.&lt;.cctor&gt;b__5_0(Object state)
21:08:53    at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext ContextCallback callback Object state)
21:08:53 --- End of stack trace from previous location where exception was thrown ---
21:08:53    at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext ContextCallback callback Object state)
21:08:53    at System.Threading.QueueUserWorkItemCallbackDefaultContext.ExecuteWorkItem()
21:08:53    at System.Threading.ThreadPoolWorkQueue.Dispatch()
21:08:53    at System.Threading._ThreadPoolWaitCallback.PerformWaitCallback()
21:08:53 ./RunTests.sh: line 128: 32432 Aborted                 $RUNTIME_PATH/dotnet xunit.console.netcore.exe XsltCompiler.Tests.dll -xml testResults.xml -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonlinuxtests -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing
```

Related to https://github.com/dotnet/coreclr/issues/19029?

Even if fixed the job will probably fail with https://github.com/dotnet/coreclr/issues/19447.

@dotnet/arm32-contrib @CarolEidt </Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19447</IssueLabelID>
    <Title>Ubuntu/arm32 corefx test infrastructure failures: "The plugin hasn't been performed correctly"</Title>
    <Description>All the Ubuntu/arm32 corefx tests are failing -- after all the tests actually pass -- with an infrastructure failure message e.g.:

https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_baseline_tst/17/consoleFull

```
00:14:27 All tests passed.
00:14:29 [Current build status] check if current [SUCCESS] is worse or equals then [SUCCESS] and better or equals then [SUCCESS]
00:14:29 Run condition [Current build status] enabling perform for step [[Archive the artifacts]]
00:14:29 Archiving artifacts
00:14:41 [xUnit] [INFO] - Starting to record.
00:14:41 [xUnit] [INFO] - Processing xUnit.Net-v2 (default)
00:14:42 [xUnit] [INFO] - [xUnit.Net-v2 (default)] - 230 test report file(s) were found with the pattern '_/fx/bin/**/testResults.xml' relative to '/ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_baseline_tst' for the testing framework 'xUnit.Net-v2 (default)'.
00:16:09 
[xUnit] [ERROR] - The plugin hasn't been performed correctly: remote file operation failed: /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_baseline_tst at hudson.remoting.Channel@3697f46d:JNLP4-connect connection from 131.107.159.149/131.107.159.149:58529: java.io.IOException: Remote call on JNLP4-connect connection from 131.107.159.149/131.107.159.149:58529 failed
00:16:09 Build step 'Publish xUnit test result report' changed build result to FAILURE
```

Others:

https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstress1_tst/22/consoleFull
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstress2_tst/22/consoleFull
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstressregs0x1000_tst/19/consoleFull
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_tst/20/consoleFull
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstressregs0x80_tst/20/consoleFull
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstressregs1_tst/19/consoleFull
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstressregs2_tst/18/consoleFull
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstressregs3_tst/19/consoleFull
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstressregs4_tst/18/consoleFull
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_minopts_tst/21/consoleFull
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_tieredcompilation_tst/7/consoleFull

@dotnet/arm32-contrib @jashook @mmitche </Description>
    <Title_Description>Ubuntu/arm32 corefx test infrastructure failures: "The plugin hasn't been performed correctly" All the Ubuntu/arm32 corefx tests are failing -- after all the tests actually pass -- with an infrastructure failure message e.g.:

https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_baseline_tst/17/consoleFull

```
00:14:27 All tests passed.
00:14:29 [Current build status] check if current [SUCCESS] is worse or equals then [SUCCESS] and better or equals then [SUCCESS]
00:14:29 Run condition [Current build status] enabling perform for step [[Archive the artifacts]]
00:14:29 Archiving artifacts
00:14:41 [xUnit] [INFO] - Starting to record.
00:14:41 [xUnit] [INFO] - Processing xUnit.Net-v2 (default)
00:14:42 [xUnit] [INFO] - [xUnit.Net-v2 (default)] - 230 test report file(s) were found with the pattern '_/fx/bin/**/testResults.xml' relative to '/ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_baseline_tst' for the testing framework 'xUnit.Net-v2 (default)'.
00:16:09 
[xUnit] [ERROR] - The plugin hasn't been performed correctly: remote file operation failed: /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_baseline_tst at hudson.remoting.Channel@3697f46d:JNLP4-connect connection from 131.107.159.149/131.107.159.149:58529: java.io.IOException: Remote call on JNLP4-connect connection from 131.107.159.149/131.107.159.149:58529 failed
00:16:09 Build step 'Publish xUnit test result report' changed build result to FAILURE
```

Others:

https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstress1_tst/22/consoleFull
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstress2_tst/22/consoleFull
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstressregs0x1000_tst/19/consoleFull
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_tst/20/consoleFull
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstressregs0x80_tst/20/consoleFull
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstressregs1_tst/19/consoleFull
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstressregs2_tst/18/consoleFull
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstressregs3_tst/19/consoleFull
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstressregs4_tst/18/consoleFull
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_minopts_tst/21/consoleFull
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_tieredcompilation_tst/7/consoleFull

@dotnet/arm32-contrib @jashook @mmitche </Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>13/08/2018 4:36:00 PM +00:00</CreatedAt>
    <ClosedAt>17/08/2018 10:22:19 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19444</IssueLabelID>
    <Title>RyuJIT: By-ref assignment with null leads to runtime crash</Title>
    <Description>The following example crashes the runtime when compiled and run in either debug or release:
```csharp
class C0
{
}

struct S0
{
    public C0 F0;
    public ulong F4;
}

class C1
{
    public S0 F3;
}

struct S1
{
    public S0 F3;
}

public class Program
{
    static S1 s_38;
    static C1 s_43;

    public static void Main()
    {
        s_38.F3 = s_43.F3;
    }
}
```

In debug (and probably checked) builds this assertion triggers:
```
Assert failure(PID 20848 [0x00005170] Thread: 17420 [0x440c]): Consistency check failed: AV in clr at this callstack:
------
CORECLR! JIT_ByRefWriteBarrier + 0x0 (0x00007ffc`5e207d70)
&lt;no module&gt;! &lt;no symbol&gt; + 0x0 (0x00007ffb`fef22611)
&lt;no module&gt;! &lt;no symbol&gt; + 0x0 (0x00007ffb`fee045e0)
&lt;no module&gt;! &lt;no symbol&gt; + 0x0 (0x000000fa`00000005)
&lt;no module&gt;! &lt;no symbol&gt; + 0x0 (0x000000fa`2077d580)
-----
.AV on tid=0x440c (17420) cxr=000000FA2077CE00 exr=000000FA2077D2F0
FAILED: false

CORECLR! CHECK::Trigger + 0x275 (0x00007ffc`5db0cea5)
CORECLR! CLRVectoredExceptionHandlerPhase3 + 0x332 (0x00007ffc`5dc1bd62)
CORECLR! CLRVectoredExceptionHandlerPhase2 + 0x8C (0x00007ffc`5dc1b70c)
CORECLR! CLRVectoredExceptionHandler + 0x275 (0x00007ffc`5dc1b665)
CORECLR! CLRVectoredExceptionHandlerShim + 0x18D (0x00007ffc`5dc1c04d)
NTDLL! RtlInitializeCriticalSection + 0x1D8 (0x00007ffc`c5bd5678)
NTDLL! RtlWalkFrameChain + 0x109A (0x00007ffc`c5b7692a)
NTDLL! KiUserExceptionDispatcher + 0x2E (0x00007ffc`c5c0dc1e)
CORECLR! JIT_ByRefWriteBarrier + 0x0 (0x00007ffc`5e207d70)
&lt;no module&gt;! &lt;no symbol&gt; + 0x0 (0x00007ffb`fef22611)
    File: z:\programming\dotnet\coreclr\src\vm\excep.cpp Line: 7831
    Image: Z:\Programming\dotnet\coreclr\bin\Product\Windows_NT.x64.Debug\CoreRun.exe
```

The code generated is:
```asm
; Assembly listing for method Program:Main()
; Emitting BLENDED_CODE for X64 CPU with AVX
; optimized code
; rsp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 OutArgs      [V00    ] (  1  1   )  lclBlk (32) [rsp+0x00]
;  V01 cse0         [V01T00] (  5  5   )    long  -&gt;  [rsp+0x20]
;
; Lcl frame size = 40

G_M5092_IG01:
       57                   push     rdi
       56                   push     rsi
       4883EC28             sub      rsp 40

G_M5092_IG02:
       48B9E045E3FEFB7F0000 mov      rcx 0x7FFBFEE345E0
       BA05000000           mov      edx 5
       E8461E455F           call     CORINFO_HELP_GETSHARED_NONGCSTATIC_BASE
       48B87829001091010000 mov      rax 0x19110002978
       488B00               mov      rax gword ptr [rax]
       488D7008             lea      rsi bword ptr [rax+8]
       48B87029001091010000 mov      rax 0x19110002970
       488B00               mov      rax gword ptr [rax]
       488D7808             lea      rdi bword ptr [rax+8]
       E85F572B5F           call     CORINFO_HELP_ASSIGN_BYREF
       48A5                 movsq

G_M5092_IG03:
       4883C428             add      rsp 40
       5E                   pop      rsi
       5F                   pop      rdi
       C3                   ret

; Total bytes of code 74 prolog size 6 for method Program:Main()
;
```

Question: How will this normally be handled by CoreCLR? Should the runtime turn the AV in `CORINFO_HELP_ASSIGN_BYREF` into a managed NRE or is the caller supposed to null-check/deref the reference before calling `CORINFO_HELP_ASSIGN_BYREF`?</Description>
    <Title_Description>RyuJIT: By-ref assignment with null leads to runtime crash The following example crashes the runtime when compiled and run in either debug or release:
```csharp
class C0
{
}

struct S0
{
    public C0 F0;
    public ulong F4;
}

class C1
{
    public S0 F3;
}

struct S1
{
    public S0 F3;
}

public class Program
{
    static S1 s_38;
    static C1 s_43;

    public static void Main()
    {
        s_38.F3 = s_43.F3;
    }
}
```

In debug (and probably checked) builds this assertion triggers:
```
Assert failure(PID 20848 [0x00005170] Thread: 17420 [0x440c]): Consistency check failed: AV in clr at this callstack:
------
CORECLR! JIT_ByRefWriteBarrier + 0x0 (0x00007ffc`5e207d70)
&lt;no module&gt;! &lt;no symbol&gt; + 0x0 (0x00007ffb`fef22611)
&lt;no module&gt;! &lt;no symbol&gt; + 0x0 (0x00007ffb`fee045e0)
&lt;no module&gt;! &lt;no symbol&gt; + 0x0 (0x000000fa`00000005)
&lt;no module&gt;! &lt;no symbol&gt; + 0x0 (0x000000fa`2077d580)
-----
.AV on tid=0x440c (17420) cxr=000000FA2077CE00 exr=000000FA2077D2F0
FAILED: false

CORECLR! CHECK::Trigger + 0x275 (0x00007ffc`5db0cea5)
CORECLR! CLRVectoredExceptionHandlerPhase3 + 0x332 (0x00007ffc`5dc1bd62)
CORECLR! CLRVectoredExceptionHandlerPhase2 + 0x8C (0x00007ffc`5dc1b70c)
CORECLR! CLRVectoredExceptionHandler + 0x275 (0x00007ffc`5dc1b665)
CORECLR! CLRVectoredExceptionHandlerShim + 0x18D (0x00007ffc`5dc1c04d)
NTDLL! RtlInitializeCriticalSection + 0x1D8 (0x00007ffc`c5bd5678)
NTDLL! RtlWalkFrameChain + 0x109A (0x00007ffc`c5b7692a)
NTDLL! KiUserExceptionDispatcher + 0x2E (0x00007ffc`c5c0dc1e)
CORECLR! JIT_ByRefWriteBarrier + 0x0 (0x00007ffc`5e207d70)
&lt;no module&gt;! &lt;no symbol&gt; + 0x0 (0x00007ffb`fef22611)
    File: z:\programming\dotnet\coreclr\src\vm\excep.cpp Line: 7831
    Image: Z:\Programming\dotnet\coreclr\bin\Product\Windows_NT.x64.Debug\CoreRun.exe
```

The code generated is:
```asm
; Assembly listing for method Program:Main()
; Emitting BLENDED_CODE for X64 CPU with AVX
; optimized code
; rsp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 OutArgs      [V00    ] (  1  1   )  lclBlk (32) [rsp+0x00]
;  V01 cse0         [V01T00] (  5  5   )    long  -&gt;  [rsp+0x20]
;
; Lcl frame size = 40

G_M5092_IG01:
       57                   push     rdi
       56                   push     rsi
       4883EC28             sub      rsp 40

G_M5092_IG02:
       48B9E045E3FEFB7F0000 mov      rcx 0x7FFBFEE345E0
       BA05000000           mov      edx 5
       E8461E455F           call     CORINFO_HELP_GETSHARED_NONGCSTATIC_BASE
       48B87829001091010000 mov      rax 0x19110002978
       488B00               mov      rax gword ptr [rax]
       488D7008             lea      rsi bword ptr [rax+8]
       48B87029001091010000 mov      rax 0x19110002970
       488B00               mov      rax gword ptr [rax]
       488D7808             lea      rdi bword ptr [rax+8]
       E85F572B5F           call     CORINFO_HELP_ASSIGN_BYREF
       48A5                 movsq

G_M5092_IG03:
       4883C428             add      rsp 40
       5E                   pop      rsi
       5F                   pop      rdi
       C3                   ret

; Total bytes of code 74 prolog size 6 for method Program:Main()
;
```

Question: How will this normally be handled by CoreCLR? Should the runtime turn the AV in `CORINFO_HELP_ASSIGN_BYREF` into a managed NRE or is the caller supposed to null-check/deref the reference before calling `CORINFO_HELP_ASSIGN_BYREF`?</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19441</IssueLabelID>
    <Title>R2RDumpTest debug failure</Title>
    <Description>This test appears to have started failing in Debug runs with https://github.com/dotnet/coreclr/pull/19419

https://ci.dot.net/job/dotnet_coreclr/job/master/view/x86/job/x86_debug_windows_nt/5075/
https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64/job/debug_windows_nt/5358/

@nattress @acmyu </Description>
    <Title_Description>R2RDumpTest debug failure This test appears to have started failing in Debug runs with https://github.com/dotnet/coreclr/pull/19419

https://ci.dot.net/job/dotnet_coreclr/job/master/view/x86/job/x86_debug_windows_nt/5075/
https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64/job/debug_windows_nt/5358/

@nattress @acmyu </Title_Description>
    <Label>area-ReadyToRun</Label>
    <Assignee>acmyu</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19440</IssueLabelID>
    <Title>Assert failure: obj != NULL</Title>
    <Description>x86 Checked Windows GCStress=c

https://ci.dot.net/job/dotnet_coreclr/job/master/view/x86/job/jitstress/job/x86_checked_windows_nt_gcstress0xc/96/consoleText


```      JIT_Regression._JitBlue_DevDiv_278372_DevDiv_278372_DevDiv_278372_._JitBlue_DevDiv_278372_DevDiv_278372_DevDiv_278372_cmd [FAIL]
        
        Assert failure(PID 3960 [0x00000f78] Thread: 7840 [0x1ea0]): obj != NULL
        
        CORECLR! StackFrameIterator::PreProcessingForManagedFrames + 0x12C (0x72eda22f)
        CORECLR! StackFrameIterator::ProcessCurrentFrame + 0x264 (0x72eda524)
        CORECLR! StackFrameIterator::NextRaw + 0x9D1 (0x72ed9e66)
        CORECLR! StackFrameIterator::Next + 0x46 (0x72ed9451)
        CORECLR! Thread::StackWalkFramesEx + 0x189 (0x72edaa78)
        CORECLR! Thread::StackWalkFrames + 0x15E (0x72eda86c)
        CORECLR! IsProtectedByGCFrame + 0xD0 (0x72fd2a39)
        CORECLR! VirtualCallStubManager::ResolveWorker + 0x25D (0x7300b58a)
        CORECLR! ExternalMethodFixupWorker + 0x4D1 (0x72f911b2)
        CORECLR! DelayLoad_MethodCall + 0x23 (0x72e149a0)
            File: d:\j\workspace\x86_checked_w---e5963ece\src\vm\stackwalk.cpp Line: 3178
            Image: D:\j\workspace\x86_checked_w---e5963ece\bin\tests\Windows_NT.x86.Checked\Tests\Core_Root\CoreRun.exe
        
        
  
  Return code:      1
  Raw output file:      D:\j\workspace\x86_checked_w---e5963ece\bin\tests\Windows_NT.x86.Checked\Reports\JIT.Regression\JitBlue\DevDiv_278372\DevDiv_278372\DevDiv_278372.output.txt
  Raw output:
  BEGIN EXECUTION
         "D:\j\workspace\x86_checked_w---e5963ece\tests\..\bin\tests\Windows_NT.x86.Checked\Tests\Core_Root\corerun.exe" DevDiv_278372.exe 
        Expected: 100
        Actual: 123456789
        END EXECUTION - FAILED
        FAILED
        Test Harness Exitcode is : 1
        
  To run the test:
  &gt; set CORE_ROOT=D:\j\workspace\x86_checked_w---e5963ece\bin\tests\Windows_NT.x86.Checked\Tests\Core_Root
  &gt; D:\j\workspace\x86_checked_w---e5963ece\bin\tests\Windows_NT.x86.Checked\JIT\Regression\JitBlue\DevDiv_278372\DevDiv_278372\DevDiv_278372.cmd
  
        Expected: True
        Actual:   False
        Stack Trace:
          D:\j\workspace\x86_checked_w---e5963ece\bin\tests\Windows_NT.x86.Checked\TestWrappers\JIT.Regression\JIT.Regression.XUnitWrapper.cs(687090): at JIT_Regression._JitBlue_DevDiv_278372_DevDiv_278372_DevDiv_278372_._JitBlue_DevDiv_278372_DevDiv_278372_DevDiv_278372_cmd()
```
</Description>
    <Title_Description>Assert failure: obj != NULL x86 Checked Windows GCStress=c

https://ci.dot.net/job/dotnet_coreclr/job/master/view/x86/job/jitstress/job/x86_checked_windows_nt_gcstress0xc/96/consoleText


```      JIT_Regression._JitBlue_DevDiv_278372_DevDiv_278372_DevDiv_278372_._JitBlue_DevDiv_278372_DevDiv_278372_DevDiv_278372_cmd [FAIL]
        
        Assert failure(PID 3960 [0x00000f78] Thread: 7840 [0x1ea0]): obj != NULL
        
        CORECLR! StackFrameIterator::PreProcessingForManagedFrames + 0x12C (0x72eda22f)
        CORECLR! StackFrameIterator::ProcessCurrentFrame + 0x264 (0x72eda524)
        CORECLR! StackFrameIterator::NextRaw + 0x9D1 (0x72ed9e66)
        CORECLR! StackFrameIterator::Next + 0x46 (0x72ed9451)
        CORECLR! Thread::StackWalkFramesEx + 0x189 (0x72edaa78)
        CORECLR! Thread::StackWalkFrames + 0x15E (0x72eda86c)
        CORECLR! IsProtectedByGCFrame + 0xD0 (0x72fd2a39)
        CORECLR! VirtualCallStubManager::ResolveWorker + 0x25D (0x7300b58a)
        CORECLR! ExternalMethodFixupWorker + 0x4D1 (0x72f911b2)
        CORECLR! DelayLoad_MethodCall + 0x23 (0x72e149a0)
            File: d:\j\workspace\x86_checked_w---e5963ece\src\vm\stackwalk.cpp Line: 3178
            Image: D:\j\workspace\x86_checked_w---e5963ece\bin\tests\Windows_NT.x86.Checked\Tests\Core_Root\CoreRun.exe
        
        
  
  Return code:      1
  Raw output file:      D:\j\workspace\x86_checked_w---e5963ece\bin\tests\Windows_NT.x86.Checked\Reports\JIT.Regression\JitBlue\DevDiv_278372\DevDiv_278372\DevDiv_278372.output.txt
  Raw output:
  BEGIN EXECUTION
         "D:\j\workspace\x86_checked_w---e5963ece\tests\..\bin\tests\Windows_NT.x86.Checked\Tests\Core_Root\corerun.exe" DevDiv_278372.exe 
        Expected: 100
        Actual: 123456789
        END EXECUTION - FAILED
        FAILED
        Test Harness Exitcode is : 1
        
  To run the test:
  &gt; set CORE_ROOT=D:\j\workspace\x86_checked_w---e5963ece\bin\tests\Windows_NT.x86.Checked\Tests\Core_Root
  &gt; D:\j\workspace\x86_checked_w---e5963ece\bin\tests\Windows_NT.x86.Checked\JIT\Regression\JitBlue\DevDiv_278372\DevDiv_278372\DevDiv_278372.cmd
  
        Expected: True
        Actual:   False
        Stack Trace:
          D:\j\workspace\x86_checked_w---e5963ece\bin\tests\Windows_NT.x86.Checked\TestWrappers\JIT.Regression\JIT.Regression.XUnitWrapper.cs(687090): at JIT_Regression._JitBlue_DevDiv_278372_DevDiv_278372_DevDiv_278372_._JitBlue_DevDiv_278372_DevDiv_278372_DevDiv_278372_cmd()
```
</Title_Description>
    <Label>GCStress</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>12/08/2018 4:09:36 PM +00:00</CreatedAt>
    <ClosedAt>14/06/2019 8:30:36 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19439</IssueLabelID>
    <Title>Assertion failed 'varDsc-&gt;lvRefCnt() == 0 &amp;&amp; !varDsc-&gt;lvRegister &amp;&amp; !varDsc-&gt;lvOnFrame'</Title>
    <Description>From x86 Checked Windows R2R with JITMinOpts=1

https://ci.dot.net/job/dotnet_coreclr/job/master/view/x86/job/jitstress/job/x86_checked_windows_nt_r2r_jitminopts/135/consoleFull

```
JIT_Regression._CLR_x86_JIT_V1_M09_5_PDC_b28927_b28927_b28927_._CLR_x86_JIT_V1_M09_5_PDC_b28927_b28927_b28927_cmd [FAIL]
23:48:23         
23:48:23 
        Assert failure(PID 6908 [0x00001afc] Thread: 6328 [0x18b8]): Assertion failed 'varDsc-&gt;lvRefCnt() == 0 &amp;&amp; !varDsc-&gt;lvRegister &amp;&amp; !varDsc-&gt;lvOnFrame' in '_ldtoken:test(int):int:this' (IL size 4)
23:48:23         
23:48:23             File: d:\j\workspace\x86_checked_w---96237527\src\jit\regalloc.cpp Line: 427
23:48:23             Image: D:\j\workspace\x86_checked_w---96237527\bin\tests\Windows_NT.x86.Checked\Tests\Core_Root\crossgen.exe
23:48:23         
23:48:23         
23:48:23   
23:48:23   Return code:      1
23:48:23   Raw output file:      D:\j\workspace\x86_checked_w---96237527\bin\tests\Windows_NT.x86.Checked\Reports\JIT.Regression\CLR-x86-JIT\V1-M09.5-PDC\b28927\b28927\b28927.output.txt
23:48:23   Raw output:
23:48:23   BEGIN EXECUTION
23:48:23                 1 file(s) copied.
23:48:23         " D:\j\workspace\x86_checked_w---96237527\tests\..\bin\tests\Windows_NT.x86.Checked\Tests\Core_Root\crossgen.exe" /Platform_Assemblies_Paths D:\j\workspace\x86_checked_w---96237527\tests\..\bin\tests\Windows_NT.x86.Checked\Tests\Core_Root;D:\j\workspace\x86_checked_w---96237527\bin\tests\Windows_NT.x86.Checked\JIT\Regression\CLR-x86-JIT\V1-M09.5-PDC\b28927\b28927\IL;D:\j\workspace\x86_checked_w---96237527\bin\tests\Windows_NT.x86.Checked\JIT\Regression\CLR-x86-JIT\V1-M09.5-PDC\b28927\b28927 /in b28927.org /out b28927.exe
23:48:23         Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0
23:48:23         Copyright (c) Microsoft Corporation.  All rights reserved.
23:48:23         
23:48:23         Crossgen failed with exitcode - 123456789
23:48:23         Test Harness Exitcode is : 1
23:48:23         
23:48:23   To run the test:
23:48:23   &gt; set CORE_ROOT=D:\j\workspace\x86_checked_w---96237527\bin\tests\Windows_NT.x86.Checked\Tests\Core_Root
23:48:23   &gt; D:\j\workspace\x86_checked_w---96237527\bin\tests\Windows_NT.x86.Checked\JIT\Regression\CLR-x86-JIT\V1-M09.5-PDC\b28927\b28927\b28927.cmd
23:48:23   
```

Failing:
```
JIT\Regression\CLR-x86-JIT\V1-M09.5-PDC\b28927\b28927\b28927.cmd
JIT\Regression\CLR-x86-JIT\V1-M12-Beta2\b71120\b71120\b71120.cmd
```
</Description>
    <Title_Description>Assertion failed 'varDsc-&gt;lvRefCnt() == 0 &amp;&amp; !varDsc-&gt;lvRegister &amp;&amp; !varDsc-&gt;lvOnFrame' From x86 Checked Windows R2R with JITMinOpts=1

https://ci.dot.net/job/dotnet_coreclr/job/master/view/x86/job/jitstress/job/x86_checked_windows_nt_r2r_jitminopts/135/consoleFull

```
JIT_Regression._CLR_x86_JIT_V1_M09_5_PDC_b28927_b28927_b28927_._CLR_x86_JIT_V1_M09_5_PDC_b28927_b28927_b28927_cmd [FAIL]
23:48:23         
23:48:23 
        Assert failure(PID 6908 [0x00001afc] Thread: 6328 [0x18b8]): Assertion failed 'varDsc-&gt;lvRefCnt() == 0 &amp;&amp; !varDsc-&gt;lvRegister &amp;&amp; !varDsc-&gt;lvOnFrame' in '_ldtoken:test(int):int:this' (IL size 4)
23:48:23         
23:48:23             File: d:\j\workspace\x86_checked_w---96237527\src\jit\regalloc.cpp Line: 427
23:48:23             Image: D:\j\workspace\x86_checked_w---96237527\bin\tests\Windows_NT.x86.Checked\Tests\Core_Root\crossgen.exe
23:48:23         
23:48:23         
23:48:23   
23:48:23   Return code:      1
23:48:23   Raw output file:      D:\j\workspace\x86_checked_w---96237527\bin\tests\Windows_NT.x86.Checked\Reports\JIT.Regression\CLR-x86-JIT\V1-M09.5-PDC\b28927\b28927\b28927.output.txt
23:48:23   Raw output:
23:48:23   BEGIN EXECUTION
23:48:23                 1 file(s) copied.
23:48:23         " D:\j\workspace\x86_checked_w---96237527\tests\..\bin\tests\Windows_NT.x86.Checked\Tests\Core_Root\crossgen.exe" /Platform_Assemblies_Paths D:\j\workspace\x86_checked_w---96237527\tests\..\bin\tests\Windows_NT.x86.Checked\Tests\Core_Root;D:\j\workspace\x86_checked_w---96237527\bin\tests\Windows_NT.x86.Checked\JIT\Regression\CLR-x86-JIT\V1-M09.5-PDC\b28927\b28927\IL;D:\j\workspace\x86_checked_w---96237527\bin\tests\Windows_NT.x86.Checked\JIT\Regression\CLR-x86-JIT\V1-M09.5-PDC\b28927\b28927 /in b28927.org /out b28927.exe
23:48:23         Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0
23:48:23         Copyright (c) Microsoft Corporation.  All rights reserved.
23:48:23         
23:48:23         Crossgen failed with exitcode - 123456789
23:48:23         Test Harness Exitcode is : 1
23:48:23         
23:48:23   To run the test:
23:48:23   &gt; set CORE_ROOT=D:\j\workspace\x86_checked_w---96237527\bin\tests\Windows_NT.x86.Checked\Tests\Core_Root
23:48:23   &gt; D:\j\workspace\x86_checked_w---96237527\bin\tests\Windows_NT.x86.Checked\JIT\Regression\CLR-x86-JIT\V1-M09.5-PDC\b28927\b28927\b28927.cmd
23:48:23   
```

Failing:
```
JIT\Regression\CLR-x86-JIT\V1-M09.5-PDC\b28927\b28927\b28927.cmd
JIT\Regression\CLR-x86-JIT\V1-M12-Beta2\b71120\b71120\b71120.cmd
```
</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19438</IssueLabelID>
    <Title>Regression: Wrapped System.Numerics types are not generating SIMD code</Title>
    <Description>Greetings

I'm running Visual Studio 2017 v15.7.6 with .Net Core 2.1.400-preview-009171. I've noticed that SIMD types from System.Numerics that are wrapped within structs are not generating optimal code. I've tried running from vanilla JIT as well as AOT (both RyuJIT and CPP CodeGen) to no avail.

I've attached a simple project that demonstrates this along with the disassembly.

Furthermore it appears that this might be a regression given it seems to have been resolved in https://github.com/dotnet/coreclr/issues/7508 for a prior version.

It would be awesome if this issue can be addressed ASAP.

[SimdCodeGen.zip](https://github.com/dotnet/coreclr/files/2280547/SimdCodeGen.zip)
[NativeVector_Disassembly.txt](https://github.com/dotnet/coreclr/files/2280548/NativeVector_Disassembly.txt)
[WrappedVector_Disassembly.txt](https://github.com/dotnet/coreclr/files/2280549/WrappedVector_Disassembly.txt)

Thanks.

@CarolEidt @sivarv </Description>
    <Title_Description>Regression: Wrapped System.Numerics types are not generating SIMD code Greetings

I'm running Visual Studio 2017 v15.7.6 with .Net Core 2.1.400-preview-009171. I've noticed that SIMD types from System.Numerics that are wrapped within structs are not generating optimal code. I've tried running from vanilla JIT as well as AOT (both RyuJIT and CPP CodeGen) to no avail.

I've attached a simple project that demonstrates this along with the disassembly.

Furthermore it appears that this might be a regression given it seems to have been resolved in https://github.com/dotnet/coreclr/issues/7508 for a prior version.

It would be awesome if this issue can be addressed ASAP.

[SimdCodeGen.zip](https://github.com/dotnet/coreclr/files/2280547/SimdCodeGen.zip)
[NativeVector_Disassembly.txt](https://github.com/dotnet/coreclr/files/2280548/NativeVector_Disassembly.txt)
[WrappedVector_Disassembly.txt](https://github.com/dotnet/coreclr/files/2280549/WrappedVector_Disassembly.txt)

Thanks.

@CarolEidt @sivarv </Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19437</IssueLabelID>
    <Title>[Linux/ARM] SIGILL during stepping under managed debugger</Title>
    <Description>Sometimes during stepping through method that could be called from different threads SIGILL occurs (https://github.com/dotnet/coreclr/pull/19409 does right things but doesn't solve this problem):
```
(gdb) i threads
  Id   Target Id         Frame
  29   Thread 0xb1d09040 (LWP 5271) "DN_sung.tv.csfs" 0xb639cce4 in read ()
   from /lib/libpthread.so.0
  28   Thread 0xb18b7040 (LWP 5272) "DN_sung.tv.csfs" 0xb61b5b14 in poll ()
   from /lib/libc.so.6
  27   Thread 0xb1657040 (LWP 5273) "DN_sung.tv.csfs" 0xb639cce4 in read ()
   from /lib/libpthread.so.0
  26   Thread 0xb1457040 (LWP 5274) "DN_sung.tv.csfs" 0xb6398674 in pthread_cond_timedwait@@GLIBC_2.4 () from /lib/libpthread.so.0
  25   Thread 0xb0eff040 (LWP 5278) "DN_sung.tv.csfs" 0xb63982c4 in pthread_cond_wait@@GLIBC_2.4 () from /lib/libpthread.so.0
  24   Thread 0xaecfe040 (LWP 5279) "DN_sung.tv.csfs" 0xb6398674 in pthread_cond_timedwait@@GLIBC_2.4 () from /lib/libpthread.so.0
  23   Thread 0xae0d0040 (LWP 5296) "DN_sung.tv.csfs" 0xb63982c4 in pthread_cond_wait@@GLIBC_2.4 () from /lib/libpthread.so.0
  22   Thread 0xadcff040 (LWP 5297) "DN_sung.tv.csfs" 0xae3479fa in sigill_handler(int siginfo_t* void*) ()
   from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.1/libclrjit.so
  21   Thread 0xad1cf040 (LWP 5317) "DN_sung.tv.csfs" 0xb63982c4 in pthread_cond_wait@@GLIBC_2.4 () from /lib/libpthread.so.0
  20   Thread 0xabd6a040 (LWP 5338) "gmain" 0xb61b5b14 in poll ()
   from /lib/libc.so.6
  19   Thread 0xab9a5040 (LWP 5339) "gkdbus" 0xb61b5b14 in poll ()
---Type &lt;return&gt; to continue or q &lt;return&gt; to quit---
   from /lib/libc.so.6
  18   Thread 0xac935040 (LWP 5384) "DN_sung.tv.csfs" 0xb63982c4 in pthread_cond_wait@@GLIBC_2.4 () from /lib/libpthread.so.0
  17   Thread 0xaa1ae040 (LWP 5386) "DN_sung.tv.csfs" 0xb63982c4 in pthread_cond_wait@@GLIBC_2.4 () from /lib/libpthread.so.0
  16   Thread 0xa9f6e040 (LWP 5387) "DN_sung.tv.csfs" 0xb63982c4 in pthread_cond_wait@@GLIBC_2.4 () from /lib/libpthread.so.0
  15   Thread 0xa9d6e040 (LWP 5388) "DN_sung.tv.csfs" 0xb63982c4 in pthread_cond_wait@@GLIBC_2.4 () from /lib/libpthread.so.0
  14   Thread 0xa9b3e040 (LWP 5390) "gkdbus" 0xb61b5b14 in poll ()
   from /lib/libc.so.6
  13   Thread 0xa64c0040 (LWP 5391) "Edbg-sys" 0xb639c524 in __lll_lock_wait ()
   from /lib/libpthread.so.0
  12   Thread 0xaa3ff040 (LWP 5392) "DN_sung.tv.csfs" 0xb63982c4 in pthread_cond_wait@@GLIBC_2.4 () from /lib/libpthread.so.0
  11   Thread 0xa4003040 (LWP 5393) "DN_sung.tv.csfs" 0xb61bf768 in epoll_wait
    () from /lib/libc.so.6
  10   Thread 0xa2d63040 (LWP 5395) "DN_sung.tv.csfs" 0xb63982c4 in pthread_cond_wait@@GLIBC_2.4 () from /lib/libpthread.so.0
  9    Thread 0x9ff3e040 (LWP 5409) "gkdbus" 0xb61b5b14 in poll ()
   from /lib/libc.so.6
  8    Thread 0xac10d040 (LWP 5461) "DN_sung.tv.csfs" 0xb63982c4 in pthread_cond_wait@@GLIBC_2.4 () from /lib/libpthread.so.0
---Type &lt;return&gt; to continue or q &lt;return&gt; to quit---
  7    Thread 0xad3ff040 (LWP 5465) "DN_sung.tv.csfs" 0xb61b5b14 in poll ()
   from /lib/libc.so.6
  6    Thread 0xacb35040 (LWP 5482) "DN_sung.tv.csfs" 0xb63982c4 in pthread_cond_wait@@GLIBC_2.4 () from /lib/libpthread.so.0
  5    Thread 0x9e05b040 (LWP 5483) "DN_sung.tv.csfs" 0xb63982c4 in pthread_cond_wait@@GLIBC_2.4 () from /lib/libpthread.so.0
  4    Thread 0x9de5b040 (LWP 5484) "DN_sung.tv.csfs" 0xb63982c4 in pthread_cond_wait@@GLIBC_2.4 () from /lib/libpthread.so.0
  3    Thread 0x9dc5b040 (LWP 5485) "DN_sung.tv.csfs" 0xb63982c4 in pthread_cond_wait@@GLIBC_2.4 () from /lib/libpthread.so.0
  2    Thread 0xad8ff040 (LWP 5486) "DN_sung.tv.csfs" 0xb63982c4 in pthread_cond_wait@@GLIBC_2.4 () from /lib/libpthread.so.0
* 1    Thread 0xb47cc000 (LWP 5269) "DN_sung.tv.csfs" 0xb63982c4 in pthread_cond_wait@@GLIBC_2.4 () from /lib/libpthread.so.0
(gdb) thread 22
[Switching to thread 22 (Thread 0xadcff040 (LWP 5297))]
#0  0xae3479fa in sigill_handler(int siginfo_t* void*) ()
   from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.1/libclrjit.so
(gdb) bt
#0  0xae3479fa in sigill_handler(int siginfo_t* void*) ()
   from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.1/libclrjit.so
#1  &lt;signal handler called&gt;
#2  0xadae0cbc in ?? ()
#3  0xb1e23158 in JIT_MonExit_Signal(Object*) ()
   from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.1/libcoreclr.so
#4  0xaea6adf8 in ?? ()
Backtrace stopped: previous frame identical to this frame (corrupt stack?)
(gdb) f 2
#2  0xadae0cbc in ?? ()
(gdb) i r
r0             0x1      1
r1             0x1      1
r2             0xadcfe848       2916083784
r3             0xf98ff3e8       4186960872
r4             0xadcfe628       2916083240
r5             0x0      0
r6             0xadcfe5f4       2916083188
r7             0xadcfe738       2916083512
r8             0x0      0
r9             0xadcfe784       2916083588
r10            0x0      0
r11            0xadcfe620       2916083232
r12            0xb622e194       3055739284
sp             0xadcfe480       0xadcfe480
lr             0xb1e23159       -1310576295
pc             0xadae0cbc       0xadae0cbc
cpsr           0x600d0030       1611464752
(gdb) x/10i $pc-4
   0xadae0cb8:  asrs    r2 r4 #15
   0xadae0cba:  blx     r3
=&gt; 0xadae0cbc:  nop
   0xadae0cbe:  nop
   0xadae0cc0:  add     sp #32
   0xadae0cc2:  ldmia.w sp! {r4 r5 r6 r10 r11 pc}
   0xadae0cc6:  stmdb   sp! {r4 r5 r6 r10 r11 lr}
   0xadae0cca:  sub     sp #32
   0xadae0ccc:  add.w   r3 r11 #8
   0xadae0cd0:  str     r3 [sp #28]
(gdb)
```
We are stepping in the main thread (5269) and sigill occurs in 5297.

The problem occurs after breakpoint patch was unapplied:
```
Breakpoint was inserted at ADAE065D for opcode bf00
DC::UP unapply patch at addr 0xADAE065D
DC::ApplyPatch at addr 0xADAE068D
Breakpoint was inserted at ADAE068D for opcode bf00
DC::UP unapply patch at addr 0xADAE068D
DC::ApplyPatch at addr 0xADAE0C99
Breakpoint was inserted at ADAE0C99 for opcode e92d
DC::UP unapply patch at addr 0xADAE0C99
DC::ApplyPatch at addr 0xADAE0CBD
Breakpoint was inserted at ADAE0CBD for opcode bf00
DC::UP unapply patch at addr 0xADAE0CBD
sigill_handler called!!!!!
```

I think the reason is that patches are applied and unapplied non-atomically:
```c++
inline void CORDbgSetInstruction(CORDB_ADDRESS_TYPE* address
                                 PRD_TYPE instruction)
{
    // In a DAC build this function assumes the input is an host address.
    LIMITED_METHOD_DAC_CONTRACT;

    ULONG ptraddr = dac_cast&lt;ULONG&gt;(address);
    _ASSERTE(ptraddr &amp; THUMB_CODE);
    ptraddr &amp;= ~THUMB_CODE;

    *(PRD_TYPE *)ptraddr = instruction; // &lt;-- non-atomically write
    FlushInstructionCache(GetCurrentProcess()
                          _ClearThumbBit(address)
                          sizeof(PRD_TYPE));
}
```

Maybe we should use `Interlocked` function to do atomic write. What do you think?

Thank you!</Description>
    <Title_Description>[Linux/ARM] SIGILL during stepping under managed debugger Sometimes during stepping through method that could be called from different threads SIGILL occurs (https://github.com/dotnet/coreclr/pull/19409 does right things but doesn't solve this problem):
```
(gdb) i threads
  Id   Target Id         Frame
  29   Thread 0xb1d09040 (LWP 5271) "DN_sung.tv.csfs" 0xb639cce4 in read ()
   from /lib/libpthread.so.0
  28   Thread 0xb18b7040 (LWP 5272) "DN_sung.tv.csfs" 0xb61b5b14 in poll ()
   from /lib/libc.so.6
  27   Thread 0xb1657040 (LWP 5273) "DN_sung.tv.csfs" 0xb639cce4 in read ()
   from /lib/libpthread.so.0
  26   Thread 0xb1457040 (LWP 5274) "DN_sung.tv.csfs" 0xb6398674 in pthread_cond_timedwait@@GLIBC_2.4 () from /lib/libpthread.so.0
  25   Thread 0xb0eff040 (LWP 5278) "DN_sung.tv.csfs" 0xb63982c4 in pthread_cond_wait@@GLIBC_2.4 () from /lib/libpthread.so.0
  24   Thread 0xaecfe040 (LWP 5279) "DN_sung.tv.csfs" 0xb6398674 in pthread_cond_timedwait@@GLIBC_2.4 () from /lib/libpthread.so.0
  23   Thread 0xae0d0040 (LWP 5296) "DN_sung.tv.csfs" 0xb63982c4 in pthread_cond_wait@@GLIBC_2.4 () from /lib/libpthread.so.0
  22   Thread 0xadcff040 (LWP 5297) "DN_sung.tv.csfs" 0xae3479fa in sigill_handler(int siginfo_t* void*) ()
   from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.1/libclrjit.so
  21   Thread 0xad1cf040 (LWP 5317) "DN_sung.tv.csfs" 0xb63982c4 in pthread_cond_wait@@GLIBC_2.4 () from /lib/libpthread.so.0
  20   Thread 0xabd6a040 (LWP 5338) "gmain" 0xb61b5b14 in poll ()
   from /lib/libc.so.6
  19   Thread 0xab9a5040 (LWP 5339) "gkdbus" 0xb61b5b14 in poll ()
---Type &lt;return&gt; to continue or q &lt;return&gt; to quit---
   from /lib/libc.so.6
  18   Thread 0xac935040 (LWP 5384) "DN_sung.tv.csfs" 0xb63982c4 in pthread_cond_wait@@GLIBC_2.4 () from /lib/libpthread.so.0
  17   Thread 0xaa1ae040 (LWP 5386) "DN_sung.tv.csfs" 0xb63982c4 in pthread_cond_wait@@GLIBC_2.4 () from /lib/libpthread.so.0
  16   Thread 0xa9f6e040 (LWP 5387) "DN_sung.tv.csfs" 0xb63982c4 in pthread_cond_wait@@GLIBC_2.4 () from /lib/libpthread.so.0
  15   Thread 0xa9d6e040 (LWP 5388) "DN_sung.tv.csfs" 0xb63982c4 in pthread_cond_wait@@GLIBC_2.4 () from /lib/libpthread.so.0
  14   Thread 0xa9b3e040 (LWP 5390) "gkdbus" 0xb61b5b14 in poll ()
   from /lib/libc.so.6
  13   Thread 0xa64c0040 (LWP 5391) "Edbg-sys" 0xb639c524 in __lll_lock_wait ()
   from /lib/libpthread.so.0
  12   Thread 0xaa3ff040 (LWP 5392) "DN_sung.tv.csfs" 0xb63982c4 in pthread_cond_wait@@GLIBC_2.4 () from /lib/libpthread.so.0
  11   Thread 0xa4003040 (LWP 5393) "DN_sung.tv.csfs" 0xb61bf768 in epoll_wait
    () from /lib/libc.so.6
  10   Thread 0xa2d63040 (LWP 5395) "DN_sung.tv.csfs" 0xb63982c4 in pthread_cond_wait@@GLIBC_2.4 () from /lib/libpthread.so.0
  9    Thread 0x9ff3e040 (LWP 5409) "gkdbus" 0xb61b5b14 in poll ()
   from /lib/libc.so.6
  8    Thread 0xac10d040 (LWP 5461) "DN_sung.tv.csfs" 0xb63982c4 in pthread_cond_wait@@GLIBC_2.4 () from /lib/libpthread.so.0
---Type &lt;return&gt; to continue or q &lt;return&gt; to quit---
  7    Thread 0xad3ff040 (LWP 5465) "DN_sung.tv.csfs" 0xb61b5b14 in poll ()
   from /lib/libc.so.6
  6    Thread 0xacb35040 (LWP 5482) "DN_sung.tv.csfs" 0xb63982c4 in pthread_cond_wait@@GLIBC_2.4 () from /lib/libpthread.so.0
  5    Thread 0x9e05b040 (LWP 5483) "DN_sung.tv.csfs" 0xb63982c4 in pthread_cond_wait@@GLIBC_2.4 () from /lib/libpthread.so.0
  4    Thread 0x9de5b040 (LWP 5484) "DN_sung.tv.csfs" 0xb63982c4 in pthread_cond_wait@@GLIBC_2.4 () from /lib/libpthread.so.0
  3    Thread 0x9dc5b040 (LWP 5485) "DN_sung.tv.csfs" 0xb63982c4 in pthread_cond_wait@@GLIBC_2.4 () from /lib/libpthread.so.0
  2    Thread 0xad8ff040 (LWP 5486) "DN_sung.tv.csfs" 0xb63982c4 in pthread_cond_wait@@GLIBC_2.4 () from /lib/libpthread.so.0
* 1    Thread 0xb47cc000 (LWP 5269) "DN_sung.tv.csfs" 0xb63982c4 in pthread_cond_wait@@GLIBC_2.4 () from /lib/libpthread.so.0
(gdb) thread 22
[Switching to thread 22 (Thread 0xadcff040 (LWP 5297))]
#0  0xae3479fa in sigill_handler(int siginfo_t* void*) ()
   from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.1/libclrjit.so
(gdb) bt
#0  0xae3479fa in sigill_handler(int siginfo_t* void*) ()
   from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.1/libclrjit.so
#1  &lt;signal handler called&gt;
#2  0xadae0cbc in ?? ()
#3  0xb1e23158 in JIT_MonExit_Signal(Object*) ()
   from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.1/libcoreclr.so
#4  0xaea6adf8 in ?? ()
Backtrace stopped: previous frame identical to this frame (corrupt stack?)
(gdb) f 2
#2  0xadae0cbc in ?? ()
(gdb) i r
r0             0x1      1
r1             0x1      1
r2             0xadcfe848       2916083784
r3             0xf98ff3e8       4186960872
r4             0xadcfe628       2916083240
r5             0x0      0
r6             0xadcfe5f4       2916083188
r7             0xadcfe738       2916083512
r8             0x0      0
r9             0xadcfe784       2916083588
r10            0x0      0
r11            0xadcfe620       2916083232
r12            0xb622e194       3055739284
sp             0xadcfe480       0xadcfe480
lr             0xb1e23159       -1310576295
pc             0xadae0cbc       0xadae0cbc
cpsr           0x600d0030       1611464752
(gdb) x/10i $pc-4
   0xadae0cb8:  asrs    r2 r4 #15
   0xadae0cba:  blx     r3
=&gt; 0xadae0cbc:  nop
   0xadae0cbe:  nop
   0xadae0cc0:  add     sp #32
   0xadae0cc2:  ldmia.w sp! {r4 r5 r6 r10 r11 pc}
   0xadae0cc6:  stmdb   sp! {r4 r5 r6 r10 r11 lr}
   0xadae0cca:  sub     sp #32
   0xadae0ccc:  add.w   r3 r11 #8
   0xadae0cd0:  str     r3 [sp #28]
(gdb)
```
We are stepping in the main thread (5269) and sigill occurs in 5297.

The problem occurs after breakpoint patch was unapplied:
```
Breakpoint was inserted at ADAE065D for opcode bf00
DC::UP unapply patch at addr 0xADAE065D
DC::ApplyPatch at addr 0xADAE068D
Breakpoint was inserted at ADAE068D for opcode bf00
DC::UP unapply patch at addr 0xADAE068D
DC::ApplyPatch at addr 0xADAE0C99
Breakpoint was inserted at ADAE0C99 for opcode e92d
DC::UP unapply patch at addr 0xADAE0C99
DC::ApplyPatch at addr 0xADAE0CBD
Breakpoint was inserted at ADAE0CBD for opcode bf00
DC::UP unapply patch at addr 0xADAE0CBD
sigill_handler called!!!!!
```

I think the reason is that patches are applied and unapplied non-atomically:
```c++
inline void CORDbgSetInstruction(CORDB_ADDRESS_TYPE* address
                                 PRD_TYPE instruction)
{
    // In a DAC build this function assumes the input is an host address.
    LIMITED_METHOD_DAC_CONTRACT;

    ULONG ptraddr = dac_cast&lt;ULONG&gt;(address);
    _ASSERTE(ptraddr &amp; THUMB_CODE);
    ptraddr &amp;= ~THUMB_CODE;

    *(PRD_TYPE *)ptraddr = instruction; // &lt;-- non-atomically write
    FlushInstructionCache(GetCurrentProcess()
                          _ClearThumbBit(address)
                          sizeof(PRD_TYPE));
}
```

Maybe we should use `Interlocked` function to do atomic write. What do you think?

Thank you!</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>hoyosjs</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19435</IssueLabelID>
    <Title>StructLayout(LayoutKind.Sequential) is not respected in some cases</Title>
    <Description>Consider the following repro code.
Here structs `S0&lt;S2A&gt;` and `S0&lt;S2B&gt;` are expected to be layed out in memory with the same sequence of fields (even though `bool` may require more bytes than `byte`). 

```
unsafe static class Program2
{
    [StructLayout(LayoutKind.Explicit Pack = sizeof(ushort) Size = sizeof(uint))]
    struct S1
    {
        [FieldOffset(0)]
        public ushort F1;

        [FieldOffset(sizeof(ushort))]
        public ushort F2;
    }

    [StructLayout(LayoutKind.Sequential Pack = sizeof(ulong))]
    unsafe struct S2A { public bool F1; }

    [StructLayout(LayoutKind.Sequential Pack = sizeof(ulong))]
    unsafe struct S2B { public byte F1; }

    [StructLayout(LayoutKind.Sequential Pack = sizeof(ulong))]
    unsafe struct S0&lt;TS&gt;
        where TS : struct
    {
        public ulong F1;
        public S1 SF2;
        public ulong F3;
        public TS F4;
    }

    static void Test(ref S0&lt;S2A&gt; instA ref S0&lt;S2B&gt; instB)
    {
        instA.F1 = 1;
        instA.SF2.F1 = 2;
        instA.SF2.F2 = 3;
        instA.F3 = 4;
        instA.F4.F1 = default;

        instB.F1 = 1;
        instB.SF2.F1 = 2;
        instB.SF2.F2 = 3;
        instB.F3 = 4;
        instB.F4.F1 = default;
    }

    static void Main(string[] args)
    {
        S0&lt;S2A&gt; instA = default;
        S0&lt;S2B&gt; instB = default;
        Test(ref instA ref instB);
    }
}
```
-----------------------
Below is actual disasm taken from method `Test()`.
It looks like fields `instA.SF2` and `instA.F3` were layed out swapped.

```
--- ...\Program2.cs ---
            instA.F1 = 1;
000007FE74C214C0  mov         qword ptr [rcx]1  
            instA.SF2.F1 = 2;
000007FE74C214C7  mov         word ptr [rcx+10h]2  &lt;======= unexpected offset
            instA.SF2.F2 = 3;
000007FE74C214CD  mov         word ptr [rcx+12h]3  &lt;======= unexpected offset
            instA.F3 = 4;
000007FE74C214D3  mov         qword ptr [rcx+8]4  &lt;======= unexpected offset
            instA.F4.F1 = default;
000007FE74C214DB  mov         byte ptr [rcx+18h]0  

            instB.F1 = 1;
000007FE74C214DF  mov         qword ptr [rdx]1  
            instB.SF2.F1 = 2;
000007FE74C214E6  mov         word ptr [rdx+8]2  
            instB.SF2.F2 = 3;
000007FE74C214EC  mov         word ptr [rdx+0Ah]3  
            instB.F3 = 4;
000007FE74C214F2  mov         qword ptr [rdx+10h]4  
            instB.F4.F1 = default;
000007FE74C214FA  mov         byte ptr [rdx+18h]0  
000007FE74C214FE  ret  
--- No source file -------------------------------------------------------------
```</Description>
    <Title_Description>StructLayout(LayoutKind.Sequential) is not respected in some cases Consider the following repro code.
Here structs `S0&lt;S2A&gt;` and `S0&lt;S2B&gt;` are expected to be layed out in memory with the same sequence of fields (even though `bool` may require more bytes than `byte`). 

```
unsafe static class Program2
{
    [StructLayout(LayoutKind.Explicit Pack = sizeof(ushort) Size = sizeof(uint))]
    struct S1
    {
        [FieldOffset(0)]
        public ushort F1;

        [FieldOffset(sizeof(ushort))]
        public ushort F2;
    }

    [StructLayout(LayoutKind.Sequential Pack = sizeof(ulong))]
    unsafe struct S2A { public bool F1; }

    [StructLayout(LayoutKind.Sequential Pack = sizeof(ulong))]
    unsafe struct S2B { public byte F1; }

    [StructLayout(LayoutKind.Sequential Pack = sizeof(ulong))]
    unsafe struct S0&lt;TS&gt;
        where TS : struct
    {
        public ulong F1;
        public S1 SF2;
        public ulong F3;
        public TS F4;
    }

    static void Test(ref S0&lt;S2A&gt; instA ref S0&lt;S2B&gt; instB)
    {
        instA.F1 = 1;
        instA.SF2.F1 = 2;
        instA.SF2.F2 = 3;
        instA.F3 = 4;
        instA.F4.F1 = default;

        instB.F1 = 1;
        instB.SF2.F1 = 2;
        instB.SF2.F2 = 3;
        instB.F3 = 4;
        instB.F4.F1 = default;
    }

    static void Main(string[] args)
    {
        S0&lt;S2A&gt; instA = default;
        S0&lt;S2B&gt; instB = default;
        Test(ref instA ref instB);
    }
}
```
-----------------------
Below is actual disasm taken from method `Test()`.
It looks like fields `instA.SF2` and `instA.F3` were layed out swapped.

```
--- ...\Program2.cs ---
            instA.F1 = 1;
000007FE74C214C0  mov         qword ptr [rcx]1  
            instA.SF2.F1 = 2;
000007FE74C214C7  mov         word ptr [rcx+10h]2  &lt;======= unexpected offset
            instA.SF2.F2 = 3;
000007FE74C214CD  mov         word ptr [rcx+12h]3  &lt;======= unexpected offset
            instA.F3 = 4;
000007FE74C214D3  mov         qword ptr [rcx+8]4  &lt;======= unexpected offset
            instA.F4.F1 = default;
000007FE74C214DB  mov         byte ptr [rcx+18h]0  

            instB.F1 = 1;
000007FE74C214DF  mov         qword ptr [rdx]1  
            instB.SF2.F1 = 2;
000007FE74C214E6  mov         word ptr [rdx+8]2  
            instB.SF2.F2 = 3;
000007FE74C214EC  mov         word ptr [rdx+0Ah]3  
            instB.F3 = 4;
000007FE74C214F2  mov         qword ptr [rdx+10h]4  
            instB.F4.F1 = default;
000007FE74C214FA  mov         byte ptr [rdx+18h]0  
000007FE74C214FE  ret  
--- No source file -------------------------------------------------------------
```</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>11/08/2018 9:13:53 AM +00:00</CreatedAt>
    <ClosedAt>11/08/2018 7:16:08 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19432</IssueLabelID>
    <Title>IL round-trip test failing</Title>
    <Description>For Windows x64 Release the `ilrt` test has been failing for a year:

https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_release_windows_nt_ilrt

Tests:
```
JIT\opt\Inline\regression\badcallee\badcallee\badcallee.cmd
JIT\superpmi\superpmicollect\superpmicollect.cmd
JIT\jit64\verif\sniff\fg\ver_fg_13\ver_fg_13.cmd
```

Related: https://github.com/dotnet/coreclr/issues/16540

Seems like the superpmicollect test should be excluded from ILRT testing.</Description>
    <Title_Description>IL round-trip test failing For Windows x64 Release the `ilrt` test has been failing for a year:

https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_release_windows_nt_ilrt

Tests:
```
JIT\opt\Inline\regression\badcallee\badcallee\badcallee.cmd
JIT\superpmi\superpmicollect\superpmicollect.cmd
JIT\jit64\verif\sniff\fg\ver_fg_13\ver_fg_13.cmd
```

Related: https://github.com/dotnet/coreclr/issues/16540

Seems like the superpmicollect test should be excluded from ILRT testing.</Title_Description>
    <Label>area-ILTools</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>11/08/2018 12:15:55 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19430</IssueLabelID>
    <Title>Build-test.sh handles native test assets</Title>
    <Description>See #19416


cc @janvorli @jashook @RussKeldorph </Description>
    <Title_Description>Build-test.sh handles native test assets See #19416


cc @janvorli @jashook @RussKeldorph </Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>jashook</Assignee>
    <CreatedAt>11/08/2018 12:05:53 AM +00:00</CreatedAt>
    <ClosedAt>16/08/2018 6:21:52 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19428</IssueLabelID>
    <Title>Speculate future methods that will need to be jitted via IL analysis of currently jitting methods</Title>
    <Description>Multicore Jit has been able to provide 20+% startup wins after it is trained but in many scenarios generating and persisting the training data is problematic. We could instead analyze the IL of methods as they were being generated to infer the additional methods they are likely to call in the near future. As a simple case if we were jitting a method:

```
Foo()
{
    Bar();
    Baz();
}
```

We have a pretty strong expectation that Bar() and Baz() will be needed in the near future. Lets naively assume that each of Foo Bar and Baz take 500us to compile Foo takes 1us to run once jitted and at the 100us mark of compiling Foo the JIT will call back to the runtime alerting it that Bar and Baz are good speculative compilation candidates. In the current runtime Foo would complete after 1501us whereas in a perfectly parallelized world with no other overhead it would complete in 601us. In practice the wins would probably be less than what we see from trained Multicore Jit but we'd need further investigation to determine how much less. We might still be able to capture a significant fraction. The advantage is that it doesn't create any dependencies that the application needs to account for which gives it broader scenario reach.

category:throughput
theme:runtime
skill-level:expert
cost:extra-large</Description>
    <Title_Description>Speculate future methods that will need to be jitted via IL analysis of currently jitting methods Multicore Jit has been able to provide 20+% startup wins after it is trained but in many scenarios generating and persisting the training data is problematic. We could instead analyze the IL of methods as they were being generated to infer the additional methods they are likely to call in the near future. As a simple case if we were jitting a method:

```
Foo()
{
    Bar();
    Baz();
}
```

We have a pretty strong expectation that Bar() and Baz() will be needed in the near future. Lets naively assume that each of Foo Bar and Baz take 500us to compile Foo takes 1us to run once jitted and at the 100us mark of compiling Foo the JIT will call back to the runtime alerting it that Bar and Baz are good speculative compilation candidates. In the current runtime Foo would complete after 1501us whereas in a perfectly parallelized world with no other overhead it would complete in 601us. In practice the wins would probably be less than what we see from trained Multicore Jit but we'd need further investigation to determine how much less. We might still be able to capture a significant fraction. The advantage is that it doesn't create any dependencies that the application needs to account for which gives it broader scenario reach.

category:throughput
theme:runtime
skill-level:expert
cost:extra-large</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>noahfalk</Assignee>
    <CreatedAt>10/08/2018 11:56:54 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19426</IssueLabelID>
    <Title>Generate JIT GC encoding asynchronously to improve JIT throughput</Title>
    <Description>Currently this is an unvalidated suggestion. Additional investigation would be required to confirm the win exists and that the tradeoff in perf/complexity elsewhere are acceptable.

In the past I think Peter did some JIT investigation and determined that encoding GC data was about 8% of JIT time. This data isn't needed until a GC occurs and the method is on the stack. It is possible that by doing the work on a parallel background thread the user perceivable delay between invoking the PreStub and having code available to run would improve by 8% with a tradeoff that datastructures used by the JIT might need to persist in memory longer and that some of the overhead might resurface as GC delay.


category:throughput
theme:gc-info
skill-level:expert
cost:extra-large</Description>
    <Title_Description>Generate JIT GC encoding asynchronously to improve JIT throughput Currently this is an unvalidated suggestion. Additional investigation would be required to confirm the win exists and that the tradeoff in perf/complexity elsewhere are acceptable.

In the past I think Peter did some JIT investigation and determined that encoding GC data was about 8% of JIT time. This data isn't needed until a GC occurs and the method is on the stack. It is possible that by doing the work on a parallel background thread the user perceivable delay between invoking the PreStub and having code available to run would improve by 8% with a tradeoff that datastructures used by the JIT might need to persist in memory longer and that some of the overhead might resurface as GC delay.


category:throughput
theme:gc-info
skill-level:expert
cost:extra-large</Title_Description>
    <Label>JitThroughput</Label>
    <Assignee>noahfalk</Assignee>
    <CreatedAt>10/08/2018 11:18:42 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19425</IssueLabelID>
    <Title>Unix: Unnecessary struct copy while passsing struct of size &lt;=16</Title>
    <Description>This is a copy of #6264. For some reason it wasn't possible to update the description of that issue.

Struct arguments whose size is &lt;= 16 bytes generate unnecessary copies. @sivarv  categorized the cases below:

The following are the struct passing cases on Amd64 Unix that are of interest:

struct of size 124 or 8 in memory/register is getting passed in an arg reg or on stack
struct of size 3567 in memory/register is getting passed in an arg reg or on stack
struct of size 9-16 bytes in memory is getting passed in two arg registers
struct of size 9-16 bytes (e.g. SIMD structs Vector3 and Vector4) in a register is getting passed in two arg registers
struct of size 9-16 bytes in memory/register is getting passed on stack.
In fgMorphArgs eeGetSystemVAmd64PassStructInRegisterDescriptor classifies the cases above as register argument except simd from vector&lt;t&gt; and sets structDesc.passedInRegisters to true this always calls fgMakeOutgoingStructArgCopy() and generates copies.

category:cq
theme:calling-convention
skill-level:intermediate
cost:medium</Description>
    <Title_Description>Unix: Unnecessary struct copy while passsing struct of size &lt;=16 This is a copy of #6264. For some reason it wasn't possible to update the description of that issue.

Struct arguments whose size is &lt;= 16 bytes generate unnecessary copies. @sivarv  categorized the cases below:

The following are the struct passing cases on Amd64 Unix that are of interest:

struct of size 124 or 8 in memory/register is getting passed in an arg reg or on stack
struct of size 3567 in memory/register is getting passed in an arg reg or on stack
struct of size 9-16 bytes in memory is getting passed in two arg registers
struct of size 9-16 bytes (e.g. SIMD structs Vector3 and Vector4) in a register is getting passed in two arg registers
struct of size 9-16 bytes in memory/register is getting passed on stack.
In fgMorphArgs eeGetSystemVAmd64PassStructInRegisterDescriptor classifies the cases above as register argument except simd from vector&lt;t&gt; and sets structDesc.passedInRegisters to true this always calls fgMakeOutgoingStructArgCopy() and generates copies.

category:cq
theme:calling-convention
skill-level:intermediate
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>erozenfeld</Assignee>
    <CreatedAt>10/08/2018 11:18:32 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19424</IssueLabelID>
    <Title>Clean up genClearStackVec3ArgUpperBits</Title>
    <Description>This is a copy of #5113. For some reason it wasn't possible to update the description of that issue.

genClearStackVec3ArgUpperBits can be split and implemented in genFnPrologCalleeRegArgs() for argument registers and genEnregisterIncomingStackArgs() for stack arguments.

Related PR: #4963

category:cq
theme:vector-codegen
skill-level:intermediate
cost:small
</Description>
    <Title_Description>Clean up genClearStackVec3ArgUpperBits This is a copy of #5113. For some reason it wasn't possible to update the description of that issue.

genClearStackVec3ArgUpperBits can be split and implemented in genFnPrologCalleeRegArgs() for argument registers and genEnregisterIncomingStackArgs() for stack arguments.

Related PR: #4963

category:cq
theme:vector-codegen
skill-level:intermediate
cost:small
</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>erozenfeld</Assignee>
    <CreatedAt>10/08/2018 11:17:06 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19418</IssueLabelID>
    <Title>[NO MERGE] Dummy PR</Title>
    <Description>**NO MERGE** **NO MERGE** **NO MERGE**</Description>
    <Title_Description>[NO MERGE] Dummy PR **NO MERGE** **NO MERGE** **NO MERGE**</Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>echesakovMSFT</Assignee>
    <CreatedAt>10/08/2018 10:12:56 PM +00:00</CreatedAt>
    <ClosedAt>13/08/2018 4:45:59 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19417</IssueLabelID>
    <Title>[local gc] Enable numa-awareness </Title>
    <Description>Right now local gc is not aware of numa (e.g. virtual_alloc_commit_for_heap)</Description>
    <Title_Description>[local gc] Enable numa-awareness  Right now local gc is not aware of numa (e.g. virtual_alloc_commit_for_heap)</Title_Description>
    <Label>area-GC</Label>
    <Assignee>davmason</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19416</IssueLabelID>
    <Title>Make test building scripts consistent across Windows and non-Windows builds</Title>
    <Description>The `build-test.cmd` handles all test asset building (native/managed) on the Windows platform. This is not the case for `build-test.sh` which is used on non-Windows platforms.

The `build-test.sh` script does _not_ handle native test asset building. Instead the `build.sh` script uses generate all repo projects based on the root `CMakelists.txt` (see `CLR_CMAKE_BUILD_TESTS`). This is in contrast to Windows where native test projects are generated from the `tests\CMakelists.txt` file.

This appears to be for historical reasons but the ramifications are bad. The generation of test projects for non-Windows has organically become dependent on many settings in the root `CMakelists.txt` file.

cc: @RussKeldorph @janvorli @BruceForstall </Description>
    <Title_Description>Make test building scripts consistent across Windows and non-Windows builds The `build-test.cmd` handles all test asset building (native/managed) on the Windows platform. This is not the case for `build-test.sh` which is used on non-Windows platforms.

The `build-test.sh` script does _not_ handle native test asset building. Instead the `build.sh` script uses generate all repo projects based on the root `CMakelists.txt` (see `CLR_CMAKE_BUILD_TESTS`). This is in contrast to Windows where native test projects are generated from the `tests\CMakelists.txt` file.

This appears to be for historical reasons but the ramifications are bad. The generation of test projects for non-Windows has organically become dependent on many settings in the root `CMakelists.txt` file.

cc: @RussKeldorph @janvorli @BruceForstall </Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>10/08/2018 8:15:26 PM +00:00</CreatedAt>
    <ClosedAt>16/08/2018 6:22:34 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19415</IssueLabelID>
    <Title>R2RDump test fails with JITMinOpts</Title>
    <Description>https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/x86_checked_windows_nt_minopts/
https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/x64_checked_windows_nt_minopts/


https://github.com/dotnet/coreclr/pull/19155 removed:
```
  &lt;PropertyGroup&gt;
    &lt;!-- Fails with JIT stress modes issue #19011 --&gt;
    &lt;JitOptimizationSensitive&gt;true&lt;/JitOptimizationSensitive&gt;
  &lt;/PropertyGroup&gt;
```

so the test now runs with JIT optimization modes. It fails under JITMinOpts. (I haven't checked other optimization cases.)
</Description>
    <Title_Description>R2RDump test fails with JITMinOpts https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/x86_checked_windows_nt_minopts/
https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/x64_checked_windows_nt_minopts/


https://github.com/dotnet/coreclr/pull/19155 removed:
```
  &lt;PropertyGroup&gt;
    &lt;!-- Fails with JIT stress modes issue #19011 --&gt;
    &lt;JitOptimizationSensitive&gt;true&lt;/JitOptimizationSensitive&gt;
  &lt;/PropertyGroup&gt;
```

so the test now runs with JIT optimization modes. It fails under JITMinOpts. (I haven't checked other optimization cases.)
</Title_Description>
    <Label>area-ReadyToRun</Label>
    <Assignee>acmyu</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19413</IssueLabelID>
    <Title>JIT: jitstress2 failure in JIT\Methodical\fp\exgen\10w5d_cs_ro after switch to R2R codegen for corelib</Title>
    <Description>Fails after #19359 running with x64 checked. Method prints same output stream but return code is now 108 instead of 100.

Fair number of diffs in jitted code before/after this change. Haven't tried pinning it down yet.

cc @dotnet/jit-contrib </Description>
    <Title_Description>JIT: jitstress2 failure in JIT\Methodical\fp\exgen\10w5d_cs_ro after switch to R2R codegen for corelib Fails after #19359 running with x64 checked. Method prints same output stream but return code is now 108 instead of 100.

Fair number of diffs in jitted code before/after this change. Haven't tried pinning it down yet.

cc @dotnet/jit-contrib </Title_Description>
    <Label>JitStress</Label>
    <Assignee>sandreenko</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19412</IssueLabelID>
    <Title>Remove GT_ASG nodes</Title>
    <Description>This came up occasionally in discussions but AFAIK there's no issue associated with it and IMO there should be due to the significant (negative) impact `GT_ASG` nodes have on RyuJIT's IR. 

IMO it's one of the worst IR "features" if not plain and simple the worst. So far I only encountered pros and no cons:
* It's an extra IR node - wastes memory and slows down IR traversal.
* It imposes a model where the meaning of some nodes depends on the context - a `GT_LCL_VAR` on the RHS is a use but on the LHS is a def. The JIT uses various means to deal with this issue - `GTF_VAR_DEF` `GTF_IND_ASG_LHS` `gtGetParent()` etc.
* It complicates UD chain traversal. SSA gives you the `GT_LCL_VAR` node on the LHS from there you need to use `gtGetParent()` to get the `GT_ASG` node and then get the assignment's second operand. If you're lucky the LHS follow the assignment otherwise `gtGetParent()` will need to traverse multiple nodes.
* It requires additional work to transform HIR into LIR the later does not use assignment nodes.
* It doesn't match the IL model that uses stores. While I don't think that the IR has to strictly follow the IL model this one seems like a huge and unnecessary deviation.
* It doesn't follow the assembly model either. One could argue that `mov eax ebx` is assignment but that's only true if `eax` and `ebx` happen to be enregistered variables. Otherwise you'd be looking at `mov [eax] ebx` which is more similar to a store.

Anyone knows any advantages?

AFAIR Phoenix did have `Assign` but its IR was very different looking more like assembly. I know next to nothing about LLVM but I don't think it has assignment.

category:implementation
theme:ir
skill-level:expert
cost:extra-large</Description>
    <Title_Description>Remove GT_ASG nodes This came up occasionally in discussions but AFAIK there's no issue associated with it and IMO there should be due to the significant (negative) impact `GT_ASG` nodes have on RyuJIT's IR. 

IMO it's one of the worst IR "features" if not plain and simple the worst. So far I only encountered pros and no cons:
* It's an extra IR node - wastes memory and slows down IR traversal.
* It imposes a model where the meaning of some nodes depends on the context - a `GT_LCL_VAR` on the RHS is a use but on the LHS is a def. The JIT uses various means to deal with this issue - `GTF_VAR_DEF` `GTF_IND_ASG_LHS` `gtGetParent()` etc.
* It complicates UD chain traversal. SSA gives you the `GT_LCL_VAR` node on the LHS from there you need to use `gtGetParent()` to get the `GT_ASG` node and then get the assignment's second operand. If you're lucky the LHS follow the assignment otherwise `gtGetParent()` will need to traverse multiple nodes.
* It requires additional work to transform HIR into LIR the later does not use assignment nodes.
* It doesn't match the IL model that uses stores. While I don't think that the IR has to strictly follow the IL model this one seems like a huge and unnecessary deviation.
* It doesn't follow the assembly model either. One could argue that `mov eax ebx` is assignment but that's only true if `eax` and `ebx` happen to be enregistered variables. Otherwise you'd be looking at `mov [eax] ebx` which is more similar to a store.

Anyone knows any advantages?

AFAIR Phoenix did have `Assign` but its IR was very different looking more like assembly. I know next to nothing about LLVM but I don't think it has assignment.

category:implementation
theme:ir
skill-level:expert
cost:extra-large</Title_Description>
    <Label>Design Discussion</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>10/08/2018 4:52:10 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19411</IssueLabelID>
    <Title>Add gcstress smoketest to CI</Title>
    <Description>gcstress is somewhat fragile as requires an additional package install and exercises paths in the runtime that aren't normally hit. We should consider adding a gcstress smoketest to the CI that just stresses a few tests to make sure it remains healthy.

cc @BruceForstall </Description>
    <Title_Description>Add gcstress smoketest to CI gcstress is somewhat fragile as requires an additional package install and exercises paths in the runtime that aren't normally hit. We should consider adding a gcstress smoketest to the CI that just stresses a few tests to make sure it remains healthy.

cc @BruceForstall </Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>AndyAyersMS</Assignee>
    <CreatedAt>10/08/2018 4:15:47 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19408</IssueLabelID>
    <Title>Profiling API: Inconsistent stack unwinding after exception in filter handler</Title>
    <Description>The short example of abnormal Profiling API behavior (.NET Core v2.1 / .NET Framework v4.7.2):
```
private static void Main(string[] args)
{
    try
    {
        throw new InvalidOperationException("QQQ");
    }
    catch (Exception ex) when (Filter(ex))
    {
    }
    catch (Exception ex)
    {
    }
}

private static bool Filter(Exception ex)
{
    throw new ApplicationException("TTT");
}
```

Logs of profiling API callbacks:
```
...
0000912C 1 0000026EE62EF980 PTProf::RdtscFastLeave fuid=00101496
0000912C 1 0000026EE62EF980 PTProf::ExceptionThrown oid=0000026EE6580F60 cid=00007FFB3AB9B3C8 cname='System.InvalidOperationException'
0000912C 1 0000026EE62EF980 BProf::ExceptionSearchFunctionEnter fid=00007FFB3A974BA0
0000912C 1 0000026EE62EF980 PTProf::ExceptionSearchFilterEnter fid=00007FFB3A974BA0 fuid=00200001
0000912C 1 0000026EE62EF980 PTProf::RdtscFastEnter fuid=00200002
0000912C 1 0000026EE62EF980 PTProf::RdtscFastEnter fuid=00101012
0000912C 1 0000026EE62EF980 PTProf::RdtscFastEnter fuid=0010037A
0000912C 1 0000026EE62EF980 PTProf::RdtscFastLeave fuid=0010037A
0000912C 1 0000026EE62EF980 PTProf::RdtscFastLeave fuid=00101012
0000912C 1 0000026EE62EF980 PTProf::ExceptionThrown oid=0000026EE6581058 cid=00007FFB3ABCC028 cname='System.ApplicationException'
0000912C 1 0000026EE62EF980 BProf::ExceptionSearchFunctionEnter fid=00007FFB3A974BB0
0000912C 1 0000026EE62EF980 BProf::ExceptionSearchFunctionLeave
0000912C 1 0000026EE62EF980 BProf::ExceptionSearchFunctionEnter fid=00007FFB3A974BA0
0000912C 1 0000026EE62EF980 BProf::ExceptionSearchFunctionLeave
0000912C 1 0000026EE62EF980 PTProf::ExceptionUnwindFunctionEnter fid=00007FFB3A974BB0 fuid=00200002
0000912C 1 0000026EE62EF980 PTProf::ExceptionUnwindFunctionLeave
0000912C 1 0000026EE62EF980 PTProf::ExceptionUnwindFunctionEnter fid=00007FFB3A974BA0 fuid=00200001 ; &lt;=== first unwind for 00007FFB3A974BA0
0000912C 1 0000026EE62EF980 PTProf::ExceptionUnwindFunctionLeave
0000912C 1 0000026EE62EF980 PTProf::ExceptionSearchFilterLeave
0000912C 1 0000026EE62EF980 BProf::ExceptionSearchCatcherFound fid=00007FFB3A974BA0
0000912C 1 0000026EE62EF980 BProf::ExceptionSearchFunctionLeave
0000912C 1 0000026EE62EF980 PTProf::ExceptionUnwindFunctionEnter fid=00007FFB3A974BA0 fuid=00200001 ; &lt;=== second unwind for 00007FFB3A974BA0
0000912C 1 0000026EE62EF980 PTProf::ExceptionCatcherEnter fid=00007FFB3A974BA0 fuid=00200001 oid=0000026EE6580F60
...
```
Diagnosis:
1. `ExceptionUnwindFunctionEnter` was called twice for one method with `fid=00007FFB3A974BA0`. It breaks the stack tracking down in Enter/Leave/Tailcall mode.
2. `ExceptionCatcherEnter` was called just after `ExceptionUnwindFunctionEnter`. The `ExceptionUnwindFunctionLeave` is absent. The diagram from https://docs.microsoft.com/en-us/previous-versions/dotnet/netframework-4.0/bb384687(v=vs.100) says that it's impossible.

Could you please comment this behavior?</Description>
    <Title_Description>Profiling API: Inconsistent stack unwinding after exception in filter handler The short example of abnormal Profiling API behavior (.NET Core v2.1 / .NET Framework v4.7.2):
```
private static void Main(string[] args)
{
    try
    {
        throw new InvalidOperationException("QQQ");
    }
    catch (Exception ex) when (Filter(ex))
    {
    }
    catch (Exception ex)
    {
    }
}

private static bool Filter(Exception ex)
{
    throw new ApplicationException("TTT");
}
```

Logs of profiling API callbacks:
```
...
0000912C 1 0000026EE62EF980 PTProf::RdtscFastLeave fuid=00101496
0000912C 1 0000026EE62EF980 PTProf::ExceptionThrown oid=0000026EE6580F60 cid=00007FFB3AB9B3C8 cname='System.InvalidOperationException'
0000912C 1 0000026EE62EF980 BProf::ExceptionSearchFunctionEnter fid=00007FFB3A974BA0
0000912C 1 0000026EE62EF980 PTProf::ExceptionSearchFilterEnter fid=00007FFB3A974BA0 fuid=00200001
0000912C 1 0000026EE62EF980 PTProf::RdtscFastEnter fuid=00200002
0000912C 1 0000026EE62EF980 PTProf::RdtscFastEnter fuid=00101012
0000912C 1 0000026EE62EF980 PTProf::RdtscFastEnter fuid=0010037A
0000912C 1 0000026EE62EF980 PTProf::RdtscFastLeave fuid=0010037A
0000912C 1 0000026EE62EF980 PTProf::RdtscFastLeave fuid=00101012
0000912C 1 0000026EE62EF980 PTProf::ExceptionThrown oid=0000026EE6581058 cid=00007FFB3ABCC028 cname='System.ApplicationException'
0000912C 1 0000026EE62EF980 BProf::ExceptionSearchFunctionEnter fid=00007FFB3A974BB0
0000912C 1 0000026EE62EF980 BProf::ExceptionSearchFunctionLeave
0000912C 1 0000026EE62EF980 BProf::ExceptionSearchFunctionEnter fid=00007FFB3A974BA0
0000912C 1 0000026EE62EF980 BProf::ExceptionSearchFunctionLeave
0000912C 1 0000026EE62EF980 PTProf::ExceptionUnwindFunctionEnter fid=00007FFB3A974BB0 fuid=00200002
0000912C 1 0000026EE62EF980 PTProf::ExceptionUnwindFunctionLeave
0000912C 1 0000026EE62EF980 PTProf::ExceptionUnwindFunctionEnter fid=00007FFB3A974BA0 fuid=00200001 ; &lt;=== first unwind for 00007FFB3A974BA0
0000912C 1 0000026EE62EF980 PTProf::ExceptionUnwindFunctionLeave
0000912C 1 0000026EE62EF980 PTProf::ExceptionSearchFilterLeave
0000912C 1 0000026EE62EF980 BProf::ExceptionSearchCatcherFound fid=00007FFB3A974BA0
0000912C 1 0000026EE62EF980 BProf::ExceptionSearchFunctionLeave
0000912C 1 0000026EE62EF980 PTProf::ExceptionUnwindFunctionEnter fid=00007FFB3A974BA0 fuid=00200001 ; &lt;=== second unwind for 00007FFB3A974BA0
0000912C 1 0000026EE62EF980 PTProf::ExceptionCatcherEnter fid=00007FFB3A974BA0 fuid=00200001 oid=0000026EE6580F60
...
```
Diagnosis:
1. `ExceptionUnwindFunctionEnter` was called twice for one method with `fid=00007FFB3A974BA0`. It breaks the stack tracking down in Enter/Leave/Tailcall mode.
2. `ExceptionCatcherEnter` was called just after `ExceptionUnwindFunctionEnter`. The `ExceptionUnwindFunctionLeave` is absent. The diagram from https://docs.microsoft.com/en-us/previous-versions/dotnet/netframework-4.0/bb384687(v=vs.100) says that it's impossible.

Could you please comment this behavior?</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>10/08/2018 2:57:53 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19407</IssueLabelID>
    <Title>Generic interface method not being called</Title>
    <Description>Tested sample code on .NET 2/3/4/4.5/4.6.1 &amp; .Net Core 2.1 behavior is the same for all why is this handled like this? 

Clearly the call to `PrintIt&lt;T&gt;` is creating the correct type `Bar` but never actually calls the correct method.

### Sample Code:
``` csharp
interface PrintMe
{
	void Print();
}

class Foo : PrintMe
{
	public void Print()
	{
		Console.WriteLine("Foo!");
	}
}

class Bar : Foo
{
	public new void Print()
	{
		Console.WriteLine("Bar!");
	}
}

class Program
{
	static void Main(string[] args)
	{
		PrintIt&lt;Foo&gt;();
		PrintIt&lt;Bar&gt;();

		var foo = new Foo();
		var bar = new Bar();

		foo.Print();
		bar.Print();

		Console.ReadKey();
	}

	static void PrintIt&lt;T&gt;() where T : PrintMe new()
	{
		new T().Print();
	}
}
```

### Output:
```
Foo!
Foo!
Foo!
Bar!
```

### Expected Output:
```
Foo!
Bar!
Foo!
Bar!
```
</Description>
    <Title_Description>Generic interface method not being called Tested sample code on .NET 2/3/4/4.5/4.6.1 &amp; .Net Core 2.1 behavior is the same for all why is this handled like this? 

Clearly the call to `PrintIt&lt;T&gt;` is creating the correct type `Bar` but never actually calls the correct method.

### Sample Code:
``` csharp
interface PrintMe
{
	void Print();
}

class Foo : PrintMe
{
	public void Print()
	{
		Console.WriteLine("Foo!");
	}
}

class Bar : Foo
{
	public new void Print()
	{
		Console.WriteLine("Bar!");
	}
}

class Program
{
	static void Main(string[] args)
	{
		PrintIt&lt;Foo&gt;();
		PrintIt&lt;Bar&gt;();

		var foo = new Foo();
		var bar = new Bar();

		foo.Print();
		bar.Print();

		Console.ReadKey();
	}

	static void PrintIt&lt;T&gt;() where T : PrintMe new()
	{
		new T().Print();
	}
}
```

### Output:
```
Foo!
Foo!
Foo!
Bar!
```

### Expected Output:
```
Foo!
Bar!
Foo!
Bar!
```
</Title_Description>
    <Label>question</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>10/08/2018 9:19:27 AM +00:00</CreatedAt>
    <ClosedAt>10/08/2018 2:24:54 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19406</IssueLabelID>
    <Title>Test failure: baseservices_threading._waithandle_waitany_waitanyex2a_waitanyex2a_/_waithandle_waitany_waitanyex2a_waitanyex2a_cmd</Title>
    <Description>Opened on behalf of @Sunny-pu

The test `baseservices_threading._waithandle_waitany_waitanyex2a_waitanyex2a_/_waithandle_waitany_waitanyex2a_waitanyex2a_cmd` has failed.


    
    Return code:      1
    Raw output file:      /home/helixbot/dotnetbuild/work/64020330-e696-44f2-9aa4-7a362aff9f95/Work/78d4e7b9-e498-41b3-b8c1-8cc91a8385b3/Unzip/Reports\\baseservices.threading\\waithandle\\waitany\\waitanyex2a\\waitanyex2a.output.txt
    Raw output:
    BEGIN EXECUTION
    in takeLock
    /home/helixbot/dotnetbuild/work/64020330-e696-44f2-9aa4-7a362aff9f95/Payload/crossgen /Platform_Assemblies_Paths /home/helixbot/dotnetbuild/work/64020330-e696-44f2-9aa4-7a362aff9f95/Payload:/home/helixbot/dotnetbuild/work/64020330-e696-44f2-9aa4-7a362aff9f95/Work/78d4e7b9-e498-41b3-b8c1-8cc91a8385b3/Unzip/waithandle/waitany/waitanyex2a/IL:/home/helixbot/dotnetbuild/work/64020330-e696-44f2-9aa4-7a362aff9f95/Work/78d4e7b9-e498-41b3-b8c1-8cc91a8385b3/Unzip/waithandle/waitany/waitanyex2a /in waitanyex2a.org /out waitanyex2a.exe
    Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0
    Copyright (c) Microsoft Corporation.  All rights reserved.
    
    Native image waitanyex2a.exe generated successfully.
    in ReleaseLock
    in takeLock
    /home/helixbot/dotnetbuild/work/64020330-e696-44f2-9aa4-7a362aff9f95/Payload/corerun waitanyex2a.exe
    Testing Mutex and non-Mutex and signaling the other element
    Acquire the Mutex
    Holding the Mutex
    Waiting...
    WaitAny did not throw AbandonedMutexException. Result: 1
    Test Failed
    in ReleaseLock
    Expected: 100
    Actual: 255
    END EXECUTION - FAILED
    Test Harness Exitcode is : 1
    
    To run the test:
    &gt; set CORE_ROOT=/home/helixbot/dotnetbuild/work/64020330-e696-44f2-9aa4-7a362aff9f95/Payload
    &gt; /home/helixbot/dotnetbuild/work/64020330-e696-44f2-9aa4-7a362aff9f95/Work/78d4e7b9-e498-41b3-b8c1-8cc91a8385b3/Unzip/waithandle/waitany/waitanyex2a/waitanyex2a.sh
    
    Expected: True
    Actual:   False

        Stack Trace:

        
Build : 3.0 - 20180810.01 (Ready-To-Run Tests)
Failing configurations:
- ubuntu.1404.amd64
  - x64

Details: https://mc.dot.net/#/product/netcore/30/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fr2r~2Fcli~2F/build/20180810.01/workItem/baseservices.threading.XUnitWrapper/analysis/xunit/baseservices_threading._waithandle_waitany_waitanyex2a_waitanyex2a_~2F_waithandle_waitany_waitanyex2a_waitanyex2a_cmd</Description>
    <Title_Description>Test failure: baseservices_threading._waithandle_waitany_waitanyex2a_waitanyex2a_/_waithandle_waitany_waitanyex2a_waitanyex2a_cmd Opened on behalf of @Sunny-pu

The test `baseservices_threading._waithandle_waitany_waitanyex2a_waitanyex2a_/_waithandle_waitany_waitanyex2a_waitanyex2a_cmd` has failed.


    
    Return code:      1
    Raw output file:      /home/helixbot/dotnetbuild/work/64020330-e696-44f2-9aa4-7a362aff9f95/Work/78d4e7b9-e498-41b3-b8c1-8cc91a8385b3/Unzip/Reports\\baseservices.threading\\waithandle\\waitany\\waitanyex2a\\waitanyex2a.output.txt
    Raw output:
    BEGIN EXECUTION
    in takeLock
    /home/helixbot/dotnetbuild/work/64020330-e696-44f2-9aa4-7a362aff9f95/Payload/crossgen /Platform_Assemblies_Paths /home/helixbot/dotnetbuild/work/64020330-e696-44f2-9aa4-7a362aff9f95/Payload:/home/helixbot/dotnetbuild/work/64020330-e696-44f2-9aa4-7a362aff9f95/Work/78d4e7b9-e498-41b3-b8c1-8cc91a8385b3/Unzip/waithandle/waitany/waitanyex2a/IL:/home/helixbot/dotnetbuild/work/64020330-e696-44f2-9aa4-7a362aff9f95/Work/78d4e7b9-e498-41b3-b8c1-8cc91a8385b3/Unzip/waithandle/waitany/waitanyex2a /in waitanyex2a.org /out waitanyex2a.exe
    Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0
    Copyright (c) Microsoft Corporation.  All rights reserved.
    
    Native image waitanyex2a.exe generated successfully.
    in ReleaseLock
    in takeLock
    /home/helixbot/dotnetbuild/work/64020330-e696-44f2-9aa4-7a362aff9f95/Payload/corerun waitanyex2a.exe
    Testing Mutex and non-Mutex and signaling the other element
    Acquire the Mutex
    Holding the Mutex
    Waiting...
    WaitAny did not throw AbandonedMutexException. Result: 1
    Test Failed
    in ReleaseLock
    Expected: 100
    Actual: 255
    END EXECUTION - FAILED
    Test Harness Exitcode is : 1
    
    To run the test:
    &gt; set CORE_ROOT=/home/helixbot/dotnetbuild/work/64020330-e696-44f2-9aa4-7a362aff9f95/Payload
    &gt; /home/helixbot/dotnetbuild/work/64020330-e696-44f2-9aa4-7a362aff9f95/Work/78d4e7b9-e498-41b3-b8c1-8cc91a8385b3/Unzip/waithandle/waitany/waitanyex2a/waitanyex2a.sh
    
    Expected: True
    Actual:   False

        Stack Trace:

        
Build : 3.0 - 20180810.01 (Ready-To-Run Tests)
Failing configurations:
- ubuntu.1404.amd64
  - x64

Details: https://mc.dot.net/#/product/netcore/30/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fr2r~2Fcli~2F/build/20180810.01/workItem/baseservices.threading.XUnitWrapper/analysis/xunit/baseservices_threading._waithandle_waitany_waitanyex2a_waitanyex2a_~2F_waithandle_waitany_waitanyex2a_waitanyex2a_cmd</Title_Description>
    <Label>area-System.Threading</Label>
    <Assignee>kouvel</Assignee>
    <CreatedAt>10/08/2018 9:13:50 AM +00:00</CreatedAt>
    <ClosedAt>26/07/2019 1:03:14 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19405</IssueLabelID>
    <Title>Test failure: CoreMangLib_cti._system_collections_generic_dictionary_DictionaryAdd_DictionaryAdd_/_system_collections_generic_dictionary_DictionaryAdd_DictionaryAdd_cmd</Title>
    <Description>Opened on behalf of @Sunny-pu

The test `CoreMangLib_cti._system_collections_generic_dictionary_DictionaryAdd_DictionaryAdd_/_system_collections_generic_dictionary_DictionaryAdd_DictionaryAdd_cmd` has failed.

coreclr_initialize failed - status: 0x80004005
    
    
    Return code:      1
    Raw output file:      /home/helixbot/dotnetbuild/work/44e226a1-fc4e-4168-97d8-c8030a8ad273/Work/075808ac-aef4-4559-9400-c36cfddf85ed/Unzip/Reports\\CoreMangLib.cti\\system\\collections\\generic\\dictionary\\DictionaryAdd\\DictionaryAdd.output.txt
    Raw output:
    BEGIN EXECUTION
    /home/helixbot/dotnetbuild/work/44e226a1-fc4e-4168-97d8-c8030a8ad273/Payload/corerun DictionaryAdd.exe
    Expected: 100
    Actual: 255
    END EXECUTION - FAILED
    Test Harness Exitcode is : 1
    
    To run the test:
    &gt; set CORE_ROOT=/home/helixbot/dotnetbuild/work/44e226a1-fc4e-4168-97d8-c8030a8ad273/Payload
    &gt; /home/helixbot/dotnetbuild/work/44e226a1-fc4e-4168-97d8-c8030a8ad273/Work/075808ac-aef4-4559-9400-c36cfddf85ed/Unzip/system/collections/generic/dictionary/DictionaryAdd/DictionaryAdd.sh
    
    Expected: True
    Actual:   False

        Stack Trace:

        
Build : 3.0 - 20180810.01 (Core Tests)
Failing configurations:
- opensuse.423.amd64-x64
  - 

Details:
https://mc.dot.net/#/product/netcore/30/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fcli~2F/build/20180810.01/workItem/CoreMangLib.cti.XUnitWrapper/analysis/xunit/CoreMangLib_cti._system_collections_generic_dictionary_DictionaryAdd_DictionaryAdd_~2F_system_collections_generic_dictionary_DictionaryAdd_DictionaryAdd_cmd</Description>
    <Title_Description>Test failure: CoreMangLib_cti._system_collections_generic_dictionary_DictionaryAdd_DictionaryAdd_/_system_collections_generic_dictionary_DictionaryAdd_DictionaryAdd_cmd Opened on behalf of @Sunny-pu

The test `CoreMangLib_cti._system_collections_generic_dictionary_DictionaryAdd_DictionaryAdd_/_system_collections_generic_dictionary_DictionaryAdd_DictionaryAdd_cmd` has failed.

coreclr_initialize failed - status: 0x80004005
    
    
    Return code:      1
    Raw output file:      /home/helixbot/dotnetbuild/work/44e226a1-fc4e-4168-97d8-c8030a8ad273/Work/075808ac-aef4-4559-9400-c36cfddf85ed/Unzip/Reports\\CoreMangLib.cti\\system\\collections\\generic\\dictionary\\DictionaryAdd\\DictionaryAdd.output.txt
    Raw output:
    BEGIN EXECUTION
    /home/helixbot/dotnetbuild/work/44e226a1-fc4e-4168-97d8-c8030a8ad273/Payload/corerun DictionaryAdd.exe
    Expected: 100
    Actual: 255
    END EXECUTION - FAILED
    Test Harness Exitcode is : 1
    
    To run the test:
    &gt; set CORE_ROOT=/home/helixbot/dotnetbuild/work/44e226a1-fc4e-4168-97d8-c8030a8ad273/Payload
    &gt; /home/helixbot/dotnetbuild/work/44e226a1-fc4e-4168-97d8-c8030a8ad273/Work/075808ac-aef4-4559-9400-c36cfddf85ed/Unzip/system/collections/generic/dictionary/DictionaryAdd/DictionaryAdd.sh
    
    Expected: True
    Actual:   False

        Stack Trace:

        
Build : 3.0 - 20180810.01 (Core Tests)
Failing configurations:
- opensuse.423.amd64-x64
  - 

Details:
https://mc.dot.net/#/product/netcore/30/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fcli~2F/build/20180810.01/workItem/CoreMangLib.cti.XUnitWrapper/analysis/xunit/CoreMangLib_cti._system_collections_generic_dictionary_DictionaryAdd_DictionaryAdd_~2F_system_collections_generic_dictionary_DictionaryAdd_DictionaryAdd_cmd</Title_Description>
    <Label>test-run-uwp-coreclr</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>10/08/2018 9:06:53 AM +00:00</CreatedAt>
    <ClosedAt>10/08/2018 2:54:45 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19404</IssueLabelID>
    <Title>Test failure: reflection_regression._dev10bugs_Dev10_629953_Dev10_629953_/_dev10bugs_Dev10_629953_Dev10_629953_cmd</Title>
    <Description>Opened on behalf of @Sunny-pu

The test `reflection_regression._dev10bugs_Dev10_629953_Dev10_629953_/_dev10bugs_Dev10_629953_Dev10_629953_cmd` has failed.

Test Infrastructure Failure: System.TypeInitializationException: The type initializer for 'System.Diagnostics.Process' threw an exception. ---&gt; System.IO.FileNotFoundException: Could not load file or assembly 'System.Text.Encoding.Extensions Version=4.1.1.0 Culture=neutral PublicKeyToken=b03f5f7f11d50a3a'. The system cannot find the file specified.
    
       at System.Diagnostics.Process..cctor()
       --- End of inner exception stack trace ---
       at System.Diagnostics.Process.EnsureSigChildHandler()
       at System.Diagnostics.Process.StartCore(ProcessStartInfo startInfo)
       at System.Diagnostics.Process.Start()
       at CoreclrTestLib.CoreclrTestWrapperLib.RunTest(String executable String outputFile String errorFile)
       at reflection_regression._dev10bugs_Dev10_630880_Dev10_630880_._dev10bugs_Dev10_630880_Dev10_630880_cmd()
    Expected: True
    Actual:   False

        Stack Trace:

        
Build : 3.0 - 20180810.01 (Core Tests)
Failing configurations:
- opensuse.423.amd64-x64
  - 

Details:
https://mc.dot.net/#/product/netcore/30/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fcli~2F/build/20180810.01/workItem/reflection.regression.XUnitWrapper/analysis/xunit/reflection_regression._dev10bugs_Dev10_629953_Dev10_629953_~2F_dev10bugs_Dev10_629953_Dev10_629953_cmd</Description>
    <Title_Description>Test failure: reflection_regression._dev10bugs_Dev10_629953_Dev10_629953_/_dev10bugs_Dev10_629953_Dev10_629953_cmd Opened on behalf of @Sunny-pu

The test `reflection_regression._dev10bugs_Dev10_629953_Dev10_629953_/_dev10bugs_Dev10_629953_Dev10_629953_cmd` has failed.

Test Infrastructure Failure: System.TypeInitializationException: The type initializer for 'System.Diagnostics.Process' threw an exception. ---&gt; System.IO.FileNotFoundException: Could not load file or assembly 'System.Text.Encoding.Extensions Version=4.1.1.0 Culture=neutral PublicKeyToken=b03f5f7f11d50a3a'. The system cannot find the file specified.
    
       at System.Diagnostics.Process..cctor()
       --- End of inner exception stack trace ---
       at System.Diagnostics.Process.EnsureSigChildHandler()
       at System.Diagnostics.Process.StartCore(ProcessStartInfo startInfo)
       at System.Diagnostics.Process.Start()
       at CoreclrTestLib.CoreclrTestWrapperLib.RunTest(String executable String outputFile String errorFile)
       at reflection_regression._dev10bugs_Dev10_630880_Dev10_630880_._dev10bugs_Dev10_630880_Dev10_630880_cmd()
    Expected: True
    Actual:   False

        Stack Trace:

        
Build : 3.0 - 20180810.01 (Core Tests)
Failing configurations:
- opensuse.423.amd64-x64
  - 

Details:
https://mc.dot.net/#/product/netcore/30/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fcli~2F/build/20180810.01/workItem/reflection.regression.XUnitWrapper/analysis/xunit/reflection_regression._dev10bugs_Dev10_629953_Dev10_629953_~2F_dev10bugs_Dev10_629953_Dev10_629953_cmd</Title_Description>
    <Label>test-run-uwp-coreclr</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>10/08/2018 8:34:11 AM +00:00</CreatedAt>
    <ClosedAt>10/08/2018 3:00:32 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19403</IssueLabelID>
    <Title>OSX CoreFX CI Leg is Consistently Failing</Title>
    <Description>It appears that all runs of this CI leg are failing due to tests timing out: https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_debug_osx10.12_corefx_innerloop_prtest/</Description>
    <Title_Description>OSX CoreFX CI Leg is Consistently Failing It appears that all runs of this CI leg are failing due to tests timing out: https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_debug_osx10.12_corefx_innerloop_prtest/</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>10/08/2018 4:23:05 AM +00:00</CreatedAt>
    <ClosedAt>16/08/2018 11:40:10 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19402</IssueLabelID>
    <Title>Run DotNet Core App on X86 Without OS</Title>
    <Description>How to run DotNet Core app on X86 without OS?</Description>
    <Title_Description>Run DotNet Core App on X86 Without OS How to run DotNet Core app on X86 without OS?</Title_Description>
    <Label>question</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>10/08/2018 3:34:18 AM +00:00</CreatedAt>
    <ClosedAt>15/08/2018 1:43:28 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19401</IssueLabelID>
    <Title>update order of locks so gcstress is unblocked</Title>
    <Description>
    </Description>
    <Title_Description>update order of locks so gcstress is unblocked </Title_Description>
    <Label>
    </Label>
    <Assignee>davmason</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19400</IssueLabelID>
    <Title>Track conversion of Intel Hardware Intrinsics tests to generated format</Title>
    <Description>This is an umbrella issue to track progress of conversion of all tests as detailed in #19245 and #19246


### Avx
 [ ]  Blend
 [ ]  BroadcastScalarToVector128
 [ ]  BroadcastScalarToVector256
 [ ]  BroadcastVector128ToVector256
 [ ]  CompareScalar
 [ ]  Compare
 [ ]  ConvertToSingle
 [ ]  ConvertToVector
 [ ]  DotProduct
 [ ]  HorizontalAdd
 [ ]  HorizontalSubtract
 [ ]  InsertExtractVector128
 [ ]  LoadAlignedVector256
 [ ]  LoadDquVector256
 [ ]  LoadVector256
 [ ]  MaskLoad
 [ ]  MoveMask
 [ ]  Permute2x128.Avx
 [ ]  SetAllVector256
 [ ]  SetVector256
 [ ]  SetZeroVector256
 [ ]  Sqrt
 [ ]  StaticCast
 [ ]  StoreAlignedNonTemporal
 [ ]  StoreAligned
 [ ]  Store
 [ ]  UnpackHigh
 [ ]  UnpackLow

### Avx2
 [ ]  AddSaturate
 [ ]  BroadcastVector128ToVector256
 [ ]  ConvertToVector256
 [ ]  HorizontalAdd
 [ ]  HorizontalSubtract
 [ ]  LoadAlignedVector256NonTemporal
 [ ]  MoveMask
 [ ]  Multiply
 [ ]  ShiftLeftLogicalVariable
 [ ]  ShiftRightLogicalVariable
 [ ]  SubtractSaturate
 [ ]  UnpackHigh
 [ ]  UnpackLow

### Sse
 [ ]  ConvertScalarToVector128Single
 [ ]  ConvertToInt32WithTruncation #19998
 [ ]  ConvertToInt32 #19998
 [ ]  ConvertToInt64WithTruncation #19998
 [ ]  ConvertToInt64 #19998
 [ ]  ConvertToSingle #19998
 [ ]  LoadAlignedVector128
 [ ]  LoadHigh
 [ ]  LoadLow
 [ ]  LoadScalarVector128
 [ ]  LoadVector128
 [ ]  MoveHighToLow
 [ ]  MoveLowToHigh
 [ ]  MoveMask
 [ ]  MoveScalar
 [ ]  Prefetch
 [ ]  ReciprocalScalar
 [ ]  ReciprocalSqrtScalar
 [ ]  ReciprocalSqrt
 [ ]  Reciprocal
 [ ]  SetAllVector128
 [ ]  SetScalarVector128
 [ ]  SetVector128
 [ ]  SetZeroVector128
 [ ]  Shuffle
 [ ]  SqrtScalar
 [ ]  Sqrt
 [ ]  StaticCast
 [ ]  StoreAlignedNonTemporal
 [ ]  StoreAligned
 [ ]  StoreFence
 [ ]  StoreHigh
 [ ]  StoreLow
 [ ]  StoreScalar
 [ ]  Store
 [ ]  UnpackHigh
 [ ]  UnpackLow

### Sse2
 [x]  CompareEqualOrderedScalar #19673
 [x]  CompareEqualScalar #19673
 [x]  CompareEqualUnorderedScalar #19673
 [x]  CompareGreaterThanOrderedScalar #19673
 [x]  CompareGreaterThanOrEqualOrderedScalar #19673
 [x]  CompareGreaterThanOrEqualScalar #19673
 [x]  CompareGreaterThanOrEqualUnorderedScalar #19673
 [x]  CompareGreaterThanScalar #19673
 [x]  CompareGreaterThanUnorderedScalar #19673
 [x]  CompareLessThanOrderedScalar #19673
 [x]  CompareLessThanOrEqualOrderedScalar #19673
 [x]  CompareLessThanOrEqualScalar #19673
 [x]  CompareLessThanOrEqualUnorderedScalar #19673
 [x]  CompareLessThanScalar #19673
 [x]  CompareLessThanUnorderedScalar #19673
 [x]  CompareNotEqualOrderedScalar #19673
 [x]  CompareNotEqualScalar #19673
 [x]  CompareNotEqualUnorderedScalar #19673
 [x]  CompareNotGreaterThanOrEqualScalar #19673
 [x]  CompareNotGreaterThanScalar #19673
 [x]  CompareNotLessThanOrEqualScalar #19673
 [x]  CompareNotLessThanScalar #19673
 [x]  CompareOrderedScalar #19673
 [x]  CompareUnorderedScalar #19673
 [ ]  ConvertScalarToVector128Double
 [ ]  ConvertScalarToVector128Int32 #19998
 [ ]  ConvertScalarToVector128Int64 #19998
 [ ]  ConvertScalarToVector128Single
 [ ]  ConvertScalarToVector128UInt32 #19998
 [ ]  ConvertScalarToVector128UInt64 #19998
 [x]  ConvertToDouble #19677 
 [x]  ConvertToInt32WithTruncation #19677
 [x]  ConvertToInt32 #19677
 [x]  ConvertToInt64WithTruncation #19677
 [x]  ConvertToInt64 #19677
 [x]  ConvertToUInt32 #19677
 [x]  ConvertToUInt64 #19677
 [x]  ConvertToVector128Double #19677
 [x]  ConvertToVector128Int32WithTruncation #19677
 [x]  ConvertToVector128Int32 #19677
 [x]  ConvertToVector128Single #19677
 [ ]  LoadAlignedVector128
 [ ]  LoadFence
 [ ]  LoadHigh
 [ ]  LoadLow
 [ ]  LoadScalarVector128
 [ ]  LoadVector128
 [ ]  MaskMove
 [ ]  MemoryFence
 [ ]  MoveMask
 [ ]  MoveScalar.Int64
 [ ]  MoveScalar.UInt64
 [ ]  MoveScalar
 [ ]  MultiplyHigh
 [ ]  MultiplyHorizontalAdd
 [ ]  MultiplyLow
 [ ]  Multiply
 [ ]  PackSignedSaturate #19670
 [ ]  PackUnsignedSaturate #19670
 [ ]  SetScalarVector128
 [ ]  SetVector128
 [ ]  SetZeroVector128
 [ ]  ShuffleHigh
 [ ]  ShuffleLow
 [ ]  Shuffle
 [ ]  SqrtScalar
 [ ]  Sqrt
 [ ]  StoreAlignedNonTemporal
 [ ]  StoreAligned
 [ ]  StoreHigh
 [ ]  StoreLow
 [ ]  StoreNonTemporal
 [ ]  StoreScalar
 [ ]  Store
 [ ]  SumAbsoluteDifferences
 [ ]  UnpackHigh #19670
 [ ]  UnpackLow #19670

### Sse3
 [ ]  LoadAndDuplicateToVector128
 [ ]  LoadDquVector128
 [ ]  MoveAndDuplicate
 [ ]  MoveHighAndDuplicate
 [ ]  MoveLowAndDuplicate

### Sse41
 [ ]  Blend
 [ ]  ConvertToVector128
 [ ]  DotProduct
 [ ]  LoadAlignedVector128NonTemporal
 [ ]  MinHorizontal
 [ ]  MultipleSumAbsoluteDifferences
 [ ]  Multiply

### Sse42
 [ ]  Crc32

### Ssse3
 [ ]  AlignRight
</Description>
    <Title_Description>Track conversion of Intel Hardware Intrinsics tests to generated format This is an umbrella issue to track progress of conversion of all tests as detailed in #19245 and #19246


### Avx
 [ ]  Blend
 [ ]  BroadcastScalarToVector128
 [ ]  BroadcastScalarToVector256
 [ ]  BroadcastVector128ToVector256
 [ ]  CompareScalar
 [ ]  Compare
 [ ]  ConvertToSingle
 [ ]  ConvertToVector
 [ ]  DotProduct
 [ ]  HorizontalAdd
 [ ]  HorizontalSubtract
 [ ]  InsertExtractVector128
 [ ]  LoadAlignedVector256
 [ ]  LoadDquVector256
 [ ]  LoadVector256
 [ ]  MaskLoad
 [ ]  MoveMask
 [ ]  Permute2x128.Avx
 [ ]  SetAllVector256
 [ ]  SetVector256
 [ ]  SetZeroVector256
 [ ]  Sqrt
 [ ]  StaticCast
 [ ]  StoreAlignedNonTemporal
 [ ]  StoreAligned
 [ ]  Store
 [ ]  UnpackHigh
 [ ]  UnpackLow

### Avx2
 [ ]  AddSaturate
 [ ]  BroadcastVector128ToVector256
 [ ]  ConvertToVector256
 [ ]  HorizontalAdd
 [ ]  HorizontalSubtract
 [ ]  LoadAlignedVector256NonTemporal
 [ ]  MoveMask
 [ ]  Multiply
 [ ]  ShiftLeftLogicalVariable
 [ ]  ShiftRightLogicalVariable
 [ ]  SubtractSaturate
 [ ]  UnpackHigh
 [ ]  UnpackLow

### Sse
 [ ]  ConvertScalarToVector128Single
 [ ]  ConvertToInt32WithTruncation #19998
 [ ]  ConvertToInt32 #19998
 [ ]  ConvertToInt64WithTruncation #19998
 [ ]  ConvertToInt64 #19998
 [ ]  ConvertToSingle #19998
 [ ]  LoadAlignedVector128
 [ ]  LoadHigh
 [ ]  LoadLow
 [ ]  LoadScalarVector128
 [ ]  LoadVector128
 [ ]  MoveHighToLow
 [ ]  MoveLowToHigh
 [ ]  MoveMask
 [ ]  MoveScalar
 [ ]  Prefetch
 [ ]  ReciprocalScalar
 [ ]  ReciprocalSqrtScalar
 [ ]  ReciprocalSqrt
 [ ]  Reciprocal
 [ ]  SetAllVector128
 [ ]  SetScalarVector128
 [ ]  SetVector128
 [ ]  SetZeroVector128
 [ ]  Shuffle
 [ ]  SqrtScalar
 [ ]  Sqrt
 [ ]  StaticCast
 [ ]  StoreAlignedNonTemporal
 [ ]  StoreAligned
 [ ]  StoreFence
 [ ]  StoreHigh
 [ ]  StoreLow
 [ ]  StoreScalar
 [ ]  Store
 [ ]  UnpackHigh
 [ ]  UnpackLow

### Sse2
 [x]  CompareEqualOrderedScalar #19673
 [x]  CompareEqualScalar #19673
 [x]  CompareEqualUnorderedScalar #19673
 [x]  CompareGreaterThanOrderedScalar #19673
 [x]  CompareGreaterThanOrEqualOrderedScalar #19673
 [x]  CompareGreaterThanOrEqualScalar #19673
 [x]  CompareGreaterThanOrEqualUnorderedScalar #19673
 [x]  CompareGreaterThanScalar #19673
 [x]  CompareGreaterThanUnorderedScalar #19673
 [x]  CompareLessThanOrderedScalar #19673
 [x]  CompareLessThanOrEqualOrderedScalar #19673
 [x]  CompareLessThanOrEqualScalar #19673
 [x]  CompareLessThanOrEqualUnorderedScalar #19673
 [x]  CompareLessThanScalar #19673
 [x]  CompareLessThanUnorderedScalar #19673
 [x]  CompareNotEqualOrderedScalar #19673
 [x]  CompareNotEqualScalar #19673
 [x]  CompareNotEqualUnorderedScalar #19673
 [x]  CompareNotGreaterThanOrEqualScalar #19673
 [x]  CompareNotGreaterThanScalar #19673
 [x]  CompareNotLessThanOrEqualScalar #19673
 [x]  CompareNotLessThanScalar #19673
 [x]  CompareOrderedScalar #19673
 [x]  CompareUnorderedScalar #19673
 [ ]  ConvertScalarToVector128Double
 [ ]  ConvertScalarToVector128Int32 #19998
 [ ]  ConvertScalarToVector128Int64 #19998
 [ ]  ConvertScalarToVector128Single
 [ ]  ConvertScalarToVector128UInt32 #19998
 [ ]  ConvertScalarToVector128UInt64 #19998
 [x]  ConvertToDouble #19677 
 [x]  ConvertToInt32WithTruncation #19677
 [x]  ConvertToInt32 #19677
 [x]  ConvertToInt64WithTruncation #19677
 [x]  ConvertToInt64 #19677
 [x]  ConvertToUInt32 #19677
 [x]  ConvertToUInt64 #19677
 [x]  ConvertToVector128Double #19677
 [x]  ConvertToVector128Int32WithTruncation #19677
 [x]  ConvertToVector128Int32 #19677
 [x]  ConvertToVector128Single #19677
 [ ]  LoadAlignedVector128
 [ ]  LoadFence
 [ ]  LoadHigh
 [ ]  LoadLow
 [ ]  LoadScalarVector128
 [ ]  LoadVector128
 [ ]  MaskMove
 [ ]  MemoryFence
 [ ]  MoveMask
 [ ]  MoveScalar.Int64
 [ ]  MoveScalar.UInt64
 [ ]  MoveScalar
 [ ]  MultiplyHigh
 [ ]  MultiplyHorizontalAdd
 [ ]  MultiplyLow
 [ ]  Multiply
 [ ]  PackSignedSaturate #19670
 [ ]  PackUnsignedSaturate #19670
 [ ]  SetScalarVector128
 [ ]  SetVector128
 [ ]  SetZeroVector128
 [ ]  ShuffleHigh
 [ ]  ShuffleLow
 [ ]  Shuffle
 [ ]  SqrtScalar
 [ ]  Sqrt
 [ ]  StoreAlignedNonTemporal
 [ ]  StoreAligned
 [ ]  StoreHigh
 [ ]  StoreLow
 [ ]  StoreNonTemporal
 [ ]  StoreScalar
 [ ]  Store
 [ ]  SumAbsoluteDifferences
 [ ]  UnpackHigh #19670
 [ ]  UnpackLow #19670

### Sse3
 [ ]  LoadAndDuplicateToVector128
 [ ]  LoadDquVector128
 [ ]  MoveAndDuplicate
 [ ]  MoveHighAndDuplicate
 [ ]  MoveLowAndDuplicate

### Sse41
 [ ]  Blend
 [ ]  ConvertToVector128
 [ ]  DotProduct
 [ ]  LoadAlignedVector128NonTemporal
 [ ]  MinHorizontal
 [ ]  MultipleSumAbsoluteDifferences
 [ ]  Multiply

### Sse42
 [ ]  Crc32

### Ssse3
 [ ]  AlignRight
</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>fiigii</Assignee>
    <CreatedAt>10/08/2018 1:46:20 AM +00:00</CreatedAt>
    <ClosedAt>20/09/2019 10:47:02 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19398</IssueLabelID>
    <Title>[dev/unix_test_workflow] Add crossgen_comparison job</Title>
    <Description>
    </Description>
    <Title_Description>[dev/unix_test_workflow] Add crossgen_comparison job </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>echesakovMSFT</Assignee>
    <CreatedAt>10/08/2018 12:43:54 AM +00:00</CreatedAt>
    <ClosedAt>10/08/2018 10:05:43 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19397</IssueLabelID>
    <Title>Assertion failed 'op1-&gt;OperGet() == GT_LONG || op1-&gt;OperGet() == GT_MUL_LONG'</Title>
    <Description>x86 Checked Windows CoreFX JitStressRegs=8

https://ci.dot.net/job/dotnet_coreclr/job/master/view/x86/job/jitstress/job/x86_checked_windows_nt_corefx_jitstressregs8/554/consoleText

hundreds of instances of:
```
  Assert failure(PID 2868 [0x00000b34] Thread: 2232 [0x08b8]): Assertion failed 'op1-&gt;OperGet() == GT_LONG || op1-&gt;OperGet() == GT_MUL_LONG' in 'System.Text.OSEncoding:GetMaxByteCount(int):int:this' (IL size 55)
  
      File: d:\j\workspace\x86_checked_w---fb0ba759\src\jit\codegenxarch.cpp Line: 8653
      Image: D:\j\workspace\x86_checked_w---fb0ba759\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-x86\dotnet.exe
```

This has been failing for a while.

@dotnet/jit-contrib </Description>
    <Title_Description>Assertion failed 'op1-&gt;OperGet() == GT_LONG || op1-&gt;OperGet() == GT_MUL_LONG' x86 Checked Windows CoreFX JitStressRegs=8

https://ci.dot.net/job/dotnet_coreclr/job/master/view/x86/job/jitstress/job/x86_checked_windows_nt_corefx_jitstressregs8/554/consoleText

hundreds of instances of:
```
  Assert failure(PID 2868 [0x00000b34] Thread: 2232 [0x08b8]): Assertion failed 'op1-&gt;OperGet() == GT_LONG || op1-&gt;OperGet() == GT_MUL_LONG' in 'System.Text.OSEncoding:GetMaxByteCount(int):int:this' (IL size 55)
  
      File: d:\j\workspace\x86_checked_w---fb0ba759\src\jit\codegenxarch.cpp Line: 8653
      Image: D:\j\workspace\x86_checked_w---fb0ba759\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-x86\dotnet.exe
```

This has been failing for a while.

@dotnet/jit-contrib </Title_Description>
    <Label>arch-x86</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19388</IssueLabelID>
    <Title>WIP NO-MERGE Dummy test for dev/unix_test_workflow change of build VMs</Title>
    <Description>
    </Description>
    <Title_Description>WIP NO-MERGE Dummy test for dev/unix_test_workflow change of build VMs </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>9/08/2018 7:27:05 PM +00:00</CreatedAt>
    <ClosedAt>13/08/2018 10:28:46 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19386</IssueLabelID>
    <Title>[Win/Infrastructure] Regression introduced by #19324 - removed parallel msbuild for tests</Title>
    <Description>PR #19324 lost default MSBuild argument  /maxcpucount which enabled parallel MSBuild test build. Build time on my laptop increased 2x.

cc @AaronRobinsonMSFT </Description>
    <Title_Description>[Win/Infrastructure] Regression introduced by #19324 - removed parallel msbuild for tests PR #19324 lost default MSBuild argument  /maxcpucount which enabled parallel MSBuild test build. Build time on my laptop increased 2x.

cc @AaronRobinsonMSFT </Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>9/08/2018 7:06:27 PM +00:00</CreatedAt>
    <ClosedAt>10/08/2018 6:10:22 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19384</IssueLabelID>
    <Title>Fix a couple of apartment state issues</Title>
    <Description>Fix for https://github.com/dotnet/coreclr/issues/17822
- The apartment state now defaults to MTA for the main thread along with a CoInitialize
- Calling `Thread.SetApartmentState` with STA now fails as expected (different behavior from previous netcore same behavior as netfx)

Fix for https://github.com/dotnet/coreclr/issues/17787
- `WaitHandle.WaitAll` for multiple handles is not supported on an STA thread due to issues described in https://github.com/dotnet/coreclr/issues/17787#issuecomment-385117537
- It now throws `NotSupportedException` as expected (different behavior from previous netcore same behavior as netfx)

Fix for https://github.com/dotnet/coreclr/issues/19225</Description>
    <Title_Description>Fix a couple of apartment state issues Fix for https://github.com/dotnet/coreclr/issues/17822
- The apartment state now defaults to MTA for the main thread along with a CoInitialize
- Calling `Thread.SetApartmentState` with STA now fails as expected (different behavior from previous netcore same behavior as netfx)

Fix for https://github.com/dotnet/coreclr/issues/17787
- `WaitHandle.WaitAll` for multiple handles is not supported on an STA thread due to issues described in https://github.com/dotnet/coreclr/issues/17787#issuecomment-385117537
- It now throws `NotSupportedException` as expected (different behavior from previous netcore same behavior as netfx)

Fix for https://github.com/dotnet/coreclr/issues/19225</Title_Description>
    <Label>area-System.Threading</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19381</IssueLabelID>
    <Title>Introduce reinterpret in Span&lt;T&gt;</Title>
    <Description>Hello

I know that there are discussions around Span&lt;T&gt; and having a reinterpret. I'm not quite sure though if this means if there is an explicit method for this or if it will be implicit. So maybe you can point me in some direction with the code below and if Span&lt;T&gt; will support it:

I have a filestream where I read my data. Unfortunately there is no ReadArray&lt;T&gt; but only a ReadBytes().
For that reason I have currently following code.

```
 /// &lt;summary&gt;
        /// Reads an array of "count" Int32 values
        /// &lt;/summary&gt;
        /// &lt;param name="stream_in"&gt;&lt;/param&gt;
        /// &lt;param name="count_in"&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static T[] Read&lt;T&gt;( Stream stream_in int? count_in = null )
        {
            if (stream_in == null)
                throw new ArgumentNullException(nameof(stream_in));

            int aElementCount = count_in ?? count_in.GetValueOrDefault( GetSize( stream_in ) );

            if( aElementCount == 0 )
                return Array.Empty&lt;T&gt;();

            // Get the size of the data
            int aBytesToRead = aElementCount * mySize;

            // Read the byte stream.
            byte[] aReadBytes = MemoryManager.AllocMem&lt;byte&gt;( aBytesToRead );
            stream_in.Read(aReadBytes 0 aBytesToRead);

            GCHandle aHandle = new GCHandle();

            try
            {
                T[] aData = MemoryManager.AllocMem&lt;T&gt;( aElementCount );
                aHandle = GCHandle.Alloc( aData GCHandleType.Pinned );

                // Copy the byte stream into the target array.
                Marshal.Copy( aReadBytes 0 aHandle.AddrOfPinnedObject() aReadBytes.Length );

                return aData;
            }
            finally
            {
                if( aHandle.IsAllocated )
                    aHandle.Free();
            }
        }
```

The bad thing about this that I have to copy memory on and on again and also allocate the memory twice. So it would be nice to have something like the code below without having to copy the array but to reinterpret it.

```
     public static Span&lt;T&gt; Read&lt;T&gt;( Stream stream_in int? count_in = null )
        {
            if (stream_in == null)
                throw new ArgumentNullException(nameof(stream_in));

            int aElementCount = count_in ?? count_in.GetValueOrDefault( GetSize( stream_in ) );

            if( aElementCount == 0 )
                return Array.Empty&lt;T&gt;();

            // Get the size of the data
            int aBytesToRead = aElementCount * mySize;

            // Read the byte stream.
            byte[] aReadBytes = MemoryManager.AllocMem&lt;byte&gt;( aBytesToRead );
            stream_in.Read(aReadBytes 0 aBytesToRead);
      
            return Span&lt;T&gt;(aReadBytes);   
        }
```

Are there any plans or suggestions?</Description>
    <Title_Description>Introduce reinterpret in Span&lt;T&gt; Hello

I know that there are discussions around Span&lt;T&gt; and having a reinterpret. I'm not quite sure though if this means if there is an explicit method for this or if it will be implicit. So maybe you can point me in some direction with the code below and if Span&lt;T&gt; will support it:

I have a filestream where I read my data. Unfortunately there is no ReadArray&lt;T&gt; but only a ReadBytes().
For that reason I have currently following code.

```
 /// &lt;summary&gt;
        /// Reads an array of "count" Int32 values
        /// &lt;/summary&gt;
        /// &lt;param name="stream_in"&gt;&lt;/param&gt;
        /// &lt;param name="count_in"&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static T[] Read&lt;T&gt;( Stream stream_in int? count_in = null )
        {
            if (stream_in == null)
                throw new ArgumentNullException(nameof(stream_in));

            int aElementCount = count_in ?? count_in.GetValueOrDefault( GetSize( stream_in ) );

            if( aElementCount == 0 )
                return Array.Empty&lt;T&gt;();

            // Get the size of the data
            int aBytesToRead = aElementCount * mySize;

            // Read the byte stream.
            byte[] aReadBytes = MemoryManager.AllocMem&lt;byte&gt;( aBytesToRead );
            stream_in.Read(aReadBytes 0 aBytesToRead);

            GCHandle aHandle = new GCHandle();

            try
            {
                T[] aData = MemoryManager.AllocMem&lt;T&gt;( aElementCount );
                aHandle = GCHandle.Alloc( aData GCHandleType.Pinned );

                // Copy the byte stream into the target array.
                Marshal.Copy( aReadBytes 0 aHandle.AddrOfPinnedObject() aReadBytes.Length );

                return aData;
            }
            finally
            {
                if( aHandle.IsAllocated )
                    aHandle.Free();
            }
        }
```

The bad thing about this that I have to copy memory on and on again and also allocate the memory twice. So it would be nice to have something like the code below without having to copy the array but to reinterpret it.

```
     public static Span&lt;T&gt; Read&lt;T&gt;( Stream stream_in int? count_in = null )
        {
            if (stream_in == null)
                throw new ArgumentNullException(nameof(stream_in));

            int aElementCount = count_in ?? count_in.GetValueOrDefault( GetSize( stream_in ) );

            if( aElementCount == 0 )
                return Array.Empty&lt;T&gt;();

            // Get the size of the data
            int aBytesToRead = aElementCount * mySize;

            // Read the byte stream.
            byte[] aReadBytes = MemoryManager.AllocMem&lt;byte&gt;( aBytesToRead );
            stream_in.Read(aReadBytes 0 aBytesToRead);
      
            return Span&lt;T&gt;(aReadBytes);   
        }
```

Are there any plans or suggestions?</Title_Description>
    <Label>area-System.Memory</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>9/08/2018 3:53:00 PM +00:00</CreatedAt>
    <ClosedAt>9/08/2018 5:33:23 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19376</IssueLabelID>
    <Title>CoreClr failed to build on Windows due to MSBUILD ERROR : error MSB1001: Unknown switch. Switch: --</Title>
    <Description>Hello
I am testing CoreCLR on Windows with VS 2017 15.7.2. It failed due to the "error MSB1001: Unknown switch. Switch: --". It casued by commit:https://github.com/dotnet/coreclr/commit/b37c6d8ee5b4ad9833f21cfc30582b56797e37b4.
I noticed you removed '--' on purpose I am surprised why does not support '--' to add  extra MSBUILD options? Is there other way that we can add extra MSBUILD flags when building source!

You can repro the issue as the steps below:
1. git clone https://github.com/dotnet/coreclr D:\CoreCLR\src
2. Open a clean x86 prompt (C:\windows\syswow64\cmd.exe) and browse to D:\CoreCLR\src
3. build x86 release -- /clp:ShowCommandLine

Could you please give me a workaround for this or consider rollback this to use '--' when building?
Thank you!</Description>
    <Title_Description>CoreClr failed to build on Windows due to MSBUILD ERROR : error MSB1001: Unknown switch. Switch: -- Hello
I am testing CoreCLR on Windows with VS 2017 15.7.2. It failed due to the "error MSB1001: Unknown switch. Switch: --". It casued by commit:https://github.com/dotnet/coreclr/commit/b37c6d8ee5b4ad9833f21cfc30582b56797e37b4.
I noticed you removed '--' on purpose I am surprised why does not support '--' to add  extra MSBUILD options? Is there other way that we can add extra MSBUILD flags when building source!

You can repro the issue as the steps below:
1. git clone https://github.com/dotnet/coreclr D:\CoreCLR\src
2. Open a clean x86 prompt (C:\windows\syswow64\cmd.exe) and browse to D:\CoreCLR\src
3. build x86 release -- /clp:ShowCommandLine

Could you please give me a workaround for this or consider rollback this to use '--' when building?
Thank you!</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>BruceForstall</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19374</IssueLabelID>
    <Title>[Question] Strange behavior when loading assemblies and its dependencies programatically</Title>
    <Description>Not sure if it's a bug I asked on SO but it seems no one has idea on it. [Question](https://stackoverflow.com/questions/51738633/strange-behavior-when-loading-assemblies-and-its-dependencies-programatically)</Description>
    <Title_Description>[Question] Strange behavior when loading assemblies and its dependencies programatically Not sure if it's a bug I asked on SO but it seems no one has idea on it. [Question](https://stackoverflow.com/questions/51738633/strange-behavior-when-loading-assemblies-and-its-dependencies-programatically)</Title_Description>
    <Label>area-AssemblyLoader</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>9/08/2018 3:50:23 AM +00:00</CreatedAt>
    <ClosedAt>10/08/2018 10:25:24 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19370</IssueLabelID>
    <Title>JIT generates binary different code in x86_arm and arm_arm due to host NaN representation</Title>
    <Description>It seems that assumption that two crossgens (x86_arm and arm_arm) generate binary identical code is not 100% true. 
I encountered this for `Microsoft.VisualBasic.dll` - produced native images were different in one **bit**! (ignoring mismatching checksums). 

The divergence happens during ` Microsoft.VisualBasic.CompilerServices.Operators:DivideObject(refref):ref` method compilation.

The "interesting" place in x86_arm disassembly:
```asm
00008A  2200           movs    r2 0
00008C  F240 0300      movw    r3 0x00
000090  F6CF 73F8      movt    r3 0xfff8
000094  EC43 2B14      vmov.i2d d8 r2 r3
000098  ED80 4B01      vstr    d8 [r0+4]
```

The corresponding place in arm_arm disassembly:
```asm
00008A  2200           movs    r2 0
00008C  F240 0300      movw    r3 0x00
000090  F6C7 73F8      movt    r3 0x7ff8
000094  EC43 2B14      vmov.i2d d8 r2 r3
000098  ED80 4B01      vstr    d8 [r0+4]
```

The code is the compiled following expression 
```C#
double cnsZero = 0.0;
double cnsNaN = cnsZero / cnsZero;
```

During its compilation JIT in `fgValueNumber()` relies on the following function
https://github.com/dotnet/coreclr/blob/d1804ad5634ef85d88b52331b99b1f58626dacf2/src/jit/valuenum.cpp#L248-L270 
which on Linux/x86 host for `v1 / v2` where `v1=0.0` and `v2=0.0` returns `fff8 0000 0000 0000` while on arm host the result is `7ff8 0000 0000 0000`. 

While semantically they both are correct this would cause us a problem with validation of cross-bitness crossgen work in the future. 

The workaround for this could be similar to how https://github.com/dotnet/coreclr/blob/d1804ad5634ef85d88b52331b99b1f58626dacf2/src/jit/valuenum.cpp#L227 is implemented and use "custom" implementation for double/float division
```c++
TFp FpDiv(TFp dividend TFp divisor)
{
    // From the ECMA standard:
    //
    // If [dividend] is zero and [divisor] is zero
    //   the result is NaN.
    // If [dividend] is infinity and [divisor] is infinity
    //   the result is NaN.

    if (dividend == 0 &amp;&amp; divisor == 0)
    {
        return TFpTraits::NaN();
    }
    else if (!_finite(dividend) &amp;&amp; !_isnan(dividend) &amp;&amp; !_finite(divisor) &amp;&amp; !_isnan(divisor))
    {
        return TFpTraits::NaN();
    }

    return dividend / divisor;
}
```

@dotnet/jit-contrib Is there any better idea how to approach this issue?</Description>
    <Title_Description>JIT generates binary different code in x86_arm and arm_arm due to host NaN representation It seems that assumption that two crossgens (x86_arm and arm_arm) generate binary identical code is not 100% true. 
I encountered this for `Microsoft.VisualBasic.dll` - produced native images were different in one **bit**! (ignoring mismatching checksums). 

The divergence happens during ` Microsoft.VisualBasic.CompilerServices.Operators:DivideObject(refref):ref` method compilation.

The "interesting" place in x86_arm disassembly:
```asm
00008A  2200           movs    r2 0
00008C  F240 0300      movw    r3 0x00
000090  F6CF 73F8      movt    r3 0xfff8
000094  EC43 2B14      vmov.i2d d8 r2 r3
000098  ED80 4B01      vstr    d8 [r0+4]
```

The corresponding place in arm_arm disassembly:
```asm
00008A  2200           movs    r2 0
00008C  F240 0300      movw    r3 0x00
000090  F6C7 73F8      movt    r3 0x7ff8
000094  EC43 2B14      vmov.i2d d8 r2 r3
000098  ED80 4B01      vstr    d8 [r0+4]
```

The code is the compiled following expression 
```C#
double cnsZero = 0.0;
double cnsNaN = cnsZero / cnsZero;
```

During its compilation JIT in `fgValueNumber()` relies on the following function
https://github.com/dotnet/coreclr/blob/d1804ad5634ef85d88b52331b99b1f58626dacf2/src/jit/valuenum.cpp#L248-L270 
which on Linux/x86 host for `v1 / v2` where `v1=0.0` and `v2=0.0` returns `fff8 0000 0000 0000` while on arm host the result is `7ff8 0000 0000 0000`. 

While semantically they both are correct this would cause us a problem with validation of cross-bitness crossgen work in the future. 

The workaround for this could be similar to how https://github.com/dotnet/coreclr/blob/d1804ad5634ef85d88b52331b99b1f58626dacf2/src/jit/valuenum.cpp#L227 is implemented and use "custom" implementation for double/float division
```c++
TFp FpDiv(TFp dividend TFp divisor)
{
    // From the ECMA standard:
    //
    // If [dividend] is zero and [divisor] is zero
    //   the result is NaN.
    // If [dividend] is infinity and [divisor] is infinity
    //   the result is NaN.

    if (dividend == 0 &amp;&amp; divisor == 0)
    {
        return TFpTraits::NaN();
    }
    else if (!_finite(dividend) &amp;&amp; !_isnan(dividend) &amp;&amp; !_finite(divisor) &amp;&amp; !_isnan(divisor))
    {
        return TFpTraits::NaN();
    }

    return dividend / divisor;
}
```

@dotnet/jit-contrib Is there any better idea how to approach this issue?</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>echesakovMSFT</Assignee>
    <CreatedAt>8/08/2018 10:21:54 PM +00:00</CreatedAt>
    <ClosedAt>20/08/2018 5:18:18 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19368</IssueLabelID>
    <Title>[RyuJIT/arm64] Implement ELT hooks</Title>
    <Description>It looks like genProfilingEnterCallback and genProfilingLeaveCallback will NYI on arm64.
</Description>
    <Title_Description>[RyuJIT/arm64] Implement ELT hooks It looks like genProfilingEnterCallback and genProfilingLeaveCallback will NYI on arm64.
</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>echesakovMSFT</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19361</IssueLabelID>
    <Title>Segfault in libcoreclr.so</Title>
    <Description>I'm experiencing a segmentation fault on .NET Core 2 on Linux/docker under versions 2.1.2 and 2.0.9 when my process is under heavy load and using a lot of memory. 

I haven't tried to reproduce outside of Linux/docker but I have reproduced on both AWS Kubernetes and my local Docker for Windows with identical stack traces.

Here are some details from capturing the segfault under the debugger:

```
Process 1608 stopped
* thread #54: tid = 1664 0x00007fff821131b3 name = 'dotnet' stop reason = signal SIGSEGV: address access protected (fault address: 0x7ffd217b05c8)
    frame #0: 0x00007fff821131b3
-&gt;  0x7fff821131b3: rep
    0x7fff821131b4: movsq  (%rsi) %es:(%rdi)
    0x7fff821131b6: incl   0x8(%rbx)
    0x7fff821131b9: movl   $0x1 %eax

(lldb) clrstack
OS Thread Id: 0x680 (54)
        Child SP               IP Call Site
00007FFB5AFFA850 00007FFF821131B3 System.Collections.Generic.List`1+Enumerator[[System.ValueTuple`3[[System.DateTime System.Private.CoreLib][Ist.Terraform.TimeSeries.CompositeCalc.CompositeSource Ist.Terraform.TimeSeries][System.Decimal System.Private.CoreLib]] System.Private.CoreLib]].MoveNext() [/root/coreclr/src/mscorlib/shared/System/Collections/Generic/List.cs @ 1139]
00007FFB5AFFA870 00007FFF82112F6B System.Linq.Enumerable.Min[[System.ValueTuple`3[[System.DateTime System.Private.CoreLib][Ist.Terraform.TimeSeries.CompositeCalc.CompositeSource Ist.Terraform.TimeSeries][System.Decimal System.Private.CoreLib]] System.Private.CoreLib][System.DateTime System.Private.CoreLib]](System.Collections.Generic.IEnumerable`1&lt;System.ValueTuple`3&lt;System.DateTimeIst.Terraform.TimeSeries.CompositeCalc.CompositeSourceSystem.Decimal&gt;&gt; System.Func`2&lt;System.ValueTuple`3&lt;System.DateTimeIst.Terraform.TimeSeries.CompositeCalc.CompositeSourceSystem.Decimal&gt;System.DateTime&gt;) [/root/corefx-1818530/src/System.Linq/src/System/Linq/Min.cs @ 910]
00007FFB5AFFA990 00007FFF82112CE4 Ist.Terraform.TimeSeries.CompositeCalc.Portfolio.PortfolioBuyHoldReturnCalc+&lt;&gt;c__DisplayClass23_0.&lt;.ctor&gt;b__9(System.ValueTuple`3&lt;System.DateTimeIst.Terraform.TimeSeries.CompositeCalc.CompositeSourceSystem.Decimal&gt;)
00007FFB5AFFA9D0 00007FFF82112B6A System.Linq.Enumerable+WhereListIterator`1[[System.ValueTuple`3[[System.DateTime System.Private.CoreLib][Ist.Terraform.TimeSeries.CompositeCalc.CompositeSource Ist.Terraform.TimeSeries][System.Decimal System.Private.CoreLib]] System.Private.CoreLib]].ToList() [/root/corefx-1818530/src/System.Linq/src/System/Linq/Where.cs @ 397]
00007FFB5AFFAAC0 00007FFF82100B35 Ist.Terraform.TimeSeries.CompositeCalc.Portfolio.PortfolioBuyHoldReturnCalc..ctor(Ist.Terraform.TimeSeries.Interfaces.ISeriesContainer System.Collections.Generic.IDictionary`2&lt;Ist.Terraform.TimeSeries.CompositeCalc.CompositeSourceIst.Terraform.TimeSeries.Interfaces.ISeries`1&lt;System.Nullable`1&lt;Double&gt;&gt;&gt; System.Collections.Generic.IList`1&lt;Ist.Terraform.TimeSeries.CompositeCalc.CompositeRatio&gt; System.Collections.Generic.IList`1&lt;Ist.Terraform.TimeSeries.CompositeCalc.CompositeRatio&gt; System.Nullable`1&lt;System.DateTime&gt; Ist.Terraform.TimeSeries.Interfaces.ISeries`1&lt;System.Nullable`1&lt;Double&gt;&gt; System.Nullable`1&lt;Double&gt;) [/app/src/Ist.Terraform.TimeSeries/CompositeCalc/Portfolio/PortfolioBuyHoldReturnCalc.cs @ 64]
00007FFB5AFFABD0 00007FFF820FF575 Ist.Terraform.TimeSeries.CompositeCalc.Portfolio.CalculatedCostReturnCalc..ctor(Ist.Terraform.TimeSeries.Interfaces.ISeriesContainer System.Collections.Generic.IDictionary`2&lt;Ist.Terraform.TimeSeries.CompositeCalc.CompositeSourceIst.Terraform.TimeSeries.Interfaces.ISeries`1&lt;System.Nullable`1&lt;Double&gt;&gt;&gt; System.Collections.Generic.IList`1&lt;Ist.Terraform.TimeSeries.CompositeCalc.CompositeRatio&gt; Ist.Terraform.TimeSeries.Interfaces.ISeries`1&lt;System.Nullable`1&lt;Double&gt;&gt; System.Collections.Generic.IList`1&lt;Ist.Terraform.TimeSeries.CompositeCalc.CompositeRatio&gt; System.Nullable`1&lt;System.DateTime&gt; System.Nullable`1&lt;Double&gt;) [/app/src/Ist.Terraform.TimeSeries/CompositeCalc/Portfolio/CalculatedCostReturnCalc.cs @ 24]
00007FFB5AFFAC50 00007FFF820FF419 Ist.Terraform.TimeSeries.TimeSeriesModuleFactory.CreatePortfolioModel(Int32 System.String Ist.Terraform.Data.Models.Enums.CompositeType System.Collections.Generic.IDictionary`2&lt;Ist.Terraform.TimeSeries.CompositeCalc.CompositeSourceIst.Terraform.TimeSeries.Interfaces.ISeries`1&lt;System.Nullable`1&lt;Double&gt;&gt;&gt; Ist.Terraform.Data.Models.Enums.CurrencyCode Ist.Terraform.Data.Models.Enums.CompositeCalcType System.Collections.Generic.IList`1&lt;Ist.Terraform.TimeSeries.CompositeCalc.CompositeRatio&gt; System.Collections.Generic.IList`1&lt;Ist.Terraform.TimeSeries.CompositeCalc.CompositeRatio&gt; Ist.Terraform.Data.Models.Enums.RebalanceFrequency System.Nullable`1&lt;System.DateTime&gt; System.Nullable`1&lt;Double&gt; Ist.Terraform.TimeSeries.Interfaces.ISeries`1&lt;System.Nullable`1&lt;Double&gt;&gt;) [/app/src/Ist.Terraform.TimeSeries/TimeSeriesModuleFactory.cs @ 261]
00007FFB5AFFAD20 00007FFF817F8544 Ist.Terraform.TimeSeries.TimeSeriesModuleFactory+&lt;CreateSystemPortfolioAsync&gt;d__25.MoveNext() [/app/src/Ist.Terraform.TimeSeries/TimeSeriesModuleFactory.cs @ 865]
00007FFB5AFFAE30 00007FFF7CB0CF9D System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext System.Threading.ContextCallback System.Object) [/root/coreclr/src/mscorlib/shared/System/Threading/ExecutionContext.cs @ 167]
00007FFB5AFFAE90 00007FFF817FFE71 System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.__Canon System.Private.CoreLib][Ist.Terraform.TimeSeries.TimeSeriesModuleFactory+&lt;CreateSystemPortfolioAsync&gt;d__25 Ist.Terraform.TimeSeries]].MoveNext() [/root/coreclr/src/mscorlib/src/System/Runtime/CompilerServices/AsyncMethodBuilder.cs @ 568]
00007FFB5AFFAEC0 00007FFF7CB9A637 System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(System.Runtime.CompilerServices.IAsyncStateMachineBox Boolean) [/root/coreclr/src/mscorlib/src/System/Threading/Tasks/TaskContinuation.cs @ 798]
00007FFB5AFFAF00 00007FFF7CB5098E System.Threading.Tasks.Task.RunContinuations(System.Object) [/root/coreclr/src/mscorlib/src/System/Threading/Tasks/Task.cs @ 3275]
00007FFB5AFFAFA0 00007FFF7CB9FD46 System.Threading.Tasks.Task`1[[System.__Canon System.Private.CoreLib]].TrySetResult(System.__Canon) [/root/coreclr/src/mscorlib/src/System/Threading/Tasks/future.cs @ 421]
00007FFB5AFFAFD0 00007FFF7CBDC60B System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.__Canon System.Private.CoreLib]].SetExistingTaskResult(System.__Canon) [/root/coreclr/src/mscorlib/src/System/Runtime/CompilerServices/AsyncMethodBuilder.cs @ 639]
00007FFB5AFFB000 00007FFF818054AC Ist.Terraform.TimeSeries.TimeSeriesModuleFactory+&lt;GetInvestableReturnsAsync&gt;d__15.MoveNext()
00007FFB5AFFB080 00007FFF7CB0CF9D System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext System.Threading.ContextCallback System.Object) [/root/coreclr/src/mscorlib/shared/System/Threading/ExecutionContext.cs @ 167]
00007FFB5AFFB0E0 00007FFF820F6031 System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.__Canon System.Private.CoreLib][Ist.Terraform.TimeSeries.TimeSeriesModuleFactory+&lt;GetInvestableReturnsAsync&gt;d__15 Ist.Terraform.TimeSeries]].MoveNext() [/root/coreclr/src/mscorlib/src/System/Runtime/CompilerServices/AsyncMethodBuilder.cs @ 568]
00007FFB5AFFB110 00007FFF7CB9A637 System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(System.Runtime.CompilerServices.IAsyncStateMachineBox Boolean) [/root/coreclr/src/mscorlib/src/System/Threading/Tasks/TaskContinuation.cs @ 798]
00007FFB5AFFB150 00007FFF7CB5098E System.Threading.Tasks.Task.RunContinuations(System.Object) [/root/coreclr/src/mscorlib/src/System/Threading/Tasks/Task.cs @ 3275]
00007FFB5AFFB1F0 00007FFF7CB9FD46 System.Threading.Tasks.Task`1[[System.__Canon System.Private.CoreLib]].TrySetResult(System.__Canon) [/root/coreclr/src/mscorlib/src/System/Threading/Tasks/future.cs @ 421]
00007FFB5AFFB220 00007FFF7CBDC60B System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.__Canon System.Private.CoreLib]].SetExistingTaskResult(System.__Canon) [/root/coreclr/src/mscorlib/src/System/Runtime/CompilerServices/AsyncMethodBuilder.cs @ 639]
00007FFB5AFFB250 00007FFF81806CB4 Ist.Terraform.TimeSeries.TimeSeriesModuleFactory+&lt;GetPricesAsync&gt;d__30.MoveNext()
00007FFB5AFFB360 00007FFF7CB0CF9D System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext System.Threading.ContextCallback System.Object) [/root/coreclr/src/mscorlib/shared/System/Threading/ExecutionContext.cs @ 167]
00007FFB5AFFB3C0 00007FFF818097F1 System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.__Canon System.Private.CoreLib][Ist.Terraform.TimeSeries.TimeSeriesModuleFactory+&lt;GetPricesAsync&gt;d__30 Ist.Terraform.TimeSeries]].MoveNext() [/root/coreclr/src/mscorlib/src/System/Runtime/CompilerServices/AsyncMethodBuilder.cs @ 568]
00007FFB5AFFB3F0 00007FFF7CB9A637 System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(System.Runtime.CompilerServices.IAsyncStateMachineBox Boolean) [/root/coreclr/src/mscorlib/src/System/Threading/Tasks/TaskContinuation.cs @ 798]
00007FFB5AFFB430 00007FFF7CB5098E System.Threading.Tasks.Task.RunContinuations(System.Object) [/root/coreclr/src/mscorlib/src/System/Threading/Tasks/Task.cs @ 3275]
00007FFB5AFFB4D0 00007FFF7CB9FD46 System.Threading.Tasks.Task`1[[System.__Canon System.Private.CoreLib]].TrySetResult(System.__Canon) [/root/coreclr/src/mscorlib/src/System/Threading/Tasks/future.cs @ 421]
00007FFB5AFFB500 00007FFF7CBDC60B System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.__Canon System.Private.CoreLib]].SetExistingTaskResult(System.__Canon) [/root/coreclr/src/mscorlib/src/System/Runtime/CompilerServices/AsyncMethodBuilder.cs @ 639]
00007FFB5AFFB530 00007FFF8180BEFA Ist.Terraform.Data.Repositories.PostgresRepository+&lt;GetSeriesPricesAsync&gt;d__24.MoveNext()
00007FFB5AFFBCB0 00007FFF7CB0CF9D System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext System.Threading.ContextCallback System.Object) [/root/coreclr/src/mscorlib/shared/System/Threading/ExecutionContext.cs @ 167]
00007FFB5AFFBD10 00007FFF81819751 System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.__Canon System.Private.CoreLib][Ist.Terraform.Data.Repositories.PostgresRepository+&lt;GetSeriesPricesAsync&gt;d__24 Ist.Terraform.Data]].MoveNext() [/root/coreclr/src/mscorlib/src/System/Runtime/CompilerServices/AsyncMethodBuilder.cs @ 568]
00007FFB5AFFBD40 00007FFF7CB9A637 System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(System.Runtime.CompilerServices.IAsyncStateMachineBox Boolean) [/root/coreclr/src/mscorlib/src/System/Threading/Tasks/TaskContinuation.cs @ 798]
00007FFB5AFFBD80 00007FFF7CB5098E System.Threading.Tasks.Task.RunContinuations(System.Object) [/root/coreclr/src/mscorlib/src/System/Threading/Tasks/Task.cs @ 3275]
00007FFB5AFFBE20 00007FFF7CBD641C System.Threading.Tasks.Task`1[[System.Threading.Tasks.VoidTaskResult System.Private.CoreLib]].TrySetResult(System.Threading.Tasks.VoidTaskResult) [/root/coreclr/src/mscorlib/src/System/Threading/Tasks/future.cs @ 424]
00007FFB5AFFBE50 00007FFF7CBA93BF System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.Threading.Tasks.VoidTaskResult System.Private.CoreLib]].SetExistingTaskResult(System.Threading.Tasks.VoidTaskResult) [/root/coreclr/src/mscorlib/src/System/Runtime/CompilerServices/AsyncMethodBuilder.cs @ 646]
00007FFB5AFFBE70 00007FFF8181BFA0 Npgsql.NpgsqlTransaction+&lt;Commit&gt;d__17.MoveNext()
00007FFB5AFFBEC0 00007FFF7CB0CF9D System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext System.Threading.ContextCallback System.Object) [/root/coreclr/src/mscorlib/shared/System/Threading/ExecutionContext.cs @ 167]
00007FFB5AFFBF20 00007FFF80B0D6C0 System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.Threading.Tasks.VoidTaskResult System.Private.CoreLib][Npgsql.NpgsqlTransaction+&lt;Commit&gt;d__17 Npgsql]].MoveNext() [/root/coreclr/src/mscorlib/src/System/Runtime/CompilerServices/AsyncMethodBuilder.cs @ 568]
00007FFB5AFFBF50 00007FFF7CB9A637 System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(System.Runtime.CompilerServices.IAsyncStateMachineBox Boolean) [/root/coreclr/src/mscorlib/src/System/Threading/Tasks/TaskContinuation.cs @ 798]
00007FFB5AFFBF90 00007FFF7CB5098E System.Threading.Tasks.Task.RunContinuations(System.Object) [/root/coreclr/src/mscorlib/src/System/Threading/Tasks/Task.cs @ 3275]
00007FFB5AFFC030 00007FFF7CBD641C System.Threading.Tasks.Task`1[[System.Threading.Tasks.VoidTaskResult System.Private.CoreLib]].TrySetResult(System.Threading.Tasks.VoidTaskResult) [/root/coreclr/src/mscorlib/src/System/Threading/Tasks/future.cs @ 424]
00007FFB5AFFC060 00007FFF7CBA93BF System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.Threading.Tasks.VoidTaskResult System.Private.CoreLib]].SetExistingTaskResult(System.Threading.Tasks.VoidTaskResult) [/root/coreclr/src/mscorlib/src/System/Runtime/CompilerServices/AsyncMethodBuilder.cs @ 646]
00007FFB5AFFC080 00007FFF8181CBA4 Npgsql.NpgsqlConnector+&lt;ExecuteInternalCommand&gt;d__204.MoveNext()
00007FFB5AFFC1B0 00007FFF7CB0CF9D System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext System.Threading.ContextCallback System.Object) [/root/coreclr/src/mscorlib/shared/System/Threading/ExecutionContext.cs @ 167]
00007FFB5AFFC210 00007FFF80381090 System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.Threading.Tasks.VoidTaskResult System.Private.CoreLib][Npgsql.NpgsqlConnector+&lt;ExecuteInternalCommand&gt;d__204 Npgsql]].MoveNext() [/root/coreclr/src/mscorlib/src/System/Runtime/CompilerServices/AsyncMethodBuilder.cs @ 568]
00007FFB5AFFC240 00007FFF7CB9A637 System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(System.Runtime.CompilerServices.IAsyncStateMachineBox Boolean) [/root/coreclr/src/mscorlib/src/System/Threading/Tasks/TaskContinuation.cs @ 798]
00007FFB5AFFC280 00007FFF7CB5098E System.Threading.Tasks.Task.RunContinuations(System.Object) [/root/coreclr/src/mscorlib/src/System/Threading/Tasks/Task.cs @ 3275]
00007FFB5AFFC320 00007FFF7CB9FD46 System.Threading.Tasks.Task`1[[System.__Canon System.Private.CoreLib]].TrySetResult(System.__Canon) [/root/coreclr/src/mscorlib/src/System/Threading/Tasks/future.cs @ 421]
00007FFB5AFFC350 00007FFF7CBDC60B System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.__Canon System.Private.CoreLib]].SetExistingTaskResult(System.__Canon) [/root/coreclr/src/mscorlib/src/System/Runtime/CompilerServices/AsyncMethodBuilder.cs @ 639]
00007FFB5AFFC380 00007FFF80AF9131 Npgsql.NpgsqlConnector+&lt;&gt;c__DisplayClass161_0+&lt;&lt;ReadMessage&gt;g__ReadMessageLong|0&gt;d.MoveNext()
00007FFB5AFFC470 00007FFF7CB0CF9D System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext System.Threading.ContextCallback System.Object) [/root/coreclr/src/mscorlib/shared/System/Threading/ExecutionContext.cs @ 167]
00007FFB5AFFC4D0 00007FFF80AFD161 System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.__Canon System.Private.CoreLib][Npgsql.NpgsqlConnector+&lt;&gt;c__DisplayClass161_0+&lt;&lt;ReadMessage&gt;g__ReadMessageLong|0&gt;d Npgsql]].MoveNext() [/root/coreclr/src/mscorlib/src/System/Runtime/CompilerServices/AsyncMethodBuilder.cs @ 568]
00007FFB5AFFC500 00007FFF7CB9A637 System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(System.Runtime.CompilerServices.IAsyncStateMachineBox Boolean) [/root/coreclr/src/mscorlib/src/System/Threading/Tasks/TaskContinuation.cs @ 798]
00007FFB5AFFC540 00007FFF7CB5098E System.Threading.Tasks.Task.RunContinuations(System.Object) [/root/coreclr/src/mscorlib/src/System/Threading/Tasks/Task.cs @ 3275]
00007FFB5AFFC5E0 00007FFF7CBD641C System.Threading.Tasks.Task`1[[System.Threading.Tasks.VoidTaskResult System.Private.CoreLib]].TrySetResult(System.Threading.Tasks.VoidTaskResult) [/root/coreclr/src/mscorlib/src/System/Threading/Tasks/future.cs @ 424]
00007FFB5AFFC610 00007FFF7CBA93BF System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.Threading.Tasks.VoidTaskResult System.Private.CoreLib]].SetExistingTaskResult(System.Threading.Tasks.VoidTaskResult) [/root/coreclr/src/mscorlib/src/System/Runtime/CompilerServices/AsyncMethodBuilder.cs @ 646]
00007FFB5AFFC630 00007FFF80AF9D95 Npgsql.NpgsqlReadBuffer+&lt;&gt;c__DisplayClass31_0+&lt;&lt;Ensure&gt;g__EnsureLong|0&gt;d.MoveNext()
00007FFB5AFFC6C0 00007FFF7CB0CF9D System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext System.Threading.ContextCallback System.Object) [/root/coreclr/src/mscorlib/shared/System/Threading/ExecutionContext.cs @ 167]
00007FFB5AFFC720 00007FFF80AFCB70 System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.Threading.Tasks.VoidTaskResult System.Private.CoreLib][Npgsql.NpgsqlReadBuffer+&lt;&gt;c__DisplayClass31_0+&lt;&lt;Ensure&gt;g__EnsureLong|0&gt;d Npgsql]].MoveNext() [/root/coreclr/src/mscorlib/src/System/Runtime/CompilerServices/AsyncMethodBuilder.cs @ 568]
00007FFB5AFFC750 00007FFF7FB06D73 System.Net.Sockets.SocketAsyncEventArgs.OnCompleted(System.Net.Sockets.SocketAsyncEventArgs) [/root/corefx-1818530/src/System.Net.Sockets/src/System/Net/Sockets/SocketAsyncEventArgs.cs @ 219]
00007FFB5AFFC770 00007FFF7FB075F0 System.Net.Sockets.SocketAsyncEventArgs.ExecutionCallback(System.Object) [/root/corefx-1818530/src/System.Net.Sockets/src/System/Net/Sockets/SocketAsyncEventArgs.cs @ 439]
00007FFB5AFFC780 00007FFF7CB0CF9D System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext System.Threading.ContextCallback System.Object) [/root/coreclr/src/mscorlib/shared/System/Threading/ExecutionContext.cs @ 167]
00007FFB5AFFC7E0 00007FFF7FB08169 System.Net.Sockets.SocketAsyncEventArgs.FinishOperationAsyncSuccess(Int32 System.Net.Sockets.SocketFlags) [/root/corefx-1818530/src/System.Net.Sockets/src/System/Net/Sockets/SocketAsyncEventArgs.cs @ 786]
00007FFB5AFFC800 00007FFF7FB095A4 System.Net.Sockets.SocketAsyncEventArgs.CompletionCallback(Int32 System.Net.Sockets.SocketFlags System.Net.Sockets.SocketError) [/root/corefx-1818530/src/System.Net.Sockets/src/System/Net/Sockets/SocketAsyncEventArgs.Unix.cs @ 413]
00007FFB5AFFC820 00007FFF7FB08686 System.Net.Sockets.SocketAsyncEventArgs.TransferCompletionCallbackCore(Int32 Byte[] Int32 System.Net.Sockets.SocketFlags System.Net.Sockets.SocketError) [/root/corefx-1818530/src/System.Net.Sockets/src/System/Net/Sockets/SocketAsyncEventArgs.Unix.cs @ 122]
00007FFB5AFFC830 00007FFF7FB15202 System.Net.Sockets.SocketAsyncContext+BufferMemoryReceiveOperation.InvokeCallback(Boolean) [/root/corefx-1818530/src/System.Net.Sockets/src/System/Net/Sockets/SocketAsyncContext.Unix.cs @ 464]
00007FFB5AFFC880 00007FFF7FB15D1B System.Net.Sockets.SocketAsyncContext+OperationQueue`1[[System.__Canon System.Private.CoreLib]].ProcessAsyncOperation(System.__Canon) [/root/corefx-1818530/src/System.Net.Sockets/src/System/Net/Sockets/SocketAsyncContext.Unix.cs @ 855]
00007FFB5AFFC8B0 00007FFF7FB16318 System.Net.Sockets.SocketAsyncContext+OperationQueue`1+&lt;&gt;c[[System.__Canon System.Private.CoreLib]].&lt;.cctor&gt;b__18_0(System.Object) [/root/corefx-1818530/src/System.Net.Sockets/src/System/Net/Sockets/SocketAsyncContext.Unix.cs @ 697]
00007FFB5AFFC8C0 00007FFF7CB9C6E8 System.Threading.ThreadPoolWorkQueue.Dispatch() [/root/coreclr/src/mscorlib/src/System/Threading/ThreadPool.cs @ 588]
00007FFB5AFFCC90 00007ffff6269ecf [DebuggerU2MCatchHandlerFrame: 00007ffb5affcc90]

(lldb) bt
* thread #54: tid = 1664 0x00007fff821131b3 name = 'dotnet' stop reason = signal SIGSEGV: address access protected (fault address: 0x7ffd217b05c8)
  * frame #0: 0x00007fff821131b3
    frame #1: 0x00007fff82112f6b
    frame #2: 0x00007fff82112ce4
    frame #3: 0x00007fff82112b6a
    frame #4: 0x00007fff82100b35
    frame #5: 0x00007fff820ff575
    frame #6: 0x00007fff820ff419
    frame #7: 0x00007fff817f8544
    frame #8: 0x00007fff7cb0cf9d
    frame #9: 0x00007fff817ffe71
    frame #10: 0x00007fff7cb9a637
    frame #11: 0x00007fff7cb5098e
    frame #12: 0x00007fff7cb9fd46
    frame #13: 0x00007fff7cbdc60b
    frame #14: 0x00007fff818054ac
    frame #15: 0x00007fff7cb0cf9d
    frame #16: 0x00007fff820f6031
    frame #17: 0x00007fff7cb9a637
    frame #18: 0x00007fff7cb5098e
    frame #19: 0x00007fff7cb9fd46
    frame #20: 0x00007fff7cbdc60b
    frame #21: 0x00007fff81806cb4
    frame #22: 0x00007fff7cb0cf9d
    frame #23: 0x00007fff818097f1
    frame #24: 0x00007fff7cb9a637
    frame #25: 0x00007fff7cb5098e
    frame #26: 0x00007fff7cb9fd46
    frame #27: 0x00007fff7cbdc60b
    frame #28: 0x00007fff8180befa
    frame #29: 0x00007fff7cb0cf9d
    frame #30: 0x00007fff81819751
    frame #31: 0x00007fff7cb9a637
    frame #32: 0x00007fff7cb5098e
    frame #33: 0x00007fff7cbd641c
    frame #34: 0x00007fff7cba93bf
    frame #35: 0x00007fff8181bfa0
    frame #36: 0x00007fff7cb0cf9d
    frame #37: 0x00007fff80b0d6c0
    frame #38: 0x00007fff7cb9a637
    frame #39: 0x00007fff7cb5098e
    frame #40: 0x00007fff7cbd641c
    frame #41: 0x00007fff7cba93bf
    frame #42: 0x00007fff8181cba4
    frame #43: 0x00007fff7cb0cf9d
    frame #44: 0x00007fff80381090
    frame #45: 0x00007fff7cb9a637
    frame #46: 0x00007fff7cb5098e
    frame #47: 0x00007fff7cb9fd46
    frame #48: 0x00007fff7cbdc60b
    frame #49: 0x00007fff80af9131
    frame #50: 0x00007fff7cb0cf9d
    frame #51: 0x00007fff80afd161
    frame #52: 0x00007fff7cb9a637
    frame #53: 0x00007fff7cb5098e
    frame #54: 0x00007fff7cbd641c
    frame #55: 0x00007fff7cba93bf
    frame #56: 0x00007fff80af9d95
    frame #57: 0x00007fff7cb0cf9d
    frame #58: 0x00007fff80afcb70
    frame #59: 0x00007fff7fb06d73
    frame #60: 0x00007fff7cb0cf9d
    frame #61: 0x00007fff7fb08169
    frame #62: 0x00007fff7fb095a4
    frame #63: 0x00007fff7fb08686
    frame #64: 0x00007fff7fb15d1b
    frame #65: 0x00007fff7fb16318
    frame #66: 0x00007ffff6269ecf libcoreclr.so`CallDescrWorkerInternal + 124
    frame #67: 0x00007ffff618a5fc libcoreclr.so`MethodDescCallSite::CallTargetWorker(unsigned long const* unsigned long* int) + 83 at callhelpers.cpp:78
    frame #68: 0x00007ffff618a5a9 libcoreclr.so`MethodDescCallSite::CallTargetWorker(this=&lt;unavailable&gt; pArguments=&lt;unavailable&gt; pReturnValue=0x00007ffb5affcb28 cbReturnValue=8) + 857 at callhelpers.cpp:620
    frame #69: 0x00007ffff630a845 libcoreclr.so`QueueUserWorkItemManagedCallback(void*) [inlined] MethodDescCallSite::Call_RetBool(this=0x00007ffb5affcb30 pArguments=&lt;unavailable&gt;) + 15 at callhelpers.h:433
    frame #70: 0x00007ffff630a836 libcoreclr.so`QueueUserWorkItemManagedCallback(pArg=0x00007ffb5affcebe) + 166 at comthreadpool.cpp:451
    frame #71: 0x00007ffff615bf2d libcoreclr.so`ManagedThreadBase_DispatchOuter(ManagedThreadCallState*) [inlined] ManagedThreadBase_DispatchInner(pCallState=0x00007ffb5affcd68) + 413 at threads.cpp:8850
    frame #72: 0x00007ffff615bedb libcoreclr.so`ManagedThreadBase_DispatchOuter(ManagedThreadCallState*) [inlined] ManagedThreadBase_DispatchMiddle(pCallState=0x00007ffb5affcd68) + 83 at threads.cpp:8901
    frame #73: 0x00007ffff615be88 libcoreclr.so`ManagedThreadBase_DispatchOuter(ManagedThreadCallState*) [inlined] ManagedThreadBase_DispatchOuter(ManagedThreadCallState*)::$_8::operator()(ManagedThreadBase_DispatchOuter(ManagedThreadCallState*)::TryArgs*) const::{lambda(Param*)#1}::operator()(Param*) const at threads.cpp:9139
    frame #74: 0x00007ffff615be88 libcoreclr.so`ManagedThreadBase_DispatchOuter(ManagedThreadCallState*) at threads.cpp:9141
    frame #75: 0x00007ffff615be88 libcoreclr.so`ManagedThreadBase_DispatchOuter(pCallState=&lt;unavailable&gt;) + 248 at threads.cpp:9178
    frame #76: 0x00007ffff615c690 libcoreclr.so`ManagedThreadBase::ThreadPool(ADID void (*)(void*) void*) [inlined] ManagedThreadBase_FullTransitionWithAD(pAppDomain=&lt;unavailable&gt; pTarget=&lt;unavailable&gt; args=&lt;unavailable&gt; filterType=ThreadPoolThread)(void*) void* UnhandledExceptionLocation) + 43 at threads.cpp:9199
    frame #77: 0x00007ffff615c665 libcoreclr.so`ManagedThreadBase::ThreadPool(pAppDomain=&lt;unavailable&gt; pTarget=&lt;unavailable&gt; args=&lt;unavailable&gt;)(void*) void*) + 21 at threads.cpp:9241
    frame #78: 0x00007ffff62eea47 libcoreclr.so`ManagedPerAppDomainTPCount::DispatchWorkItem(this=0x00000000006952a0 foundWork=0x00007ffb5affcebf wasNotRecalled=0x00007ffb5affcebe) + 295 at threadpoolrequest.cpp:754
    frame #79: 0x00007ffff617ad23 libcoreclr.so`ThreadpoolMgr::WorkerThreadStart(void*) [inlined] ThreadpoolMgr::ExecuteWorkRequest(bool* bool*) + 1267 at win32threadpool.cpp:1560
    frame #80: 0x00007ffff617ad02 libcoreclr.so`ThreadpoolMgr::WorkerThreadStart(lpArgs=&lt;unavailable&gt;) + 1234 at win32threadpool.cpp:2024
    frame #81: 0x00007ffff64f0f72 libcoreclr.so`CorUnix::CPalThread::ThreadEntry(pvParam=0x00007ffb74003b80) + 306 at thread.cpp:1682
    frame #82: 0x00007ffff79bf494 libpthread.so.0`start_thread + 196
    frame #83: 0x00007ffff6e64acf libc.so.6`clone + 63

(lldb) sos VerifyHeap
Object 00007ffb01dd4ff8 has an invalid method table.
Last good object: 00007FFB01DD4FD8.
Object 00007ffe12430570 has an invalid method table.
Last good object: 00007FFE12430358.
Object 00007fff4ffff000 has an invalid method table.Object 00007ffae914b000 has an invalid method table.Object 00007ffa9593b000 has an invalid method table.Object 00007ffe8ffff000 has an invalid method table.Object 00007fff5ffff000 has an invalid method table.Object 00007ffad9149000 has an invalid method table.Object 00007ffaa593d000 has an invalid method table.Failed to request SyncBlk at index 1.
VerifyHeap  failed

```

I don't have the coredump from this particular crash (because it got OOM killed after calling VerifyHeap!) but most times it crashes the top of the stack is identical to this (see attached file 4 for one of the times it didn't look like this). 

Unfortunately I can't post the code because it's proprietary. We're working on trying to produce a minimal test case but that's a lot easier said than done. However if you have somewhere secure and private to upload core dumps to I could do that.

I have also attached information from the debugger from other crashes (the one above is file 3):

[dumpinfo1.txt](https://github.com/dotnet/coreclr/files/2271414/dumpinfo1.txt)
[dumpinfo2.txt](https://github.com/dotnet/coreclr/files/2271413/dumpinfo2.txt)
[dumpinfo3.txt](https://github.com/dotnet/coreclr/files/2271412/dumpinfo3.txt)
[dumpinfo4.txt](https://github.com/dotnet/coreclr/files/2271415/dumpinfo4.txt)


The environment I set up to reproduce the issue is here: https://github.com/ist-ltd/dotnet-core-debug-helper-tools - but it relies on a private docker image.</Description>
    <Title_Description>Segfault in libcoreclr.so I'm experiencing a segmentation fault on .NET Core 2 on Linux/docker under versions 2.1.2 and 2.0.9 when my process is under heavy load and using a lot of memory. 

I haven't tried to reproduce outside of Linux/docker but I have reproduced on both AWS Kubernetes and my local Docker for Windows with identical stack traces.

Here are some details from capturing the segfault under the debugger:

```
Process 1608 stopped
* thread #54: tid = 1664 0x00007fff821131b3 name = 'dotnet' stop reason = signal SIGSEGV: address access protected (fault address: 0x7ffd217b05c8)
    frame #0: 0x00007fff821131b3
-&gt;  0x7fff821131b3: rep
    0x7fff821131b4: movsq  (%rsi) %es:(%rdi)
    0x7fff821131b6: incl   0x8(%rbx)
    0x7fff821131b9: movl   $0x1 %eax

(lldb) clrstack
OS Thread Id: 0x680 (54)
        Child SP               IP Call Site
00007FFB5AFFA850 00007FFF821131B3 System.Collections.Generic.List`1+Enumerator[[System.ValueTuple`3[[System.DateTime System.Private.CoreLib][Ist.Terraform.TimeSeries.CompositeCalc.CompositeSource Ist.Terraform.TimeSeries][System.Decimal System.Private.CoreLib]] System.Private.CoreLib]].MoveNext() [/root/coreclr/src/mscorlib/shared/System/Collections/Generic/List.cs @ 1139]
00007FFB5AFFA870 00007FFF82112F6B System.Linq.Enumerable.Min[[System.ValueTuple`3[[System.DateTime System.Private.CoreLib][Ist.Terraform.TimeSeries.CompositeCalc.CompositeSource Ist.Terraform.TimeSeries][System.Decimal System.Private.CoreLib]] System.Private.CoreLib][System.DateTime System.Private.CoreLib]](System.Collections.Generic.IEnumerable`1&lt;System.ValueTuple`3&lt;System.DateTimeIst.Terraform.TimeSeries.CompositeCalc.CompositeSourceSystem.Decimal&gt;&gt; System.Func`2&lt;System.ValueTuple`3&lt;System.DateTimeIst.Terraform.TimeSeries.CompositeCalc.CompositeSourceSystem.Decimal&gt;System.DateTime&gt;) [/root/corefx-1818530/src/System.Linq/src/System/Linq/Min.cs @ 910]
00007FFB5AFFA990 00007FFF82112CE4 Ist.Terraform.TimeSeries.CompositeCalc.Portfolio.PortfolioBuyHoldReturnCalc+&lt;&gt;c__DisplayClass23_0.&lt;.ctor&gt;b__9(System.ValueTuple`3&lt;System.DateTimeIst.Terraform.TimeSeries.CompositeCalc.CompositeSourceSystem.Decimal&gt;)
00007FFB5AFFA9D0 00007FFF82112B6A System.Linq.Enumerable+WhereListIterator`1[[System.ValueTuple`3[[System.DateTime System.Private.CoreLib][Ist.Terraform.TimeSeries.CompositeCalc.CompositeSource Ist.Terraform.TimeSeries][System.Decimal System.Private.CoreLib]] System.Private.CoreLib]].ToList() [/root/corefx-1818530/src/System.Linq/src/System/Linq/Where.cs @ 397]
00007FFB5AFFAAC0 00007FFF82100B35 Ist.Terraform.TimeSeries.CompositeCalc.Portfolio.PortfolioBuyHoldReturnCalc..ctor(Ist.Terraform.TimeSeries.Interfaces.ISeriesContainer System.Collections.Generic.IDictionary`2&lt;Ist.Terraform.TimeSeries.CompositeCalc.CompositeSourceIst.Terraform.TimeSeries.Interfaces.ISeries`1&lt;System.Nullable`1&lt;Double&gt;&gt;&gt; System.Collections.Generic.IList`1&lt;Ist.Terraform.TimeSeries.CompositeCalc.CompositeRatio&gt; System.Collections.Generic.IList`1&lt;Ist.Terraform.TimeSeries.CompositeCalc.CompositeRatio&gt; System.Nullable`1&lt;System.DateTime&gt; Ist.Terraform.TimeSeries.Interfaces.ISeries`1&lt;System.Nullable`1&lt;Double&gt;&gt; System.Nullable`1&lt;Double&gt;) [/app/src/Ist.Terraform.TimeSeries/CompositeCalc/Portfolio/PortfolioBuyHoldReturnCalc.cs @ 64]
00007FFB5AFFABD0 00007FFF820FF575 Ist.Terraform.TimeSeries.CompositeCalc.Portfolio.CalculatedCostReturnCalc..ctor(Ist.Terraform.TimeSeries.Interfaces.ISeriesContainer System.Collections.Generic.IDictionary`2&lt;Ist.Terraform.TimeSeries.CompositeCalc.CompositeSourceIst.Terraform.TimeSeries.Interfaces.ISeries`1&lt;System.Nullable`1&lt;Double&gt;&gt;&gt; System.Collections.Generic.IList`1&lt;Ist.Terraform.TimeSeries.CompositeCalc.CompositeRatio&gt; Ist.Terraform.TimeSeries.Interfaces.ISeries`1&lt;System.Nullable`1&lt;Double&gt;&gt; System.Collections.Generic.IList`1&lt;Ist.Terraform.TimeSeries.CompositeCalc.CompositeRatio&gt; System.Nullable`1&lt;System.DateTime&gt; System.Nullable`1&lt;Double&gt;) [/app/src/Ist.Terraform.TimeSeries/CompositeCalc/Portfolio/CalculatedCostReturnCalc.cs @ 24]
00007FFB5AFFAC50 00007FFF820FF419 Ist.Terraform.TimeSeries.TimeSeriesModuleFactory.CreatePortfolioModel(Int32 System.String Ist.Terraform.Data.Models.Enums.CompositeType System.Collections.Generic.IDictionary`2&lt;Ist.Terraform.TimeSeries.CompositeCalc.CompositeSourceIst.Terraform.TimeSeries.Interfaces.ISeries`1&lt;System.Nullable`1&lt;Double&gt;&gt;&gt; Ist.Terraform.Data.Models.Enums.CurrencyCode Ist.Terraform.Data.Models.Enums.CompositeCalcType System.Collections.Generic.IList`1&lt;Ist.Terraform.TimeSeries.CompositeCalc.CompositeRatio&gt; System.Collections.Generic.IList`1&lt;Ist.Terraform.TimeSeries.CompositeCalc.CompositeRatio&gt; Ist.Terraform.Data.Models.Enums.RebalanceFrequency System.Nullable`1&lt;System.DateTime&gt; System.Nullable`1&lt;Double&gt; Ist.Terraform.TimeSeries.Interfaces.ISeries`1&lt;System.Nullable`1&lt;Double&gt;&gt;) [/app/src/Ist.Terraform.TimeSeries/TimeSeriesModuleFactory.cs @ 261]
00007FFB5AFFAD20 00007FFF817F8544 Ist.Terraform.TimeSeries.TimeSeriesModuleFactory+&lt;CreateSystemPortfolioAsync&gt;d__25.MoveNext() [/app/src/Ist.Terraform.TimeSeries/TimeSeriesModuleFactory.cs @ 865]
00007FFB5AFFAE30 00007FFF7CB0CF9D System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext System.Threading.ContextCallback System.Object) [/root/coreclr/src/mscorlib/shared/System/Threading/ExecutionContext.cs @ 167]
00007FFB5AFFAE90 00007FFF817FFE71 System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.__Canon System.Private.CoreLib][Ist.Terraform.TimeSeries.TimeSeriesModuleFactory+&lt;CreateSystemPortfolioAsync&gt;d__25 Ist.Terraform.TimeSeries]].MoveNext() [/root/coreclr/src/mscorlib/src/System/Runtime/CompilerServices/AsyncMethodBuilder.cs @ 568]
00007FFB5AFFAEC0 00007FFF7CB9A637 System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(System.Runtime.CompilerServices.IAsyncStateMachineBox Boolean) [/root/coreclr/src/mscorlib/src/System/Threading/Tasks/TaskContinuation.cs @ 798]
00007FFB5AFFAF00 00007FFF7CB5098E System.Threading.Tasks.Task.RunContinuations(System.Object) [/root/coreclr/src/mscorlib/src/System/Threading/Tasks/Task.cs @ 3275]
00007FFB5AFFAFA0 00007FFF7CB9FD46 System.Threading.Tasks.Task`1[[System.__Canon System.Private.CoreLib]].TrySetResult(System.__Canon) [/root/coreclr/src/mscorlib/src/System/Threading/Tasks/future.cs @ 421]
00007FFB5AFFAFD0 00007FFF7CBDC60B System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.__Canon System.Private.CoreLib]].SetExistingTaskResult(System.__Canon) [/root/coreclr/src/mscorlib/src/System/Runtime/CompilerServices/AsyncMethodBuilder.cs @ 639]
00007FFB5AFFB000 00007FFF818054AC Ist.Terraform.TimeSeries.TimeSeriesModuleFactory+&lt;GetInvestableReturnsAsync&gt;d__15.MoveNext()
00007FFB5AFFB080 00007FFF7CB0CF9D System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext System.Threading.ContextCallback System.Object) [/root/coreclr/src/mscorlib/shared/System/Threading/ExecutionContext.cs @ 167]
00007FFB5AFFB0E0 00007FFF820F6031 System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.__Canon System.Private.CoreLib][Ist.Terraform.TimeSeries.TimeSeriesModuleFactory+&lt;GetInvestableReturnsAsync&gt;d__15 Ist.Terraform.TimeSeries]].MoveNext() [/root/coreclr/src/mscorlib/src/System/Runtime/CompilerServices/AsyncMethodBuilder.cs @ 568]
00007FFB5AFFB110 00007FFF7CB9A637 System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(System.Runtime.CompilerServices.IAsyncStateMachineBox Boolean) [/root/coreclr/src/mscorlib/src/System/Threading/Tasks/TaskContinuation.cs @ 798]
00007FFB5AFFB150 00007FFF7CB5098E System.Threading.Tasks.Task.RunContinuations(System.Object) [/root/coreclr/src/mscorlib/src/System/Threading/Tasks/Task.cs @ 3275]
00007FFB5AFFB1F0 00007FFF7CB9FD46 System.Threading.Tasks.Task`1[[System.__Canon System.Private.CoreLib]].TrySetResult(System.__Canon) [/root/coreclr/src/mscorlib/src/System/Threading/Tasks/future.cs @ 421]
00007FFB5AFFB220 00007FFF7CBDC60B System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.__Canon System.Private.CoreLib]].SetExistingTaskResult(System.__Canon) [/root/coreclr/src/mscorlib/src/System/Runtime/CompilerServices/AsyncMethodBuilder.cs @ 639]
00007FFB5AFFB250 00007FFF81806CB4 Ist.Terraform.TimeSeries.TimeSeriesModuleFactory+&lt;GetPricesAsync&gt;d__30.MoveNext()
00007FFB5AFFB360 00007FFF7CB0CF9D System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext System.Threading.ContextCallback System.Object) [/root/coreclr/src/mscorlib/shared/System/Threading/ExecutionContext.cs @ 167]
00007FFB5AFFB3C0 00007FFF818097F1 System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.__Canon System.Private.CoreLib][Ist.Terraform.TimeSeries.TimeSeriesModuleFactory+&lt;GetPricesAsync&gt;d__30 Ist.Terraform.TimeSeries]].MoveNext() [/root/coreclr/src/mscorlib/src/System/Runtime/CompilerServices/AsyncMethodBuilder.cs @ 568]
00007FFB5AFFB3F0 00007FFF7CB9A637 System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(System.Runtime.CompilerServices.IAsyncStateMachineBox Boolean) [/root/coreclr/src/mscorlib/src/System/Threading/Tasks/TaskContinuation.cs @ 798]
00007FFB5AFFB430 00007FFF7CB5098E System.Threading.Tasks.Task.RunContinuations(System.Object) [/root/coreclr/src/mscorlib/src/System/Threading/Tasks/Task.cs @ 3275]
00007FFB5AFFB4D0 00007FFF7CB9FD46 System.Threading.Tasks.Task`1[[System.__Canon System.Private.CoreLib]].TrySetResult(System.__Canon) [/root/coreclr/src/mscorlib/src/System/Threading/Tasks/future.cs @ 421]
00007FFB5AFFB500 00007FFF7CBDC60B System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.__Canon System.Private.CoreLib]].SetExistingTaskResult(System.__Canon) [/root/coreclr/src/mscorlib/src/System/Runtime/CompilerServices/AsyncMethodBuilder.cs @ 639]
00007FFB5AFFB530 00007FFF8180BEFA Ist.Terraform.Data.Repositories.PostgresRepository+&lt;GetSeriesPricesAsync&gt;d__24.MoveNext()
00007FFB5AFFBCB0 00007FFF7CB0CF9D System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext System.Threading.ContextCallback System.Object) [/root/coreclr/src/mscorlib/shared/System/Threading/ExecutionContext.cs @ 167]
00007FFB5AFFBD10 00007FFF81819751 System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.__Canon System.Private.CoreLib][Ist.Terraform.Data.Repositories.PostgresRepository+&lt;GetSeriesPricesAsync&gt;d__24 Ist.Terraform.Data]].MoveNext() [/root/coreclr/src/mscorlib/src/System/Runtime/CompilerServices/AsyncMethodBuilder.cs @ 568]
00007FFB5AFFBD40 00007FFF7CB9A637 System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(System.Runtime.CompilerServices.IAsyncStateMachineBox Boolean) [/root/coreclr/src/mscorlib/src/System/Threading/Tasks/TaskContinuation.cs @ 798]
00007FFB5AFFBD80 00007FFF7CB5098E System.Threading.Tasks.Task.RunContinuations(System.Object) [/root/coreclr/src/mscorlib/src/System/Threading/Tasks/Task.cs @ 3275]
00007FFB5AFFBE20 00007FFF7CBD641C System.Threading.Tasks.Task`1[[System.Threading.Tasks.VoidTaskResult System.Private.CoreLib]].TrySetResult(System.Threading.Tasks.VoidTaskResult) [/root/coreclr/src/mscorlib/src/System/Threading/Tasks/future.cs @ 424]
00007FFB5AFFBE50 00007FFF7CBA93BF System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.Threading.Tasks.VoidTaskResult System.Private.CoreLib]].SetExistingTaskResult(System.Threading.Tasks.VoidTaskResult) [/root/coreclr/src/mscorlib/src/System/Runtime/CompilerServices/AsyncMethodBuilder.cs @ 646]
00007FFB5AFFBE70 00007FFF8181BFA0 Npgsql.NpgsqlTransaction+&lt;Commit&gt;d__17.MoveNext()
00007FFB5AFFBEC0 00007FFF7CB0CF9D System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext System.Threading.ContextCallback System.Object) [/root/coreclr/src/mscorlib/shared/System/Threading/ExecutionContext.cs @ 167]
00007FFB5AFFBF20 00007FFF80B0D6C0 System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.Threading.Tasks.VoidTaskResult System.Private.CoreLib][Npgsql.NpgsqlTransaction+&lt;Commit&gt;d__17 Npgsql]].MoveNext() [/root/coreclr/src/mscorlib/src/System/Runtime/CompilerServices/AsyncMethodBuilder.cs @ 568]
00007FFB5AFFBF50 00007FFF7CB9A637 System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(System.Runtime.CompilerServices.IAsyncStateMachineBox Boolean) [/root/coreclr/src/mscorlib/src/System/Threading/Tasks/TaskContinuation.cs @ 798]
00007FFB5AFFBF90 00007FFF7CB5098E System.Threading.Tasks.Task.RunContinuations(System.Object) [/root/coreclr/src/mscorlib/src/System/Threading/Tasks/Task.cs @ 3275]
00007FFB5AFFC030 00007FFF7CBD641C System.Threading.Tasks.Task`1[[System.Threading.Tasks.VoidTaskResult System.Private.CoreLib]].TrySetResult(System.Threading.Tasks.VoidTaskResult) [/root/coreclr/src/mscorlib/src/System/Threading/Tasks/future.cs @ 424]
00007FFB5AFFC060 00007FFF7CBA93BF System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.Threading.Tasks.VoidTaskResult System.Private.CoreLib]].SetExistingTaskResult(System.Threading.Tasks.VoidTaskResult) [/root/coreclr/src/mscorlib/src/System/Runtime/CompilerServices/AsyncMethodBuilder.cs @ 646]
00007FFB5AFFC080 00007FFF8181CBA4 Npgsql.NpgsqlConnector+&lt;ExecuteInternalCommand&gt;d__204.MoveNext()
00007FFB5AFFC1B0 00007FFF7CB0CF9D System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext System.Threading.ContextCallback System.Object) [/root/coreclr/src/mscorlib/shared/System/Threading/ExecutionContext.cs @ 167]
00007FFB5AFFC210 00007FFF80381090 System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.Threading.Tasks.VoidTaskResult System.Private.CoreLib][Npgsql.NpgsqlConnector+&lt;ExecuteInternalCommand&gt;d__204 Npgsql]].MoveNext() [/root/coreclr/src/mscorlib/src/System/Runtime/CompilerServices/AsyncMethodBuilder.cs @ 568]
00007FFB5AFFC240 00007FFF7CB9A637 System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(System.Runtime.CompilerServices.IAsyncStateMachineBox Boolean) [/root/coreclr/src/mscorlib/src/System/Threading/Tasks/TaskContinuation.cs @ 798]
00007FFB5AFFC280 00007FFF7CB5098E System.Threading.Tasks.Task.RunContinuations(System.Object) [/root/coreclr/src/mscorlib/src/System/Threading/Tasks/Task.cs @ 3275]
00007FFB5AFFC320 00007FFF7CB9FD46 System.Threading.Tasks.Task`1[[System.__Canon System.Private.CoreLib]].TrySetResult(System.__Canon) [/root/coreclr/src/mscorlib/src/System/Threading/Tasks/future.cs @ 421]
00007FFB5AFFC350 00007FFF7CBDC60B System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.__Canon System.Private.CoreLib]].SetExistingTaskResult(System.__Canon) [/root/coreclr/src/mscorlib/src/System/Runtime/CompilerServices/AsyncMethodBuilder.cs @ 639]
00007FFB5AFFC380 00007FFF80AF9131 Npgsql.NpgsqlConnector+&lt;&gt;c__DisplayClass161_0+&lt;&lt;ReadMessage&gt;g__ReadMessageLong|0&gt;d.MoveNext()
00007FFB5AFFC470 00007FFF7CB0CF9D System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext System.Threading.ContextCallback System.Object) [/root/coreclr/src/mscorlib/shared/System/Threading/ExecutionContext.cs @ 167]
00007FFB5AFFC4D0 00007FFF80AFD161 System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.__Canon System.Private.CoreLib][Npgsql.NpgsqlConnector+&lt;&gt;c__DisplayClass161_0+&lt;&lt;ReadMessage&gt;g__ReadMessageLong|0&gt;d Npgsql]].MoveNext() [/root/coreclr/src/mscorlib/src/System/Runtime/CompilerServices/AsyncMethodBuilder.cs @ 568]
00007FFB5AFFC500 00007FFF7CB9A637 System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(System.Runtime.CompilerServices.IAsyncStateMachineBox Boolean) [/root/coreclr/src/mscorlib/src/System/Threading/Tasks/TaskContinuation.cs @ 798]
00007FFB5AFFC540 00007FFF7CB5098E System.Threading.Tasks.Task.RunContinuations(System.Object) [/root/coreclr/src/mscorlib/src/System/Threading/Tasks/Task.cs @ 3275]
00007FFB5AFFC5E0 00007FFF7CBD641C System.Threading.Tasks.Task`1[[System.Threading.Tasks.VoidTaskResult System.Private.CoreLib]].TrySetResult(System.Threading.Tasks.VoidTaskResult) [/root/coreclr/src/mscorlib/src/System/Threading/Tasks/future.cs @ 424]
00007FFB5AFFC610 00007FFF7CBA93BF System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.Threading.Tasks.VoidTaskResult System.Private.CoreLib]].SetExistingTaskResult(System.Threading.Tasks.VoidTaskResult) [/root/coreclr/src/mscorlib/src/System/Runtime/CompilerServices/AsyncMethodBuilder.cs @ 646]
00007FFB5AFFC630 00007FFF80AF9D95 Npgsql.NpgsqlReadBuffer+&lt;&gt;c__DisplayClass31_0+&lt;&lt;Ensure&gt;g__EnsureLong|0&gt;d.MoveNext()
00007FFB5AFFC6C0 00007FFF7CB0CF9D System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext System.Threading.ContextCallback System.Object) [/root/coreclr/src/mscorlib/shared/System/Threading/ExecutionContext.cs @ 167]
00007FFB5AFFC720 00007FFF80AFCB70 System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.Threading.Tasks.VoidTaskResult System.Private.CoreLib][Npgsql.NpgsqlReadBuffer+&lt;&gt;c__DisplayClass31_0+&lt;&lt;Ensure&gt;g__EnsureLong|0&gt;d Npgsql]].MoveNext() [/root/coreclr/src/mscorlib/src/System/Runtime/CompilerServices/AsyncMethodBuilder.cs @ 568]
00007FFB5AFFC750 00007FFF7FB06D73 System.Net.Sockets.SocketAsyncEventArgs.OnCompleted(System.Net.Sockets.SocketAsyncEventArgs) [/root/corefx-1818530/src/System.Net.Sockets/src/System/Net/Sockets/SocketAsyncEventArgs.cs @ 219]
00007FFB5AFFC770 00007FFF7FB075F0 System.Net.Sockets.SocketAsyncEventArgs.ExecutionCallback(System.Object) [/root/corefx-1818530/src/System.Net.Sockets/src/System/Net/Sockets/SocketAsyncEventArgs.cs @ 439]
00007FFB5AFFC780 00007FFF7CB0CF9D System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext System.Threading.ContextCallback System.Object) [/root/coreclr/src/mscorlib/shared/System/Threading/ExecutionContext.cs @ 167]
00007FFB5AFFC7E0 00007FFF7FB08169 System.Net.Sockets.SocketAsyncEventArgs.FinishOperationAsyncSuccess(Int32 System.Net.Sockets.SocketFlags) [/root/corefx-1818530/src/System.Net.Sockets/src/System/Net/Sockets/SocketAsyncEventArgs.cs @ 786]
00007FFB5AFFC800 00007FFF7FB095A4 System.Net.Sockets.SocketAsyncEventArgs.CompletionCallback(Int32 System.Net.Sockets.SocketFlags System.Net.Sockets.SocketError) [/root/corefx-1818530/src/System.Net.Sockets/src/System/Net/Sockets/SocketAsyncEventArgs.Unix.cs @ 413]
00007FFB5AFFC820 00007FFF7FB08686 System.Net.Sockets.SocketAsyncEventArgs.TransferCompletionCallbackCore(Int32 Byte[] Int32 System.Net.Sockets.SocketFlags System.Net.Sockets.SocketError) [/root/corefx-1818530/src/System.Net.Sockets/src/System/Net/Sockets/SocketAsyncEventArgs.Unix.cs @ 122]
00007FFB5AFFC830 00007FFF7FB15202 System.Net.Sockets.SocketAsyncContext+BufferMemoryReceiveOperation.InvokeCallback(Boolean) [/root/corefx-1818530/src/System.Net.Sockets/src/System/Net/Sockets/SocketAsyncContext.Unix.cs @ 464]
00007FFB5AFFC880 00007FFF7FB15D1B System.Net.Sockets.SocketAsyncContext+OperationQueue`1[[System.__Canon System.Private.CoreLib]].ProcessAsyncOperation(System.__Canon) [/root/corefx-1818530/src/System.Net.Sockets/src/System/Net/Sockets/SocketAsyncContext.Unix.cs @ 855]
00007FFB5AFFC8B0 00007FFF7FB16318 System.Net.Sockets.SocketAsyncContext+OperationQueue`1+&lt;&gt;c[[System.__Canon System.Private.CoreLib]].&lt;.cctor&gt;b__18_0(System.Object) [/root/corefx-1818530/src/System.Net.Sockets/src/System/Net/Sockets/SocketAsyncContext.Unix.cs @ 697]
00007FFB5AFFC8C0 00007FFF7CB9C6E8 System.Threading.ThreadPoolWorkQueue.Dispatch() [/root/coreclr/src/mscorlib/src/System/Threading/ThreadPool.cs @ 588]
00007FFB5AFFCC90 00007ffff6269ecf [DebuggerU2MCatchHandlerFrame: 00007ffb5affcc90]

(lldb) bt
* thread #54: tid = 1664 0x00007fff821131b3 name = 'dotnet' stop reason = signal SIGSEGV: address access protected (fault address: 0x7ffd217b05c8)
  * frame #0: 0x00007fff821131b3
    frame #1: 0x00007fff82112f6b
    frame #2: 0x00007fff82112ce4
    frame #3: 0x00007fff82112b6a
    frame #4: 0x00007fff82100b35
    frame #5: 0x00007fff820ff575
    frame #6: 0x00007fff820ff419
    frame #7: 0x00007fff817f8544
    frame #8: 0x00007fff7cb0cf9d
    frame #9: 0x00007fff817ffe71
    frame #10: 0x00007fff7cb9a637
    frame #11: 0x00007fff7cb5098e
    frame #12: 0x00007fff7cb9fd46
    frame #13: 0x00007fff7cbdc60b
    frame #14: 0x00007fff818054ac
    frame #15: 0x00007fff7cb0cf9d
    frame #16: 0x00007fff820f6031
    frame #17: 0x00007fff7cb9a637
    frame #18: 0x00007fff7cb5098e
    frame #19: 0x00007fff7cb9fd46
    frame #20: 0x00007fff7cbdc60b
    frame #21: 0x00007fff81806cb4
    frame #22: 0x00007fff7cb0cf9d
    frame #23: 0x00007fff818097f1
    frame #24: 0x00007fff7cb9a637
    frame #25: 0x00007fff7cb5098e
    frame #26: 0x00007fff7cb9fd46
    frame #27: 0x00007fff7cbdc60b
    frame #28: 0x00007fff8180befa
    frame #29: 0x00007fff7cb0cf9d
    frame #30: 0x00007fff81819751
    frame #31: 0x00007fff7cb9a637
    frame #32: 0x00007fff7cb5098e
    frame #33: 0x00007fff7cbd641c
    frame #34: 0x00007fff7cba93bf
    frame #35: 0x00007fff8181bfa0
    frame #36: 0x00007fff7cb0cf9d
    frame #37: 0x00007fff80b0d6c0
    frame #38: 0x00007fff7cb9a637
    frame #39: 0x00007fff7cb5098e
    frame #40: 0x00007fff7cbd641c
    frame #41: 0x00007fff7cba93bf
    frame #42: 0x00007fff8181cba4
    frame #43: 0x00007fff7cb0cf9d
    frame #44: 0x00007fff80381090
    frame #45: 0x00007fff7cb9a637
    frame #46: 0x00007fff7cb5098e
    frame #47: 0x00007fff7cb9fd46
    frame #48: 0x00007fff7cbdc60b
    frame #49: 0x00007fff80af9131
    frame #50: 0x00007fff7cb0cf9d
    frame #51: 0x00007fff80afd161
    frame #52: 0x00007fff7cb9a637
    frame #53: 0x00007fff7cb5098e
    frame #54: 0x00007fff7cbd641c
    frame #55: 0x00007fff7cba93bf
    frame #56: 0x00007fff80af9d95
    frame #57: 0x00007fff7cb0cf9d
    frame #58: 0x00007fff80afcb70
    frame #59: 0x00007fff7fb06d73
    frame #60: 0x00007fff7cb0cf9d
    frame #61: 0x00007fff7fb08169
    frame #62: 0x00007fff7fb095a4
    frame #63: 0x00007fff7fb08686
    frame #64: 0x00007fff7fb15d1b
    frame #65: 0x00007fff7fb16318
    frame #66: 0x00007ffff6269ecf libcoreclr.so`CallDescrWorkerInternal + 124
    frame #67: 0x00007ffff618a5fc libcoreclr.so`MethodDescCallSite::CallTargetWorker(unsigned long const* unsigned long* int) + 83 at callhelpers.cpp:78
    frame #68: 0x00007ffff618a5a9 libcoreclr.so`MethodDescCallSite::CallTargetWorker(this=&lt;unavailable&gt; pArguments=&lt;unavailable&gt; pReturnValue=0x00007ffb5affcb28 cbReturnValue=8) + 857 at callhelpers.cpp:620
    frame #69: 0x00007ffff630a845 libcoreclr.so`QueueUserWorkItemManagedCallback(void*) [inlined] MethodDescCallSite::Call_RetBool(this=0x00007ffb5affcb30 pArguments=&lt;unavailable&gt;) + 15 at callhelpers.h:433
    frame #70: 0x00007ffff630a836 libcoreclr.so`QueueUserWorkItemManagedCallback(pArg=0x00007ffb5affcebe) + 166 at comthreadpool.cpp:451
    frame #71: 0x00007ffff615bf2d libcoreclr.so`ManagedThreadBase_DispatchOuter(ManagedThreadCallState*) [inlined] ManagedThreadBase_DispatchInner(pCallState=0x00007ffb5affcd68) + 413 at threads.cpp:8850
    frame #72: 0x00007ffff615bedb libcoreclr.so`ManagedThreadBase_DispatchOuter(ManagedThreadCallState*) [inlined] ManagedThreadBase_DispatchMiddle(pCallState=0x00007ffb5affcd68) + 83 at threads.cpp:8901
    frame #73: 0x00007ffff615be88 libcoreclr.so`ManagedThreadBase_DispatchOuter(ManagedThreadCallState*) [inlined] ManagedThreadBase_DispatchOuter(ManagedThreadCallState*)::$_8::operator()(ManagedThreadBase_DispatchOuter(ManagedThreadCallState*)::TryArgs*) const::{lambda(Param*)#1}::operator()(Param*) const at threads.cpp:9139
    frame #74: 0x00007ffff615be88 libcoreclr.so`ManagedThreadBase_DispatchOuter(ManagedThreadCallState*) at threads.cpp:9141
    frame #75: 0x00007ffff615be88 libcoreclr.so`ManagedThreadBase_DispatchOuter(pCallState=&lt;unavailable&gt;) + 248 at threads.cpp:9178
    frame #76: 0x00007ffff615c690 libcoreclr.so`ManagedThreadBase::ThreadPool(ADID void (*)(void*) void*) [inlined] ManagedThreadBase_FullTransitionWithAD(pAppDomain=&lt;unavailable&gt; pTarget=&lt;unavailable&gt; args=&lt;unavailable&gt; filterType=ThreadPoolThread)(void*) void* UnhandledExceptionLocation) + 43 at threads.cpp:9199
    frame #77: 0x00007ffff615c665 libcoreclr.so`ManagedThreadBase::ThreadPool(pAppDomain=&lt;unavailable&gt; pTarget=&lt;unavailable&gt; args=&lt;unavailable&gt;)(void*) void*) + 21 at threads.cpp:9241
    frame #78: 0x00007ffff62eea47 libcoreclr.so`ManagedPerAppDomainTPCount::DispatchWorkItem(this=0x00000000006952a0 foundWork=0x00007ffb5affcebf wasNotRecalled=0x00007ffb5affcebe) + 295 at threadpoolrequest.cpp:754
    frame #79: 0x00007ffff617ad23 libcoreclr.so`ThreadpoolMgr::WorkerThreadStart(void*) [inlined] ThreadpoolMgr::ExecuteWorkRequest(bool* bool*) + 1267 at win32threadpool.cpp:1560
    frame #80: 0x00007ffff617ad02 libcoreclr.so`ThreadpoolMgr::WorkerThreadStart(lpArgs=&lt;unavailable&gt;) + 1234 at win32threadpool.cpp:2024
    frame #81: 0x00007ffff64f0f72 libcoreclr.so`CorUnix::CPalThread::ThreadEntry(pvParam=0x00007ffb74003b80) + 306 at thread.cpp:1682
    frame #82: 0x00007ffff79bf494 libpthread.so.0`start_thread + 196
    frame #83: 0x00007ffff6e64acf libc.so.6`clone + 63

(lldb) sos VerifyHeap
Object 00007ffb01dd4ff8 has an invalid method table.
Last good object: 00007FFB01DD4FD8.
Object 00007ffe12430570 has an invalid method table.
Last good object: 00007FFE12430358.
Object 00007fff4ffff000 has an invalid method table.Object 00007ffae914b000 has an invalid method table.Object 00007ffa9593b000 has an invalid method table.Object 00007ffe8ffff000 has an invalid method table.Object 00007fff5ffff000 has an invalid method table.Object 00007ffad9149000 has an invalid method table.Object 00007ffaa593d000 has an invalid method table.Failed to request SyncBlk at index 1.
VerifyHeap  failed

```

I don't have the coredump from this particular crash (because it got OOM killed after calling VerifyHeap!) but most times it crashes the top of the stack is identical to this (see attached file 4 for one of the times it didn't look like this). 

Unfortunately I can't post the code because it's proprietary. We're working on trying to produce a minimal test case but that's a lot easier said than done. However if you have somewhere secure and private to upload core dumps to I could do that.

I have also attached information from the debugger from other crashes (the one above is file 3):

[dumpinfo1.txt](https://github.com/dotnet/coreclr/files/2271414/dumpinfo1.txt)
[dumpinfo2.txt](https://github.com/dotnet/coreclr/files/2271413/dumpinfo2.txt)
[dumpinfo3.txt](https://github.com/dotnet/coreclr/files/2271412/dumpinfo3.txt)
[dumpinfo4.txt](https://github.com/dotnet/coreclr/files/2271415/dumpinfo4.txt)


The environment I set up to reproduce the issue is here: https://github.com/ist-ltd/dotnet-core-debug-helper-tools - but it relies on a private docker image.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>sandreenko</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19360</IssueLabelID>
    <Title>Invalid flag causing test build failures in master</Title>
    <Description>Opened on behalf of @MattGal

Maybe something to do with escaping quote characters?
```
2018-08-08T13:05:37.5262655Z BUILDTEST: Starting the Managed Tests Build
2018-08-08T13:05:37.5410426Z BUILDTEST: Building tests group 2 with 16 subgroups
2018-08-08T13:05:37.7599817Z MSBUILD : error MSB1001: Unknown switch.
2018-08-08T13:05:37.7600402Z Switch: --
2018-08-08T13:05:37.7600650Z 
2018-08-08T13:05:37.7600982Z For switch syntax type "MSBuild /help"
2018-08-08T13:05:37.7666290Z BUILDTEST: Error: build failed. Refer to the build log files for details:
2018-08-08T13:05:37.7667106Z     E:\A\_work\80\s\bin\Logs\Tests_Managed_Windows_NT__arm__Release.log
2018-08-08T13:05:37.7667945Z     E:\A\_work\80\s\bin\Logs\Tests_Managed_Windows_NT__arm__Release.wrn
2018-08-08T13:05:37.7668860Z     E:\A\_work\80\s\bin\Logs\Tests_Managed_Windows_NT__arm__Release.err
2018-08-08T13:05:37.7745149Z ##[section]Finishing: Run build-test.cmd
```


Warnings: 1
Status Message: failed

Build : 3.0 - 20180808.04 (Product Build)
Failing configurations:
- Alpine3.6
  - Build-Tests-R2R-Release
  - Build-Tests-Release
- RedHat6
  - Build-Tests-R2R-Release
  - Build-Tests-Release
- RedHat 7
  - Build-Tests-R2R-Release
  - Build-Tests-Release
- OSX
  - Build-Tests-R2R-Release
  - Build-Tests-Release
- Windows
  - Build-Tests-R2R-Release-arm64
  - Build-Tests-Release-arm64
  - Build-Tests-R2R-Release
  - Build-Tests-Release
[Mission Control Build Info](https://mc.dot.net/#/product/netcore/30/source/official~2Fcoreclr~2Fmaster~2F/type/build~2Fproduct~2F/build/20180808.04/workItem/Orchestration/analysis/external/Link)</Description>
    <Title_Description>Invalid flag causing test build failures in master Opened on behalf of @MattGal

Maybe something to do with escaping quote characters?
```
2018-08-08T13:05:37.5262655Z BUILDTEST: Starting the Managed Tests Build
2018-08-08T13:05:37.5410426Z BUILDTEST: Building tests group 2 with 16 subgroups
2018-08-08T13:05:37.7599817Z MSBUILD : error MSB1001: Unknown switch.
2018-08-08T13:05:37.7600402Z Switch: --
2018-08-08T13:05:37.7600650Z 
2018-08-08T13:05:37.7600982Z For switch syntax type "MSBuild /help"
2018-08-08T13:05:37.7666290Z BUILDTEST: Error: build failed. Refer to the build log files for details:
2018-08-08T13:05:37.7667106Z     E:\A\_work\80\s\bin\Logs\Tests_Managed_Windows_NT__arm__Release.log
2018-08-08T13:05:37.7667945Z     E:\A\_work\80\s\bin\Logs\Tests_Managed_Windows_NT__arm__Release.wrn
2018-08-08T13:05:37.7668860Z     E:\A\_work\80\s\bin\Logs\Tests_Managed_Windows_NT__arm__Release.err
2018-08-08T13:05:37.7745149Z ##[section]Finishing: Run build-test.cmd
```


Warnings: 1
Status Message: failed

Build : 3.0 - 20180808.04 (Product Build)
Failing configurations:
- Alpine3.6
  - Build-Tests-R2R-Release
  - Build-Tests-Release
- RedHat6
  - Build-Tests-R2R-Release
  - Build-Tests-Release
- RedHat 7
  - Build-Tests-R2R-Release
  - Build-Tests-Release
- OSX
  - Build-Tests-R2R-Release
  - Build-Tests-Release
- Windows
  - Build-Tests-R2R-Release-arm64
  - Build-Tests-Release-arm64
  - Build-Tests-R2R-Release
  - Build-Tests-Release
[Mission Control Build Info](https://mc.dot.net/#/product/netcore/30/source/official~2Fcoreclr~2Fmaster~2F/type/build~2Fproduct~2F/build/20180808.04/workItem/Orchestration/analysis/external/Link)</Title_Description>
    <Label>
    </Label>
    <Assignee>BruceForstall</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19358</IssueLabelID>
    <Title>MS build failure compling test sources</Title>
    <Description>Opened on behalf of @spshant
@russkeldorph Can you please take a look:
2018-08-08T12:59:47.9671610Z E:\A\_work\99\s\tests\publishdependency.targets(915): warning : Your project is not referencing the ".NETCoreAppVersion=v3.0" framework. Add a reference to ".NETCoreAppVersion=v3.0" in the "frameworks" section of your project.json and then re-run NuGet restore. [E:\A\_work\99\s\tests\runtest.proj]
2018-08-08T12:59:47.9672360Z E:\A\_work\99\s\tests\publishdependency.targets(915): warning : Your project is not referencing the ".NETCoreAppVersion=v3.0" framework. Add a reference to ".NETCoreAppVersion=v3.0" in the "frameworks" section of your project.json and then re-run NuGet restore. [E:\A\_work\99\s\tests\runtest.proj]
2018-08-08T12:59:47.9673128Z E:\A\_work\99\s\tests\publishdependency.targets(915): warning : Your project is not referencing the ".NETCoreAppVersion=v3.0" framework. Add a reference to ".NETCoreAppVersion=v3.0" in the "frameworks" section of your project.json and then re-run NuGet restore. [E:\A\_work\99\s\tests\runtest.proj]
2018-08-08T12:59:47.9673619Z     7 Warning(s)
2018-08-08T12:59:47.9673822Z     0 Error(s)
2018-08-08T12:59:47.9674005Z 
2018-08-08T12:59:47.9674211Z Time Elapsed 00:00:00.29
2018-08-08T12:59:47.9854416Z Command execution succeeded.
2018-08-08T12:59:47.9934777Z BUILDTEST: Starting the Managed Tests Build
2018-08-08T12:59:47.9970898Z BUILDTEST: Building tests group 2 with 16 subgroups
2018-08-08T12:59:48.0716070Z MSBUILD : error MSB1001: Unknown switch.
2018-08-08T12:59:48.0716402Z Switch: --
2018-08-08T12:59:48.0716528Z 

Warnings: 1
Status Message: failed

Build : 3.0 - 20180808.04 (Product Build)
Failing configurations:
- Alpine3.6
  - Build-Tests-R2R-Release
- RedHat6
  - Build-Tests-R2R-Release
- RedHat 7
  - Build-Tests-R2R-Release
- OSX
  - Build-Tests-R2R-Release
- Windows
  - Build-Tests-R2R-Release-arm64
  - Build-Tests-R2R-Release
[Mission Control Build Info](https://mc.dot.net/#/product/netcore/30/source/official~2Fcoreclr~2Fmaster~2F/type/build~2Fproduct~2F/build/20180808.04/workItem/Orchestration/analysis/external/Link)</Description>
    <Title_Description>MS build failure compling test sources Opened on behalf of @spshant
@russkeldorph Can you please take a look:
2018-08-08T12:59:47.9671610Z E:\A\_work\99\s\tests\publishdependency.targets(915): warning : Your project is not referencing the ".NETCoreAppVersion=v3.0" framework. Add a reference to ".NETCoreAppVersion=v3.0" in the "frameworks" section of your project.json and then re-run NuGet restore. [E:\A\_work\99\s\tests\runtest.proj]
2018-08-08T12:59:47.9672360Z E:\A\_work\99\s\tests\publishdependency.targets(915): warning : Your project is not referencing the ".NETCoreAppVersion=v3.0" framework. Add a reference to ".NETCoreAppVersion=v3.0" in the "frameworks" section of your project.json and then re-run NuGet restore. [E:\A\_work\99\s\tests\runtest.proj]
2018-08-08T12:59:47.9673128Z E:\A\_work\99\s\tests\publishdependency.targets(915): warning : Your project is not referencing the ".NETCoreAppVersion=v3.0" framework. Add a reference to ".NETCoreAppVersion=v3.0" in the "frameworks" section of your project.json and then re-run NuGet restore. [E:\A\_work\99\s\tests\runtest.proj]
2018-08-08T12:59:47.9673619Z     7 Warning(s)
2018-08-08T12:59:47.9673822Z     0 Error(s)
2018-08-08T12:59:47.9674005Z 
2018-08-08T12:59:47.9674211Z Time Elapsed 00:00:00.29
2018-08-08T12:59:47.9854416Z Command execution succeeded.
2018-08-08T12:59:47.9934777Z BUILDTEST: Starting the Managed Tests Build
2018-08-08T12:59:47.9970898Z BUILDTEST: Building tests group 2 with 16 subgroups
2018-08-08T12:59:48.0716070Z MSBUILD : error MSB1001: Unknown switch.
2018-08-08T12:59:48.0716402Z Switch: --
2018-08-08T12:59:48.0716528Z 

Warnings: 1
Status Message: failed

Build : 3.0 - 20180808.04 (Product Build)
Failing configurations:
- Alpine3.6
  - Build-Tests-R2R-Release
- RedHat6
  - Build-Tests-R2R-Release
- RedHat 7
  - Build-Tests-R2R-Release
- OSX
  - Build-Tests-R2R-Release
- Windows
  - Build-Tests-R2R-Release-arm64
  - Build-Tests-R2R-Release
[Mission Control Build Info](https://mc.dot.net/#/product/netcore/30/source/official~2Fcoreclr~2Fmaster~2F/type/build~2Fproduct~2F/build/20180808.04/workItem/Orchestration/analysis/external/Link)</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19357</IssueLabelID>
    <Title>Report a better error message when assembly version conflict is encountered</Title>
    <Description>I’m seeing very odd intermittent failures on .NET Core 2.1.400-preview-009088 when loading a dependency from a build task.

An example of such failure is https://devdiv.visualstudio.com/DevDiv/_build/results?buildId=1916424&amp;_a=summary&amp;view=logs 

E:\A\_work\154\s\.packages\microsoft.dotnet.arcade.sdk\1.0.0-prerelease-63202-02\tools\Sign.proj(395): error MSB4018: System.IO.FileLoadException: Could not load file or assembly 'System.IO.Packaging Version=4.0.3.0 Culture=neutral PublicKeyToken=b03f5f7f11d50a3a'. Could not find or load a specific file. (Exception from HRESULT: 0x80131621)
E:\A\_work\154\s\.packages\microsoft.dotnet.arcade.sdk\1.0.0-prerelease-63202-02\tools\Sign.proj(395): error MSB4018: File name: 'System.IO.Packaging Version=4.0.3.0 Culture=neutral PublicKeyToken=b03f5f7f11d50a3a'

The file being loaded (System.IO.Packaging) is located in the same directory as the build task assembly.

Memory dump: %internal_share%\tomat\Bugs\CoreLoaderBug

Turns out we have two tasks that depend on a different version of System.IO.Packaging - 4.0.2.0 and 4.0.3.0. The load error is intermittent since it depends on the order in which these two versions are loaded. The solution to this problem would be to load tasks to separate Assembly Load Contexts: https://github.com/Microsoft/msbuild/issues/1754.

However the assembly loader should report an error that indicates the version mismatch instead of the above error.</Description>
    <Title_Description>Report a better error message when assembly version conflict is encountered I’m seeing very odd intermittent failures on .NET Core 2.1.400-preview-009088 when loading a dependency from a build task.

An example of such failure is https://devdiv.visualstudio.com/DevDiv/_build/results?buildId=1916424&amp;_a=summary&amp;view=logs 

E:\A\_work\154\s\.packages\microsoft.dotnet.arcade.sdk\1.0.0-prerelease-63202-02\tools\Sign.proj(395): error MSB4018: System.IO.FileLoadException: Could not load file or assembly 'System.IO.Packaging Version=4.0.3.0 Culture=neutral PublicKeyToken=b03f5f7f11d50a3a'. Could not find or load a specific file. (Exception from HRESULT: 0x80131621)
E:\A\_work\154\s\.packages\microsoft.dotnet.arcade.sdk\1.0.0-prerelease-63202-02\tools\Sign.proj(395): error MSB4018: File name: 'System.IO.Packaging Version=4.0.3.0 Culture=neutral PublicKeyToken=b03f5f7f11d50a3a'

The file being loaded (System.IO.Packaging) is located in the same directory as the build task assembly.

Memory dump: %internal_share%\tomat\Bugs\CoreLoaderBug

Turns out we have two tasks that depend on a different version of System.IO.Packaging - 4.0.2.0 and 4.0.3.0. The load error is intermittent since it depends on the order in which these two versions are loaded. The solution to this problem would be to load tasks to separate Assembly Load Contexts: https://github.com/Microsoft/msbuild/issues/1754.

However the assembly loader should report an error that indicates the version mismatch instead of the above error.</Title_Description>
    <Label>area-AssemblyLoader</Label>
    <Assignee>tmat</Assignee>
    <CreatedAt>8/08/2018 4:42:53 PM +00:00</CreatedAt>
    <ClosedAt>10/08/2018 10:16:03 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19355</IssueLabelID>
    <Title>Slowdown of code when doing subtraction of ints.</Title>
    <Description>[Reproduction repo](https://github.com/aensidhe/dotnet-core-minus-regression)

**Problem**

Code with writing `baseInt-i` to span is slower by 50% `baseInt` where `baseInt` is `Int32` const `i` is `Int32` counter.

**Expected**

Almost no effect like in native code. Code excerpt and benchmark results below.

````csharp
[Benchmark(Baseline = true)]
public int NoMinus()
{
    var i = 0;
    for (; i &lt; length; i++)
        BinaryPrimitives.WriteInt32BigEndian(_buffer baseInt);
    return i;
}

[Benchmark]
public int Minus()
{
    var i = 0;
    for (; i &lt; length; i++)
        BinaryPrimitives.WriteInt32BigEndian(_buffer baseInt - i);
    return i;
}
````

**Benchmark results**
``` ini

BenchmarkDotNet=v0.11.0 OS=debian 9
Intel Core i7-6700HQ CPU 2.60GHz (Skylake) 1 CPU 8 logical and 8 physical cores
.NET Core SDK=2.1.302
  [Host]     : .NET Core 2.1.2 (CoreCLR 4.6.26628.05 CoreFX 4.6.26629.01) 64bit RyuJIT
  DefaultJob : .NET Core 2.1.2 (CoreCLR 4.6.26628.05 CoreFX 4.6.26629.01) 64bit RyuJIT


```
|          Method |      Mean |    Error |     StdDev |        Q3 | Scaled | ScaledSD | Allocated |
|---------------- |----------:|---------:|-----------:|----------:|-------:|---------:|----------:|
|         NoMinus | 133.19 ns | 2.705 ns |  3.1150 ns | 134.64 ns |   1.00 |     0.00 |       0 B |
|           Minus | 225.59 ns | 4.521 ns | 11.7502 ns | 232.00 ns |   1.69 |     0.10 |       0 B |
|   MinusLocalVar | 202.04 ns | 3.792 ns |  3.7244 ns | 204.48 ns |   1.52 |     0.04 |       0 B |
| MinusLocalConst | 213.54 ns | 4.193 ns |  4.4860 ns | 217.70 ns |   1.60 |     0.05 |       0 B |
|         Pointer |  91.14 ns | 1.819 ns |  1.8681 ns |  92.42 ns |   0.68 |     0.02 |       0 B |
|    PointerMinus | 104.95 ns | 2.026 ns |  1.8954 ns | 106.36 ns |   0.79 |     0.02 |       0 B |
|          CArray |  93.81 ns | 1.068 ns |  0.9468 ns |  94.43 ns |   0.70 |     0.02 |       0 B |
|     CArrayMinus |  96.51 ns | 1.977 ns |  2.1155 ns |  97.44 ns |   0.72 |     0.02 |       0 B |
|        CppArray |  86.01 ns | 1.713 ns |  1.9730 ns |  86.91 ns |   0.65 |     0.02 |       0 B |
|   CppArrayMinus |  92.25 ns | 1.817 ns |  1.7849 ns |  93.28 ns |   0.69 |     0.02 |       0 B |

[Disassembly diff](https://www.diffchecker.com/SUwzDw8w) between `NoMinus` and `Minus`.

Difference can't be explained by `field access` since `baseInt` is const but I added several benchmarks to check that. 

If we change `int` to `uint` 50% difference for .net code stays almost zero difference for native code - too.

Problem persists even if we use unsafe code for .net so it's not specific to `BinaryPrimitives` class but it's of much smaller magnitude.

If we choose smaller ints (like 200 not 1&lt;&lt;30) it will not change anything.</Description>
    <Title_Description>Slowdown of code when doing subtraction of ints. [Reproduction repo](https://github.com/aensidhe/dotnet-core-minus-regression)

**Problem**

Code with writing `baseInt-i` to span is slower by 50% `baseInt` where `baseInt` is `Int32` const `i` is `Int32` counter.

**Expected**

Almost no effect like in native code. Code excerpt and benchmark results below.

````csharp
[Benchmark(Baseline = true)]
public int NoMinus()
{
    var i = 0;
    for (; i &lt; length; i++)
        BinaryPrimitives.WriteInt32BigEndian(_buffer baseInt);
    return i;
}

[Benchmark]
public int Minus()
{
    var i = 0;
    for (; i &lt; length; i++)
        BinaryPrimitives.WriteInt32BigEndian(_buffer baseInt - i);
    return i;
}
````

**Benchmark results**
``` ini

BenchmarkDotNet=v0.11.0 OS=debian 9
Intel Core i7-6700HQ CPU 2.60GHz (Skylake) 1 CPU 8 logical and 8 physical cores
.NET Core SDK=2.1.302
  [Host]     : .NET Core 2.1.2 (CoreCLR 4.6.26628.05 CoreFX 4.6.26629.01) 64bit RyuJIT
  DefaultJob : .NET Core 2.1.2 (CoreCLR 4.6.26628.05 CoreFX 4.6.26629.01) 64bit RyuJIT


```
|          Method |      Mean |    Error |     StdDev |        Q3 | Scaled | ScaledSD | Allocated |
|---------------- |----------:|---------:|-----------:|----------:|-------:|---------:|----------:|
|         NoMinus | 133.19 ns | 2.705 ns |  3.1150 ns | 134.64 ns |   1.00 |     0.00 |       0 B |
|           Minus | 225.59 ns | 4.521 ns | 11.7502 ns | 232.00 ns |   1.69 |     0.10 |       0 B |
|   MinusLocalVar | 202.04 ns | 3.792 ns |  3.7244 ns | 204.48 ns |   1.52 |     0.04 |       0 B |
| MinusLocalConst | 213.54 ns | 4.193 ns |  4.4860 ns | 217.70 ns |   1.60 |     0.05 |       0 B |
|         Pointer |  91.14 ns | 1.819 ns |  1.8681 ns |  92.42 ns |   0.68 |     0.02 |       0 B |
|    PointerMinus | 104.95 ns | 2.026 ns |  1.8954 ns | 106.36 ns |   0.79 |     0.02 |       0 B |
|          CArray |  93.81 ns | 1.068 ns |  0.9468 ns |  94.43 ns |   0.70 |     0.02 |       0 B |
|     CArrayMinus |  96.51 ns | 1.977 ns |  2.1155 ns |  97.44 ns |   0.72 |     0.02 |       0 B |
|        CppArray |  86.01 ns | 1.713 ns |  1.9730 ns |  86.91 ns |   0.65 |     0.02 |       0 B |
|   CppArrayMinus |  92.25 ns | 1.817 ns |  1.7849 ns |  93.28 ns |   0.69 |     0.02 |       0 B |

[Disassembly diff](https://www.diffchecker.com/SUwzDw8w) between `NoMinus` and `Minus`.

Difference can't be explained by `field access` since `baseInt` is const but I added several benchmarks to check that. 

If we change `int` to `uint` 50% difference for .net code stays almost zero difference for native code - too.

Problem persists even if we use unsafe code for .net so it's not specific to `BinaryPrimitives` class but it's of much smaller magnitude.

If we choose smaller ints (like 200 not 1&lt;&lt;30) it will not change anything.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>mikedn</Assignee>
    <CreatedAt>8/08/2018 1:59:12 PM +00:00</CreatedAt>
    <ClosedAt>25/01/2019 9:37:14 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19352</IssueLabelID>
    <Title>Add PInvoke/Structures tests</Title>
    <Description>
    </Description>
    <Title_Description>Add PInvoke/Structures tests </Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jkoritzinsky</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19348</IssueLabelID>
    <Title>Add PInvoke/SizeParamIndex tests</Title>
    <Description>
    </Description>
    <Title_Description>Add PInvoke/SizeParamIndex tests </Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jkoritzinsky</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19347</IssueLabelID>
    <Title>Assert failure: !IsAfContentType_WindowsRuntime(pModule-&gt;GetAssemblyRefFlags(tkType))</Title>
    <Description>Seen in Ubuntu arm32 Checked R2R testing:

https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/arm_cross_checked_ubuntu_r2r_flow/20/

Also e.g. Ubuntu x64 Checked R2R:

https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64/job/x64_checked_ubuntu_r2r_flow/2364/

```
./tests/runtest.sh: line 537:  2762 Aborted                 $overlayDir/crossgen /Platform_Assemblies_Paths $overlayDir $filename &gt; $filename.stdout 2&gt; $filename.stderr
Unable to precompile /ssd/j/workspace/dotnet_coreclr/master/arm_cross_checked_ubuntu_r2r_tst/bin/tests/Linux.arm.Checked/Tests/Core_Root/System.Runtime.WindowsRuntime.dll.
Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0
Copyright (c) Microsoft Corporation.  All rights reserved.


Assert failure(PID 2762 [0x00000aca] Thread: 2762 [0x0aca]): !IsAfContentType_WindowsRuntime(pModule-&gt;GetAssemblyRefFlags(tkType))
    File: /mnt/j/workspace/dotnet_coreclr/master/arm_cross_checked_ubuntu/src/vm/assembly.cpp Line: 1222
    Image: /ssd/j/workspace/dotnet_coreclr/master/arm_cross_checked_ubuntu_r2r_tst/bin/tests/Linux.arm.Checked/Tests/Core_Root/crossgen
```</Description>
    <Title_Description>Assert failure: !IsAfContentType_WindowsRuntime(pModule-&gt;GetAssemblyRefFlags(tkType)) Seen in Ubuntu arm32 Checked R2R testing:

https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/arm_cross_checked_ubuntu_r2r_flow/20/

Also e.g. Ubuntu x64 Checked R2R:

https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64/job/x64_checked_ubuntu_r2r_flow/2364/

```
./tests/runtest.sh: line 537:  2762 Aborted                 $overlayDir/crossgen /Platform_Assemblies_Paths $overlayDir $filename &gt; $filename.stdout 2&gt; $filename.stderr
Unable to precompile /ssd/j/workspace/dotnet_coreclr/master/arm_cross_checked_ubuntu_r2r_tst/bin/tests/Linux.arm.Checked/Tests/Core_Root/System.Runtime.WindowsRuntime.dll.
Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0
Copyright (c) Microsoft Corporation.  All rights reserved.


Assert failure(PID 2762 [0x00000aca] Thread: 2762 [0x0aca]): !IsAfContentType_WindowsRuntime(pModule-&gt;GetAssemblyRefFlags(tkType))
    File: /mnt/j/workspace/dotnet_coreclr/master/arm_cross_checked_ubuntu/src/vm/assembly.cpp Line: 1222
    Image: /ssd/j/workspace/dotnet_coreclr/master/arm_cross_checked_ubuntu_r2r_tst/bin/tests/Linux.arm.Checked/Tests/Core_Root/crossgen
```</Title_Description>
    <Label>area-ReadyToRun</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>8/08/2018 5:25:08 AM +00:00</CreatedAt>
    <ClosedAt>13/08/2018 12:09:56 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19346</IssueLabelID>
    <Title>Assertion failed 'varDsc-&gt;lvImplicitlyReferenced'</Title>
    <Description>Looks like a regression due to https://github.com/dotnet/coreclr/pull/19325

https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64/job/checked_windows_nt/10114/consoleText

3 failures e.g.
```
      JIT_Directed._coverage_oldtests_switchdefaultonly1_il_d_switchdefaultonly1_il_d_._coverage_oldtests_switchdefaultonly1_il_d_switchdefaultonly1_il_d_cmd [FAIL]
        
        Assert failure(PID 13300 [0x000033f4] Thread: 14688 [0x3960]): Assertion failed 'varDsc-&gt;lvImplicitlyReferenced' in 'switchdefaultonly1:Main(ref):int' (IL size 31)
        
            File: d:\j\workspace\checked_windo---14fb495b\src\jit\lclvars.cpp Line: 4103
            Image: D:\j\workspace\checked_windo---14fb495b\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root\CoreRun.exe
        
        
  
  Return code:      1
  Raw output file:      D:\j\workspace\checked_windo---14fb495b\bin\tests\Windows_NT.x64.Checked\Reports\JIT.Directed\coverage\oldtests\switchdefaultonly1_il_d\switchdefaultonly1_il_d.output.txt
  Raw output:
  BEGIN EXECUTION
         "D:\j\workspace\checked_windo---14fb495b\tests\..\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root\corerun.exe" switchdefaultonly1_il_d.exe 
        Expected: 100
        Actual: 123456789
        END EXECUTION - FAILED
        FAILED
        Test Harness Exitcode is : 1
        
  To run the test:
  &gt; set CORE_ROOT=D:\j\workspace\checked_windo---14fb495b\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root
  &gt; D:\j\workspace\checked_windo---14fb495b\bin\tests\Windows_NT.x64.Checked\JIT\Directed\coverage\oldtests\switchdefaultonly1_il_d\switchdefaultonly1_il_d.cmd
  
        Expected: True
        Actual:   False
        Stack Trace:
          D:\j\workspace\checked_windo---14fb495b\bin\tests\Windows_NT.x64.Checked\TestWrappers\JIT.Directed\JIT.Directed.XUnitWrapper.cs(146690): at JIT_Directed._coverage_oldtests_switchdefaultonly1_il_d_switchdefaultonly1_il_d_._coverage_oldtests_switchdefaultonly1_il_d_switchdefaultonly1_il_d_cmd()
```

@AndyAyersMS 
cc @dotnet/jit-contrib </Description>
    <Title_Description>Assertion failed 'varDsc-&gt;lvImplicitlyReferenced' Looks like a regression due to https://github.com/dotnet/coreclr/pull/19325

https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64/job/checked_windows_nt/10114/consoleText

3 failures e.g.
```
      JIT_Directed._coverage_oldtests_switchdefaultonly1_il_d_switchdefaultonly1_il_d_._coverage_oldtests_switchdefaultonly1_il_d_switchdefaultonly1_il_d_cmd [FAIL]
        
        Assert failure(PID 13300 [0x000033f4] Thread: 14688 [0x3960]): Assertion failed 'varDsc-&gt;lvImplicitlyReferenced' in 'switchdefaultonly1:Main(ref):int' (IL size 31)
        
            File: d:\j\workspace\checked_windo---14fb495b\src\jit\lclvars.cpp Line: 4103
            Image: D:\j\workspace\checked_windo---14fb495b\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root\CoreRun.exe
        
        
  
  Return code:      1
  Raw output file:      D:\j\workspace\checked_windo---14fb495b\bin\tests\Windows_NT.x64.Checked\Reports\JIT.Directed\coverage\oldtests\switchdefaultonly1_il_d\switchdefaultonly1_il_d.output.txt
  Raw output:
  BEGIN EXECUTION
         "D:\j\workspace\checked_windo---14fb495b\tests\..\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root\corerun.exe" switchdefaultonly1_il_d.exe 
        Expected: 100
        Actual: 123456789
        END EXECUTION - FAILED
        FAILED
        Test Harness Exitcode is : 1
        
  To run the test:
  &gt; set CORE_ROOT=D:\j\workspace\checked_windo---14fb495b\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root
  &gt; D:\j\workspace\checked_windo---14fb495b\bin\tests\Windows_NT.x64.Checked\JIT\Directed\coverage\oldtests\switchdefaultonly1_il_d\switchdefaultonly1_il_d.cmd
  
        Expected: True
        Actual:   False
        Stack Trace:
          D:\j\workspace\checked_windo---14fb495b\bin\tests\Windows_NT.x64.Checked\TestWrappers\JIT.Directed\JIT.Directed.XUnitWrapper.cs(146690): at JIT_Directed._coverage_oldtests_switchdefaultonly1_il_d_switchdefaultonly1_il_d_._coverage_oldtests_switchdefaultonly1_il_d_switchdefaultonly1_il_d_cmd()
```

@AndyAyersMS 
cc @dotnet/jit-contrib </Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19341</IssueLabelID>
    <Title>WIP NO-MERGE Dummy change</Title>
    <Description>
    </Description>
    <Title_Description>WIP NO-MERGE Dummy change </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>7/08/2018 10:23:39 PM +00:00</CreatedAt>
    <ClosedAt>9/08/2018 3:13:43 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19340</IssueLabelID>
    <Title>Test failure in tracing\runtimeeventsource\runtimeeventsource\runtimeeventsource.cmd</Title>
    <Description>There is a recent regression in tracing\runtimeeventsource\runtimeeventsource\runtimeeventsource.cmd in (at least?) the Window x64 zapdisable test leg run with:

```
COMPlus_TieredCompilation=0 
COMPlus_ZapDisable=1
COMPlus_ReadyToRun=0 
```

starting with:

https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64/job/jitstress/job/x64_checked_windows_nt_zapdisable/586/

```
      tracing_runtimeeventsource._runtimeeventsource_runtimeeventsource_._runtimeeventsource_runtimeeventsource_cmd [FAIL]
        
  Unhandled Exception: System.Exception: Condition 'listener.EventCount &gt; 0' is not true
           at Tracing.Tests.Common.Assert.True(String name Boolean condition) in D:\j\workspace\x64_checked_w---fa5d14d7\tests\src\tracing\common\Assert.cs:line 11
           at Tracing.Tests.RuntimeEventSourceTest.Main(String[] args) in D:\j\workspace\x64_checked_w---fa5d14d7\tests\src\tracing\runtimeeventsource\RuntimeEventSourceTest.cs:line 44
  
  
  Return code:      1
  Raw output file:      D:\j\workspace\x64_checked_w---fa5d14d7\bin\tests\Windows_NT.x64.Checked\Reports\tracing.runtimeeventsource\runtimeeventsource\runtimeeventsource.output.txt
  Raw output:
  BEGIN EXECUTION
         "D:\j\workspace\x64_checked_w---fa5d14d7\tests\..\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root\corerun.exe" runtimeeventsource.exe 
        [Simple] ThreadID = 5928 ID = 200 Name = IncreaseMemoryPressure
        TimeStamp: 8/2/2018 7:09:15 AM
        LocalTime: 8/2/2018 7:09:19 AM
        Difference: 00:00:03.7268529
        	Name = "BytesAllocated" Value = "3984"
        	Name = "ClrInstanceID" Value = "0"
        
  
        [Simple] ThreadID = 5928 ID = 70 Name = ThreadCreating
        TimeStamp: 8/2/2018 7:09:15 AM
        LocalTime: 8/2/2018 7:09:19 AM
        Difference: 00:00:03.9582825
        	Name = "ID" Value = "1763982960"
        	Name = "ClrInstanceID" Value = "0"
        
  
        [Simple] ThreadID = 7124 ID = 10 Name = GCAllocationTick_V3
        TimeStamp: 8/2/2018 7:09:15 AM
        LocalTime: 8/2/2018 7:09:19 AM
        Difference: 00:00:03.6601227
        	Name = "AllocationAmount" Value = "104712"
        	Name = "AllocationKind" Value = "0"
        	Name = "ClrInstanceID" Value = "0"
        	Name = "AllocationAmount64" Value = "104712"
        	Name = "TypeID" Value = "1787297752"
        	Name = "TypeName" Value = "System.Object"
        	Name = "HeapIndex" Value = "0"
        	Name = "Address" Value = "2396152"
        
  
        [Simple] ThreadID = 2872 ID = 85 Name = ThreadCreated
        TimeStamp: 8/2/2018 7:09:15 AM
        LocalTime: 8/2/2018 7:09:19 AM
        Difference: 00:00:03.6193479
        	Name = "ManagedThreadID" Value = "1763982960"
        	Name = "AppDomainID" Value = "1723735920"
        	Name = "Flags" Value = "0"
        	Name = "ManagedThreadIndex" Value = "7"
        	Name = "OSThreadID" Value = "2872"
        	Name = "ClrInstanceID" Value = "0"
        
  
        [Simple] ThreadID = 2872 ID = 71 Name = ThreadRunning
        TimeStamp: 8/2/2018 7:09:15 AM
        LocalTime: 8/2/2018 7:09:19 AM
        Difference: 00:00:03.6194882
        	Name = "ID" Value = "1763982960"
        	Name = "ClrInstanceID" Value = "0"
        
  
        [Simple] ThreadID = 2872 ID = 145 Name = MethodJittingStarted_V1
        TimeStamp: 8/2/2018 7:09:15 AM
        LocalTime: 8/2/2018 7:09:19 AM
        Difference: 00:00:03.6193243
        	Name = "MethodID" Value = "1791492016"
        	Name = "ModuleID" Value = "1785724832"
        	Name = "MethodToken" Value = "100670965"
        	Name = "MethodILSize" Value = "133"
        	Name = "MethodNamespace" Value = "System.Diagnostics.Tracing.EventPipeEventDispatcher"
        	Name = "MethodName" Value = "TimeStampToDateTime"
        	Name = "MethodSignature" Value = "instance value class System.DateTime  (int64)"
        	Name = "ClrInstanceID" Value = "0"
        
  
        [Simple] ThreadID = 2872 ID = 143 Name = MethodLoadVerbose_V2
        TimeStamp: 8/2/2018 7:09:15 AM
        LocalTime: 8/2/2018 7:09:19 AM
        Difference: 00:00:03.6150592
        	Name = "MethodID" Value = "1791492016"
        	Name = "ModuleID" Value = "1785724832"
        	Name = "MethodStartAddress" Value = "1792016304"
        	Name = "MethodSize" Value = "264"
        	Name = "MethodToken" Value = "100670965"
        	Name = "MethodFlags" Value = "8"
        	Name = "MethodNamespace" Value = "System.Diagnostics.Tracing.EventPipeEventDispatcher"
        	Name = "MethodName" Value = "TimeStampToDateTime"
        	Name = "MethodSignature" Value = "instance value class System.DateTime  (int64)"
        	Name = "ClrInstanceID" Value = "0"
        	Name = "ReJITID" Value = ""
        
  
        [Simple] ThreadID = 2872 ID = 190 Name = MethodILToNativeMap
        TimeStamp: 8/2/2018 7:09:15 AM
        LocalTime: 8/2/2018 7:09:19 AM
        Difference: 00:00:03.6151830
        	Name = "MethodID" Value = "1791492016"
        	Name = "ReJITID" Value = "0"
        	Name = "MethodExtent" Value = "0"
        	Name = "CountOfMapEntries" Value = "15"
        
  
        [Simple] ThreadID = 2872 ID = 145 Name = MethodJittingStarted_V1
        TimeStamp: 8/2/2018 7:09:15 AM
        LocalTime: 8/2/2018 7:09:19 AM
        Difference: 00:00:03.6200239
        	Name = "MethodID" Value = "1792540664"
        	Name = "ModuleID" Value = "1785724832"
        	Name = "MethodToken" Value = "100670993"
        	Name = "MethodILSize" Value = "892"
        	Name = "MethodNamespace" Value = "System.Diagnostics.Tracing.EventPipePayloadDecoder"
        	Name = "MethodName" Value = "DecodePayload"
        	Name = "MethodSignature" Value = "class System.Object[]  (value class EventMetadata&amp;value class System.ReadOnlySpan`1&lt;unsigned int8&gt;)"
        	Name = "ClrInstanceID" Value = "0"
        
  
        [Simple] ThreadID = 2872 ID = 143 Name = MethodLoadVerbose_V2
        TimeStamp: 8/2/2018 7:09:15 AM
        LocalTime: 8/2/2018 7:09:19 AM
        Difference: 00:00:03.4660610
        	Name = "MethodID" Value = "1792540664"
        	Name = "ModuleID" Value = "1785724832"
        	Name = "MethodStartAddress" Value = "1792016368"
        	Name = "MethodSize" Value = "2299"
        	Name = "MethodToken" Value = "100670993"
        	Name = "MethodFlags" Value = "8"
        	Name = "MethodNamespace" Value = "System.Diagnostics.Tracing.EventPipePayloadDecoder"
        	Name = "MethodName" Value = "DecodePayload"
        	Name = "MethodSignature" Value = "class System.Object[]  (value class EventMetadata&amp;value class System.ReadOnlySpan`1&lt;unsigned int8&gt;)"
        	Name = "ClrInstanceID" Value = "0"
        	Name = "ReJITID" Value = ""
        
  
        Expected: 100
        Actual: -532462766
        END EXECUTION - FAILED
        FAILED
        Test Harness Exitcode is : 1
        
  To run the test:
  &gt; set CORE_ROOT=D:\j\workspace\x64_checked_w---fa5d14d7\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root
  &gt; D:\j\workspace\x64_checked_w---fa5d14d7\bin\tests\Windows_NT.x64.Checked\tracing\runtimeeventsource\runtimeeventsource\runtimeeventsource.cmd
  
        Expected: True
        Actual:   False
        Stack Trace:
          D:\j\workspace\x64_checked_w---fa5d14d7\bin\tests\Windows_NT.x64.Checked\TestWrappers\tracing.runtimeeventsource\tracing.runtimeeventsource.XUnitWrapper.cs(1090): at tracing_runtimeeventsource._runtimeeventsource_runtimeeventsource_._runtimeeventsource_runtimeeventsource_cmd()
```
</Description>
    <Title_Description>Test failure in tracing\runtimeeventsource\runtimeeventsource\runtimeeventsource.cmd There is a recent regression in tracing\runtimeeventsource\runtimeeventsource\runtimeeventsource.cmd in (at least?) the Window x64 zapdisable test leg run with:

```
COMPlus_TieredCompilation=0 
COMPlus_ZapDisable=1
COMPlus_ReadyToRun=0 
```

starting with:

https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64/job/jitstress/job/x64_checked_windows_nt_zapdisable/586/

```
      tracing_runtimeeventsource._runtimeeventsource_runtimeeventsource_._runtimeeventsource_runtimeeventsource_cmd [FAIL]
        
  Unhandled Exception: System.Exception: Condition 'listener.EventCount &gt; 0' is not true
           at Tracing.Tests.Common.Assert.True(String name Boolean condition) in D:\j\workspace\x64_checked_w---fa5d14d7\tests\src\tracing\common\Assert.cs:line 11
           at Tracing.Tests.RuntimeEventSourceTest.Main(String[] args) in D:\j\workspace\x64_checked_w---fa5d14d7\tests\src\tracing\runtimeeventsource\RuntimeEventSourceTest.cs:line 44
  
  
  Return code:      1
  Raw output file:      D:\j\workspace\x64_checked_w---fa5d14d7\bin\tests\Windows_NT.x64.Checked\Reports\tracing.runtimeeventsource\runtimeeventsource\runtimeeventsource.output.txt
  Raw output:
  BEGIN EXECUTION
         "D:\j\workspace\x64_checked_w---fa5d14d7\tests\..\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root\corerun.exe" runtimeeventsource.exe 
        [Simple] ThreadID = 5928 ID = 200 Name = IncreaseMemoryPressure
        TimeStamp: 8/2/2018 7:09:15 AM
        LocalTime: 8/2/2018 7:09:19 AM
        Difference: 00:00:03.7268529
        	Name = "BytesAllocated" Value = "3984"
        	Name = "ClrInstanceID" Value = "0"
        
  
        [Simple] ThreadID = 5928 ID = 70 Name = ThreadCreating
        TimeStamp: 8/2/2018 7:09:15 AM
        LocalTime: 8/2/2018 7:09:19 AM
        Difference: 00:00:03.9582825
        	Name = "ID" Value = "1763982960"
        	Name = "ClrInstanceID" Value = "0"
        
  
        [Simple] ThreadID = 7124 ID = 10 Name = GCAllocationTick_V3
        TimeStamp: 8/2/2018 7:09:15 AM
        LocalTime: 8/2/2018 7:09:19 AM
        Difference: 00:00:03.6601227
        	Name = "AllocationAmount" Value = "104712"
        	Name = "AllocationKind" Value = "0"
        	Name = "ClrInstanceID" Value = "0"
        	Name = "AllocationAmount64" Value = "104712"
        	Name = "TypeID" Value = "1787297752"
        	Name = "TypeName" Value = "System.Object"
        	Name = "HeapIndex" Value = "0"
        	Name = "Address" Value = "2396152"
        
  
        [Simple] ThreadID = 2872 ID = 85 Name = ThreadCreated
        TimeStamp: 8/2/2018 7:09:15 AM
        LocalTime: 8/2/2018 7:09:19 AM
        Difference: 00:00:03.6193479
        	Name = "ManagedThreadID" Value = "1763982960"
        	Name = "AppDomainID" Value = "1723735920"
        	Name = "Flags" Value = "0"
        	Name = "ManagedThreadIndex" Value = "7"
        	Name = "OSThreadID" Value = "2872"
        	Name = "ClrInstanceID" Value = "0"
        
  
        [Simple] ThreadID = 2872 ID = 71 Name = ThreadRunning
        TimeStamp: 8/2/2018 7:09:15 AM
        LocalTime: 8/2/2018 7:09:19 AM
        Difference: 00:00:03.6194882
        	Name = "ID" Value = "1763982960"
        	Name = "ClrInstanceID" Value = "0"
        
  
        [Simple] ThreadID = 2872 ID = 145 Name = MethodJittingStarted_V1
        TimeStamp: 8/2/2018 7:09:15 AM
        LocalTime: 8/2/2018 7:09:19 AM
        Difference: 00:00:03.6193243
        	Name = "MethodID" Value = "1791492016"
        	Name = "ModuleID" Value = "1785724832"
        	Name = "MethodToken" Value = "100670965"
        	Name = "MethodILSize" Value = "133"
        	Name = "MethodNamespace" Value = "System.Diagnostics.Tracing.EventPipeEventDispatcher"
        	Name = "MethodName" Value = "TimeStampToDateTime"
        	Name = "MethodSignature" Value = "instance value class System.DateTime  (int64)"
        	Name = "ClrInstanceID" Value = "0"
        
  
        [Simple] ThreadID = 2872 ID = 143 Name = MethodLoadVerbose_V2
        TimeStamp: 8/2/2018 7:09:15 AM
        LocalTime: 8/2/2018 7:09:19 AM
        Difference: 00:00:03.6150592
        	Name = "MethodID" Value = "1791492016"
        	Name = "ModuleID" Value = "1785724832"
        	Name = "MethodStartAddress" Value = "1792016304"
        	Name = "MethodSize" Value = "264"
        	Name = "MethodToken" Value = "100670965"
        	Name = "MethodFlags" Value = "8"
        	Name = "MethodNamespace" Value = "System.Diagnostics.Tracing.EventPipeEventDispatcher"
        	Name = "MethodName" Value = "TimeStampToDateTime"
        	Name = "MethodSignature" Value = "instance value class System.DateTime  (int64)"
        	Name = "ClrInstanceID" Value = "0"
        	Name = "ReJITID" Value = ""
        
  
        [Simple] ThreadID = 2872 ID = 190 Name = MethodILToNativeMap
        TimeStamp: 8/2/2018 7:09:15 AM
        LocalTime: 8/2/2018 7:09:19 AM
        Difference: 00:00:03.6151830
        	Name = "MethodID" Value = "1791492016"
        	Name = "ReJITID" Value = "0"
        	Name = "MethodExtent" Value = "0"
        	Name = "CountOfMapEntries" Value = "15"
        
  
        [Simple] ThreadID = 2872 ID = 145 Name = MethodJittingStarted_V1
        TimeStamp: 8/2/2018 7:09:15 AM
        LocalTime: 8/2/2018 7:09:19 AM
        Difference: 00:00:03.6200239
        	Name = "MethodID" Value = "1792540664"
        	Name = "ModuleID" Value = "1785724832"
        	Name = "MethodToken" Value = "100670993"
        	Name = "MethodILSize" Value = "892"
        	Name = "MethodNamespace" Value = "System.Diagnostics.Tracing.EventPipePayloadDecoder"
        	Name = "MethodName" Value = "DecodePayload"
        	Name = "MethodSignature" Value = "class System.Object[]  (value class EventMetadata&amp;value class System.ReadOnlySpan`1&lt;unsigned int8&gt;)"
        	Name = "ClrInstanceID" Value = "0"
        
  
        [Simple] ThreadID = 2872 ID = 143 Name = MethodLoadVerbose_V2
        TimeStamp: 8/2/2018 7:09:15 AM
        LocalTime: 8/2/2018 7:09:19 AM
        Difference: 00:00:03.4660610
        	Name = "MethodID" Value = "1792540664"
        	Name = "ModuleID" Value = "1785724832"
        	Name = "MethodStartAddress" Value = "1792016368"
        	Name = "MethodSize" Value = "2299"
        	Name = "MethodToken" Value = "100670993"
        	Name = "MethodFlags" Value = "8"
        	Name = "MethodNamespace" Value = "System.Diagnostics.Tracing.EventPipePayloadDecoder"
        	Name = "MethodName" Value = "DecodePayload"
        	Name = "MethodSignature" Value = "class System.Object[]  (value class EventMetadata&amp;value class System.ReadOnlySpan`1&lt;unsigned int8&gt;)"
        	Name = "ClrInstanceID" Value = "0"
        	Name = "ReJITID" Value = ""
        
  
        Expected: 100
        Actual: -532462766
        END EXECUTION - FAILED
        FAILED
        Test Harness Exitcode is : 1
        
  To run the test:
  &gt; set CORE_ROOT=D:\j\workspace\x64_checked_w---fa5d14d7\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root
  &gt; D:\j\workspace\x64_checked_w---fa5d14d7\bin\tests\Windows_NT.x64.Checked\tracing\runtimeeventsource\runtimeeventsource\runtimeeventsource.cmd
  
        Expected: True
        Actual:   False
        Stack Trace:
          D:\j\workspace\x64_checked_w---fa5d14d7\bin\tests\Windows_NT.x64.Checked\TestWrappers\tracing.runtimeeventsource\tracing.runtimeeventsource.XUnitWrapper.cs(1090): at tracing_runtimeeventsource._runtimeeventsource_runtimeeventsource_._runtimeeventsource_runtimeeventsource_cmd()
```
</Title_Description>
    <Label>area-Tracing</Label>
    <Assignee>jorive</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19339</IssueLabelID>
    <Title>GThread inconsistent test failures</Title>
    <Description>I see inconsistent failures in baseservices\threading\generics\threadstart\GThread23\GThread23.cmd as well as GThread22 GThread24 for Windows x64 Checked test jobs in the CI. Looks like timeouts:

```
baseservices_threading._generics_threadstart_GThread23_GThread23_._generics_threadstart_GThread23_GThread23_cmd [FAIL]
        
  cmdLine:D:\j\workspace\checked_windo---14fb495b\bin\tests\Windows_NT.x64.Checked\baseservices\threading\generics\threadstart\GThread23\GThread23.cmd Timed Out
        
  
  Return code:      -100
  Raw output file:      D:\j\workspace\checked_windo---14fb495b\bin\tests\Windows_NT.x64.Checked\Reports\baseservices.threading\generics\threadstart\GThread23\GThread23.output.txt
  Raw output:
  BEGIN EXECUTION
         "D:\j\workspace\checked_windo---14fb495b\tests\..\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root\corerun.exe" GThread23.exe 
        
  cmdLine:D:\j\workspace\checked_windo---14fb495b\bin\tests\Windows_NT.x64.Checked\baseservices\threading\generics\threadstart\GThread23\GThread23.cmd Timed Out
        Test Harness Exitcode is : -100
        
  To run the test:
  &gt; set CORE_ROOT=D:\j\workspace\checked_windo---14fb495b\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root
  &gt; D:\j\workspace\checked_windo---14fb495b\bin\tests\Windows_NT.x64.Checked\baseservices\threading\generics\threadstart\GThread23\GThread23.cmd
  
        Expected: True
        Actual:   False
        Stack Trace:
          D:\j\workspace\checked_windo---14fb495b\bin\tests\Windows_NT.x64.Checked\TestWrappers\baseservices.threading\baseservices.threading.XUnitWrapper.cs(71090): at baseservices_threading._generics_threadstart_GThread23_GThread23_._generics_threadstart_GThread23_GThread23_cmd()
```

Overall: https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64/job/checked_windows_nt/

Also saw one timeout in Regressions\coreclr\1514\InterlockExchange\InterlockExchange.cmd
</Description>
    <Title_Description>GThread inconsistent test failures I see inconsistent failures in baseservices\threading\generics\threadstart\GThread23\GThread23.cmd as well as GThread22 GThread24 for Windows x64 Checked test jobs in the CI. Looks like timeouts:

```
baseservices_threading._generics_threadstart_GThread23_GThread23_._generics_threadstart_GThread23_GThread23_cmd [FAIL]
        
  cmdLine:D:\j\workspace\checked_windo---14fb495b\bin\tests\Windows_NT.x64.Checked\baseservices\threading\generics\threadstart\GThread23\GThread23.cmd Timed Out
        
  
  Return code:      -100
  Raw output file:      D:\j\workspace\checked_windo---14fb495b\bin\tests\Windows_NT.x64.Checked\Reports\baseservices.threading\generics\threadstart\GThread23\GThread23.output.txt
  Raw output:
  BEGIN EXECUTION
         "D:\j\workspace\checked_windo---14fb495b\tests\..\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root\corerun.exe" GThread23.exe 
        
  cmdLine:D:\j\workspace\checked_windo---14fb495b\bin\tests\Windows_NT.x64.Checked\baseservices\threading\generics\threadstart\GThread23\GThread23.cmd Timed Out
        Test Harness Exitcode is : -100
        
  To run the test:
  &gt; set CORE_ROOT=D:\j\workspace\checked_windo---14fb495b\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root
  &gt; D:\j\workspace\checked_windo---14fb495b\bin\tests\Windows_NT.x64.Checked\baseservices\threading\generics\threadstart\GThread23\GThread23.cmd
  
        Expected: True
        Actual:   False
        Stack Trace:
          D:\j\workspace\checked_windo---14fb495b\bin\tests\Windows_NT.x64.Checked\TestWrappers\baseservices.threading\baseservices.threading.XUnitWrapper.cs(71090): at baseservices_threading._generics_threadstart_GThread23_GThread23_._generics_threadstart_GThread23_GThread23_cmd()
```

Overall: https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64/job/checked_windows_nt/

Also saw one timeout in Regressions\coreclr\1514\InterlockExchange\InterlockExchange.cmd
</Title_Description>
    <Label>area-System.Threading</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>7/08/2018 9:31:22 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19337</IssueLabelID>
    <Title>PDBs for crossgenned binaries on Linux/macOS?</Title>
    <Description>I've been working on https://github.com/PowerShell/PowerShell/issues/7348 trying to get symbols available for PowerShell releases.

It looks like PDB generation for crossgen builds is:
 - possible on Windows with https://github.com/dotnet/coreclr/pull/4572
 - but not possible on Linux/macOS with DiaSymReader not open source (based on https://github.com/dotnet/coreclr/issues/8175)

Is that still correct?

Just want to register that PowerShell would get use out of PDBs for crossgen builds on Linux/macOS.</Description>
    <Title_Description>PDBs for crossgenned binaries on Linux/macOS? I've been working on https://github.com/PowerShell/PowerShell/issues/7348 trying to get symbols available for PowerShell releases.

It looks like PDB generation for crossgen builds is:
 - possible on Windows with https://github.com/dotnet/coreclr/pull/4572
 - but not possible on Linux/macOS with DiaSymReader not open source (based on https://github.com/dotnet/coreclr/issues/8175)

Is that still correct?

Just want to register that PowerShell would get use out of PDBs for crossgen builds on Linux/macOS.</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>7/08/2018 8:27:21 PM +00:00</CreatedAt>
    <ClosedAt>7/08/2018 8:59:32 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19333</IssueLabelID>
    <Title>[automated] Merge branch 'release/2.1' =&gt; 'release/2.2'</Title>
    <Description>I detected changes in the release/2.1 branch which have not been merged yet to release/2.2.
I'm a robot and am configured to help you automatically keep release/2.2 up to date so
I've opened this PR.

This PR merges commits made on release/2.1 by the following committers:

* @joshfree

## Instructions for merging

This PR will not be auto-merged. When pull request checks pass please complete this PR
by creating a merge commit *not* a squash or rebase commit.

&lt;img alt="merge button instructions" src="https://i.imgur.com/GepcNJV.png" width="300" /&gt;

You can also do this on command line:
```
git checkout release/2.2
git pull
git fetch --force https://github.com/dotnet-maestro-bot/coreclr merge/release/2.1-to-release/2.2:merge/release/2.1-to-release/2.2
git merge merge/release/2.1-to-release/2.2
git push
```

:warning: If there are merge conflicts you will need to resolve them manually before merging.

Please contact ASP.NET Core Engineering if you have questions or issues.
Also if this PR was generated incorrectly help us fix it. See https://github.com/aspnet/BuildTools/blob/master/scripts/GitHubMergeBranches.ps1.</Description>
    <Title_Description>[automated] Merge branch 'release/2.1' =&gt; 'release/2.2' I detected changes in the release/2.1 branch which have not been merged yet to release/2.2.
I'm a robot and am configured to help you automatically keep release/2.2 up to date so
I've opened this PR.

This PR merges commits made on release/2.1 by the following committers:

* @joshfree

## Instructions for merging

This PR will not be auto-merged. When pull request checks pass please complete this PR
by creating a merge commit *not* a squash or rebase commit.

&lt;img alt="merge button instructions" src="https://i.imgur.com/GepcNJV.png" width="300" /&gt;

You can also do this on command line:
```
git checkout release/2.2
git pull
git fetch --force https://github.com/dotnet-maestro-bot/coreclr merge/release/2.1-to-release/2.2:merge/release/2.1-to-release/2.2
git merge merge/release/2.1-to-release/2.2
git push
```

:warning: If there are merge conflicts you will need to resolve them manually before merging.

Please contact ASP.NET Core Engineering if you have questions or issues.
Also if this PR was generated incorrectly help us fix it. See https://github.com/aspnet/BuildTools/blob/master/scripts/GitHubMergeBranches.ps1.</Title_Description>
    <Label>os-tizen</Label>
    <Assignee>wtgodbe</Assignee>
    <CreatedAt>7/08/2018 5:23:14 PM +00:00</CreatedAt>
    <ClosedAt>8/08/2018 6:03:05 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19330</IssueLabelID>
    <Title>Add PInvoke/SafeHandles tests</Title>
    <Description>
    </Description>
    <Title_Description>Add PInvoke/SafeHandles tests </Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jkoritzinsky</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19328</IssueLabelID>
    <Title>Add PInvoke/NativeCallManagedComVisible tests</Title>
    <Description>
    </Description>
    <Title_Description>Add PInvoke/NativeCallManagedComVisible tests </Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jkoritzinsky</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19327</IssueLabelID>
    <Title>Bad check test count</Title>
    <Description>
    </Description>
    <Title_Description>Bad check test count </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>7/08/2018 6:19:13 AM +00:00</CreatedAt>
    <ClosedAt>7/08/2018 9:58:27 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19326</IssueLabelID>
    <Title>Add PInvoke/Miscellaneous tests</Title>
    <Description>
    </Description>
    <Title_Description>Add PInvoke/Miscellaneous tests </Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jkoritzinsky</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19324</IssueLabelID>
    <Title>Use dotnet MSBuild for tests</Title>
    <Description>Revert the revert of #19254

cc @BruceForstall @chsienki </Description>
    <Title_Description>Use dotnet MSBuild for tests Revert the revert of #19254

cc @BruceForstall @chsienki </Title_Description>
    <Label>test enhancement</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>7/08/2018 2:56:10 AM +00:00</CreatedAt>
    <ClosedAt>8/08/2018 12:42:16 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19323</IssueLabelID>
    <Title>Add PInvoke/Delegate tests</Title>
    <Description>
    </Description>
    <Title_Description>Add PInvoke/Delegate tests </Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jkoritzinsky</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19322</IssueLabelID>
    <Title>some methods unexpectedly bypass tier0 jitting and go straight to tier1</Title>
    <Description>Noticed this while messing about with the interpreter. A few methods from corelib unexpectedly end up getting jitted initially at tier1 and bypass tier0. 

@kouvel compiled this list for MusicStore:
```
System.SpanHelpers System.Private.CoreLib.SequenceEqual(Byte ByRef Byte ByRef UInt64)
System.SpanHelpers System.Private.CoreLib.IndexOf(Char ByRef Char Int32)
System.SpanHelpers System.Private.CoreLib.LastIndexOf(Char ByRef Char Int32)
System.SpanHelpers System.Private.CoreLib.SequenceCompareTo(Char ByRef Int32 Char ByRef Int32)
System.SpanHelpers System.Private.CoreLib.IndexOf(Byte ByRef Byte Int32)
System.Decimal+DecCalc System.Private.CoreLib.VarDecFromR8(Double DecCalc ByRef)
System.SZArrayHelper System.Private.CoreLib.get_Count&lt;&lt;System.Byte System.Private.CoreLib&gt;&gt;()
System.SZArrayHelper System.Private.CoreLib.get_Item&lt;&lt;System.Byte System.Private.CoreLib&gt;&gt;(Int32)
```
These all seem to be methods that use Vector or HW intrinsics. So perhaps when they bail out from crossgen something important gets bypassed and as a result tiering thinks that they're not tiering-eligible.

cc @noahfalk </Description>
    <Title_Description>some methods unexpectedly bypass tier0 jitting and go straight to tier1 Noticed this while messing about with the interpreter. A few methods from corelib unexpectedly end up getting jitted initially at tier1 and bypass tier0. 

@kouvel compiled this list for MusicStore:
```
System.SpanHelpers System.Private.CoreLib.SequenceEqual(Byte ByRef Byte ByRef UInt64)
System.SpanHelpers System.Private.CoreLib.IndexOf(Char ByRef Char Int32)
System.SpanHelpers System.Private.CoreLib.LastIndexOf(Char ByRef Char Int32)
System.SpanHelpers System.Private.CoreLib.SequenceCompareTo(Char ByRef Int32 Char ByRef Int32)
System.SpanHelpers System.Private.CoreLib.IndexOf(Byte ByRef Byte Int32)
System.Decimal+DecCalc System.Private.CoreLib.VarDecFromR8(Double DecCalc ByRef)
System.SZArrayHelper System.Private.CoreLib.get_Count&lt;&lt;System.Byte System.Private.CoreLib&gt;&gt;()
System.SZArrayHelper System.Private.CoreLib.get_Item&lt;&lt;System.Byte System.Private.CoreLib&gt;&gt;(Int32)
```
These all seem to be methods that use Vector or HW intrinsics. So perhaps when they bail out from crossgen something important gets bypassed and as a result tiering thinks that they're not tiering-eligible.

cc @noahfalk </Title_Description>
    <Label>area-TieredCompilation</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19317</IssueLabelID>
    <Title>spmi shim counter accesses mcs before it is initialized</Title>
    <Description>To repro: build then set up environment:

```
set COREDIR=c:\repos\coreclr\bin\tests\Windows_NT.x86.Release\Tests\Core_Root
set SuperPMIShimPath=%COREDIR%\clrjit.dll
set COMPlus_AltJit=*
set COMPlus_AltJitNgen=*
set COMPlus_AltJitName=superpmi-shim-counter.dll
set SuperPMIShimLogFilePath=&lt;something&gt;
set SuperPMILogFilePath=&lt;something&gt;
```
then run crossgen.

Workaround is to just ignore these early calls:
```diff
--- a/src/ToolBox/superpmi/superpmi-shim-counter/jithost.cpp
+++ b/src/ToolBox/superpmi/superpmi-shim-counter/jithost.cpp
@@ -3218 +3218 @@ void JitHost::freeMemory(void* block)

 int JitHost::getIntConfigValue(const wchar_t* key int defaultValue)
 {
-    mcs-&gt;AddCall("getIntConfigValue");
+    if (mcs != nullptr) mcs-&gt;AddCall("getIntConfigValue");
     return wrappedHost-&gt;getIntConfigValue(key defaultValue);
 }

 const wchar_t* JitHost::getStringConfigValue(const wchar_t* key)
 {
-    mcs-&gt;AddCall("getStringConfigValue");
+    if (mcs != nullptr) mcs-&gt;AddCall("getStringConfigValue");
     return wrappedHost-&gt;getStringConfigValue(key);
 }

 void JitHost::freeStringConfigValue(const wchar_t* value)
 {
-    mcs-&gt;AddCall("freeStringConfigValue");
+    if (mcs != nullptr) mcs-&gt;AddCall("freeStringConfigValue");
     wrappedHost-&gt;freeStringConfigValue(value);
 }
```


</Description>
    <Title_Description>spmi shim counter accesses mcs before it is initialized To repro: build then set up environment:

```
set COREDIR=c:\repos\coreclr\bin\tests\Windows_NT.x86.Release\Tests\Core_Root
set SuperPMIShimPath=%COREDIR%\clrjit.dll
set COMPlus_AltJit=*
set COMPlus_AltJitNgen=*
set COMPlus_AltJitName=superpmi-shim-counter.dll
set SuperPMIShimLogFilePath=&lt;something&gt;
set SuperPMILogFilePath=&lt;something&gt;
```
then run crossgen.

Workaround is to just ignore these early calls:
```diff
--- a/src/ToolBox/superpmi/superpmi-shim-counter/jithost.cpp
+++ b/src/ToolBox/superpmi/superpmi-shim-counter/jithost.cpp
@@ -3218 +3218 @@ void JitHost::freeMemory(void* block)

 int JitHost::getIntConfigValue(const wchar_t* key int defaultValue)
 {
-    mcs-&gt;AddCall("getIntConfigValue");
+    if (mcs != nullptr) mcs-&gt;AddCall("getIntConfigValue");
     return wrappedHost-&gt;getIntConfigValue(key defaultValue);
 }

 const wchar_t* JitHost::getStringConfigValue(const wchar_t* key)
 {
-    mcs-&gt;AddCall("getStringConfigValue");
+    if (mcs != nullptr) mcs-&gt;AddCall("getStringConfigValue");
     return wrappedHost-&gt;getStringConfigValue(key);
 }

 void JitHost::freeStringConfigValue(const wchar_t* value)
 {
-    mcs-&gt;AddCall("freeStringConfigValue");
+    if (mcs != nullptr) mcs-&gt;AddCall("freeStringConfigValue");
     wrappedHost-&gt;freeStringConfigValue(value);
 }
```


</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>sandreenko</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19309</IssueLabelID>
    <Title>Only register signals and create alt exception stack in coreclr.</Title>
    <Description>There was a couple of places where the DAC (IsValidObject GetAppDomainForObject)
assumed that a NULL target/debuggee address would throw an exception that would
be caught by try/catch. Any other invalid address is handled with a software
exception throwed by the read memory functions. In general it is a better overall
design not to have any of the DBI/DAC etc. code depend on hardware exceptions
being caught. On Linux the C++ runtime sometimes can't handle it. There is a
slight risk that there are other places in the DAC that make the NULL address
assumption but testing so far has found any.

Added PAL_SetInitializeDLLFlags as a fallback to allow the PAL_InitializeDLL flags
to be set for a PAL instance for the DAC where we could still register h/w signals
but not the altstack switching to reduce this risk. The flags can't be build time
conditional because we only build one coreclrpal.a library that all the modules
used. Having a PAL_InitializeFlags function doesn't really help either because of
the PAL_RegisterModule call to PAL_IntializeDLL and the LoadLibrary dance/protocol
that uses it to call the loading module's DLLMain.

Remove flags from PAL_INITIALIZE and PAL_INITIALIZE_DLL default. Add PAL_InitializeFlags()
to allow the default to be overridden.</Description>
    <Title_Description>Only register signals and create alt exception stack in coreclr. There was a couple of places where the DAC (IsValidObject GetAppDomainForObject)
assumed that a NULL target/debuggee address would throw an exception that would
be caught by try/catch. Any other invalid address is handled with a software
exception throwed by the read memory functions. In general it is a better overall
design not to have any of the DBI/DAC etc. code depend on hardware exceptions
being caught. On Linux the C++ runtime sometimes can't handle it. There is a
slight risk that there are other places in the DAC that make the NULL address
assumption but testing so far has found any.

Added PAL_SetInitializeDLLFlags as a fallback to allow the PAL_InitializeDLL flags
to be set for a PAL instance for the DAC where we could still register h/w signals
but not the altstack switching to reduce this risk. The flags can't be build time
conditional because we only build one coreclrpal.a library that all the modules
used. Having a PAL_InitializeFlags function doesn't really help either because of
the PAL_RegisterModule call to PAL_IntializeDLL and the LoadLibrary dance/protocol
that uses it to call the loading module's DLLMain.

Remove flags from PAL_INITIALIZE and PAL_INITIALIZE_DLL default. Add PAL_InitializeFlags()
to allow the default to be overridden.</Title_Description>
    <Label>
    </Label>
    <Assignee>mikem8361</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19308</IssueLabelID>
    <Title>Fix type of cast node generated by box import</Title>
    <Description>Importing box to primitive type may produce a cast node that has "incorrect" type:
https://github.com/dotnet/coreclr/blob/ac8f8e52c49b0ffa712d68730a41883d281bea01/src/jit/importer.cpp#L5681
Normally the type of the cast node is `TYP_INT` or `TYP_LONG` the actual type of the cast type. The above code can produce a node having small int type which is unusual. So far it seems that this is the only place where the JIT produces such a cast.

Changing the cast node type to be the actual type results in an assert here:
https://github.com/dotnet/coreclr/blob/ac8f8e52c49b0ffa712d68730a41883d281bea01/src/jit/gentree.cpp#L13240-L13242

when compiling code like:
```C#
enum ShortEnum : short
{
    None
    Boo
}

static bool Test(ShortEnum s) =&gt; s.HasFlag(ShortEnum.Boo);
```
Those types should too be "actual" types. As is we end up generating `TYP_SHORT` `AND`/`EQ` nodes that are also unusual and some less than ideal assembly code:
```asm
       480FBFC1             movsx    rax cx
       BA01000000           mov      edx 1
       6623C2               and      ax dx
       663BC2               cmp      ax dx
       0F94C0               sete     al
       0FB6C0               movzx    rax al
```
Normally this should generate
```asm
       movsx    rax cx ; this could be omitted too but that's another story
       test     al 1
       sete     al
       movzx    rax al
```</Description>
    <Title_Description>Fix type of cast node generated by box import Importing box to primitive type may produce a cast node that has "incorrect" type:
https://github.com/dotnet/coreclr/blob/ac8f8e52c49b0ffa712d68730a41883d281bea01/src/jit/importer.cpp#L5681
Normally the type of the cast node is `TYP_INT` or `TYP_LONG` the actual type of the cast type. The above code can produce a node having small int type which is unusual. So far it seems that this is the only place where the JIT produces such a cast.

Changing the cast node type to be the actual type results in an assert here:
https://github.com/dotnet/coreclr/blob/ac8f8e52c49b0ffa712d68730a41883d281bea01/src/jit/gentree.cpp#L13240-L13242

when compiling code like:
```C#
enum ShortEnum : short
{
    None
    Boo
}

static bool Test(ShortEnum s) =&gt; s.HasFlag(ShortEnum.Boo);
```
Those types should too be "actual" types. As is we end up generating `TYP_SHORT` `AND`/`EQ` nodes that are also unusual and some less than ideal assembly code:
```asm
       480FBFC1             movsx    rax cx
       BA01000000           mov      edx 1
       6623C2               and      ax dx
       663BC2               cmp      ax dx
       0F94C0               sete     al
       0FB6C0               movzx    rax al
```
Normally this should generate
```asm
       movsx    rax cx ; this could be omitted too but that's another story
       test     al 1
       sete     al
       movzx    rax al
```</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>6/08/2018 4:51:47 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19307</IssueLabelID>
    <Title>Support for reflection-invoking methods that take pointers by reference</Title>
    <Description>dotnet/coreclr#17732 added support for reflection-invoking methods that return unmanaged pointers by reference (so e.g. `ref void* Do()`) but methods that get them by-reference as their parameters are still pretty broken (so e.g. `void Do(ref void* x)`).

For example:

```csharp
using System;
using System.Reflection;

unsafe class Program
{
    public static void InvokeMe(out int* pointer)
    {
        pointer = (int*)0x12345;
    }

    static void Main(string[] args)
    {
        typeof(Program).GetMethod(nameof(InvokeMe)).Invoke(null new object[] { null });
    }
}
```

Will crash the runtime with an `ExecutionEngineException`.

(Note this behavior is on parity with the desktop CLR so it has quite likely been this broken for 17 years.)</Description>
    <Title_Description>Support for reflection-invoking methods that take pointers by reference dotnet/coreclr#17732 added support for reflection-invoking methods that return unmanaged pointers by reference (so e.g. `ref void* Do()`) but methods that get them by-reference as their parameters are still pretty broken (so e.g. `void Do(ref void* x)`).

For example:

```csharp
using System;
using System.Reflection;

unsafe class Program
{
    public static void InvokeMe(out int* pointer)
    {
        pointer = (int*)0x12345;
    }

    static void Main(string[] args)
    {
        typeof(Program).GetMethod(nameof(InvokeMe)).Invoke(null new object[] { null });
    }
}
```

Will crash the runtime with an `ExecutionEngineException`.

(Note this behavior is on parity with the desktop CLR so it has quite likely been this broken for 17 years.)</Title_Description>
    <Label>area-System.Reflection</Label>
    <Assignee>MichalStrehovsky</Assignee>
    <CreatedAt>6/08/2018 4:07:30 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19304</IssueLabelID>
    <Title>Add PInvoke/Primitives/Int tests</Title>
    <Description>
    </Description>
    <Title_Description>Add PInvoke/Primitives/Int tests </Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jkoritzinsky</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19303</IssueLabelID>
    <Title>Add PInvoke/ExactSpelling tests</Title>
    <Description>
    </Description>
    <Title_Description>Add PInvoke/ExactSpelling tests </Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jkoritzinsky</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19302</IssueLabelID>
    <Title>Test failure: tracing_eventsource._eventpipeandetw_eventpipeandetw_eventpipeandetw_/_eventpipeandetw_eventpipeandetw_eventpipeandetw_cmd</Title>
    <Description>Opened on behalf of @Sunny-pu

The test `tracing_eventsource._eventpipeandetw_eventpipeandetw_eventpipeandetw_/_eventpipeandetw_eventpipeandetw_eventpipeandetw_cmd` has failed.


    Unhandled Exception: System.InvalidOperationException: TdhEnumerateProviders failed.\r
       at Microsoft.Diagnostics.Tracing.Session.TraceEventSession.get_ProviderNameToGuid()\r
       at Microsoft.Diagnostics.Tracing.Session.TraceEventProviders.GetProviderGuidByName(String name)\r
       at Microsoft.Diagnostics.Tracing.Session.TraceEventSession.EnableProvider(String providerName TraceEventLevel providerLevel UInt64 matchAnyKeywords TraceEventProviderOptions options)\r
       at Tracing.Tests.EventPipeAndEtw.EnableETW(EventSource eventSource EventKeywords keywords String outputFile) in E:\\A\\_work\\138\\s\\tests\\src\\tracing\\eventsource\\eventpipeandetw\\EventPipeAndEtw.cs:line 113\r
       at Tracing.Tests.EventPipeAndEtw.RoundOne(String[] args) in E:\\A\\_work\\138\\s\\tests\\src\\tracing\\eventsource\\eventpipeandetw\\EventPipeAndEtw.cs:line 144\r
       at Tracing.Tests.EventPipeAndEtw.Main(String[] args) in E:\\A\\_work\\138\\s\\tests\\src\\tracing\\eventsource\\eventpipeandetw\\EventPipeAndEtw.cs:line 287
    
    
    Return code:      1
    Raw output file:      C:\\work\\f2125dcf-0985-4d70-b7d0-00824a6edc84\\Work\\c8415983-ece0-46e7-b42d-256fbc794b63\\Unzip\\Reports\\tracing.eventsource\\eventpipeandetw\\eventpipeandetw\\eventpipeandetw.output.txt
    Raw output:
    BEGIN EXECUTION\r
            1 file(s) copied.\r
    \" C:\\work\\f2125dcf-0985-4d70-b7d0-00824a6edc84\\Payload\\crossgen.exe\" /Platform_Assemblies_Paths C:\\work\\f2125dcf-0985-4d70-b7d0-00824a6edc84\\Payload;C:\\work\\f2125dcf-0985-4d70-b7d0-00824a6edc84\\Work\\c8415983-ece0-46e7-b42d-256fbc794b63\\Unzip\\eventpipeandetw\\eventpipeandetw\\IL;C:\\work\\f2125dcf-0985-4d70-b7d0-00824a6edc84\\Work\\c8415983-ece0-46e7-b42d-256fbc794b63\\Unzip\\eventpipeandetw\\eventpipeandetw /in eventpipeandetw.org /out eventpipeandetw.exe\r
    Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0\r
    Copyright (c) Microsoft Corporation.  All rights reserved.\r
    \r
    Native image eventpipeandetw.exe generated successfully.\r
     \"C:\\work\\f2125dcf-0985-4d70-b7d0-00824a6edc84\\Payload\\corerun.exe\" eventpipeandetw.exe \r
    \tStart: Enable EventPipe.\r
    \tEnd: Enable EventPipe.
    \r
    \tStart: Enable ETW.\r
    Expected: 100\r
    Actual: -532462766\r
    END EXECUTION - FAILED\r
    FAILED\r
    Test Harness Exitcode is : 1\r
    
    To run the test:
    &gt; set CORE_ROOT=C:\\work\\f2125dcf-0985-4d70-b7d0-00824a6edc84\\Payload
    &gt; C:\\work\\f2125dcf-0985-4d70-b7d0-00824a6edc84\\Work\\c8415983-ece0-46e7-b42d-256fbc794b63\\Unzip\\eventpipeandetw\\eventpipeandetw\\eventpipeandetw.cmd
    \r
    Expected: True\r
    Actual:   False

        Stack Trace:

        
Build : 3.0 - 20180806.01 (Ready-To-Run Tests)
Failing configurations:
- Windows.10.Nano.Amd64
  - x64

Details: https://mc.dot.net/#/product/netcore/30/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fr2r~2Fcli~2F/build/20180806.01/workItem/tracing.eventsource.XUnitWrapper/analysis/xunit/tracing_eventsource._eventpipeandetw_eventpipeandetw_eventpipeandetw_~2F_eventpipeandetw_eventpipeandetw_eventpipeandetw_cmd</Description>
    <Title_Description>Test failure: tracing_eventsource._eventpipeandetw_eventpipeandetw_eventpipeandetw_/_eventpipeandetw_eventpipeandetw_eventpipeandetw_cmd Opened on behalf of @Sunny-pu

The test `tracing_eventsource._eventpipeandetw_eventpipeandetw_eventpipeandetw_/_eventpipeandetw_eventpipeandetw_eventpipeandetw_cmd` has failed.


    Unhandled Exception: System.InvalidOperationException: TdhEnumerateProviders failed.\r
       at Microsoft.Diagnostics.Tracing.Session.TraceEventSession.get_ProviderNameToGuid()\r
       at Microsoft.Diagnostics.Tracing.Session.TraceEventProviders.GetProviderGuidByName(String name)\r
       at Microsoft.Diagnostics.Tracing.Session.TraceEventSession.EnableProvider(String providerName TraceEventLevel providerLevel UInt64 matchAnyKeywords TraceEventProviderOptions options)\r
       at Tracing.Tests.EventPipeAndEtw.EnableETW(EventSource eventSource EventKeywords keywords String outputFile) in E:\\A\\_work\\138\\s\\tests\\src\\tracing\\eventsource\\eventpipeandetw\\EventPipeAndEtw.cs:line 113\r
       at Tracing.Tests.EventPipeAndEtw.RoundOne(String[] args) in E:\\A\\_work\\138\\s\\tests\\src\\tracing\\eventsource\\eventpipeandetw\\EventPipeAndEtw.cs:line 144\r
       at Tracing.Tests.EventPipeAndEtw.Main(String[] args) in E:\\A\\_work\\138\\s\\tests\\src\\tracing\\eventsource\\eventpipeandetw\\EventPipeAndEtw.cs:line 287
    
    
    Return code:      1
    Raw output file:      C:\\work\\f2125dcf-0985-4d70-b7d0-00824a6edc84\\Work\\c8415983-ece0-46e7-b42d-256fbc794b63\\Unzip\\Reports\\tracing.eventsource\\eventpipeandetw\\eventpipeandetw\\eventpipeandetw.output.txt
    Raw output:
    BEGIN EXECUTION\r
            1 file(s) copied.\r
    \" C:\\work\\f2125dcf-0985-4d70-b7d0-00824a6edc84\\Payload\\crossgen.exe\" /Platform_Assemblies_Paths C:\\work\\f2125dcf-0985-4d70-b7d0-00824a6edc84\\Payload;C:\\work\\f2125dcf-0985-4d70-b7d0-00824a6edc84\\Work\\c8415983-ece0-46e7-b42d-256fbc794b63\\Unzip\\eventpipeandetw\\eventpipeandetw\\IL;C:\\work\\f2125dcf-0985-4d70-b7d0-00824a6edc84\\Work\\c8415983-ece0-46e7-b42d-256fbc794b63\\Unzip\\eventpipeandetw\\eventpipeandetw /in eventpipeandetw.org /out eventpipeandetw.exe\r
    Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0\r
    Copyright (c) Microsoft Corporation.  All rights reserved.\r
    \r
    Native image eventpipeandetw.exe generated successfully.\r
     \"C:\\work\\f2125dcf-0985-4d70-b7d0-00824a6edc84\\Payload\\corerun.exe\" eventpipeandetw.exe \r
    \tStart: Enable EventPipe.\r
    \tEnd: Enable EventPipe.
    \r
    \tStart: Enable ETW.\r
    Expected: 100\r
    Actual: -532462766\r
    END EXECUTION - FAILED\r
    FAILED\r
    Test Harness Exitcode is : 1\r
    
    To run the test:
    &gt; set CORE_ROOT=C:\\work\\f2125dcf-0985-4d70-b7d0-00824a6edc84\\Payload
    &gt; C:\\work\\f2125dcf-0985-4d70-b7d0-00824a6edc84\\Work\\c8415983-ece0-46e7-b42d-256fbc794b63\\Unzip\\eventpipeandetw\\eventpipeandetw\\eventpipeandetw.cmd
    \r
    Expected: True\r
    Actual:   False

        Stack Trace:

        
Build : 3.0 - 20180806.01 (Ready-To-Run Tests)
Failing configurations:
- Windows.10.Nano.Amd64
  - x64

Details: https://mc.dot.net/#/product/netcore/30/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fr2r~2Fcli~2F/build/20180806.01/workItem/tracing.eventsource.XUnitWrapper/analysis/xunit/tracing_eventsource._eventpipeandetw_eventpipeandetw_eventpipeandetw_~2F_eventpipeandetw_eventpipeandetw_eventpipeandetw_cmd</Title_Description>
    <Label>area-Tracing</Label>
    <Assignee>jorive</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19301</IssueLabelID>
    <Title>Add PInvoke/Decimal tests</Title>
    <Description>Fixes #18908</Description>
    <Title_Description>Add PInvoke/Decimal tests Fixes #18908</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jkoritzinsky</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19300</IssueLabelID>
    <Title>Cannot run linux-arm64 published binary on CentOS 7 ARM64: GLIBCXX_3.4.21 not found</Title>
    <Description>The nuget packages built for linux-arm64 uses higher GLIBCXX versions than that on CentOS 7.

Steps to reproduce:
On a x86_64 machine with latest .NET Core SDK installed:
```
mkdir HelloWorld
cd HelloWorld
dotnet new console
dotnet publish -c Release -f netcoreapp2.1 -r linux-arm64
```

Copy the `publish` folder to a CentOS 7 ARM64 machine:
```
cd publish
./HelloWorld
```
output:
```
[hjc@centos7-64 publish]$ ./HelloWorld 
./HelloWorld: /lib64/libstdc++.so.6: version `GLIBCXX_3.4.21' not found (required by ./HelloWorld)
```


This is probably because CentOS's libstdc++ only has GLIBCXX symbols up to 3.4.19
```
[hjc@centos7-64 publish]$ nm -D /lib64/libstdc++.so.6|grep GLIBCXX
0000000000000000 A GLIBCXX_3.4
0000000000000000 A GLIBCXX_3.4.1
0000000000000000 A GLIBCXX_3.4.10
0000000000000000 A GLIBCXX_3.4.11
0000000000000000 A GLIBCXX_3.4.12
0000000000000000 A GLIBCXX_3.4.13
0000000000000000 A GLIBCXX_3.4.14
0000000000000000 A GLIBCXX_3.4.15
0000000000000000 A GLIBCXX_3.4.16
0000000000000000 A GLIBCXX_3.4.17
0000000000000000 A GLIBCXX_3.4.18
0000000000000000 A GLIBCXX_3.4.19
0000000000000000 A GLIBCXX_3.4.2
0000000000000000 A GLIBCXX_3.4.3
0000000000000000 A GLIBCXX_3.4.4
0000000000000000 A GLIBCXX_3.4.5
0000000000000000 A GLIBCXX_3.4.6
0000000000000000 A GLIBCXX_3.4.7
0000000000000000 A GLIBCXX_3.4.8
0000000000000000 A GLIBCXX_3.4.9
```</Description>
    <Title_Description>Cannot run linux-arm64 published binary on CentOS 7 ARM64: GLIBCXX_3.4.21 not found The nuget packages built for linux-arm64 uses higher GLIBCXX versions than that on CentOS 7.

Steps to reproduce:
On a x86_64 machine with latest .NET Core SDK installed:
```
mkdir HelloWorld
cd HelloWorld
dotnet new console
dotnet publish -c Release -f netcoreapp2.1 -r linux-arm64
```

Copy the `publish` folder to a CentOS 7 ARM64 machine:
```
cd publish
./HelloWorld
```
output:
```
[hjc@centos7-64 publish]$ ./HelloWorld 
./HelloWorld: /lib64/libstdc++.so.6: version `GLIBCXX_3.4.21' not found (required by ./HelloWorld)
```


This is probably because CentOS's libstdc++ only has GLIBCXX symbols up to 3.4.19
```
[hjc@centos7-64 publish]$ nm -D /lib64/libstdc++.so.6|grep GLIBCXX
0000000000000000 A GLIBCXX_3.4
0000000000000000 A GLIBCXX_3.4.1
0000000000000000 A GLIBCXX_3.4.10
0000000000000000 A GLIBCXX_3.4.11
0000000000000000 A GLIBCXX_3.4.12
0000000000000000 A GLIBCXX_3.4.13
0000000000000000 A GLIBCXX_3.4.14
0000000000000000 A GLIBCXX_3.4.15
0000000000000000 A GLIBCXX_3.4.16
0000000000000000 A GLIBCXX_3.4.17
0000000000000000 A GLIBCXX_3.4.18
0000000000000000 A GLIBCXX_3.4.19
0000000000000000 A GLIBCXX_3.4.2
0000000000000000 A GLIBCXX_3.4.3
0000000000000000 A GLIBCXX_3.4.4
0000000000000000 A GLIBCXX_3.4.5
0000000000000000 A GLIBCXX_3.4.6
0000000000000000 A GLIBCXX_3.4.7
0000000000000000 A GLIBCXX_3.4.8
0000000000000000 A GLIBCXX_3.4.9
```</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>6/08/2018 7:45:03 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19299</IssueLabelID>
    <Title>Test failure: JIT_HardwareIntrinsics._X86_Avx_Avx_ro_Avx_ro_/_X86_Avx_Avx_ro_Avx_ro_cmd</Title>
    <Description>Opened on behalf of @Sunny-pu

The test `JIT_HardwareIntrinsics._X86_Avx_Avx_ro_Avx_ro_/_X86_Avx_Avx_ro_Avx_ro_cmd` has failed.

/Users/dotnet-bot/dotnetbuild/work/94bf0b1f-9c0f-4b51-8b45-bc2c3b20cff7/Work/acf3d313-bf55-4ff6-952f-68bfbb7b9dbf/Unzip/X86/Avx/Avx_ro/Avx_ro.sh: line 244: 76085 Abort trap: 6           $_DebuggerFullPath \"$CORE_ROOT/corerun\" $ExePath $CLRTestExecutionArguments
    
    
    Return code:      1
    Raw output file:      /Users/dotnet-bot/dotnetbuild/work/94bf0b1f-9c0f-4b51-8b45-bc2c3b20cff7/Work/acf3d313-bf55-4ff6-952f-68bfbb7b9dbf/Unzip/Reports\\JIT.HardwareIntrinsics\\X86\\Avx\\Avx_ro\\Avx_ro.output.txt
    Raw output:
    BEGIN EXECUTION
    /Users/dotnet-bot/dotnetbuild/work/94bf0b1f-9c0f-4b51-8b45-bc2c3b20cff7/Payload/corerun Avx_ro.exe
    Supported ISAs:
      AES:       False
      AVX:       True
      AVX2:      False
      BMI1:      False
      BMI2:      False
      FMA:       False
      LZCNT:     False
      PCLMULQDQ: False
      POPCNT:    True
      SSE:       True
      SSE2:      True
      SSE3:      True
      SSE4.1:    True
      SSE4.2:    True
      SSSE3:     True
    
    Beginning test case Add.Double at 08/05/2018 19:26:15
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case Add.Single at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case AddSubtract.Double at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case AddSubtract.Single at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case And.Double at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case And.Single at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case AndNot.Double at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case AndNot.Single at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case BlendVariable.Double at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case BlendVariable.Single at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case Ceiling.Double at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case Ceiling.Single at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case Divide.Double at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case Divide.Single at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case DuplicateEvenIndexed.Double at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case DuplicateEvenIndexed.Single at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case DuplicateOddIndexed.Single at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case Extract.Byte.1 at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    Expected: 100
    Actual: 134
    END EXECUTION - FAILED
    Test Harness Exitcode is : 1
    
    To run the test:
    &gt; set CORE_ROOT=/Users/dotnet-bot/dotnetbuild/work/94bf0b1f-9c0f-4b51-8b45-bc2c3b20cff7/Payload
    &gt; /Users/dotnet-bot/dotnetbuild/work/94bf0b1f-9c0f-4b51-8b45-bc2c3b20cff7/Work/acf3d313-bf55-4ff6-952f-68bfbb7b9dbf/Unzip/X86/Avx/Avx_ro/Avx_ro.sh
    
    Expected: True
    Actual:   False

        Stack Trace:

        
Build : 3.0 - 20180806.01 (Core Tests)
Failing configurations:
- osx.1013.amd64-x64
  - 
- osx.1012.amd64-x64
  - 

Details: https://mc.dot.net/#/product/netcore/30/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fcli~2F/build/20180806.01/workItem/JIT.HardwareIntrinsics.XUnitWrapper/analysis/xunit/JIT_HardwareIntrinsics._X86_Avx_Avx_ro_Avx_ro_~2F_X86_Avx_Avx_ro_Avx_ro_cmd</Description>
    <Title_Description>Test failure: JIT_HardwareIntrinsics._X86_Avx_Avx_ro_Avx_ro_/_X86_Avx_Avx_ro_Avx_ro_cmd Opened on behalf of @Sunny-pu

The test `JIT_HardwareIntrinsics._X86_Avx_Avx_ro_Avx_ro_/_X86_Avx_Avx_ro_Avx_ro_cmd` has failed.

/Users/dotnet-bot/dotnetbuild/work/94bf0b1f-9c0f-4b51-8b45-bc2c3b20cff7/Work/acf3d313-bf55-4ff6-952f-68bfbb7b9dbf/Unzip/X86/Avx/Avx_ro/Avx_ro.sh: line 244: 76085 Abort trap: 6           $_DebuggerFullPath \"$CORE_ROOT/corerun\" $ExePath $CLRTestExecutionArguments
    
    
    Return code:      1
    Raw output file:      /Users/dotnet-bot/dotnetbuild/work/94bf0b1f-9c0f-4b51-8b45-bc2c3b20cff7/Work/acf3d313-bf55-4ff6-952f-68bfbb7b9dbf/Unzip/Reports\\JIT.HardwareIntrinsics\\X86\\Avx\\Avx_ro\\Avx_ro.output.txt
    Raw output:
    BEGIN EXECUTION
    /Users/dotnet-bot/dotnetbuild/work/94bf0b1f-9c0f-4b51-8b45-bc2c3b20cff7/Payload/corerun Avx_ro.exe
    Supported ISAs:
      AES:       False
      AVX:       True
      AVX2:      False
      BMI1:      False
      BMI2:      False
      FMA:       False
      LZCNT:     False
      PCLMULQDQ: False
      POPCNT:    True
      SSE:       True
      SSE2:      True
      SSE3:      True
      SSE4.1:    True
      SSE4.2:    True
      SSSE3:     True
    
    Beginning test case Add.Double at 08/05/2018 19:26:15
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case Add.Single at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case AddSubtract.Double at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case AddSubtract.Single at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case And.Double at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case And.Single at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case AndNot.Double at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case AndNot.Single at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case BlendVariable.Double at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case BlendVariable.Single at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case Ceiling.Double at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case Ceiling.Single at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case Divide.Double at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case Divide.Single at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case DuplicateEvenIndexed.Double at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case DuplicateEvenIndexed.Single at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case DuplicateOddIndexed.Single at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    
    Ending test case at 08/05/2018 19:26:16
    Beginning test case Extract.Byte.1 at 08/05/2018 19:26:16
    Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
    
    Expected: 100
    Actual: 134
    END EXECUTION - FAILED
    Test Harness Exitcode is : 1
    
    To run the test:
    &gt; set CORE_ROOT=/Users/dotnet-bot/dotnetbuild/work/94bf0b1f-9c0f-4b51-8b45-bc2c3b20cff7/Payload
    &gt; /Users/dotnet-bot/dotnetbuild/work/94bf0b1f-9c0f-4b51-8b45-bc2c3b20cff7/Work/acf3d313-bf55-4ff6-952f-68bfbb7b9dbf/Unzip/X86/Avx/Avx_ro/Avx_ro.sh
    
    Expected: True
    Actual:   False

        Stack Trace:

        
Build : 3.0 - 20180806.01 (Core Tests)
Failing configurations:
- osx.1013.amd64-x64
  - 
- osx.1012.amd64-x64
  - 

Details: https://mc.dot.net/#/product/netcore/30/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fcli~2F/build/20180806.01/workItem/JIT.HardwareIntrinsics.XUnitWrapper/analysis/xunit/JIT_HardwareIntrinsics._X86_Avx_Avx_ro_Avx_ro_~2F_X86_Avx_Avx_ro_Avx_ro_cmd</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19298</IssueLabelID>
    <Title>Add PInvoke/DateTime tests</Title>
    <Description>
    </Description>
    <Title_Description>Add PInvoke/DateTime tests </Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jkoritzinsky</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19297</IssueLabelID>
    <Title>Add PInvoke/CriticalHandles tests</Title>
    <Description>
    </Description>
    <Title_Description>Add PInvoke/CriticalHandles tests </Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jkoritzinsky</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19295</IssueLabelID>
    <Title>Frequent failure in CoreFX ReadAsyncCompletesIfFlushAsyncCanceledMidFlush test</Title>
    <Description>This fails in Jenkins frequently though not always e.g.:

Windows x86:

https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/x86_checked_windows_nt_corefx_baseline/562/
https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/x86_checked_windows_nt_corefx_baseline/560/
https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/x86_checked_windows_nt_corefx_baseline/558/
https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/x86_checked_windows_nt_corefx_baseline/557/
https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/x86_checked_windows_nt_corefx_baseline/554/

Windows x64:

https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/x64_checked_windows_nt_corefx_baseline/590/

```  System.IO.Pipelines.Tests.FlushAsyncCancellationTests.ReadAsyncCompletesIfFlushAsyncCanceledMidFlush [FAIL]
        Reader was not completed in reasonable time
        Expected: True
        Actual:   False
```
</Description>
    <Title_Description>Frequent failure in CoreFX ReadAsyncCompletesIfFlushAsyncCanceledMidFlush test This fails in Jenkins frequently though not always e.g.:

Windows x86:

https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/x86_checked_windows_nt_corefx_baseline/562/
https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/x86_checked_windows_nt_corefx_baseline/560/
https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/x86_checked_windows_nt_corefx_baseline/558/
https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/x86_checked_windows_nt_corefx_baseline/557/
https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/x86_checked_windows_nt_corefx_baseline/554/

Windows x64:

https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/x64_checked_windows_nt_corefx_baseline/590/

```  System.IO.Pipelines.Tests.FlushAsyncCancellationTests.ReadAsyncCompletesIfFlushAsyncCanceledMidFlush [FAIL]
        Reader was not completed in reasonable time
        Expected: True
        Actual:   False
```
</Title_Description>
    <Label>
    </Label>
    <Assignee>pakrym</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19293</IssueLabelID>
    <Title>Array -&gt; Memory -&gt; Span overly defensive?</Title>
    <Description>Creating a {ReadOnly}Memory from an array does lots of checks; which is correct
https://github.com/dotnet/coreclr/blob/9d1e7dd8eb744b14eb4a90b401e854d7a5f79fff/src/System.Private.CoreLib/shared/System/Memory.cs#L96-L113

Slicing a {ReadOnly}Memory also performs bounds checks based on the confirmed offset and lengths

However creating a Span from and array backed {ReadOnly}Memory uses the regular array constructor
https://github.com/dotnet/coreclr/blob/9d1e7dd8eb744b14eb4a90b401e854d7a5f79fff/src/System.Private.CoreLib/shared/System/Memory.cs#L286-L289

Which then rechecks all the parameters again 
https://github.com/dotnet/coreclr/blob/9d1e7dd8eb744b14eb4a90b401e854d7a5f79fff/src/System.Private.CoreLib/shared/System/Span.Fast.cs#L73-L89

This makes an array backed Memory the most expensive kind of Span creator.

Does it need to recheck everything or can it use an internal Span .ctor that bypasses the additional checks?

/cc @jkotas @stephentoub @GrabYourPitchforks @davidfowl @ahsonkhan </Description>
    <Title_Description>Array -&gt; Memory -&gt; Span overly defensive? Creating a {ReadOnly}Memory from an array does lots of checks; which is correct
https://github.com/dotnet/coreclr/blob/9d1e7dd8eb744b14eb4a90b401e854d7a5f79fff/src/System.Private.CoreLib/shared/System/Memory.cs#L96-L113

Slicing a {ReadOnly}Memory also performs bounds checks based on the confirmed offset and lengths

However creating a Span from and array backed {ReadOnly}Memory uses the regular array constructor
https://github.com/dotnet/coreclr/blob/9d1e7dd8eb744b14eb4a90b401e854d7a5f79fff/src/System.Private.CoreLib/shared/System/Memory.cs#L286-L289

Which then rechecks all the parameters again 
https://github.com/dotnet/coreclr/blob/9d1e7dd8eb744b14eb4a90b401e854d7a5f79fff/src/System.Private.CoreLib/shared/System/Span.Fast.cs#L73-L89

This makes an array backed Memory the most expensive kind of Span creator.

Does it need to recheck everything or can it use an internal Span .ctor that bypasses the additional checks?

/cc @jkotas @stephentoub @GrabYourPitchforks @davidfowl @ahsonkhan </Title_Description>
    <Label>area-System.Memory</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>5/08/2018 8:36:45 AM +00:00</CreatedAt>
    <ClosedAt>17/11/2018 12:42:32 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19292</IssueLabelID>
    <Title>.NET Core 2.1: Non-GAC DLLs Not Found</Title>
    <Description>See https://github.com/PowerShell/PowerShell/issues/7326 and https://github.com/PowerShell/PowerShell/issues/7076 for further details. Thank you!</Description>
    <Title_Description>.NET Core 2.1: Non-GAC DLLs Not Found See https://github.com/PowerShell/PowerShell/issues/7326 and https://github.com/PowerShell/PowerShell/issues/7076 for further details. Thank you!</Title_Description>
    <Label>area-AssemblyLoader</Label>
    <Assignee>vitek-karas</Assignee>
    <CreatedAt>5/08/2018 2:37:38 AM +00:00</CreatedAt>
    <ClosedAt>7/08/2018 8:46:23 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19289</IssueLabelID>
    <Title>AggressiveInlining flaw?</Title>
    <Description>I can understand why a method with MethodImplOptions.AggressiveInlining attribute passed as Action cannot be in-lined when called. However I don't see any reason why such method couldn't be in-lined in case it is passed to a constructor and stored in a readonly field. See the following code fragment.
I believe the call to `_inline()` inside `PassInlinendMethod.Main()` should be considered for in-lining and in this particular case in-lined.

```csharp
using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;

namespace TestInline
{
    class Program
    {
        static void Main()
        {
            Console.WriteLine("Direct call");
            NotInlinedMethod();
            IfYouSeeThisItIsNotInlined();

            Console.WriteLine("\nPassed as parameter");
            new PassInlinendMethod(NotInlinedMethod IfYouSeeThisItIsNotInlined).Main();
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        private static void NotInlinedMethod() =&gt; Console.WriteLine(new StackTrace().GetFrame(0).GetMethod().Name);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static void IfYouSeeThisItIsNotInlined() =&gt; Console.WriteLine(new StackTrace().GetFrame(0).GetMethod().Name);

        private sealed class PassInlinendMethod
        {
            private readonly Action _notInlined;
            private readonly Action _inlined;

            public PassInlinendMethod(Action notInlined Action inlined)
            {
                _notInlined = notInlined ?? throw new ArgumentNullException(nameof(notInlined));
                _inlined = inlined ?? throw new ArgumentNullException(nameof(inlined));
            }

            public void Main()
            {
                _notInlined();
                _inlined();
                IfYouSeeThisItIsNotInlined();
            }
        }
    }
}
```</Description>
    <Title_Description>AggressiveInlining flaw? I can understand why a method with MethodImplOptions.AggressiveInlining attribute passed as Action cannot be in-lined when called. However I don't see any reason why such method couldn't be in-lined in case it is passed to a constructor and stored in a readonly field. See the following code fragment.
I believe the call to `_inline()` inside `PassInlinendMethod.Main()` should be considered for in-lining and in this particular case in-lined.

```csharp
using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;

namespace TestInline
{
    class Program
    {
        static void Main()
        {
            Console.WriteLine("Direct call");
            NotInlinedMethod();
            IfYouSeeThisItIsNotInlined();

            Console.WriteLine("\nPassed as parameter");
            new PassInlinendMethod(NotInlinedMethod IfYouSeeThisItIsNotInlined).Main();
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        private static void NotInlinedMethod() =&gt; Console.WriteLine(new StackTrace().GetFrame(0).GetMethod().Name);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static void IfYouSeeThisItIsNotInlined() =&gt; Console.WriteLine(new StackTrace().GetFrame(0).GetMethod().Name);

        private sealed class PassInlinendMethod
        {
            private readonly Action _notInlined;
            private readonly Action _inlined;

            public PassInlinendMethod(Action notInlined Action inlined)
            {
                _notInlined = notInlined ?? throw new ArgumentNullException(nameof(notInlined));
                _inlined = inlined ?? throw new ArgumentNullException(nameof(inlined));
            }

            public void Main()
            {
                _notInlined();
                _inlined();
                IfYouSeeThisItIsNotInlined();
            }
        }
    }
}
```</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>4/08/2018 8:32:48 AM +00:00</CreatedAt>
    <ClosedAt>4/08/2018 1:19:08 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19288</IssueLabelID>
    <Title>Incorrect up-sizing for non-power-of-2 structs that are not LclVars</Title>
    <Description>When loading a struct from an arbitrary location it is not safe to load any more bytes than the specified size of the struct. For instance in the case where you're loading a 3-byte struct that's in the last three bytes of a page the next byte following the struct may be on a page that is unmapped or not readable.

A JIT dump showed this transformation during the morph process (note the `OBJ(3)` turns into an `IND int`):
```
fgMorphTree BB02 stmt 23 (before)
               [000124] --CXG-------              *  CALL      void   Test.Foo
               [000121] ------------ this in x0   +--*  LCL_VAR   ref    V00 this         
               [000123] ---XG------- arg1         \--*  OBJ(3)    struct
               [000122] ------------                 \--*  LCL_VAR   long   V05 loc4         
argSlots=2 preallocatedArgCount=0 nextSlotNum=0 outgoingArgSpaceSize=0

Sorting the arguments:
Deferred argument ('x1'):
               [000123] ---XG+------              *  IND       int   
               [000122] -----+------              \--*  LCL_VAR   long   V05 loc4         
Replaced with placeholder node:
               [000186] ----------L-              *  ARGPLACE  int   
Deferred argument ('x0'):
               [000121] -----+------              *  LCL_VAR   ref    V00 this         
Replaced with placeholder node:
               [000188] ----------L-              *  ARGPLACE  ref   
```

Debugging `fgMorphArgs` shows that we’re taking this codepath which is changing the size from 3 to 4:

```c++
#if defined(_TARGET_ARM64_) || defined(UNIX_AMD64_ABI)
                    // For ARM64 or AMD64/UX we can pass non-power-of-2 structs in a register.
                    if ((howToPassStruct == SPK_PrimitiveType) &amp;&amp; // Passed in a single register
                        !isPow2(originalSize))                    // size is 356 or 7 bytes
                    {
                        originalSize = genTypeSize(structBaseType);
                    }
#endif //  _TARGET_ARM64_ || UNIX_AMD64_ABI
```

This branch was modified a couple of months ago in https://github.com/dotnet/coreclr/pull/18358 to remove an additional check in there that was also checking if the source was a LclVar before adjusting the size.

@CarolEidt Can you please take a look and determine whether we need to reintroduce that check or make a better fix?</Description>
    <Title_Description>Incorrect up-sizing for non-power-of-2 structs that are not LclVars When loading a struct from an arbitrary location it is not safe to load any more bytes than the specified size of the struct. For instance in the case where you're loading a 3-byte struct that's in the last three bytes of a page the next byte following the struct may be on a page that is unmapped or not readable.

A JIT dump showed this transformation during the morph process (note the `OBJ(3)` turns into an `IND int`):
```
fgMorphTree BB02 stmt 23 (before)
               [000124] --CXG-------              *  CALL      void   Test.Foo
               [000121] ------------ this in x0   +--*  LCL_VAR   ref    V00 this         
               [000123] ---XG------- arg1         \--*  OBJ(3)    struct
               [000122] ------------                 \--*  LCL_VAR   long   V05 loc4         
argSlots=2 preallocatedArgCount=0 nextSlotNum=0 outgoingArgSpaceSize=0

Sorting the arguments:
Deferred argument ('x1'):
               [000123] ---XG+------              *  IND       int   
               [000122] -----+------              \--*  LCL_VAR   long   V05 loc4         
Replaced with placeholder node:
               [000186] ----------L-              *  ARGPLACE  int   
Deferred argument ('x0'):
               [000121] -----+------              *  LCL_VAR   ref    V00 this         
Replaced with placeholder node:
               [000188] ----------L-              *  ARGPLACE  ref   
```

Debugging `fgMorphArgs` shows that we’re taking this codepath which is changing the size from 3 to 4:

```c++
#if defined(_TARGET_ARM64_) || defined(UNIX_AMD64_ABI)
                    // For ARM64 or AMD64/UX we can pass non-power-of-2 structs in a register.
                    if ((howToPassStruct == SPK_PrimitiveType) &amp;&amp; // Passed in a single register
                        !isPow2(originalSize))                    // size is 356 or 7 bytes
                    {
                        originalSize = genTypeSize(structBaseType);
                    }
#endif //  _TARGET_ARM64_ || UNIX_AMD64_ABI
```

This branch was modified a couple of months ago in https://github.com/dotnet/coreclr/pull/18358 to remove an additional check in there that was also checking if the source was a LclVar before adjusting the size.

@CarolEidt Can you please take a look and determine whether we need to reintroduce that check or make a better fix?</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19285</IssueLabelID>
    <Title>r2rdump test failure: FileNotFoundException HelloWorld.xml</Title>
    <Description>Looks like the x64 release build has been failing with this problem for a while.

https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64/job/release_windows_nt/

```
      readytorun_r2rdump._R2RDumpTest_R2RDumpTest_._R2RDumpTest_R2RDumpTest_cmd [FAIL]
15:43:51         
15:43:51   Unhandled Exception: System.IO.FileNotFoundException: Could not find file 'D:\j\workspace\release_windo---dfb17e42\bin\tests\Windows_NT.x64.Release\readytorun\r2rdump\R2RDumpTest\HelloWorld.xml'.
15:43:51            at System.IO.FileStream.ValidateFileHandle(SafeFileHandle fileHandle)
15:43:51            at System.IO.FileStream.CreateFileOpenHandle(FileMode mode FileShare share FileOptions options)
15:43:51            at System.IO.FileStream..ctor(String path FileMode mode FileAccess access FileShare share Int32 bufferSize FileOptions options)
15:43:51            at System.Xml.XmlDownloadManager.GetStream(Uri uri ICredentials credentials IWebProxy proxy RequestCachePolicy cachePolicy) in E:\A\_work\5\s\corefx\src\System.Private.Xml\src\System\Xml\XmlDownloadManager.cs:line 27
15:43:51            at System.Xml.XmlUrlResolver.GetEntity(Uri absoluteUri String role Type ofObjectToReturn) in E:\A\_work\5\s\corefx\src\System.Private.Xml\src\System\Xml\XmlUrlResolver.cs:line 66
15:43:51            at System.Xml.XmlTextReaderImpl.OpenUrl() in E:\A\_work\5\s\corefx\src\System.Private.Xml\src\System\Xml\Core\XmlTextReaderImpl.cs:line 3087
15:43:51            at System.Xml.XmlTextReaderImpl.Read() in E:\A\_work\5\s\corefx\src\System.Private.Xml\src\System\Xml\Core\XmlTextReaderImpl.cs:line 1206
15:43:51            at System.Xml.XmlLoader.Load(XmlDocument doc XmlReader reader Boolean preserveWhitespace) in E:\A\_work\5\s\corefx\src\System.Private.Xml\src\System\Xml\Dom\XmlLoader.cs:line 50
15:43:51            at System.Xml.XmlDocument.Load(XmlReader reader) in E:\A\_work\5\s\corefx\src\System.Private.Xml\src\System\Xml\Dom\XmlDocument.cs:line 1336
15:43:51            at System.Xml.XmlDocument.Load(String filename) in E:\A\_work\5\s\corefx\src\System.Private.Xml\src\System\Xml\Dom\XmlDocument.cs:line 1288
15:43:51            at R2RDumpTest.TestHelpers.RunTest(String name) in D:\j\workspace\release_windo---dfb17e42\tests\src\readytorun\r2rdump\TestHelpers.cs:line 20
15:43:51            at R2RDumpTest.BasicTests.Main(String[] args) in D:\j\workspace\release_windo---dfb17e42\tests\src\readytorun\r2rdump\BasicTests.cs:line 16
15:43:51   
15:43:51   
15:43:51   Return code:      1
15:43:51   Raw output file:      D:\j\workspace\release_windo---dfb17e42\bin\tests\Windows_NT.x64.Release\Reports\readytorun.r2rdump\R2RDumpTest\R2RDumpTest.output.txt
15:43:51   Raw output:
15:43:51   BEGIN EXECUTION
15:43:51         The system cannot find the path specified.
15:43:51         Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0
15:43:51         Copyright (c) Microsoft Corporation.  All rights reserved.
15:43:51         
15:43:51         Native image HelloWorld.ni.dll generated successfully.
15:43:51         Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0
15:43:51         Copyright (c) Microsoft Corporation.  All rights reserved.
15:43:51         
15:43:51         Native image GcInfoTransitions.ni.dll generated successfully.
15:43:51         Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0
15:43:51         Copyright (c) Microsoft Corporation.  All rights reserved.
15:43:51         
15:43:51         Native image GenericFunctions.ni.dll generated successfully.
15:43:51         Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0
15:43:51         Copyright (c) Microsoft Corporation.  All rights reserved.
15:43:51         
15:43:51         Native image MultipleRuntimeFunctions.ni.dll generated successfully.
15:43:51          "D:\j\workspace\release_windo---dfb17e42\tests\..\bin\tests\Windows_NT.x64.Release\Tests\Core_Root\corerun.exe" R2RDumpTest.exe 
15:43:51         Starting the test
15:43:51         Expected: 100
15:43:51         Actual: -532462766
15:43:51         END EXECUTION - FAILED
15:43:51         FAILED
15:43:51         Test Harness Exitcode is : 1
15:43:51         
15:43:51   To run the test:
15:43:51   &gt; set CORE_ROOT=D:\j\workspace\release_windo---dfb17e42\bin\tests\Windows_NT.x64.Release\Tests\Core_Root
15:43:51   &gt; D:\j\workspace\release_windo---dfb17e42\bin\tests\Windows_NT.x64.Release\readytorun\r2rdump\R2RDumpTest\R2RDumpTest.cmd
15:43:51   
15:43:51         Expected: True
15:43:51         Actual:   False
```

@acmyu @nattress </Description>
    <Title_Description>r2rdump test failure: FileNotFoundException HelloWorld.xml Looks like the x64 release build has been failing with this problem for a while.

https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64/job/release_windows_nt/

```
      readytorun_r2rdump._R2RDumpTest_R2RDumpTest_._R2RDumpTest_R2RDumpTest_cmd [FAIL]
15:43:51         
15:43:51   Unhandled Exception: System.IO.FileNotFoundException: Could not find file 'D:\j\workspace\release_windo---dfb17e42\bin\tests\Windows_NT.x64.Release\readytorun\r2rdump\R2RDumpTest\HelloWorld.xml'.
15:43:51            at System.IO.FileStream.ValidateFileHandle(SafeFileHandle fileHandle)
15:43:51            at System.IO.FileStream.CreateFileOpenHandle(FileMode mode FileShare share FileOptions options)
15:43:51            at System.IO.FileStream..ctor(String path FileMode mode FileAccess access FileShare share Int32 bufferSize FileOptions options)
15:43:51            at System.Xml.XmlDownloadManager.GetStream(Uri uri ICredentials credentials IWebProxy proxy RequestCachePolicy cachePolicy) in E:\A\_work\5\s\corefx\src\System.Private.Xml\src\System\Xml\XmlDownloadManager.cs:line 27
15:43:51            at System.Xml.XmlUrlResolver.GetEntity(Uri absoluteUri String role Type ofObjectToReturn) in E:\A\_work\5\s\corefx\src\System.Private.Xml\src\System\Xml\XmlUrlResolver.cs:line 66
15:43:51            at System.Xml.XmlTextReaderImpl.OpenUrl() in E:\A\_work\5\s\corefx\src\System.Private.Xml\src\System\Xml\Core\XmlTextReaderImpl.cs:line 3087
15:43:51            at System.Xml.XmlTextReaderImpl.Read() in E:\A\_work\5\s\corefx\src\System.Private.Xml\src\System\Xml\Core\XmlTextReaderImpl.cs:line 1206
15:43:51            at System.Xml.XmlLoader.Load(XmlDocument doc XmlReader reader Boolean preserveWhitespace) in E:\A\_work\5\s\corefx\src\System.Private.Xml\src\System\Xml\Dom\XmlLoader.cs:line 50
15:43:51            at System.Xml.XmlDocument.Load(XmlReader reader) in E:\A\_work\5\s\corefx\src\System.Private.Xml\src\System\Xml\Dom\XmlDocument.cs:line 1336
15:43:51            at System.Xml.XmlDocument.Load(String filename) in E:\A\_work\5\s\corefx\src\System.Private.Xml\src\System\Xml\Dom\XmlDocument.cs:line 1288
15:43:51            at R2RDumpTest.TestHelpers.RunTest(String name) in D:\j\workspace\release_windo---dfb17e42\tests\src\readytorun\r2rdump\TestHelpers.cs:line 20
15:43:51            at R2RDumpTest.BasicTests.Main(String[] args) in D:\j\workspace\release_windo---dfb17e42\tests\src\readytorun\r2rdump\BasicTests.cs:line 16
15:43:51   
15:43:51   
15:43:51   Return code:      1
15:43:51   Raw output file:      D:\j\workspace\release_windo---dfb17e42\bin\tests\Windows_NT.x64.Release\Reports\readytorun.r2rdump\R2RDumpTest\R2RDumpTest.output.txt
15:43:51   Raw output:
15:43:51   BEGIN EXECUTION
15:43:51         The system cannot find the path specified.
15:43:51         Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0
15:43:51         Copyright (c) Microsoft Corporation.  All rights reserved.
15:43:51         
15:43:51         Native image HelloWorld.ni.dll generated successfully.
15:43:51         Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0
15:43:51         Copyright (c) Microsoft Corporation.  All rights reserved.
15:43:51         
15:43:51         Native image GcInfoTransitions.ni.dll generated successfully.
15:43:51         Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0
15:43:51         Copyright (c) Microsoft Corporation.  All rights reserved.
15:43:51         
15:43:51         Native image GenericFunctions.ni.dll generated successfully.
15:43:51         Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0
15:43:51         Copyright (c) Microsoft Corporation.  All rights reserved.
15:43:51         
15:43:51         Native image MultipleRuntimeFunctions.ni.dll generated successfully.
15:43:51          "D:\j\workspace\release_windo---dfb17e42\tests\..\bin\tests\Windows_NT.x64.Release\Tests\Core_Root\corerun.exe" R2RDumpTest.exe 
15:43:51         Starting the test
15:43:51         Expected: 100
15:43:51         Actual: -532462766
15:43:51         END EXECUTION - FAILED
15:43:51         FAILED
15:43:51         Test Harness Exitcode is : 1
15:43:51         
15:43:51   To run the test:
15:43:51   &gt; set CORE_ROOT=D:\j\workspace\release_windo---dfb17e42\bin\tests\Windows_NT.x64.Release\Tests\Core_Root
15:43:51   &gt; D:\j\workspace\release_windo---dfb17e42\bin\tests\Windows_NT.x64.Release\readytorun\r2rdump\R2RDumpTest\R2RDumpTest.cmd
15:43:51   
15:43:51         Expected: True
15:43:51         Actual:   False
```

@acmyu @nattress </Title_Description>
    <Label>
    </Label>
    <Assignee>acmyu</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19283</IssueLabelID>
    <Title>[RyuJIT] switch statement can be further optimized when using bitmasks</Title>
    <Description>RyuJIT has room for optimization in switch statements like the case below.

```cs
private static void WriteInteger(uint i)
{
    string s;
    switch (i &amp; 7)
    {
        case 0: s = "0"; break;
        case 1: s = "1"; break;
        case 2: s = "2"; break;
        case 3: s = "3"; break;
        case 4: s = "4"; break;
        case 5: s = "5"; break;
        case 6: s = "6"; break;
        case 7: s = "7"; break;
        default: s = "xxx"; break;
    }
    Console.WriteLine(s);
}
```

RyuJIT can optimize this by detecting the `&amp; (2^n - 1)` in the switch statement concluding that the resulting value must fall into the range `[ 0 2^n - 1 ]` and omitting code gen for all other cases. Below is the current codegen along with my annotations of which statements can be removed with an enlightened JIT.

```asm
00007FF9AB5D2152  sub         esp20h  
00007FF9AB5D2155  mov         esiecx  
00007FF9AB5D2157  and         esi7

; the two lines immediately following can be removed  
00007FF9AB5D215A  cmp         esi7  
00007FF9AB5D215D  ja          00007FF9AB5D21F3  

00007FF9AB5D2163  mov         eaxesi  
00007FF9AB5D2165  lea         rdx[7FF9AB5D2210h]  
00007FF9AB5D216C  mov         edxdword ptr [rdx+rax*4]  
00007FF9AB5D216F  lea         rcx[7FF9AB5D2155h]  
00007FF9AB5D2176  add         rdxrcx  
00007FF9AB5D2179  jmp         rdx  
00007FF9AB5D217B  mov         rax1DF900030C0h  ; case 0
00007FF9AB5D2185  mov         rcxqword ptr [rax]  
00007FF9AB5D2188  jmp         00007FF9AB5D2200  
00007FF9AB5D218A  mov         rcx1DF900030C8h  ; case 1
00007FF9AB5D2194  mov         rcxqword ptr [rcx]  
00007FF9AB5D2197  jmp         00007FF9AB5D2200  
00007FF9AB5D2199  mov         rcx1DF900030D0h  ; case 2
00007FF9AB5D21A3  mov         rcxqword ptr [rcx]  
00007FF9AB5D21A6  jmp         00007FF9AB5D2200  
00007FF9AB5D21A8  mov         rcx1DF900030D8h  ; case 3
00007FF9AB5D21B2  mov         rcxqword ptr [rcx]  
00007FF9AB5D21B5  jmp         00007FF9AB5D2200  
00007FF9AB5D21B7  mov         rcx1DF900030E0h  ; case 4
00007FF9AB5D21C1  mov         rcxqword ptr [rcx]  
00007FF9AB5D21C4  jmp         00007FF9AB5D2200  
00007FF9AB5D21C6  mov         rcx1DF900030E8h  ; case 5
00007FF9AB5D21D0  mov         rcxqword ptr [rcx]  
00007FF9AB5D21D3  jmp         00007FF9AB5D2200  
00007FF9AB5D21D5  mov         rcx1DF900030F0h  ; case 6
00007FF9AB5D21DF  mov         rcxqword ptr [rcx]  
00007FF9AB5D21E2  jmp         00007FF9AB5D2200  
00007FF9AB5D21E4  mov         rcx1DF900030F8h  ; case 7
00007FF9AB5D21EE  mov         rcxqword ptr [rcx]  

; the three lines immediately following can be removed
00007FF9AB5D21F1  jmp         00007FF9AB5D2200  
00007FF9AB5D21F3  mov         rcx1DF90003100h  ; case default
00007FF9AB5D21FD  mov         rcxqword ptr [rcx]  

00007FF9AB5D2200  call        00007FF9AB5D1740  
00007FF9AB5D2205  nop  
00007FF9AB5D2206  add         rsp20h  
00007FF9AB5D220A  pop         rsi  
00007FF9AB5D220B  ret
```

Additionally the registers used can be optimized by keeping the input value in `ecx/rcx` and not bouncing it through `esi` and `eax/rax`.

FWIW the reason I'm looking into this is that I'm investigating optimizing the `Marvin.GetHashCode(...)` logic and I'm seeing patterns very similar to this in the optimized code.

category:cq
theme:optimization
skill-level:intermediate
cost:large</Description>
    <Title_Description>[RyuJIT] switch statement can be further optimized when using bitmasks RyuJIT has room for optimization in switch statements like the case below.

```cs
private static void WriteInteger(uint i)
{
    string s;
    switch (i &amp; 7)
    {
        case 0: s = "0"; break;
        case 1: s = "1"; break;
        case 2: s = "2"; break;
        case 3: s = "3"; break;
        case 4: s = "4"; break;
        case 5: s = "5"; break;
        case 6: s = "6"; break;
        case 7: s = "7"; break;
        default: s = "xxx"; break;
    }
    Console.WriteLine(s);
}
```

RyuJIT can optimize this by detecting the `&amp; (2^n - 1)` in the switch statement concluding that the resulting value must fall into the range `[ 0 2^n - 1 ]` and omitting code gen for all other cases. Below is the current codegen along with my annotations of which statements can be removed with an enlightened JIT.

```asm
00007FF9AB5D2152  sub         esp20h  
00007FF9AB5D2155  mov         esiecx  
00007FF9AB5D2157  and         esi7

; the two lines immediately following can be removed  
00007FF9AB5D215A  cmp         esi7  
00007FF9AB5D215D  ja          00007FF9AB5D21F3  

00007FF9AB5D2163  mov         eaxesi  
00007FF9AB5D2165  lea         rdx[7FF9AB5D2210h]  
00007FF9AB5D216C  mov         edxdword ptr [rdx+rax*4]  
00007FF9AB5D216F  lea         rcx[7FF9AB5D2155h]  
00007FF9AB5D2176  add         rdxrcx  
00007FF9AB5D2179  jmp         rdx  
00007FF9AB5D217B  mov         rax1DF900030C0h  ; case 0
00007FF9AB5D2185  mov         rcxqword ptr [rax]  
00007FF9AB5D2188  jmp         00007FF9AB5D2200  
00007FF9AB5D218A  mov         rcx1DF900030C8h  ; case 1
00007FF9AB5D2194  mov         rcxqword ptr [rcx]  
00007FF9AB5D2197  jmp         00007FF9AB5D2200  
00007FF9AB5D2199  mov         rcx1DF900030D0h  ; case 2
00007FF9AB5D21A3  mov         rcxqword ptr [rcx]  
00007FF9AB5D21A6  jmp         00007FF9AB5D2200  
00007FF9AB5D21A8  mov         rcx1DF900030D8h  ; case 3
00007FF9AB5D21B2  mov         rcxqword ptr [rcx]  
00007FF9AB5D21B5  jmp         00007FF9AB5D2200  
00007FF9AB5D21B7  mov         rcx1DF900030E0h  ; case 4
00007FF9AB5D21C1  mov         rcxqword ptr [rcx]  
00007FF9AB5D21C4  jmp         00007FF9AB5D2200  
00007FF9AB5D21C6  mov         rcx1DF900030E8h  ; case 5
00007FF9AB5D21D0  mov         rcxqword ptr [rcx]  
00007FF9AB5D21D3  jmp         00007FF9AB5D2200  
00007FF9AB5D21D5  mov         rcx1DF900030F0h  ; case 6
00007FF9AB5D21DF  mov         rcxqword ptr [rcx]  
00007FF9AB5D21E2  jmp         00007FF9AB5D2200  
00007FF9AB5D21E4  mov         rcx1DF900030F8h  ; case 7
00007FF9AB5D21EE  mov         rcxqword ptr [rcx]  

; the three lines immediately following can be removed
00007FF9AB5D21F1  jmp         00007FF9AB5D2200  
00007FF9AB5D21F3  mov         rcx1DF90003100h  ; case default
00007FF9AB5D21FD  mov         rcxqword ptr [rcx]  

00007FF9AB5D2200  call        00007FF9AB5D1740  
00007FF9AB5D2205  nop  
00007FF9AB5D2206  add         rsp20h  
00007FF9AB5D220A  pop         rsi  
00007FF9AB5D220B  ret
```

Additionally the registers used can be optimized by keeping the input value in `ecx/rcx` and not bouncing it through `esi` and `eax/rax`.

FWIW the reason I'm looking into this is that I'm investigating optimizing the `Marvin.GetHashCode(...)` logic and I'm seeing patterns very similar to this in the optimized code.

category:cq
theme:optimization
skill-level:intermediate
cost:large</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>3/08/2018 11:16:49 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19282</IssueLabelID>
    <Title>WIP Update base services tests to SDK style projects</Title>
    <Description>Update all the tests in baseservices to be SDK style projects</Description>
    <Title_Description>WIP Update base services tests to SDK style projects Update all the tests in baseservices to be SDK style projects</Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>chsienki</Assignee>
    <CreatedAt>3/08/2018 10:56:13 PM +00:00</CreatedAt>
    <ClosedAt>24/05/2019 2:38:01 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19279</IssueLabelID>
    <Title>[Feature] Have optimizer aggressively fold branches</Title>
    <Description>I'd like the JIT to detect when one branch leads to another branch and fold them into a single branch.

I'm sure this optimization has a specific name in compiler theory but I don't know it. If you'll excuse a dumb example:

```
int InitialBranching(string x)
{
    if (x == "foo") return 0;
    if (x == "bar") return 0;
    if (x == "baz") return 1;
    return -1;
}

string SubsequentBranching(string x)
{
    int y = InitialBranching(x);

    if (y == 0) return x + "0";
    if (y == 1) return x + "1";
    return "other";
}
```

Here a sufficiently advanced compiler should be able to transform this into something like:

```
string Folded(string x)
{
    if (x == "foo") goto zero;
    if (x == "bar") goto zero;
    if (x == "baz") goto one;
    goto other;

    zero:
    return x + "0";

    one:
    return x + "1";

    other:
    return "other";
}
```

**Why?**

Obviously the dumb example is not what I'm actually doing. For performance purposes I'm updating a text parser from depending on `char` to be encoding-agnostic. In some places it needs to allow injecting inlineable sub-parsers that handles encoding-specific things:

```
// returns length of newline if matched 0 if not matched -1 if more data is needed.
int IsNewLine&lt;T&gt;(ReadOnlySpan&lt;T&gt; data);
```

This sits right in a hotspot in my code: optimizing this bit makes a huge difference. I've found the extra tests needed to check the return value are causing the code to perform at about 1/4th the speed when compared to a non-agnostic version with `IsNewLine` manually inlined. Having the compiler optimize away these tests would make a huge difference to me.

category:cq
theme:optimization
skill-level:expert
cost:large</Description>
    <Title_Description>[Feature] Have optimizer aggressively fold branches I'd like the JIT to detect when one branch leads to another branch and fold them into a single branch.

I'm sure this optimization has a specific name in compiler theory but I don't know it. If you'll excuse a dumb example:

```
int InitialBranching(string x)
{
    if (x == "foo") return 0;
    if (x == "bar") return 0;
    if (x == "baz") return 1;
    return -1;
}

string SubsequentBranching(string x)
{
    int y = InitialBranching(x);

    if (y == 0) return x + "0";
    if (y == 1) return x + "1";
    return "other";
}
```

Here a sufficiently advanced compiler should be able to transform this into something like:

```
string Folded(string x)
{
    if (x == "foo") goto zero;
    if (x == "bar") goto zero;
    if (x == "baz") goto one;
    goto other;

    zero:
    return x + "0";

    one:
    return x + "1";

    other:
    return "other";
}
```

**Why?**

Obviously the dumb example is not what I'm actually doing. For performance purposes I'm updating a text parser from depending on `char` to be encoding-agnostic. In some places it needs to allow injecting inlineable sub-parsers that handles encoding-specific things:

```
// returns length of newline if matched 0 if not matched -1 if more data is needed.
int IsNewLine&lt;T&gt;(ReadOnlySpan&lt;T&gt; data);
```

This sits right in a hotspot in my code: optimizing this bit makes a huge difference. I've found the extra tests needed to check the return value are causing the code to perform at about 1/4th the speed when compared to a non-agnostic version with `IsNewLine` manually inlined. Having the compiler optimize away these tests would make a huge difference to me.

category:cq
theme:optimization
skill-level:expert
cost:large</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>3/08/2018 9:08:04 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19277</IssueLabelID>
    <Title>Test failure: readytorun_r2rdump._R2RDumpTest_R2RDumpTest_/_R2RDumpTest_R2RDumpTest_cmd</Title>
    <Description>Opened on behalf of @RussKeldorph

The test `readytorun_r2rdump._R2RDumpTest_R2RDumpTest_/_R2RDumpTest_R2RDumpTest_cmd` has failed.

The system cannot find the path specified.\r
    The system cannot find the path specified.\r
    The system cannot find the path specified.\r
    The system cannot find the path specified.\r
    
    
    Return code:      1
    Raw output file:      C:\\dotnetbuild\\work\\83984791-e58e-4726-a52b-550c3a40b9d5\\Work\\9abd53db-5b26-435c-b386-5cb7c26699a8\\Unzip\\Reports\\readytorun.r2rdump\\R2RDumpTest\\R2RDumpTest.output.txt
    Raw output:
    BEGIN EXECUTION\r
    The system cannot find the path specified.\r
    Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0\r
    Copyright (c) Microsoft Corporation.  All rights reserved.\r
    \r
    Native image HelloWorld.ni.dll generated successfully.\r
    Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0\r
    Copyright (c) Microsoft Corporation.  All rights reserved.\r
    \r
    Native image GcInfoTransitions.ni.dll generated successfully.\r
    Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0\r
    Copyright (c) Microsoft Corporation.  All rights reserved.\r
    \r
    Native image GenericFunctions.ni.dll generated successfully.\r
    Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0\r
    Copyright (c) Microsoft Corporation.  All rights reserved.\r
    \r
    Native image MultipleRuntimeFunctions.ni.dll generated successfully.\r
     \"C:\\dotnetbuild\\work\\83984791-e58e-4726-a52b-550c3a40b9d5\\Payload\\corerun.exe\" R2RDumpTest.exe \r
    Starting the test\r
    Expected: 100\r
    Actual: -532462766\r
    END EXECUTION - FAILED\r
    FAILED\r
    Test Harness Exitcode is : 1\r
    
    To run the test:
    &gt; set CORE_ROOT=C:\\dotnetbuild\\work\\83984791-e58e-4726-a52b-550c3a40b9d5\\Payload
    &gt; C:\\dotnetbuild\\work\\83984791-e58e-4726-a52b-550c3a40b9d5\\Work\\9abd53db-5b26-435c-b386-5cb7c26699a8\\Unzip\\R2RDumpTest\\R2RDumpTest.cmd
    \r
    Expected: True\r
    Actual:   False

        Stack Trace:

           at readytorun_r2rdump._R2RDumpTest_R2RDumpTest_._R2RDumpTest_R2RDumpTest_cmd() in E:\A\_work\105\s\bin\tests\Windows_NT.arm.Release\TestWrappers\readytorun.r2rdump\readytorun.r2rdump.XUnitWrapper.cs:line 109
Build : 3.0 - 20180803.04 (Core Tests)
Failing configurations:
- windows.10.arm64-arm
  - 
- osx.1013.amd64-x64
  - 
- osx.1012.amd64-x64
  - 
- sles.12.amd64-x64
  - 
- opensuse.423.amd64-x64
  - 
- ubuntu.1804.amd64-x64
  - 
- ubuntu.1710.amd64-x64
  - 
- ubuntu.1604.amd64-x64
  - 
- ubuntu.1404.amd64-x64
  - 
- redhat.73.amd64-x64
  - 
- fedora.27.amd64-x64
  - 
- fedora.26.amd64-x64
  - 
- debian.82.amd64-x64
  - 
- redhat.69.amd64-x64
  - 
- Alpine.36.Amd64-x64
  - 
- Windows.81.Amd64-x64
  - 
- Windows.7.Amd64-x64
  - 
- Windows.10.Amd64.Core-x64
  - 
- Windows.10.Nano.Amd64-x64
  - 
- Windows.10.Amd64-x64
  - 
</Description>
    <Title_Description>Test failure: readytorun_r2rdump._R2RDumpTest_R2RDumpTest_/_R2RDumpTest_R2RDumpTest_cmd Opened on behalf of @RussKeldorph

The test `readytorun_r2rdump._R2RDumpTest_R2RDumpTest_/_R2RDumpTest_R2RDumpTest_cmd` has failed.

The system cannot find the path specified.\r
    The system cannot find the path specified.\r
    The system cannot find the path specified.\r
    The system cannot find the path specified.\r
    
    
    Return code:      1
    Raw output file:      C:\\dotnetbuild\\work\\83984791-e58e-4726-a52b-550c3a40b9d5\\Work\\9abd53db-5b26-435c-b386-5cb7c26699a8\\Unzip\\Reports\\readytorun.r2rdump\\R2RDumpTest\\R2RDumpTest.output.txt
    Raw output:
    BEGIN EXECUTION\r
    The system cannot find the path specified.\r
    Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0\r
    Copyright (c) Microsoft Corporation.  All rights reserved.\r
    \r
    Native image HelloWorld.ni.dll generated successfully.\r
    Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0\r
    Copyright (c) Microsoft Corporation.  All rights reserved.\r
    \r
    Native image GcInfoTransitions.ni.dll generated successfully.\r
    Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0\r
    Copyright (c) Microsoft Corporation.  All rights reserved.\r
    \r
    Native image GenericFunctions.ni.dll generated successfully.\r
    Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0\r
    Copyright (c) Microsoft Corporation.  All rights reserved.\r
    \r
    Native image MultipleRuntimeFunctions.ni.dll generated successfully.\r
     \"C:\\dotnetbuild\\work\\83984791-e58e-4726-a52b-550c3a40b9d5\\Payload\\corerun.exe\" R2RDumpTest.exe \r
    Starting the test\r
    Expected: 100\r
    Actual: -532462766\r
    END EXECUTION - FAILED\r
    FAILED\r
    Test Harness Exitcode is : 1\r
    
    To run the test:
    &gt; set CORE_ROOT=C:\\dotnetbuild\\work\\83984791-e58e-4726-a52b-550c3a40b9d5\\Payload
    &gt; C:\\dotnetbuild\\work\\83984791-e58e-4726-a52b-550c3a40b9d5\\Work\\9abd53db-5b26-435c-b386-5cb7c26699a8\\Unzip\\R2RDumpTest\\R2RDumpTest.cmd
    \r
    Expected: True\r
    Actual:   False

        Stack Trace:

           at readytorun_r2rdump._R2RDumpTest_R2RDumpTest_._R2RDumpTest_R2RDumpTest_cmd() in E:\A\_work\105\s\bin\tests\Windows_NT.arm.Release\TestWrappers\readytorun.r2rdump\readytorun.r2rdump.XUnitWrapper.cs:line 109
Build : 3.0 - 20180803.04 (Core Tests)
Failing configurations:
- windows.10.arm64-arm
  - 
- osx.1013.amd64-x64
  - 
- osx.1012.amd64-x64
  - 
- sles.12.amd64-x64
  - 
- opensuse.423.amd64-x64
  - 
- ubuntu.1804.amd64-x64
  - 
- ubuntu.1710.amd64-x64
  - 
- ubuntu.1604.amd64-x64
  - 
- ubuntu.1404.amd64-x64
  - 
- redhat.73.amd64-x64
  - 
- fedora.27.amd64-x64
  - 
- fedora.26.amd64-x64
  - 
- debian.82.amd64-x64
  - 
- redhat.69.amd64-x64
  - 
- Alpine.36.Amd64-x64
  - 
- Windows.81.Amd64-x64
  - 
- Windows.7.Amd64-x64
  - 
- Windows.10.Amd64.Core-x64
  - 
- Windows.10.Nano.Amd64-x64
  - 
- Windows.10.Amd64-x64
  - 
</Title_Description>
    <Label>area-ReadyToRun</Label>
    <Assignee>acmyu</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19273</IssueLabelID>
    <Title>[Linux/ARM] SIGSEGV during GC under managed debugger</Title>
    <Description>In some cases SIGSEGV occurs during gc:
```
0xb1fe7868 in WKS::GCHeap::Promote(Object** ScanContext* unsigned int) ()
   from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.0.0/libcoreclr.so
(gdb) bt
#0  0xb1fe7868 in WKS::GCHeap::Promote(Object** ScanContext* unsigned int) ()
   from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.0.0/libcoreclr.so
#1  0xb1ef8ae8 in GcInfoDecoder::EnumerateLiveSlots(REGDISPLAY* bool unsigned int void (*)(void* Object** unsigned int) void*) ()
   from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.0.0/libcoreclr.so
#2  0xb1ddfc26 in EECodeManager::EnumGcRefs(REGDISPLAY* EECodeInfo* unsigned int void (*)(void* Object** unsigned int) void* unsigned int) ()
   from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.0.0/libcoreclr.so
#3  0xb1e7de40 in GcStackCrawlCallBack(CrawlFrame* void*) ()
   from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.0.0/libcoreclr.so
#4  0xb1e2ae7c in Thread::MakeStackwalkerCallback(CrawlFrame* StackWalkAction (*)(CrawlFrame* void*) void*) ()
   from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.0.0/libcoreclr.so
#5  0xb1e2b00e in Thread::StackWalkFramesEx(REGDISPLAY* StackWalkAction (*)(CrawlFrame* void*) void* unsigned int Frame*) ()
   from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.0.0/libcoreclr.so
#6  0xb1e2b2aa in Thread::StackWalkFrames(StackWalkAction (*)(CrawlFrame* void*) void* unsigned int Frame*) ()
   from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.0.0/libcoreclr.so
#7  0xb1e7e23c in ScanStackRoots(Thread* void (*)(Object** ScanContext* unsigned int) ScanContext*) ()
   from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.0.0/libcoreclr.so
#8  0xb1e7e10a in GCToEEInterface::GcScanRoots(void (*)(Object** ScanContext* ---Type &lt;return&gt; to continue or q &lt;return&gt; to quit---
unsigned int) int int ScanContext*) ()
   from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.0.0/libcoreclr.so
#9  0xb1fded34 in WKS::gc_heap::mark_phase(int int) ()
   from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.0.0/libcoreclr.so
#10 0xb1fdcf5a in WKS::gc_heap::gc1() ()
   from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.0.0/libcoreclr.so
#11 0xb1fe3dd2 in WKS::gc_heap::garbage_collect(int) ()
   from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.0.0/libcoreclr.so
#12 0xb1fda18c in WKS::GCHeap::GarbageCollectGeneration(unsigned int gc_reason) () from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.0.0/libcoreclr.so
#13 0xb1fdb934 in WKS::gc_heap::try_allocate_more_space(alloc_context* unsigned int int) ()
   from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.0.0/libcoreclr.so
#14 0xb1ff38fc in WKS::GCHeap::Alloc(gc_alloc_context* unsigned int unsigned int) () from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.0.0/libcoreclr.so
#15 0xb1e8011e in SlowAllocateString(unsigned int) ()
   from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.0.0/libcoreclr.so
#16 0xb1e8cd0c in FramedAllocateString(unsigned int) ()
   from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.0.0/libcoreclr.so
#17 0xae21732c in ?? ()
```
The problem occurs due to `ppObject` is NULL in `GCHeap::Promote`:
```c++
void GCHeap::Promote(Object** ppObject ScanContext* sc uint32_t flags)
{
    THREAD_NUMBER_FROM_CONTEXT;
#ifndef MULTIPLE_HEAPS
    const int thread = 0;
#endif //!MULTIPLE_HEAPS

    uint8_t* o = (uint8_t*)*ppObject;

    if (o == 0)
        return;
    ...
}
```

We get `ppObject` value in `GcInfoDecoder::ReportRegisterToGC` or `GcInfoDecoder::ReportStackSlotToGC`. There is the special check in  `GcInfoDecoder::ReportRegisterToGC` for AMD64 for this case:
```c++
void GcInfoDecoder::ReportRegisterToGC(  // AMD64
                                int             regNum
                                unsigned        gcFlags
                                PREGDISPLAY     pRD
                                unsigned        flags
                                GCEnumCallback  pCallBack
                                void *          hCallBack)
{
    GCINFODECODER_CONTRACT;

    _ASSERTE(regNum &gt;= 0 &amp;&amp; regNum &lt;= 16);
    _ASSERTE(regNum != 4);  // rsp

    LOG((LF_GCROOTS LL_INFO1000 "Reporting " FMT_REG regNum ));

    OBJECTREF* pObjRef = GetRegisterSlot( regNum pRD );
#if defined(FEATURE_PAL) &amp;&amp; !defined(SOS_TARGET_AMD64) 
    // On PAL we don't always have the context pointers available due to
    // a limitation of an unwinding library. In such case the context
    // pointers for some nonvolatile registers are NULL.
    // In such case we let the pObjRef point to the captured register
    // value in the context and pin the object itself.
    if (pObjRef == NULL)
    {
        // Report a pinned object to GC only in the promotion phase when the
        // GC is scanning roots. 
        GCCONTEXT* pGCCtx = (GCCONTEXT*)(hCallBack);
        if (!pGCCtx-&gt;sc-&gt;promotion)
        {
            return;
        }
        
        pObjRef = GetCapturedRegister(regNum pRD);

        gcFlags |= GC_CALL_PINNED;
    }
#endif // FEATURE_PAL &amp;&amp; !SOS_TARGET_AMD64
    ...
}
```

Could it be relevant for ARM too or `pObjRef` is always not NULL in this case for ARM?

Thank you!</Description>
    <Title_Description>[Linux/ARM] SIGSEGV during GC under managed debugger In some cases SIGSEGV occurs during gc:
```
0xb1fe7868 in WKS::GCHeap::Promote(Object** ScanContext* unsigned int) ()
   from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.0.0/libcoreclr.so
(gdb) bt
#0  0xb1fe7868 in WKS::GCHeap::Promote(Object** ScanContext* unsigned int) ()
   from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.0.0/libcoreclr.so
#1  0xb1ef8ae8 in GcInfoDecoder::EnumerateLiveSlots(REGDISPLAY* bool unsigned int void (*)(void* Object** unsigned int) void*) ()
   from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.0.0/libcoreclr.so
#2  0xb1ddfc26 in EECodeManager::EnumGcRefs(REGDISPLAY* EECodeInfo* unsigned int void (*)(void* Object** unsigned int) void* unsigned int) ()
   from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.0.0/libcoreclr.so
#3  0xb1e7de40 in GcStackCrawlCallBack(CrawlFrame* void*) ()
   from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.0.0/libcoreclr.so
#4  0xb1e2ae7c in Thread::MakeStackwalkerCallback(CrawlFrame* StackWalkAction (*)(CrawlFrame* void*) void*) ()
   from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.0.0/libcoreclr.so
#5  0xb1e2b00e in Thread::StackWalkFramesEx(REGDISPLAY* StackWalkAction (*)(CrawlFrame* void*) void* unsigned int Frame*) ()
   from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.0.0/libcoreclr.so
#6  0xb1e2b2aa in Thread::StackWalkFrames(StackWalkAction (*)(CrawlFrame* void*) void* unsigned int Frame*) ()
   from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.0.0/libcoreclr.so
#7  0xb1e7e23c in ScanStackRoots(Thread* void (*)(Object** ScanContext* unsigned int) ScanContext*) ()
   from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.0.0/libcoreclr.so
#8  0xb1e7e10a in GCToEEInterface::GcScanRoots(void (*)(Object** ScanContext* ---Type &lt;return&gt; to continue or q &lt;return&gt; to quit---
unsigned int) int int ScanContext*) ()
   from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.0.0/libcoreclr.so
#9  0xb1fded34 in WKS::gc_heap::mark_phase(int int) ()
   from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.0.0/libcoreclr.so
#10 0xb1fdcf5a in WKS::gc_heap::gc1() ()
   from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.0.0/libcoreclr.so
#11 0xb1fe3dd2 in WKS::gc_heap::garbage_collect(int) ()
   from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.0.0/libcoreclr.so
#12 0xb1fda18c in WKS::GCHeap::GarbageCollectGeneration(unsigned int gc_reason) () from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.0.0/libcoreclr.so
#13 0xb1fdb934 in WKS::gc_heap::try_allocate_more_space(alloc_context* unsigned int int) ()
   from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.0.0/libcoreclr.so
#14 0xb1ff38fc in WKS::GCHeap::Alloc(gc_alloc_context* unsigned int unsigned int) () from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.0.0/libcoreclr.so
#15 0xb1e8011e in SlowAllocateString(unsigned int) ()
   from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.0.0/libcoreclr.so
#16 0xb1e8cd0c in FramedAllocateString(unsigned int) ()
   from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.0.0/libcoreclr.so
#17 0xae21732c in ?? ()
```
The problem occurs due to `ppObject` is NULL in `GCHeap::Promote`:
```c++
void GCHeap::Promote(Object** ppObject ScanContext* sc uint32_t flags)
{
    THREAD_NUMBER_FROM_CONTEXT;
#ifndef MULTIPLE_HEAPS
    const int thread = 0;
#endif //!MULTIPLE_HEAPS

    uint8_t* o = (uint8_t*)*ppObject;

    if (o == 0)
        return;
    ...
}
```

We get `ppObject` value in `GcInfoDecoder::ReportRegisterToGC` or `GcInfoDecoder::ReportStackSlotToGC`. There is the special check in  `GcInfoDecoder::ReportRegisterToGC` for AMD64 for this case:
```c++
void GcInfoDecoder::ReportRegisterToGC(  // AMD64
                                int             regNum
                                unsigned        gcFlags
                                PREGDISPLAY     pRD
                                unsigned        flags
                                GCEnumCallback  pCallBack
                                void *          hCallBack)
{
    GCINFODECODER_CONTRACT;

    _ASSERTE(regNum &gt;= 0 &amp;&amp; regNum &lt;= 16);
    _ASSERTE(regNum != 4);  // rsp

    LOG((LF_GCROOTS LL_INFO1000 "Reporting " FMT_REG regNum ));

    OBJECTREF* pObjRef = GetRegisterSlot( regNum pRD );
#if defined(FEATURE_PAL) &amp;&amp; !defined(SOS_TARGET_AMD64) 
    // On PAL we don't always have the context pointers available due to
    // a limitation of an unwinding library. In such case the context
    // pointers for some nonvolatile registers are NULL.
    // In such case we let the pObjRef point to the captured register
    // value in the context and pin the object itself.
    if (pObjRef == NULL)
    {
        // Report a pinned object to GC only in the promotion phase when the
        // GC is scanning roots. 
        GCCONTEXT* pGCCtx = (GCCONTEXT*)(hCallBack);
        if (!pGCCtx-&gt;sc-&gt;promotion)
        {
            return;
        }
        
        pObjRef = GetCapturedRegister(regNum pRD);

        gcFlags |= GC_CALL_PINNED;
    }
#endif // FEATURE_PAL &amp;&amp; !SOS_TARGET_AMD64
    ...
}
```

Could it be relevant for ARM too or `pObjRef` is always not NULL in this case for ARM?

Thank you!</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>alpencolt</Assignee>
    <CreatedAt>3/08/2018 3:58:38 PM +00:00</CreatedAt>
    <ClosedAt>10/01/2019 5:34:44 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19272</IssueLabelID>
    <Title>RyuJIT: Morph forgets about side effects when optimizing casted shift</Title>
    <Description>The following example does not print anything in release:
```csharp
// Debug: Prints 1 line(s)
// Release: Prints 0 line(s)
struct S0
{
    public ulong F0;
    public sbyte F6;
    public S0(sbyte f6): this() { F6 = f6; }
}

public class Program
{
    static S0 s_1 = new S0(127);
    public static void Main()
    {
        int vr0 = (int)((ulong)M1() &lt;&lt; 33) / s_1.F6;
    }

    static byte M1()
    {
        System.Console.WriteLine(s_1.F0);
        return 0;
    }
}
```

It looks like morph optimizes the left-hand side of the division to 0 but gets completely rid of the call in the process:
```
fgMorphTree BB01 stmt 1 (before)
               [000021] ------------              /--*  NOP       void  
               [000022] --CXG-------              *  COMMA     void  
               [000019] --CXG-------              |  /--*  FIELD     byte   F6
               [000010] ------------              |  |  |     /--*  CNS_INT   long   8 Fseq[#FirstElem]
               [000011] ------------              |  |  |  /--*  ADD       byref 
               [000009] ------------              |  |  |  |  \--*  IND       ref   
               [000008] ------------              |  |  |  |     \--*  CNS_INT(h) long   0x198583d2970 static Fseq[s_1]
               [000018] --CXG-------              |  |  \--*  COMMA     byref 
               [000017] H-CXG-------              |  |     \--*  CALL help long   HELPER.CORINFO_HELP_GETSHARED_NONGCSTATIC_BASE
               [000013] ------------ arg0         |  |        +--*  CNS_INT   long   0x7ffa6bac45c8
               [000014] ------------ arg1         |  |        \--*  CNS_INT   int    2
               [000020] --CXG-------              \--*  DIV       int   
               [000007] --C---------                 \--*  CAST      int &lt;- long
               [000005] ------------                    |  /--*  CNS_INT   int    33
               [000006] --C---------                    \--*  LSH       long  
               [000004] --C------U--                       \--*  CAST      long &lt;- ulong &lt;- uint
               [000001] --C-G-------                          \--*  CALL      int    Program.M1
Morphing args for 17.CALL:
argSlots=2 preallocatedArgCount=4 nextSlotNum=4 outgoingArgSpaceSize=32

Sorting the arguments:
Deferred argument ('rcx'):
               [000013] -----+------              *  CNS_INT   long   0x7ffa6bac45c8
Replaced with placeholder node:
               [000030] ----------L-              *  ARGPLACE  long  
Deferred argument ('rdx'):
               [000014] -----+------              *  CNS_INT   int    2
Replaced with placeholder node:
               [000032] ----------L-              *  ARGPLACE  int   

Shuffled argument table:    rcx rdx 
fgArgTabEntry[arg 0 13.CNS_INT 1 reg: rcx align=1 lateArgInx=0 processed]
fgArgTabEntry[arg 1 14.CNS_INT 1 reg: rdx align=1 lateArgInx=1 processed]

fgMorphTree BB01 stmt 1 (after)
               [000021] -----+------              /--*  NOP       void  
               [000022] --CXG+------              *  COMMA     void  
               [000019] *-CXG+------              |  /--*  IND       byte  
               [000028] -----+------              |  |  |  /--*  CNS_INT   long   8 field offset Fseq[F6]
               [000029] --CXG+------              |  |  \--*  ADD       byref 
               [000010] -----+------              |  |     |     /--*  CNS_INT   long   8 Fseq[#FirstElem]
               [000011] -----+------              |  |     |  /--*  ADD       byref 
               [000009] x----+------              |  |     |  |  \--*  IND       ref   
               [000008] -----+------              |  |     |  |     \--*  CNS_INT(h) long   0x198583d2970 static Fseq[s_1]
               [000018] --CXG+------              |  |     \--*  COMMA     byref 
               [000017] H-CXG+------              |  |        \--*  CALL help long   HELPER.CORINFO_HELP_GETSHARED_NONGCSTATIC_BASE
               [000013] -----+------ arg0 in rcx  |  |           +--*  CNS_INT   long   0x7ffa6bac45c8
               [000014] -----+------ arg1 in rdx  |  |           \--*  CNS_INT   int    2
               [000020] --CXG+------              \--*  DIV       int   
               [000027] -----+------                 \--*  CNS_INT   int    0
```</Description>
    <Title_Description>RyuJIT: Morph forgets about side effects when optimizing casted shift The following example does not print anything in release:
```csharp
// Debug: Prints 1 line(s)
// Release: Prints 0 line(s)
struct S0
{
    public ulong F0;
    public sbyte F6;
    public S0(sbyte f6): this() { F6 = f6; }
}

public class Program
{
    static S0 s_1 = new S0(127);
    public static void Main()
    {
        int vr0 = (int)((ulong)M1() &lt;&lt; 33) / s_1.F6;
    }

    static byte M1()
    {
        System.Console.WriteLine(s_1.F0);
        return 0;
    }
}
```

It looks like morph optimizes the left-hand side of the division to 0 but gets completely rid of the call in the process:
```
fgMorphTree BB01 stmt 1 (before)
               [000021] ------------              /--*  NOP       void  
               [000022] --CXG-------              *  COMMA     void  
               [000019] --CXG-------              |  /--*  FIELD     byte   F6
               [000010] ------------              |  |  |     /--*  CNS_INT   long   8 Fseq[#FirstElem]
               [000011] ------------              |  |  |  /--*  ADD       byref 
               [000009] ------------              |  |  |  |  \--*  IND       ref   
               [000008] ------------              |  |  |  |     \--*  CNS_INT(h) long   0x198583d2970 static Fseq[s_1]
               [000018] --CXG-------              |  |  \--*  COMMA     byref 
               [000017] H-CXG-------              |  |     \--*  CALL help long   HELPER.CORINFO_HELP_GETSHARED_NONGCSTATIC_BASE
               [000013] ------------ arg0         |  |        +--*  CNS_INT   long   0x7ffa6bac45c8
               [000014] ------------ arg1         |  |        \--*  CNS_INT   int    2
               [000020] --CXG-------              \--*  DIV       int   
               [000007] --C---------                 \--*  CAST      int &lt;- long
               [000005] ------------                    |  /--*  CNS_INT   int    33
               [000006] --C---------                    \--*  LSH       long  
               [000004] --C------U--                       \--*  CAST      long &lt;- ulong &lt;- uint
               [000001] --C-G-------                          \--*  CALL      int    Program.M1
Morphing args for 17.CALL:
argSlots=2 preallocatedArgCount=4 nextSlotNum=4 outgoingArgSpaceSize=32

Sorting the arguments:
Deferred argument ('rcx'):
               [000013] -----+------              *  CNS_INT   long   0x7ffa6bac45c8
Replaced with placeholder node:
               [000030] ----------L-              *  ARGPLACE  long  
Deferred argument ('rdx'):
               [000014] -----+------              *  CNS_INT   int    2
Replaced with placeholder node:
               [000032] ----------L-              *  ARGPLACE  int   

Shuffled argument table:    rcx rdx 
fgArgTabEntry[arg 0 13.CNS_INT 1 reg: rcx align=1 lateArgInx=0 processed]
fgArgTabEntry[arg 1 14.CNS_INT 1 reg: rdx align=1 lateArgInx=1 processed]

fgMorphTree BB01 stmt 1 (after)
               [000021] -----+------              /--*  NOP       void  
               [000022] --CXG+------              *  COMMA     void  
               [000019] *-CXG+------              |  /--*  IND       byte  
               [000028] -----+------              |  |  |  /--*  CNS_INT   long   8 field offset Fseq[F6]
               [000029] --CXG+------              |  |  \--*  ADD       byref 
               [000010] -----+------              |  |     |     /--*  CNS_INT   long   8 Fseq[#FirstElem]
               [000011] -----+------              |  |     |  /--*  ADD       byref 
               [000009] x----+------              |  |     |  |  \--*  IND       ref   
               [000008] -----+------              |  |     |  |     \--*  CNS_INT(h) long   0x198583d2970 static Fseq[s_1]
               [000018] --CXG+------              |  |     \--*  COMMA     byref 
               [000017] H-CXG+------              |  |        \--*  CALL help long   HELPER.CORINFO_HELP_GETSHARED_NONGCSTATIC_BASE
               [000013] -----+------ arg0 in rcx  |  |           +--*  CNS_INT   long   0x7ffa6bac45c8
               [000014] -----+------ arg1 in rdx  |  |           \--*  CNS_INT   int    2
               [000020] --CXG+------              \--*  DIV       int   
               [000027] -----+------                 \--*  CNS_INT   int    0
```</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>sandreenko</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19271</IssueLabelID>
    <Title>HW intrinsics: Expose REP MOVSB/D in API to allow conscious use of ERMSB feature</Title>
    <Description>Please expose REP MOVSB/D in HW intrinsics API to allow use of ERMSB feature to copy memory blocks without use of SSE and later. obvious use case is - transfer of large memory areas like set of VM pages (typically N x 4Kb for Windows).

Example of numbers obtained by benchmarking and some descriptive text can be found here:
https://stackoverflow.com/a/43574756

category:proposal
theme:intrinsics
skill-level:intermediate
cost:medium</Description>
    <Title_Description>HW intrinsics: Expose REP MOVSB/D in API to allow conscious use of ERMSB feature Please expose REP MOVSB/D in HW intrinsics API to allow use of ERMSB feature to copy memory blocks without use of SSE and later. obvious use case is - transfer of large memory areas like set of VM pages (typically N x 4Kb for Windows).

Example of numbers obtained by benchmarking and some descriptive text can be found here:
https://stackoverflow.com/a/43574756

category:proposal
theme:intrinsics
skill-level:intermediate
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>3/08/2018 10:53:52 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19270</IssueLabelID>
    <Title>Add PInvoke/DllImportpath tests</Title>
    <Description>
    </Description>
    <Title_Description>Add PInvoke/DllImportpath tests </Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jkoritzinsky</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19269</IssueLabelID>
    <Title>Add PInvoke/BestFitMapping tests</Title>
    <Description>
    </Description>
    <Title_Description>Add PInvoke/BestFitMapping tests </Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jkoritzinsky</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19268</IssueLabelID>
    <Title>Test failure: tracing_runtimeeventsource._runtimeeventsource_runtimeeventsource_/_runtimeeventsource_runtimeeventsource_cmd</Title>
    <Description>Opened on behalf of @Sunny-pu

The test `tracing_runtimeeventsource._runtimeeventsource_runtimeeventsource_/_runtimeeventsource_runtimeeventsource_cmd` has failed.


    Unhandled Exception: System.Exception: Condition 'listener.EventCount &gt; 0' is not true\r
       at Tracing.Tests.Common.Assert.True(String name Boolean condition)\r
       at Tracing.Tests.RuntimeEventSourceTest.Main(String[] args)
    
    
    Return code:      1
    Raw output file:      C:\\dotnetbuild\\work\\e7ea211b-8ea4-4f83-8f9c-587faa935083\\Work\\40455e47-1819-41ce-8ba1-d1c1be28e5bf\\Unzip\\Reports\\tracing.runtimeeventsource\\runtimeeventsource\\runtimeeventsource.output.txt
    Raw output:
    BEGIN EXECUTION\r
            1 file(s) copied.\r
    \" C:\\dotnetbuild\\work\\e7ea211b-8ea4-4f83-8f9c-587faa935083\\Payload\\crossgen.exe\" /Platform_Assemblies_Paths C:\\dotnetbuild\\work\\e7ea211b-8ea4-4f83-8f9c-587faa935083\\Payload;C:\\dotnetbuild\\work\\e7ea211b-8ea4-4f83-8f9c-587faa935083\\Work\\40455e47-1819-41ce-8ba1-d1c1be28e5bf\\Unzip\\runtimeeventsource\\IL;C:\\dotnetbuild\\work\\e7ea211b-8ea4-4f83-8f9c-587faa935083\\Work\\40455e47-1819-41ce-8ba1-d1c1be28e5bf\\Unzip\\runtimeeventsource /in runtimeeventsource.org /out runtimeeventsource.exe\r
    Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0\r
    Copyright (c) Microsoft Corporation.  All rights reserved.\r
    \r
    Native image runtimeeventsource.exe generated successfully.\r
     \"C:\\dotnetbuild\\work\\e7ea211b-8ea4-4f83-8f9c-587faa935083\\Payload\\corerun.exe\" runtimeeventsource.exe \r
    [Simple] ThreadID = 2768 ID = 200 Name = IncreaseMemoryPressure\r
    TimeStamp: 8/3/2018 2:33:49 AM\r
    LocalTime: 8/3/2018 2:33:49 AM\r
    Difference: -00:00:00.0000304\r
    [Simple] ThreadID = 632 ID = 0 Name = EventSourceMessage\r
    TimeStamp: 8/3/2018 2:33:49 AM\r
    LocalTime: 8/3/2018 2:33:49 AM\r
    Difference: 00:00:00\r
    [NoEvents] ThreadID = 632 ID = 0 Name = EventSourceMessage\r
    TimeStamp: 8/3/2018 2:33:49 AM\r
    LocalTime: 8/3/2018 2:33:49 AM\r
    Difference: 00:00:00\r
    Expected: 100\r
    Actual: -532462766\r
    END EXECUTION - FAILED\r
    FAILED\r
    Test Harness Exitcode is : 1\r
    
    To run the test:
    &gt; set CORE_ROOT=C:\\dotnetbuild\\work\\e7ea211b-8ea4-4f83-8f9c-587faa935083\\Payload
    &gt; C:\\dotnetbuild\\work\\e7ea211b-8ea4-4f83-8f9c-587faa935083\\Work\\40455e47-1819-41ce-8ba1-d1c1be28e5bf\\Unzip\\runtimeeventsource\\runtimeeventsource.cmd
    \r
    Expected: True\r
    Actual:   False

        Stack Trace:

        
Build : 3.0 - 20180803.01 (Ready-To-Run Tests)
Failing configurations:
- Windows.7.Amd64
  - x64

Details: https://mc.dot.net/#/product/netcore/30/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fr2r~2Fcli~2F/build/20180803.01/workItem/tracing.runtimeeventsource.XUnitWrapper/analysis/xunit/tracing_runtimeeventsource._runtimeeventsource_runtimeeventsource_~2F_runtimeeventsource_runtimeeventsource_cmd</Description>
    <Title_Description>Test failure: tracing_runtimeeventsource._runtimeeventsource_runtimeeventsource_/_runtimeeventsource_runtimeeventsource_cmd Opened on behalf of @Sunny-pu

The test `tracing_runtimeeventsource._runtimeeventsource_runtimeeventsource_/_runtimeeventsource_runtimeeventsource_cmd` has failed.


    Unhandled Exception: System.Exception: Condition 'listener.EventCount &gt; 0' is not true\r
       at Tracing.Tests.Common.Assert.True(String name Boolean condition)\r
       at Tracing.Tests.RuntimeEventSourceTest.Main(String[] args)
    
    
    Return code:      1
    Raw output file:      C:\\dotnetbuild\\work\\e7ea211b-8ea4-4f83-8f9c-587faa935083\\Work\\40455e47-1819-41ce-8ba1-d1c1be28e5bf\\Unzip\\Reports\\tracing.runtimeeventsource\\runtimeeventsource\\runtimeeventsource.output.txt
    Raw output:
    BEGIN EXECUTION\r
            1 file(s) copied.\r
    \" C:\\dotnetbuild\\work\\e7ea211b-8ea4-4f83-8f9c-587faa935083\\Payload\\crossgen.exe\" /Platform_Assemblies_Paths C:\\dotnetbuild\\work\\e7ea211b-8ea4-4f83-8f9c-587faa935083\\Payload;C:\\dotnetbuild\\work\\e7ea211b-8ea4-4f83-8f9c-587faa935083\\Work\\40455e47-1819-41ce-8ba1-d1c1be28e5bf\\Unzip\\runtimeeventsource\\IL;C:\\dotnetbuild\\work\\e7ea211b-8ea4-4f83-8f9c-587faa935083\\Work\\40455e47-1819-41ce-8ba1-d1c1be28e5bf\\Unzip\\runtimeeventsource /in runtimeeventsource.org /out runtimeeventsource.exe\r
    Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0\r
    Copyright (c) Microsoft Corporation.  All rights reserved.\r
    \r
    Native image runtimeeventsource.exe generated successfully.\r
     \"C:\\dotnetbuild\\work\\e7ea211b-8ea4-4f83-8f9c-587faa935083\\Payload\\corerun.exe\" runtimeeventsource.exe \r
    [Simple] ThreadID = 2768 ID = 200 Name = IncreaseMemoryPressure\r
    TimeStamp: 8/3/2018 2:33:49 AM\r
    LocalTime: 8/3/2018 2:33:49 AM\r
    Difference: -00:00:00.0000304\r
    [Simple] ThreadID = 632 ID = 0 Name = EventSourceMessage\r
    TimeStamp: 8/3/2018 2:33:49 AM\r
    LocalTime: 8/3/2018 2:33:49 AM\r
    Difference: 00:00:00\r
    [NoEvents] ThreadID = 632 ID = 0 Name = EventSourceMessage\r
    TimeStamp: 8/3/2018 2:33:49 AM\r
    LocalTime: 8/3/2018 2:33:49 AM\r
    Difference: 00:00:00\r
    Expected: 100\r
    Actual: -532462766\r
    END EXECUTION - FAILED\r
    FAILED\r
    Test Harness Exitcode is : 1\r
    
    To run the test:
    &gt; set CORE_ROOT=C:\\dotnetbuild\\work\\e7ea211b-8ea4-4f83-8f9c-587faa935083\\Payload
    &gt; C:\\dotnetbuild\\work\\e7ea211b-8ea4-4f83-8f9c-587faa935083\\Work\\40455e47-1819-41ce-8ba1-d1c1be28e5bf\\Unzip\\runtimeeventsource\\runtimeeventsource.cmd
    \r
    Expected: True\r
    Actual:   False

        Stack Trace:

        
Build : 3.0 - 20180803.01 (Ready-To-Run Tests)
Failing configurations:
- Windows.7.Amd64
  - x64

Details: https://mc.dot.net/#/product/netcore/30/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fr2r~2Fcli~2F/build/20180803.01/workItem/tracing.runtimeeventsource.XUnitWrapper/analysis/xunit/tracing_runtimeeventsource._runtimeeventsource_runtimeeventsource_~2F_runtimeeventsource_runtimeeventsource_cmd</Title_Description>
    <Label>area-Tracing</Label>
    <Assignee>brianrob</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19267</IssueLabelID>
    <Title>Test failure: JIT_CodeGenBringUpTests._DblRoots_r_DblRoots_r_/_DblRoots_r_DblRoots_r_cmd</Title>
    <Description>Opened on behalf of @Sunny-pu

The test `JIT_CodeGenBringUpTests._DblRoots_r_DblRoots_r_/_DblRoots_r_DblRoots_r_cmd` has failed.

The system cannot find the file specified.\r
    Error compiling DblRoots_r.org: The system cannot find the file specified. (Exception from HRESULT: 0x80070002)\r
    Error: file \"DblRoots_r.org\" or one of its dependencies was not found\r
    
    
    Return code:      1
    Raw output file:      C:\\work\\02b4a928-9662-4407-b289-c7f586bb1e7b\\Work\\942af0b4-095f-4dd4-b8b3-f240d618c442\\Unzip\\Reports\\JIT.CodeGenBringUpTests\\DblRoots_r\\DblRoots_r.output.txt
    Raw output:
    BEGIN EXECUTION\r
    The system cannot find the file specified.\r
    \" C:\\work\\02b4a928-9662-4407-b289-c7f586bb1e7b\\Payload\\crossgen.exe\" /Platform_Assemblies_Paths C:\\work\\02b4a928-9662-4407-b289-c7f586bb1e7b\\Payload;C:\\work\\02b4a928-9662-4407-b289-c7f586bb1e7b\\Work\\942af0b4-095f-4dd4-b8b3-f240d618c442\\Unzip\\DblRoots_r\\IL;C:\\work\\02b4a928-9662-4407-b289-c7f586bb1e7b\\Work\\942af0b4-095f-4dd4-b8b3-f240d618c442\\Unzip\\DblRoots_r /in DblRoots_r.org /out DblRoots_r.exe\r
    Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0\r
    Copyright (c) Microsoft Corporation.  All rights reserved.\r
    \r
    Crossgen failed with exitcode - -3\r
    Test Harness Exitcode is : 1\r
    
    To run the test:
    &gt; set CORE_ROOT=C:\\work\\02b4a928-9662-4407-b289-c7f586bb1e7b\\Payload
    &gt; C:\\work\\02b4a928-9662-4407-b289-c7f586bb1e7b\\Work\\942af0b4-095f-4dd4-b8b3-f240d618c442\\Unzip\\DblRoots_r\\DblRoots_r.cmd
    \r
    Expected: True\r
    Actual:   False

        Stack Trace:

        
Build : 3.0 - 20180803.01 (Ready-To-Run Tests)
Failing configurations:
- Windows.10.Nano.Amd64
  - x64

Details: https://mc.dot.net/#/product/netcore/30/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fr2r~2Fcli~2F/build/20180803.01/workItem/JIT.CodeGenBringUpTests.XUnitWrapper</Description>
    <Title_Description>Test failure: JIT_CodeGenBringUpTests._DblRoots_r_DblRoots_r_/_DblRoots_r_DblRoots_r_cmd Opened on behalf of @Sunny-pu

The test `JIT_CodeGenBringUpTests._DblRoots_r_DblRoots_r_/_DblRoots_r_DblRoots_r_cmd` has failed.

The system cannot find the file specified.\r
    Error compiling DblRoots_r.org: The system cannot find the file specified. (Exception from HRESULT: 0x80070002)\r
    Error: file \"DblRoots_r.org\" or one of its dependencies was not found\r
    
    
    Return code:      1
    Raw output file:      C:\\work\\02b4a928-9662-4407-b289-c7f586bb1e7b\\Work\\942af0b4-095f-4dd4-b8b3-f240d618c442\\Unzip\\Reports\\JIT.CodeGenBringUpTests\\DblRoots_r\\DblRoots_r.output.txt
    Raw output:
    BEGIN EXECUTION\r
    The system cannot find the file specified.\r
    \" C:\\work\\02b4a928-9662-4407-b289-c7f586bb1e7b\\Payload\\crossgen.exe\" /Platform_Assemblies_Paths C:\\work\\02b4a928-9662-4407-b289-c7f586bb1e7b\\Payload;C:\\work\\02b4a928-9662-4407-b289-c7f586bb1e7b\\Work\\942af0b4-095f-4dd4-b8b3-f240d618c442\\Unzip\\DblRoots_r\\IL;C:\\work\\02b4a928-9662-4407-b289-c7f586bb1e7b\\Work\\942af0b4-095f-4dd4-b8b3-f240d618c442\\Unzip\\DblRoots_r /in DblRoots_r.org /out DblRoots_r.exe\r
    Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0\r
    Copyright (c) Microsoft Corporation.  All rights reserved.\r
    \r
    Crossgen failed with exitcode - -3\r
    Test Harness Exitcode is : 1\r
    
    To run the test:
    &gt; set CORE_ROOT=C:\\work\\02b4a928-9662-4407-b289-c7f586bb1e7b\\Payload
    &gt; C:\\work\\02b4a928-9662-4407-b289-c7f586bb1e7b\\Work\\942af0b4-095f-4dd4-b8b3-f240d618c442\\Unzip\\DblRoots_r\\DblRoots_r.cmd
    \r
    Expected: True\r
    Actual:   False

        Stack Trace:

        
Build : 3.0 - 20180803.01 (Ready-To-Run Tests)
Failing configurations:
- Windows.10.Nano.Amd64
  - x64

Details: https://mc.dot.net/#/product/netcore/30/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fr2r~2Fcli~2F/build/20180803.01/workItem/JIT.CodeGenBringUpTests.XUnitWrapper</Title_Description>
    <Label>test-run-uwp-coreclr</Label>
    <Assignee>sandreenko</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19266</IssueLabelID>
    <Title>Add PInvoke/Array tests</Title>
    <Description>
    </Description>
    <Title_Description>Add PInvoke/Array tests </Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jkoritzinsky</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19262</IssueLabelID>
    <Title>Update debugging doc with symbol downloader instructions.</Title>
    <Description>
    </Description>
    <Title_Description>Update debugging doc with symbol downloader instructions. </Title_Description>
    <Label>
    </Label>
    <Assignee>mikem8361</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19257</IssueLabelID>
    <Title>JIT: emitter assert running PMI</Title>
    <Description>Compile attached test case (from #9066 requires `/langversion:latest`) and jit via PMI to get the following emitter assert:
```
D:\repos\coreclr2\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root\corerun.exe d:\repos\jitutils\bin\PMI.dll prepall-quiet d:\bugs\9066\ex3.exe

Assert failure(PID 19908 [0x00004dc4] Thread: 22384 [0x5770]): Assertion failed '((regMask &amp; emitThisGCrefRegs) &amp;&amp; (ins == INS_add)) || ((regMask &amp; emitThisByrefRegs) &amp;&amp; (ins == INS_add || ins == INS_sub))' in 'SpanLike`1[Vector`1][System.Numerics.Vector`1[System.Single]]:get_Item(int):byref:this' (IL size 74)

    File: d:\repos\coreclr2\src\jit\emitxarch.cpp Line: 11498
    Image: D:\repos\coreclr2\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root\CoreRun.exe
```
~~This assert is new in the past 10 months or so...~~ (edit: probably not relevant -- we didn't have PMI back then and this instantiation is not created when you run the test normally).

cc @dotnet/jit-contrib 

Test case
```C#
using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;

class Program
{
    static void Main(string[] args)
    {
        var bytes = Encoding.ASCII.GetBytes("Hello World! Testing stack space!");
        Console.WriteLine(OneSpantype(bytes));
        Console.WriteLine(LotsOfSpans(bytes));
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    private static byte OneSpantype(byte[] array)
    {
        var span = new SpanLike&lt;byte&gt;(array);
        span = span.Slice(1);
        span = span.Slice(1);
        span = span.Slice(1);
        span = span.Slice(1);
        span = span.Slice(1);
        span = span.Slice(1);
        span = span.Slice(1);
        span = span.Slice(1);
        span = span.Slice(1);
        span = span.Slice(1);
        span = span.Slice(1);
        span = span.Slice(1);
        span = span.Slice(1);
        span = span.Slice(1);
        span = span.Slice(1);
        span = span.Slice(1);
        span = span.Slice(1);
        span = span.Slice(1);
        span = span.Slice(1);
        span = span.Slice(1);
        span = span.Slice(1);
        span = span.Slice(1);
        span = span.Slice(1);
        span = span.Slice(1);
        span = span.Slice(1);
        span = span.Slice(1);
        span = span.Slice(1);
        span = span.Slice(1);
        span = span.Slice(1);
        span = span.Slice(1);
        return span[0];
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    private static byte LotsOfSpans(byte[] array)
    {
        var span00 = new SpanLike&lt;byte&gt;(array);
        var span01 = span00.Slice(1);
        var span02 = span01.Slice(1);
        var span03 = span02.Slice(1);
        var span04 = span03.Slice(1);
        var span05 = span04.Slice(1);
        var span06 = span05.Slice(1);
        var span07 = span06.Slice(1);
        var span08 = span07.Slice(1);
        var span09 = span08.Slice(1);
        var span10 = span09.Slice(1);
        var span11 = span10.Slice(1);
        var span12 = span11.Slice(1);
        var span13 = span12.Slice(1);
        var span14 = span13.Slice(1);
        var span15 = span14.Slice(1);
        var span16 = span15.Slice(1);
        var span17 = span16.Slice(1);
        var span18 = span17.Slice(1);
        var span19 = span18.Slice(1);
        var span20 = span19.Slice(1);
        var span21 = span20.Slice(1);
        var span22 = span21.Slice(1);
        var span23 = span22.Slice(1);
        var span24 = span23.Slice(1);
        var span25 = span24.Slice(1);
        var span26 = span25.Slice(1);
        var span27 = span26.Slice(1);
        var span28 = span27.Slice(1);
        var span29 = span28.Slice(1);
        var span30 = span29.Slice(1);
        return span30[0];
    }
}

public readonly ref struct SpanLike&lt;T&gt;
{
    private readonly Pinnable&lt;T&gt; _pinnable;
    private readonly IntPtr _byteOffset;
    private readonly int _length;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public SpanLike(T[] array)
    {
        if (array == null)
            ThrowHelper.ThrowArgumentNullException(ExceptionArgument.array);
        if (default(T) == null &amp;&amp; array.GetType() != typeof(T[]))
            ThrowHelper.ThrowArrayTypeMismatchException_ArrayTypeMustBeExactMatch(typeof(T));

        _length = array.Length;
        _pinnable = Unsafe.As&lt;Pinnable&lt;T&gt;&gt;(array);
        _byteOffset = SpanHelpers.PerTypeValues&lt;T&gt;.ArrayAdjustment;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal SpanLike(Pinnable&lt;T&gt; pinnable IntPtr byteOffset int length)
    {
        Debug.Assert(length &gt;= 0);

        _length = length;
        _pinnable = pinnable;
        _byteOffset = byteOffset;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public SpanLike&lt;T&gt; Slice(int start)
    {
        if ((uint)start &gt; (uint)_length)
            ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.start);

        IntPtr newOffset = _byteOffset.Add&lt;T&gt;(start);
        int length = _length - start;
        return new SpanLike&lt;T&gt;(_pinnable newOffset length);
    }

    public ref T this[int index]
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            if ((uint)index &gt;= ((uint)_length))
                ThrowHelper.ThrowIndexOutOfRangeException();

            if (_pinnable == null)
                unsafe { return ref Unsafe.Add&lt;T&gt;(ref Unsafe.AsRef&lt;T&gt;(_byteOffset.ToPointer()) index); }
            else
                return ref Unsafe.Add&lt;T&gt;(ref Unsafe.AddByteOffset&lt;T&gt;(ref _pinnable.Data _byteOffset) index);
        }
    }
}

[StructLayout(LayoutKind.Sequential)]
internal sealed class Pinnable&lt;T&gt;
{
    public T Data;
}

internal static partial class SpanHelpers
{
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static IntPtr Add&lt;T&gt;(this IntPtr start int index)
    {
        Debug.Assert(start.ToInt64() &gt;= 0);
        Debug.Assert(index &gt;= 0);

        unsafe
        {
            if (sizeof(IntPtr) == sizeof(int))
            {
                // 32-bit path.
                uint byteLength = (uint)index * (uint)Unsafe.SizeOf&lt;T&gt;();
                return (IntPtr)(((byte*)start) + byteLength);
            }
            else
            {
                // 64-bit path.
                ulong byteLength = (ulong)index * (ulong)Unsafe.SizeOf&lt;T&gt;();
                return (IntPtr)(((byte*)start) + byteLength);
            }
        }
    }

    public class PerTypeValues&lt;T&gt;
    {
        public static readonly IntPtr ArrayAdjustment = MeasureArrayAdjustment();

        // Array header sizes are a runtime implementation detail and aren't the same across all runtimes. (The CLR made a tweak after 4.5 and Mono has an extra Bounds pointer.)
        private static IntPtr MeasureArrayAdjustment()
        {
            T[] sampleArray = new T[1];
            return Unsafe.ByteOffset&lt;T&gt;(ref Unsafe.As&lt;Pinnable&lt;T&gt;&gt;(sampleArray).Data ref sampleArray[0]);
        }
    }
}

internal static class ThrowHelper
{
    internal static void ThrowArgumentNullException(ExceptionArgument argument) { throw CreateArgumentNullException(argument); }
    [MethodImpl(MethodImplOptions.NoInlining)]
    private static Exception CreateArgumentNullException(ExceptionArgument argument) { return new ArgumentNullException(argument.ToString()); }

    internal static void ThrowArrayTypeMismatchException_ArrayTypeMustBeExactMatch(Type type) { throw CreateArrayTypeMismatchException_ArrayTypeMustBeExactMatch(type); }
    [MethodImpl(MethodImplOptions.NoInlining)]
    private static Exception CreateArrayTypeMismatchException_ArrayTypeMustBeExactMatch(Type type) { return new ArrayTypeMismatchException(); }

    internal static void ThrowIndexOutOfRangeException() { throw CreateIndexOutOfRangeException(); }
    [MethodImpl(MethodImplOptions.NoInlining)]
    private static Exception CreateIndexOutOfRangeException() { return new IndexOutOfRangeException(); }

    internal static void ThrowArgumentOutOfRangeException(ExceptionArgument argument) { throw CreateArgumentOutOfRangeException(argument); }
    [MethodImpl(MethodImplOptions.NoInlining)]
    private static Exception CreateArgumentOutOfRangeException(ExceptionArgument argument) { return new ArgumentOutOfRangeException(argument.ToString()); }
}

internal enum ExceptionArgument
{
    array
    start
}

```

category:correctness
theme:ir
skill-level:expert
cost:large</Description>
    <Title_Description>JIT: emitter assert running PMI Compile attached test case (from #9066 requires `/langversion:latest`) and jit via PMI to get the following emitter assert:
```
D:\repos\coreclr2\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root\corerun.exe d:\repos\jitutils\bin\PMI.dll prepall-quiet d:\bugs\9066\ex3.exe

Assert failure(PID 19908 [0x00004dc4] Thread: 22384 [0x5770]): Assertion failed '((regMask &amp; emitThisGCrefRegs) &amp;&amp; (ins == INS_add)) || ((regMask &amp; emitThisByrefRegs) &amp;&amp; (ins == INS_add || ins == INS_sub))' in 'SpanLike`1[Vector`1][System.Numerics.Vector`1[System.Single]]:get_Item(int):byref:this' (IL size 74)

    File: d:\repos\coreclr2\src\jit\emitxarch.cpp Line: 11498
    Image: D:\repos\coreclr2\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root\CoreRun.exe
```
~~This assert is new in the past 10 months or so...~~ (edit: probably not relevant -- we didn't have PMI back then and this instantiation is not created when you run the test normally).

cc @dotnet/jit-contrib 

Test case
```C#
using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;

class Program
{
    static void Main(string[] args)
    {
        var bytes = Encoding.ASCII.GetBytes("Hello World! Testing stack space!");
        Console.WriteLine(OneSpantype(bytes));
        Console.WriteLine(LotsOfSpans(bytes));
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    private static byte OneSpantype(byte[] array)
    {
        var span = new SpanLike&lt;byte&gt;(array);
        span = span.Slice(1);
        span = span.Slice(1);
        span = span.Slice(1);
        span = span.Slice(1);
        span = span.Slice(1);
        span = span.Slice(1);
        span = span.Slice(1);
        span = span.Slice(1);
        span = span.Slice(1);
        span = span.Slice(1);
        span = span.Slice(1);
        span = span.Slice(1);
        span = span.Slice(1);
        span = span.Slice(1);
        span = span.Slice(1);
        span = span.Slice(1);
        span = span.Slice(1);
        span = span.Slice(1);
        span = span.Slice(1);
        span = span.Slice(1);
        span = span.Slice(1);
        span = span.Slice(1);
        span = span.Slice(1);
        span = span.Slice(1);
        span = span.Slice(1);
        span = span.Slice(1);
        span = span.Slice(1);
        span = span.Slice(1);
        span = span.Slice(1);
        span = span.Slice(1);
        return span[0];
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    private static byte LotsOfSpans(byte[] array)
    {
        var span00 = new SpanLike&lt;byte&gt;(array);
        var span01 = span00.Slice(1);
        var span02 = span01.Slice(1);
        var span03 = span02.Slice(1);
        var span04 = span03.Slice(1);
        var span05 = span04.Slice(1);
        var span06 = span05.Slice(1);
        var span07 = span06.Slice(1);
        var span08 = span07.Slice(1);
        var span09 = span08.Slice(1);
        var span10 = span09.Slice(1);
        var span11 = span10.Slice(1);
        var span12 = span11.Slice(1);
        var span13 = span12.Slice(1);
        var span14 = span13.Slice(1);
        var span15 = span14.Slice(1);
        var span16 = span15.Slice(1);
        var span17 = span16.Slice(1);
        var span18 = span17.Slice(1);
        var span19 = span18.Slice(1);
        var span20 = span19.Slice(1);
        var span21 = span20.Slice(1);
        var span22 = span21.Slice(1);
        var span23 = span22.Slice(1);
        var span24 = span23.Slice(1);
        var span25 = span24.Slice(1);
        var span26 = span25.Slice(1);
        var span27 = span26.Slice(1);
        var span28 = span27.Slice(1);
        var span29 = span28.Slice(1);
        var span30 = span29.Slice(1);
        return span30[0];
    }
}

public readonly ref struct SpanLike&lt;T&gt;
{
    private readonly Pinnable&lt;T&gt; _pinnable;
    private readonly IntPtr _byteOffset;
    private readonly int _length;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public SpanLike(T[] array)
    {
        if (array == null)
            ThrowHelper.ThrowArgumentNullException(ExceptionArgument.array);
        if (default(T) == null &amp;&amp; array.GetType() != typeof(T[]))
            ThrowHelper.ThrowArrayTypeMismatchException_ArrayTypeMustBeExactMatch(typeof(T));

        _length = array.Length;
        _pinnable = Unsafe.As&lt;Pinnable&lt;T&gt;&gt;(array);
        _byteOffset = SpanHelpers.PerTypeValues&lt;T&gt;.ArrayAdjustment;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal SpanLike(Pinnable&lt;T&gt; pinnable IntPtr byteOffset int length)
    {
        Debug.Assert(length &gt;= 0);

        _length = length;
        _pinnable = pinnable;
        _byteOffset = byteOffset;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public SpanLike&lt;T&gt; Slice(int start)
    {
        if ((uint)start &gt; (uint)_length)
            ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.start);

        IntPtr newOffset = _byteOffset.Add&lt;T&gt;(start);
        int length = _length - start;
        return new SpanLike&lt;T&gt;(_pinnable newOffset length);
    }

    public ref T this[int index]
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            if ((uint)index &gt;= ((uint)_length))
                ThrowHelper.ThrowIndexOutOfRangeException();

            if (_pinnable == null)
                unsafe { return ref Unsafe.Add&lt;T&gt;(ref Unsafe.AsRef&lt;T&gt;(_byteOffset.ToPointer()) index); }
            else
                return ref Unsafe.Add&lt;T&gt;(ref Unsafe.AddByteOffset&lt;T&gt;(ref _pinnable.Data _byteOffset) index);
        }
    }
}

[StructLayout(LayoutKind.Sequential)]
internal sealed class Pinnable&lt;T&gt;
{
    public T Data;
}

internal static partial class SpanHelpers
{
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static IntPtr Add&lt;T&gt;(this IntPtr start int index)
    {
        Debug.Assert(start.ToInt64() &gt;= 0);
        Debug.Assert(index &gt;= 0);

        unsafe
        {
            if (sizeof(IntPtr) == sizeof(int))
            {
                // 32-bit path.
                uint byteLength = (uint)index * (uint)Unsafe.SizeOf&lt;T&gt;();
                return (IntPtr)(((byte*)start) + byteLength);
            }
            else
            {
                // 64-bit path.
                ulong byteLength = (ulong)index * (ulong)Unsafe.SizeOf&lt;T&gt;();
                return (IntPtr)(((byte*)start) + byteLength);
            }
        }
    }

    public class PerTypeValues&lt;T&gt;
    {
        public static readonly IntPtr ArrayAdjustment = MeasureArrayAdjustment();

        // Array header sizes are a runtime implementation detail and aren't the same across all runtimes. (The CLR made a tweak after 4.5 and Mono has an extra Bounds pointer.)
        private static IntPtr MeasureArrayAdjustment()
        {
            T[] sampleArray = new T[1];
            return Unsafe.ByteOffset&lt;T&gt;(ref Unsafe.As&lt;Pinnable&lt;T&gt;&gt;(sampleArray).Data ref sampleArray[0]);
        }
    }
}

internal static class ThrowHelper
{
    internal static void ThrowArgumentNullException(ExceptionArgument argument) { throw CreateArgumentNullException(argument); }
    [MethodImpl(MethodImplOptions.NoInlining)]
    private static Exception CreateArgumentNullException(ExceptionArgument argument) { return new ArgumentNullException(argument.ToString()); }

    internal static void ThrowArrayTypeMismatchException_ArrayTypeMustBeExactMatch(Type type) { throw CreateArrayTypeMismatchException_ArrayTypeMustBeExactMatch(type); }
    [MethodImpl(MethodImplOptions.NoInlining)]
    private static Exception CreateArrayTypeMismatchException_ArrayTypeMustBeExactMatch(Type type) { return new ArrayTypeMismatchException(); }

    internal static void ThrowIndexOutOfRangeException() { throw CreateIndexOutOfRangeException(); }
    [MethodImpl(MethodImplOptions.NoInlining)]
    private static Exception CreateIndexOutOfRangeException() { return new IndexOutOfRangeException(); }

    internal static void ThrowArgumentOutOfRangeException(ExceptionArgument argument) { throw CreateArgumentOutOfRangeException(argument); }
    [MethodImpl(MethodImplOptions.NoInlining)]
    private static Exception CreateArgumentOutOfRangeException(ExceptionArgument argument) { return new ArgumentOutOfRangeException(argument.ToString()); }
}

internal enum ExceptionArgument
{
    array
    start
}

```

category:correctness
theme:ir
skill-level:expert
cost:large</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19256</IssueLabelID>
    <Title>RyuJIT: Argument written to stack too early on Linux</Title>
    <Description>On Linux x64 the following program prints `1 1234` in release but should print `1 2`.
```csharp
struct S2
{
    public uint F0;
    public ulong F1 F2;
    public S2(uint f0): this() { F0 = f0; }
}

public class Program
{
    static S2 s_one = new S2(1);
    static S2 s_two = new S2(2);
    public static void Main()
    {
        M28(s_two M28(s_one s_one));
    }

    static ref S2 M28(S2 arg0 S2 arg1)
    {
        System.Console.WriteLine(arg0.F0);
        arg0.F0 = 1234; // this is printed in next invocation
        System.GC.KeepAlive(arg0); // ensure that assignment isn't removed
        return ref s_one;
    }
}
```

The disassembly shows that RyuJIT does not properly pass the first argument to the outer call; it is written to the stack before the inner call:
```asm
; Assembly listing for method Program:Main()
; Emitting BLENDED_CODE for X64 CPU with AVX
; optimized code
; rbp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 OutArgs      [V00    ] (  1  1   )  lclBlk (48) [rsp+0x00]
;* V01 tmp1         [V01    ] (  0  0   )  struct (24) zero-ref
;  V02 tmp2         [V02T02] (  5  5   )     int  -&gt;  rdi         V01.F0(offs=0x00) P-INDEP
;  V03 tmp3         [V03T03] (  5  5   )    long  -&gt;  rsi         V01.F1(offs=0x08) P-INDEP
;  V04 tmp4         [V04T04] (  5  5   )    long  -&gt;  rax         V01.F2(offs=0x10) P-INDEP
;  V05 tmp5         [V05T01] (  4  8   )   byref  -&gt;  rax
;  V06 cse0         [V06T00] ( 11 11   )   byref  -&gt;  rax
;  V07 cse1         [V07T05] (  3  3   )    long  -&gt;  [rbp-0x08]
;
; Lcl frame size = 64

G_M5092_IG01:
       55                   push     rbp
       4883EC40             sub      rsp 64
       C5F877               vzeroupper
       488D6C2440           lea      rbp [rsp+40H]

G_M5092_IG02:
       48BF98463F9E4C7F0000 mov      rdi 0x7F4C9E3F4698
       BE02000000           mov      esi 2
       E87F0F9F78           call     CORINFO_HELP_GETSHARED_NONGCSTATIC_BASE
       48B8180900904C7F0000 mov      rax 0x7F4C90000918                 
       488B00               mov      rax gword ptr [rax]
       4883C008             add      rax 8                              ; rax = address of s_two
       8B38                 mov      edi dword ptr [rax]                |
       488B7008             mov      rsi qword ptr [rax+8]              |
       488B4010             mov      rax qword ptr [rax+16]             |
       893C24               mov      dword ptr [rsp] edi                |
       4889742408           mov      qword ptr [rsp+08H] rsi            |
       4889442410           mov      qword ptr [rsp+10H] rax            | write s_two as first arg (too early)
       48B8100900904C7F0000 mov      rax 0x7F4C90000910
       488B00               mov      rax gword ptr [rax]
       4883C008             add      rax 8                              ; rax = address of s_one
       C4E17A6F00           vmovdqu  xmm0 qword ptr [rax]               |
       C4E17A7F0424         vmovdqu  qword ptr [rsp] xmm0               |
       488B7810             mov      rdi qword ptr [rax+16]             |
       48897C2410           mov      qword ptr [rsp+10H] rdi            ; write s_one as first arg
       C4E17A6F00           vmovdqu  xmm0 qword ptr [rax]               |
       C4E17A7F442418       vmovdqu  qword ptr [rsp+18H] xmm0           |
       488B7810             mov      rdi qword ptr [rax+16]             |
       48897C2428           mov      qword ptr [rsp+28H] rdi            ; write s_one as second arg
       E888FBFFFF           call     Program:M28(structstruct):byref    ; inner call
       C4E17A6F00           vmovdqu  xmm0 qword ptr [rax]               |
       C4E17A7F442418       vmovdqu  qword ptr [rsp+18H] xmm0           |
       488B7810             mov      rdi qword ptr [rax+16]             |
       48897C2428           mov      qword ptr [rsp+28H] rdi            | write second arg
       E86EFBFFFF           call     Program:M28(structstruct):byref    ; outer call. First arg was passed too early
       90                   nop

G_M5092_IG03:
       488D6500             lea      rsp [rbp]
       5D                   pop      rbp
       C3                   ret

; Total bytes of code 169 prolog size 13 for method Program:Main()
```

This does not repro on Windows which is likely related to the fact that both args are passed by reference there.</Description>
    <Title_Description>RyuJIT: Argument written to stack too early on Linux On Linux x64 the following program prints `1 1234` in release but should print `1 2`.
```csharp
struct S2
{
    public uint F0;
    public ulong F1 F2;
    public S2(uint f0): this() { F0 = f0; }
}

public class Program
{
    static S2 s_one = new S2(1);
    static S2 s_two = new S2(2);
    public static void Main()
    {
        M28(s_two M28(s_one s_one));
    }

    static ref S2 M28(S2 arg0 S2 arg1)
    {
        System.Console.WriteLine(arg0.F0);
        arg0.F0 = 1234; // this is printed in next invocation
        System.GC.KeepAlive(arg0); // ensure that assignment isn't removed
        return ref s_one;
    }
}
```

The disassembly shows that RyuJIT does not properly pass the first argument to the outer call; it is written to the stack before the inner call:
```asm
; Assembly listing for method Program:Main()
; Emitting BLENDED_CODE for X64 CPU with AVX
; optimized code
; rbp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 OutArgs      [V00    ] (  1  1   )  lclBlk (48) [rsp+0x00]
;* V01 tmp1         [V01    ] (  0  0   )  struct (24) zero-ref
;  V02 tmp2         [V02T02] (  5  5   )     int  -&gt;  rdi         V01.F0(offs=0x00) P-INDEP
;  V03 tmp3         [V03T03] (  5  5   )    long  -&gt;  rsi         V01.F1(offs=0x08) P-INDEP
;  V04 tmp4         [V04T04] (  5  5   )    long  -&gt;  rax         V01.F2(offs=0x10) P-INDEP
;  V05 tmp5         [V05T01] (  4  8   )   byref  -&gt;  rax
;  V06 cse0         [V06T00] ( 11 11   )   byref  -&gt;  rax
;  V07 cse1         [V07T05] (  3  3   )    long  -&gt;  [rbp-0x08]
;
; Lcl frame size = 64

G_M5092_IG01:
       55                   push     rbp
       4883EC40             sub      rsp 64
       C5F877               vzeroupper
       488D6C2440           lea      rbp [rsp+40H]

G_M5092_IG02:
       48BF98463F9E4C7F0000 mov      rdi 0x7F4C9E3F4698
       BE02000000           mov      esi 2
       E87F0F9F78           call     CORINFO_HELP_GETSHARED_NONGCSTATIC_BASE
       48B8180900904C7F0000 mov      rax 0x7F4C90000918                 
       488B00               mov      rax gword ptr [rax]
       4883C008             add      rax 8                              ; rax = address of s_two
       8B38                 mov      edi dword ptr [rax]                |
       488B7008             mov      rsi qword ptr [rax+8]              |
       488B4010             mov      rax qword ptr [rax+16]             |
       893C24               mov      dword ptr [rsp] edi                |
       4889742408           mov      qword ptr [rsp+08H] rsi            |
       4889442410           mov      qword ptr [rsp+10H] rax            | write s_two as first arg (too early)
       48B8100900904C7F0000 mov      rax 0x7F4C90000910
       488B00               mov      rax gword ptr [rax]
       4883C008             add      rax 8                              ; rax = address of s_one
       C4E17A6F00           vmovdqu  xmm0 qword ptr [rax]               |
       C4E17A7F0424         vmovdqu  qword ptr [rsp] xmm0               |
       488B7810             mov      rdi qword ptr [rax+16]             |
       48897C2410           mov      qword ptr [rsp+10H] rdi            ; write s_one as first arg
       C4E17A6F00           vmovdqu  xmm0 qword ptr [rax]               |
       C4E17A7F442418       vmovdqu  qword ptr [rsp+18H] xmm0           |
       488B7810             mov      rdi qword ptr [rax+16]             |
       48897C2428           mov      qword ptr [rsp+28H] rdi            ; write s_one as second arg
       E888FBFFFF           call     Program:M28(structstruct):byref    ; inner call
       C4E17A6F00           vmovdqu  xmm0 qword ptr [rax]               |
       C4E17A7F442418       vmovdqu  qword ptr [rsp+18H] xmm0           |
       488B7810             mov      rdi qword ptr [rax+16]             |
       48897C2428           mov      qword ptr [rsp+28H] rdi            | write second arg
       E86EFBFFFF           call     Program:M28(structstruct):byref    ; outer call. First arg was passed too early
       90                   nop

G_M5092_IG03:
       488D6500             lea      rsp [rbp]
       5D                   pop      rbp
       C3                   ret

; Total bytes of code 169 prolog size 13 for method Program:Main()
```

This does not repro on Windows which is likely related to the fact that both args are passed by reference there.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19255</IssueLabelID>
    <Title>[armel][2.1.1] Incorrect stepping in debugger</Title>
    <Description>After setting break point we try to make step but CoreCLR crash with abort.
If we attach with gdb we'll see several `SIGTRAP` it's ok for ARM and CoreCLR handle them well but one of this SIGTRAP aren't handled by runtime which cause abort in `sigtrap_handler()`.

We've checked latest master and it works. There are several PRs which fix stepping after 2.1 release:
https://github.com/dotnet/coreclr/pull/17617
https://github.com/dotnet/coreclr/pull/17879
https://github.com/dotnet/coreclr/pull/17990
https://github.com/dotnet/coreclr/pull/18129
https://github.com/dotnet/coreclr/pull/18247
They help but not at all - application crashed but little bit later with the same abort.
Are there any others fixes which we've missed?

cc @jkotas @BruceForstall @kbaladurin @BredPet </Description>
    <Title_Description>[armel][2.1.1] Incorrect stepping in debugger After setting break point we try to make step but CoreCLR crash with abort.
If we attach with gdb we'll see several `SIGTRAP` it's ok for ARM and CoreCLR handle them well but one of this SIGTRAP aren't handled by runtime which cause abort in `sigtrap_handler()`.

We've checked latest master and it works. There are several PRs which fix stepping after 2.1 release:
https://github.com/dotnet/coreclr/pull/17617
https://github.com/dotnet/coreclr/pull/17879
https://github.com/dotnet/coreclr/pull/17990
https://github.com/dotnet/coreclr/pull/18129
https://github.com/dotnet/coreclr/pull/18247
They help but not at all - application crashed but little bit later with the same abort.
Are there any others fixes which we've missed?

cc @jkotas @BruceForstall @kbaladurin @BredPet </Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>hoyosjs</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19248</IssueLabelID>
    <Title>[arm32] Test failures in finalizearraysleep finalizearray</Title>
    <Description>With JitStress=1

https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_jitstress1_tst/36/artifact/bin/tests/Windows_NT.arm.Checked/Smarty.run.0/Smarty.0.fail.smrt/*view*/

```
TEST_CMD_LINE: GC\Features\Finalizer\finalizeother\finalizearraysleep&gt; C:\Users\robox\j\workspace\arm_cross_che---722ff6b5\bin\tests\Windows_NT.arm.Checked\GC\Features\Finalizer\finalizeother\finalizearraysleep\finalizearraysleep.cmd 

BEGIN EXECUTION
 "C:\Users\robox\j\workspace\arm_cross_che---722ff6b5\bin\tests\Windows_NT.arm.Checked\Tests\Core_Root\corerun.exe" finalizearraysleep.exe 
Test for Finalize() for array of objects failed!
Expected: 100
Actual: 0
END EXECUTION - FAILED
FAILED
```

```
TEST_CMD_LINE: GC\Features\Finalizer\finalizeother\finalizearray&gt; C:\Users\robox\j\workspace\arm_cross_che---722ff6b5\bin\tests\Windows_NT.arm.Checked\GC\Features\Finalizer\finalizeother\finalizearray\finalizearray.cmd 

BEGIN EXECUTION
 "C:\Users\robox\j\workspace\arm_cross_che---722ff6b5\bin\tests\Windows_NT.arm.Checked\Tests\Core_Root\corerun.exe" finalizearray.exe 
Test for Finalize() for array of objects failed!
Expected: 100
Actual: 1
END EXECUTION - FAILED
FAILED
```

@dotnet/arm32-contrib </Description>
    <Title_Description>[arm32] Test failures in finalizearraysleep, finalizearray With JitStress=1

https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_jitstress1_tst/36/artifact/bin/tests/Windows_NT.arm.Checked/Smarty.run.0/Smarty.0.fail.smrt/*view*/

```
TEST_CMD_LINE: GC\Features\Finalizer\finalizeother\finalizearraysleep&gt; C:\Users\robox\j\workspace\arm_cross_che---722ff6b5\bin\tests\Windows_NT.arm.Checked\GC\Features\Finalizer\finalizeother\finalizearraysleep\finalizearraysleep.cmd 

BEGIN EXECUTION
 "C:\Users\robox\j\workspace\arm_cross_che---722ff6b5\bin\tests\Windows_NT.arm.Checked\Tests\Core_Root\corerun.exe" finalizearraysleep.exe 
Test for Finalize() for array of objects failed!
Expected: 100
Actual: 0
END EXECUTION - FAILED
FAILED
```

```
TEST_CMD_LINE: GC\Features\Finalizer\finalizeother\finalizearray&gt; C:\Users\robox\j\workspace\arm_cross_che---722ff6b5\bin\tests\Windows_NT.arm.Checked\GC\Features\Finalizer\finalizeother\finalizearray\finalizearray.cmd 

BEGIN EXECUTION
 "C:\Users\robox\j\workspace\arm_cross_che---722ff6b5\bin\tests\Windows_NT.arm.Checked\Tests\Core_Root\corerun.exe" finalizearray.exe 
Test for Finalize() for array of objects failed!
Expected: 100
Actual: 1
END EXECUTION - FAILED
FAILED
```

@dotnet/arm32-contrib </Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>2/08/2018 3:52:11 PM +00:00</CreatedAt>
    <ClosedAt>17/10/2018 12:10:11 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19246</IssueLabelID>
    <Title>Remaining non-generated HWIntrinsic tests should be moved to be generated</Title>
    <Description>Currently there are a number of HWIntrinsic tests that are hand written which leads to maintainability issues and gaps in coverage as compared to the other HWIntrinsic tests (templates have been updated a few times in order to fix bugs or add new scenarios which impacts the vast majority of other HWIntrinsic tests).

It would be beneficial to move them to the same code generation templates as the other HWIntrinsic tests. 

category:testing
theme:vector-codegen
skill-level:intermediate
cost:medium</Description>
    <Title_Description>Remaining non-generated HWIntrinsic tests should be moved to be generated Currently there are a number of HWIntrinsic tests that are hand written which leads to maintainability issues and gaps in coverage as compared to the other HWIntrinsic tests (templates have been updated a few times in order to fix bugs or add new scenarios which impacts the vast majority of other HWIntrinsic tests).

It would be beneficial to move them to the same code generation templates as the other HWIntrinsic tests. 

category:testing
theme:vector-codegen
skill-level:intermediate
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>4creators</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19245</IssueLabelID>
    <Title>SSE2 HWIntrinsics tests should be moved to use the code templates</Title>
    <Description>Currently the majority of the SSE2 HWIntrinsic tests are hand written which leads to maintainability issues and gaps in coverage as compared to the other HWIntrinsic tests (templates have been updated a few times in order to fix bugs or add new scenarios which impacts the vast majority of other HWIntrinsic tests).

It would be beneficial to move them to the same code generation templates as the other HWIntrinsic tests. Additionally if the SSE2 tests were covering relevant code patterns not covered by the existing templates it should be reviewed whether or not adding those scenarios to the templates would be generally beneficial.</Description>
    <Title_Description>SSE2 HWIntrinsics tests should be moved to use the code templates Currently the majority of the SSE2 HWIntrinsic tests are hand written which leads to maintainability issues and gaps in coverage as compared to the other HWIntrinsic tests (templates have been updated a few times in order to fix bugs or add new scenarios which impacts the vast majority of other HWIntrinsic tests).

It would be beneficial to move them to the same code generation templates as the other HWIntrinsic tests. Additionally if the SSE2 tests were covering relevant code patterns not covered by the existing templates it should be reviewed whether or not adding those scenarios to the templates would be generally beneficial.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>tannergooding</Assignee>
    <CreatedAt>2/08/2018 2:21:52 PM +00:00</CreatedAt>
    <ClosedAt>24/01/2019 6:31:04 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19243</IssueLabelID>
    <Title>RyuJIT: Invalid ordering when assigning ref-return</Title>
    <Description>The following example gives different results in debug and release:
```csharp
// Debug: Outputs 8614979244451975600
// Release: Outputs 0
struct S0
{
    public long F0;
    public sbyte F4;
    public S0(long f0): this() { F0 = f0; }
}

class C0
{
    public S0 F5;
    public C0(S0 f5) { F5 = f5; }
}

public class Program
{
    static C0 s_13 = new C0(new S0(0));
    static S0 s_37;
    public static void Main()
    {
        M7() = s_13.F5;
        System.Console.WriteLine(s_37.F0);
    }

    static ref S0 M7()
    {
        s_13 = new C0(new S0(8614979244451975600L));
        return ref s_37;
    }
}
```

The disassembly shows that the `s_13` reference is loaded before the call to `M7`:
```asm
       48B9C8456396FA7F0000 mov      rcx 0x7FFA966345C8
       BA03000000           mov      edx 3
       E854CD815F           call     CORINFO_HELP_GETSHARED_NONGCSTATIC_BASE
       48B878291C2943020000 mov      rax 0x243291C2978
       488B00               mov      rax gword ptr [rax]           ; [s_13]
       488D7008             lea      rsi bword ptr [rax+8]
       E8DEFBFFFF           call     Program:M7():byref
```

As far as I can tell everything looks fine before rationalize:
```
***** BB01 stmt 1
     ( 47 43) [000015] ------------              *  STMT      void  (IL   ???...  ???)
N019 ( 29 35) [000012] -ACXG--N----              |  /--*  IND       struct &lt;l:$383 c:$382&gt;
N017 (  1  1) [000034] ------------              |  |  |  /--*  CNS_INT   long   8 field offset Fseq[F5] $181
N018 ( 26 33) [000035] -ACXG-------              |  |  \--*  ADD       byref  &lt;l:$343 c:$342&gt;
N015 (  5 12) [000004] x---G-------              |  |     |  /--*  IND       ref    &lt;l:$2c0 c:$300&gt;
N014 (  3 10) [000040] ------------              |  |     |  |  \--*  CNS_INT(h) long   0x2d423b92978 static Fseq[s_13] $280
N016 ( 24 31) [000011] -ACXG-------              |  |     \--*  COMMA     ref    &lt;l:$202 c:$201&gt;
N012 (  1  1) [000050] ------------              |  |        |  /--*  LCL_VAR   long   V01 cse0          $241
N013 ( 19 19) [000051] -ACXG-------              |  |        \--*  COMMA     long   $241
N009 ( 18 18) [000010] H-CXG-------              |  |           |  /--*  CALL help long   HELPER.CORINFO_HELP_GETSHARED_NONGCSTATIC_BASE $241
N005 (  3 10) [000006] ------------ arg0 in rcx  |  |           |  |  +--*  CNS_INT   long   0x7ffa71e245c8 $180
N006 (  1  1) [000007] ------------ arg1 in rdx  |  |           |  |  \--*  CNS_INT   int    3 $41
N011 ( 18 18) [000049] -ACXG---R---              |  |           \--*  ASG       long   $VN.Void
N010 (  1  1) [000048] D------N----              |  |              \--*  LCL_VAR   long   V01 cse0          $241
N022 ( 47 43) [000014] -ACXG---R---              \--*  ASG       struct (copy) $VN.Void
N021 ( 17  7) [000013] --CXG-------                 \--*  BLK(16)   struct
N020 ( 14  5) [000001] --CXG-------                    \--*  CALL      byref  Program.M7 $400
```

But rationalize seems to end up with this in the wrong order:
```
Rewriting GT_ASG(BLK(X) Y) to STORE_BLK(XY):
N014 (  3 10) [000040] ------------        t40 =    CNS_INT(h) long   0x2d423b92978 static Fseq[s_13] $280
                                                 /--*  t40    long   
N015 (  5 12) [000004] x---G-------         t4 = *  IND       ref    &lt;l:$2c0 c:$300&gt;
N017 (  1  1) [000034] ------------        t34 =    CNS_INT   long   8 field offset Fseq[F5] $181
                                                 /--*  t4     ref    
                                                 +--*  t34    long   
N018 ( 26 33) [000035] ---XG-------        t35 = *  ADD       byref  &lt;l:$343 c:$342&gt;
                                                 /--*  t35    byref  
N019 ( 29 35) [000012] ---XG--N----        t12 = *  IND       struct &lt;l:$383 c:$382&gt;
N020 ( 14  5) [000001] --CXG-------         t1 =    CALL      byref  Program.M7 $400
                                                 /--*  t1     byref  
                                                 +--*  t12    struct 
N021 ( 17  7) [000013] -ACXG-------              *  STORE_BLK(16) struct (copy)
```</Description>
    <Title_Description>RyuJIT: Invalid ordering when assigning ref-return The following example gives different results in debug and release:
```csharp
// Debug: Outputs 8614979244451975600
// Release: Outputs 0
struct S0
{
    public long F0;
    public sbyte F4;
    public S0(long f0): this() { F0 = f0; }
}

class C0
{
    public S0 F5;
    public C0(S0 f5) { F5 = f5; }
}

public class Program
{
    static C0 s_13 = new C0(new S0(0));
    static S0 s_37;
    public static void Main()
    {
        M7() = s_13.F5;
        System.Console.WriteLine(s_37.F0);
    }

    static ref S0 M7()
    {
        s_13 = new C0(new S0(8614979244451975600L));
        return ref s_37;
    }
}
```

The disassembly shows that the `s_13` reference is loaded before the call to `M7`:
```asm
       48B9C8456396FA7F0000 mov      rcx 0x7FFA966345C8
       BA03000000           mov      edx 3
       E854CD815F           call     CORINFO_HELP_GETSHARED_NONGCSTATIC_BASE
       48B878291C2943020000 mov      rax 0x243291C2978
       488B00               mov      rax gword ptr [rax]           ; [s_13]
       488D7008             lea      rsi bword ptr [rax+8]
       E8DEFBFFFF           call     Program:M7():byref
```

As far as I can tell everything looks fine before rationalize:
```
***** BB01 stmt 1
     ( 47 43) [000015] ------------              *  STMT      void  (IL   ???...  ???)
N019 ( 29 35) [000012] -ACXG--N----              |  /--*  IND       struct &lt;l:$383 c:$382&gt;
N017 (  1  1) [000034] ------------              |  |  |  /--*  CNS_INT   long   8 field offset Fseq[F5] $181
N018 ( 26 33) [000035] -ACXG-------              |  |  \--*  ADD       byref  &lt;l:$343 c:$342&gt;
N015 (  5 12) [000004] x---G-------              |  |     |  /--*  IND       ref    &lt;l:$2c0 c:$300&gt;
N014 (  3 10) [000040] ------------              |  |     |  |  \--*  CNS_INT(h) long   0x2d423b92978 static Fseq[s_13] $280
N016 ( 24 31) [000011] -ACXG-------              |  |     \--*  COMMA     ref    &lt;l:$202 c:$201&gt;
N012 (  1  1) [000050] ------------              |  |        |  /--*  LCL_VAR   long   V01 cse0          $241
N013 ( 19 19) [000051] -ACXG-------              |  |        \--*  COMMA     long   $241
N009 ( 18 18) [000010] H-CXG-------              |  |           |  /--*  CALL help long   HELPER.CORINFO_HELP_GETSHARED_NONGCSTATIC_BASE $241
N005 (  3 10) [000006] ------------ arg0 in rcx  |  |           |  |  +--*  CNS_INT   long   0x7ffa71e245c8 $180
N006 (  1  1) [000007] ------------ arg1 in rdx  |  |           |  |  \--*  CNS_INT   int    3 $41
N011 ( 18 18) [000049] -ACXG---R---              |  |           \--*  ASG       long   $VN.Void
N010 (  1  1) [000048] D------N----              |  |              \--*  LCL_VAR   long   V01 cse0          $241
N022 ( 47 43) [000014] -ACXG---R---              \--*  ASG       struct (copy) $VN.Void
N021 ( 17  7) [000013] --CXG-------                 \--*  BLK(16)   struct
N020 ( 14  5) [000001] --CXG-------                    \--*  CALL      byref  Program.M7 $400
```

But rationalize seems to end up with this in the wrong order:
```
Rewriting GT_ASG(BLK(X) Y) to STORE_BLK(XY):
N014 (  3 10) [000040] ------------        t40 =    CNS_INT(h) long   0x2d423b92978 static Fseq[s_13] $280
                                                 /--*  t40    long   
N015 (  5 12) [000004] x---G-------         t4 = *  IND       ref    &lt;l:$2c0 c:$300&gt;
N017 (  1  1) [000034] ------------        t34 =    CNS_INT   long   8 field offset Fseq[F5] $181
                                                 /--*  t4     ref    
                                                 +--*  t34    long   
N018 ( 26 33) [000035] ---XG-------        t35 = *  ADD       byref  &lt;l:$343 c:$342&gt;
                                                 /--*  t35    byref  
N019 ( 29 35) [000012] ---XG--N----        t12 = *  IND       struct &lt;l:$383 c:$382&gt;
N020 ( 14  5) [000001] --CXG-------         t1 =    CALL      byref  Program.M7 $400
                                                 /--*  t1     byref  
                                                 +--*  t12    struct 
N021 ( 17  7) [000013] -ACXG-------              *  STORE_BLK(16) struct (copy)
```</Title_Description>
    <Label>
    </Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19242</IssueLabelID>
    <Title>[WIP] dummy change to test dev/unix_test_workflow</Title>
    <Description>
    </Description>
    <Title_Description>[WIP] dummy change to test dev/unix_test_workflow </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>2/08/2018 5:44:52 AM +00:00</CreatedAt>
    <ClosedAt>7/08/2018 12:10:32 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19238</IssueLabelID>
    <Title>Fix interop test targets</Title>
    <Description>Remove TargetFramework from Interop.settings.targets since it already gets handled by the build environment and 2.0 doesn't work.</Description>
    <Title_Description>Fix interop test targets Remove TargetFramework from Interop.settings.targets since it already gets handled by the build environment and 2.0 doesn't work.</Title_Description>
    <Label>test bug</Label>
    <Assignee>morganbr</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19236</IssueLabelID>
    <Title>[WIP] dummy change to test dev/unix_test_workflow branch</Title>
    <Description>
    </Description>
    <Title_Description>[WIP] dummy change to test dev/unix_test_workflow branch </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>dotnet-bot</Assignee>
    <CreatedAt>2/08/2018 1:17:01 AM +00:00</CreatedAt>
    <ClosedAt>2/08/2018 5:45:31 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19235</IssueLabelID>
    <Title>Improve StreamWriter format perf</Title>
    <Description>Override the format overloads for TextWriter and skip the extra string allocation for the formatted string by using StringBuilder directly copying straight to the output buffer.

Improves performance roughtly 10% and cuts allocations by 10x and up (formatting a string into a string goes to *zero* allocations).</Description>
    <Title_Description>Improve StreamWriter format perf Override the format overloads for TextWriter and skip the extra string allocation for the formatted string by using StringBuilder directly copying straight to the output buffer.

Improves performance roughtly 10% and cuts allocations by 10x and up (formatting a string into a string goes to *zero* allocations).</Title_Description>
    <Label>area-System.IO</Label>
    <Assignee>JeremyKuhne</Assignee>
    <CreatedAt>2/08/2018 12:56:21 AM +00:00</CreatedAt>
    <ClosedAt>6/08/2018 6:22:58 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19232</IssueLabelID>
    <Title>Support O_DIRECT file open option handling for FileStream.Unix</Title>
    <Description>As discussed in #19229 changes are very small. The value 0x4000 is [from Mono](https://github.com/mono/mono/blob/78eb8324b20b29544233c3fe42f6c12e78041ba7/mcs/class/Mono.Posix/Mono.Unix.Native/Syscall.cs#L150) and cross-checked with some Google search.

</Description>
    <Title_Description>Support O_DIRECT file open option handling for FileStream.Unix As discussed in #19229 changes are very small. The value 0x4000 is [from Mono](https://github.com/mono/mono/blob/78eb8324b20b29544233c3fe42f6c12e78041ba7/mcs/class/Mono.Posix/Mono.Unix.Native/Syscall.cs#L150) and cross-checked with some Google search.

</Title_Description>
    <Label>area-System.IO</Label>
    <Assignee>JeremyKuhne</Assignee>
    <CreatedAt>1/08/2018 9:31:08 PM +00:00</CreatedAt>
    <ClosedAt>16/09/2018 4:24:00 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19231</IssueLabelID>
    <Title>Better diagnostics for fail-fast conditions</Title>
    <Description>Given the simulation process used for rich debugging purposes it may happen that bugs could lead the runtime to an unsafe state. 

When CoreCLR crashes the runtime because of fail-fast conditions it should give (if possible) information about the underlying fail-fast trigger that causes the crash.  It doesn't have to be perfect but it could use something better than COR_E_EXECUTIONENGINE(0x80131506). For the impact of not having the information readily available take a look at #19220 

cc @AndyAyersMS </Description>
    <Title_Description>Better diagnostics for fail-fast conditions Given the simulation process used for rich debugging purposes it may happen that bugs could lead the runtime to an unsafe state. 

When CoreCLR crashes the runtime because of fail-fast conditions it should give (if possible) information about the underlying fail-fast trigger that causes the crash.  It doesn't have to be perfect but it could use something better than COR_E_EXECUTIONENGINE(0x80131506). For the impact of not having the information readily available take a look at #19220 

cc @AndyAyersMS </Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>AndyAyersMS</Assignee>
    <CreatedAt>1/08/2018 6:42:08 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19229</IssueLabelID>
    <Title>Add O_DIRECT file open option handling for FileStream.Unix</Title>
    <Description>[Here](https://github.com/dotnet/coreclr/blob/75e62c545ac5c7195bf846b47e28c4f27736d64c/src/System.Private.CoreLib/shared/System/IO/FileStream.cs#L204) `NoBuffering`/`FILE_FLAG_NO_BUFFERING` flag is hidden but supported on Windows. But for Unix only `FILE_FLAG_WRITE_THROUGH` is supported [here](https://github.com/dotnet/coreclr/blob/75e62c545ac5c7195bf846b47e28c4f27736d64c/src/System.Private.CoreLib/shared/System/IO/FileStream.Unix.cs#L183).

I know the limitations on alignment and complexity. But the use case is for simple write-ahead log when I append buffers of a multiple of 512 bytes. If I open `FileStream` with e.g. `buffersize = 1` it works on Windows performance is better and such write is probably safer. Even though docs for WriteThrough say that data hits the disk before write returns maybe there is still some caching is happening at some level.

I have studied public WAL implementations and the two flags are usually enough and what people do. In `FileStream` implementation nothing stops from using this option and I get a nice catchable IO exceptoin on Windows when a buffer is not aligned. This change doesn't require changing public API makes Linux behavior match one on Windows and allows to avoid PITA with P/Invoke implementation.

Required change is trivial add three lines in `PreOpenConfigurationFromOptions` in [`FileStream.Unix.cs`](https://github.com/dotnet/coreclr/blob/75e62c545ac5c7195bf846b47e28c4f27736d64c/src/System.Private.CoreLib/shared/System/IO/FileStream.Unix.cs#L185) and `O_DICRECT` option to [`Interop.Sys.OpenFlags`](https://github.com/dotnet/coreclr/blob/master/src/System.Private.CoreLib/shared/Interop/Unix/System.Native/Interop.OpenFlags.cs):

```
if ((options &amp; (FileOptions)0x20000000) != 0)
{
    flags |= Interop.Sys.OpenFlags.O_DIRECT;
}
```</Description>
    <Title_Description>Add O_DIRECT file open option handling for FileStream.Unix [Here](https://github.com/dotnet/coreclr/blob/75e62c545ac5c7195bf846b47e28c4f27736d64c/src/System.Private.CoreLib/shared/System/IO/FileStream.cs#L204) `NoBuffering`/`FILE_FLAG_NO_BUFFERING` flag is hidden but supported on Windows. But for Unix only `FILE_FLAG_WRITE_THROUGH` is supported [here](https://github.com/dotnet/coreclr/blob/75e62c545ac5c7195bf846b47e28c4f27736d64c/src/System.Private.CoreLib/shared/System/IO/FileStream.Unix.cs#L183).

I know the limitations on alignment and complexity. But the use case is for simple write-ahead log when I append buffers of a multiple of 512 bytes. If I open `FileStream` with e.g. `buffersize = 1` it works on Windows performance is better and such write is probably safer. Even though docs for WriteThrough say that data hits the disk before write returns maybe there is still some caching is happening at some level.

I have studied public WAL implementations and the two flags are usually enough and what people do. In `FileStream` implementation nothing stops from using this option and I get a nice catchable IO exceptoin on Windows when a buffer is not aligned. This change doesn't require changing public API makes Linux behavior match one on Windows and allows to avoid PITA with P/Invoke implementation.

Required change is trivial add three lines in `PreOpenConfigurationFromOptions` in [`FileStream.Unix.cs`](https://github.com/dotnet/coreclr/blob/75e62c545ac5c7195bf846b47e28c4f27736d64c/src/System.Private.CoreLib/shared/System/IO/FileStream.Unix.cs#L185) and `O_DICRECT` option to [`Interop.Sys.OpenFlags`](https://github.com/dotnet/coreclr/blob/master/src/System.Private.CoreLib/shared/Interop/Unix/System.Native/Interop.OpenFlags.cs):

```
if ((options &amp; (FileOptions)0x20000000) != 0)
{
    flags |= Interop.Sys.OpenFlags.O_DIRECT;
}
```</Title_Description>
    <Label>area-System.IO</Label>
    <Assignee>JeremyKuhne</Assignee>
    <CreatedAt>1/08/2018 12:43:41 PM +00:00</CreatedAt>
    <ClosedAt>2/08/2018 12:20:10 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19204</IssueLabelID>
    <Title>WIndows does not decode EventSource events if they use enums that not based on int or long.</Title>
    <Description>@brianrob 

See the VS bug https://microsoft.visualstudio.com/OS/_workitems/edit/18408493 which is where this issue arose.  I have copied the important part in the next comment in case the link break. </Description>
    <Title_Description>WIndows does not decode EventSource events if they use enums that not based on int or long. @brianrob 

See the VS bug https://microsoft.visualstudio.com/OS/_workitems/edit/18408493 which is where this issue arose.  I have copied the important part in the next comment in case the link break. </Title_Description>
    <Label>area-Tracing</Label>
    <Assignee>vancem</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19203</IssueLabelID>
    <Title>CRT Pow function has bad performance on Windows</Title>
    <Description>During benchmarking AoS/SoA ray-tracer https://github.com/dotnet/coreclr/pull/18839 we found that the `Vector3` benchmark ([RayTracer](https://github.com/dotnet/coreclr/tree/master/tests/src/JIT/Performance/CodeQuality/SIMD/RayTracer)) is much slower on Windows than Linux.

|      Execution time     |    Windows    |    Linux    |
|:-----------------------:|:-----------------------:|:---------------------:|
|      Baseline ([RayTracer](https://github.com/dotnet/coreclr/tree/master/tests/src/JIT/Performance/CodeQuality/SIMD/RayTracer) )     |          6.00s          |         4.13s         |
|      PacketTracer     |          1.20s          |         1.35s         |
|    Performance Gains    |          5.00x          |         3.06x         |

According to VTune analysis this gap is caused by the CRT math library which RayTracer uses `Math.Pow` at https://github.com/dotnet/coreclr/blob/master/tests/src/JIT/Performance/CodeQuality/SIMD/RayTracer/Raytracer.cs#L153

### Windows
![image](https://user-images.githubusercontent.com/1263030/43163298-9d34bf94-8f42-11e8-8111-82c5dd8329ef.png)
### Linux
![image](https://user-images.githubusercontent.com/1263030/43163360-b86972b4-8f42-11e8-810b-3652ec5c20fe.png)

On the left side (AoS means [RayTracer](https://github.com/dotnet/coreclr/tree/master/tests/src/JIT/Performance/CodeQuality/SIMD/RayTracer)) we can see `ucrtbase.dll` on Windows has much more time consuming and instruction retired than `libm-2.23.so` on Linux.

The data is collected on Core i9 + VS2017 but Core i7+ VS2015 has the same performance gap.</Description>
    <Title_Description>CRT Pow function has bad performance on Windows During benchmarking AoS/SoA ray-tracer https://github.com/dotnet/coreclr/pull/18839 we found that the `Vector3` benchmark ([RayTracer](https://github.com/dotnet/coreclr/tree/master/tests/src/JIT/Performance/CodeQuality/SIMD/RayTracer)) is much slower on Windows than Linux.

|      Execution time     |    Windows    |    Linux    |
|:-----------------------:|:-----------------------:|:---------------------:|
|      Baseline ([RayTracer](https://github.com/dotnet/coreclr/tree/master/tests/src/JIT/Performance/CodeQuality/SIMD/RayTracer) )     |          6.00s          |         4.13s         |
|      PacketTracer     |          1.20s          |         1.35s         |
|    Performance Gains    |          5.00x          |         3.06x         |

According to VTune analysis this gap is caused by the CRT math library which RayTracer uses `Math.Pow` at https://github.com/dotnet/coreclr/blob/master/tests/src/JIT/Performance/CodeQuality/SIMD/RayTracer/Raytracer.cs#L153

### Windows
![image](https://user-images.githubusercontent.com/1263030/43163298-9d34bf94-8f42-11e8-8111-82c5dd8329ef.png)
### Linux
![image](https://user-images.githubusercontent.com/1263030/43163360-b86972b4-8f42-11e8-810b-3652ec5c20fe.png)

On the left side (AoS means [RayTracer](https://github.com/dotnet/coreclr/tree/master/tests/src/JIT/Performance/CodeQuality/SIMD/RayTracer)) we can see `ucrtbase.dll` on Windows has much more time consuming and instruction retired than `libm-2.23.so` on Linux.

The data is collected on Core i9 + VS2017 but Core i7+ VS2015 has the same performance gap.</Title_Description>
    <Label>area-System.Runtime</Label>
    <Assignee>fiigii</Assignee>
    <CreatedAt>30/07/2018 8:34:38 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19201</IssueLabelID>
    <Title>Enable Tiered Compilation by default</Title>
    <Description>1) Changes the default state of the tiered compilation feature check to be ON BY DEFAULT
2) Removed comments about the source about this being a work in progress. Although it will surely continue to evolve and improve remaining issues would be better tracked in our issue tracking system with the same default presumption as other runtime features - assume it works unless noted otherwise.
3) Adjusts a number of tests and automated scripts that made assumptions that the default setting of this feature is off.
4) Stop accepting the deprecated env var COMPLUS_EXPERIMENTAL_TieredCompilation. I'm not aware it has any remaining usage but if so we're going to find out.</Description>
    <Title_Description>Enable Tiered Compilation by default 1) Changes the default state of the tiered compilation feature check to be ON BY DEFAULT
2) Removed comments about the source about this being a work in progress. Although it will surely continue to evolve and improve remaining issues would be better tracked in our issue tracking system with the same default presumption as other runtime features - assume it works unless noted otherwise.
3) Adjusts a number of tests and automated scripts that made assumptions that the default setting of this feature is off.
4) Stop accepting the deprecated env var COMPLUS_EXPERIMENTAL_TieredCompilation. I'm not aware it has any remaining usage but if so we're going to find out.</Title_Description>
    <Label>area-VM</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19199</IssueLabelID>
    <Title>Why doesn't the EE save volatile registers for profiler function callbacks?</Title>
    <Description>Apologies in advance if this question is particularly ignorant or does not belong here. I browsed the repo for things tagged `question` and it didn't seem particularly out of order to raise an issue for clarification.

As [corprof.idl](https://github.com/dotnet/coreclr/blob/master/src/inc/corprof.idl) explains for the `FunctionEnter*` `FunctionLeave*` and `FunctionTailcall*` callbacks (set with `ICorProfilerInfo*::SetEnterLeaveFunctionHooks*`):

&gt; It is VERY IMPORTANT to note that these function implementations must be
&gt; __declspec(naked) since the EE is not saving any registers before calling
&gt; any of them.  YOU MUST SAVE ALL REGISTERS YOU USE INCLUDING FPU REGISTERS
&gt; IF THE FPU STACK IS NOT EMPTY AND YOU INTEND TO USE IT.

Alright so... *why* does the EE not save any registers (as opposed to following the platform ABI rules for volatiles)? This mostly leads to profilers doing a predictable [register saving dance](https://github.com/Microsoft/clr-samples/blob/master/ProfilingAPI/ELTProfiler/CorProfiler.cpp#L27) before invoking another function the regular way. This is nasty since it requires some platform-specific assembler that's not covered by intrinsics (the alternative being [IL rewriting](https://github.com/Microsoft/clr-samples/blob/master/ProfilingAPI/ReJITEnterLeaveHooks/CorProfiler.cpp) of any and all methods you want to instrument which has its own issues).

What's the design or implementation rationale behind this? Speed? But if every profiler has to save registers anyway (practically speaking assuming not too many are written in raw asm) where would those savings come in? If no hook is set surely the EE could just invoke a stub that literally does nothing (as I believe it already does) while if a hook *is* set it can call a stub to save the volatiles before the profiler proper removing this burden from profilers?

This requirement gets onerous as you're going cross-platform as #18977 illustrates but I'm just interested in why this is (or was deemed) necessary/expedient in the first place.</Description>
    <Title_Description>Why doesn't the EE save volatile registers for profiler function callbacks? Apologies in advance if this question is particularly ignorant or does not belong here. I browsed the repo for things tagged `question` and it didn't seem particularly out of order to raise an issue for clarification.

As [corprof.idl](https://github.com/dotnet/coreclr/blob/master/src/inc/corprof.idl) explains for the `FunctionEnter*` `FunctionLeave*` and `FunctionTailcall*` callbacks (set with `ICorProfilerInfo*::SetEnterLeaveFunctionHooks*`):

&gt; It is VERY IMPORTANT to note that these function implementations must be
&gt; __declspec(naked) since the EE is not saving any registers before calling
&gt; any of them.  YOU MUST SAVE ALL REGISTERS YOU USE INCLUDING FPU REGISTERS
&gt; IF THE FPU STACK IS NOT EMPTY AND YOU INTEND TO USE IT.

Alright so... *why* does the EE not save any registers (as opposed to following the platform ABI rules for volatiles)? This mostly leads to profilers doing a predictable [register saving dance](https://github.com/Microsoft/clr-samples/blob/master/ProfilingAPI/ELTProfiler/CorProfiler.cpp#L27) before invoking another function the regular way. This is nasty since it requires some platform-specific assembler that's not covered by intrinsics (the alternative being [IL rewriting](https://github.com/Microsoft/clr-samples/blob/master/ProfilingAPI/ReJITEnterLeaveHooks/CorProfiler.cpp) of any and all methods you want to instrument which has its own issues).

What's the design or implementation rationale behind this? Speed? But if every profiler has to save registers anyway (practically speaking assuming not too many are written in raw asm) where would those savings come in? If no hook is set surely the EE could just invoke a stub that literally does nothing (as I believe it already does) while if a hook *is* set it can call a stub to save the volatiles before the profiler proper removing this burden from profilers?

This requirement gets onerous as you're going cross-platform as #18977 illustrates but I'm just interested in why this is (or was deemed) necessary/expedient in the first place.</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>30/07/2018 7:02:27 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19198</IssueLabelID>
    <Title>Add prefix to DAC's PAL exports for alpine</Title>
    <Description>Added some cmake logic to create assembly include mapping files. One that maps the
prefixed name (DAC_foo) to the actual name (foo) which is included in the DAC module
and another that maps the actual name to the prefixed name that is included in the SOS
DBI and createdump modules.

The data exports like IID_IUnknown are not prefixed and don't need to be (immutable static data).

There were some C++ exports functions exported with their decorated names in
the CatchHardwareExceptionHolder and NativeExceptionHolderBase classes. Created
PAL_* style export functions that implements the code.

Fix lldb plugin cmake file to use LLDB_H/LLDB_LIB env vars to build it.</Description>
    <Title_Description>Add prefix to DAC's PAL exports for alpine Added some cmake logic to create assembly include mapping files. One that maps the
prefixed name (DAC_foo) to the actual name (foo) which is included in the DAC module
and another that maps the actual name to the prefixed name that is included in the SOS
DBI and createdump modules.

The data exports like IID_IUnknown are not prefixed and don't need to be (immutable static data).

There were some C++ exports functions exported with their decorated names in
the CatchHardwareExceptionHolder and NativeExceptionHolderBase classes. Created
PAL_* style export functions that implements the code.

Fix lldb plugin cmake file to use LLDB_H/LLDB_LIB env vars to build it.</Title_Description>
    <Label>
    </Label>
    <Assignee>mikem8361</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19197</IssueLabelID>
    <Title>[JITMinOpts=1] CoreFX System.Numerics.Vectors.Tests (Vector3EqualsTest) crashes under minopts</Title>
    <Description>The test crashes on Windows and Unix under JITMinOpts=1 or TieredCompilation=1. Stack:

```
 # Child-SP          RetAddr           Call Site
00 00000073`4fb79240 00007ff8`9c3b7779 coreclr!EEPolicy::HandleFatalError+0x7a [e:\a\_work\41\s\src\vm\eepolicy.cpp @ 1522] 
01 00000073`4fb79840 00007ff8`e3d3eced coreclr!ProcessCLRException+0x1203f9 [e:\a\_work\41\s\src\vm\exceptionhandling.cpp @ 1029] 
02 00000073`4fb79980 00007ff8`e3ca6c86 ntdll!RtlpExecuteHandlerForException+0xd [minkernel\ntos\rtl\amd64\xcptmisc.asm @ 131] 
03 00000073`4fb799b0 00007ff8`e3ca52ca ntdll!RtlDispatchException+0x3c6 [minkernel\ntos\rtl\amd64\exdsptch.c @ 569] 
04 00000073`4fb7a0b0 00007ff8`e0dca388 ntdll!RtlRaiseException+0x31a [minkernel\ntos\rtl\amd64\raise.c @ 178] 
05 00000073`4fb7a910 00007ff8`9c333369 KERNELBASE!RaiseException+0x68 [minkernel\kernelbase\xcpt.c @ 922] 
06 00000073`4fb7a9f0 00007ff8`9c33339b coreclr!NakedThrowHelper2+0x9 [E:\A\_work\41\s\src\vm\amd64\RedirectedHandledJITCase.asm @ 229] 
07 00000073`4fb7aa20 00007ff8`9c3333a5 coreclr!NakedThrowHelper_RspAligned+0x1e [E:\A\_work\41\s\src\vm\amd64\RedirectedHandledJITCase.asm @ 233] 
08 00000073`4fb7af48 00007ff8`3cca5377 coreclr!NakedThrowHelper_FixRsp+0x5 [E:\A\_work\41\s\src\vm\amd64\RedirectedHandledJITCase.asm @ 233] 
09 00000073`4fb7af50 00007ff8`9c333753 System_Numerics_Vectors_Tests!System.Numerics.Tests.Vector3Tests.Vector3EqualsTest()+0xc7
0a 00000073`4fb7afd0 00007ff8`9c2be7fa coreclr!CallDescrWorkerInternal+0x83 [E:\A\_work\41\s\src\vm\amd64\CallDescrWorkerAMD64.asm @ 101] 
0b 00000073`4fb7b010 00007ff8`9c2be33b coreclr!CallDescrWorkerReflectionWrapper+0x1a [e:\a\_work\41\s\src\vm\reflectioninvocation.cpp @ 667] 
0c 00000073`4fb7b060 00007ff8`8b03b6f1 coreclr!RuntimeMethodHandle::InvokeMethod+0x4eb [e:\a\_work\41\s\src\vm\reflectioninvocation.cpp @ 1300] 
0d 00000073`4fb7b6e0 00007ff8`8b006292 System_Private_CoreLib!System.Reflection.RuntimeMethodInfo.Invoke(System.Object System.Reflection.BindingFlags System.Reflection.Binder System.Object[] System.Globalization.CultureInfo)+0xb1
0e 00000073`4fb7b750 00007ff8`3cb2b5e9 System_Private_CoreLib!System.Reflection.MethodBase.Invoke(System.Object System.Object[])+0x22
0f 00000073`4fb7b790 00007ff8`3cb2b262 xunit_execution_dotnet!Xunit.Sdk.TestInvoker`1[[System.__Canon System.Private.CoreLib]].CallTestMethod(System.Object)+0x49 [C:\BuildAgent\work\cb37e9acf085d108\src\xunit.execution\Sdk\Frameworks\Runners\TestInvoker.cs @ 147] 
10 00000073`4fb7b7d0 00007ff8`3cb2abfd xunit_execution_dotnet!Xunit.Sdk.TestInvoker`1+&lt;&gt;c__DisplayClass46_1+&lt;&lt;InvokeTestMethodAsync&gt;b__1&gt;d[[System.__Canon System.Private.CoreLib]].MoveNext()+0x562 [C:\BuildAgent\work\cb37e9acf085d108\src\xunit.execution\Sdk\Frameworks\Runners\TestInvoker.cs @ 224] 
11 00000073`4fb7b9f0 00007ff8`3cb2aaf1 System_Private_CoreLib!System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[System.IO.TextWriter+&lt;&lt;WriteAsync&gt;g__WriteAsyncCore|59_0&gt;d System.Private.CoreLib]](&lt;&lt;WriteAsync&gt;g__WriteAsyncCore|59_0&gt;d ByRef)+0xffffffff`b1a924cd
12 00000073`4fb7baa0 00007ff8`3cb2aa63 System_Private_CoreLib!System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[System.__Canon System.Private.CoreLib]](System.__Canon ByRef)+0xffffffff`b19adda1
13 00000073`4fb7bae0 00007ff8`3cb2a7f0 xunit_execution_dotnet!Xunit.Sdk.TestInvoker`1+&lt;&gt;c__DisplayClass46_1[[System.__Canon System.Private.CoreLib]].&lt;InvokeTestMethodAsync&gt;b__1()+0xa3
14 00000073`4fb7bb70 00007ff8`3cb2a68c xunit_execution_dotnet!Xunit.Sdk.ExecutionTimer+&lt;AggregateAsync&gt;d__4.MoveNext()+0x70 [C:\BuildAgent\work\cb37e9acf085d108\src\xunit.execution\Sdk\Frameworks\ExecutionTimer.cs @ 48] 
15 00000073`4fb7bc00 00007ff8`3cb2a5d7 System_Private_CoreLib!System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[System.IO.TextWriter+&lt;&lt;WriteAsync&gt;g__WriteAsyncCore|59_0&gt;d System.Private.CoreLib]](&lt;&lt;WriteAsync&gt;g__WriteAsyncCore|59_0&gt;d ByRef)+0xffffffff`b1a91f5c
16 00000073`4fb7bc90 00007ff8`3cb2a58c System_Private_CoreLib!System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[System.__Canon System.Private.CoreLib]](System.__Canon ByRef)+0xffffffff`b19ad887
17 00000073`4fb7bcc0 00007ff8`3cb2a4f5 xunit_execution_dotnet!Xunit.Sdk.ExecutionTimer.AggregateAsync(System.Func`1&lt;System.Threading.Tasks.Task&gt;)+0x6c
18 00000073`4fb7bd40 00007ff8`3cb29e87 xunit_execution_dotnet!Xunit.Sdk.TestInvoker`1+&lt;&gt;c__DisplayClass46_1[[System.__Canon System.Private.CoreLib]].&lt;InvokeTestMethodAsync&gt;b__0()+0xb5 [C:\BuildAgent\work\cb37e9acf085d108\src\xunit.execution\Sdk\Frameworks\Runners\TestInvoker.cs @ 209] 
19 00000073`4fb7bdb0 00007ff8`3cb29d3c xunit_core!Xunit.Sdk.ExceptionAggregator+&lt;RunAsync&gt;d__9.MoveNext()+0x57 [C:\BuildAgent\work\cb37e9acf085d108\src\xunit.core\Sdk\ExceptionAggregator.cs @ 90] 
1a 00000073`4fb7be50 00007ff8`3cb29c87 System_Private_CoreLib!System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[System.IO.TextWriter+&lt;&lt;WriteAsync&gt;g__WriteAsyncCore|59_0&gt;d System.Private.CoreLib]](&lt;&lt;WriteAsync&gt;g__WriteAsyncCore|59_0&gt;d ByRef)+0xffffffff`b1a9160c
1b 00000073`4fb7bee0 00007ff8`3cb29c3c System_Private_CoreLib!System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[System.__Canon System.Private.CoreLib]](System.__Canon ByRef)+0xffffffff`b19acf37
1c 00000073`4fb7bf10 00007ff8`3cb296b9 xunit_core!Xunit.Sdk.ExceptionAggregator.RunAsync(System.Func`1&lt;System.Threading.Tasks.Task&gt;)+0x6c
1d 00000073`4fb7bf80 00007ff8`3cb293ad xunit_execution_dotnet!Xunit.Sdk.TestInvoker`1+&lt;InvokeTestMethodAsync&gt;d__46[[System.__Canon System.Private.CoreLib]].MoveNext()+0x209 [C:\BuildAgent\work\cb37e9acf085d108\src\xunit.execution\Sdk\Frameworks\Runners\TestInvoker.cs @ 208] 
1e 00000073`4fb7c0a0 00007ff8`3cb292a1 System_Private_CoreLib!System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[System.IO.TextWriter+&lt;&lt;WriteAsync&gt;g__WriteAsyncCore|59_0&gt;d System.Private.CoreLib]](&lt;&lt;WriteAsync&gt;g__WriteAsyncCore|59_0&gt;d ByRef)+0xffffffff`b1a90c7d
1f 00000073`4fb7c150 00007ff8`3cb29213 System_Private_CoreLib!System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.__Canon System.Private.CoreLib]].Start[[System.CommonlyUsedGenericInstantiations+&lt;AsyncHelper2&gt;d__4`1[[System.__Canon System.Private.CoreLib]] System.Private.CoreLib]](&lt;AsyncHelper2&gt;d__4`1&lt;System.__Canon&gt; ByRef)+0xffffffff`b19bd3a1
20 00000073`4fb7c190 00007ff8`3cb27a38 xunit_execution_dotnet!Xunit.Sdk.TestInvoker`1[[System.__Canon System.Private.CoreLib]].InvokeTestMethodAsync(System.Object)+0xb3
21 00000073`4fb7c220 00007ff8`3cb274ed xunit_execution_dotnet!Xunit.Sdk.TestInvoker`1+&lt;&lt;RunAsync&gt;b__45_0&gt;d[[System.__Canon System.Private.CoreLib]].MoveNext()+0x448 [C:\BuildAgent\work\cb37e9acf085d108\src\xunit.execution\Sdk\Frameworks\Runners\TestInvoker.cs @ 173] 
22 00000073`4fb7c3b0 00007ff8`3cb273e1 System_Private_CoreLib!System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[System.IO.TextWriter+&lt;&lt;WriteAsync&gt;g__WriteAsyncCore|59_0&gt;d System.Private.CoreLib]](&lt;&lt;WriteAsync&gt;g__WriteAsyncCore|59_0&gt;d ByRef)+0xffffffff`b1a8edbd
23 00000073`4fb7c460 00007ff8`3cb27356 System_Private_CoreLib!System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.__Canon System.Private.CoreLib]].Start[[System.CommonlyUsedGenericInstantiations+&lt;AsyncHelper2&gt;d__4`1[[System.__Canon System.Private.CoreLib]] System.Private.CoreLib]](&lt;AsyncHelper2&gt;d__4`1&lt;System.__Canon&gt; ByRef)+0xffffffff`b19bb4e1
24 00000073`4fb7c4a0 00007ff8`3cb270ad xunit_execution_dotnet!Xunit.Sdk.TestInvoker`1[[System.__Canon System.Private.CoreLib]].&lt;RunAsync&gt;b__45_0()+0xa6
25 00000073`4fb7c540 00007ff8`3cb26f4c xunit_core!Xunit.Sdk.ExceptionAggregator+&lt;RunAsync&gt;d__10`1[[System.__Canon System.Private.CoreLib]].MoveNext()+0x1dbd [C:\BuildAgent\work\cb37e9acf085d108\src\xunit.core\Sdk\TraitDiscoverer.cs @ 16] 
26 00000073`4fb7c610 00007ff8`3cb26e97 System_Private_CoreLib!System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[System.IO.TextWriter+&lt;&lt;WriteAsync&gt;g__WriteAsyncCore|59_0&gt;d System.Private.CoreLib]](&lt;&lt;WriteAsync&gt;g__WriteAsyncCore|59_0&gt;d ByRef)+0xffffffff`b1a8e81c
27 00000073`4fb7c6a0 00007ff8`3cb26e0c System_Private_CoreLib!System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.__Canon System.Private.CoreLib]].Start[[System.CommonlyUsedGenericInstantiations+&lt;AsyncHelper2&gt;d__4`1[[System.__Canon System.Private.CoreLib]] System.Private.CoreLib]](&lt;AsyncHelper2&gt;d__4`1&lt;System.__Canon&gt; ByRef)+0xffffffff`b19baf97
28 00000073`4fb7c6d0 00007ff8`3cb26d4e xunit_core!Xunit.Sdk.ExceptionAggregator.RunAsync[[System.Decimal System.Private.CoreLib]](System.Func`1&lt;System.Threading.Tasks.Task`1&lt;System.Decimal&gt;&gt;)+0x6c
29 00000073`4fb7c740 00007ff8`3cb262ac xunit_execution_dotnet!Xunit.Sdk.TestInvoker`1[[System.__Canon System.Private.CoreLib]].RunAsync()+0x5e [C:\BuildAgent\work\cb37e9acf085d108\src\xunit.execution\Sdk\Frameworks\Runners\TestInvoker.cs @ 156] 
2a 00000073`4fb7c780 00007ff8`3cb25f74 xunit_execution_dotnet!Xunit.Sdk.XunitTestRunner.InvokeTestMethodAsync(Xunit.Sdk.ExceptionAggregator)+0xfc [C:\BuildAgent\work\cb37e9acf085d108\src\xunit.execution\Sdk\Frameworks\Runners\XunitTestRunner.cs @ 84] 
2b 00000073`4fb7c840 00007ff8`3cb25d0c xunit_execution_dotnet!Xunit.Sdk.XunitTestRunner+&lt;InvokeTestAsync&gt;d__4.MoveNext()+0x174 [C:\BuildAgent\work\cb37e9acf085d108\src\xunit.execution\Sdk\Frameworks\Runners\XunitTestRunner.cs @ 67] 
2c 00000073`4fb7c930 00007ff8`3cb25c57 System_Private_CoreLib!System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[System.IO.TextWriter+&lt;&lt;WriteAsync&gt;g__WriteAsyncCore|59_0&gt;d System.Private.CoreLib]](&lt;&lt;WriteAsync&gt;g__WriteAsyncCore|59_0&gt;d ByRef)+0xffffffff`b1a8d5dc
2d 00000073`4fb7c9c0 00007ff8`3cb25c00 System_Private_CoreLib!System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.__Canon System.Private.CoreLib]].Start[[System.CommonlyUsedGenericInstantiations+&lt;AsyncHelper2&gt;d__4`1[[System.__Canon System.Private.CoreLib]] System.Private.CoreLib]](&lt;AsyncHelper2&gt;d__4`1&lt;System.__Canon&gt; ByRef)+0xffffffff`b19b9d57
2e 00000073`4fb7c9f0 00007ff8`3cb25b5a xunit_execution_dotnet!Xunit.Sdk.XunitTestRunner.InvokeTestAsync(Xunit.Sdk.ExceptionAggregator)+0x80
2f 00000073`4fb7ca70 00007ff8`3cb25362 xunit_execution_dotnet!Xunit.Sdk.TestRunner`1+&lt;&gt;c__DisplayClass43_0[[System.__Canon System.Private.CoreLib]].&lt;RunAsync&gt;b__0()+0x3a [C:\BuildAgent\work\cb37e9acf085d108\src\xunit.execution\Sdk\Frameworks\Runners\TestRunner.cs @ 149] 
30 00000073`4fb7cab0 00007ff8`3cb2488d xunit_core!Xunit.Sdk.ExceptionAggregator+&lt;RunAsync&gt;d__10`1[[System.__Canon System.Private.CoreLib]].MoveNext()+0x72 [C:\BuildAgent\work\cb37e9acf085d108\src\xunit.core\Sdk\ExceptionAggregator.cs @ 107] 
31 00000073`4fb7cbb0 00007ff8`3cb24641 System_Private_CoreLib!System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[System.IO.TextWriter+&lt;&lt;WriteAsync&gt;g__WriteAsyncCore|59_0&gt;d System.Private.CoreLib]](&lt;&lt;WriteAsync&gt;g__WriteAsyncCore|59_0&gt;d ByRef)+0xffffffff`b1a8c15d
32 00000073`4fb7cc60 00007ff8`3cb2448b System_Private_CoreLib!System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.__Canon System.Private.CoreLib]].Start[[System.CommonlyUsedGenericInstantiations+&lt;AsyncHelper2&gt;d__4`1[[System.__Canon System.Private.CoreLib]] System.Private.CoreLib]](&lt;AsyncHelper2&gt;d__4`1&lt;System.__Canon&gt; ByRef)+0xffffffff`b19b8741
33 00000073`4fb7cca0 00007ff8`3cb23866 xunit_core!Xunit.Sdk.ExceptionAggregator.RunAsync[[System.Decimal System.Private.CoreLib]](System.Func`1&lt;System.Threading.Tasks.Task`1&lt;System.Decimal&gt;&gt;)+0xffffffff`ffffd6eb
34 00000073`4fb7cd30 00007ff8`3cb22fad xunit_execution_dotnet!Xunit.Sdk.TestRunner`1+&lt;RunAsync&gt;d__43[[System.__Canon System.Private.CoreLib]].MoveNext()+0x3b6 [C:\BuildAgent\work\cb37e9acf085d108\src\xunit.execution\Sdk\Frameworks\Runners\TestRunner.cs @ 149] 
35 00000073`4fb7cf30 00007ff8`3cb22ea1 System_Private_CoreLib!System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[System.IO.TextWriter+&lt;&lt;WriteAsync&gt;g__WriteAsyncCore|59_0&gt;d System.Private.CoreLib]](&lt;&lt;WriteAsync&gt;g__WriteAsyncCore|59_0&gt;d ByRef)+0xffffffff`b1a8a87d
36 00000073`4fb7cfe0 00007ff8`3cb22e0d System_Private_CoreLib!System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.__Canon System.Private.CoreLib]].Start[[System.CommonlyUsedGenericInstantiations+&lt;AsyncHelper2&gt;d__4`1[[System.__Canon System.Private.CoreLib]] System.Private.CoreLib]](&lt;AsyncHelper2&gt;d__4`1&lt;System.__Canon&gt; ByRef)+0xffffffff`b19b6fa1
37 00000073`4fb7d020 00007ff8`3cb225fb xunit_execution_dotnet!Xunit.Sdk.TestRunner`1[[System.__Canon System.Private.CoreLib]].RunAsync()+0xad
38 00000073`4fb7d0b0 00007ff8`3cb21a04 xunit_execution_dotnet!Xunit.Sdk.XunitTestCaseRunner.RunTestAsync()+0x16b [C:\BuildAgent\work\cb37e9acf085d108\src\xunit.execution\Sdk\Frameworks\Runners\XunitTestCaseRunner.cs @ 106] 
39 00000073`4fb7d1a0 00007ff8`3cb2169d xunit_execution_dotnet!Xunit.Sdk.TestCaseRunner`1+&lt;RunAsync&gt;d__19[[System.__Canon System.Private.CoreLib]].MoveNext()+0x264 [C:\BuildAgent\work\cb37e9acf085d108\src\xunit.execution\Sdk\Frameworks\Runners\TestCaseRunner.cs @ 82] 
3a 00000073`4fb7d310 00007ff8`3cb21591 System_Private_CoreLib!System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[System.IO.TextWriter+&lt;&lt;WriteAsync&gt;g__WriteAsyncCore|59_0&gt;d System.Private.CoreLib]](&lt;&lt;WriteAsync&gt;g__WriteAsyncCore|59_0&gt;d ByRef)+0xffffffff`b1a88f6d
3b 00000073`4fb7d3c0 00007ff8`3cb214fd System_Private_CoreLib!System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.__Canon System.Private.CoreLib]].Start[[System.CommonlyUsedGenericInstantiations+&lt;AsyncHelper2&gt;d__4`1[[System.__Canon System.Private.CoreLib]] System.Private.CoreLib]](&lt;AsyncHelper2&gt;d__4`1&lt;System.__Canon&gt; ByRef)+0xffffffff`b19b5691
3c 00000073`4fb7d400 00007ff8`3cb20223 xunit_execution_dotnet!Xunit.Sdk.TestCaseRunner`1[[System.__Canon System.Private.CoreLib]].RunAsync()+0xad
3d 00000073`4fb7d490 00007ff8`3cb200ea xunit_execution_dotnet!Xunit.Sdk.XunitTestCase.RunAsync(Xunit.Abstractions.IMessageSink Xunit.Sdk.IMessageBus System.Object[] Xunit.Sdk.ExceptionAggregator System.Threading.CancellationTokenSource)+0xb3 [C:\BuildAgent\work\cb37e9acf085d108\src\xunit.execution\Sdk\Frameworks\XunitTestCase.cs @ 106] 
3e 00000073`4fb7d520 00007ff8`3cb1fd85 xunit_execution_dotnet!Xunit.Sdk.XunitTestMethodRunner.RunTestCaseAsync(Xunit.Sdk.IXunitTestCase)+0xba [C:\BuildAgent\work\cb37e9acf085d108\src\xunit.execution\Sdk\Frameworks\Runners\XunitTestMethodRunner.cs @ 45] 
3f 00000073`4fb7d5a0 00007ff8`3cb1fafd xunit_execution_dotnet!Xunit.Sdk.TestMethodRunner`1+&lt;RunTestCasesAsync&gt;d__32[[System.__Canon System.Private.CoreLib]].MoveNext()+0x185 [C:\BuildAgent\work\cb37e9acf085d108\src\xunit.execution\Sdk\Frameworks\Runners\TestMethodRunner.cs @ 136] 
40 00000073`4fb7d680 00007ff8`3cb1f9f1 System_Private_CoreLib!System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[System.IO.TextWriter+&lt;&lt;WriteAsync&gt;g__WriteAsyncCore|59_0&gt;d System.Private.CoreLib]](&lt;&lt;WriteAsync&gt;g__WriteAsyncCore|59_0&gt;d ByRef)+0xffffffff`b1a873cd
41 00000073`4fb7d730 00007ff8`3cb1f960 System_Private_CoreLib!System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.__Canon System.Private.CoreLib]].Start[[System.CommonlyUsedGenericInstantiations+&lt;AsyncHelper2&gt;d__4`1[[System.__Canon System.Private.CoreLib]] System.Private.CoreLib]](&lt;AsyncHelper2&gt;d__4`1&lt;System.__Canon&gt; ByRef)+0xffffffff`b19b3af1
42 00000073`4fb7d770 00007ff8`3cb1ee1b xunit_execution_dotnet!Xunit.Sdk.TestMethodRunner`1[[System.__Canon System.Private.CoreLib]].RunTestCasesAsync()+0xb0
43 00000073`4fb7d810 00007ff8`3cb1eb6d xunit_execution_dotnet!Xunit.Sdk.TestMethodRunner`1+&lt;RunAsync&gt;d__31[[System.__Canon System.Private.CoreLib]].MoveNext()+0x1ab [C:\BuildAgent\work\cb37e9acf085d108\src\xunit.execution\Sdk\Frameworks\Runners\TestMethodRunner.cs @ 106] 
44 00000073`4fb7d980 00007ff8`3cb1ea61 System_Private_CoreLib!System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[System.IO.TextWriter+&lt;&lt;WriteAsync&gt;g__WriteAsyncCore|59_0&gt;d System.Private.CoreLib]](&lt;&lt;WriteAsync&gt;g__WriteAsyncCore|59_0&gt;d ByRef)+0xffffffff`b1a8643d
45 00000073`4fb7da30 00007ff8`3cb1e9cd System_Private_CoreLib!System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.__Canon System.Private.CoreLib]].Start[[System.CommonlyUsedGenericInstantiations+&lt;AsyncHelper2&gt;d__4`1[[System.__Canon System.Private.CoreLib]] System.Private.CoreLib]](&lt;AsyncHelper2&gt;d__4`1&lt;System.__Canon&gt; ByRef)+0xffffffff`b19b2b61
46 00000073`4fb7da70 00007ff8`3cb1e56d xunit_execution_dotnet!Xunit.Sdk.TestMethodRunner`1[[System.__Canon System.Private.CoreLib]].RunAsync()+0xad
47 00000073`4fb7db00 00007ff8`3cb1ae30 xunit_execution_dotnet!Xunit.Sdk.XunitTestClassRunner.RunTestMethodAsync(Xunit.Abstractions.ITestMethod Xunit.Abstractions.IReflectionMethodInfo System.Collections.Generic.IEnumerable`1&lt;Xunit.Sdk.IXunitTestCase&gt; System.Object[])+0xfd [C:\BuildAgent\work\cb37e9acf085d108\src\xunit.execution\Sdk\Frameworks\Runners\XunitTestClassRunner.cs @ 152] 
48 00000073`4fb7dbb0 00007ff8`3cb1a87d xunit_execution_dotnet!Xunit.Sdk.TestClassRunner`1+&lt;RunTestMethodsAsync&gt;d__38[[System.__Canon System.Private.CoreLib]].MoveNext()+0x4b0 [C:\BuildAgent\work\cb37e9acf085d108\src\xunit.execution\Sdk\Frameworks\Runners\TestClassRunner.cs @ 205] 
49 00000073`4fb7ddb0 00007ff8`3cb1a361 System_Private_CoreLib!System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[System.IO.TextWriter+&lt;&lt;WriteAsync&gt;g__WriteAsyncCore|59_0&gt;d System.Private.CoreLib]](&lt;&lt;WriteAsync&gt;g__WriteAsyncCore|59_0&gt;d ByRef)+0xffffffff`b1a8214d
4a 00000073`4fb7de60 00007ff8`3cb1a2d0 System_Private_CoreLib!System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.__Canon System.Private.CoreLib]].Start[[System.CommonlyUsedGenericInstantiations+&lt;AsyncHelper2&gt;d__4`1[[System.__Canon System.Private.CoreLib]] System.Private.CoreLib]](&lt;AsyncHelper2&gt;d__4`1&lt;System.__Canon&gt; ByRef)+0xffffffff`b19ae461
4b 00000073`4fb7dea0 00007ff8`3cb17fb6 xunit_execution_dotnet!Xunit.Sdk.TestClassRunner`1[[System.__Canon System.Private.CoreLib]].RunTestMethodsAsync()+0xb0
4c 00000073`4fb7df40 00007ff8`3cb17c1d xunit_execution_dotnet!Xunit.Sdk.TestClassRunner`1+&lt;RunAsync&gt;d__37[[System.__Canon System.Private.CoreLib]].MoveNext()+0x296 [C:\BuildAgent\work\cb37e9acf085d108\src\xunit.execution\Sdk\Frameworks\Runners\TestClassRunner.cs @ 163] 
4d 00000073`4fb7e0f0 00007ff8`3cb17b11 System_Private_CoreLib!System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[System.IO.TextWriter+&lt;&lt;WriteAsync&gt;g__WriteAsyncCore|59_0&gt;d System.Private.CoreLib]](&lt;&lt;WriteAsync&gt;g__WriteAsyncCore|59_0&gt;d ByRef)+0xffffffff`b1a7f4ed
4e 00000073`4fb7e1a0 00007ff8`3cb17a7d System_Private_CoreLib!System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.__Canon System.Private.CoreLib]].Start[[System.CommonlyUsedGenericInstantiations+&lt;AsyncHelper2&gt;d__4`1[[System.__Canon System.Private.CoreLib]] System.Private.CoreLib]](&lt;AsyncHelper2&gt;d__4`1&lt;System.__Canon&gt; ByRef)+0xffffffff`b19abc11
4f 00000073`4fb7e1e0 00007ff8`3cb175a9 xunit_execution_dotnet!Xunit.Sdk.TestClassRunner`1[[System.__Canon System.Private.CoreLib]].RunAsync()+0xad
50 00000073`4fb7e270 00007ff8`3cb16b1a xunit_execution_dotnet!Xunit.Sdk.XunitTestCollectionRunner.RunTestClassAsync(Xunit.Abstractions.ITestClass Xunit.Abstractions.IReflectionTypeInfo System.Collections.Generic.IEnumerable`1&lt;Xunit.Sdk.IXunitTestCase&gt;)+0x109 [C:\BuildAgent\work\cb37e9acf085d108\src\xunit.execution\Sdk\Frameworks\Runners\XunitTestCollectionRunner.cs @ 124] 
51 00000073`4fb7e320 00007ff8`3cb1662d xunit_execution_dotnet!Xunit.Sdk.TestCollectionRunner`1+&lt;RunTestClassesAsync&gt;d__28[[System.__Canon System.Private.CoreLib]].MoveNext()+0x3ea [C:\BuildAgent\work\cb37e9acf085d108\src\xunit.execution\Sdk\Frameworks\Runners\TestCollectionRunner.cs @ 130] 
52 00000073`4fb7e490 00007ff8`3cb16521 System_Private_CoreLib!System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[System.IO.TextWriter+&lt;&lt;WriteAsync&gt;g__WriteAsyncCore|59_0&gt;d System.Private.CoreLib]](&lt;&lt;WriteAsync&gt;g__WriteAsyncCore|59_0&gt;d ByRef)+0xffffffff`b1a7defd
53 00000073`4fb7e540 00007ff8`3cb16490 System_Private_CoreLib!System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.__Canon System.Private.CoreLib]].Start[[System.CommonlyUsedGenericInstantiations+&lt;AsyncHelper2&gt;d__4`1[[System.__Canon System.Private.CoreLib]] System.Private.CoreLib]](&lt;AsyncHelper2&gt;d__4`1&lt;System.__Canon&gt; ByRef)+0xffffffff`b19aa621
54 00000073`4fb7e580 00007ff8`3cb13a77 xunit_execution_dotnet!Xunit.Sdk.TestCollectionRunner`1[[System.__Canon System.Private.CoreLib]].RunTestClassesAsync()+0xb0
55 00000073`4fb7e620 00007ff8`3cb12a1d xunit_execution_dotnet!Xunit.Sdk.TestCollectionRunner`1+&lt;RunAsync&gt;d__27[[System.__Canon System.Private.CoreLib]].MoveNext()+0x297 [C:\BuildAgent\work\cb37e9acf085d108\src\xunit.execution\Sdk\Frameworks\Runners\TestCollectionRunner.cs @ 101] 
56 00000073`4fb7e7d0 00007ff8`3cb12911 System_Private_CoreLib!System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[System.IO.TextWriter+&lt;&lt;WriteAsync&gt;g__WriteAsyncCore|59_0&gt;d System.Private.CoreLib]](&lt;&lt;WriteAsync&gt;g__WriteAsyncCore|59_0&gt;d ByRef)+0xffffffff`b1a7a2ed
57 00000073`4fb7e880 00007ff8`3cb1287d System_Private_CoreLib!System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.__Canon System.Private.CoreLib]].Start[[System.CommonlyUsedGenericInstantiations+&lt;AsyncHelper2&gt;d__4`1[[System.__Canon System.Private.CoreLib]] System.Private.CoreLib]](&lt;AsyncHelper2&gt;d__4`1&lt;System.__Canon&gt; ByRef)+0xffffffff`b19a6a11
58 00000073`4fb7e8c0 00007ff8`3cb11f0e xunit_execution_dotnet!Xunit.Sdk.TestCollectionRunner`1[[System.__Canon System.Private.CoreLib]].RunAsync()+0xad
59 00000073`4fb7e950 00007ff8`3cb11e18 xunit_execution_dotnet!Xunit.Sdk.XunitTestAssemblyRunner.RunTestCollectionAsync(Xunit.Sdk.IMessageBus Xunit.Abstractions.ITestCollection System.Collections.Generic.IEnumerable`1&lt;Xunit.Sdk.IXunitTestCase&gt; System.Threading.CancellationTokenSource)+0xce [C:\BuildAgent\work\cb37e9acf085d108\src\xunit.execution\Sdk\Frameworks\Runners\XunitTestAssemblyRunner.cs @ 203] 
5a 00000073`4fb7e9e0 00007ff8`8b0920d9 xunit_execution_dotnet!Xunit.Sdk.XunitTestAssemblyRunner+&lt;&gt;c__DisplayClass14_2.&lt;RunTestCollectionsAsync&gt;b__3()+0x98 [C:\BuildAgent\work\cb37e9acf085d108\src\xunit.execution\Sdk\Frameworks\Runners\XunitTestAssemblyRunner.cs @ 179] 
5b 00000073`4fb7ea50 00007ff8`8afa77d6 System_Private_CoreLib!System.Threading.Tasks.Task`1[[System.__Canon System.Private.CoreLib]].InnerInvoke()+0x49
5c 00000073`4fb7eaa0 00007ff8`8b0634da System_Private_CoreLib!System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext System.Threading.ContextCallback System.Object)+0x86
5d 00000073`4fb7eb20 00007ff8`8b063264 System_Private_CoreLib!System.Threading.Tasks.Task.ExecuteWithThreadLocal(System.Threading.Tasks.Task ByRef)+0x19a
5e 00000073`4fb7ebc0 00007ff8`8b0c7a6b System_Private_CoreLib!System.Threading.Tasks.Task.ExecuteEntry()+0x84
5f 00000073`4fb7ec00 00007ff8`3cb11d4d System_Private_CoreLib!System.Threading.Tasks.SynchronizationContextTaskScheduler+&lt;&gt;c.&lt;.cctor&gt;b__8_0(System.Object)+0x2b
60 00000073`4fb7ec30 00007ff8`3cb11cd6 xunit_execution_dotnet!Xunit.Sdk.MaxConcurrencySyncContext.RunOnSyncContext(System.Threading.SendOrPostCallback System.Object)+0x4d [C:\BuildAgent\work\cb37e9acf085d108\src\xunit.execution\Sdk\MaxConcurrencySyncContext.cs @ 107] 
61 00000073`4fb7ec70 00007ff8`8afa77d6 xunit_execution_dotnet!Xunit.Sdk.MaxConcurrencySyncContext+&lt;&gt;c__DisplayClass11_0.&lt;WorkerThreadProc&gt;b__0(System.Object)+0x66 [C:\BuildAgent\work\cb37e9acf085d108\src\xunit.execution\Sdk\MaxConcurrencySyncContext.cs @ 96] 
62 00000073`4fb7ecd0 00007ff8`3cb9015a System_Private_CoreLib!System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext System.Threading.ContextCallback System.Object)+0x86
63 00000073`4fb7ed50 00007ff8`3cb11c49 DynamicClass.lambda_method(System.Runtime.CompilerServices.Closure System.Object System.Object)+0x5a
64 00000073`4fb7ed90 00007ff8`3cb0d689 xunit_execution_dotnet!Xunit.Sdk.ExecutionContextHelper.Run(System.Object System.Action`1&lt;System.Object&gt;)+0x69 [C:\BuildAgent\work\cb37e9acf085d108\src\xunit.execution\Sdk\Utility\ExecutionContextHelper.cs @ 111] 
65 00000073`4fb7edf0 00007ff8`3c86f7fe xunit_execution_dotnet!Xunit.Sdk.MaxConcurrencySyncContext.WorkerThreadProc()+0x159 [C:\BuildAgent\work\cb37e9acf085d108\src\xunit.execution\Sdk\MaxConcurrencySyncContext.cs @ 85] 
66 00000073`4fb7ee70 00007ff8`8afa77d6 xunit_execution_dotnet!Xunit.Sdk.XunitWorkerThread+&lt;&gt;c.&lt;QueueUserWorkItem&gt;b__5_0(System.Object)+0x4e [C:\BuildAgent\work\cb37e9acf085d108\src\common\XunitWorkerThread.cs @ 37] 
67 00000073`4fb7eec0 00007ff8`8b0634da System_Private_CoreLib!System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext System.Threading.ContextCallback System.Object)+0x86
68 00000073`4fb7ef40 00007ff8`8afa77d6 System_Private_CoreLib!System.Threading.Tasks.Task.ExecuteWithThreadLocal(System.Threading.Tasks.Task ByRef)+0x19a
69 00000073`4fb7efe0 00007ff8`9c333753 System_Private_CoreLib!System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext System.Threading.ContextCallback System.Object)+0x86
6a 00000073`4fb7f060 00007ff8`9c286a79 coreclr!CallDescrWorkerInternal+0x83 [E:\A\_work\41\s\src\vm\amd64\CallDescrWorkerAMD64.asm @ 101] 
6b (Inline Function) --------`-------- coreclr!CallDescrWorkerWithHandler+0x53 [e:\a\_work\41\s\src\vm\callhelpers.cpp @ 78] 
6c 00000073`4fb7f0a0 00007ff8`9c32526a coreclr!MethodDescCallSite::CallTargetWorker+0x2b5 [e:\a\_work\41\s\src\vm\callhelpers.cpp @ 628] 
6d (Inline Function) --------`-------- coreclr!StressLog::InlinedStressLogOn+0x5 [e:\a\_work\41\s\src\utilcode\stresslog.cpp @ 595] 
6e (Inline Function) --------`-------- coreclr!StressLog::LogOn+0x5 [e:\a\_work\41\s\src\utilcode\stresslog.cpp @ 629] 
6f 00000073`4fb7f1f0 00007ff8`9c28652e coreclr!ThreadNative::KickOffThread_Worker+0x13a [e:\a\_work\41\s\src\vm\comsynchronizable.cpp @ 260] 
70 00000073`4fb7f360 00007ff8`9c28640b coreclr!ManagedThreadBase_DispatchMiddle+0x8e [e:\a\_work\41\s\src\vm\threads.cpp @ 8903] 
71 00000073`4fb7f480 00007ff8`9c32cddb coreclr!ManagedThreadBase_DispatchOuter+0xaf [e:\a\_work\41\s\src\vm\threads.cpp @ 9142] 
72 00000073`4fb7f520 00007ff8`9c2ab01a coreclr!ManagedThreadBase_FullTransitionWithAD+0x2f [e:\a\_work\41\s\src\vm\threads.cpp @ 9202] 
73 (Inline Function) --------`-------- coreclr!ManagedThreadBase::KickOff+0x20 [e:\a\_work\41\s\src\vm\threads.cpp @ 9236] 
74 00000073`4fb7f580 00007ff8`9c2aaeea coreclr!ThreadNative::KickOffThread+0x10a [e:\a\_work\41\s\src\vm\comsynchronizable.cpp @ 380] 
75 00000073`4fb7f660 00007ff8`e1ca3034 coreclr!Thread::intermediateThreadProc+0x8a [e:\a\_work\41\s\src\vm\threads.cpp @ 2256] 
76 00000073`4fb7faa0 00007ff8`e3d11431 KERNEL32!BaseThreadInitThunk+0x14 [base\win32\client\thread.c @ 64] 
77 00000073`4fb7fad0 00000000`00000000 ntdll!RtlUserThreadStart+0x21 [minkernel\ntdll\rtlstrt.c @ 998] 
```</Description>
    <Title_Description>[JITMinOpts=1] CoreFX System.Numerics.Vectors.Tests (Vector3EqualsTest) crashes under minopts The test crashes on Windows and Unix under JITMinOpts=1 or TieredCompilation=1. Stack:

```
 # Child-SP          RetAddr           Call Site
00 00000073`4fb79240 00007ff8`9c3b7779 coreclr!EEPolicy::HandleFatalError+0x7a [e:\a\_work\41\s\src\vm\eepolicy.cpp @ 1522] 
01 00000073`4fb79840 00007ff8`e3d3eced coreclr!ProcessCLRException+0x1203f9 [e:\a\_work\41\s\src\vm\exceptionhandling.cpp @ 1029] 
02 00000073`4fb79980 00007ff8`e3ca6c86 ntdll!RtlpExecuteHandlerForException+0xd [minkernel\ntos\rtl\amd64\xcptmisc.asm @ 131] 
03 00000073`4fb799b0 00007ff8`e3ca52ca ntdll!RtlDispatchException+0x3c6 [minkernel\ntos\rtl\amd64\exdsptch.c @ 569] 
04 00000073`4fb7a0b0 00007ff8`e0dca388 ntdll!RtlRaiseException+0x31a [minkernel\ntos\rtl\amd64\raise.c @ 178] 
05 00000073`4fb7a910 00007ff8`9c333369 KERNELBASE!RaiseException+0x68 [minkernel\kernelbase\xcpt.c @ 922] 
06 00000073`4fb7a9f0 00007ff8`9c33339b coreclr!NakedThrowHelper2+0x9 [E:\A\_work\41\s\src\vm\amd64\RedirectedHandledJITCase.asm @ 229] 
07 00000073`4fb7aa20 00007ff8`9c3333a5 coreclr!NakedThrowHelper_RspAligned+0x1e [E:\A\_work\41\s\src\vm\amd64\RedirectedHandledJITCase.asm @ 233] 
08 00000073`4fb7af48 00007ff8`3cca5377 coreclr!NakedThrowHelper_FixRsp+0x5 [E:\A\_work\41\s\src\vm\amd64\RedirectedHandledJITCase.asm @ 233] 
09 00000073`4fb7af50 00007ff8`9c333753 System_Numerics_Vectors_Tests!System.Numerics.Tests.Vector3Tests.Vector3EqualsTest()+0xc7
0a 00000073`4fb7afd0 00007ff8`9c2be7fa coreclr!CallDescrWorkerInternal+0x83 [E:\A\_work\41\s\src\vm\amd64\CallDescrWorkerAMD64.asm @ 101] 
0b 00000073`4fb7b010 00007ff8`9c2be33b coreclr!CallDescrWorkerReflectionWrapper+0x1a [e:\a\_work\41\s\src\vm\reflectioninvocation.cpp @ 667] 
0c 00000073`4fb7b060 00007ff8`8b03b6f1 coreclr!RuntimeMethodHandle::InvokeMethod+0x4eb [e:\a\_work\41\s\src\vm\reflectioninvocation.cpp @ 1300] 
0d 00000073`4fb7b6e0 00007ff8`8b006292 System_Private_CoreLib!System.Reflection.RuntimeMethodInfo.Invoke(System.Object System.Reflection.BindingFlags System.Reflection.Binder System.Object[] System.Globalization.CultureInfo)+0xb1
0e 00000073`4fb7b750 00007ff8`3cb2b5e9 System_Private_CoreLib!System.Reflection.MethodBase.Invoke(System.Object System.Object[])+0x22
0f 00000073`4fb7b790 00007ff8`3cb2b262 xunit_execution_dotnet!Xunit.Sdk.TestInvoker`1[[System.__Canon System.Private.CoreLib]].CallTestMethod(System.Object)+0x49 [C:\BuildAgent\work\cb37e9acf085d108\src\xunit.execution\Sdk\Frameworks\Runners\TestInvoker.cs @ 147] 
10 00000073`4fb7b7d0 00007ff8`3cb2abfd xunit_execution_dotnet!Xunit.Sdk.TestInvoker`1+&lt;&gt;c__DisplayClass46_1+&lt;&lt;InvokeTestMethodAsync&gt;b__1&gt;d[[System.__Canon System.Private.CoreLib]].MoveNext()+0x562 [C:\BuildAgent\work\cb37e9acf085d108\src\xunit.execution\Sdk\Frameworks\Runners\TestInvoker.cs @ 224] 
11 00000073`4fb7b9f0 00007ff8`3cb2aaf1 System_Private_CoreLib!System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[System.IO.TextWriter+&lt;&lt;WriteAsync&gt;g__WriteAsyncCore|59_0&gt;d System.Private.CoreLib]](&lt;&lt;WriteAsync&gt;g__WriteAsyncCore|59_0&gt;d ByRef)+0xffffffff`b1a924cd
12 00000073`4fb7baa0 00007ff8`3cb2aa63 System_Private_CoreLib!System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[System.__Canon System.Private.CoreLib]](System.__Canon ByRef)+0xffffffff`b19adda1
13 00000073`4fb7bae0 00007ff8`3cb2a7f0 xunit_execution_dotnet!Xunit.Sdk.TestInvoker`1+&lt;&gt;c__DisplayClass46_1[[System.__Canon System.Private.CoreLib]].&lt;InvokeTestMethodAsync&gt;b__1()+0xa3
14 00000073`4fb7bb70 00007ff8`3cb2a68c xunit_execution_dotnet!Xunit.Sdk.ExecutionTimer+&lt;AggregateAsync&gt;d__4.MoveNext()+0x70 [C:\BuildAgent\work\cb37e9acf085d108\src\xunit.execution\Sdk\Frameworks\ExecutionTimer.cs @ 48] 
15 00000073`4fb7bc00 00007ff8`3cb2a5d7 System_Private_CoreLib!System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[System.IO.TextWriter+&lt;&lt;WriteAsync&gt;g__WriteAsyncCore|59_0&gt;d System.Private.CoreLib]](&lt;&lt;WriteAsync&gt;g__WriteAsyncCore|59_0&gt;d ByRef)+0xffffffff`b1a91f5c
16 00000073`4fb7bc90 00007ff8`3cb2a58c System_Private_CoreLib!System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[System.__Canon System.Private.CoreLib]](System.__Canon ByRef)+0xffffffff`b19ad887
17 00000073`4fb7bcc0 00007ff8`3cb2a4f5 xunit_execution_dotnet!Xunit.Sdk.ExecutionTimer.AggregateAsync(System.Func`1&lt;System.Threading.Tasks.Task&gt;)+0x6c
18 00000073`4fb7bd40 00007ff8`3cb29e87 xunit_execution_dotnet!Xunit.Sdk.TestInvoker`1+&lt;&gt;c__DisplayClass46_1[[System.__Canon System.Private.CoreLib]].&lt;InvokeTestMethodAsync&gt;b__0()+0xb5 [C:\BuildAgent\work\cb37e9acf085d108\src\xunit.execution\Sdk\Frameworks\Runners\TestInvoker.cs @ 209] 
19 00000073`4fb7bdb0 00007ff8`3cb29d3c xunit_core!Xunit.Sdk.ExceptionAggregator+&lt;RunAsync&gt;d__9.MoveNext()+0x57 [C:\BuildAgent\work\cb37e9acf085d108\src\xunit.core\Sdk\ExceptionAggregator.cs @ 90] 
1a 00000073`4fb7be50 00007ff8`3cb29c87 System_Private_CoreLib!System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[System.IO.TextWriter+&lt;&lt;WriteAsync&gt;g__WriteAsyncCore|59_0&gt;d System.Private.CoreLib]](&lt;&lt;WriteAsync&gt;g__WriteAsyncCore|59_0&gt;d ByRef)+0xffffffff`b1a9160c
1b 00000073`4fb7bee0 00007ff8`3cb29c3c System_Private_CoreLib!System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[System.__Canon System.Private.CoreLib]](System.__Canon ByRef)+0xffffffff`b19acf37
1c 00000073`4fb7bf10 00007ff8`3cb296b9 xunit_core!Xunit.Sdk.ExceptionAggregator.RunAsync(System.Func`1&lt;System.Threading.Tasks.Task&gt;)+0x6c
1d 00000073`4fb7bf80 00007ff8`3cb293ad xunit_execution_dotnet!Xunit.Sdk.TestInvoker`1+&lt;InvokeTestMethodAsync&gt;d__46[[System.__Canon System.Private.CoreLib]].MoveNext()+0x209 [C:\BuildAgent\work\cb37e9acf085d108\src\xunit.execution\Sdk\Frameworks\Runners\TestInvoker.cs @ 208] 
1e 00000073`4fb7c0a0 00007ff8`3cb292a1 System_Private_CoreLib!System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[System.IO.TextWriter+&lt;&lt;WriteAsync&gt;g__WriteAsyncCore|59_0&gt;d System.Private.CoreLib]](&lt;&lt;WriteAsync&gt;g__WriteAsyncCore|59_0&gt;d ByRef)+0xffffffff`b1a90c7d
1f 00000073`4fb7c150 00007ff8`3cb29213 System_Private_CoreLib!System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.__Canon System.Private.CoreLib]].Start[[System.CommonlyUsedGenericInstantiations+&lt;AsyncHelper2&gt;d__4`1[[System.__Canon System.Private.CoreLib]] System.Private.CoreLib]](&lt;AsyncHelper2&gt;d__4`1&lt;System.__Canon&gt; ByRef)+0xffffffff`b19bd3a1
20 00000073`4fb7c190 00007ff8`3cb27a38 xunit_execution_dotnet!Xunit.Sdk.TestInvoker`1[[System.__Canon System.Private.CoreLib]].InvokeTestMethodAsync(System.Object)+0xb3
21 00000073`4fb7c220 00007ff8`3cb274ed xunit_execution_dotnet!Xunit.Sdk.TestInvoker`1+&lt;&lt;RunAsync&gt;b__45_0&gt;d[[System.__Canon System.Private.CoreLib]].MoveNext()+0x448 [C:\BuildAgent\work\cb37e9acf085d108\src\xunit.execution\Sdk\Frameworks\Runners\TestInvoker.cs @ 173] 
22 00000073`4fb7c3b0 00007ff8`3cb273e1 System_Private_CoreLib!System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[System.IO.TextWriter+&lt;&lt;WriteAsync&gt;g__WriteAsyncCore|59_0&gt;d System.Private.CoreLib]](&lt;&lt;WriteAsync&gt;g__WriteAsyncCore|59_0&gt;d ByRef)+0xffffffff`b1a8edbd
23 00000073`4fb7c460 00007ff8`3cb27356 System_Private_CoreLib!System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.__Canon System.Private.CoreLib]].Start[[System.CommonlyUsedGenericInstantiations+&lt;AsyncHelper2&gt;d__4`1[[System.__Canon System.Private.CoreLib]] System.Private.CoreLib]](&lt;AsyncHelper2&gt;d__4`1&lt;System.__Canon&gt; ByRef)+0xffffffff`b19bb4e1
24 00000073`4fb7c4a0 00007ff8`3cb270ad xunit_execution_dotnet!Xunit.Sdk.TestInvoker`1[[System.__Canon System.Private.CoreLib]].&lt;RunAsync&gt;b__45_0()+0xa6
25 00000073`4fb7c540 00007ff8`3cb26f4c xunit_core!Xunit.Sdk.ExceptionAggregator+&lt;RunAsync&gt;d__10`1[[System.__Canon System.Private.CoreLib]].MoveNext()+0x1dbd [C:\BuildAgent\work\cb37e9acf085d108\src\xunit.core\Sdk\TraitDiscoverer.cs @ 16] 
26 00000073`4fb7c610 00007ff8`3cb26e97 System_Private_CoreLib!System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[System.IO.TextWriter+&lt;&lt;WriteAsync&gt;g__WriteAsyncCore|59_0&gt;d System.Private.CoreLib]](&lt;&lt;WriteAsync&gt;g__WriteAsyncCore|59_0&gt;d ByRef)+0xffffffff`b1a8e81c
27 00000073`4fb7c6a0 00007ff8`3cb26e0c System_Private_CoreLib!System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.__Canon System.Private.CoreLib]].Start[[System.CommonlyUsedGenericInstantiations+&lt;AsyncHelper2&gt;d__4`1[[System.__Canon System.Private.CoreLib]] System.Private.CoreLib]](&lt;AsyncHelper2&gt;d__4`1&lt;System.__Canon&gt; ByRef)+0xffffffff`b19baf97
28 00000073`4fb7c6d0 00007ff8`3cb26d4e xunit_core!Xunit.Sdk.ExceptionAggregator.RunAsync[[System.Decimal System.Private.CoreLib]](System.Func`1&lt;System.Threading.Tasks.Task`1&lt;System.Decimal&gt;&gt;)+0x6c
29 00000073`4fb7c740 00007ff8`3cb262ac xunit_execution_dotnet!Xunit.Sdk.TestInvoker`1[[System.__Canon System.Private.CoreLib]].RunAsync()+0x5e [C:\BuildAgent\work\cb37e9acf085d108\src\xunit.execution\Sdk\Frameworks\Runners\TestInvoker.cs @ 156] 
2a 00000073`4fb7c780 00007ff8`3cb25f74 xunit_execution_dotnet!Xunit.Sdk.XunitTestRunner.InvokeTestMethodAsync(Xunit.Sdk.ExceptionAggregator)+0xfc [C:\BuildAgent\work\cb37e9acf085d108\src\xunit.execution\Sdk\Frameworks\Runners\XunitTestRunner.cs @ 84] 
2b 00000073`4fb7c840 00007ff8`3cb25d0c xunit_execution_dotnet!Xunit.Sdk.XunitTestRunner+&lt;InvokeTestAsync&gt;d__4.MoveNext()+0x174 [C:\BuildAgent\work\cb37e9acf085d108\src\xunit.execution\Sdk\Frameworks\Runners\XunitTestRunner.cs @ 67] 
2c 00000073`4fb7c930 00007ff8`3cb25c57 System_Private_CoreLib!System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[System.IO.TextWriter+&lt;&lt;WriteAsync&gt;g__WriteAsyncCore|59_0&gt;d System.Private.CoreLib]](&lt;&lt;WriteAsync&gt;g__WriteAsyncCore|59_0&gt;d ByRef)+0xffffffff`b1a8d5dc
2d 00000073`4fb7c9c0 00007ff8`3cb25c00 System_Private_CoreLib!System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.__Canon System.Private.CoreLib]].Start[[System.CommonlyUsedGenericInstantiations+&lt;AsyncHelper2&gt;d__4`1[[System.__Canon System.Private.CoreLib]] System.Private.CoreLib]](&lt;AsyncHelper2&gt;d__4`1&lt;System.__Canon&gt; ByRef)+0xffffffff`b19b9d57
2e 00000073`4fb7c9f0 00007ff8`3cb25b5a xunit_execution_dotnet!Xunit.Sdk.XunitTestRunner.InvokeTestAsync(Xunit.Sdk.ExceptionAggregator)+0x80
2f 00000073`4fb7ca70 00007ff8`3cb25362 xunit_execution_dotnet!Xunit.Sdk.TestRunner`1+&lt;&gt;c__DisplayClass43_0[[System.__Canon System.Private.CoreLib]].&lt;RunAsync&gt;b__0()+0x3a [C:\BuildAgent\work\cb37e9acf085d108\src\xunit.execution\Sdk\Frameworks\Runners\TestRunner.cs @ 149] 
30 00000073`4fb7cab0 00007ff8`3cb2488d xunit_core!Xunit.Sdk.ExceptionAggregator+&lt;RunAsync&gt;d__10`1[[System.__Canon System.Private.CoreLib]].MoveNext()+0x72 [C:\BuildAgent\work\cb37e9acf085d108\src\xunit.core\Sdk\ExceptionAggregator.cs @ 107] 
31 00000073`4fb7cbb0 00007ff8`3cb24641 System_Private_CoreLib!System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[System.IO.TextWriter+&lt;&lt;WriteAsync&gt;g__WriteAsyncCore|59_0&gt;d System.Private.CoreLib]](&lt;&lt;WriteAsync&gt;g__WriteAsyncCore|59_0&gt;d ByRef)+0xffffffff`b1a8c15d
32 00000073`4fb7cc60 00007ff8`3cb2448b System_Private_CoreLib!System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.__Canon System.Private.CoreLib]].Start[[System.CommonlyUsedGenericInstantiations+&lt;AsyncHelper2&gt;d__4`1[[System.__Canon System.Private.CoreLib]] System.Private.CoreLib]](&lt;AsyncHelper2&gt;d__4`1&lt;System.__Canon&gt; ByRef)+0xffffffff`b19b8741
33 00000073`4fb7cca0 00007ff8`3cb23866 xunit_core!Xunit.Sdk.ExceptionAggregator.RunAsync[[System.Decimal System.Private.CoreLib]](System.Func`1&lt;System.Threading.Tasks.Task`1&lt;System.Decimal&gt;&gt;)+0xffffffff`ffffd6eb
34 00000073`4fb7cd30 00007ff8`3cb22fad xunit_execution_dotnet!Xunit.Sdk.TestRunner`1+&lt;RunAsync&gt;d__43[[System.__Canon System.Private.CoreLib]].MoveNext()+0x3b6 [C:\BuildAgent\work\cb37e9acf085d108\src\xunit.execution\Sdk\Frameworks\Runners\TestRunner.cs @ 149] 
35 00000073`4fb7cf30 00007ff8`3cb22ea1 System_Private_CoreLib!System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[System.IO.TextWriter+&lt;&lt;WriteAsync&gt;g__WriteAsyncCore|59_0&gt;d System.Private.CoreLib]](&lt;&lt;WriteAsync&gt;g__WriteAsyncCore|59_0&gt;d ByRef)+0xffffffff`b1a8a87d
36 00000073`4fb7cfe0 00007ff8`3cb22e0d System_Private_CoreLib!System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.__Canon System.Private.CoreLib]].Start[[System.CommonlyUsedGenericInstantiations+&lt;AsyncHelper2&gt;d__4`1[[System.__Canon System.Private.CoreLib]] System.Private.CoreLib]](&lt;AsyncHelper2&gt;d__4`1&lt;System.__Canon&gt; ByRef)+0xffffffff`b19b6fa1
37 00000073`4fb7d020 00007ff8`3cb225fb xunit_execution_dotnet!Xunit.Sdk.TestRunner`1[[System.__Canon System.Private.CoreLib]].RunAsync()+0xad
38 00000073`4fb7d0b0 00007ff8`3cb21a04 xunit_execution_dotnet!Xunit.Sdk.XunitTestCaseRunner.RunTestAsync()+0x16b [C:\BuildAgent\work\cb37e9acf085d108\src\xunit.execution\Sdk\Frameworks\Runners\XunitTestCaseRunner.cs @ 106] 
39 00000073`4fb7d1a0 00007ff8`3cb2169d xunit_execution_dotnet!Xunit.Sdk.TestCaseRunner`1+&lt;RunAsync&gt;d__19[[System.__Canon System.Private.CoreLib]].MoveNext()+0x264 [C:\BuildAgent\work\cb37e9acf085d108\src\xunit.execution\Sdk\Frameworks\Runners\TestCaseRunner.cs @ 82] 
3a 00000073`4fb7d310 00007ff8`3cb21591 System_Private_CoreLib!System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[System.IO.TextWriter+&lt;&lt;WriteAsync&gt;g__WriteAsyncCore|59_0&gt;d System.Private.CoreLib]](&lt;&lt;WriteAsync&gt;g__WriteAsyncCore|59_0&gt;d ByRef)+0xffffffff`b1a88f6d
3b 00000073`4fb7d3c0 00007ff8`3cb214fd System_Private_CoreLib!System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.__Canon System.Private.CoreLib]].Start[[System.CommonlyUsedGenericInstantiations+&lt;AsyncHelper2&gt;d__4`1[[System.__Canon System.Private.CoreLib]] System.Private.CoreLib]](&lt;AsyncHelper2&gt;d__4`1&lt;System.__Canon&gt; ByRef)+0xffffffff`b19b5691
3c 00000073`4fb7d400 00007ff8`3cb20223 xunit_execution_dotnet!Xunit.Sdk.TestCaseRunner`1[[System.__Canon System.Private.CoreLib]].RunAsync()+0xad
3d 00000073`4fb7d490 00007ff8`3cb200ea xunit_execution_dotnet!Xunit.Sdk.XunitTestCase.RunAsync(Xunit.Abstractions.IMessageSink Xunit.Sdk.IMessageBus System.Object[] Xunit.Sdk.ExceptionAggregator System.Threading.CancellationTokenSource)+0xb3 [C:\BuildAgent\work\cb37e9acf085d108\src\xunit.execution\Sdk\Frameworks\XunitTestCase.cs @ 106] 
3e 00000073`4fb7d520 00007ff8`3cb1fd85 xunit_execution_dotnet!Xunit.Sdk.XunitTestMethodRunner.RunTestCaseAsync(Xunit.Sdk.IXunitTestCase)+0xba [C:\BuildAgent\work\cb37e9acf085d108\src\xunit.execution\Sdk\Frameworks\Runners\XunitTestMethodRunner.cs @ 45] 
3f 00000073`4fb7d5a0 00007ff8`3cb1fafd xunit_execution_dotnet!Xunit.Sdk.TestMethodRunner`1+&lt;RunTestCasesAsync&gt;d__32[[System.__Canon System.Private.CoreLib]].MoveNext()+0x185 [C:\BuildAgent\work\cb37e9acf085d108\src\xunit.execution\Sdk\Frameworks\Runners\TestMethodRunner.cs @ 136] 
40 00000073`4fb7d680 00007ff8`3cb1f9f1 System_Private_CoreLib!System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[System.IO.TextWriter+&lt;&lt;WriteAsync&gt;g__WriteAsyncCore|59_0&gt;d System.Private.CoreLib]](&lt;&lt;WriteAsync&gt;g__WriteAsyncCore|59_0&gt;d ByRef)+0xffffffff`b1a873cd
41 00000073`4fb7d730 00007ff8`3cb1f960 System_Private_CoreLib!System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.__Canon System.Private.CoreLib]].Start[[System.CommonlyUsedGenericInstantiations+&lt;AsyncHelper2&gt;d__4`1[[System.__Canon System.Private.CoreLib]] System.Private.CoreLib]](&lt;AsyncHelper2&gt;d__4`1&lt;System.__Canon&gt; ByRef)+0xffffffff`b19b3af1
42 00000073`4fb7d770 00007ff8`3cb1ee1b xunit_execution_dotnet!Xunit.Sdk.TestMethodRunner`1[[System.__Canon System.Private.CoreLib]].RunTestCasesAsync()+0xb0
43 00000073`4fb7d810 00007ff8`3cb1eb6d xunit_execution_dotnet!Xunit.Sdk.TestMethodRunner`1+&lt;RunAsync&gt;d__31[[System.__Canon System.Private.CoreLib]].MoveNext()+0x1ab [C:\BuildAgent\work\cb37e9acf085d108\src\xunit.execution\Sdk\Frameworks\Runners\TestMethodRunner.cs @ 106] 
44 00000073`4fb7d980 00007ff8`3cb1ea61 System_Private_CoreLib!System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[System.IO.TextWriter+&lt;&lt;WriteAsync&gt;g__WriteAsyncCore|59_0&gt;d System.Private.CoreLib]](&lt;&lt;WriteAsync&gt;g__WriteAsyncCore|59_0&gt;d ByRef)+0xffffffff`b1a8643d
45 00000073`4fb7da30 00007ff8`3cb1e9cd System_Private_CoreLib!System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.__Canon System.Private.CoreLib]].Start[[System.CommonlyUsedGenericInstantiations+&lt;AsyncHelper2&gt;d__4`1[[System.__Canon System.Private.CoreLib]] System.Private.CoreLib]](&lt;AsyncHelper2&gt;d__4`1&lt;System.__Canon&gt; ByRef)+0xffffffff`b19b2b61
46 00000073`4fb7da70 00007ff8`3cb1e56d xunit_execution_dotnet!Xunit.Sdk.TestMethodRunner`1[[System.__Canon System.Private.CoreLib]].RunAsync()+0xad
47 00000073`4fb7db00 00007ff8`3cb1ae30 xunit_execution_dotnet!Xunit.Sdk.XunitTestClassRunner.RunTestMethodAsync(Xunit.Abstractions.ITestMethod Xunit.Abstractions.IReflectionMethodInfo System.Collections.Generic.IEnumerable`1&lt;Xunit.Sdk.IXunitTestCase&gt; System.Object[])+0xfd [C:\BuildAgent\work\cb37e9acf085d108\src\xunit.execution\Sdk\Frameworks\Runners\XunitTestClassRunner.cs @ 152] 
48 00000073`4fb7dbb0 00007ff8`3cb1a87d xunit_execution_dotnet!Xunit.Sdk.TestClassRunner`1+&lt;RunTestMethodsAsync&gt;d__38[[System.__Canon System.Private.CoreLib]].MoveNext()+0x4b0 [C:\BuildAgent\work\cb37e9acf085d108\src\xunit.execution\Sdk\Frameworks\Runners\TestClassRunner.cs @ 205] 
49 00000073`4fb7ddb0 00007ff8`3cb1a361 System_Private_CoreLib!System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[System.IO.TextWriter+&lt;&lt;WriteAsync&gt;g__WriteAsyncCore|59_0&gt;d System.Private.CoreLib]](&lt;&lt;WriteAsync&gt;g__WriteAsyncCore|59_0&gt;d ByRef)+0xffffffff`b1a8214d
4a 00000073`4fb7de60 00007ff8`3cb1a2d0 System_Private_CoreLib!System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.__Canon System.Private.CoreLib]].Start[[System.CommonlyUsedGenericInstantiations+&lt;AsyncHelper2&gt;d__4`1[[System.__Canon System.Private.CoreLib]] System.Private.CoreLib]](&lt;AsyncHelper2&gt;d__4`1&lt;System.__Canon&gt; ByRef)+0xffffffff`b19ae461
4b 00000073`4fb7dea0 00007ff8`3cb17fb6 xunit_execution_dotnet!Xunit.Sdk.TestClassRunner`1[[System.__Canon System.Private.CoreLib]].RunTestMethodsAsync()+0xb0
4c 00000073`4fb7df40 00007ff8`3cb17c1d xunit_execution_dotnet!Xunit.Sdk.TestClassRunner`1+&lt;RunAsync&gt;d__37[[System.__Canon System.Private.CoreLib]].MoveNext()+0x296 [C:\BuildAgent\work\cb37e9acf085d108\src\xunit.execution\Sdk\Frameworks\Runners\TestClassRunner.cs @ 163] 
4d 00000073`4fb7e0f0 00007ff8`3cb17b11 System_Private_CoreLib!System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[System.IO.TextWriter+&lt;&lt;WriteAsync&gt;g__WriteAsyncCore|59_0&gt;d System.Private.CoreLib]](&lt;&lt;WriteAsync&gt;g__WriteAsyncCore|59_0&gt;d ByRef)+0xffffffff`b1a7f4ed
4e 00000073`4fb7e1a0 00007ff8`3cb17a7d System_Private_CoreLib!System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.__Canon System.Private.CoreLib]].Start[[System.CommonlyUsedGenericInstantiations+&lt;AsyncHelper2&gt;d__4`1[[System.__Canon System.Private.CoreLib]] System.Private.CoreLib]](&lt;AsyncHelper2&gt;d__4`1&lt;System.__Canon&gt; ByRef)+0xffffffff`b19abc11
4f 00000073`4fb7e1e0 00007ff8`3cb175a9 xunit_execution_dotnet!Xunit.Sdk.TestClassRunner`1[[System.__Canon System.Private.CoreLib]].RunAsync()+0xad
50 00000073`4fb7e270 00007ff8`3cb16b1a xunit_execution_dotnet!Xunit.Sdk.XunitTestCollectionRunner.RunTestClassAsync(Xunit.Abstractions.ITestClass Xunit.Abstractions.IReflectionTypeInfo System.Collections.Generic.IEnumerable`1&lt;Xunit.Sdk.IXunitTestCase&gt;)+0x109 [C:\BuildAgent\work\cb37e9acf085d108\src\xunit.execution\Sdk\Frameworks\Runners\XunitTestCollectionRunner.cs @ 124] 
51 00000073`4fb7e320 00007ff8`3cb1662d xunit_execution_dotnet!Xunit.Sdk.TestCollectionRunner`1+&lt;RunTestClassesAsync&gt;d__28[[System.__Canon System.Private.CoreLib]].MoveNext()+0x3ea [C:\BuildAgent\work\cb37e9acf085d108\src\xunit.execution\Sdk\Frameworks\Runners\TestCollectionRunner.cs @ 130] 
52 00000073`4fb7e490 00007ff8`3cb16521 System_Private_CoreLib!System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[System.IO.TextWriter+&lt;&lt;WriteAsync&gt;g__WriteAsyncCore|59_0&gt;d System.Private.CoreLib]](&lt;&lt;WriteAsync&gt;g__WriteAsyncCore|59_0&gt;d ByRef)+0xffffffff`b1a7defd
53 00000073`4fb7e540 00007ff8`3cb16490 System_Private_CoreLib!System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.__Canon System.Private.CoreLib]].Start[[System.CommonlyUsedGenericInstantiations+&lt;AsyncHelper2&gt;d__4`1[[System.__Canon System.Private.CoreLib]] System.Private.CoreLib]](&lt;AsyncHelper2&gt;d__4`1&lt;System.__Canon&gt; ByRef)+0xffffffff`b19aa621
54 00000073`4fb7e580 00007ff8`3cb13a77 xunit_execution_dotnet!Xunit.Sdk.TestCollectionRunner`1[[System.__Canon System.Private.CoreLib]].RunTestClassesAsync()+0xb0
55 00000073`4fb7e620 00007ff8`3cb12a1d xunit_execution_dotnet!Xunit.Sdk.TestCollectionRunner`1+&lt;RunAsync&gt;d__27[[System.__Canon System.Private.CoreLib]].MoveNext()+0x297 [C:\BuildAgent\work\cb37e9acf085d108\src\xunit.execution\Sdk\Frameworks\Runners\TestCollectionRunner.cs @ 101] 
56 00000073`4fb7e7d0 00007ff8`3cb12911 System_Private_CoreLib!System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[System.IO.TextWriter+&lt;&lt;WriteAsync&gt;g__WriteAsyncCore|59_0&gt;d System.Private.CoreLib]](&lt;&lt;WriteAsync&gt;g__WriteAsyncCore|59_0&gt;d ByRef)+0xffffffff`b1a7a2ed
57 00000073`4fb7e880 00007ff8`3cb1287d System_Private_CoreLib!System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.__Canon System.Private.CoreLib]].Start[[System.CommonlyUsedGenericInstantiations+&lt;AsyncHelper2&gt;d__4`1[[System.__Canon System.Private.CoreLib]] System.Private.CoreLib]](&lt;AsyncHelper2&gt;d__4`1&lt;System.__Canon&gt; ByRef)+0xffffffff`b19a6a11
58 00000073`4fb7e8c0 00007ff8`3cb11f0e xunit_execution_dotnet!Xunit.Sdk.TestCollectionRunner`1[[System.__Canon System.Private.CoreLib]].RunAsync()+0xad
59 00000073`4fb7e950 00007ff8`3cb11e18 xunit_execution_dotnet!Xunit.Sdk.XunitTestAssemblyRunner.RunTestCollectionAsync(Xunit.Sdk.IMessageBus Xunit.Abstractions.ITestCollection System.Collections.Generic.IEnumerable`1&lt;Xunit.Sdk.IXunitTestCase&gt; System.Threading.CancellationTokenSource)+0xce [C:\BuildAgent\work\cb37e9acf085d108\src\xunit.execution\Sdk\Frameworks\Runners\XunitTestAssemblyRunner.cs @ 203] 
5a 00000073`4fb7e9e0 00007ff8`8b0920d9 xunit_execution_dotnet!Xunit.Sdk.XunitTestAssemblyRunner+&lt;&gt;c__DisplayClass14_2.&lt;RunTestCollectionsAsync&gt;b__3()+0x98 [C:\BuildAgent\work\cb37e9acf085d108\src\xunit.execution\Sdk\Frameworks\Runners\XunitTestAssemblyRunner.cs @ 179] 
5b 00000073`4fb7ea50 00007ff8`8afa77d6 System_Private_CoreLib!System.Threading.Tasks.Task`1[[System.__Canon System.Private.CoreLib]].InnerInvoke()+0x49
5c 00000073`4fb7eaa0 00007ff8`8b0634da System_Private_CoreLib!System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext System.Threading.ContextCallback System.Object)+0x86
5d 00000073`4fb7eb20 00007ff8`8b063264 System_Private_CoreLib!System.Threading.Tasks.Task.ExecuteWithThreadLocal(System.Threading.Tasks.Task ByRef)+0x19a
5e 00000073`4fb7ebc0 00007ff8`8b0c7a6b System_Private_CoreLib!System.Threading.Tasks.Task.ExecuteEntry()+0x84
5f 00000073`4fb7ec00 00007ff8`3cb11d4d System_Private_CoreLib!System.Threading.Tasks.SynchronizationContextTaskScheduler+&lt;&gt;c.&lt;.cctor&gt;b__8_0(System.Object)+0x2b
60 00000073`4fb7ec30 00007ff8`3cb11cd6 xunit_execution_dotnet!Xunit.Sdk.MaxConcurrencySyncContext.RunOnSyncContext(System.Threading.SendOrPostCallback System.Object)+0x4d [C:\BuildAgent\work\cb37e9acf085d108\src\xunit.execution\Sdk\MaxConcurrencySyncContext.cs @ 107] 
61 00000073`4fb7ec70 00007ff8`8afa77d6 xunit_execution_dotnet!Xunit.Sdk.MaxConcurrencySyncContext+&lt;&gt;c__DisplayClass11_0.&lt;WorkerThreadProc&gt;b__0(System.Object)+0x66 [C:\BuildAgent\work\cb37e9acf085d108\src\xunit.execution\Sdk\MaxConcurrencySyncContext.cs @ 96] 
62 00000073`4fb7ecd0 00007ff8`3cb9015a System_Private_CoreLib!System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext System.Threading.ContextCallback System.Object)+0x86
63 00000073`4fb7ed50 00007ff8`3cb11c49 DynamicClass.lambda_method(System.Runtime.CompilerServices.Closure System.Object System.Object)+0x5a
64 00000073`4fb7ed90 00007ff8`3cb0d689 xunit_execution_dotnet!Xunit.Sdk.ExecutionContextHelper.Run(System.Object System.Action`1&lt;System.Object&gt;)+0x69 [C:\BuildAgent\work\cb37e9acf085d108\src\xunit.execution\Sdk\Utility\ExecutionContextHelper.cs @ 111] 
65 00000073`4fb7edf0 00007ff8`3c86f7fe xunit_execution_dotnet!Xunit.Sdk.MaxConcurrencySyncContext.WorkerThreadProc()+0x159 [C:\BuildAgent\work\cb37e9acf085d108\src\xunit.execution\Sdk\MaxConcurrencySyncContext.cs @ 85] 
66 00000073`4fb7ee70 00007ff8`8afa77d6 xunit_execution_dotnet!Xunit.Sdk.XunitWorkerThread+&lt;&gt;c.&lt;QueueUserWorkItem&gt;b__5_0(System.Object)+0x4e [C:\BuildAgent\work\cb37e9acf085d108\src\common\XunitWorkerThread.cs @ 37] 
67 00000073`4fb7eec0 00007ff8`8b0634da System_Private_CoreLib!System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext System.Threading.ContextCallback System.Object)+0x86
68 00000073`4fb7ef40 00007ff8`8afa77d6 System_Private_CoreLib!System.Threading.Tasks.Task.ExecuteWithThreadLocal(System.Threading.Tasks.Task ByRef)+0x19a
69 00000073`4fb7efe0 00007ff8`9c333753 System_Private_CoreLib!System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext System.Threading.ContextCallback System.Object)+0x86
6a 00000073`4fb7f060 00007ff8`9c286a79 coreclr!CallDescrWorkerInternal+0x83 [E:\A\_work\41\s\src\vm\amd64\CallDescrWorkerAMD64.asm @ 101] 
6b (Inline Function) --------`-------- coreclr!CallDescrWorkerWithHandler+0x53 [e:\a\_work\41\s\src\vm\callhelpers.cpp @ 78] 
6c 00000073`4fb7f0a0 00007ff8`9c32526a coreclr!MethodDescCallSite::CallTargetWorker+0x2b5 [e:\a\_work\41\s\src\vm\callhelpers.cpp @ 628] 
6d (Inline Function) --------`-------- coreclr!StressLog::InlinedStressLogOn+0x5 [e:\a\_work\41\s\src\utilcode\stresslog.cpp @ 595] 
6e (Inline Function) --------`-------- coreclr!StressLog::LogOn+0x5 [e:\a\_work\41\s\src\utilcode\stresslog.cpp @ 629] 
6f 00000073`4fb7f1f0 00007ff8`9c28652e coreclr!ThreadNative::KickOffThread_Worker+0x13a [e:\a\_work\41\s\src\vm\comsynchronizable.cpp @ 260] 
70 00000073`4fb7f360 00007ff8`9c28640b coreclr!ManagedThreadBase_DispatchMiddle+0x8e [e:\a\_work\41\s\src\vm\threads.cpp @ 8903] 
71 00000073`4fb7f480 00007ff8`9c32cddb coreclr!ManagedThreadBase_DispatchOuter+0xaf [e:\a\_work\41\s\src\vm\threads.cpp @ 9142] 
72 00000073`4fb7f520 00007ff8`9c2ab01a coreclr!ManagedThreadBase_FullTransitionWithAD+0x2f [e:\a\_work\41\s\src\vm\threads.cpp @ 9202] 
73 (Inline Function) --------`-------- coreclr!ManagedThreadBase::KickOff+0x20 [e:\a\_work\41\s\src\vm\threads.cpp @ 9236] 
74 00000073`4fb7f580 00007ff8`9c2aaeea coreclr!ThreadNative::KickOffThread+0x10a [e:\a\_work\41\s\src\vm\comsynchronizable.cpp @ 380] 
75 00000073`4fb7f660 00007ff8`e1ca3034 coreclr!Thread::intermediateThreadProc+0x8a [e:\a\_work\41\s\src\vm\threads.cpp @ 2256] 
76 00000073`4fb7faa0 00007ff8`e3d11431 KERNEL32!BaseThreadInitThunk+0x14 [base\win32\client\thread.c @ 64] 
77 00000073`4fb7fad0 00000000`00000000 ntdll!RtlUserThreadStart+0x21 [minkernel\ntdll\rtlstrt.c @ 998] 
```</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19196</IssueLabelID>
    <Title>Fix mscordbi metadata reader alignment bug on Linux.</Title>
    <Description>Works fine on Windows minidumps but on Linux (via OpenVirtualProcess
for production breakpoints and future core dumps) the compiler's struct
alignment rules are different. On Windows classes/structs are aligned
based on the largest field. On Linux they are 4 byte aligned regardless
of the field sizes.

https://github.com/dotnet/coreclr/issues/17692</Description>
    <Title_Description>Fix mscordbi metadata reader alignment bug on Linux. Works fine on Windows minidumps but on Linux (via OpenVirtualProcess
for production breakpoints and future core dumps) the compiler's struct
alignment rules are different. On Windows classes/structs are aligned
based on the largest field. On Linux they are 4 byte aligned regardless
of the field sizes.

https://github.com/dotnet/coreclr/issues/17692</Title_Description>
    <Label>
    </Label>
    <Assignee>mikem8361</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19195</IssueLabelID>
    <Title>Add ICustomMarshaler tests</Title>
    <Description>Finally got round to getting https://github.com/dotnet/corefx/pull/17804 into coreclr

@AaronRobinsonMSFT @yizhang82 @tijoytom</Description>
    <Title_Description>Add ICustomMarshaler tests Finally got round to getting https://github.com/dotnet/corefx/pull/17804 into coreclr

@AaronRobinsonMSFT @yizhang82 @tijoytom</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>30/07/2018 1:48:43 PM +00:00</CreatedAt>
    <ClosedAt>18/11/2018 6:31:29 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19194</IssueLabelID>
    <Title>Dataflow cancellation crashes console app when debugger is attached</Title>
    <Description>Platform: Windows
Debugger: Visual Studio 2017
Version: 2.1.2

After pressing Ctrl+C The following program will hang before the 2nd beakpoint is hit but only when debugger is attached:

```
class Program
{
    static async Task Main(string[] args)
    {
        var cts = new CancellationTokenSource();
        Console.CancelKeyPress += (s e) =&gt; cts.Cancel(true);

        var block1 = new TransformBlock&lt;int int&gt;(async x =&gt;
        {
            Console.WriteLine($"In: {x}");
            await Task.Delay(3000);
            return x;
        } new ExecutionDataflowBlockOptions()
        {
            CancellationToken = cts.Token
        });
        var block2 = new ActionBlock&lt;int&gt;(x =&gt;
        {
            Console.WriteLine($"Processed: {x}");
        });

        block1.LinkTo(block2 new DataflowLinkOptions() { PropagateCompletion = true });

        foreach (var i in Enumerable.Range(0 100))
            await block1.SendAsync(i);

        block1.Complete();

        // wait for cancellation to be triggered
        await Task.WhenAny(Task.Delay(Timeout.Infinite cts.Token));

        await block1.Completion; // breakpoint 1
        await block2.Completion; // breakpoint 2

        Console.ReadKey();
    }
}
```</Description>
    <Title_Description>Dataflow cancellation crashes console app when debugger is attached Platform: Windows
Debugger: Visual Studio 2017
Version: 2.1.2

After pressing Ctrl+C The following program will hang before the 2nd beakpoint is hit but only when debugger is attached:

```
class Program
{
    static async Task Main(string[] args)
    {
        var cts = new CancellationTokenSource();
        Console.CancelKeyPress += (s e) =&gt; cts.Cancel(true);

        var block1 = new TransformBlock&lt;int int&gt;(async x =&gt;
        {
            Console.WriteLine($"In: {x}");
            await Task.Delay(3000);
            return x;
        } new ExecutionDataflowBlockOptions()
        {
            CancellationToken = cts.Token
        });
        var block2 = new ActionBlock&lt;int&gt;(x =&gt;
        {
            Console.WriteLine($"Processed: {x}");
        });

        block1.LinkTo(block2 new DataflowLinkOptions() { PropagateCompletion = true });

        foreach (var i in Enumerable.Range(0 100))
            await block1.SendAsync(i);

        block1.Complete();

        // wait for cancellation to be triggered
        await Task.WhenAny(Task.Delay(Timeout.Infinite cts.Token));

        await block1.Completion; // breakpoint 1
        await block2.Completion; // breakpoint 2

        Console.ReadKey();
    }
}
```</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>30/07/2018 12:48:15 PM +00:00</CreatedAt>
    <ClosedAt>25/02/2019 7:07:15 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19192</IssueLabelID>
    <Title>Unable to catch in managed code any user exception thrown from native Linux code</Title>
    <Description>Basically I have a solution that contains one project of managed C# .NET Core and another native linux C++ project. The managed code project uses the native one. In the native code I throw various C++ exceptions (such as `runtime_error`). In the managed code I call the native code within a `try`-`catch` block expecting to catch the offending exception(s) in the managed code.

I've tried:

1.  `catch (Exception)`;
2.  `catch (System.Runtime.CompilerServices.RuntimeWrappedException)`;
3.  Parameterless `catch {..}`;
4.  Using `[SecurityCritical]` + `[HandleProcessCorruptedStateExceptions]` although I thought these exceptions are probably not considered corrupted-state exception and even if they did in #9045 @jkotas [states that corrupted-state exceptions are not converted to managed exceptions](https://github.com/dotnet/coreclr/issues/9045#issuecomment-274615567);
5.  Setting `legacyCorruptedState­­ExceptionsPolicy` to `true` (again - although I thought I'm not dealing with corrupted-state exceptions).

All to no avail.

I've set-up [this Minimal Complete and Verifiable example](https://github.com/yaireclipse/CatchNativeExceptions) that demonstrates what I currently fail to achieve and the different attempts to solve it.

Tested with .NET Core 2.0 on Ubuntu 16.04.2 LTS (via Bash on Ubuntu on Windows) and CentOS Linux release 7.5.1804 (via Docker for Windows).

This was actually [asked in the past on Stackoverflow](https://stackoverflow.com/questions/50851329/catch-native-exception-in-dotnet-core) by @levhaikin a colleage of mine with no answers so we turn to you :) :

1.  Is my expectation correct? Meaning is there a way in .NET Core to catch an exception thrown from native code in managed code?
2.  If so what am I doing wrong? How should it be done?

Thanks
Yair</Description>
    <Title_Description>Unable to catch in managed code any user exception thrown from native Linux code Basically I have a solution that contains one project of managed C# .NET Core and another native linux C++ project. The managed code project uses the native one. In the native code I throw various C++ exceptions (such as `runtime_error`). In the managed code I call the native code within a `try`-`catch` block expecting to catch the offending exception(s) in the managed code.

I've tried:

1.  `catch (Exception)`;
2.  `catch (System.Runtime.CompilerServices.RuntimeWrappedException)`;
3.  Parameterless `catch {..}`;
4.  Using `[SecurityCritical]` + `[HandleProcessCorruptedStateExceptions]` although I thought these exceptions are probably not considered corrupted-state exception and even if they did in #9045 @jkotas [states that corrupted-state exceptions are not converted to managed exceptions](https://github.com/dotnet/coreclr/issues/9045#issuecomment-274615567);
5.  Setting `legacyCorruptedState­­ExceptionsPolicy` to `true` (again - although I thought I'm not dealing with corrupted-state exceptions).

All to no avail.

I've set-up [this Minimal Complete and Verifiable example](https://github.com/yaireclipse/CatchNativeExceptions) that demonstrates what I currently fail to achieve and the different attempts to solve it.

Tested with .NET Core 2.0 on Ubuntu 16.04.2 LTS (via Bash on Ubuntu on Windows) and CentOS Linux release 7.5.1804 (via Docker for Windows).

This was actually [asked in the past on Stackoverflow](https://stackoverflow.com/questions/50851329/catch-native-exception-in-dotnet-core) by @levhaikin a colleage of mine with no answers so we turn to you :) :

1.  Is my expectation correct? Meaning is there a way in .NET Core to catch an exception thrown from native code in managed code?
2.  If so what am I doing wrong? How should it be done?

Thanks
Yair</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>30/07/2018 12:41:32 AM +00:00</CreatedAt>
    <ClosedAt>30/07/2018 1:20:06 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19190</IssueLabelID>
    <Title>[x64/OSX] JitStress=2 JitStressregs=3 Hardware Intrinsics AVX AVX2 test failures</Title>
    <Description>Recent OSX PR test failed due to several Hardware Intrinsics failures on:

1.  OSX x64 JitStress=2 JitStressregs=3 
2. OSX x64 JitStress=2

https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/x64_checked_osx10.12_jitstress2_jitstressregs3_tst_prtest/2/
https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/x64_checked_osx10.12_jitstress2_flow_prtest/9/

The failures are as follows:

```
JIT/HardwareIntrinsics/X86/Avx/Avx_ro/Avx_ro.sh
JIT/HardwareIntrinsics/X86/Avx2/Avx2_ro/Avx2_ro.sh
JIT/HardwareIntrinsics/X86/Avx2/ConvertToVector256_ro/ConvertToVector256_ro.sh
```

@tannergooding @fiigii @CarolEidt </Description>
    <Title_Description>[x64/OSX] JitStress=2 JitStressregs=3 Hardware Intrinsics AVX, AVX2 test failures Recent OSX PR test failed due to several Hardware Intrinsics failures on:

1.  OSX x64 JitStress=2 JitStressregs=3 
2. OSX x64 JitStress=2

https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/x64_checked_osx10.12_jitstress2_jitstressregs3_tst_prtest/2/
https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/x64_checked_osx10.12_jitstress2_flow_prtest/9/

The failures are as follows:

```
JIT/HardwareIntrinsics/X86/Avx/Avx_ro/Avx_ro.sh
JIT/HardwareIntrinsics/X86/Avx2/Avx2_ro/Avx2_ro.sh
JIT/HardwareIntrinsics/X86/Avx2/ConvertToVector256_ro/ConvertToVector256_ro.sh
```

@tannergooding @fiigii @CarolEidt </Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>tannergooding</Assignee>
    <CreatedAt>29/07/2018 1:16:59 PM +00:00</CreatedAt>
    <ClosedAt>10/12/2018 8:59:30 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19185</IssueLabelID>
    <Title>JIT: Unnecessary field load for promoted struct</Title>
    <Description>&lt;sub&gt;tl;dr: tried to go plaid got polka dots&lt;/sub&gt;
C# code:
```cs
  public class TestCase
	{
		public int TestCaseCode()
		{
			int result = 0;
			using (var lineSource = new LineEnumeratorSource())
				foreach (var line in lineSource)
					result += line.GetString(0).Length;
			return result;
		}

		public class LineEnumeratorSource : IDisposable
		{
			public LineEnumerator GetEnumerator() =&gt; new LineEnumerator(ReadOnlySpan&lt;byte&gt;.Empty 0);
			[MethodImpl(MethodImplOptions.NoInlining)]
			public void Dispose() { }
		}

		public class StringTable
		{
			[MethodImpl(MethodImplOptions.NoInlining)]
			public string GetStringForBytes(ReadOnlySpan&lt;byte&gt; bytes) =&gt; "";
		}

		public readonly ref struct SpanLineParser
		{
			private readonly ReadOnlySpan&lt;byte&gt; _span;
			private readonly ReadOnlySpan&lt;int&gt; _colStarts;
			private readonly StringTable _stringTable;

			public SpanLineParser(ReadOnlySpan&lt;byte&gt; memory ReadOnlySpan&lt;int&gt; colStarts StringTable strings)
			{
				_span = memory; _colStarts = colStarts; _stringTable = strings;
			}

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			public string GetString(int col)
			{
				if ((uint)col + 1 &lt; (uint)_colStarts.Length)
				{
					ref int colStarts = ref MemoryMarshal.GetReference(_colStarts);
					int from = Unsafe.Add(ref colStarts col);
					int end = Unsafe.Add(ref colStarts col + 1) - 1;

					return _stringTable.GetStringForBytes(_span.Slice(from end - from));
				}
				return string.Empty;
			}
		}
		
		public ref struct LineEnumerator
		{
			private ReadOnlySpan&lt;byte&gt; _actualMemory;
			private readonly StringTable _stringTable;
			private readonly int[] _colStarts;
			private int _delimIndexCount;
			private int _nextIndex;
			public LineEnumerator(ReadOnlySpan&lt;byte&gt; memory byte delim)
			{
				_actualMemory = memory; _colStarts = new int[128]; _stringTable = new StringTable(); _delimIndexCount = 0; _nextIndex = 1;
			}

			public SpanLineParser Current =&gt; GetCurrent();

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			private SpanLineParser GetCurrent() =&gt; new SpanLineParser(_actualMemory.Slice(0 _nextIndex - 1) new ReadOnlySpan&lt;int&gt;(_colStarts 0 _delimIndexCount) _stringTable);

			[MethodImpl(MethodImplOptions.NoInlining)]
			public bool MoveNext() =&gt; false;
		}
	}
```
Selected ASM:
```asm
	xor     eaxeax
	lea     r8[rbp-0D0h]
	vxorps  xmm0xmm0xmm0
	vmovdqu xmmword ptr [r8]xmm0
	vmovdqu xmmword ptr [r8+10h]xmm0
	mov     qword ptr [r8+20h]rax
	mov     raxqword ptr [rbp-50h]
	lea     r8[rbp-0C8h]
	mov     qword ptr [r8]rdx
	mov     dword ptr [r8+8]ecx
	lea     rcx[rbp-0B8h]
	mov     qword ptr [rcx]r14
	mov     dword ptr [rcx+8]ebx
	mov     qword ptr [rbp-0D0h]rax
	vmovdqu xmm0xmmword ptr [rbp-0D0h]
	vmovdqu xmmword ptr [rbp-78h]xmm0
	vmovdqu xmm0xmmword ptr [rbp-0C0h]
	vmovdqu xmmword ptr [rbp-68h]xmm0
	mov     rcxqword ptr [rbp-0B0h]
	mov     qword ptr [rbp-58h]rcx
;     vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
;     result += line.GetString(0).Length;
	cmp     dword ptr [rbp-58h]1
	jbe     M00_L08
	lea     rcx[rbp-60h]
	mov     rdxqword ptr [rcx]
	mov     ecxdword ptr [rcx+8]
	mov     ecxdword ptr [rdx]
	mov     edxdword ptr [rdx+4]
	dec     edx
```

I see a few issues here...

1. Zeroing out the struct immediately before writing to all of the fields (pretty sure I've seen an issue for this already)
2. Copying the struct before the GetString call. It's a `readonly` struct so it shouldn't need a defensive copy but even if it did it's not referenced after the call so it wouldn't be necessary and even if it were the call is inlined so the lack of modification should be detectable.
3. I'm no x86 assembly expert but I'm pretty sure that `mov ecxdword ptr [rcx+8]` is completely pointless since it's immediately overwritten.</Description>
    <Title_Description>JIT: Unnecessary field load for promoted struct &lt;sub&gt;tl;dr: tried to go plaid got polka dots&lt;/sub&gt;
C# code:
```cs
  public class TestCase
	{
		public int TestCaseCode()
		{
			int result = 0;
			using (var lineSource = new LineEnumeratorSource())
				foreach (var line in lineSource)
					result += line.GetString(0).Length;
			return result;
		}

		public class LineEnumeratorSource : IDisposable
		{
			public LineEnumerator GetEnumerator() =&gt; new LineEnumerator(ReadOnlySpan&lt;byte&gt;.Empty 0);
			[MethodImpl(MethodImplOptions.NoInlining)]
			public void Dispose() { }
		}

		public class StringTable
		{
			[MethodImpl(MethodImplOptions.NoInlining)]
			public string GetStringForBytes(ReadOnlySpan&lt;byte&gt; bytes) =&gt; "";
		}

		public readonly ref struct SpanLineParser
		{
			private readonly ReadOnlySpan&lt;byte&gt; _span;
			private readonly ReadOnlySpan&lt;int&gt; _colStarts;
			private readonly StringTable _stringTable;

			public SpanLineParser(ReadOnlySpan&lt;byte&gt; memory ReadOnlySpan&lt;int&gt; colStarts StringTable strings)
			{
				_span = memory; _colStarts = colStarts; _stringTable = strings;
			}

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			public string GetString(int col)
			{
				if ((uint)col + 1 &lt; (uint)_colStarts.Length)
				{
					ref int colStarts = ref MemoryMarshal.GetReference(_colStarts);
					int from = Unsafe.Add(ref colStarts col);
					int end = Unsafe.Add(ref colStarts col + 1) - 1;

					return _stringTable.GetStringForBytes(_span.Slice(from end - from));
				}
				return string.Empty;
			}
		}
		
		public ref struct LineEnumerator
		{
			private ReadOnlySpan&lt;byte&gt; _actualMemory;
			private readonly StringTable _stringTable;
			private readonly int[] _colStarts;
			private int _delimIndexCount;
			private int _nextIndex;
			public LineEnumerator(ReadOnlySpan&lt;byte&gt; memory byte delim)
			{
				_actualMemory = memory; _colStarts = new int[128]; _stringTable = new StringTable(); _delimIndexCount = 0; _nextIndex = 1;
			}

			public SpanLineParser Current =&gt; GetCurrent();

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			private SpanLineParser GetCurrent() =&gt; new SpanLineParser(_actualMemory.Slice(0 _nextIndex - 1) new ReadOnlySpan&lt;int&gt;(_colStarts 0 _delimIndexCount) _stringTable);

			[MethodImpl(MethodImplOptions.NoInlining)]
			public bool MoveNext() =&gt; false;
		}
	}
```
Selected ASM:
```asm
	xor     eaxeax
	lea     r8[rbp-0D0h]
	vxorps  xmm0xmm0xmm0
	vmovdqu xmmword ptr [r8]xmm0
	vmovdqu xmmword ptr [r8+10h]xmm0
	mov     qword ptr [r8+20h]rax
	mov     raxqword ptr [rbp-50h]
	lea     r8[rbp-0C8h]
	mov     qword ptr [r8]rdx
	mov     dword ptr [r8+8]ecx
	lea     rcx[rbp-0B8h]
	mov     qword ptr [rcx]r14
	mov     dword ptr [rcx+8]ebx
	mov     qword ptr [rbp-0D0h]rax
	vmovdqu xmm0xmmword ptr [rbp-0D0h]
	vmovdqu xmmword ptr [rbp-78h]xmm0
	vmovdqu xmm0xmmword ptr [rbp-0C0h]
	vmovdqu xmmword ptr [rbp-68h]xmm0
	mov     rcxqword ptr [rbp-0B0h]
	mov     qword ptr [rbp-58h]rcx
;     vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
;     result += line.GetString(0).Length;
	cmp     dword ptr [rbp-58h]1
	jbe     M00_L08
	lea     rcx[rbp-60h]
	mov     rdxqword ptr [rcx]
	mov     ecxdword ptr [rcx+8]
	mov     ecxdword ptr [rdx]
	mov     edxdword ptr [rdx+4]
	dec     edx
```

I see a few issues here...

1. Zeroing out the struct immediately before writing to all of the fields (pretty sure I've seen an issue for this already)
2. Copying the struct before the GetString call. It's a `readonly` struct so it shouldn't need a defensive copy but even if it did it's not referenced after the call so it wouldn't be necessary and even if it were the call is inlined so the lack of modification should be detectable.
3. I'm no x86 assembly expert but I'm pretty sure that `mov ecxdword ptr [rcx+8]` is completely pointless since it's immediately overwritten.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>28/07/2018 1:55:24 AM +00:00</CreatedAt>
    <ClosedAt>7/02/2019 1:41:03 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19183</IssueLabelID>
    <Title>Create CI jobs for long running tests</Title>
    <Description>In https://github.com/dotnet/coreclr/pull/15388 a number of tests were disabled as "long running" since they exceed normal job timeouts. This means they are currently never running in some scenarios.

Create a new job or set of jobs or other mechanism to run them sometimes.
</Description>
    <Title_Description>Create CI jobs for long running tests In https://github.com/dotnet/coreclr/pull/15388 a number of tests were disabled as "long running" since they exceed normal job timeouts. This means they are currently never running in some scenarios.

Create a new job or set of jobs or other mechanism to run them sometimes.
</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>28/07/2018 12:34:11 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19182</IssueLabelID>
    <Title>[arm32] CQ: improved call sequence for JIT code</Title>
    <Description>JIT'ed code (but not crossgen/ngen code) always generates direct calls using a 10-byte movw/movt/blx sequence e.g.:
```
movw    r12 0x2305
movt    r12 0x5b21
blx     r12      // CORINFO_HELP_ASSIGN_REF
```
It should instead generate using the 4-byte `bl` instruction:
```
bl     CORINFO_HELP_ASSIGN_REF
```

The limitation is that `bl` has a relative range of 26 bits or -16777216 to 16777212 bytes from the instruction. If this range is not sufficient we need a fallback mechanism. Note that when we are generating code we don't know the address it will be placed at so we don't know what range we actually need.

One option is to implement jump stub logic for arm32 as we have for arm64/amd64. Another option is to implement a rejit mechanism where if the relocation for this call fails during `recordRelocation` then we re-jit the function preventing the JIT from using direct `bl` calls. We could either prevent it for just this function or for ever JIT-ed function thereafter in the same process.

The determination of whether a call is "close enough" is done in lowerarmarch.cpp `Lowering::IsCallTargetInRange()`. This calls `validImmForBL` which asks the VM via `CEEJitInfo::getRelocTypeHint()` whether it is ok. For ARM32 this function always says no. (For NGEN it says yes but then if we overflow the required relocs by generating a too-large ngen image it restarts the ngen process and disallows direct branches.)

It might be worth doing some investigation to see how many of these calls are likely to be possible to be made direct. Most seem to be to JIT helpers so it would require the generated code buffer to be relatively close to coreclr.dll.


category:cq
theme:optimization
skill-level:expert
cost:large</Description>
    <Title_Description>[arm32] CQ: improved call sequence for JIT code JIT'ed code (but not crossgen/ngen code) always generates direct calls using a 10-byte movw/movt/blx sequence e.g.:
```
movw    r12 0x2305
movt    r12 0x5b21
blx     r12      // CORINFO_HELP_ASSIGN_REF
```
It should instead generate using the 4-byte `bl` instruction:
```
bl     CORINFO_HELP_ASSIGN_REF
```

The limitation is that `bl` has a relative range of 26 bits or -16777216 to 16777212 bytes from the instruction. If this range is not sufficient we need a fallback mechanism. Note that when we are generating code we don't know the address it will be placed at so we don't know what range we actually need.

One option is to implement jump stub logic for arm32 as we have for arm64/amd64. Another option is to implement a rejit mechanism where if the relocation for this call fails during `recordRelocation` then we re-jit the function preventing the JIT from using direct `bl` calls. We could either prevent it for just this function or for ever JIT-ed function thereafter in the same process.

The determination of whether a call is "close enough" is done in lowerarmarch.cpp `Lowering::IsCallTargetInRange()`. This calls `validImmForBL` which asks the VM via `CEEJitInfo::getRelocTypeHint()` whether it is ok. For ARM32 this function always says no. (For NGEN it says yes but then if we overflow the required relocs by generating a too-large ngen image it restarts the ngen process and disallows direct branches.)

It might be worth doing some investigation to see how many of these calls are likely to be possible to be made direct. Most seem to be to JIT helpers so it would require the generated code buffer to be relatively close to coreclr.dll.


category:cq
theme:optimization
skill-level:expert
cost:large</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>28/07/2018 12:19:36 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19180</IssueLabelID>
    <Title>build-test - fix TestWrapper CS warnings</Title>
    <Description>@BruceForstall I have splitted my PR #19109 and here is fix for test wrappers only. You can cp or cherry-pick my commit</Description>
    <Title_Description>build-test - fix TestWrapper CS warnings @BruceForstall I have splitted my PR #19109 and here is fix for test wrappers only. You can cp or cherry-pick my commit</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>27/07/2018 11:51:44 PM +00:00</CreatedAt>
    <ClosedAt>28/07/2018 3:50:56 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19179</IssueLabelID>
    <Title>Alpine tests are all broken </Title>
    <Description>https://mc.dot.net/#/product/netcore/30/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fcli~2F/build/20180727.01

It seems some script issue:
```
2018-06-26 12:20:06991: INFO: proc(54): run_and_log_output: Output: /home/helixbot/dotnetbuild/work/6b9941f0-db03-4533-a536-11716462b85f/Work/1225557e-52ac-41f7-8b62-8428a2169d36/Unzip/runtests.sh: line 13: /home/helixbot/dotnetbuild/work/6b9941f0-db03-4533-a536-11716462b85f/Payload/corerun: not found
2018-06-26 12:20:06991: INFO: proc(54): run_and_log_output: Output: Finished running tests. Exit code = 127
```

Looking back they have been broken for at least a month so we may not be getting any Alpine coverage for that time at least in official runs.

@RussKeldorph </Description>
    <Title_Description>Alpine tests are all broken  https://mc.dot.net/#/product/netcore/30/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fcli~2F/build/20180727.01

It seems some script issue:
```
2018-06-26 12:20:06991: INFO: proc(54): run_and_log_output: Output: /home/helixbot/dotnetbuild/work/6b9941f0-db03-4533-a536-11716462b85f/Work/1225557e-52ac-41f7-8b62-8428a2169d36/Unzip/runtests.sh: line 13: /home/helixbot/dotnetbuild/work/6b9941f0-db03-4533-a536-11716462b85f/Payload/corerun: not found
2018-06-26 12:20:06991: INFO: proc(54): run_and_log_output: Output: Finished running tests. Exit code = 127
```

Looking back they have been broken for at least a month so we may not be getting any Alpine coverage for that time at least in official runs.

@RussKeldorph </Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>27/07/2018 10:31:56 PM +00:00</CreatedAt>
    <ClosedAt>2/08/2018 6:27:43 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19178</IssueLabelID>
    <Title>[Windows/arm64] Update runtime used to run tests</Title>
    <Description>As part of https://github.com/dotnet/coreclr/issues/18048 (building Windows ARM using public tools) we should also update the snapshot of VC CRT used on the test machines.

netci.groovy currently copies a specific cached copy of part of the CRT when running a Windows arm64 job:
```
if (architecture == "arm64") {
    addCommand("copy C:\\Jenkins\\vcruntime140.dll bin\\tests\\${osGroup}.${architecture}.${configuration}\\Tests\\Core_Root")
    addCommand("copy C:\\Jenkins\\vcruntime140d.dll bin\\tests\\${osGroup}.${architecture}.${configuration}\\Tests\\Core_Root")
}
```

This is needed by the `Exceptions\ForeignThread\ForeignThreadExceptions` test at minimum (which is currently disabled due to https://github.com/dotnet/coreclr/issues/10636).

We should update this to copy the entire CRT that is up-to-date with the build tools e.g.:
```
c:\Program Files (x86)\Microsoft Visual Studio\2017\Enterprise\VC\Redist\MSVC\14.14.26405\onecore\arm64\Microsoft.VC141.CRT
```

This directory contains:
```
concrt140.dll
msvcp140.dll
msvcp140_1.dll
msvcp140_2.dll
vccorlib140.dll
vcruntime140.dll
```

When I copy these to the arm64 `CORE_ROOT` then the ForeignThreadExceptions test passes.

Instead of the `C:\\Jenkins` path we should keep the entire tree so we have a version number e.g.:
```
c:\Redist\MSVC\14.14.26405\onecore\arm64\Microsoft.VC141.CRT
```
</Description>
    <Title_Description>[Windows/arm64] Update runtime used to run tests As part of https://github.com/dotnet/coreclr/issues/18048 (building Windows ARM using public tools) we should also update the snapshot of VC CRT used on the test machines.

netci.groovy currently copies a specific cached copy of part of the CRT when running a Windows arm64 job:
```
if (architecture == "arm64") {
    addCommand("copy C:\\Jenkins\\vcruntime140.dll bin\\tests\\${osGroup}.${architecture}.${configuration}\\Tests\\Core_Root")
    addCommand("copy C:\\Jenkins\\vcruntime140d.dll bin\\tests\\${osGroup}.${architecture}.${configuration}\\Tests\\Core_Root")
}
```

This is needed by the `Exceptions\ForeignThread\ForeignThreadExceptions` test at minimum (which is currently disabled due to https://github.com/dotnet/coreclr/issues/10636).

We should update this to copy the entire CRT that is up-to-date with the build tools e.g.:
```
c:\Program Files (x86)\Microsoft Visual Studio\2017\Enterprise\VC\Redist\MSVC\14.14.26405\onecore\arm64\Microsoft.VC141.CRT
```

This directory contains:
```
concrt140.dll
msvcp140.dll
msvcp140_1.dll
msvcp140_2.dll
vccorlib140.dll
vcruntime140.dll
```

When I copy these to the arm64 `CORE_ROOT` then the ForeignThreadExceptions test passes.

Instead of the `C:\\Jenkins` path we should keep the entire tree so we have a version number e.g.:
```
c:\Redist\MSVC\14.14.26405\onecore\arm64\Microsoft.VC141.CRT
```
</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>BruceForstall</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19176</IssueLabelID>
    <Title>Add comment explaining the return value of ToUpper/ToLower</Title>
    <Description>Fixes https://github.com/dotnet/corefx/issues/31340

cc @Tornhoof @JarLob</Description>
    <Title_Description>Add comment explaining the return value of ToUpper/ToLower Fixes https://github.com/dotnet/corefx/issues/31340

cc @Tornhoof @JarLob</Title_Description>
    <Label>area-System.Memory</Label>
    <Assignee>ahsonkhan</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19175</IssueLabelID>
    <Title>Reduce the scope of the CCW cache or consider lock free</Title>
    <Description>In processes that heavy use of COM can have considerable contention on the CCW cache lock.  Currently the lock is for the whole process (eg. per-appdomain).</Description>
    <Title_Description>Reduce the scope of the CCW cache or consider lock free In processes that heavy use of COM can have considerable contention on the CCW cache lock.  Currently the lock is for the whole process (eg. per-appdomain).</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jeffschwMSFT</Assignee>
    <CreatedAt>27/07/2018 8:22:08 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19174</IssueLabelID>
    <Title>Make compiler warnings as errors for test projects to enforce explicit handling of warnings during tests build</Title>
    <Description>Over last couple of months coreclr tests accumulated increasing number of compiler warnings (C# IL C++) which create a lot of noise. According to my checks there were couple of thousands of them for inner loop tests only.

There are increasing number of msbuild warnings as well however they should be fixed after projects are converted to SDK style.

One of actions which would prevent accumulation of warnings would be treating them as errors by compilers what would force everyone to handle them explicitly. Elimination of current warnings may take more than PR and it would be good to avoid them in future.

cc @BruceForstall @jkotas @AaronRobinsonMSFT @jashook @tannergooding @AndyAyersMS 
</Description>
    <Title_Description>Make compiler warnings as errors for test projects to enforce explicit handling of warnings during tests build Over last couple of months coreclr tests accumulated increasing number of compiler warnings (C# IL C++) which create a lot of noise. According to my checks there were couple of thousands of them for inner loop tests only.

There are increasing number of msbuild warnings as well however they should be fixed after projects are converted to SDK style.

One of actions which would prevent accumulation of warnings would be treating them as errors by compilers what would force everyone to handle them explicitly. Elimination of current warnings may take more than PR and it would be good to avoid them in future.

cc @BruceForstall @jkotas @AaronRobinsonMSFT @jashook @tannergooding @AndyAyersMS 
</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>27/07/2018 8:18:50 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19171</IssueLabelID>
    <Title>Lowering: Atomic ops can produce a value</Title>
    <Description>This code:
```
        if (!checkResult(Interlocked.Read(ref g_static)))
```
Results in the following assert:
```
Assertion failed 'argNode-&gt;gtRegNum == argReg' in 'NewBug:Function(long)'
```
This is because #18887 changed `OperIsStore` to include the atomic functions but `Lowering::LowerArg()` and `Lowering::CheckCallArg()` assume that stores do not produce a value so it doesn't correctly set the argument register (or build a `PUTARG_REG`) for the case where the result of an atomic op is passed to a call.</Description>
    <Title_Description>Lowering: Atomic ops can produce a value This code:
```
        if (!checkResult(Interlocked.Read(ref g_static)))
```
Results in the following assert:
```
Assertion failed 'argNode-&gt;gtRegNum == argReg' in 'NewBug:Function(long)'
```
This is because #18887 changed `OperIsStore` to include the atomic functions but `Lowering::LowerArg()` and `Lowering::CheckCallArg()` assume that stores do not produce a value so it doesn't correctly set the argument register (or build a `PUTARG_REG`) for the case where the result of an atomic op is passed to a call.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19168</IssueLabelID>
    <Title>WIP Update baseservices tests to SDK style csprojs</Title>
    <Description>Update the base services test projects to SDK style projects</Description>
    <Title_Description>WIP Update baseservices tests to SDK style csprojs Update the base services test projects to SDK style projects</Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>chsienki</Assignee>
    <CreatedAt>27/07/2018 6:31:05 PM +00:00</CreatedAt>
    <ClosedAt>1/08/2018 5:24:45 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19167</IssueLabelID>
    <Title>BuildTest fails in CI for 2.0.0</Title>
    <Description>&gt; 11:07:05 Locating coredistools.dll
11:07:05 File Not Found
11:07:05 CoreDisTools library path: 
11:07:05 Failed to locate the downloaded library: 
11:07:05 BUILDTEST: Commencing build of native test components for arm/Debug
11:07:05 BUILDTEST: Using environment: "C:\Program Files (x86)\Microsoft Visual Studio\2017\Enterprise\Common7\Tools\\..\..\VC\Auxiliary\Build\vcvarsall.bat" x86_arm
11:07:06 **********************************************************************
11:07:06 ** Visual Studio 2017 Developer Command Prompt v15.0.26730.16
11:07:06 ** Copyright (c) 2017 Microsoft Corporation
11:07:06 **********************************************************************
11:07:06 The input line is too long.
11:07:06 :export_x86
11:07:06  was unexpected at this time.
11:07:06 

https://ci.dot.net/job/dotnet_coreclr/job/release_2.0.0/job/arm_cross_release_windows_nt_prtest/

CC @joshfree </Description>
    <Title_Description>BuildTest fails in CI for 2.0.0 &gt; 11:07:05 Locating coredistools.dll
11:07:05 File Not Found
11:07:05 CoreDisTools library path: 
11:07:05 Failed to locate the downloaded library: 
11:07:05 BUILDTEST: Commencing build of native test components for arm/Debug
11:07:05 BUILDTEST: Using environment: "C:\Program Files (x86)\Microsoft Visual Studio\2017\Enterprise\Common7\Tools\\..\..\VC\Auxiliary\Build\vcvarsall.bat" x86_arm
11:07:06 **********************************************************************
11:07:06 ** Visual Studio 2017 Developer Command Prompt v15.0.26730.16
11:07:06 ** Copyright (c) 2017 Microsoft Corporation
11:07:06 **********************************************************************
11:07:06 The input line is too long.
11:07:06 :export_x86
11:07:06  was unexpected at this time.
11:07:06 

https://ci.dot.net/job/dotnet_coreclr/job/release_2.0.0/job/arm_cross_release_windows_nt_prtest/

CC @joshfree </Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>wtgodbe</Assignee>
    <CreatedAt>27/07/2018 6:29:00 PM +00:00</CreatedAt>
    <ClosedAt>3/12/2018 9:41:51 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19166</IssueLabelID>
    <Title>Suggested enhancements to CheckProjects</Title>
    <Description>The CheckProjects jit test is intended to verify that all the jit test project files meet our expectations:

* test suffix convention (_d _do etc) matches projects settings
* the IL generated for the test does not depend on the ambient build environment

#19132 points out some example where the optimization settings were not checked
#19131 some examples where the suffix convention was misused

We should enhance CheckProjects to catch those cases.

#19165 is removing check exclusions for the codegen bring up tests so all jit tests (modulo the bugs above) should now conform.

In addition because it can rewrite project files we might want to enhance it so that all projects have a unique GUID.

If / when we convert tests over to using SDK style projects we should make corresponding updates to the tool.

category:testing
theme:testing
skill-level:beginner
cost:small</Description>
    <Title_Description>Suggested enhancements to CheckProjects The CheckProjects jit test is intended to verify that all the jit test project files meet our expectations:

* test suffix convention (_d _do etc) matches projects settings
* the IL generated for the test does not depend on the ambient build environment

#19132 points out some example where the optimization settings were not checked
#19131 some examples where the suffix convention was misused

We should enhance CheckProjects to catch those cases.

#19165 is removing check exclusions for the codegen bring up tests so all jit tests (modulo the bugs above) should now conform.

In addition because it can rewrite project files we might want to enhance it so that all projects have a unique GUID.

If / when we convert tests over to using SDK style projects we should make corresponding updates to the tool.

category:testing
theme:testing
skill-level:beginner
cost:small</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
    <CreatedAt>27/07/2018 6:07:26 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19164</IssueLabelID>
    <Title>Interop\COM\NETClients\Primitives\NETClientPrimitives fails on r2r and some jitstress jobs</Title>
    <Description>- See PR https://github.com/dotnet/coreclr/pull/19122
- Example: https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_checked_windows_nt_r2r_prtest/70/

```
10:12:11          "D:\j\workspace\x64_checked_w---962da9ce\tests\..\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root\corerun.exe" NETClientPrimitives.exe 
10:12:11         Numeric RNG seed: 37
10:12:11         Test Failure: System.Runtime.InteropServices.COMException (0x80040154): Retrieving the COM class factory for component with CLSID {53169A33-E85D-4E3C-B668-24E438D0929B} failed due to the following error: 80040154 Class not registered (Exception from HRESULT: 0x80040154 (REGDB_E_CLASSNOTREG)).
10:12:11 
      Interop_COM._NETClients_Primitives_NETClientPrimitives_NETClientPrimitives_._NETClients_Primitives_NETClientPrimitives_NETClientPrimitives_cmd [FAIL]
10:12:11            at NetClient.NumericTests..ctor(Int32 seed) in D:\j\workspace\x64_checked_w---962da9ce\tests\src\Interop\COM\NETClients\Primitives\NumericTests.cs:line 22
10:12:11            at NetClient.Program.Main(String[] doNotUse) in D:\j\workspace\x64_checked_w---962da9ce\tests\src\Interop\COM\NETClients\Primitives\Program.cs:line 15
10:12:11         Expected: 100
10:12:11         Actual: 101
10:12:11         END EXECUTION - FAILED
10:12:11         FAILED
10:12:11         Test Harness Exitcode is : 1
10:12:11         
10:12:11   To run the test:
10:12:11   &gt; set CORE_ROOT=D:\j\workspace\x64_checked_w---962da9ce\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root
10:12:11   &gt; D:\j\workspace\x64_checked_w---962da9ce\bin\tests\Windows_NT.x64.Checked\Interop\COM\NETClients\Primitives\NETClientPrimitives\NETClientPrimitives.cmd
10:12:11   
10:12:11         Expected: True
10:12:11         Actual:   False
10:12:11         Stack Trace:
10:12:11           D:\j\workspace\x64_checked_w---962da9ce\bin\tests\Windows_NT.x64.Checked\TestWrappers\Interop.COM\Interop.COM.XUnitWrapper.cs(1090): at Interop_COM._NETClients_Primitives_NETClientPrimitives_NETClientPrimitives_._NETClients_Primitives_NETClientPrimitives_NETClientPrimitives_cmd()
```

Failed in the following jobs:
```
Windows_NT x64 Checked R2R Build &amp; Test
Windows_NT x64 Checked R2R jitstress1 Build &amp; Test
Windows_NT x64 Checked R2R jitstress1_tiered Build &amp; Test
Windows_NT x64 Checked R2R jitstress2 Build &amp; Test
Windows_NT x64 Checked R2R jitstress2_tiered Build &amp; Test
Windows_NT x64 Checked R2R no_tiered_compilation Build &amp; Test
Windows_NT x64_arm64_altjit Checked jitstress1
Windows_NT x64_arm64_altjit Checked jitstress1_tiered
Windows_NT x64_arm64_altjit Checked jitstress2
Windows_NT x64_arm64_altjit Checked jitstress2_tiered
Windows_NT x64_arm64_altjit Checked r2r
Windows_NT x64_arm64_altjit Checked r2r_jitstress1
Windows_NT x64_arm64_altjit Checked r2r_jitstress1_tiered
Windows_NT x64_arm64_altjit Checked r2r_jitstress2
Windows_NT x64_arm64_altjit Checked r2r_jitstress2_tiered
Windows_NT x64_arm64_altjit Checked r2r_no_tiered_compilation
Windows_NT x86 Checked R2R Build &amp; Test
Windows_NT x86 Checked R2R jitstress1 Build &amp; Test
Windows_NT x86 Checked R2R jitstress1_tiered Build &amp; Test
Windows_NT x86 Checked R2R jitstress2 Build &amp; Test
Windows_NT x86 Checked R2R jitstress2_tiered Build &amp; Test
Windows_NT x86 Checked R2R no_tiered_compilation Build &amp; Test
Windows_NT x86_arm_altjit Checked r2r
Windows_NT x86_arm_altjit Checked r2r_jitstress1
Windows_NT x86_arm_altjit Checked r2r_jitstress1_tiered
Windows_NT x86_arm_altjit Checked r2r_jitstress2
```

@AaronRobinsonMSFT this test did not seem to get disabled in these jobs by https://github.com/dotnet/coreclr/pull/19047 though I'm not sure if it's related.

@BruceForstall is there something special about the r2r and jitstress jobs do they run in a particular mode? Is there a way to disable a test from those jobs?</Description>
    <Title_Description>Interop\COM\NETClients\Primitives\NETClientPrimitives fails on r2r and some jitstress jobs - See PR https://github.com/dotnet/coreclr/pull/19122
- Example: https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_checked_windows_nt_r2r_prtest/70/

```
10:12:11          "D:\j\workspace\x64_checked_w---962da9ce\tests\..\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root\corerun.exe" NETClientPrimitives.exe 
10:12:11         Numeric RNG seed: 37
10:12:11         Test Failure: System.Runtime.InteropServices.COMException (0x80040154): Retrieving the COM class factory for component with CLSID {53169A33-E85D-4E3C-B668-24E438D0929B} failed due to the following error: 80040154 Class not registered (Exception from HRESULT: 0x80040154 (REGDB_E_CLASSNOTREG)).
10:12:11 
      Interop_COM._NETClients_Primitives_NETClientPrimitives_NETClientPrimitives_._NETClients_Primitives_NETClientPrimitives_NETClientPrimitives_cmd [FAIL]
10:12:11            at NetClient.NumericTests..ctor(Int32 seed) in D:\j\workspace\x64_checked_w---962da9ce\tests\src\Interop\COM\NETClients\Primitives\NumericTests.cs:line 22
10:12:11            at NetClient.Program.Main(String[] doNotUse) in D:\j\workspace\x64_checked_w---962da9ce\tests\src\Interop\COM\NETClients\Primitives\Program.cs:line 15
10:12:11         Expected: 100
10:12:11         Actual: 101
10:12:11         END EXECUTION - FAILED
10:12:11         FAILED
10:12:11         Test Harness Exitcode is : 1
10:12:11         
10:12:11   To run the test:
10:12:11   &gt; set CORE_ROOT=D:\j\workspace\x64_checked_w---962da9ce\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root
10:12:11   &gt; D:\j\workspace\x64_checked_w---962da9ce\bin\tests\Windows_NT.x64.Checked\Interop\COM\NETClients\Primitives\NETClientPrimitives\NETClientPrimitives.cmd
10:12:11   
10:12:11         Expected: True
10:12:11         Actual:   False
10:12:11         Stack Trace:
10:12:11           D:\j\workspace\x64_checked_w---962da9ce\bin\tests\Windows_NT.x64.Checked\TestWrappers\Interop.COM\Interop.COM.XUnitWrapper.cs(1090): at Interop_COM._NETClients_Primitives_NETClientPrimitives_NETClientPrimitives_._NETClients_Primitives_NETClientPrimitives_NETClientPrimitives_cmd()
```

Failed in the following jobs:
```
Windows_NT x64 Checked R2R Build &amp; Test
Windows_NT x64 Checked R2R jitstress1 Build &amp; Test
Windows_NT x64 Checked R2R jitstress1_tiered Build &amp; Test
Windows_NT x64 Checked R2R jitstress2 Build &amp; Test
Windows_NT x64 Checked R2R jitstress2_tiered Build &amp; Test
Windows_NT x64 Checked R2R no_tiered_compilation Build &amp; Test
Windows_NT x64_arm64_altjit Checked jitstress1
Windows_NT x64_arm64_altjit Checked jitstress1_tiered
Windows_NT x64_arm64_altjit Checked jitstress2
Windows_NT x64_arm64_altjit Checked jitstress2_tiered
Windows_NT x64_arm64_altjit Checked r2r
Windows_NT x64_arm64_altjit Checked r2r_jitstress1
Windows_NT x64_arm64_altjit Checked r2r_jitstress1_tiered
Windows_NT x64_arm64_altjit Checked r2r_jitstress2
Windows_NT x64_arm64_altjit Checked r2r_jitstress2_tiered
Windows_NT x64_arm64_altjit Checked r2r_no_tiered_compilation
Windows_NT x86 Checked R2R Build &amp; Test
Windows_NT x86 Checked R2R jitstress1 Build &amp; Test
Windows_NT x86 Checked R2R jitstress1_tiered Build &amp; Test
Windows_NT x86 Checked R2R jitstress2 Build &amp; Test
Windows_NT x86 Checked R2R jitstress2_tiered Build &amp; Test
Windows_NT x86 Checked R2R no_tiered_compilation Build &amp; Test
Windows_NT x86_arm_altjit Checked r2r
Windows_NT x86_arm_altjit Checked r2r_jitstress1
Windows_NT x86_arm_altjit Checked r2r_jitstress1_tiered
Windows_NT x86_arm_altjit Checked r2r_jitstress2
```

@AaronRobinsonMSFT this test did not seem to get disabled in these jobs by https://github.com/dotnet/coreclr/pull/19047 though I'm not sure if it's related.

@BruceForstall is there something special about the r2r and jitstress jobs do they run in a particular mode? Is there a way to disable a test from those jobs?</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19163</IssueLabelID>
    <Title>Temporarily flag a SIMD test as optimization-sensitive</Title>
    <Description>The test runs in several PR-triggered jobs. It fails with minopts and once tiering is enabled it would fail in every PR. See https://github.com/dotnet/coreclr/issues/19124.

CC @dotnet/jit-contrib </Description>
    <Title_Description>Temporarily flag a SIMD test as optimization-sensitive The test runs in several PR-triggered jobs. It fails with minopts and once tiering is enabled it would fail in every PR. See https://github.com/dotnet/coreclr/issues/19124.

CC @dotnet/jit-contrib </Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19161</IssueLabelID>
    <Title>Finalizer is called on live object</Title>
    <Description>[This test](https://github.com/Spreads/Spreads/blob/d5a9239cbea0df292c14abaac783ecd63efed9d7/tests/Spreads.Core.Tests/Cursors/AsyncCursorTests.cs#L452-L530) fails not always but reliably when [run multiple times in a loop](https://github.com/Spreads/Spreads/blob/d5a9239cbea0df292c14abaac783ecd63efed9d7/tests/Spreads.Core.Run/Program.cs#L10-L17).

The [problem I observe](https://github.com/Spreads/Spreads/blob/d5a9239cbea0df292c14abaac783ecd63efed9d7/tests/Spreads.Core.Tests/Cursors/AsyncCursorTests.cs#L499) is that an object is finalized (and GCed if I comment the finalizer away) when there are strong references to it from within async task that is being awaited later. [Here](https://github.com/Spreads/Spreads/blob/d5a9239cbea0df292c14abaac783ecd63efed9d7/tests/Spreads.Core.Tests/Cursors/AsyncCursorTests.cs#L512) and [here](https://github.com/Spreads/Spreads/blob/d5a9239cbea0df292c14abaac783ecd63efed9d7/tests/Spreads.Core.Tests/Cursors/AsyncCursorTests.cs#L514) there are references that cause side effects (`Console.Write`) and dereference the object to return a value outside the task. Optimizer should not be allowed to kill the object earlier that this but the behavior remains even in debug build with F5. The [async loop](https://github.com/Spreads/Spreads/blob/d5a9239cbea0df292c14abaac783ecd63efed9d7/tests/Spreads.Core.Tests/Cursors/AsyncCursorTests.cs#L503-L510) hangs I see that the cursor is finalized [here](https://github.com/Spreads/Spreads/blob/d5a9239cbea0df292c14abaac783ecd63efed9d7/src/Spreads.Core/AsyncCursor.cs#L905) (even breakpoint is hit in debug mode in the finalizer).

This behavior is visible only when I explicitly call `GC.Collect(0+ GCCollectionMode.Default false/true);` from another thread than the object is referenced from (the more aggressive GC.Collect params the earlier it happens). However the code is optimized for allocations (the object in question is `IValueTaskSource`) and probably I just do not see normal GCs during small tests. Also I often do call GC0 explicitly in real code to avoid GC1 and keep memory low [my experiments showed](https://github.com/aspnet/KestrelHttpServer/issues/2620#issuecomment-393009892) that pauses are much shorter and GC1 is much rarer with explicit calls to GC0. -so the scenario is quite real in production code.

 If I declare the cursor outside a task like [here](https://github.com/Spreads/Spreads/blob/d5a9239cbea0df292c14abaac783ecd63efed9d7/tests/Spreads.Core.Tests/Cursors/AsyncCursorTests.cs#L490) the problem disappears.

There is [a place where I create a `WeakReference`](https://github.com/Spreads/Spreads/blob/d5a9239cbea0df292c14abaac783ecd63efed9d7/src/Spreads.Core/Series'2%20(Base).cs#L1088) to that object if that may be relevant maybe it somehow affects GC.

To reproduce clone the repo with submodules and hit F5 to run `Spreads.Core.Run` project. Expected behavior is that it prints `Finished press enter to exit...` but now it prints `Called AsyncCursor finalizer` and hangs after several iterations.

Is this a bug in GC or some weird feature?

Tested with `netcoreapp2.1` (`both with 2.1.300` and `2.1.400-preview-009063` set via global.json on Windows and Linux in Docker) and with `net462`. 

```
[Test]
public async Task CouldReadDataStreamWhileWritingFromManyThreads()
{
    var map = new SortedMap&lt;int int&gt;();

    var count = 10_000;
    var rounds = 100;

    var writeTask = Task.Run(async () =&gt;
    {
        for (int j = 0; j &lt; rounds; j++)
        {
            var t1 = Task.Run(async () =&gt;
            {
                //using (Benchmark.Run("Write" count true))
                {
                    for (int i = j * count; i &lt; (j + 1) * count; i++)
                    {
                        await map.TryAddLast(i i);
                    }
                }
                
                // even with 0 and false AsyncCursor it is finalized but needs more iterations. With Optimized works OK
                GC.Collect(1 GCCollectionMode.Default true);

                // `using (Benchmark.Run...` does this found it during benchmarking
                //GC.Collect(2 GCCollectionMode.Forced true);
                // GC.WaitForPendingFinalizers();
                //GC.Collect(2 GCCollectionMode.Forced true);
                //GC.WaitForPendingFinalizers();
            });
            await t1;
        }
    });

    var cnt = 0L;

    // if we put it here everything works as expected
    // ICursor&lt;int int&gt; cursor;

    var readTask = Task.Run(async () =&gt;
    {
        var lastKey1 = 0;
        for (int r = 0; r &lt; 1; r++)
        {
            // using (Benchmark.Run("Read" count true))
            {
                // PROBLEM: cursor is collected and finalized before async loop finishes
                ICursor&lt;int int&gt; cursor;
                using (cursor = map.GetCursor())
                {
                    while (await cursor.MoveNextAsync())
                    {
                        Interlocked.Increment(ref cnt);
                        if (cnt == count * rounds)
                        {
                            Console.WriteLine("Reader reached the end waiting for complete signal");
                        }
                    }
                    // here is a strong reference to cursor with side effects of printing to console
                    Console.WriteLine("Last value: " + cursor.Current.Key);
                    // another strong reference after while loop we dereference it's value and return from task
                    lastKey1 = cursor.CurrentKey;
                }
            }
        }

        return lastKey1;
    });

    writeTask.Wait();
    await map.Complete();
    Console.WriteLine("Read after complete:" + Interlocked.Read(ref cnt));
    var lastKey = await readTask;
    Console.WriteLine("Last key: " + lastKey);
    // Benchmark.Dump();
    map.Dispose();
}

```
</Description>
    <Title_Description>Finalizer is called on live object [This test](https://github.com/Spreads/Spreads/blob/d5a9239cbea0df292c14abaac783ecd63efed9d7/tests/Spreads.Core.Tests/Cursors/AsyncCursorTests.cs#L452-L530) fails not always but reliably when [run multiple times in a loop](https://github.com/Spreads/Spreads/blob/d5a9239cbea0df292c14abaac783ecd63efed9d7/tests/Spreads.Core.Run/Program.cs#L10-L17).

The [problem I observe](https://github.com/Spreads/Spreads/blob/d5a9239cbea0df292c14abaac783ecd63efed9d7/tests/Spreads.Core.Tests/Cursors/AsyncCursorTests.cs#L499) is that an object is finalized (and GCed if I comment the finalizer away) when there are strong references to it from within async task that is being awaited later. [Here](https://github.com/Spreads/Spreads/blob/d5a9239cbea0df292c14abaac783ecd63efed9d7/tests/Spreads.Core.Tests/Cursors/AsyncCursorTests.cs#L512) and [here](https://github.com/Spreads/Spreads/blob/d5a9239cbea0df292c14abaac783ecd63efed9d7/tests/Spreads.Core.Tests/Cursors/AsyncCursorTests.cs#L514) there are references that cause side effects (`Console.Write`) and dereference the object to return a value outside the task. Optimizer should not be allowed to kill the object earlier that this but the behavior remains even in debug build with F5. The [async loop](https://github.com/Spreads/Spreads/blob/d5a9239cbea0df292c14abaac783ecd63efed9d7/tests/Spreads.Core.Tests/Cursors/AsyncCursorTests.cs#L503-L510) hangs I see that the cursor is finalized [here](https://github.com/Spreads/Spreads/blob/d5a9239cbea0df292c14abaac783ecd63efed9d7/src/Spreads.Core/AsyncCursor.cs#L905) (even breakpoint is hit in debug mode in the finalizer).

This behavior is visible only when I explicitly call `GC.Collect(0+ GCCollectionMode.Default false/true);` from another thread than the object is referenced from (the more aggressive GC.Collect params the earlier it happens). However the code is optimized for allocations (the object in question is `IValueTaskSource`) and probably I just do not see normal GCs during small tests. Also I often do call GC0 explicitly in real code to avoid GC1 and keep memory low [my experiments showed](https://github.com/aspnet/KestrelHttpServer/issues/2620#issuecomment-393009892) that pauses are much shorter and GC1 is much rarer with explicit calls to GC0. -so the scenario is quite real in production code.

 If I declare the cursor outside a task like [here](https://github.com/Spreads/Spreads/blob/d5a9239cbea0df292c14abaac783ecd63efed9d7/tests/Spreads.Core.Tests/Cursors/AsyncCursorTests.cs#L490) the problem disappears.

There is [a place where I create a `WeakReference`](https://github.com/Spreads/Spreads/blob/d5a9239cbea0df292c14abaac783ecd63efed9d7/src/Spreads.Core/Series'2%20(Base).cs#L1088) to that object if that may be relevant maybe it somehow affects GC.

To reproduce clone the repo with submodules and hit F5 to run `Spreads.Core.Run` project. Expected behavior is that it prints `Finished press enter to exit...` but now it prints `Called AsyncCursor finalizer` and hangs after several iterations.

Is this a bug in GC or some weird feature?

Tested with `netcoreapp2.1` (`both with 2.1.300` and `2.1.400-preview-009063` set via global.json on Windows and Linux in Docker) and with `net462`. 

```
[Test]
public async Task CouldReadDataStreamWhileWritingFromManyThreads()
{
    var map = new SortedMap&lt;int int&gt;();

    var count = 10_000;
    var rounds = 100;

    var writeTask = Task.Run(async () =&gt;
    {
        for (int j = 0; j &lt; rounds; j++)
        {
            var t1 = Task.Run(async () =&gt;
            {
                //using (Benchmark.Run("Write" count true))
                {
                    for (int i = j * count; i &lt; (j + 1) * count; i++)
                    {
                        await map.TryAddLast(i i);
                    }
                }
                
                // even with 0 and false AsyncCursor it is finalized but needs more iterations. With Optimized works OK
                GC.Collect(1 GCCollectionMode.Default true);

                // `using (Benchmark.Run...` does this found it during benchmarking
                //GC.Collect(2 GCCollectionMode.Forced true);
                // GC.WaitForPendingFinalizers();
                //GC.Collect(2 GCCollectionMode.Forced true);
                //GC.WaitForPendingFinalizers();
            });
            await t1;
        }
    });

    var cnt = 0L;

    // if we put it here everything works as expected
    // ICursor&lt;int int&gt; cursor;

    var readTask = Task.Run(async () =&gt;
    {
        var lastKey1 = 0;
        for (int r = 0; r &lt; 1; r++)
        {
            // using (Benchmark.Run("Read" count true))
            {
                // PROBLEM: cursor is collected and finalized before async loop finishes
                ICursor&lt;int int&gt; cursor;
                using (cursor = map.GetCursor())
                {
                    while (await cursor.MoveNextAsync())
                    {
                        Interlocked.Increment(ref cnt);
                        if (cnt == count * rounds)
                        {
                            Console.WriteLine("Reader reached the end waiting for complete signal");
                        }
                    }
                    // here is a strong reference to cursor with side effects of printing to console
                    Console.WriteLine("Last value: " + cursor.Current.Key);
                    // another strong reference after while loop we dereference it's value and return from task
                    lastKey1 = cursor.CurrentKey;
                }
            }
        }

        return lastKey1;
    });

    writeTask.Wait();
    await map.Complete();
    Console.WriteLine("Read after complete:" + Interlocked.Read(ref cnt));
    var lastKey = await readTask;
    Console.WriteLine("Last key: " + lastKey);
    // Benchmark.Dump();
    map.Dispose();
}

```
</Title_Description>
    <Label>area-GC</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>27/07/2018 11:35:32 AM +00:00</CreatedAt>
    <ClosedAt>3/08/2018 2:39:15 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19159</IssueLabelID>
    <Title>Temporary path being defined as C:\Windows.</Title>
    <Description>Oddly today while working me and a co-worker experienced a strange encounter where our lockfile was attempting to be created in C:\Windows while running the application as the current logged on user.

We expected this to be a problem with my environment variables however they appear to be set properly.

![image](https://user-images.githubusercontent.com/33913289/43299462-537f9544-9128-11e8-89e6-a534ccea902a.png)


This is the logs from our ASP.NET Core Application.
```csharp
Unhandled Exception: System.UnauthorizedAccessException: Access to the path 'C:\WINDOWS\spectero-startup-2018-7-27-4' is denied.
   at System.IO.FileStream.ValidateFileHandle(SafeFileHandle fileHandle)
   at System.IO.FileStream.CreateFileOpenHandle(FileMode mode FileShare share FileOptions options)
   at System.IO.FileStream..ctor(String path FileMode mode FileAccess access FileShare share Int32 bufferSize FileOptions options)
   at System.IO.FileStream..ctor(String path FileMode mode FileAccess access FileShare share Int32 bufferSize)
   at System.IO.File.Create(String path)
```

And the code we are utilizing to generate the path programamtically:
```csharp
        public static string GetCurrentStartupMarker()
        {
            var currentTIme = DateTime.UtcNow;
            var minuteMarker = currentTIme.Minute.ToString()[0];

            return Path.Combine(Path.GetTempPath()
                $"spectero-startup-{currentTIme.Year}-{currentTIme.Month}-{currentTIme.Day}-{minuteMarker}");
        }

        public static bool ManageStartupMarker(bool delete = false)
        {
            var marker = GetCurrentStartupMarker();

            if (delete)
            {
                if (File.Exists(marker))
                    File.Delete(marker);
                else
                    return false;
            }
            else
            {
                File.Create(marker).Dispose();
            }

            return true;
        }
```
---

Environment Information:
Windows 10 (10.0.17134 Build 17134)
Dotnet Core/ASP Version: 2.1.2

---

If there's any more information @Wintereise or I can provide we would be glad to help out in solving this issue.</Description>
    <Title_Description>Temporary path being defined as C:\Windows. Oddly today while working me and a co-worker experienced a strange encounter where our lockfile was attempting to be created in C:\Windows while running the application as the current logged on user.

We expected this to be a problem with my environment variables however they appear to be set properly.

![image](https://user-images.githubusercontent.com/33913289/43299462-537f9544-9128-11e8-89e6-a534ccea902a.png)


This is the logs from our ASP.NET Core Application.
```csharp
Unhandled Exception: System.UnauthorizedAccessException: Access to the path 'C:\WINDOWS\spectero-startup-2018-7-27-4' is denied.
   at System.IO.FileStream.ValidateFileHandle(SafeFileHandle fileHandle)
   at System.IO.FileStream.CreateFileOpenHandle(FileMode mode FileShare share FileOptions options)
   at System.IO.FileStream..ctor(String path FileMode mode FileAccess access FileShare share Int32 bufferSize FileOptions options)
   at System.IO.FileStream..ctor(String path FileMode mode FileAccess access FileShare share Int32 bufferSize)
   at System.IO.File.Create(String path)
```

And the code we are utilizing to generate the path programamtically:
```csharp
        public static string GetCurrentStartupMarker()
        {
            var currentTIme = DateTime.UtcNow;
            var minuteMarker = currentTIme.Minute.ToString()[0];

            return Path.Combine(Path.GetTempPath()
                $"spectero-startup-{currentTIme.Year}-{currentTIme.Month}-{currentTIme.Day}-{minuteMarker}");
        }

        public static bool ManageStartupMarker(bool delete = false)
        {
            var marker = GetCurrentStartupMarker();

            if (delete)
            {
                if (File.Exists(marker))
                    File.Delete(marker);
                else
                    return false;
            }
            else
            {
                File.Create(marker).Dispose();
            }

            return true;
        }
```
---

Environment Information:
Windows 10 (10.0.17134 Build 17134)
Dotnet Core/ASP Version: 2.1.2

---

If there's any more information @Wintereise or I can provide we would be glad to help out in solving this issue.</Title_Description>
    <Label>os-windows</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>27/07/2018 3:12:57 AM +00:00</CreatedAt>
    <ClosedAt>27/07/2018 4:29:30 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19157</IssueLabelID>
    <Title>Add support for writing EventPipeEvents to ProfAPI</Title>
    <Description>This augments the EventPipe framework to send data to the Profiler APIs in addition to any other receivers that may be configured.

This change does not add or remove any requirement on how the eventing system is initialized. Although it does provide a provision to the Profiler APIs that despite whatever the eventing system may be initialized to it can eject itself when it needs to.</Description>
    <Title_Description>Add support for writing EventPipeEvents to ProfAPI This augments the EventPipe framework to send data to the Profiler APIs in addition to any other receivers that may be configured.

This change does not add or remove any requirement on how the eventing system is initialized. Although it does provide a provision to the Profiler APIs that despite whatever the eventing system may be initialized to it can eject itself when it needs to.</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>brianrob</Assignee>
    <CreatedAt>27/07/2018 12:39:04 AM +00:00</CreatedAt>
    <ClosedAt>5/11/2019 6:26:33 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19152</IssueLabelID>
    <Title>Enable Tiered Compilation by default</Title>
    <Description>1) Changes the default state of the tiered compilation feature check to be ON BY DEFAULT
2) Removed comments about the source about this being a work in progress. Although it will surely continue to evolve and improve remaining issues would be better tracked in our issue tracking system with the same default presumption as other runtime features - assume it works unless noted otherwise.
3) Adjusts a number of tests and automated scripts that made assumptions that the default setting of this feature is off.
4) Stop accepting the deprecated env var COMPLUS_EXPERIMENTAL_TieredCompilation. I'm not aware it has any remaining usage but if so we're going to find out.</Description>
    <Title_Description>Enable Tiered Compilation by default 1) Changes the default state of the tiered compilation feature check to be ON BY DEFAULT
2) Removed comments about the source about this being a work in progress. Although it will surely continue to evolve and improve remaining issues would be better tracked in our issue tracking system with the same default presumption as other runtime features - assume it works unless noted otherwise.
3) Adjusts a number of tests and automated scripts that made assumptions that the default setting of this feature is off.
4) Stop accepting the deprecated env var COMPLUS_EXPERIMENTAL_TieredCompilation. I'm not aware it has any remaining usage but if so we're going to find out.</Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19150</IssueLabelID>
    <Title>Enable Tiered Compilation by default</Title>
    <Description>1) Changes the default state of the tiered compilation feature check to be ON BY DEFAULT
2) Removed comments about the source about this being a work in progress. Although it will surely continue to evolve and improve remaining issues would be better tracked in our issue tracking system with the same default presumption as other runtime features - assume it works unless noted otherwise.
3) Adjusts a number of tests and automated scripts that made assumptions that the default setting of this feature is off.
4) Stop accepting the deprecated env var COMPLUS_EXPERIMENTAL_TieredCompilation. I'm not aware it has any remaining usage but if so we're going to find out.</Description>
    <Title_Description>Enable Tiered Compilation by default 1) Changes the default state of the tiered compilation feature check to be ON BY DEFAULT
2) Removed comments about the source about this being a work in progress. Although it will surely continue to evolve and improve remaining issues would be better tracked in our issue tracking system with the same default presumption as other runtime features - assume it works unless noted otherwise.
3) Adjusts a number of tests and automated scripts that made assumptions that the default setting of this feature is off.
4) Stop accepting the deprecated env var COMPLUS_EXPERIMENTAL_TieredCompilation. I'm not aware it has any remaining usage but if so we're going to find out.</Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19149</IssueLabelID>
    <Title>Breaking change in netcoreapp2.1 (possibly JIT bug?) re fixed buffers</Title>
    <Description>New in netcoreapp2.1 (doesn't impact netcoreapp2.0 or net47)

Full repro below; synopsis: fixed buffers go pretty wild when used on a field in a key in a `Dictionary&lt;TKeyTValue&gt;` (and possibly some other scenarios) causing:

- items not being found even though it can be shown (by looking via `foreach`) that `GetHashCode()` and `Equals()` are working correctly
- data corruption - in particular when more than one element in the fixed buffer is involved (so... most of the time; a fixed buffer of length 1 isn't very useful)

Since this could affect many more scenarios I'd wager this is a pretty serious regression.

Code:

```c#
// #define EXPLICIT_FIELDS

// Hypothesis: JIT bug affecting how fixed buffers are handled
//
// Affects: netcoreapp2.1 debug and release
// Does not seem to affect: netcoreapp2.0 net47
//
// the idea behind CommandBytes is that it is a fixed-sized string-like thing
// used for matching commands; it is *implemented* as a fixed buffer
// of **longs** but: the first byte of the first element is coerced into
// a byte and used to store the length; the actual text payload (ASCII)
// starts at the second byte of the first element
//
// as far as I can tell it is all validly implemented and it works fine
// in isolation however: when used in a dictionary it goes bad;
// - items not being found despite having GetHashCode and Equals match
// - items over 1 chunk size becoming corrupted (see: ToInnerString)
//
// however if I replace the fixed buffer with the same number of
// regular fields (_c0_c1_c2) and use *all the same code* it
// all works correctly! to see this define EXPLICIT_FIELDS
//
// The "Main" method populates a dictionary in the expected way
// then attempts to find things - either via TryGetValue or manually;
// it then compares the contents
//
// Yes this code is evil; it is for a very specific optimized scenario.

using System;
using System.Collections.Generic;
using System.Text;

unsafe struct CommandBytes : IEquatable&lt;CommandBytes&gt;
{
    private const int ChunkLength = 3;
    public const int MaxLength = (ChunkLength * 8) - 1;

#if !EXPLICIT_FIELDS
    fixed long _chunks[ChunkLength];
#else
    long _c0 _c1 _c2;
#endif
    public override int GetHashCode()
    {
#if !EXPLICIT_FIELDS
        fixed (long* lPtr = _chunks)
#else
        fixed (long* lPtr = &amp;_c0)
#endif
        {
            var hashCode = -1923861349;
            long* x = lPtr;
            for (int i = 0; i &lt; ChunkLength; i++)
            {
                hashCode = hashCode * -1521134295 + (*x++).GetHashCode();
            }
            return hashCode;
        }
    }

    public override string ToString()
    {
#if !EXPLICIT_FIELDS
        fixed (long* lPtr = _chunks)
#else
        fixed (long* lPtr = &amp;_c0)
#endif
        {
            var bPtr = (byte*)lPtr;
            return Encoding.ASCII.GetString(bPtr + 1 bPtr[0]);
        }
    }
    public int Length
    {
        get
        {
#if !EXPLICIT_FIELDS
            fixed (long* lPtr = _chunks)
#else
            fixed (long* lPtr = &amp;_c0)
#endif
            {
                var bPtr = (byte*)lPtr;
                return bPtr[0];
            }
        }
    }
    public byte this[int index]
    {
        get
        {
#if !EXPLICIT_FIELDS
            fixed (long* lPtr = _chunks)
#else
            fixed (long* lPtr = &amp;_c0)
#endif
            {
                byte* bPtr = (byte*)lPtr;
                int len = bPtr[0];
                if (index &lt; 0 || index &gt;= len) throw new IndexOutOfRangeException();
                return bPtr[index + 1];
            }
        }
    }

    public CommandBytes(string value)
    {
        value = value.ToLowerInvariant();
        var len = Encoding.ASCII.GetByteCount(value);
        if (len &gt; MaxLength) throw new ArgumentOutOfRangeException("Maximum command length exceeed");

#if !EXPLICIT_FIELDS
        fixed (long* lPtr = _chunks)
#else
        _c0 = _c1 = _c2 = 0L;
        fixed (long* lPtr = &amp;_c0)
#endif
        {
            Clear(lPtr);
            byte* bPtr = (byte*)lPtr;
            bPtr[0] = (byte)len;
            fixed (char* cPtr = value)
            {
                Encoding.ASCII.GetBytes(cPtr value.Length bPtr + 1 len);
            }
        }
    }
    public override bool Equals(object obj) =&gt; obj is CommandBytes cb &amp;&amp; Equals(cb);

    public string ToInnerString()
    {
#if !EXPLICIT_FIELDS
        fixed (long* lPtr = _chunks)
#else
        fixed (long* lPtr = &amp;_c0)
#endif
        {
            long* x = lPtr;
            var sb = new StringBuilder();
            for (int i = 0; i &lt; ChunkLength; i++)
            {
                if (sb.Length != 0) sb.Append('');
                sb.Append(*x++);
            }
            return sb.ToString();
        }
    }
    public bool Equals(CommandBytes value)
    {
#if !EXPLICIT_FIELDS
        fixed (long* lPtr = _chunks)
#else
        fixed (long* lPtr = &amp;_c0)
#endif
        {
            long* x = lPtr;
#if !EXPLICIT_FIELDS
            long* y = value._chunks;
#else
            long* y = &amp;value._c0;
#endif
            for (int i = 0; i &lt; ChunkLength; i++)
            {
                if (*x++ != *y++) return false;
            }
            return true;
        }
    }
    private static void Clear(long* ptr)
    {
        for (int i = 0; i &lt; ChunkLength; i++)
        {
            *ptr++ = 0L;
        }
    }
}

static class Program
{
    static void Main()
    {
        var lookup = new Dictionary&lt;CommandBytes string&gt;();
        void Add(string val)
        {
            var cb = new CommandBytes(val);
            // prove we didn't screw up
            if (cb.ToString() != val)
                throw new InvalidOperationException("oops!");
            lookup.Add(cb val);
        }
        Add("client");
        Add("cluster");
        Add("command");
        Add("config");
        Add("dbsize");
        Add("decr");
        Add("del");
        Add("echo");
        Add("exists");
        Add("flushall");
        Add("flushdb");
        Add("get");
        Add("incr");
        Add("incrby");
        Add("info");
        Add("keys");
        Add("llen");
        Add("lpop");
        Add("lpush");
        Add("lrange");
        Add("memory");
        Add("mget");
        Add("mset");
        Add("ping");
        Add("quit");
        Add("role");
        Add("rpop");
        Add("rpush");
        Add("sadd");
        Add("scard");
        Add("select");
        Add("set");
        Add("shutdown");
        Add("sismember");
        Add("spop");
        Add("srem");
        Add("strlen");
        Add("subscribe");
        Add("time");
        Add("unlink");
        Add("unsubscribe");

        void HuntFor(string lookFor)
        {
            Console.WriteLine($"Looking for: '{lookFor}'");
            var hunt = new CommandBytes(lookFor);


            if (lookup.TryGetValue(hunt out var found))
            {
                Console.WriteLine($"Found via TryGetValue: '{found}'");
            }
            else
            {
                Console.WriteLine("**NOT FOUND** via TryGetValue");
            }
            Console.WriteLine("looking manually");
            foreach (var pair in lookup)
            {
                if (pair.Value == lookFor)
                {
                    Console.WriteLine($"Found manually: '{pair.Value}'");
                    var key = pair.Key;
                    void Compare&lt;T&gt;(string caption Func&lt;CommandBytes T&gt; func)
                    {
                        T x = func(hunt) y = func(key);
                        Console.WriteLine($"{caption}: {EqualityComparer&lt;T&gt;.Default.Equals(x y)} '{x}' vs '{y}'");
                    }
                    Compare("GetHashCode" _ =&gt; _.GetHashCode());
                    Compare("ToString" _ =&gt; _.ToString());
                    Compare("Length" _ =&gt; _.Length);
                    Compare("ToInnerString" _ =&gt; _.ToInnerString());
                    Console.WriteLine($"Equals: {key.Equals(hunt)} {hunt.Equals(key)}");
                    var eq = EqualityComparer&lt;CommandBytes&gt;.Default;

                    Console.WriteLine($"EqualityComparer: {eq.Equals(key hunt)} {eq.Equals(hunt key)}");
                    Compare("eq GetHashCode" _ =&gt; eq.GetHashCode(_));
                }
            }
            Console.WriteLine();
        }
        HuntFor("ping");
        HuntFor("subscribe");
    }
}
```

Expected output:

```
Looking for: 'ping'
Found via TryGetValue: 'ping'
looking manually
Found manually: 'ping'
GetHashCode: True '-1991953770' vs '-1991953770'
ToString: True 'ping' vs 'ping'
Length: True '4' vs '4'
ToInnerString: True '44423403520400' vs '44423403520400'
Equals: True True
EqualityComparer: True True
eq GetHashCode: True '-1991953770' vs '-1991953770'

Looking for: 'subscribe'
Found via TryGetValue: 'subscribe'
looking manually
Found manually: 'subscribe'
GetHashCode: True '764962383' vs '764962383'
ToString: True 'subscribe' vs 'subscribe'
Length: True '9' vs '9'
ToInnerString: True '7598244868551701257259540' vs '7598244868551701257259540'
Equals: True True
EqualityComparer: True True
eq GetHashCode: True '764962383' vs '764962383'
```

(note `Found via TryGetValue` and lots of `True` indicating no corruption)

Actual output on netcoreapp2.1

```
Looking for: 'ping'
**NOT FOUND** via TryGetValue
looking manually
Found manually: 'ping'
GetHashCode: True '-1991953770' vs '-1991953770'
ToString: True 'ping' vs 'ping'
Length: True '4' vs '4'
ToInnerString: True '44423403520400' vs '44423403520400'
Equals: True True
EqualityComparer: True True
eq GetHashCode: True '-1991953770' vs '-1991953770'

Looking for: 'subscribe'
**NOT FOUND** via TryGetValue
looking manually
Found manually: 'subscribe'
GetHashCode: False '764962383' vs '945069981'
ToString: False 'subscribe' vs 'subscri  '
Length: True '9' vs '9'
ToInnerString: False '7598244868551701257259540' vs '759824486855170125700'
Equals: False False
EqualityComparer: False False
eq GetHashCode: False '764962383' vs '945069981'
```

Note the `**NOT FOUND**` for both; the first item doesn't have data corruption (but fails anyway) - the second item (longer hits 2 elements) has become corrupted.</Description>
    <Title_Description>Breaking change in netcoreapp2.1 (possibly JIT bug?) re fixed buffers New in netcoreapp2.1 (doesn't impact netcoreapp2.0 or net47)

Full repro below; synopsis: fixed buffers go pretty wild when used on a field in a key in a `Dictionary&lt;TKeyTValue&gt;` (and possibly some other scenarios) causing:

- items not being found even though it can be shown (by looking via `foreach`) that `GetHashCode()` and `Equals()` are working correctly
- data corruption - in particular when more than one element in the fixed buffer is involved (so... most of the time; a fixed buffer of length 1 isn't very useful)

Since this could affect many more scenarios I'd wager this is a pretty serious regression.

Code:

```c#
// #define EXPLICIT_FIELDS

// Hypothesis: JIT bug affecting how fixed buffers are handled
//
// Affects: netcoreapp2.1 debug and release
// Does not seem to affect: netcoreapp2.0 net47
//
// the idea behind CommandBytes is that it is a fixed-sized string-like thing
// used for matching commands; it is *implemented* as a fixed buffer
// of **longs** but: the first byte of the first element is coerced into
// a byte and used to store the length; the actual text payload (ASCII)
// starts at the second byte of the first element
//
// as far as I can tell it is all validly implemented and it works fine
// in isolation however: when used in a dictionary it goes bad;
// - items not being found despite having GetHashCode and Equals match
// - items over 1 chunk size becoming corrupted (see: ToInnerString)
//
// however if I replace the fixed buffer with the same number of
// regular fields (_c0_c1_c2) and use *all the same code* it
// all works correctly! to see this define EXPLICIT_FIELDS
//
// The "Main" method populates a dictionary in the expected way
// then attempts to find things - either via TryGetValue or manually;
// it then compares the contents
//
// Yes this code is evil; it is for a very specific optimized scenario.

using System;
using System.Collections.Generic;
using System.Text;

unsafe struct CommandBytes : IEquatable&lt;CommandBytes&gt;
{
    private const int ChunkLength = 3;
    public const int MaxLength = (ChunkLength * 8) - 1;

#if !EXPLICIT_FIELDS
    fixed long _chunks[ChunkLength];
#else
    long _c0 _c1 _c2;
#endif
    public override int GetHashCode()
    {
#if !EXPLICIT_FIELDS
        fixed (long* lPtr = _chunks)
#else
        fixed (long* lPtr = &amp;_c0)
#endif
        {
            var hashCode = -1923861349;
            long* x = lPtr;
            for (int i = 0; i &lt; ChunkLength; i++)
            {
                hashCode = hashCode * -1521134295 + (*x++).GetHashCode();
            }
            return hashCode;
        }
    }

    public override string ToString()
    {
#if !EXPLICIT_FIELDS
        fixed (long* lPtr = _chunks)
#else
        fixed (long* lPtr = &amp;_c0)
#endif
        {
            var bPtr = (byte*)lPtr;
            return Encoding.ASCII.GetString(bPtr + 1 bPtr[0]);
        }
    }
    public int Length
    {
        get
        {
#if !EXPLICIT_FIELDS
            fixed (long* lPtr = _chunks)
#else
            fixed (long* lPtr = &amp;_c0)
#endif
            {
                var bPtr = (byte*)lPtr;
                return bPtr[0];
            }
        }
    }
    public byte this[int index]
    {
        get
        {
#if !EXPLICIT_FIELDS
            fixed (long* lPtr = _chunks)
#else
            fixed (long* lPtr = &amp;_c0)
#endif
            {
                byte* bPtr = (byte*)lPtr;
                int len = bPtr[0];
                if (index &lt; 0 || index &gt;= len) throw new IndexOutOfRangeException();
                return bPtr[index + 1];
            }
        }
    }

    public CommandBytes(string value)
    {
        value = value.ToLowerInvariant();
        var len = Encoding.ASCII.GetByteCount(value);
        if (len &gt; MaxLength) throw new ArgumentOutOfRangeException("Maximum command length exceeed");

#if !EXPLICIT_FIELDS
        fixed (long* lPtr = _chunks)
#else
        _c0 = _c1 = _c2 = 0L;
        fixed (long* lPtr = &amp;_c0)
#endif
        {
            Clear(lPtr);
            byte* bPtr = (byte*)lPtr;
            bPtr[0] = (byte)len;
            fixed (char* cPtr = value)
            {
                Encoding.ASCII.GetBytes(cPtr value.Length bPtr + 1 len);
            }
        }
    }
    public override bool Equals(object obj) =&gt; obj is CommandBytes cb &amp;&amp; Equals(cb);

    public string ToInnerString()
    {
#if !EXPLICIT_FIELDS
        fixed (long* lPtr = _chunks)
#else
        fixed (long* lPtr = &amp;_c0)
#endif
        {
            long* x = lPtr;
            var sb = new StringBuilder();
            for (int i = 0; i &lt; ChunkLength; i++)
            {
                if (sb.Length != 0) sb.Append('');
                sb.Append(*x++);
            }
            return sb.ToString();
        }
    }
    public bool Equals(CommandBytes value)
    {
#if !EXPLICIT_FIELDS
        fixed (long* lPtr = _chunks)
#else
        fixed (long* lPtr = &amp;_c0)
#endif
        {
            long* x = lPtr;
#if !EXPLICIT_FIELDS
            long* y = value._chunks;
#else
            long* y = &amp;value._c0;
#endif
            for (int i = 0; i &lt; ChunkLength; i++)
            {
                if (*x++ != *y++) return false;
            }
            return true;
        }
    }
    private static void Clear(long* ptr)
    {
        for (int i = 0; i &lt; ChunkLength; i++)
        {
            *ptr++ = 0L;
        }
    }
}

static class Program
{
    static void Main()
    {
        var lookup = new Dictionary&lt;CommandBytes string&gt;();
        void Add(string val)
        {
            var cb = new CommandBytes(val);
            // prove we didn't screw up
            if (cb.ToString() != val)
                throw new InvalidOperationException("oops!");
            lookup.Add(cb val);
        }
        Add("client");
        Add("cluster");
        Add("command");
        Add("config");
        Add("dbsize");
        Add("decr");
        Add("del");
        Add("echo");
        Add("exists");
        Add("flushall");
        Add("flushdb");
        Add("get");
        Add("incr");
        Add("incrby");
        Add("info");
        Add("keys");
        Add("llen");
        Add("lpop");
        Add("lpush");
        Add("lrange");
        Add("memory");
        Add("mget");
        Add("mset");
        Add("ping");
        Add("quit");
        Add("role");
        Add("rpop");
        Add("rpush");
        Add("sadd");
        Add("scard");
        Add("select");
        Add("set");
        Add("shutdown");
        Add("sismember");
        Add("spop");
        Add("srem");
        Add("strlen");
        Add("subscribe");
        Add("time");
        Add("unlink");
        Add("unsubscribe");

        void HuntFor(string lookFor)
        {
            Console.WriteLine($"Looking for: '{lookFor}'");
            var hunt = new CommandBytes(lookFor);


            if (lookup.TryGetValue(hunt out var found))
            {
                Console.WriteLine($"Found via TryGetValue: '{found}'");
            }
            else
            {
                Console.WriteLine("**NOT FOUND** via TryGetValue");
            }
            Console.WriteLine("looking manually");
            foreach (var pair in lookup)
            {
                if (pair.Value == lookFor)
                {
                    Console.WriteLine($"Found manually: '{pair.Value}'");
                    var key = pair.Key;
                    void Compare&lt;T&gt;(string caption Func&lt;CommandBytes T&gt; func)
                    {
                        T x = func(hunt) y = func(key);
                        Console.WriteLine($"{caption}: {EqualityComparer&lt;T&gt;.Default.Equals(x y)} '{x}' vs '{y}'");
                    }
                    Compare("GetHashCode" _ =&gt; _.GetHashCode());
                    Compare("ToString" _ =&gt; _.ToString());
                    Compare("Length" _ =&gt; _.Length);
                    Compare("ToInnerString" _ =&gt; _.ToInnerString());
                    Console.WriteLine($"Equals: {key.Equals(hunt)} {hunt.Equals(key)}");
                    var eq = EqualityComparer&lt;CommandBytes&gt;.Default;

                    Console.WriteLine($"EqualityComparer: {eq.Equals(key hunt)} {eq.Equals(hunt key)}");
                    Compare("eq GetHashCode" _ =&gt; eq.GetHashCode(_));
                }
            }
            Console.WriteLine();
        }
        HuntFor("ping");
        HuntFor("subscribe");
    }
}
```

Expected output:

```
Looking for: 'ping'
Found via TryGetValue: 'ping'
looking manually
Found manually: 'ping'
GetHashCode: True '-1991953770' vs '-1991953770'
ToString: True 'ping' vs 'ping'
Length: True '4' vs '4'
ToInnerString: True '44423403520400' vs '44423403520400'
Equals: True True
EqualityComparer: True True
eq GetHashCode: True '-1991953770' vs '-1991953770'

Looking for: 'subscribe'
Found via TryGetValue: 'subscribe'
looking manually
Found manually: 'subscribe'
GetHashCode: True '764962383' vs '764962383'
ToString: True 'subscribe' vs 'subscribe'
Length: True '9' vs '9'
ToInnerString: True '7598244868551701257259540' vs '7598244868551701257259540'
Equals: True True
EqualityComparer: True True
eq GetHashCode: True '764962383' vs '764962383'
```

(note `Found via TryGetValue` and lots of `True` indicating no corruption)

Actual output on netcoreapp2.1

```
Looking for: 'ping'
**NOT FOUND** via TryGetValue
looking manually
Found manually: 'ping'
GetHashCode: True '-1991953770' vs '-1991953770'
ToString: True 'ping' vs 'ping'
Length: True '4' vs '4'
ToInnerString: True '44423403520400' vs '44423403520400'
Equals: True True
EqualityComparer: True True
eq GetHashCode: True '-1991953770' vs '-1991953770'

Looking for: 'subscribe'
**NOT FOUND** via TryGetValue
looking manually
Found manually: 'subscribe'
GetHashCode: False '764962383' vs '945069981'
ToString: False 'subscribe' vs 'subscri  '
Length: True '9' vs '9'
ToInnerString: False '7598244868551701257259540' vs '759824486855170125700'
Equals: False False
EqualityComparer: False False
eq GetHashCode: False '764962383' vs '945069981'
```

Note the `**NOT FOUND**` for both; the first item doesn't have data corruption (but fails anyway) - the second item (longer hits 2 elements) has become corrupted.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19148</IssueLabelID>
    <Title>COM object lifetime is subject to Windows rundown policy (6 minute idle)</Title>
    <Description>Call CoMarshalInterface with MSHLFLAGS_TABLESTRONG (as opposed to MSHLFLAGS_NORMAL) to avoid COM rundown timeouts.

https://github.com/dotnet/coreclr/blob/8e48db2c113052ef18cdafb43e114a8633864ec0/src/vm/comcache.cpp#L178

The lifetime issue tends to hit very large applications.  Viable workarounds are: 1) use the COM objects regularly or 2) avoid the .NET COM cache and get the raw IntPtr then call GetUniqueObjectForIUnknown.</Description>
    <Title_Description>COM object lifetime is subject to Windows rundown policy (6 minute idle) Call CoMarshalInterface with MSHLFLAGS_TABLESTRONG (as opposed to MSHLFLAGS_NORMAL) to avoid COM rundown timeouts.

https://github.com/dotnet/coreclr/blob/8e48db2c113052ef18cdafb43e114a8633864ec0/src/vm/comcache.cpp#L178

The lifetime issue tends to hit very large applications.  Viable workarounds are: 1) use the COM objects regularly or 2) avoid the .NET COM cache and get the raw IntPtr then call GetUniqueObjectForIUnknown.</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jeffschwMSFT</Assignee>
    <CreatedAt>26/07/2018 9:45:40 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19147</IssueLabelID>
    <Title>Cannot find libSystem.dylib</Title>
    <Description>Our .net core 2.1.201 app uses native interop on Mac and has methods attributed with `[DllImport("libSystem.dylib")]` some customers report that it fails to find libSystem.dylib or one of its dependencies:
</Description>
    <Title_Description>Cannot find libSystem.dylib Our .net core 2.1.201 app uses native interop on Mac and has methods attributed with `[DllImport("libSystem.dylib")]` some customers report that it fails to find libSystem.dylib or one of its dependencies:
</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>26/07/2018 9:12:56 PM +00:00</CreatedAt>
    <ClosedAt>26/10/2018 7:08:54 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19140</IssueLabelID>
    <Title>JIT: assert compiling System.Runtime.Intrinsics.X86.Avx:TestC via PMI</Title>
    <Description>I made a couple of improvements to the generic expansions in PMI and am now seeing an assert when running PMI on system.private.corelib:
```
D:\repos\coreclr2\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root\corerun.exe d:\repos\jitutils\bin\PMI.dll prepall-quiet D:\repos\coreclr2\bin\tests\Windows_NT.x64.Release\Tests\Core_Root\System.Private.CoreLib.dll

. . .

Assert failure(PID 3308 [0x00000cec] Thread: 36100 [0x8d04]): 
Assertion failed 'baseType != TYP_UNKNOWN' 
in 'System.Runtime.Intrinsics.X86.Avx:TestC(structstruct):bool' (IL size 8)

    File: d:\repos\coreclr2\src\jit\hwintrinsicxarch.cpp Line: 728
    Image: D:\repos\coreclr2\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root\CoreRun.exe
```

To repro build x64 checked sync to latest jitutils and build then run the above.</Description>
    <Title_Description>JIT: assert compiling System.Runtime.Intrinsics.X86.Avx:TestC via PMI I made a couple of improvements to the generic expansions in PMI and am now seeing an assert when running PMI on system.private.corelib:
```
D:\repos\coreclr2\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root\corerun.exe d:\repos\jitutils\bin\PMI.dll prepall-quiet D:\repos\coreclr2\bin\tests\Windows_NT.x64.Release\Tests\Core_Root\System.Private.CoreLib.dll

. . .

Assert failure(PID 3308 [0x00000cec] Thread: 36100 [0x8d04]): 
Assertion failed 'baseType != TYP_UNKNOWN' 
in 'System.Runtime.Intrinsics.X86.Avx:TestC(structstruct):bool' (IL size 8)

    File: d:\repos\coreclr2\src\jit\hwintrinsicxarch.cpp Line: 728
    Image: D:\repos\coreclr2\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root\CoreRun.exe
```

To repro build x64 checked sync to latest jitutils and build then run the above.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
    <CreatedAt>26/07/2018 4:10:22 PM +00:00</CreatedAt>
    <ClosedAt>27/07/2018 2:07:51 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19139</IssueLabelID>
    <Title>Unnecessary code in System.Numerics.ConstantHelper ?</Title>
    <Description>most of the methods in [System.Private.CoreLib/shared/System/Numerics/ConstantHelper.cs](https://github.com/dotnet/coreclr/blob/1456a38ed9ee3eda8022b9f162a45334723a0d7a/src/System.Private.CoreLib/shared/System/Numerics/ConstantHelper.cs#L12) are using unsafe/unchecked blocks unnecessarly
shouldn't a simple method like 
```
        [MethodImplAttribute(MethodImplOptions.AggressiveInlining)]
        public static byte GetByteWithAllBitsSet()
        {
            byte value = 0;
            unsafe
            {
                unchecked
                {
                    *((byte*)&amp;value) = (byte)0xff;
                }
            }
            return value;
        }
```
be more like 
```
        [MethodImplAttribute(MethodImplOptions.AggressiveInlining)]
        public static byte GetByteWithAllBitsSet()
        {           
            return (byte)0xff;
        }
```</Description>
    <Title_Description>Unnecessary code in System.Numerics.ConstantHelper ? most of the methods in [System.Private.CoreLib/shared/System/Numerics/ConstantHelper.cs](https://github.com/dotnet/coreclr/blob/1456a38ed9ee3eda8022b9f162a45334723a0d7a/src/System.Private.CoreLib/shared/System/Numerics/ConstantHelper.cs#L12) are using unsafe/unchecked blocks unnecessarly
shouldn't a simple method like 
```
        [MethodImplAttribute(MethodImplOptions.AggressiveInlining)]
        public static byte GetByteWithAllBitsSet()
        {
            byte value = 0;
            unsafe
            {
                unchecked
                {
                    *((byte*)&amp;value) = (byte)0xff;
                }
            }
            return value;
        }
```
be more like 
```
        [MethodImplAttribute(MethodImplOptions.AggressiveInlining)]
        public static byte GetByteWithAllBitsSet()
        {           
            return (byte)0xff;
        }
```</Title_Description>
    <Label>area-Meta-corelib</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>26/07/2018 2:56:46 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19138</IssueLabelID>
    <Title>Build failure: error CS1503: Argument 1: cannot convert from 'System.Runtime.Intrinsics.Vector256&lt;sbyte&gt;' to 'System.Runtime.Intrinsics.Vector256&lt;byte&gt;'</Title>
    <Description>Opened on behalf of @RussKeldorph

Warnings: 1
Status Message: failed

Build : 2.1 - 20180726.01 (Product Build)
Failing configurations:
- Alpine3.6
  - Build-Tests-R2R-Release
  - Build-Tests-Release
- RedHat6
  - Build-Tests-R2R-Release
  - Build-Tests-Release
- RedHat 7
  - Build-Tests-R2R-Release
  - Build-Tests-Release
- OSX
  - Build-Tests-R2R-Release
  - Build-Tests-Release
- Windows
  - Build-Tests-R2R-Release-arm64
  - Build-Tests-Release-arm64
  - Build-Tests-R2R-Release
  - Build-Tests-Release
[Mission Control Build Info](https://mc.dot.net/#/product/netcore/21/source/prodcon~2Fcoreclr~2Frelease~2F2.1~2F/type/build~2Fproduct~2F/build/20180726.01/workItem/Orchestration/analysis/external/Link)
</Description>
    <Title_Description>Build failure: error CS1503: Argument 1: cannot convert from 'System.Runtime.Intrinsics.Vector256&lt;sbyte&gt;' to 'System.Runtime.Intrinsics.Vector256&lt;byte&gt;' Opened on behalf of @RussKeldorph

Warnings: 1
Status Message: failed

Build : 2.1 - 20180726.01 (Product Build)
Failing configurations:
- Alpine3.6
  - Build-Tests-R2R-Release
  - Build-Tests-Release
- RedHat6
  - Build-Tests-R2R-Release
  - Build-Tests-Release
- RedHat 7
  - Build-Tests-R2R-Release
  - Build-Tests-Release
- OSX
  - Build-Tests-R2R-Release
  - Build-Tests-Release
- Windows
  - Build-Tests-R2R-Release-arm64
  - Build-Tests-Release-arm64
  - Build-Tests-R2R-Release
  - Build-Tests-Release
[Mission Control Build Info](https://mc.dot.net/#/product/netcore/21/source/prodcon~2Fcoreclr~2Frelease~2F2.1~2F/type/build~2Fproduct~2F/build/20180726.01/workItem/Orchestration/analysis/external/Link)
</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>26/07/2018 2:52:54 PM +00:00</CreatedAt>
    <ClosedAt>9/08/2018 8:37:01 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19135</IssueLabelID>
    <Title>[automated] Merge branch 'release/2.1' =&gt; 'release/2.2'</Title>
    <Description>I detected changes in the release/2.1 branch which have not been merged yet to release/2.2.
I'm a robot and am configured to help you automatically keep release/2.2 up to date so
I've opened this PR.

This PR merges commits made on release/2.1 by the following committers:

* @weshaggard
* @dotnet-maestro-bot

## Instructions for merging

This PR will not be auto-merged. When pull request checks pass please complete this PR
by creating a merge commit *not* a squash or rebase commit.

&lt;img alt="merge button instructions" src="https://i.imgur.com/GepcNJV.png" width="300" /&gt;

You can also do this on command line:
```
git checkout release/2.2
git pull
git fetch --force https://github.com/dotnet-maestro-bot/coreclr merge/release/2.1-to-release/2.2:merge/release/2.1-to-release/2.2
git merge merge/release/2.1-to-release/2.2
git push
```

:warning: If there are merge conflicts you will need to resolve them manually before merging.

Please contact ASP.NET Core Engineering if you have questions or issues.
Also if this PR was generated incorrectly help us fix it. See https://github.com/aspnet/BuildTools/blob/master/scripts/GitHubMergeBranches.ps1.</Description>
    <Title_Description>[automated] Merge branch 'release/2.1' =&gt; 'release/2.2' I detected changes in the release/2.1 branch which have not been merged yet to release/2.2.
I'm a robot and am configured to help you automatically keep release/2.2 up to date so
I've opened this PR.

This PR merges commits made on release/2.1 by the following committers:

* @weshaggard
* @dotnet-maestro-bot

## Instructions for merging

This PR will not be auto-merged. When pull request checks pass please complete this PR
by creating a merge commit *not* a squash or rebase commit.

&lt;img alt="merge button instructions" src="https://i.imgur.com/GepcNJV.png" width="300" /&gt;

You can also do this on command line:
```
git checkout release/2.2
git pull
git fetch --force https://github.com/dotnet-maestro-bot/coreclr merge/release/2.1-to-release/2.2:merge/release/2.1-to-release/2.2
git merge merge/release/2.1-to-release/2.2
git push
```

:warning: If there are merge conflicts you will need to resolve them manually before merging.

Please contact ASP.NET Core Engineering if you have questions or issues.
Also if this PR was generated incorrectly help us fix it. See https://github.com/aspnet/BuildTools/blob/master/scripts/GitHubMergeBranches.ps1.</Title_Description>
    <Label>
    </Label>
    <Assignee>wtgodbe</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19134</IssueLabelID>
    <Title>Enable optimizations for interoputil.cpp@SafeRelease</Title>
    <Description>https://github.com/dotnet/coreclr/blob/master/src/vm/interoputil.cpp#L1510

Optimizations were disabled years ago due to a likely now fixed native toolset bug.</Description>
    <Title_Description>Enable optimizations for interoputil.cpp@SafeRelease https://github.com/dotnet/coreclr/blob/master/src/vm/interoputil.cpp#L1510

Optimizations were disabled years ago due to a likely now fixed native toolset bug.</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19133</IssueLabelID>
    <Title>Tiered Compilation: Need an ETW event that explicitly indicates tiering is enabled or disabled</Title>
    <Description>Right now PerfView assumes that the lack of a jit compilation tier1 event means tiering was disabled but this is error prone in at least two situations:
a) Short running apps may never have time to tier any methods but the feature was enabled
b) Apps that generate large amounts of ETW events may drop events or exhaust the circular buffer causing all tier1 jit events to be lost (this is exacerbated by PerfView's misleading UI that shows you have enough buffer even when events are being dropped)</Description>
    <Title_Description>Tiered Compilation: Need an ETW event that explicitly indicates tiering is enabled or disabled Right now PerfView assumes that the lack of a jit compilation tier1 event means tiering was disabled but this is error prone in at least two situations:
a) Short running apps may never have time to tier any methods but the feature was enabled
b) Apps that generate large amounts of ETW events may drop events or exhaust the circular buffer causing all tier1 jit events to be lost (this is exacerbated by PerfView's misleading UI that shows you have enough buffer even when events are being dropped)</Title_Description>
    <Label>area-TieredCompilation</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19132</IssueLabelID>
    <Title>Incorrect Optimization setting for tests</Title>
    <Description>The naming convention is that `*_ro` tests are optimized (`&lt;Optimize&gt;True&lt;/Optimize&gt;`) and `*_r` tests are not (`&lt;Optimize&gt;&lt;/Optimize&gt;`).

The following are not built optimized and should be (and the build is the same as the `_r` versions):
```
JIT\HardwareIntrinsics\X86\Sse2\CompareGreaterThanOrEqualScalar_ro.csproj
JIT\HardwareIntrinsics\X86\Sse2\CompareGreaterThanOrEqualUnorderedScalar_ro.csproj
```

The following are built optimized and should not be (the `_ro` versions are built optimized):
```
Sse2\MaskMove_r.csproj
Sse2\MoveMask_r.csproj
Sse2\MoveScalar_r.csproj
Sse2\MoveScalar_r.Int64.csproj
Sse2\MoveScalar_r.UInt64.csproj
Avx\InsertExtractVector128_r.csproj
Avx\MoveMask_r.csproj
Avx2\MoveMask_r.csproj
```

(related: https://github.com/dotnet/coreclr/pull/19083)</Description>
    <Title_Description>Incorrect Optimization setting for tests The naming convention is that `*_ro` tests are optimized (`&lt;Optimize&gt;True&lt;/Optimize&gt;`) and `*_r` tests are not (`&lt;Optimize&gt;&lt;/Optimize&gt;`).

The following are not built optimized and should be (and the build is the same as the `_r` versions):
```
JIT\HardwareIntrinsics\X86\Sse2\CompareGreaterThanOrEqualScalar_ro.csproj
JIT\HardwareIntrinsics\X86\Sse2\CompareGreaterThanOrEqualUnorderedScalar_ro.csproj
```

The following are built optimized and should not be (the `_ro` versions are built optimized):
```
Sse2\MaskMove_r.csproj
Sse2\MoveMask_r.csproj
Sse2\MoveScalar_r.csproj
Sse2\MoveScalar_r.Int64.csproj
Sse2\MoveScalar_r.UInt64.csproj
Avx\InsertExtractVector128_r.csproj
Avx\MoveMask_r.csproj
Avx2\MoveMask_r.csproj
```

(related: https://github.com/dotnet/coreclr/pull/19083)</Title_Description>
    <Label>
    </Label>
    <Assignee>4creators</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19131</IssueLabelID>
    <Title>Incorrect naming for JIT\HardwareIntrinsics\X86\Sse2 test projects</Title>
    <Description>The naming of the following doesn't follow the correct naming scheme:
```
MoveScalar_r.Int64.csproj
MoveScalar_r.UInt64.csproj
MoveScalar_ro.Int64.csproj
MoveScalar_ro.UInt64.csproj
```
The `_r` or `_ro` suffix needs to be the _last_ thing before the file extension. Thus they should be:
```
MoveScalar.Int64_r.csproj
MoveScalar.UInt64_r.csproj
MoveScalar.Int64_ro.csproj
MoveScalar.UInt64_ro.csproj
```
</Description>
    <Title_Description>Incorrect naming for JIT\HardwareIntrinsics\X86\Sse2 test projects The naming of the following doesn't follow the correct naming scheme:
```
MoveScalar_r.Int64.csproj
MoveScalar_r.UInt64.csproj
MoveScalar_ro.Int64.csproj
MoveScalar_ro.UInt64.csproj
```
The `_r` or `_ro` suffix needs to be the _last_ thing before the file extension. Thus they should be:
```
MoveScalar.Int64_r.csproj
MoveScalar.UInt64_r.csproj
MoveScalar.Int64_ro.csproj
MoveScalar.UInt64_ro.csproj
```
</Title_Description>
    <Label>
    </Label>
    <Assignee>4creators</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19129</IssueLabelID>
    <Title>[RyuJIT] lack of escape analysis makes redundant memory-access of Vector128/256&lt;T&gt; fields</Title>
    <Description>Related to https://github.com/dotnet/coreclr/issues/19116

The C# source code below is from https://github.com/dotnet/coreclr/pull/18839
```csharp
internal class VectorPacket256
{
    public Vector256&lt;float&gt; Xs;
    public Vector256&lt;float&gt; Ys;
    public Vector256&lt;float&gt; Zs;
    public Vector256&lt;float&gt; Lengths
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            return Sqrt(DotProduct(this this));
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vector256&lt;float&gt; DotProduct(VectorPacket256 left VectorPacket256 right)
    {
        var x2 = Multiply(left.Xs right.Xs);
        var y2 = Multiply(left.Ys right.Ys);
        var z2 = Multiply(left.Zs right.Zs);
        return Add(Add(x2 y2) z2);
    }
    ...
}
```

`get_Lengths` will be compiled to 
```asm
vmovupd ymm0 ymmword ptr [rax+0x8]
vmulps ymm0 ymm0 ymmword ptr [rax+0x8]
vmovupd ymm1 ymmword ptr [rax+0x28]
vmulps ymm1 ymm1 ymmword ptr [rax+0x28]
vmovupd ymm2 ymmword ptr [rax+0x48]
mov qword ptr [rbp-0x370] rax
vmulps ymm2 ymm2 ymmword ptr [rax+0x48]
vaddps ymm0 ymm0 ymm1
vaddps ymm0 ymm0 ymm2
vsqrtps ymm0 ymm0
```

`Multiply(this.Xs this.Xs)` generates redundant memory access instructions for `Vector256&lt;float&gt;` field access. Actually the codgen could be
```asm
vmovupd ymm0 ymmword ptr [rax+0x8]
vmulps ymm0 ymm0 ymm0
vmovupd ymm1 ymmword ptr [rax+0x28]
vmulps ymm1 ymm1 ymm1
vmovupd ymm2 ymmword ptr [rax+0x48]
vmulps ymm2 ymm2 ymm2
vaddps ymm0 ymm0 ymm1
vaddps ymm0 ymm0 ymm2
vsqrtps ymm0 ymm0
```
This redundant could be eliminated by escape analysis and unwarping `VectorPacket256`.

A worse example with `Vector256&lt;float&gt;` field assignments. In the code below `difColor` is a local `VectorPacket256` object (but `dif` is returned by another function)
```csharp
                difColor.Xs = BlendVariable(difColor.Xs dif.Xs thingMask);
                difColor.Ys = BlendVariable(difColor.Ys dif.Ys thingMask);
                difColor.Zs = BlendVariable(difColor.Zs dif.Zs thingMask);
```
that is compiled to 
```asm
mov r8 qword ptr [rsp+0x70]
vmovupd ymm0 ymmword ptr [r8+0x8]
vblendvps ymm0 ymm0 ymmword ptr [rax+0x8] ymm11
vmovupd ymmword ptr [r8+0x8] ymm0
vmovupd ymm0 ymmword ptr [r8+0x28]
vblendvps ymm0 ymm0 ymmword ptr [rax+0x28] ymm11
vmovupd ymmword ptr [r8+0x28] ymm0
vmovupd ymm0 ymmword ptr [r8+0x48]
vblendvps ymm0 ymm0 ymmword ptr [rax+0x48] ymm11
mov qword ptr [rsp+0x70] r8
vmovupd ymmword ptr [r8+0x48] ymm0
```
Ideally this could be optimized to
```asm
vblendvps ymm1 ymm1 ymmword ptr [rax+0x8] ymm11
vblendvps ymm2 ymm2 ymmword ptr [rax+0x28] ymm11
vblendvps ymm3 ymm3 ymmword ptr [rax+0x48] ymm11
```

category:cq
theme:optimization
skill-level:expert
cost:large</Description>
    <Title_Description>[RyuJIT] lack of escape analysis makes redundant memory-access of Vector128/256&lt;T&gt; fields Related to https://github.com/dotnet/coreclr/issues/19116

The C# source code below is from https://github.com/dotnet/coreclr/pull/18839
```csharp
internal class VectorPacket256
{
    public Vector256&lt;float&gt; Xs;
    public Vector256&lt;float&gt; Ys;
    public Vector256&lt;float&gt; Zs;
    public Vector256&lt;float&gt; Lengths
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            return Sqrt(DotProduct(this this));
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vector256&lt;float&gt; DotProduct(VectorPacket256 left VectorPacket256 right)
    {
        var x2 = Multiply(left.Xs right.Xs);
        var y2 = Multiply(left.Ys right.Ys);
        var z2 = Multiply(left.Zs right.Zs);
        return Add(Add(x2 y2) z2);
    }
    ...
}
```

`get_Lengths` will be compiled to 
```asm
vmovupd ymm0 ymmword ptr [rax+0x8]
vmulps ymm0 ymm0 ymmword ptr [rax+0x8]
vmovupd ymm1 ymmword ptr [rax+0x28]
vmulps ymm1 ymm1 ymmword ptr [rax+0x28]
vmovupd ymm2 ymmword ptr [rax+0x48]
mov qword ptr [rbp-0x370] rax
vmulps ymm2 ymm2 ymmword ptr [rax+0x48]
vaddps ymm0 ymm0 ymm1
vaddps ymm0 ymm0 ymm2
vsqrtps ymm0 ymm0
```

`Multiply(this.Xs this.Xs)` generates redundant memory access instructions for `Vector256&lt;float&gt;` field access. Actually the codgen could be
```asm
vmovupd ymm0 ymmword ptr [rax+0x8]
vmulps ymm0 ymm0 ymm0
vmovupd ymm1 ymmword ptr [rax+0x28]
vmulps ymm1 ymm1 ymm1
vmovupd ymm2 ymmword ptr [rax+0x48]
vmulps ymm2 ymm2 ymm2
vaddps ymm0 ymm0 ymm1
vaddps ymm0 ymm0 ymm2
vsqrtps ymm0 ymm0
```
This redundant could be eliminated by escape analysis and unwarping `VectorPacket256`.

A worse example with `Vector256&lt;float&gt;` field assignments. In the code below `difColor` is a local `VectorPacket256` object (but `dif` is returned by another function)
```csharp
                difColor.Xs = BlendVariable(difColor.Xs dif.Xs thingMask);
                difColor.Ys = BlendVariable(difColor.Ys dif.Ys thingMask);
                difColor.Zs = BlendVariable(difColor.Zs dif.Zs thingMask);
```
that is compiled to 
```asm
mov r8 qword ptr [rsp+0x70]
vmovupd ymm0 ymmword ptr [r8+0x8]
vblendvps ymm0 ymm0 ymmword ptr [rax+0x8] ymm11
vmovupd ymmword ptr [r8+0x8] ymm0
vmovupd ymm0 ymmword ptr [r8+0x28]
vblendvps ymm0 ymm0 ymmword ptr [rax+0x28] ymm11
vmovupd ymmword ptr [r8+0x28] ymm0
vmovupd ymm0 ymmword ptr [r8+0x48]
vblendvps ymm0 ymm0 ymmword ptr [rax+0x48] ymm11
mov qword ptr [rsp+0x70] r8
vmovupd ymmword ptr [r8+0x48] ymm0
```
Ideally this could be optimized to
```asm
vblendvps ymm1 ymm1 ymmword ptr [rax+0x8] ymm11
vblendvps ymm2 ymm2 ymmword ptr [rax+0x28] ymm11
vblendvps ymm3 ymm3 ymmword ptr [rax+0x48] ymm11
```

category:cq
theme:optimization
skill-level:expert
cost:large</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
    <CreatedAt>25/07/2018 8:18:28 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19128</IssueLabelID>
    <Title>reenable corefx System.Runtime.Tests  on arm32</Title>
    <Description>the issue #17585 was fixed long time ago but this exclusion was forgotten.</Description>
    <Title_Description>reenable corefx System.Runtime.Tests  on arm32 the issue #17585 was fixed long time ago but this exclusion was forgotten.</Title_Description>
    <Label>disabled-test</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>25/07/2018 7:24:14 PM +00:00</CreatedAt>
    <ClosedAt>26/07/2018 10:46:54 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19127</IssueLabelID>
    <Title>JIT: gcstress failure in BMI1 test x64 minopts</Title>
    <Description>Suspect this is likely a test bug as the test is new....

To repro: build x64 checked build tests\src\jit\HardwareIntrinsics\X86\bmi1\Bmi1_r.csproj
```
complus_gcstress=C
complus_heapverify=1
complus_jitminopts=1

D:\repos\coreclr2\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root\corerun.exe D:\repos\coreclr\bin\tests\Windows_NT.x64.Release\jit\HardwareIntrinsics\X86\bmi1\Bmi1_r\Bmi1_r.exe
Beginning test case AndNot.UInt32 at 7/25/2018 11:58:26 AM
Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro


Ending test case at 7/25/2018 11:58:30 AM
Beginning test case AndNot.UInt64 at 7/25/2018 11:58:30 AM
Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro


Ending test case at 7/25/2018 11:58:30 AM
Beginning test case ExtractLowestSetBit.UInt32 at 7/25/2018 11:58:30 AM
Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro


Assert failure(PID 7416 [0x00001cf8] Thread: 21256 [0x5308]): !CREATE_CHECK_STRING(!"Detected use of a corrupted OBJECTREF. Possible GC hole.")

CORECLR! `Object::ValidateInner'::`1'::catch$12 + 0x13E (0x00007ff9`002e2a74)
CORECLR! CallSettingFrame + 0x20 (0x00007ff9`001d2390)
CORECLR! _FrameHandler3::CxxCallCatchBlock + 0x15A (0x00007ff9`001d0b3a)
NTDLL! RtlCaptureContext + 0x3E3 (0x00007ff9`4ae343f3)
CORECLR! Object::ValidateInner + 0x73 (0x00007ff8`ff8f41a3)
CORECLR! Object::Validate + 0x143 (0x00007ff8`ff8f4013)
CORECLR! GcInfoDecoder::ReportRegisterToGC + 0x123 (0x00007ff8`fffbdc03)
CORECLR! GcInfoDecoder::ReportSlotToGC + 0xCD (0x00007ff8`fffbde41)
CORECLR! GcInfoDecoder::EnumerateLiveSlots + 0xCBE (0x00007ff8`fffbd056)
CORECLR! EECodeManager::EnumGcRefs + 0x3A3 (0x00007ff8`ffcabc63)
    File: d:\repos\coreclr2\src\vm\object.cpp Line: 806
    Image: D:\repos\coreclr2\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root\CoreRun.exe
```

cc @dotnet/jit-contrib @tannergooding </Description>
    <Title_Description>JIT: gcstress failure in BMI1 test x64 minopts Suspect this is likely a test bug as the test is new....

To repro: build x64 checked build tests\src\jit\HardwareIntrinsics\X86\bmi1\Bmi1_r.csproj
```
complus_gcstress=C
complus_heapverify=1
complus_jitminopts=1

D:\repos\coreclr2\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root\corerun.exe D:\repos\coreclr\bin\tests\Windows_NT.x64.Release\jit\HardwareIntrinsics\X86\bmi1\Bmi1_r\Bmi1_r.exe
Beginning test case AndNot.UInt32 at 7/25/2018 11:58:26 AM
Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro


Ending test case at 7/25/2018 11:58:30 AM
Beginning test case AndNot.UInt64 at 7/25/2018 11:58:30 AM
Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro


Ending test case at 7/25/2018 11:58:30 AM
Beginning test case ExtractLowestSetBit.UInt32 at 7/25/2018 11:58:30 AM
Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro


Assert failure(PID 7416 [0x00001cf8] Thread: 21256 [0x5308]): !CREATE_CHECK_STRING(!"Detected use of a corrupted OBJECTREF. Possible GC hole.")

CORECLR! `Object::ValidateInner'::`1'::catch$12 + 0x13E (0x00007ff9`002e2a74)
CORECLR! CallSettingFrame + 0x20 (0x00007ff9`001d2390)
CORECLR! _FrameHandler3::CxxCallCatchBlock + 0x15A (0x00007ff9`001d0b3a)
NTDLL! RtlCaptureContext + 0x3E3 (0x00007ff9`4ae343f3)
CORECLR! Object::ValidateInner + 0x73 (0x00007ff8`ff8f41a3)
CORECLR! Object::Validate + 0x143 (0x00007ff8`ff8f4013)
CORECLR! GcInfoDecoder::ReportRegisterToGC + 0x123 (0x00007ff8`fffbdc03)
CORECLR! GcInfoDecoder::ReportSlotToGC + 0xCD (0x00007ff8`fffbde41)
CORECLR! GcInfoDecoder::EnumerateLiveSlots + 0xCBE (0x00007ff8`fffbd056)
CORECLR! EECodeManager::EnumGcRefs + 0x3A3 (0x00007ff8`ffcabc63)
    File: d:\repos\coreclr2\src\vm\object.cpp Line: 806
    Image: D:\repos\coreclr2\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root\CoreRun.exe
```

cc @dotnet/jit-contrib @tannergooding </Title_Description>
    <Label>GCStress</Label>
    <Assignee>tannergooding</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19124</IssueLabelID>
    <Title>JIT: SysV minopts simd assert in fgMorphMultiregStructArg</Title>
    <Description>To repro on windows: build x64 checked build the jit\SIMD\VectorExp_ro test.
```
set complus_altjit=*
set complus_altjitname=linuxnonjit.dll
set complus_jitminopts=1

D:\repos\coreclr2\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root\corerun.exe d:\repos\coreclr\bin\tests\Windows_NT.x64.Release\jit\SIMD\VectorExp_ro\VectorExp_ro.exe

Assert failure(PID 18552 [0x00004878] Thread: 21208 [0x52d8]): Assertion failed 'arg-&gt;OperGet() == GT_LCL_VAR' in 'VectorExpTest`1[Int64][System.Int64]:VectorExp(structlonglonglong):int' (IL size 148)

    File: d:\repos\coreclr2\src\jit\morph.cpp Line: 4630
    Image: D:\repos\coreclr2\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root\CoreRun.exe
```

Assert is that morph sees an unexpected GT_COMMA.

You can also repro via PMI if you pick up dotnet/jitutils#159.

cc @dotnet/jit-contrib </Description>
    <Title_Description>JIT: SysV minopts simd assert in fgMorphMultiregStructArg To repro on windows: build x64 checked build the jit\SIMD\VectorExp_ro test.
```
set complus_altjit=*
set complus_altjitname=linuxnonjit.dll
set complus_jitminopts=1

D:\repos\coreclr2\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root\corerun.exe d:\repos\coreclr\bin\tests\Windows_NT.x64.Release\jit\SIMD\VectorExp_ro\VectorExp_ro.exe

Assert failure(PID 18552 [0x00004878] Thread: 21208 [0x52d8]): Assertion failed 'arg-&gt;OperGet() == GT_LCL_VAR' in 'VectorExpTest`1[Int64][System.Int64]:VectorExp(structlonglonglong):int' (IL size 148)

    File: d:\repos\coreclr2\src\jit\morph.cpp Line: 4630
    Image: D:\repos\coreclr2\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root\CoreRun.exe
```

Assert is that morph sees an unexpected GT_COMMA.

You can also repro via PMI if you pick up dotnet/jitutils#159.

cc @dotnet/jit-contrib </Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19123</IssueLabelID>
    <Title>Add CI PR-triggered Ubuntu x64 innerloop no-tiering job</Title>
    <Description>
    </Description>
    <Title_Description>Add CI PR-triggered Ubuntu x64 innerloop no-tiering job </Title_Description>
    <Label>area-TieredCompilation</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19122</IssueLabelID>
    <Title>[WIP] Test new CI jobs for enabling Tiered Compilation by default</Title>
    <Description>For https://github.com/dotnet/coreclr/pull/19121</Description>
    <Title_Description>[WIP] Test new CI jobs for enabling Tiered Compilation by default For https://github.com/dotnet/coreclr/pull/19121</Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19121</IssueLabelID>
    <Title>Enable Tiered Compilation by default</Title>
    <Description>1) Changes the default state of the tiered compilation feature check to be ON BY DEFAULT
2) Removed comments about the source about this being a work in progress. Although it will surely continue to evolve and improve remaining issues would be better tracked in our issue tracking system with the same default presumption as other runtime features - assume it works unless noted otherwise.
3) Adjusts a number of tests and automated scripts that made assumptions that the default setting of this feature is off.
4) Stop accepting the deprecated env var COMPLUS_EXPERIMENTAL_TieredCompilation. I'm not aware it has any remaining usage but if so we're going to find out.</Description>
    <Title_Description>Enable Tiered Compilation by default 1) Changes the default state of the tiered compilation feature check to be ON BY DEFAULT
2) Removed comments about the source about this being a work in progress. Although it will surely continue to evolve and improve remaining issues would be better tracked in our issue tracking system with the same default presumption as other runtime features - assume it works unless noted otherwise.
3) Adjusts a number of tests and automated scripts that made assumptions that the default setting of this feature is off.
4) Stop accepting the deprecated env var COMPLUS_EXPERIMENTAL_TieredCompilation. I'm not aware it has any remaining usage but if so we're going to find out.</Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19120</IssueLabelID>
    <Title>Support .Net Core in RegAsm and TlbExp</Title>
    <Description>Currently you can create .net core application with COM object:
```C#
    [Guid("7ce1e40f-760a-4d81-b70b-61108ed15cb4")]
    [ComVisible(true)]
    public interface IComExampleClass
    {
        IComModelClass ExampleMethod(string param1 string param2);

    }

    [Guid("a8436b3f-3657-4a01-a133-fd333a84cb58")]
    [ClassInterface(ClassInterfaceType.None)]
    [ComVisible(true)]
    public class ComExampleClass : IComExampleClass
    {
        public IComModelClass ExampleMethod(string param1 string param2)
        {
            return new ComModelClass()
            {
                Result = $"{param1} + {param2}"
            };
        }
    }


    [Guid("9f5aeede-ec3e-443d-8ba0-9a9f2a6b9e53")]
    [ComVisible(true)]
    public interface IComModelClass
    {
        string Result { get; set; }
    }


    [Guid("526c6cb5-264d-4629-a894-fff02aeb9ec1")]
    [ClassInterface(ClassInterfaceType.None)]
    [ComVisible(true)]
    public class ComModelClass : IComModelClass
    {
        public string Result { get; set; }
    }

```

But you can't generate tbl file:

```cmd
"c:\Program Files (x86)\Microsoft SDKs\Windows\v10.0A\bin\NETFX 4.7.2 Tools\TlbExp.exe" ComExample.exe /out:ComExample.tlb
```

you can't register assembly using RegAsm:
```cmd
c:\Windows\Microsoft.NET\Framework64\v4.0.30319
 RegAsm.exe /tlb:ComExample.tlb C:\Users\wnagorsx\source\repos\ConsoleApp1\ConsoleApp1\bin\x64\Debug\net4.7.2\win7-x64\ComExample.exe
```

How can I register COM objects from .net core and then use it in CPP (existing) application?

I was trying publish application with --self-contained. It doesn't work too.</Description>
    <Title_Description>Support .Net Core in RegAsm and TlbExp Currently you can create .net core application with COM object:
```C#
    [Guid("7ce1e40f-760a-4d81-b70b-61108ed15cb4")]
    [ComVisible(true)]
    public interface IComExampleClass
    {
        IComModelClass ExampleMethod(string param1 string param2);

    }

    [Guid("a8436b3f-3657-4a01-a133-fd333a84cb58")]
    [ClassInterface(ClassInterfaceType.None)]
    [ComVisible(true)]
    public class ComExampleClass : IComExampleClass
    {
        public IComModelClass ExampleMethod(string param1 string param2)
        {
            return new ComModelClass()
            {
                Result = $"{param1} + {param2}"
            };
        }
    }


    [Guid("9f5aeede-ec3e-443d-8ba0-9a9f2a6b9e53")]
    [ComVisible(true)]
    public interface IComModelClass
    {
        string Result { get; set; }
    }


    [Guid("526c6cb5-264d-4629-a894-fff02aeb9ec1")]
    [ClassInterface(ClassInterfaceType.None)]
    [ComVisible(true)]
    public class ComModelClass : IComModelClass
    {
        public string Result { get; set; }
    }

```

But you can't generate tbl file:

```cmd
"c:\Program Files (x86)\Microsoft SDKs\Windows\v10.0A\bin\NETFX 4.7.2 Tools\TlbExp.exe" ComExample.exe /out:ComExample.tlb
```

you can't register assembly using RegAsm:
```cmd
c:\Windows\Microsoft.NET\Framework64\v4.0.30319
 RegAsm.exe /tlb:ComExample.tlb C:\Users\wnagorsx\source\repos\ConsoleApp1\ConsoleApp1\bin\x64\Debug\net4.7.2\win7-x64\ComExample.exe
```

How can I register COM objects from .net core and then use it in CPP (existing) application?

I was trying publish application with --self-contained. It doesn't work too.</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19119</IssueLabelID>
    <Title>Where is source code for .NET Native toolchain?</Title>
    <Description>Hello

I'm trying to find the source code for the .NET Native toolchain.  Is this in some dotnet repo?  Specifically ilc.exe nutc_driver.exe etc.

Thanks so much</Description>
    <Title_Description>Where is source code for .NET Native toolchain? Hello

I'm trying to find the source code for the .NET Native toolchain.  Is this in some dotnet repo?  Specifically ilc.exe nutc_driver.exe etc.

Thanks so much</Title_Description>
    <Label>question</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>24/07/2018 11:40:30 PM +00:00</CreatedAt>
    <ClosedAt>26/07/2018 9:04:28 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19118</IssueLabelID>
    <Title>IMetaDataImport::GetFieldProps reporting size of field name wrong</Title>
    <Description>Working with this API and in this method:

```
HRESULT GetFieldProps(
  [in]                                           mdFieldDef      tkFieldDef
  [out]                                          mdTypeDef       *ptkTypeDef
  [out size_is(cchField) length_is(*pchField)] LPWSTR          szField
  [in]                                           ULONG           cchField
  [out]                                          ULONG           *pchField
  [out]                                          DWORD           *pdwAttr
  [out size_is( *pcbSigBlob)]                  PCCOR_SIGNATURE *ppvSigBlob
  [out]                                          ULONG           *pcbSigBlob
  [out]                                          DWORD           *pdwCPlusTypeFlag
  [out size_is( *pcchValue)]                   UVCP_CONSTANT   *ppValue
  [out]                                          ULONG           *pcchValue
);
```

The `out ULONG *pchField ` parameter is always reporting 1 byte larger than the field actually is.

For example:

```
private string MyField;
```
reports as a size of 8.

Any idea why this is?</Description>
    <Title_Description>IMetaDataImport::GetFieldProps reporting size of field name wrong Working with this API and in this method:

```
HRESULT GetFieldProps(
  [in]                                           mdFieldDef      tkFieldDef
  [out]                                          mdTypeDef       *ptkTypeDef
  [out size_is(cchField) length_is(*pchField)] LPWSTR          szField
  [in]                                           ULONG           cchField
  [out]                                          ULONG           *pchField
  [out]                                          DWORD           *pdwAttr
  [out size_is( *pcbSigBlob)]                  PCCOR_SIGNATURE *ppvSigBlob
  [out]                                          ULONG           *pcbSigBlob
  [out]                                          DWORD           *pdwCPlusTypeFlag
  [out size_is( *pcchValue)]                   UVCP_CONSTANT   *ppValue
  [out]                                          ULONG           *pcchValue
);
```

The `out ULONG *pchField ` parameter is always reporting 1 byte larger than the field actually is.

For example:

```
private string MyField;
```
reports as a size of 8.

Any idea why this is?</Title_Description>
    <Label>question</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>24/07/2018 11:02:53 PM +00:00</CreatedAt>
    <ClosedAt>25/07/2018 7:05:47 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19116</IssueLabelID>
    <Title>[RyuJIT] lack of escape analysis makes high GC overhead in SoA SIMD programs</Title>
    <Description>According to the VTune characterization https://github.com/dotnet/coreclr/pull/18839#issue-200232155 SoA SIMD programs have higher GC overhead than AoS and scalar programs because of temp object allocation.

SoA SIMD programs use `VectorPacket` as the primitive data type (Note here `VectorPacket` is a reference type `class`)
```csharp
class VectorPacket256
{
    public Vector256&lt;float&gt; Xs;
    public Vector256&lt;float&gt; Ys;
    public Vector256&lt;float&gt; Zs;
}
```
And each `VectorPacket` operation is immutable that returns a new `VectorPacket` as the result.
```csharp
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public static VectorPacket256 operator -(VectorPacket256 left VectorPacket256 right)
{
    return new VectorPacket256(Subtract(left.Xs right.Xs) Subtract(left.Ys right.Ys) Subtract(left.Zs right.Zs));
}
```
This semantic makes a lot of temp object allocations for example there are two `VectorPacket` operations in the code segment below
```csharp
    private ColorPacket256 GetNaturalColor(Vector256&lt;int&gt; things VectorPacket256 pos VectorPacket256 norms VectorPacket256 rds Scene scene)
    {
        var colors = ColorPacket256Helper.DefaultColor;
        for (int i = 0; i &lt; scene.Lights.Length; i++)
        {
            var lights = scene.Lights[i];
            var zero = SetZeroVector256&lt;float&gt;();
            var colorPacket = lights.Colors;
            VectorPacket256 ldis = lights.Positions - pos;   // VectorPacket256 operation
            VectorPacket256 livec = ldis.Normalize();        // VectorPacket256 operation
            var neatIsectDis = TestRay(new RayPacket256(pos livec) scene);
```

These two lines will be compiled by RyuJIT to
```asm
vextractf128 xmm7 ymm6 0x1		
call CORINFO_HELP_NEWSFAST  ;;; allocate the object	
vinsertf128 ymm6 ymm6 xmm7 0x1
		
mov rcx qword ptr [rsp+0x58]		
vmovupd ymm0 ymmword ptr [rcx+0x8]
vsubps ymm0 ymm0 ymmword ptr [rbx+0x8]	
vmovupd ymm1 ymmword ptr [rcx+0x28]	
vsubps ymm1 ymm1 ymmword ptr [rbx+0x28]		
vmovupd ymm2 ymmword ptr [rcx+0x48]	
vsubps ymm2 ymm2 ymmword ptr [rbx+0x48]	

vmovupd ymmword ptr [rax+0x8] ymm0	
vmovupd ymmword ptr [rax+0x28] ymm1	
vmovupd ymmword ptr [rax+0x48] ymm2	;;; Assigning the Subtract results to the new object

vmovupd ymm0 ymmword ptr [rax+0x8]		
vmulps ymm0 ymm0 ymmword ptr [rax+0x8]	
vmovupd ymm1 ymmword ptr [rax+0x28]	
vmulps ymm1 ymm1 ymmword ptr [rax+0x28]		
vmovupd ymm2 ymmword ptr [rax+0x48]	
mov qword ptr [rsp+0x50] rax		
vmulps ymm2 ymm2 ymmword ptr [rax+0x48]		
vaddps ymm0 ymm0 ymm1	
vaddps ymm0 ymm0 ymm2
vsqrtps ymm7 ymm0
```

However the two commented blocks are unnecessary and the ideal codegen could be
```asm
;;; No memory allocation for the intermediate object
mov rcx qword ptr [rsp+0x58]		
vmovupd ymm0 ymmword ptr [rcx+0x8]
vsubps ymm0 ymm0 ymmword ptr [rbx+0x8]	
vmovupd ymm1 ymmword ptr [rcx+0x28]	
vsubps ymm1 ymm1 ymmword ptr [rbx+0x28]		
vmovupd ymm2 ymmword ptr [rcx+0x48]	
vsubps ymm2 ymm2 ymmword ptr [rbx+0x48]	
vmulps ymm0 ymm0 ymm0		
vmulps ymm1 ymm1 ymm1	
vmulps ymm2 ymm2 ymm2	
vaddps ymm0 ymm0 ymm1	
vaddps ymm0 ymm0 ymm2
vsqrtps ymm7 ymm0
```

So introducing escape analysis https://github.com/dotnet/coreclr/issues/1784 and unwarping the local `VectorPacket` objects will significantly reduce the GC overhead of SIMD programs.

Additionally the current struct promotion also does not work with `VectorPacket` so if changing `VectorPacket` to `struct` from `class` that will generate so much memory copies and get worse performance.


category:cq
theme:optimization
skill-level:expert
cost:large</Description>
    <Title_Description>[RyuJIT] lack of escape analysis makes high GC overhead in SoA SIMD programs According to the VTune characterization https://github.com/dotnet/coreclr/pull/18839#issue-200232155 SoA SIMD programs have higher GC overhead than AoS and scalar programs because of temp object allocation.

SoA SIMD programs use `VectorPacket` as the primitive data type (Note here `VectorPacket` is a reference type `class`)
```csharp
class VectorPacket256
{
    public Vector256&lt;float&gt; Xs;
    public Vector256&lt;float&gt; Ys;
    public Vector256&lt;float&gt; Zs;
}
```
And each `VectorPacket` operation is immutable that returns a new `VectorPacket` as the result.
```csharp
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public static VectorPacket256 operator -(VectorPacket256 left VectorPacket256 right)
{
    return new VectorPacket256(Subtract(left.Xs right.Xs) Subtract(left.Ys right.Ys) Subtract(left.Zs right.Zs));
}
```
This semantic makes a lot of temp object allocations for example there are two `VectorPacket` operations in the code segment below
```csharp
    private ColorPacket256 GetNaturalColor(Vector256&lt;int&gt; things VectorPacket256 pos VectorPacket256 norms VectorPacket256 rds Scene scene)
    {
        var colors = ColorPacket256Helper.DefaultColor;
        for (int i = 0; i &lt; scene.Lights.Length; i++)
        {
            var lights = scene.Lights[i];
            var zero = SetZeroVector256&lt;float&gt;();
            var colorPacket = lights.Colors;
            VectorPacket256 ldis = lights.Positions - pos;   // VectorPacket256 operation
            VectorPacket256 livec = ldis.Normalize();        // VectorPacket256 operation
            var neatIsectDis = TestRay(new RayPacket256(pos livec) scene);
```

These two lines will be compiled by RyuJIT to
```asm
vextractf128 xmm7 ymm6 0x1		
call CORINFO_HELP_NEWSFAST  ;;; allocate the object	
vinsertf128 ymm6 ymm6 xmm7 0x1
		
mov rcx qword ptr [rsp+0x58]		
vmovupd ymm0 ymmword ptr [rcx+0x8]
vsubps ymm0 ymm0 ymmword ptr [rbx+0x8]	
vmovupd ymm1 ymmword ptr [rcx+0x28]	
vsubps ymm1 ymm1 ymmword ptr [rbx+0x28]		
vmovupd ymm2 ymmword ptr [rcx+0x48]	
vsubps ymm2 ymm2 ymmword ptr [rbx+0x48]	

vmovupd ymmword ptr [rax+0x8] ymm0	
vmovupd ymmword ptr [rax+0x28] ymm1	
vmovupd ymmword ptr [rax+0x48] ymm2	;;; Assigning the Subtract results to the new object

vmovupd ymm0 ymmword ptr [rax+0x8]		
vmulps ymm0 ymm0 ymmword ptr [rax+0x8]	
vmovupd ymm1 ymmword ptr [rax+0x28]	
vmulps ymm1 ymm1 ymmword ptr [rax+0x28]		
vmovupd ymm2 ymmword ptr [rax+0x48]	
mov qword ptr [rsp+0x50] rax		
vmulps ymm2 ymm2 ymmword ptr [rax+0x48]		
vaddps ymm0 ymm0 ymm1	
vaddps ymm0 ymm0 ymm2
vsqrtps ymm7 ymm0
```

However the two commented blocks are unnecessary and the ideal codegen could be
```asm
;;; No memory allocation for the intermediate object
mov rcx qword ptr [rsp+0x58]		
vmovupd ymm0 ymmword ptr [rcx+0x8]
vsubps ymm0 ymm0 ymmword ptr [rbx+0x8]	
vmovupd ymm1 ymmword ptr [rcx+0x28]	
vsubps ymm1 ymm1 ymmword ptr [rbx+0x28]		
vmovupd ymm2 ymmword ptr [rcx+0x48]	
vsubps ymm2 ymm2 ymmword ptr [rbx+0x48]	
vmulps ymm0 ymm0 ymm0		
vmulps ymm1 ymm1 ymm1	
vmulps ymm2 ymm2 ymm2	
vaddps ymm0 ymm0 ymm1	
vaddps ymm0 ymm0 ymm2
vsqrtps ymm7 ymm0
```

So introducing escape analysis https://github.com/dotnet/coreclr/issues/1784 and unwarping the local `VectorPacket` objects will significantly reduce the GC overhead of SIMD programs.

Additionally the current struct promotion also does not work with `VectorPacket` so if changing `VectorPacket` to `struct` from `class` that will generate so much memory copies and get worse performance.


category:cq
theme:optimization
skill-level:expert
cost:large</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
    <CreatedAt>24/07/2018 8:56:48 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19114</IssueLabelID>
    <Title>[WIP] Dummy change PR to dev/unix_test_workflow</Title>
    <Description>
    </Description>
    <Title_Description>[WIP] Dummy change PR to dev/unix_test_workflow </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>dotnet-bot</Assignee>
    <CreatedAt>24/07/2018 8:12:41 PM +00:00</CreatedAt>
    <ClosedAt>2/08/2018 1:10:59 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19113</IssueLabelID>
    <Title>[WIP] Dummy change PR to dev/unix_test_workflow</Title>
    <Description>
    </Description>
    <Title_Description>[WIP] Dummy change PR to dev/unix_test_workflow </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>24/07/2018 6:38:39 PM +00:00</CreatedAt>
    <ClosedAt>24/07/2018 8:13:10 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19112</IssueLabelID>
    <Title>Lightweight and dynamic driving of P/Invoke</Title>
    <Description>While Mono has `&lt;dllmap&gt;` and there is a long-standing discussion going on in https://github.com/dotnet/coreclr/issues/930 and efforts like https://github.com/dotnet/corefx/issues/17135 to work around the limitations of P/Invoke and even [`NativeLibrary`](https://github.com/dotnet/coreclr/pull/16409) was introduced I feel that we could come up with a simple solution that leverages the existing P/Invoke capabilities without the overhead and ugly machinery that comes from variations of `GetDelegateForFunctionPointer` and similar hacks that have been attempted to work around the limitations of P/Invoke.

The proposal is to add an API to inform the runtime how we where we want a particular file referenced in the `DllImport` attribute to be loaded from.   Developers would then annotate their `DllImport` attributes with a custom name and at startup their own logic would determine which library to load.

For example:

```csharp
//
// We declare our DllImport and by convention we use reverse domains to avoid clashes:
//
using System.Runtime.InteropServices;

[DllImport ("github.com/migueldeicaza/gui.cs/curses")]
extern static void initscr ();

// At startup we decide what we want to do.
static void Main ()
{
    string library = "github.com/migueldeicaza/gui.cs/curses";

    if (File.Exists ("/usr/lib/libncurses_6.so"))
        PInvoke.RegisterLibrary (library "/usr/lib/libncurses_6.so");
   else if (File.Exists ("/usr/lib/libncurses_7.so"))
        PInvoke.RegisterLibrary (library "/usr/lib/libncurses_7.so"); 
   else
        throw ();
}
```

Working around this today requires ugly hacks from Gui.cs having doubled definitions to Grpc generating proxies and entirer class hierarchies and tons of delegates to achieve the desired effect.   And the result produces more junk than the current P/Invoke does.

```Bonus points:``` we could make it so that the string passed to DllImport could have parameters similar in spirit to say a ConnectionString in SQL so we could provide defaults or even simple inline switching that is evaluated at resolution time.

For example:

```csharp
// Built-in switching capabilities similar to Dllmap:
[DllImport ("(switch 'osMac:libSystem 'osLinux:libc 'osWindows:user32)")]

// Define a key that can be referenced by PInvoke.RegisterLibrary but also provide a default if the API is not called
[DllImport ("(key 'github.com/migueldeicaza/gui.cs)(default 'ncurses)")]
```

While I can certainly add a bag of hacks to gui.cs (for forked different naming versions) and TensorFlowSharp (for CPU vs GPU vs various SIMD operation builds) none of those libraries are particularly affected by the transition speed.   But it would be a shame if we did not implement something for every other user that needs to cope with different bits of native code but does not want to pay the performance price of the `GetDelegateFrom...`


</Description>
    <Title_Description>Lightweight and dynamic driving of P/Invoke While Mono has `&lt;dllmap&gt;` and there is a long-standing discussion going on in https://github.com/dotnet/coreclr/issues/930 and efforts like https://github.com/dotnet/corefx/issues/17135 to work around the limitations of P/Invoke and even [`NativeLibrary`](https://github.com/dotnet/coreclr/pull/16409) was introduced I feel that we could come up with a simple solution that leverages the existing P/Invoke capabilities without the overhead and ugly machinery that comes from variations of `GetDelegateForFunctionPointer` and similar hacks that have been attempted to work around the limitations of P/Invoke.

The proposal is to add an API to inform the runtime how we where we want a particular file referenced in the `DllImport` attribute to be loaded from.   Developers would then annotate their `DllImport` attributes with a custom name and at startup their own logic would determine which library to load.

For example:

```csharp
//
// We declare our DllImport and by convention we use reverse domains to avoid clashes:
//
using System.Runtime.InteropServices;

[DllImport ("github.com/migueldeicaza/gui.cs/curses")]
extern static void initscr ();

// At startup we decide what we want to do.
static void Main ()
{
    string library = "github.com/migueldeicaza/gui.cs/curses";

    if (File.Exists ("/usr/lib/libncurses_6.so"))
        PInvoke.RegisterLibrary (library "/usr/lib/libncurses_6.so");
   else if (File.Exists ("/usr/lib/libncurses_7.so"))
        PInvoke.RegisterLibrary (library "/usr/lib/libncurses_7.so"); 
   else
        throw ();
}
```

Working around this today requires ugly hacks from Gui.cs having doubled definitions to Grpc generating proxies and entirer class hierarchies and tons of delegates to achieve the desired effect.   And the result produces more junk than the current P/Invoke does.

```Bonus points:``` we could make it so that the string passed to DllImport could have parameters similar in spirit to say a ConnectionString in SQL so we could provide defaults or even simple inline switching that is evaluated at resolution time.

For example:

```csharp
// Built-in switching capabilities similar to Dllmap:
[DllImport ("(switch 'osMac:libSystem 'osLinux:libc 'osWindows:user32)")]

// Define a key that can be referenced by PInvoke.RegisterLibrary but also provide a default if the API is not called
[DllImport ("(key 'github.com/migueldeicaza/gui.cs)(default 'ncurses)")]
```

While I can certainly add a bag of hacks to gui.cs (for forked different naming versions) and TensorFlowSharp (for CPU vs GPU vs various SIMD operation builds) none of those libraries are particularly affected by the transition speed.   But it would be a shame if we did not implement something for every other user that needs to cope with different bits of native code but does not want to pay the performance price of the `GetDelegateFrom...`


</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>24/07/2018 2:22:42 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19108</IssueLabelID>
    <Title>CoreCLR failed to run test in VS2017 Update 7</Title>
    <Description>CoreCLR failed to run test on Windows with VS2017 Update7. Could you please help take a look at this? Thank you!

**You can repro this issue as the steps below:**
1. git clone https://github.com/dotnet/coreclr D:\CoreCLR\src
2. Open a clean x86 prompt (C:\windows\syswow64\cmd.exe) and browse to D:\CoreCLR\src
3. build x86 release -Rebuild -- /clp:ShowCommandLine
4. build-test.cmd x86 release -- /clp:ShowCommandLine
5. tests\runtest.cmd x86 release

**Error info:**
The whole log file please see attachment.
[log_x86_test.log](https://github.com/dotnet/coreclr/files/2223051/log_x86_test.log)
</Description>
    <Title_Description>CoreCLR failed to run test in VS2017 Update 7 CoreCLR failed to run test on Windows with VS2017 Update7. Could you please help take a look at this? Thank you!

**You can repro this issue as the steps below:**
1. git clone https://github.com/dotnet/coreclr D:\CoreCLR\src
2. Open a clean x86 prompt (C:\windows\syswow64\cmd.exe) and browse to D:\CoreCLR\src
3. build x86 release -Rebuild -- /clp:ShowCommandLine
4. build-test.cmd x86 release -- /clp:ShowCommandLine
5. tests\runtest.cmd x86 release

**Error info:**
The whole log file please see attachment.
[log_x86_test.log](https://github.com/dotnet/coreclr/files/2223051/log_x86_test.log)
</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>sandreenko</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19107</IssueLabelID>
    <Title>Add Interop/PInvoke/Attributes tests</Title>
    <Description>
    </Description>
    <Title_Description>Add Interop/PInvoke/Attributes tests </Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jkoritzinsky</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19093</IssueLabelID>
    <Title>Leaked ICorProfilerCallback9 in vm/eetoprofinterfaceimpl.cpp</Title>
    <Description>Hi guys!

Looks like we forgot to Release `ICorProfilerCallback9* pCallback9` in [EEToProfInterfaceImpl::~EEToProfInterfaceImpl()](https://github.com/dotnet/coreclr/blob/67a66156d0307b49522a13618522d289268bc1f9/src/vm/eetoprofinterfaceimpl.cpp#L964). Can anyone check and fix it? 

cc: @mjsabby 

P.S. I can prepare a pull request for this issue.</Description>
    <Title_Description>Leaked ICorProfilerCallback9 in vm/eetoprofinterfaceimpl.cpp Hi guys!

Looks like we forgot to Release `ICorProfilerCallback9* pCallback9` in [EEToProfInterfaceImpl::~EEToProfInterfaceImpl()](https://github.com/dotnet/coreclr/blob/67a66156d0307b49522a13618522d289268bc1f9/src/vm/eetoprofinterfaceimpl.cpp#L964). Can anyone check and fix it? 

cc: @mjsabby 

P.S. I can prepare a pull request for this issue.</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>mjsabby</Assignee>
    <CreatedAt>23/07/2018 7:15:43 PM +00:00</CreatedAt>
    <ClosedAt>24/07/2018 4:49:25 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19091</IssueLabelID>
    <Title>[ARM32] Split CodeGen::instGen_Set_Reg_To_Imm into relocatable immediate/non-relocatable immediate cases</Title>
    <Description>As suggested in https://github.com/dotnet/coreclr/pull/19013#discussion_r204171338 the next step complement to #19013 should be splitting `instGen_Set_Reg_To_Imm` in src/jit/codegenarm.cpp into two separate functions:
1. the one that accepts  *only* relocatable immediate (as a `BYTE* addr`);
2. another one that accepts non-relocatable immediate (as a `target_ssize_t imm`). 

@BruceForstall Please feel free to add if I missed anything

category:implementation
theme:emitter
skill-level:beginner
cost:small</Description>
    <Title_Description>[ARM32] Split CodeGen::instGen_Set_Reg_To_Imm into relocatable immediate/non-relocatable immediate cases As suggested in https://github.com/dotnet/coreclr/pull/19013#discussion_r204171338 the next step complement to #19013 should be splitting `instGen_Set_Reg_To_Imm` in src/jit/codegenarm.cpp into two separate functions:
1. the one that accepts  *only* relocatable immediate (as a `BYTE* addr`);
2. another one that accepts non-relocatable immediate (as a `target_ssize_t imm`). 

@BruceForstall Please feel free to add if I missed anything

category:implementation
theme:emitter
skill-level:beginner
cost:small</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>23/07/2018 6:06:52 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19090</IssueLabelID>
    <Title>Properly document memory semantics for marshalling x-plat</Title>
    <Description>One of the base assumptions on Windows was that `CoTaskMemAlloc()` and `CoTaskMemFree()` were the canonical memory management mechanism when performing an interop. These function do not exist on x-plat scenarios so we need some explicit documentation or example where this is demonstrated.

See https://github.com/dotnet/coreclr/issues/19082</Description>
    <Title_Description>Properly document memory semantics for marshalling x-plat One of the base assumptions on Windows was that `CoTaskMemAlloc()` and `CoTaskMemFree()` were the canonical memory management mechanism when performing an interop. These function do not exist on x-plat scenarios so we need some explicit documentation or example where this is demonstrated.

See https://github.com/dotnet/coreclr/issues/19082</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>23/07/2018 6:00:33 PM +00:00</CreatedAt>
    <ClosedAt>23/07/2018 9:25:59 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19089</IssueLabelID>
    <Title>Support R2RDump on non-Windows and ARM machines</Title>
    <Description>Right now R2RDump is only supported on Windows x64 and x86. It works on Linux but the R2RDumpTests for that OS are disabled because of errors. It hasn't been tested on OSX or ARM.</Description>
    <Title_Description>Support R2RDump on non-Windows and ARM machines Right now R2RDump is only supported on Windows x64 and x86. It works on Linux but the R2RDumpTests for that OS are disabled because of errors. It hasn't been tested on OSX or ARM.</Title_Description>
    <Label>area-R2RDump</Label>
    <Assignee>nattress</Assignee>
    <CreatedAt>23/07/2018 5:39:53 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19088</IssueLabelID>
    <Title>Reduce time in .NET Threadpool's WorkStealingQueue.TrySteal method and ThredPoolWorkQueue.Dequeue methods.  </Title>
    <Description>A number of different users have noted a large amount of time in the .NET ThreadPool WorkStealingQueue.TrySteal method (Being called from [ThredPoolWorkQueue.Dequeue](https://github.com/dotnet/coreclr/blob/master/src/System.Private.CoreLib/src/System/Threading/ThreadPool.cs#L465)  method).    

From what we can tell the scenario that causes is bursty workloads.   For bursty workloads our guidance is to set a MinWorkerThreads high enough so that there are threads available to handle the burst.   For high scale machines (e.g. 16 Proc) it is not uncommon then to set this minimum in the 160-320 thread range.   

When a burst  (lets say it needs 100 threads to do the work) then those 100 threads do the work then calle Dequeue to get the next work.   However the burst is over and thus they all don't find any work left and go through a loop lin the [ThredPoolWorkQueue.Dequeue](https://github.com/dotnet/coreclr/blob/master/src/System.Private.CoreLib/src/System/Threading/ThreadPool.cs#L465)  method to find work to steal from other threads.  (which will fail).

Thus you have 100 threads spinning through 160-320 worker threads looking for more work thus requring 16K to 32K checks.   These threads 'fight' over the memory to check that the queues are empty and thus even though the check is short it consumes a non-trivial amount of CPU time.    If these bursts come frequently (e.g. every 10-100 msec) then the CPU adds up.   

Here is where we see the CPU time spent (This is on Desktop framework but the code is very similar  for .NET core).  Here is the code in Dequeue. 
```
                   if (null == callback)
                   {
100.0 |                WorkStealingQueue[] otherQueues = allThreadQueues.Current;
  1.9K|                int i = tl.random.Next(otherQueues.Length);
                       int c = otherQueues.Length;
                       while (c &gt; 0)
                       {
 49.1K|                    WorkStealingQueue otherQueue = Volatile.Read(ref otherQueues[i % otherQueues.Length]);
141.2K|                    if (otherQueue != null &amp;&amp;
                               otherQueue != wsq &amp;&amp;
                               otherQueue.TrySteal(out callback ref missedSteal))
```
And here we see the hot code in TrySteal (That 141K broken down) 
```
                   private bool TrySteal(out IThreadPoolWorkItem obj ref bool missedSteal int millisecondsTimeout)
                   {
 23.8K|                obj = null;
       
                       while (true)
                       {
 92.5K|                    if (m_headIndex &gt;= m_tailIndex)
  8.1K|                        return false;
```

In .NET Core the code is a bit different because we have created a helper called 'CanSteal' that does m_headIndex &gt;= m_tailIndex and we call this helper in Dequeue before calling TrySteal.  This helps cut the cost per iteration but does not mitigate the fact that we are doing an O(n) operation and we have to 'fight' over the memory representing m_headIndex and m_tailIndex variables)   Thus on .NET Core the problem will not show up in TrySteal and should be less severe but probably still problematic.  

To really fix the problem we need to be less aggressive about checking for stealing.   Ideally want to do some checking but we want to be much less aggressive if we know that other threads will shortly come along and do a more aggressive check.   This avoids O(N) behavior which is the fundamental problem.  

The solutions probably looks like only looking for work to steal for a subset unless we have been asked to be 'aggressive'.   We are aggressive only after a certain amount of time. 

@kouvel @stephentoub 
</Description>
    <Title_Description>Reduce time in .NET Threadpool's WorkStealingQueue.TrySteal method and ThredPoolWorkQueue.Dequeue methods.   A number of different users have noted a large amount of time in the .NET ThreadPool WorkStealingQueue.TrySteal method (Being called from [ThredPoolWorkQueue.Dequeue](https://github.com/dotnet/coreclr/blob/master/src/System.Private.CoreLib/src/System/Threading/ThreadPool.cs#L465)  method).    

From what we can tell the scenario that causes is bursty workloads.   For bursty workloads our guidance is to set a MinWorkerThreads high enough so that there are threads available to handle the burst.   For high scale machines (e.g. 16 Proc) it is not uncommon then to set this minimum in the 160-320 thread range.   

When a burst  (lets say it needs 100 threads to do the work) then those 100 threads do the work then calle Dequeue to get the next work.   However the burst is over and thus they all don't find any work left and go through a loop lin the [ThredPoolWorkQueue.Dequeue](https://github.com/dotnet/coreclr/blob/master/src/System.Private.CoreLib/src/System/Threading/ThreadPool.cs#L465)  method to find work to steal from other threads.  (which will fail).

Thus you have 100 threads spinning through 160-320 worker threads looking for more work thus requring 16K to 32K checks.   These threads 'fight' over the memory to check that the queues are empty and thus even though the check is short it consumes a non-trivial amount of CPU time.    If these bursts come frequently (e.g. every 10-100 msec) then the CPU adds up.   

Here is where we see the CPU time spent (This is on Desktop framework but the code is very similar  for .NET core).  Here is the code in Dequeue. 
```
                   if (null == callback)
                   {
100.0 |                WorkStealingQueue[] otherQueues = allThreadQueues.Current;
  1.9K|                int i = tl.random.Next(otherQueues.Length);
                       int c = otherQueues.Length;
                       while (c &gt; 0)
                       {
 49.1K|                    WorkStealingQueue otherQueue = Volatile.Read(ref otherQueues[i % otherQueues.Length]);
141.2K|                    if (otherQueue != null &amp;&amp;
                               otherQueue != wsq &amp;&amp;
                               otherQueue.TrySteal(out callback ref missedSteal))
```
And here we see the hot code in TrySteal (That 141K broken down) 
```
                   private bool TrySteal(out IThreadPoolWorkItem obj ref bool missedSteal int millisecondsTimeout)
                   {
 23.8K|                obj = null;
       
                       while (true)
                       {
 92.5K|                    if (m_headIndex &gt;= m_tailIndex)
  8.1K|                        return false;
```

In .NET Core the code is a bit different because we have created a helper called 'CanSteal' that does m_headIndex &gt;= m_tailIndex and we call this helper in Dequeue before calling TrySteal.  This helps cut the cost per iteration but does not mitigate the fact that we are doing an O(n) operation and we have to 'fight' over the memory representing m_headIndex and m_tailIndex variables)   Thus on .NET Core the problem will not show up in TrySteal and should be less severe but probably still problematic.  

To really fix the problem we need to be less aggressive about checking for stealing.   Ideally want to do some checking but we want to be much less aggressive if we know that other threads will shortly come along and do a more aggressive check.   This avoids O(N) behavior which is the fundamental problem.  

The solutions probably looks like only looking for work to steal for a subset unless we have been asked to be 'aggressive'.   We are aggressive only after a certain amount of time. 

@kouvel @stephentoub 
</Title_Description>
    <Label>area-System.Threading</Label>
    <Assignee>kouvel</Assignee>
    <CreatedAt>23/07/2018 4:56:12 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19086</IssueLabelID>
    <Title>[Ubuntu/arm][GCStress=0xC][ZapDisable] Regressions/coreclr/GitHub_12224/Test12224</Title>
    <Description>This failed twice while testing PR #18784 in 
[Ubuntu arm Cross Checked gcstress0xc_zapdisable Build and Test](https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_ubuntu_gcstress0xc_zapdisable_tst_prtest/5/consoleText)
[Ubuntu arm Cross Checked gcstress0xc_zapdisable_heapverify1 Build and Test](https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_ubuntu_gcstress0xc_zapdisable_heapverify1_tst_prtest/4/consoleText)
```
FAILED   - Regressions/coreclr/GitHub_12224/Test12224/Test12224.sh
               BEGIN EXECUTION
               /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_gcstress0xc_zapdisable_tst_prtest/bin/tests/Linux.arm.Checked/Tests/Core_Root/corerun Test12224.exe
               Expected: 100
               Actual: 255
               END EXECUTION - FAILED
```

**Note:** when the issue is resolved remove the corresponding line in tests/testsFailing.arm.txt (https://github.com/dotnet/coreclr/pull/19087)</Description>
    <Title_Description>[Ubuntu/arm][GCStress=0xC][ZapDisable] Regressions/coreclr/GitHub_12224/Test12224 This failed twice while testing PR #18784 in 
[Ubuntu arm Cross Checked gcstress0xc_zapdisable Build and Test](https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_ubuntu_gcstress0xc_zapdisable_tst_prtest/5/consoleText)
[Ubuntu arm Cross Checked gcstress0xc_zapdisable_heapverify1 Build and Test](https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_ubuntu_gcstress0xc_zapdisable_heapverify1_tst_prtest/4/consoleText)
```
FAILED   - Regressions/coreclr/GitHub_12224/Test12224/Test12224.sh
               BEGIN EXECUTION
               /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_gcstress0xc_zapdisable_tst_prtest/bin/tests/Linux.arm.Checked/Tests/Core_Root/corerun Test12224.exe
               Expected: 100
               Actual: 255
               END EXECUTION - FAILED
```

**Note:** when the issue is resolved remove the corresponding line in tests/testsFailing.arm.txt (https://github.com/dotnet/coreclr/pull/19087)</Title_Description>
    <Label>GCStress</Label>
    <Assignee>AndyAyersMS</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19085</IssueLabelID>
    <Title>[Ubuntu/arm][GCStress=0xC][JitStress] GC/API/WeakReference/Finalize2</Title>
    <Description>This has failed three times while testing PR #18784 in

[Ubuntu arm Cross Checked gcstress0xc_jitstress1 Build and Test](https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_ubuntu_gcstress0xc_jitstress1_tst_prtest/8/consoleText)
[Ubuntu arm Cross Checked gcstress0xc_jitstress2 Build and Test](https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_ubuntu_gcstress0xc_jitstress2_tst_prtest/9/consoleText)
```
FAILED   - GC/API/WeakReference/Finalize2/Finalize2.sh
               BEGIN EXECUTION
               /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_gcstress0xc_jitstress1_tst_prtest/bin/tests/Linux.arm.Checked/Tests/Core_Root/corerun Finalize2.exe
               Running ~GetTargetTest
               getTarget passed
               
               Running ~IsAliveTest
               IsAliveTest passed
               
               Running ~SetTargetTest
               setTarget failed
               
               
               Short WR Test Failed!
               
               
               Running ~GetTargetTest
               getTarget failed
               
               Running ~IsAliveTest
               IsAliveTest passed
               
               Running ~SetTargetTest
               Caught expected InvalidOperationException
               setTarget passed
               
               
               Long WR Test Passed!
               
               
               Test Failed!
               Expected: 100
               Actual: 1
               END EXECUTION - FAILED
```

**Note:** when the issue is resolved remove the corresponding line in tests/testsFailing.arm.txt (https://github.com/dotnet/coreclr/pull/19087)</Description>
    <Title_Description>[Ubuntu/arm][GCStress=0xC][JitStress] GC/API/WeakReference/Finalize2 This has failed three times while testing PR #18784 in

[Ubuntu arm Cross Checked gcstress0xc_jitstress1 Build and Test](https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_ubuntu_gcstress0xc_jitstress1_tst_prtest/8/consoleText)
[Ubuntu arm Cross Checked gcstress0xc_jitstress2 Build and Test](https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_ubuntu_gcstress0xc_jitstress2_tst_prtest/9/consoleText)
```
FAILED   - GC/API/WeakReference/Finalize2/Finalize2.sh
               BEGIN EXECUTION
               /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_gcstress0xc_jitstress1_tst_prtest/bin/tests/Linux.arm.Checked/Tests/Core_Root/corerun Finalize2.exe
               Running ~GetTargetTest
               getTarget passed
               
               Running ~IsAliveTest
               IsAliveTest passed
               
               Running ~SetTargetTest
               setTarget failed
               
               
               Short WR Test Failed!
               
               
               Running ~GetTargetTest
               getTarget failed
               
               Running ~IsAliveTest
               IsAliveTest passed
               
               Running ~SetTargetTest
               Caught expected InvalidOperationException
               setTarget passed
               
               
               Long WR Test Passed!
               
               
               Test Failed!
               Expected: 100
               Actual: 1
               END EXECUTION - FAILED
```

**Note:** when the issue is resolved remove the corresponding line in tests/testsFailing.arm.txt (https://github.com/dotnet/coreclr/pull/19087)</Title_Description>
    <Label>GCStress</Label>
    <Assignee>AndyAyersMS</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19084</IssueLabelID>
    <Title>Build failure: ARM64 build of Interop\COM\NativeServer\COMNativeServer</Title>
    <Description>Opened on behalf of @RussKeldorph

Warnings: 1
Status Message: failed

Build : Master - 20180723.04 (Product Build)
Failing configurations:
- Windows
  - Build-Tests-R2R-Release-arm64
  - Build-Tests-Release-arm64
[Mission Control Build Info](https://mc.dot.net/#/product/netcore/master/source/official~2Fcoreclr~2Fmaster~2F/type/build~2Fproduct~2F/build/20180723.04/workItem/Orchestration/analysis/external/Link)
</Description>
    <Title_Description>Build failure: ARM64 build of Interop\COM\NativeServer\COMNativeServer Opened on behalf of @RussKeldorph

Warnings: 1
Status Message: failed

Build : Master - 20180723.04 (Product Build)
Failing configurations:
- Windows
  - Build-Tests-R2R-Release-arm64
  - Build-Tests-Release-arm64
[Mission Control Build Info](https://mc.dot.net/#/product/netcore/master/source/official~2Fcoreclr~2Fmaster~2F/type/build~2Fproduct~2F/build/20180723.04/workItem/Orchestration/analysis/external/Link)
</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19082</IssueLabelID>
    <Title>Cross platform PInvoke - returning strings to .NET core 2.0</Title>
    <Description>I need to have my C++ dll return a string to .NET core 2.0 wrapper.   I want .NET to free up string when appropriate and not have to make explicit call back to C++ to deallocate string.  I've been able to do this successfully if I use CoTaskMemAlloc() (in Windows) to allocate the memory for string on C++ side but CoTaskMemAlloc is not supported in Linux.  Windows C++ solution with CoTaskMemAlloc:

**[.NET code]**
        [DllImport(EngineDllFullPath CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.LPStr)]
        public static extern string getText();

        public static string GetValue()
        {
            string s = getText();  // No need to free; .NET will take care of it
            return s;
        }

**[Unmanaged C++ code]**
       char* getText()
       {
          ...
          char* s = (char*)::CoTaskMemAlloc(size);
          ...
          return s;
       }


Is there a cross platform solution to this that doesn't use CoTaskMemAlloc that can compile/run on windows and linux?

Thanks</Description>
    <Title_Description>Cross platform PInvoke - returning strings to .NET core 2.0 I need to have my C++ dll return a string to .NET core 2.0 wrapper.   I want .NET to free up string when appropriate and not have to make explicit call back to C++ to deallocate string.  I've been able to do this successfully if I use CoTaskMemAlloc() (in Windows) to allocate the memory for string on C++ side but CoTaskMemAlloc is not supported in Linux.  Windows C++ solution with CoTaskMemAlloc:

**[.NET code]**
        [DllImport(EngineDllFullPath CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.LPStr)]
        public static extern string getText();

        public static string GetValue()
        {
            string s = getText();  // No need to free; .NET will take care of it
            return s;
        }

**[Unmanaged C++ code]**
       char* getText()
       {
          ...
          char* s = (char*)::CoTaskMemAlloc(size);
          ...
          return s;
       }


Is there a cross platform solution to this that doesn't use CoTaskMemAlloc that can compile/run on windows and linux?

Thanks</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>23/07/2018 11:23:30 AM +00:00</CreatedAt>
    <ClosedAt>23/07/2018 6:02:06 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19081</IssueLabelID>
    <Title>[x86/Windows] Assertion failed 'shiftNode-&gt;OperIsShiftOrRotate()' in lrsabuild.cpp L782 introduced by PR #18941</Title>
    <Description>x86 Windows JitStress=2 JitStressRegs=3 Assertion failed 'shiftNode-&gt;OperIsShiftOrRotate()' in lrsabuild.cpp L782 - 177 failures for outer loop tests 64 failures for inner loop tests when run with JitStress=2 JitStressRegs=3.

https://ci.dot.net/job/dotnet_coreclr/job/master/view/x86/job/jitstress/job/x86_checked_windows_nt_jitstress2_jitstressregs3/556/

Failing tests:

```
JIT_HardwareIntrinsics._X86_Sse2_Sse2_r_Sse2_r_._X86_Sse2_Sse2_r_Sse2_r_cmd -&gt; ShiftLeftLogical.Int64.1
JIT_HardwareIntrinsics._X86_Avx2_Avx2_ro_Avx2_ro_._X86_Avx2_Avx2_ro_Avx2_ro_cmd -&gt; ShiftLeftLogical.Int64.1
JIT_HardwareIntrinsics._X86_Sse2_Sse2_ro_Sse2_ro_._X86_Sse2_Sse2_ro_Sse2_ro_cmd -&gt; ShiftLeftLogical.Int64.1
JIT_HardwareIntrinsics._X86_Avx2_Avx2_r_Avx2_r_._X86_Avx2_Avx2_r_Avx2_r_cmd -&gt; ShiftLeftLogical.Int64.1

baseservices_exceptions._stacktrace_Tier1StackTrace_Tier1StackTrace_._stacktrace_Tier1StackTrace_Tier1StackTrace_cmd
CoreMangLib_cti._system_decimal_DecimalRemainder_DecimalRemainder_._system_decimal_DecimalRemainder_DecimalRemainder_cmd
CoreMangLib_cti._system_string_StringFormat2_StringFormat2_._system_string_StringFormat2_StringFormat2_cmd
CoreMangLib_cti._system_string_StringFormat1_StringFormat1_._system_string_StringFormat1_StringFormat1_cmd
CoreMangLib_cti._system_array_ArrayLastIndexOf4_ArrayLastIndexOf4_._system_array_ArrayLastIndexOf4_ArrayLastIndexOf4_cmd
CoreMangLib_cti._system_array_ArrayLastIndexOf2b_ArrayLastIndexOf2b_._system_array_ArrayLastIndexOf2b_ArrayLastIndexOf2b_cmd
CoreMangLib_cti._system_array_ArrayLastIndexOf3b_ArrayLastIndexOf3b_._system_array_ArrayLastIndexOf3b_ArrayLastIndexOf3b_cmd
CoreMangLib_cti._system_decimal_DecimalDivide_DecimalDivide_._system_decimal_DecimalDivide_DecimalDivide_cmd
JIT_CheckProjects._CheckProjects_CheckProjects_._CheckProjects_CheckProjects_cmd
JIT_CodeGenBringUpTests._DivConst_DivConst_._DivConst_DivConst_cmd
JIT_CodeGenBringUpTests._Shift_Shift_._Shift_Shift_cmd
JIT_CodeGenBringUpTests._ModConst_ModConst_._ModConst_ModConst_cmd
JIT_CodeGenBringUpTests._Rotate_Rotate_._Rotate_Rotate_cmd
JIT_Directed._shift_int64_r_int64_r_._shift_int64_r_int64_r_cmd
JIT_Directed._perffix_primitivevt_mixed1_cs_ro_mixed1_cs_ro_._perffix_primitivevt_mixed1_cs_ro_mixed1_cs_ro_cmd
JIT_Directed._zeroinit_init_struct_init_struct_._zeroinit_init_struct_init_struct_cmd
JIT_Directed._perffix_primitivevt_mixed2_cs_ro_mixed2_cs_ro_._perffix_primitivevt_mixed2_cs_ro_mixed2_cs_ro_cmd
JIT_Directed._coverage_oldtests_lclfldrem_cs_do_lclfldrem_cs_do_._coverage_oldtests_lclfldrem_cs_do_lclfldrem_cs_do_cmd
JIT_Directed._coverage_oldtests_lclflddiv_cs_ro_lclflddiv_cs_ro_._coverage_oldtests_lclflddiv_cs_ro_lclflddiv_cs_ro_cmd
JIT_Directed._shift_int64_do_int64_do_._shift_int64_do_int64_do_cmd
JIT_Directed._shift_uint64_r_uint64_r_._shift_uint64_r_uint64_r_cmd
JIT_Directed._zeroinit_init_int64_init_int64_._zeroinit_init_int64_init_int64_cmd
JIT_Directed._coverage_oldtests_lclfldrem_cs_ro_lclfldrem_cs_ro_._coverage_oldtests_lclfldrem_cs_ro_lclfldrem_cs_ro_cmd
JIT_Directed._shift_int64_ro_int64_ro_._shift_int64_ro_int64_ro_cmd
JIT_Directed._coverage_oldtests_lclflddiv_cs_do_lclflddiv_cs_do_._coverage_oldtests_lclflddiv_cs_do_lclflddiv_cs_do_cmd
JIT_Directed._shift_uint64_d_uint64_d_._shift_uint64_d_uint64_d_cmd
JIT_Directed._shift_uint64_ro_uint64_ro_._shift_uint64_ro_uint64_ro_cmd
JIT_Directed._coverage_oldtests_lclfldrem_cs_r_lclfldrem_cs_r_._coverage_oldtests_lclfldrem_cs_r_lclfldrem_cs_r_cmd
JIT_Directed._coverage_oldtests_lclfldrem_cs_d_lclfldrem_cs_d_._coverage_oldtests_lclfldrem_cs_d_lclfldrem_cs_d_cmd
JIT_Directed._tailcall_tailcall_tailcall_._tailcall_tailcall_tailcall_cmd
JIT_Directed._perffix_primitivevt_mixed2_cs_r_mixed2_cs_r_._perffix_primitivevt_mixed2_cs_r_mixed2_cs_r_cmd
JIT_Directed._perffix_primitivevt_mixed2_cs_d_mixed2_cs_d_._perffix_primitivevt_mixed2_cs_d_mixed2_cs_d_cmd
JIT_Directed._coverage_oldtests_lclflddiv_cs_r_lclflddiv_cs_r_._coverage_oldtests_lclflddiv_cs_r_lclflddiv_cs_r_cmd
JIT_Directed._coverage_oldtests_lclflddiv_cs_d_lclflddiv_cs_d_._coverage_oldtests_lclflddiv_cs_d_lclflddiv_cs_d_cmd
JIT_Directed._perffix_primitivevt_mixed2_cs_do_mixed2_cs_do_._perffix_primitivevt_mixed2_cs_do_mixed2_cs_do_cmd
JIT_Directed._perffix_primitivevt_mixed1_cs_r_mixed1_cs_r_._perffix_primitivevt_mixed1_cs_r_mixed1_cs_r_cmd
JIT_Directed._shift_uint64_do_uint64_do_._shift_uint64_do_uint64_do_cmd
JIT_Directed._shift_int64_d_int64_d_._shift_int64_d_int64_d_cmd
JIT_Directed._perffix_primitivevt_mixed1_cs_do_mixed1_cs_do_._perffix_primitivevt_mixed1_cs_do_mixed1_cs_do_cmd
JIT_Directed._perffix_primitivevt_mixed1_cs_d_mixed1_cs_d_._perffix_primitivevt_mixed1_cs_d_mixed1_cs_d_cmd
JIT_jit64._regress_vsw_539509_test1_test1_._regress_vsw_539509_test1_test1_cmd
JIT_Methodical._fp_exgen_5w1d_03_cs_d_5w1d_03_cs_d_._fp_exgen_5w1d_03_cs_d_5w1d_03_cs_d_cmd
JIT_Methodical._divrem_rem_u4rem_cs_do_u4rem_cs_do_._divrem_rem_u4rem_cs_do_u4rem_cs_do_cmd
JIT_Methodical._fp_exgen_10w250d_cs_do_10w250d_cs_do_._fp_exgen_10w250d_cs_do_10w250d_cs_do_cmd
JIT_Methodical._unsafecsharp__speed_dbgunsafe_3__speed_dbgunsafe_3_._unsafecsharp__speed_dbgunsafe_3__speed_dbgunsafe_3_cmd
JIT_Methodical._divrem_div_decimaldiv_cs_ro_decimaldiv_cs_ro_._divrem_div_decimaldiv_cs_ro_decimaldiv_cs_ro_cmd
JIT_Methodical._fp_exgen_5w1d_03_cs_r_5w1d_03_cs_r_._fp_exgen_5w1d_03_cs_r_5w1d_03_cs_r_cmd
JIT_Methodical._tailcall__il_dbgtest_implicit__il_dbgtest_implicit_._tailcall__il_dbgtest_implicit__il_dbgtest_implicit_cmd
JIT_Methodical._divrem_div_decimaldiv_cs_do_decimaldiv_cs_do_._divrem_div_decimaldiv_cs_do_decimaldiv_cs_do_cmd
JIT_Methodical._unsafecsharp__relunsafe_1__relunsafe_1_._unsafecsharp__relunsafe_1__relunsafe_1_cmd
JIT_Methodical._divrem_rem_i4rem_cs_ro_i4rem_cs_ro_._divrem_rem_i4rem_cs_ro_i4rem_cs_ro_cmd
JIT_Methodical._divrem_rem_u8rem_cs_d_u8rem_cs_d_._divrem_rem_u8rem_cs_d_u8rem_cs_d_cmd
JIT_Methodical._unsafecsharp__relunsafe_6__relunsafe_6_._unsafecsharp__relunsafe_6__relunsafe_6_cmd
JIT_Methodical._divrem_rem_i8rem_cs_do_i8rem_cs_do_._divrem_rem_i8rem_cs_do_i8rem_cs_do_cmd
JIT_Methodical._unsafecsharp__speed_relunsafe_0__speed_relunsafe_0_._unsafecsharp__speed_relunsafe_0__speed_relunsafe_0_cmd
JIT_Methodical._divrem_div_u4div_cs_ro_u4div_cs_ro_._divrem_div_u4div_cs_ro_u4div_cs_ro_cmd
JIT_Methodical._divrem_rem_u8rem_cs_r_u8rem_cs_r_._divrem_rem_u8rem_cs_r_u8rem_cs_r_cmd
JIT_Methodical._unsafecsharp__speed_dbgunsafe_4__speed_dbgunsafe_4_._unsafecsharp__speed_dbgunsafe_4__speed_dbgunsafe_4_cmd
JIT_Methodical._divrem_rem_u4rem_cs_d_u4rem_cs_d_._divrem_rem_u4rem_cs_d_u4rem_cs_d_cmd
JIT_Methodical._divrem_div_overlddiv_cs_ro_overlddiv_cs_ro_._divrem_div_overlddiv_cs_ro_overlddiv_cs_ro_cmd
JIT_Methodical._divrem_div_u8div_cs_d_u8div_cs_d_._divrem_div_u8div_cs_d_u8div_cs_d_cmd
JIT_Methodical._unsafecsharp__relunsafe_5__relunsafe_5_._unsafecsharp__relunsafe_5__relunsafe_5_cmd
JIT_Methodical._divrem_div_u8div_cs_do_u8div_cs_do_._divrem_div_u8div_cs_do_u8div_cs_do_cmd
JIT_Methodical._tailcall__il_reltest_implicit__il_reltest_implicit_._tailcall__il_reltest_implicit__il_reltest_implicit_cmd
JIT_Methodical._unsafecsharp__relunsafe_3__relunsafe_3_._unsafecsharp__relunsafe_3__relunsafe_3_cmd
JIT_Methodical._divrem_div_u4div_cs_do_u4div_cs_do_._divrem_div_u4div_cs_do_u4div_cs_do_cmd
JIT_Methodical._divrem_rem_decimalrem_cs_d_decimalrem_cs_d_._divrem_rem_decimalrem_cs_d_decimalrem_cs_d_cmd
JIT_Methodical._divrem_rem_i4rem_cs_r_i4rem_cs_r_._divrem_rem_i4rem_cs_r_i4rem_cs_r_cmd
JIT_Methodical._unsafecsharp__speed_dbgunsafe_5__speed_dbgunsafe_5_._unsafecsharp__speed_dbgunsafe_5__speed_dbgunsafe_5_cmd
JIT_Methodical._fp_exgen_1000w1d_cs_do_1000w1d_cs_do_._fp_exgen_1000w1d_cs_do_1000w1d_cs_do_cmd
JIT_Methodical._unsafecsharp__dbgunsafe_3__dbgunsafe_3_._unsafecsharp__dbgunsafe_3__dbgunsafe_3_cmd
JIT_Methodical._divrem_rem_i4rem_cs_do_i4rem_cs_do_._divrem_rem_i4rem_cs_do_i4rem_cs_do_cmd
JIT_Methodical._divrem_rem_u8rem_cs_ro_u8rem_cs_ro_._divrem_rem_u8rem_cs_ro_u8rem_cs_ro_cmd
JIT_Methodical._divrem_rem_u4rem_cs_ro_u4rem_cs_ro_._divrem_rem_u4rem_cs_ro_u4rem_cs_ro_cmd
JIT_Methodical._unsafecsharp__dbgunsafe_5__dbgunsafe_5_._unsafecsharp__dbgunsafe_5__dbgunsafe_5_cmd
JIT_Methodical._unsafecsharp__dbgunsafe_1__dbgunsafe_1_._unsafecsharp__dbgunsafe_1__dbgunsafe_1_cmd
JIT_Methodical._divrem_div_i8div_cs_ro_i8div_cs_ro_._divrem_div_i8div_cs_ro_i8div_cs_ro_cmd
JIT_Methodical._divrem_rem_decimalrem_cs_r_decimalrem_cs_r_._divrem_rem_decimalrem_cs_r_decimalrem_cs_r_cmd
JIT_Methodical._divrem_rem_overldrem_cs_do_overldrem_cs_do_._divrem_rem_overldrem_cs_do_overldrem_cs_do_cmd
JIT_Methodical._unsafecsharp__speed_dbgunsafe_1__speed_dbgunsafe_1_._unsafecsharp__speed_dbgunsafe_1__speed_dbgunsafe_1_cmd
JIT_Methodical._divrem_div_overlddiv_cs_do_overlddiv_cs_do_._divrem_div_overlddiv_cs_do_overlddiv_cs_do_cmd
JIT_Methodical._fp_exgen_10w250d_cs_d_10w250d_cs_d_._fp_exgen_10w250d_cs_d_10w250d_cs_d_cmd
JIT_Methodical._unsafecsharp__speed_relunsafe_5__speed_relunsafe_5_._unsafecsharp__speed_relunsafe_5__speed_relunsafe_5_cmd
JIT_Methodical._divrem_div_overlddiv_cs_d_overlddiv_cs_d_._divrem_div_overlddiv_cs_d_overlddiv_cs_d_cmd
JIT_Methodical._divrem_div_decimaldiv_cs_d_decimaldiv_cs_d_._divrem_div_decimaldiv_cs_d_decimaldiv_cs_d_cmd
JIT_Methodical._divrem_div_i4div_cs_ro_i4div_cs_ro_._divrem_div_i4div_cs_ro_i4div_cs_ro_cmd
JIT_Methodical._unsafecsharp__relunsafe_0__relunsafe_0_._unsafecsharp__relunsafe_0__relunsafe_0_cmd
JIT_Methodical._fp_exgen_200w1d_02_cs_r_200w1d_02_cs_r_._fp_exgen_200w1d_02_cs_r_200w1d_02_cs_r_cmd
JIT_Methodical._fp_exgen_200w1d_02_cs_ro_200w1d_02_cs_ro_._fp_exgen_200w1d_02_cs_ro_200w1d_02_cs_ro_cmd
JIT_Methodical._divrem_div_u8div_cs_r_u8div_cs_r_._divrem_div_u8div_cs_r_u8div_cs_r_cmd
JIT_Methodical._unsafecsharp__speed_relunsafe_1__speed_relunsafe_1_._unsafecsharp__speed_relunsafe_1__speed_relunsafe_1_cmd
JIT_Methodical._unsafecsharp__relunsafe_4__relunsafe_4_._unsafecsharp__relunsafe_4__relunsafe_4_cmd
JIT_Methodical._unsafecsharp__dbgunsafe_4__dbgunsafe_4_._unsafecsharp__dbgunsafe_4__dbgunsafe_4_cmd
JIT_Methodical._fp_exgen_200w1d_02_cs_do_200w1d_02_cs_do_._fp_exgen_200w1d_02_cs_do_200w1d_02_cs_do_cmd
JIT_Methodical._divrem_rem_u4rem_cs_r_u4rem_cs_r_._divrem_rem_u4rem_cs_r_u4rem_cs_r_cmd
JIT_Methodical._unsafecsharp__dbgunsafe_6__dbgunsafe_6_._unsafecsharp__dbgunsafe_6__dbgunsafe_6_cmd
JIT_Methodical._divrem_div_i4div_cs_do_i4div_cs_do_._divrem_div_i4div_cs_do_i4div_cs_do_cmd
JIT_Methodical._divrem_div_i4div_cs_r_i4div_cs_r_._divrem_div_i4div_cs_r_i4div_cs_r_cmd
JIT_Methodical._unsafecsharp__speed_dbgunsafe_0__speed_dbgunsafe_0_._unsafecsharp__speed_dbgunsafe_0__speed_dbgunsafe_0_cmd
JIT_Methodical._unsafecsharp__dbgunsafe_2__dbgunsafe_2_._unsafecsharp__dbgunsafe_2__dbgunsafe_2_cmd
JIT_Methodical._divrem_rem_overldrem_cs_d_overldrem_cs_d_._divrem_rem_overldrem_cs_d_overldrem_cs_d_cmd
JIT_Methodical._fp_exgen_10w5d_cs_do_10w5d_cs_do_._fp_exgen_10w5d_cs_do_10w5d_cs_do_cmd
JIT_Methodical._unsafecsharp__speed_relunsafe_6__speed_relunsafe_6_._unsafecsharp__speed_relunsafe_6__speed_relunsafe_6_cmd
JIT_Methodical._divrem_div_i8div_cs_r_i8div_cs_r_._divrem_div_i8div_cs_r_i8div_cs_r_cmd
JIT_Methodical._unsafecsharp__speed_dbgunsafe_2__speed_dbgunsafe_2_._unsafecsharp__speed_dbgunsafe_2__speed_dbgunsafe_2_cmd
JIT_Methodical._fp_exgen_10w5d_cs_r_10w5d_cs_r_._fp_exgen_10w5d_cs_r_10w5d_cs_r_cmd
JIT_Methodical._fp_exgen_5w1d_03_cs_ro_5w1d_03_cs_ro_._fp_exgen_5w1d_03_cs_ro_5w1d_03_cs_ro_cmd
JIT_Methodical._divrem_rem_i8rem_cs_r_i8rem_cs_r_._divrem_rem_i8rem_cs_r_i8rem_cs_r_cmd
JIT_Methodical._divrem_rem_overldrem_cs_ro_overldrem_cs_ro_._divrem_rem_overldrem_cs_ro_overldrem_cs_ro_cmd
JIT_Methodical._divrem_rem_u8rem_cs_do_u8rem_cs_do_._divrem_rem_u8rem_cs_do_u8rem_cs_do_cmd
JIT_Methodical._divrem_rem_overldrem_cs_r_overldrem_cs_r_._divrem_rem_overldrem_cs_r_overldrem_cs_r_cmd
JIT_Methodical._divrem_rem_i4rem_cs_d_i4rem_cs_d_._divrem_rem_i4rem_cs_d_i4rem_cs_d_cmd
JIT_Methodical._fp_exgen_5w1d_03_cs_do_5w1d_03_cs_do_._fp_exgen_5w1d_03_cs_do_5w1d_03_cs_do_cmd
JIT_Methodical._divrem_rem_i8rem_cs_d_i8rem_cs_d_._divrem_rem_i8rem_cs_d_i8rem_cs_d_cmd
JIT_Methodical._fp_exgen_10w5d_cs_ro_10w5d_cs_ro_._fp_exgen_10w5d_cs_ro_10w5d_cs_ro_cmd
JIT_Methodical._fp_exgen_1000w1d_cs_ro_1000w1d_cs_ro_._fp_exgen_1000w1d_cs_ro_1000w1d_cs_ro_cmd
JIT_Methodical._fp_exgen_10w250d_cs_r_10w250d_cs_r_._fp_exgen_10w250d_cs_r_10w250d_cs_r_cmd
JIT_Methodical._unsafecsharp__speed_relunsafe_4__speed_relunsafe_4_._unsafecsharp__speed_relunsafe_4__speed_relunsafe_4_cmd
JIT_Methodical._divrem_div_u4div_cs_r_u4div_cs_r_._divrem_div_u4div_cs_r_u4div_cs_r_cmd
JIT_Methodical._divrem_div_i8div_cs_do_i8div_cs_do_._divrem_div_i8div_cs_do_i8div_cs_do_cmd
JIT_Methodical._divrem_div_overlddiv_cs_r_overlddiv_cs_r_._divrem_div_overlddiv_cs_r_overlddiv_cs_r_cmd
JIT_Methodical._fp_exgen_1000w1d_cs_d_1000w1d_cs_d_._fp_exgen_1000w1d_cs_d_1000w1d_cs_d_cmd
JIT_Methodical._unsafecsharp__speed_relunsafe_3__speed_relunsafe_3_._unsafecsharp__speed_relunsafe_3__speed_relunsafe_3_cmd
JIT_Methodical._unsafecsharp__speed_relunsafe_2__speed_relunsafe_2_._unsafecsharp__speed_relunsafe_2__speed_relunsafe_2_cmd
JIT_Methodical._unsafecsharp__relunsafe_2__relunsafe_2_._unsafecsharp__relunsafe_2__relunsafe_2_cmd
JIT_Methodical._divrem_rem_decimalrem_cs_ro_decimalrem_cs_ro_._divrem_rem_decimalrem_cs_ro_decimalrem_cs_ro_cmd
JIT_Methodical._fp_exgen_1000w1d_cs_r_1000w1d_cs_r_._fp_exgen_1000w1d_cs_r_1000w1d_cs_r_cmd
JIT_Methodical._divrem_rem_decimalrem_cs_do_decimalrem_cs_do_._divrem_rem_decimalrem_cs_do_decimalrem_cs_do_cmd
JIT_Methodical._fp_exgen_10w250d_cs_ro_10w250d_cs_ro_._fp_exgen_10w250d_cs_ro_10w250d_cs_ro_cmd
JIT_Methodical._unsafecsharp__dbgunsafe_0__dbgunsafe_0_._unsafecsharp__dbgunsafe_0__dbgunsafe_0_cmd
JIT_Methodical._unsafecsharp__speed_dbgunsafe_6__speed_dbgunsafe_6_._unsafecsharp__speed_dbgunsafe_6__speed_dbgunsafe_6_cmd
JIT_Methodical._divrem_div_decimaldiv_cs_r_decimaldiv_cs_r_._divrem_div_decimaldiv_cs_r_decimaldiv_cs_r_cmd
JIT_Methodical._divrem_div_i4div_cs_d_i4div_cs_d_._divrem_div_i4div_cs_d_i4div_cs_d_cmd
JIT_Methodical._divrem_rem_i8rem_cs_ro_i8rem_cs_ro_._divrem_rem_i8rem_cs_ro_i8rem_cs_ro_cmd
JIT_Methodical._fp_exgen_10w5d_cs_d_10w5d_cs_d_._fp_exgen_10w5d_cs_d_10w5d_cs_d_cmd
JIT_Methodical._divrem_div_i8div_cs_d_i8div_cs_d_._divrem_div_i8div_cs_d_i8div_cs_d_cmd
JIT_Methodical._fp_exgen_200w1d_02_cs_d_200w1d_02_cs_d_._fp_exgen_200w1d_02_cs_d_200w1d_02_cs_d_cmd
JIT_Methodical._divrem_div_u8div_cs_ro_u8div_cs_ro_._divrem_div_u8div_cs_ro_u8div_cs_ro_cmd
JIT_Methodical._divrem_div_u4div_cs_d_u4div_cs_d_._divrem_div_u4div_cs_d_u4div_cs_d_cmd
JIT_Performance._CodeQuality_Roslyn_CscBench_CscBench_._CodeQuality_Roslyn_CscBench_CscBench_cmd
JIT_Performance._CodeQuality_BenchmarksGame_regex_redux_regex_redux_1_regex_redux_1_._CodeQuality_BenchmarksGame_regex_redux_regex_redux_1_regex_redux_1_cmd
JIT_Performance._CodeQuality_BenchmarksGame_binarytrees_binarytrees_5_binarytrees_5_._CodeQuality_BenchmarksGame_binarytrees_binarytrees_5_binarytrees_5_cmd
JIT_Performance._CodeQuality_BenchmarksGame_reverse_complement_reverse_complement_1_reverse_complement_1_._CodeQuality_BenchmarksGame_reverse_complement_reverse_complement_1_reverse_complement_1_cmd
JIT_Performance._CodeQuality_BenchmarksGame_k_nucleotide_k_nucleotide_1_k_nucleotide_1_._CodeQuality_BenchmarksGame_k_nucleotide_k_nucleotide_1_k_nucleotide_1_cmd
JIT_Performance._CodeQuality_BenchmarksGame_k_nucleotide_k_nucleotide_9_k_nucleotide_9_._CodeQuality_BenchmarksGame_k_nucleotide_k_nucleotide_9_k_nucleotide_9_cmd
JIT_Performance._CodeQuality_BenchmarksGame_regex_redux_regex_redux_5_regex_redux_5_._CodeQuality_BenchmarksGame_regex_redux_regex_redux_5_regex_redux_5_cmd
JIT_Performance._CodeQuality_BenchmarksGame_reverse_complement_reverse_complement_6_reverse_complement_6_._CodeQuality_BenchmarksGame_reverse_complement_reverse_complement_6_reverse_complement_6_cmd
JIT_Regression._JitBlue_DevDiv_406156_DevDiv_406156_DevDiv_406156_._JitBlue_DevDiv_406156_DevDiv_406156_DevDiv_406156_cmd
JIT_Regression._CLR_x86_JIT_V1_M12_Beta2_b53884_b53884_b53884_._CLR_x86_JIT_V1_M12_Beta2_b53884_b53884_b53884_cmd
JIT_Regression._CLR_x86_JIT_V1_M09_5_PDC_b29456_b29456_b29456_._CLR_x86_JIT_V1_M09_5_PDC_b29456_b29456_b29456_cmd
JIT_Regression._CLR_x86_JIT_V1_M11_Beta1_b46569_b46569_b46569_._CLR_x86_JIT_V1_M11_Beta1_b46569_b46569_b46569_cmd
JIT_Regression._CLR_x86_JIT_V1_2_M01_b00722_b00722_b00722_._CLR_x86_JIT_V1_2_M01_b00722_b00722_b00722_cmd
JIT_Regression._CLR_x86_JIT_V1_M12_Beta2_b79250_b79250_b79250_._CLR_x86_JIT_V1_M12_Beta2_b79250_b79250_b79250_cmd
JIT_Regression._CLR_x86_JIT_v2_1_b610750_b610750_b610750_._CLR_x86_JIT_v2_1_b610750_b610750_b610750_cmd
JIT_Regression._CLR_x86_JIT_V1_M12_Beta2_b59782_b59782_b59782_._CLR_x86_JIT_V1_M12_Beta2_b59782_b59782_b59782_cmd
JIT_Regression._CLR_x86_JIT_V1_M09_5_PDC_b14326_b14326_b14326_._CLR_x86_JIT_V1_M09_5_PDC_b14326_b14326_b14326_cmd
JIT_Regression._CLR_x86_JIT_V1_M09_b14277_b14277_b14277_._CLR_x86_JIT_V1_M09_b14277_b14277_b14277_cmd
JIT_Regression._CLR_x86_JIT_V1_M11_Beta1_b41278_b41278_b41278_._CLR_x86_JIT_V1_M11_Beta1_b41278_b41278_b41278_cmd
JIT_Regression._CLR_x86_JIT_V1_M12_Beta2_b71179_b71179_b71179_._CLR_x86_JIT_V1_M12_Beta2_b71179_b71179_b71179_cmd
JIT_Regression._CLR_x86_JIT_V1_M12_Beta2_b50027_b50027_b50027_._CLR_x86_JIT_V1_M12_Beta2_b50027_b50027_b50027_cmd
JIT_Regression._VS_ia64_JIT_M00_b80738_b80738_b80738_._VS_ia64_JIT_M00_b80738_b80738_b80738_cmd
JIT_Regression._CLR_x86_JIT_v2_1_b610750_b610750_32vs64_b610750_32vs64_._CLR_x86_JIT_v2_1_b610750_b610750_32vs64_b610750_32vs64_cmd
managed_Compilation._Compilation_Compilation_._Compilation_Compilation_cmd
readytorun_r2rdump._R2RDumpTest_R2RDumpTest_._R2RDumpTest_R2RDumpTest_cmd
reflection_DefaultInterfaceMethods._Emit_Emit_._Emit_Emit_cmd
reflection_Tier1Collectible._Tier1Collectible_Tier1Collectible_._Tier1Collectible_Tier1Collectible_cmd
tracing_eventlistener._eventlistener_eventlistener_._eventlistener_eventlistener_cmd
tracing_eventsource._eventsourcetrace_eventsourcetrace_eventsourcetrace_._eventsourcetrace_eventsourcetrace_eventsourcetrace_cmd
tracing_runtimeeventsource._runtimeeventsource_runtimeeventsource_._runtimeeventsource_runtimeeventsource_cmd
tracing_tracevalidation._rundown_rundown_rundown_._rundown_rundown_rundown_cmd
tracing_tracevalidation._tracelogging_tracelogging_tracelogging_._tracelogging_tracelogging_tracelogging_cmd
tracing_tracevalidation._jittingstarted_JittingStarted_JittingStarted_._jittingstarted_JittingStarted_JittingStarted_cmd
tracing_tracevalidation._inducedgc_inducedgc_inducedgc_._inducedgc_inducedgc_inducedgc_cmd
```

Output dump:

[GitHub-18941-test-output.txt](https://github.com/dotnet/coreclr/files/2219026/GitHub-18941-test-output.txt)

cc @CarolEidt @tannergooding @fiigii </Description>
    <Title_Description>[x86/Windows] Assertion failed 'shiftNode-&gt;OperIsShiftOrRotate()' in lrsabuild.cpp L782 introduced by PR #18941 x86 Windows JitStress=2 JitStressRegs=3 Assertion failed 'shiftNode-&gt;OperIsShiftOrRotate()' in lrsabuild.cpp L782 - 177 failures for outer loop tests 64 failures for inner loop tests when run with JitStress=2 JitStressRegs=3.

https://ci.dot.net/job/dotnet_coreclr/job/master/view/x86/job/jitstress/job/x86_checked_windows_nt_jitstress2_jitstressregs3/556/

Failing tests:

```
JIT_HardwareIntrinsics._X86_Sse2_Sse2_r_Sse2_r_._X86_Sse2_Sse2_r_Sse2_r_cmd -&gt; ShiftLeftLogical.Int64.1
JIT_HardwareIntrinsics._X86_Avx2_Avx2_ro_Avx2_ro_._X86_Avx2_Avx2_ro_Avx2_ro_cmd -&gt; ShiftLeftLogical.Int64.1
JIT_HardwareIntrinsics._X86_Sse2_Sse2_ro_Sse2_ro_._X86_Sse2_Sse2_ro_Sse2_ro_cmd -&gt; ShiftLeftLogical.Int64.1
JIT_HardwareIntrinsics._X86_Avx2_Avx2_r_Avx2_r_._X86_Avx2_Avx2_r_Avx2_r_cmd -&gt; ShiftLeftLogical.Int64.1

baseservices_exceptions._stacktrace_Tier1StackTrace_Tier1StackTrace_._stacktrace_Tier1StackTrace_Tier1StackTrace_cmd
CoreMangLib_cti._system_decimal_DecimalRemainder_DecimalRemainder_._system_decimal_DecimalRemainder_DecimalRemainder_cmd
CoreMangLib_cti._system_string_StringFormat2_StringFormat2_._system_string_StringFormat2_StringFormat2_cmd
CoreMangLib_cti._system_string_StringFormat1_StringFormat1_._system_string_StringFormat1_StringFormat1_cmd
CoreMangLib_cti._system_array_ArrayLastIndexOf4_ArrayLastIndexOf4_._system_array_ArrayLastIndexOf4_ArrayLastIndexOf4_cmd
CoreMangLib_cti._system_array_ArrayLastIndexOf2b_ArrayLastIndexOf2b_._system_array_ArrayLastIndexOf2b_ArrayLastIndexOf2b_cmd
CoreMangLib_cti._system_array_ArrayLastIndexOf3b_ArrayLastIndexOf3b_._system_array_ArrayLastIndexOf3b_ArrayLastIndexOf3b_cmd
CoreMangLib_cti._system_decimal_DecimalDivide_DecimalDivide_._system_decimal_DecimalDivide_DecimalDivide_cmd
JIT_CheckProjects._CheckProjects_CheckProjects_._CheckProjects_CheckProjects_cmd
JIT_CodeGenBringUpTests._DivConst_DivConst_._DivConst_DivConst_cmd
JIT_CodeGenBringUpTests._Shift_Shift_._Shift_Shift_cmd
JIT_CodeGenBringUpTests._ModConst_ModConst_._ModConst_ModConst_cmd
JIT_CodeGenBringUpTests._Rotate_Rotate_._Rotate_Rotate_cmd
JIT_Directed._shift_int64_r_int64_r_._shift_int64_r_int64_r_cmd
JIT_Directed._perffix_primitivevt_mixed1_cs_ro_mixed1_cs_ro_._perffix_primitivevt_mixed1_cs_ro_mixed1_cs_ro_cmd
JIT_Directed._zeroinit_init_struct_init_struct_._zeroinit_init_struct_init_struct_cmd
JIT_Directed._perffix_primitivevt_mixed2_cs_ro_mixed2_cs_ro_._perffix_primitivevt_mixed2_cs_ro_mixed2_cs_ro_cmd
JIT_Directed._coverage_oldtests_lclfldrem_cs_do_lclfldrem_cs_do_._coverage_oldtests_lclfldrem_cs_do_lclfldrem_cs_do_cmd
JIT_Directed._coverage_oldtests_lclflddiv_cs_ro_lclflddiv_cs_ro_._coverage_oldtests_lclflddiv_cs_ro_lclflddiv_cs_ro_cmd
JIT_Directed._shift_int64_do_int64_do_._shift_int64_do_int64_do_cmd
JIT_Directed._shift_uint64_r_uint64_r_._shift_uint64_r_uint64_r_cmd
JIT_Directed._zeroinit_init_int64_init_int64_._zeroinit_init_int64_init_int64_cmd
JIT_Directed._coverage_oldtests_lclfldrem_cs_ro_lclfldrem_cs_ro_._coverage_oldtests_lclfldrem_cs_ro_lclfldrem_cs_ro_cmd
JIT_Directed._shift_int64_ro_int64_ro_._shift_int64_ro_int64_ro_cmd
JIT_Directed._coverage_oldtests_lclflddiv_cs_do_lclflddiv_cs_do_._coverage_oldtests_lclflddiv_cs_do_lclflddiv_cs_do_cmd
JIT_Directed._shift_uint64_d_uint64_d_._shift_uint64_d_uint64_d_cmd
JIT_Directed._shift_uint64_ro_uint64_ro_._shift_uint64_ro_uint64_ro_cmd
JIT_Directed._coverage_oldtests_lclfldrem_cs_r_lclfldrem_cs_r_._coverage_oldtests_lclfldrem_cs_r_lclfldrem_cs_r_cmd
JIT_Directed._coverage_oldtests_lclfldrem_cs_d_lclfldrem_cs_d_._coverage_oldtests_lclfldrem_cs_d_lclfldrem_cs_d_cmd
JIT_Directed._tailcall_tailcall_tailcall_._tailcall_tailcall_tailcall_cmd
JIT_Directed._perffix_primitivevt_mixed2_cs_r_mixed2_cs_r_._perffix_primitivevt_mixed2_cs_r_mixed2_cs_r_cmd
JIT_Directed._perffix_primitivevt_mixed2_cs_d_mixed2_cs_d_._perffix_primitivevt_mixed2_cs_d_mixed2_cs_d_cmd
JIT_Directed._coverage_oldtests_lclflddiv_cs_r_lclflddiv_cs_r_._coverage_oldtests_lclflddiv_cs_r_lclflddiv_cs_r_cmd
JIT_Directed._coverage_oldtests_lclflddiv_cs_d_lclflddiv_cs_d_._coverage_oldtests_lclflddiv_cs_d_lclflddiv_cs_d_cmd
JIT_Directed._perffix_primitivevt_mixed2_cs_do_mixed2_cs_do_._perffix_primitivevt_mixed2_cs_do_mixed2_cs_do_cmd
JIT_Directed._perffix_primitivevt_mixed1_cs_r_mixed1_cs_r_._perffix_primitivevt_mixed1_cs_r_mixed1_cs_r_cmd
JIT_Directed._shift_uint64_do_uint64_do_._shift_uint64_do_uint64_do_cmd
JIT_Directed._shift_int64_d_int64_d_._shift_int64_d_int64_d_cmd
JIT_Directed._perffix_primitivevt_mixed1_cs_do_mixed1_cs_do_._perffix_primitivevt_mixed1_cs_do_mixed1_cs_do_cmd
JIT_Directed._perffix_primitivevt_mixed1_cs_d_mixed1_cs_d_._perffix_primitivevt_mixed1_cs_d_mixed1_cs_d_cmd
JIT_jit64._regress_vsw_539509_test1_test1_._regress_vsw_539509_test1_test1_cmd
JIT_Methodical._fp_exgen_5w1d_03_cs_d_5w1d_03_cs_d_._fp_exgen_5w1d_03_cs_d_5w1d_03_cs_d_cmd
JIT_Methodical._divrem_rem_u4rem_cs_do_u4rem_cs_do_._divrem_rem_u4rem_cs_do_u4rem_cs_do_cmd
JIT_Methodical._fp_exgen_10w250d_cs_do_10w250d_cs_do_._fp_exgen_10w250d_cs_do_10w250d_cs_do_cmd
JIT_Methodical._unsafecsharp__speed_dbgunsafe_3__speed_dbgunsafe_3_._unsafecsharp__speed_dbgunsafe_3__speed_dbgunsafe_3_cmd
JIT_Methodical._divrem_div_decimaldiv_cs_ro_decimaldiv_cs_ro_._divrem_div_decimaldiv_cs_ro_decimaldiv_cs_ro_cmd
JIT_Methodical._fp_exgen_5w1d_03_cs_r_5w1d_03_cs_r_._fp_exgen_5w1d_03_cs_r_5w1d_03_cs_r_cmd
JIT_Methodical._tailcall__il_dbgtest_implicit__il_dbgtest_implicit_._tailcall__il_dbgtest_implicit__il_dbgtest_implicit_cmd
JIT_Methodical._divrem_div_decimaldiv_cs_do_decimaldiv_cs_do_._divrem_div_decimaldiv_cs_do_decimaldiv_cs_do_cmd
JIT_Methodical._unsafecsharp__relunsafe_1__relunsafe_1_._unsafecsharp__relunsafe_1__relunsafe_1_cmd
JIT_Methodical._divrem_rem_i4rem_cs_ro_i4rem_cs_ro_._divrem_rem_i4rem_cs_ro_i4rem_cs_ro_cmd
JIT_Methodical._divrem_rem_u8rem_cs_d_u8rem_cs_d_._divrem_rem_u8rem_cs_d_u8rem_cs_d_cmd
JIT_Methodical._unsafecsharp__relunsafe_6__relunsafe_6_._unsafecsharp__relunsafe_6__relunsafe_6_cmd
JIT_Methodical._divrem_rem_i8rem_cs_do_i8rem_cs_do_._divrem_rem_i8rem_cs_do_i8rem_cs_do_cmd
JIT_Methodical._unsafecsharp__speed_relunsafe_0__speed_relunsafe_0_._unsafecsharp__speed_relunsafe_0__speed_relunsafe_0_cmd
JIT_Methodical._divrem_div_u4div_cs_ro_u4div_cs_ro_._divrem_div_u4div_cs_ro_u4div_cs_ro_cmd
JIT_Methodical._divrem_rem_u8rem_cs_r_u8rem_cs_r_._divrem_rem_u8rem_cs_r_u8rem_cs_r_cmd
JIT_Methodical._unsafecsharp__speed_dbgunsafe_4__speed_dbgunsafe_4_._unsafecsharp__speed_dbgunsafe_4__speed_dbgunsafe_4_cmd
JIT_Methodical._divrem_rem_u4rem_cs_d_u4rem_cs_d_._divrem_rem_u4rem_cs_d_u4rem_cs_d_cmd
JIT_Methodical._divrem_div_overlddiv_cs_ro_overlddiv_cs_ro_._divrem_div_overlddiv_cs_ro_overlddiv_cs_ro_cmd
JIT_Methodical._divrem_div_u8div_cs_d_u8div_cs_d_._divrem_div_u8div_cs_d_u8div_cs_d_cmd
JIT_Methodical._unsafecsharp__relunsafe_5__relunsafe_5_._unsafecsharp__relunsafe_5__relunsafe_5_cmd
JIT_Methodical._divrem_div_u8div_cs_do_u8div_cs_do_._divrem_div_u8div_cs_do_u8div_cs_do_cmd
JIT_Methodical._tailcall__il_reltest_implicit__il_reltest_implicit_._tailcall__il_reltest_implicit__il_reltest_implicit_cmd
JIT_Methodical._unsafecsharp__relunsafe_3__relunsafe_3_._unsafecsharp__relunsafe_3__relunsafe_3_cmd
JIT_Methodical._divrem_div_u4div_cs_do_u4div_cs_do_._divrem_div_u4div_cs_do_u4div_cs_do_cmd
JIT_Methodical._divrem_rem_decimalrem_cs_d_decimalrem_cs_d_._divrem_rem_decimalrem_cs_d_decimalrem_cs_d_cmd
JIT_Methodical._divrem_rem_i4rem_cs_r_i4rem_cs_r_._divrem_rem_i4rem_cs_r_i4rem_cs_r_cmd
JIT_Methodical._unsafecsharp__speed_dbgunsafe_5__speed_dbgunsafe_5_._unsafecsharp__speed_dbgunsafe_5__speed_dbgunsafe_5_cmd
JIT_Methodical._fp_exgen_1000w1d_cs_do_1000w1d_cs_do_._fp_exgen_1000w1d_cs_do_1000w1d_cs_do_cmd
JIT_Methodical._unsafecsharp__dbgunsafe_3__dbgunsafe_3_._unsafecsharp__dbgunsafe_3__dbgunsafe_3_cmd
JIT_Methodical._divrem_rem_i4rem_cs_do_i4rem_cs_do_._divrem_rem_i4rem_cs_do_i4rem_cs_do_cmd
JIT_Methodical._divrem_rem_u8rem_cs_ro_u8rem_cs_ro_._divrem_rem_u8rem_cs_ro_u8rem_cs_ro_cmd
JIT_Methodical._divrem_rem_u4rem_cs_ro_u4rem_cs_ro_._divrem_rem_u4rem_cs_ro_u4rem_cs_ro_cmd
JIT_Methodical._unsafecsharp__dbgunsafe_5__dbgunsafe_5_._unsafecsharp__dbgunsafe_5__dbgunsafe_5_cmd
JIT_Methodical._unsafecsharp__dbgunsafe_1__dbgunsafe_1_._unsafecsharp__dbgunsafe_1__dbgunsafe_1_cmd
JIT_Methodical._divrem_div_i8div_cs_ro_i8div_cs_ro_._divrem_div_i8div_cs_ro_i8div_cs_ro_cmd
JIT_Methodical._divrem_rem_decimalrem_cs_r_decimalrem_cs_r_._divrem_rem_decimalrem_cs_r_decimalrem_cs_r_cmd
JIT_Methodical._divrem_rem_overldrem_cs_do_overldrem_cs_do_._divrem_rem_overldrem_cs_do_overldrem_cs_do_cmd
JIT_Methodical._unsafecsharp__speed_dbgunsafe_1__speed_dbgunsafe_1_._unsafecsharp__speed_dbgunsafe_1__speed_dbgunsafe_1_cmd
JIT_Methodical._divrem_div_overlddiv_cs_do_overlddiv_cs_do_._divrem_div_overlddiv_cs_do_overlddiv_cs_do_cmd
JIT_Methodical._fp_exgen_10w250d_cs_d_10w250d_cs_d_._fp_exgen_10w250d_cs_d_10w250d_cs_d_cmd
JIT_Methodical._unsafecsharp__speed_relunsafe_5__speed_relunsafe_5_._unsafecsharp__speed_relunsafe_5__speed_relunsafe_5_cmd
JIT_Methodical._divrem_div_overlddiv_cs_d_overlddiv_cs_d_._divrem_div_overlddiv_cs_d_overlddiv_cs_d_cmd
JIT_Methodical._divrem_div_decimaldiv_cs_d_decimaldiv_cs_d_._divrem_div_decimaldiv_cs_d_decimaldiv_cs_d_cmd
JIT_Methodical._divrem_div_i4div_cs_ro_i4div_cs_ro_._divrem_div_i4div_cs_ro_i4div_cs_ro_cmd
JIT_Methodical._unsafecsharp__relunsafe_0__relunsafe_0_._unsafecsharp__relunsafe_0__relunsafe_0_cmd
JIT_Methodical._fp_exgen_200w1d_02_cs_r_200w1d_02_cs_r_._fp_exgen_200w1d_02_cs_r_200w1d_02_cs_r_cmd
JIT_Methodical._fp_exgen_200w1d_02_cs_ro_200w1d_02_cs_ro_._fp_exgen_200w1d_02_cs_ro_200w1d_02_cs_ro_cmd
JIT_Methodical._divrem_div_u8div_cs_r_u8div_cs_r_._divrem_div_u8div_cs_r_u8div_cs_r_cmd
JIT_Methodical._unsafecsharp__speed_relunsafe_1__speed_relunsafe_1_._unsafecsharp__speed_relunsafe_1__speed_relunsafe_1_cmd
JIT_Methodical._unsafecsharp__relunsafe_4__relunsafe_4_._unsafecsharp__relunsafe_4__relunsafe_4_cmd
JIT_Methodical._unsafecsharp__dbgunsafe_4__dbgunsafe_4_._unsafecsharp__dbgunsafe_4__dbgunsafe_4_cmd
JIT_Methodical._fp_exgen_200w1d_02_cs_do_200w1d_02_cs_do_._fp_exgen_200w1d_02_cs_do_200w1d_02_cs_do_cmd
JIT_Methodical._divrem_rem_u4rem_cs_r_u4rem_cs_r_._divrem_rem_u4rem_cs_r_u4rem_cs_r_cmd
JIT_Methodical._unsafecsharp__dbgunsafe_6__dbgunsafe_6_._unsafecsharp__dbgunsafe_6__dbgunsafe_6_cmd
JIT_Methodical._divrem_div_i4div_cs_do_i4div_cs_do_._divrem_div_i4div_cs_do_i4div_cs_do_cmd
JIT_Methodical._divrem_div_i4div_cs_r_i4div_cs_r_._divrem_div_i4div_cs_r_i4div_cs_r_cmd
JIT_Methodical._unsafecsharp__speed_dbgunsafe_0__speed_dbgunsafe_0_._unsafecsharp__speed_dbgunsafe_0__speed_dbgunsafe_0_cmd
JIT_Methodical._unsafecsharp__dbgunsafe_2__dbgunsafe_2_._unsafecsharp__dbgunsafe_2__dbgunsafe_2_cmd
JIT_Methodical._divrem_rem_overldrem_cs_d_overldrem_cs_d_._divrem_rem_overldrem_cs_d_overldrem_cs_d_cmd
JIT_Methodical._fp_exgen_10w5d_cs_do_10w5d_cs_do_._fp_exgen_10w5d_cs_do_10w5d_cs_do_cmd
JIT_Methodical._unsafecsharp__speed_relunsafe_6__speed_relunsafe_6_._unsafecsharp__speed_relunsafe_6__speed_relunsafe_6_cmd
JIT_Methodical._divrem_div_i8div_cs_r_i8div_cs_r_._divrem_div_i8div_cs_r_i8div_cs_r_cmd
JIT_Methodical._unsafecsharp__speed_dbgunsafe_2__speed_dbgunsafe_2_._unsafecsharp__speed_dbgunsafe_2__speed_dbgunsafe_2_cmd
JIT_Methodical._fp_exgen_10w5d_cs_r_10w5d_cs_r_._fp_exgen_10w5d_cs_r_10w5d_cs_r_cmd
JIT_Methodical._fp_exgen_5w1d_03_cs_ro_5w1d_03_cs_ro_._fp_exgen_5w1d_03_cs_ro_5w1d_03_cs_ro_cmd
JIT_Methodical._divrem_rem_i8rem_cs_r_i8rem_cs_r_._divrem_rem_i8rem_cs_r_i8rem_cs_r_cmd
JIT_Methodical._divrem_rem_overldrem_cs_ro_overldrem_cs_ro_._divrem_rem_overldrem_cs_ro_overldrem_cs_ro_cmd
JIT_Methodical._divrem_rem_u8rem_cs_do_u8rem_cs_do_._divrem_rem_u8rem_cs_do_u8rem_cs_do_cmd
JIT_Methodical._divrem_rem_overldrem_cs_r_overldrem_cs_r_._divrem_rem_overldrem_cs_r_overldrem_cs_r_cmd
JIT_Methodical._divrem_rem_i4rem_cs_d_i4rem_cs_d_._divrem_rem_i4rem_cs_d_i4rem_cs_d_cmd
JIT_Methodical._fp_exgen_5w1d_03_cs_do_5w1d_03_cs_do_._fp_exgen_5w1d_03_cs_do_5w1d_03_cs_do_cmd
JIT_Methodical._divrem_rem_i8rem_cs_d_i8rem_cs_d_._divrem_rem_i8rem_cs_d_i8rem_cs_d_cmd
JIT_Methodical._fp_exgen_10w5d_cs_ro_10w5d_cs_ro_._fp_exgen_10w5d_cs_ro_10w5d_cs_ro_cmd
JIT_Methodical._fp_exgen_1000w1d_cs_ro_1000w1d_cs_ro_._fp_exgen_1000w1d_cs_ro_1000w1d_cs_ro_cmd
JIT_Methodical._fp_exgen_10w250d_cs_r_10w250d_cs_r_._fp_exgen_10w250d_cs_r_10w250d_cs_r_cmd
JIT_Methodical._unsafecsharp__speed_relunsafe_4__speed_relunsafe_4_._unsafecsharp__speed_relunsafe_4__speed_relunsafe_4_cmd
JIT_Methodical._divrem_div_u4div_cs_r_u4div_cs_r_._divrem_div_u4div_cs_r_u4div_cs_r_cmd
JIT_Methodical._divrem_div_i8div_cs_do_i8div_cs_do_._divrem_div_i8div_cs_do_i8div_cs_do_cmd
JIT_Methodical._divrem_div_overlddiv_cs_r_overlddiv_cs_r_._divrem_div_overlddiv_cs_r_overlddiv_cs_r_cmd
JIT_Methodical._fp_exgen_1000w1d_cs_d_1000w1d_cs_d_._fp_exgen_1000w1d_cs_d_1000w1d_cs_d_cmd
JIT_Methodical._unsafecsharp__speed_relunsafe_3__speed_relunsafe_3_._unsafecsharp__speed_relunsafe_3__speed_relunsafe_3_cmd
JIT_Methodical._unsafecsharp__speed_relunsafe_2__speed_relunsafe_2_._unsafecsharp__speed_relunsafe_2__speed_relunsafe_2_cmd
JIT_Methodical._unsafecsharp__relunsafe_2__relunsafe_2_._unsafecsharp__relunsafe_2__relunsafe_2_cmd
JIT_Methodical._divrem_rem_decimalrem_cs_ro_decimalrem_cs_ro_._divrem_rem_decimalrem_cs_ro_decimalrem_cs_ro_cmd
JIT_Methodical._fp_exgen_1000w1d_cs_r_1000w1d_cs_r_._fp_exgen_1000w1d_cs_r_1000w1d_cs_r_cmd
JIT_Methodical._divrem_rem_decimalrem_cs_do_decimalrem_cs_do_._divrem_rem_decimalrem_cs_do_decimalrem_cs_do_cmd
JIT_Methodical._fp_exgen_10w250d_cs_ro_10w250d_cs_ro_._fp_exgen_10w250d_cs_ro_10w250d_cs_ro_cmd
JIT_Methodical._unsafecsharp__dbgunsafe_0__dbgunsafe_0_._unsafecsharp__dbgunsafe_0__dbgunsafe_0_cmd
JIT_Methodical._unsafecsharp__speed_dbgunsafe_6__speed_dbgunsafe_6_._unsafecsharp__speed_dbgunsafe_6__speed_dbgunsafe_6_cmd
JIT_Methodical._divrem_div_decimaldiv_cs_r_decimaldiv_cs_r_._divrem_div_decimaldiv_cs_r_decimaldiv_cs_r_cmd
JIT_Methodical._divrem_div_i4div_cs_d_i4div_cs_d_._divrem_div_i4div_cs_d_i4div_cs_d_cmd
JIT_Methodical._divrem_rem_i8rem_cs_ro_i8rem_cs_ro_._divrem_rem_i8rem_cs_ro_i8rem_cs_ro_cmd
JIT_Methodical._fp_exgen_10w5d_cs_d_10w5d_cs_d_._fp_exgen_10w5d_cs_d_10w5d_cs_d_cmd
JIT_Methodical._divrem_div_i8div_cs_d_i8div_cs_d_._divrem_div_i8div_cs_d_i8div_cs_d_cmd
JIT_Methodical._fp_exgen_200w1d_02_cs_d_200w1d_02_cs_d_._fp_exgen_200w1d_02_cs_d_200w1d_02_cs_d_cmd
JIT_Methodical._divrem_div_u8div_cs_ro_u8div_cs_ro_._divrem_div_u8div_cs_ro_u8div_cs_ro_cmd
JIT_Methodical._divrem_div_u4div_cs_d_u4div_cs_d_._divrem_div_u4div_cs_d_u4div_cs_d_cmd
JIT_Performance._CodeQuality_Roslyn_CscBench_CscBench_._CodeQuality_Roslyn_CscBench_CscBench_cmd
JIT_Performance._CodeQuality_BenchmarksGame_regex_redux_regex_redux_1_regex_redux_1_._CodeQuality_BenchmarksGame_regex_redux_regex_redux_1_regex_redux_1_cmd
JIT_Performance._CodeQuality_BenchmarksGame_binarytrees_binarytrees_5_binarytrees_5_._CodeQuality_BenchmarksGame_binarytrees_binarytrees_5_binarytrees_5_cmd
JIT_Performance._CodeQuality_BenchmarksGame_reverse_complement_reverse_complement_1_reverse_complement_1_._CodeQuality_BenchmarksGame_reverse_complement_reverse_complement_1_reverse_complement_1_cmd
JIT_Performance._CodeQuality_BenchmarksGame_k_nucleotide_k_nucleotide_1_k_nucleotide_1_._CodeQuality_BenchmarksGame_k_nucleotide_k_nucleotide_1_k_nucleotide_1_cmd
JIT_Performance._CodeQuality_BenchmarksGame_k_nucleotide_k_nucleotide_9_k_nucleotide_9_._CodeQuality_BenchmarksGame_k_nucleotide_k_nucleotide_9_k_nucleotide_9_cmd
JIT_Performance._CodeQuality_BenchmarksGame_regex_redux_regex_redux_5_regex_redux_5_._CodeQuality_BenchmarksGame_regex_redux_regex_redux_5_regex_redux_5_cmd
JIT_Performance._CodeQuality_BenchmarksGame_reverse_complement_reverse_complement_6_reverse_complement_6_._CodeQuality_BenchmarksGame_reverse_complement_reverse_complement_6_reverse_complement_6_cmd
JIT_Regression._JitBlue_DevDiv_406156_DevDiv_406156_DevDiv_406156_._JitBlue_DevDiv_406156_DevDiv_406156_DevDiv_406156_cmd
JIT_Regression._CLR_x86_JIT_V1_M12_Beta2_b53884_b53884_b53884_._CLR_x86_JIT_V1_M12_Beta2_b53884_b53884_b53884_cmd
JIT_Regression._CLR_x86_JIT_V1_M09_5_PDC_b29456_b29456_b29456_._CLR_x86_JIT_V1_M09_5_PDC_b29456_b29456_b29456_cmd
JIT_Regression._CLR_x86_JIT_V1_M11_Beta1_b46569_b46569_b46569_._CLR_x86_JIT_V1_M11_Beta1_b46569_b46569_b46569_cmd
JIT_Regression._CLR_x86_JIT_V1_2_M01_b00722_b00722_b00722_._CLR_x86_JIT_V1_2_M01_b00722_b00722_b00722_cmd
JIT_Regression._CLR_x86_JIT_V1_M12_Beta2_b79250_b79250_b79250_._CLR_x86_JIT_V1_M12_Beta2_b79250_b79250_b79250_cmd
JIT_Regression._CLR_x86_JIT_v2_1_b610750_b610750_b610750_._CLR_x86_JIT_v2_1_b610750_b610750_b610750_cmd
JIT_Regression._CLR_x86_JIT_V1_M12_Beta2_b59782_b59782_b59782_._CLR_x86_JIT_V1_M12_Beta2_b59782_b59782_b59782_cmd
JIT_Regression._CLR_x86_JIT_V1_M09_5_PDC_b14326_b14326_b14326_._CLR_x86_JIT_V1_M09_5_PDC_b14326_b14326_b14326_cmd
JIT_Regression._CLR_x86_JIT_V1_M09_b14277_b14277_b14277_._CLR_x86_JIT_V1_M09_b14277_b14277_b14277_cmd
JIT_Regression._CLR_x86_JIT_V1_M11_Beta1_b41278_b41278_b41278_._CLR_x86_JIT_V1_M11_Beta1_b41278_b41278_b41278_cmd
JIT_Regression._CLR_x86_JIT_V1_M12_Beta2_b71179_b71179_b71179_._CLR_x86_JIT_V1_M12_Beta2_b71179_b71179_b71179_cmd
JIT_Regression._CLR_x86_JIT_V1_M12_Beta2_b50027_b50027_b50027_._CLR_x86_JIT_V1_M12_Beta2_b50027_b50027_b50027_cmd
JIT_Regression._VS_ia64_JIT_M00_b80738_b80738_b80738_._VS_ia64_JIT_M00_b80738_b80738_b80738_cmd
JIT_Regression._CLR_x86_JIT_v2_1_b610750_b610750_32vs64_b610750_32vs64_._CLR_x86_JIT_v2_1_b610750_b610750_32vs64_b610750_32vs64_cmd
managed_Compilation._Compilation_Compilation_._Compilation_Compilation_cmd
readytorun_r2rdump._R2RDumpTest_R2RDumpTest_._R2RDumpTest_R2RDumpTest_cmd
reflection_DefaultInterfaceMethods._Emit_Emit_._Emit_Emit_cmd
reflection_Tier1Collectible._Tier1Collectible_Tier1Collectible_._Tier1Collectible_Tier1Collectible_cmd
tracing_eventlistener._eventlistener_eventlistener_._eventlistener_eventlistener_cmd
tracing_eventsource._eventsourcetrace_eventsourcetrace_eventsourcetrace_._eventsourcetrace_eventsourcetrace_eventsourcetrace_cmd
tracing_runtimeeventsource._runtimeeventsource_runtimeeventsource_._runtimeeventsource_runtimeeventsource_cmd
tracing_tracevalidation._rundown_rundown_rundown_._rundown_rundown_rundown_cmd
tracing_tracevalidation._tracelogging_tracelogging_tracelogging_._tracelogging_tracelogging_tracelogging_cmd
tracing_tracevalidation._jittingstarted_JittingStarted_JittingStarted_._jittingstarted_JittingStarted_JittingStarted_cmd
tracing_tracevalidation._inducedgc_inducedgc_inducedgc_._inducedgc_inducedgc_inducedgc_cmd
```

Output dump:

[GitHub-18941-test-output.txt](https://github.com/dotnet/coreclr/files/2219026/GitHub-18941-test-output.txt)

cc @CarolEidt @tannergooding @fiigii </Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19079</IssueLabelID>
    <Title>Remove hosthook api</Title>
    <Description>cc @luqunl @jkotas </Description>
    <Title_Description>Remove hosthook api cc @luqunl @jkotas </Title_Description>
    <Label>area-Interop</Label>
    <Assignee>luqunl</Assignee>
    <CreatedAt>23/07/2018 4:50:13 AM +00:00</CreatedAt>
    <ClosedAt>23/07/2018 10:30:58 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19078</IssueLabelID>
    <Title>JIT: multiply &amp; add not optimized to LEA when destination is a different register</Title>
    <Description>```cs
i = i * sizeof(uint) + 3;
refDestination = i;
```
JITs down to
```asm
lea     eax[rdx*4+3]
mov     dword ptr [rcx]eax
```
all well and good. But if I cut out the intermediate set....
```cs
refDestination = i * sizeof(uint) + 3
```
JIT gives me
```asm
	mov     eaxedx
	shl     eax2
	add     eax3
	mov     dword ptr [rcx]eax
```

It's bit unfortunate that `lea` isn't getting used in the scenario where it could also cut out an additional instruction.

category:cq
theme:optimization
skill-level:beginner
cost:small</Description>
    <Title_Description>JIT: multiply &amp; add not optimized to LEA when destination is a different register ```cs
i = i * sizeof(uint) + 3;
refDestination = i;
```
JITs down to
```asm
lea     eax[rdx*4+3]
mov     dword ptr [rcx]eax
```
all well and good. But if I cut out the intermediate set....
```cs
refDestination = i * sizeof(uint) + 3
```
JIT gives me
```asm
	mov     eaxedx
	shl     eax2
	add     eax3
	mov     dword ptr [rcx]eax
```

It's bit unfortunate that `lea` isn't getting used in the scenario where it could also cut out an additional instruction.

category:cq
theme:optimization
skill-level:beginner
cost:small</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>23/07/2018 3:48:18 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19076</IssueLabelID>
    <Title>JIT: Stack zeroed with rep stosd</Title>
    <Description>C# source in this gist: https://gist.github.com/Zhentar/4ffb0a5d597c4c1e788d6007f1602b21

According to vTune 5% of my execution time is in my function's prologue. This was unexpected because it hadn't been in previous iterations (and my function body had unfortunately not improved at all).
Looking at the the disassembly I see:
```asm
LineEnumerator.MoveNext()
	push    rdi
	push    rsi
	sub     rsp48h
	mov     rsircx
	lea     rdi[rsp+28h]
	mov     ecx8
	xor     eaxeax
	rep     stos dword ptr [rdi]
	mov     rcxrsi
	mov     rax0F1CD0434ED23h
	mov     qword ptr [rsp+40h]rax
```

The `rep stos dword` in there seems rather odd - at the very least it should be a `rep stos qword` with half as many iterations (although I'm not sure it would be any faster on my Skylake). But also I don't think there's any x86 architecture for which a 32 byte `rep stos` is faster than a reasonable unrolled version and the unrolled version wouldn't even be particularly large. And some of the comments in the JIT code seem to suggest that `rep stos` shouldn't ever be getting emitted.

category:cq
theme:optimization
skill-level:intermediate
cost:medium</Description>
    <Title_Description>JIT: Stack zeroed with rep stosd C# source in this gist: https://gist.github.com/Zhentar/4ffb0a5d597c4c1e788d6007f1602b21

According to vTune 5% of my execution time is in my function's prologue. This was unexpected because it hadn't been in previous iterations (and my function body had unfortunately not improved at all).
Looking at the the disassembly I see:
```asm
LineEnumerator.MoveNext()
	push    rdi
	push    rsi
	sub     rsp48h
	mov     rsircx
	lea     rdi[rsp+28h]
	mov     ecx8
	xor     eaxeax
	rep     stos dword ptr [rdi]
	mov     rcxrsi
	mov     rax0F1CD0434ED23h
	mov     qword ptr [rsp+40h]rax
```

The `rep stos dword` in there seems rather odd - at the very least it should be a `rep stos qword` with half as many iterations (although I'm not sure it would be any faster on my Skylake). But also I don't think there's any x86 architecture for which a 32 byte `rep stos` is faster than a reasonable unrolled version and the unrolled version wouldn't even be particularly large. And some of the comments in the JIT code seem to suggest that `rep stos` shouldn't ever be getting emitted.

category:cq
theme:optimization
skill-level:intermediate
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>erozenfeld</Assignee>
    <CreatedAt>22/07/2018 5:05:57 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19075</IssueLabelID>
    <Title>Pri-1 tests broken as of #18695</Title>
    <Description>All pri-1 JitStress jobs started failing after https://github.com/dotnet/coreclr/pull/18695 was merged.

I have validated locally that reverting f5f9a3456abcfdea5d886fededaa0265c80281ed fixes the issue.</Description>
    <Title_Description>Pri-1 tests broken as of #18695 All pri-1 JitStress jobs started failing after https://github.com/dotnet/coreclr/pull/18695 was merged.

I have validated locally that reverting f5f9a3456abcfdea5d886fededaa0265c80281ed fixes the issue.</Title_Description>
    <Label>
    </Label>
    <Assignee>sbomer</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19074</IssueLabelID>
    <Title>JIT can generate redundant TEST operations</Title>
    <Description>The following C# code generates assembly which has what I understand to be a redundant `test` instruction:
```cs
private static int PopulatedByte(uint bytes uint delimMask)
{
	var checkDelim = bytes ^ delimMask; //zero out matches all others non-zero
	uint onlyDelimHasSign = Bmi1.AndNot( /*notted*/ checkDelim checkDelim - INDEXOF_BYTEMULT32) &amp; 0x80808080u;
	return onlyDelimHasSign == 0 ? -1 : ByteIndexThatIsntZero(onlyDelimHasSign);
}

private static int ByteIndexThatIsntZero(uint value)
{
	return (int)(Bmi1.TrailingZeroCount(value) &gt;&gt; 3);
}
```


```asm
	xor     r9d0A0A0A0Ah
	lea     r10d[r9-1010101h]
	andn    r9dr9dr10d
	and     r9d80808080h
	test    r9dr9d   ;not needed because  flags have already been set by preceding and
	je      M04_L07
	tzcnt   r9dr9d
	shr     r9d3
	jmp     M04_L08
M04_L07
	mov     r9d0FFFFFFFFh
M04_L08
```

category:cq
theme:optimization
skill-level:beginner
cost:small</Description>
    <Title_Description>JIT can generate redundant TEST operations The following C# code generates assembly which has what I understand to be a redundant `test` instruction:
```cs
private static int PopulatedByte(uint bytes uint delimMask)
{
	var checkDelim = bytes ^ delimMask; //zero out matches all others non-zero
	uint onlyDelimHasSign = Bmi1.AndNot( /*notted*/ checkDelim checkDelim - INDEXOF_BYTEMULT32) &amp; 0x80808080u;
	return onlyDelimHasSign == 0 ? -1 : ByteIndexThatIsntZero(onlyDelimHasSign);
}

private static int ByteIndexThatIsntZero(uint value)
{
	return (int)(Bmi1.TrailingZeroCount(value) &gt;&gt; 3);
}
```


```asm
	xor     r9d0A0A0A0Ah
	lea     r10d[r9-1010101h]
	andn    r9dr9dr10d
	and     r9d80808080h
	test    r9dr9d   ;not needed because  flags have already been set by preceding and
	je      M04_L07
	tzcnt   r9dr9d
	shr     r9d3
	jmp     M04_L08
M04_L07
	mov     r9d0FFFFFFFFh
M04_L08
```

category:cq
theme:optimization
skill-level:beginner
cost:small</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>21/07/2018 6:40:15 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19071</IssueLabelID>
    <Title>HW Intrinsics: Add BSR BSF and BSWAP intrinsics</Title>
    <Description>BSR &amp; BSF are functionally equivalent to LZCNT &amp; TZCNT for non-zero values - except that instead of needing Haswell/Piledriver plus the minimum requirement is 80386. Would be nice for things like Span&lt;byte&gt;.IndexOf where it's only applied to non-zero values.

BSWAP is an 80486 instruction that reverses the order of bytes. It's supposed to be good for endian-ness conversions but I care because word on the street is that it's better than rotates for entropy diffusion in hash functions leading to some of the trendy new fast hash functions (such as FarmHash and t1ha) using it.

category:proposal
theme:intrinsics
skill-level:intermediate
cost:medium</Description>
    <Title_Description>HW Intrinsics: Add BSR, BSF, and BSWAP intrinsics BSR &amp; BSF are functionally equivalent to LZCNT &amp; TZCNT for non-zero values - except that instead of needing Haswell/Piledriver plus the minimum requirement is 80386. Would be nice for things like Span&lt;byte&gt;.IndexOf where it's only applied to non-zero values.

BSWAP is an 80486 instruction that reverses the order of bytes. It's supposed to be good for endian-ness conversions but I care because word on the street is that it's better than rotates for entropy diffusion in hash functions leading to some of the trendy new fast hash functions (such as FarmHash and t1ha) using it.

category:proposal
theme:intrinsics
skill-level:intermediate
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>21/07/2018 3:19:42 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19070</IssueLabelID>
    <Title>Fix mscordbi metadata reader alignment bug on Linux.</Title>
    <Description>Works fine on Windows minidumps but on Linux (via OpenVirtualProcess
for production breakpoints and future core dumps) the compiler's struct
alignment rules are different. On Windows classes/structs are aligned
based on the largest field. On Linux they are 4 byte aligned regardless
of the field sizes.

https://github.com/dotnet/coreclr/issues/17692</Description>
    <Title_Description>Fix mscordbi metadata reader alignment bug on Linux. Works fine on Windows minidumps but on Linux (via OpenVirtualProcess
for production breakpoints and future core dumps) the compiler's struct
alignment rules are different. On Windows classes/structs are aligned
based on the largest field. On Linux they are 4 byte aligned regardless
of the field sizes.

https://github.com/dotnet/coreclr/issues/17692</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>mikem8361</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19069</IssueLabelID>
    <Title>Prep for ported PInvoke tests from .NET Framework</Title>
    <Description>Add root MSBuild targets for Interop managed test assets
Add root CMake file for Interop native test assets</Description>
    <Title_Description>Prep for ported PInvoke tests from .NET Framework Add root MSBuild targets for Interop managed test assets
Add root CMake file for Interop native test assets</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>20/07/2018 10:49:33 PM +00:00</CreatedAt>
    <ClosedAt>24/07/2018 1:40:17 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19063</IssueLabelID>
    <Title>Update documentation for testing</Title>
    <Description>
    </Description>
    <Title_Description>Update documentation for testing </Title_Description>
    <Label>documentation</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>20/07/2018 6:43:14 PM +00:00</CreatedAt>
    <ClosedAt>20/07/2018 10:27:29 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19061</IssueLabelID>
    <Title>JIT: review costing logic in gtIsLikelyRegVar and gtSetEvalOrder</Title>
    <Description>There are a number of things here that seem questionable or holdovers from when floating point used x87.

Floats can be enregistered now:

https://github.com/dotnet/coreclr/blob/b896dd14830b600043a99c2626ea848ad679fb4f/src/jit/gentree.cpp#L2991-L2996

We don't use these instructions for float literals anymore:

https://github.com/dotnet/coreclr/blob/b896dd14830b600043a99c2626ea848ad679fb4f/src/jit/gentree.cpp#L3238-L3253

Why would enregistered variables incur sign or zero extend costs?

https://github.com/dotnet/coreclr/blob/b896dd14830b600043a99c2626ea848ad679fb4f/src/jit/gentree.cpp#L3257-L3266

Extra size cost (if legit; probably is but we should verify) should also apply to x86:

https://github.com/dotnet/coreclr/blob/b896dd14830b600043a99c2626ea848ad679fb4f/src/jit/gentree.cpp#L3279-L3289

There is probably more.

category:implementation
theme:ir
skill-level:beginner
cost:small</Description>
    <Title_Description>JIT: review costing logic in gtIsLikelyRegVar and gtSetEvalOrder There are a number of things here that seem questionable or holdovers from when floating point used x87.

Floats can be enregistered now:

https://github.com/dotnet/coreclr/blob/b896dd14830b600043a99c2626ea848ad679fb4f/src/jit/gentree.cpp#L2991-L2996

We don't use these instructions for float literals anymore:

https://github.com/dotnet/coreclr/blob/b896dd14830b600043a99c2626ea848ad679fb4f/src/jit/gentree.cpp#L3238-L3253

Why would enregistered variables incur sign or zero extend costs?

https://github.com/dotnet/coreclr/blob/b896dd14830b600043a99c2626ea848ad679fb4f/src/jit/gentree.cpp#L3257-L3266

Extra size cost (if legit; probably is but we should verify) should also apply to x86:

https://github.com/dotnet/coreclr/blob/b896dd14830b600043a99c2626ea848ad679fb4f/src/jit/gentree.cpp#L3279-L3289

There is probably more.

category:implementation
theme:ir
skill-level:beginner
cost:small</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
    <CreatedAt>20/07/2018 5:38:56 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19060</IssueLabelID>
    <Title>.NET Core applications get oom killed on Kubernetes/OpenShift</Title>
    <Description>We have been investigating why .net core applications are killed by OpenShift because they exceed their assigned memory.

OpenShift/Kubernetes informs the app via the sysfs `limit_in_bytes`. This is detected by .NET Core: 

https://github.com/dotnet/coreclr/blob/08d39ddf02c81c99bd49c19b808c855235cbabdc/src/pal/src/misc/cgroup.cpp#L25

Then memory is monitored by the oom killer based on sysfs `usage_in_bytes`.
.NET Core is using `statm` for this:

https://github.com/dotnet/coreclr/blob/08d39ddf02c81c99bd49c19b808c855235cbabdc/src/pal/src/misc/cgroup.cpp#L24

`usage_in_bytes` includes RSS and CACHE while `statm` is only RSS.
So memory in cache is a reason to get oom killed but .NET Core doesn't use it to detect when to do a GC.

We should change the implementation so it also is aware of `usage_in_bytes` to measure the memory load of the system.

CC @janvorli </Description>
    <Title_Description>.NET Core applications get oom killed on Kubernetes/OpenShift We have been investigating why .net core applications are killed by OpenShift because they exceed their assigned memory.

OpenShift/Kubernetes informs the app via the sysfs `limit_in_bytes`. This is detected by .NET Core: 

https://github.com/dotnet/coreclr/blob/08d39ddf02c81c99bd49c19b808c855235cbabdc/src/pal/src/misc/cgroup.cpp#L25

Then memory is monitored by the oom killer based on sysfs `usage_in_bytes`.
.NET Core is using `statm` for this:

https://github.com/dotnet/coreclr/blob/08d39ddf02c81c99bd49c19b808c855235cbabdc/src/pal/src/misc/cgroup.cpp#L24

`usage_in_bytes` includes RSS and CACHE while `statm` is only RSS.
So memory in cache is a reason to get oom killed but .NET Core doesn't use it to detect when to do a GC.

We should change the implementation so it also is aware of `usage_in_bytes` to measure the memory load of the system.

CC @janvorli </Title_Description>
    <Label>area-GC</Label>
    <Assignee>tmds</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19056</IssueLabelID>
    <Title>.Net Core and IoThread</Title>
    <Description>In the [document](https://github.com/dotnet/coreclr/blob/master/Documentation/project-docs/clr-configuration-knobs.md)  I not found any about IoThread message .NET Core has no IoThread?</Description>
    <Title_Description>.Net Core and IoThread In the [document](https://github.com/dotnet/coreclr/blob/master/Documentation/project-docs/clr-configuration-knobs.md)  I not found any about IoThread message .NET Core has no IoThread?</Title_Description>
    <Label>question</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>20/07/2018 9:39:29 AM +00:00</CreatedAt>
    <ClosedAt>21/07/2018 6:12:04 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19054</IssueLabelID>
    <Title>Allow rejit on attach</Title>
    <Description>
    </Description>
    <Title_Description>Allow rejit on attach </Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>davmason</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19053</IssueLabelID>
    <Title>Set function size to -1 if sizing info unavailable</Title>
    <Description>If GCInfo and RVA information is unavailable Size needs to be set to `-1` to properly display `Unavailable` in dump output. Currently it displays a misleading `Size: 0`.</Description>
    <Title_Description>Set function size to -1 if sizing info unavailable If GCInfo and RVA information is unavailable Size needs to be set to `-1` to properly display `Unavailable` in dump output. Currently it displays a misleading `Size: 0`.</Title_Description>
    <Label>area-R2RDump</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>20/07/2018 5:52:31 AM +00:00</CreatedAt>
    <ClosedAt>29/08/2018 1:09:05 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19050</IssueLabelID>
    <Title>DO NOT MERGE to master - dummy change for testing CI</Title>
    <Description>
    </Description>
    <Title_Description>DO NOT MERGE to master - dummy change for testing CI </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>noahfalk</Assignee>
    <CreatedAt>20/07/2018 12:24:15 AM +00:00</CreatedAt>
    <ClosedAt>5/09/2018 9:36:15 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19048</IssueLabelID>
    <Title>NETClientPrimitives test fails on Windows.Nano</Title>
    <Description>Remove the global disabling of NETClientPrimitives test done in #19047 by investigating why RegFree COM is failing on Windows.Nano. This is only occurring in helix builds - the test still runs properly in Jenkins CI.</Description>
    <Title_Description>NETClientPrimitives test fails on Windows.Nano Remove the global disabling of NETClientPrimitives test done in #19047 by investigating why RegFree COM is failing on Windows.Nano. This is only occurring in helix builds - the test still runs properly in Jenkins CI.</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>19/07/2018 11:22:14 PM +00:00</CreatedAt>
    <ClosedAt>26/10/2018 10:29:30 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19047</IssueLabelID>
    <Title>Address issues with COM tests in the helix build.</Title>
    <Description>Presently COM tests does not appear to run properly on Windows.Nano but
there is no way to special case that OS so disabling them on all builds.

see #19017</Description>
    <Title_Description>Address issues with COM tests in the helix build. Presently COM tests does not appear to run properly on Windows.Nano but
there is no way to special case that OS so disabling them on all builds.

see #19017</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>19/07/2018 10:57:41 PM +00:00</CreatedAt>
    <ClosedAt>20/07/2018 2:42:48 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19042</IssueLabelID>
    <Title>Disable manual COM registration logic on ARM32</Title>
    <Description>see #19020

cc @jkotas @BruceForstall </Description>
    <Title_Description>Disable manual COM registration logic on ARM32 see #19020

cc @jkotas @BruceForstall </Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>19/07/2018 7:18:36 PM +00:00</CreatedAt>
    <ClosedAt>20/07/2018 8:07:26 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19038</IssueLabelID>
    <Title>Assembly analysis without reflection</Title>
    <Description>There is sometimes a need to examine the internals of assemblies for various things like does the assembly contain class X or does it have some attribute Y etc. Using reflection and the various load options is fine for many cases but not all.

For example it's not easy to load an assembly by some tool if the app that uses it uses version overrides in its config file this is because to load the assembly requires its referenced assemblies to also be loaded and this only works under specific circumstances the app can load a different version to the one in the parent manifest because it "knows about" the overrides but a tool or utility has no idea about these overrides and may fail to load assembly A1 if the version of a referenced assembly file A2 differs from the version defined in the A1 manifest.

If we just want to open some DLL file and examine it for _certain_ things then it must be possible to do this without using reflection because the file format is well defined (as an [ECMA standard](https://www.ecma-international.org/publications/standards/Ecma-335.htm)).

Does anyone know if anything exists to let me analyze assembly files in some way without relying on reflection loading and so on?
</Description>
    <Title_Description>Assembly analysis without reflection There is sometimes a need to examine the internals of assemblies for various things like does the assembly contain class X or does it have some attribute Y etc. Using reflection and the various load options is fine for many cases but not all.

For example it's not easy to load an assembly by some tool if the app that uses it uses version overrides in its config file this is because to load the assembly requires its referenced assemblies to also be loaded and this only works under specific circumstances the app can load a different version to the one in the parent manifest because it "knows about" the overrides but a tool or utility has no idea about these overrides and may fail to load assembly A1 if the version of a referenced assembly file A2 differs from the version defined in the A1 manifest.

If we just want to open some DLL file and examine it for _certain_ things then it must be possible to do this without using reflection because the file format is well defined (as an [ECMA standard](https://www.ecma-international.org/publications/standards/Ecma-335.htm)).

Does anyone know if anything exists to let me analyze assembly files in some way without relying on reflection loading and so on?
</Title_Description>
    <Label>area-System.Reflection</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>19/07/2018 6:47:41 PM +00:00</CreatedAt>
    <ClosedAt>19/07/2018 8:44:12 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19037</IssueLabelID>
    <Title>CI: convert all builds to new Helix machines</Title>
    <Description>After https://github.com/dotnet/coreclr/issues/18048 we will use new Helix-provided machines for building ARM32/ARM64.

Convert the rest of the Jenkins CI build pool to use the same machines so all builds use the same toolset.

Currently they use the "latest-or-auto" tag (see netci.groovy `setMachineAffinity()`).
</Description>
    <Title_Description>CI: convert all builds to new Helix machines After https://github.com/dotnet/coreclr/issues/18048 we will use new Helix-provided machines for building ARM32/ARM64.

Convert the rest of the Jenkins CI build pool to use the same machines so all builds use the same toolset.

Currently they use the "latest-or-auto" tag (see netci.groovy `setMachineAffinity()`).
</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>BruceForstall</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19036</IssueLabelID>
    <Title>CI: Convert arm32/arm64 build to not require whitelist</Title>
    <Description>Currently the Windows arm32 and arm64 builds use a "whitelist" of allowed users to access a set of private build machines. After the arm64 builds change to use public tools remove the whitelist restriction for the builds. (The whitelist restriction will remain for the Windows arm64 test machines which are also used for Windows arm32 test runs.)

Add build-only arm32/arm64 PR-triggered "innerloop" jobs to every PR to protect against arm32/arm64 build failures.

Depends on https://github.com/dotnet/coreclr/issues/18048</Description>
    <Title_Description>CI: Convert arm32/arm64 build to not require whitelist Currently the Windows arm32 and arm64 builds use a "whitelist" of allowed users to access a set of private build machines. After the arm64 builds change to use public tools remove the whitelist restriction for the builds. (The whitelist restriction will remain for the Windows arm64 test machines which are also used for Windows arm32 test runs.)

Add build-only arm32/arm64 PR-triggered "innerloop" jobs to every PR to protect against arm32/arm64 build failures.

Depends on https://github.com/dotnet/coreclr/issues/18048</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>BruceForstall</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19034</IssueLabelID>
    <Title>Arm64: Verify that IP0/IP1 are reserved as needed for jumps</Title>
    <Description>IP0/IP1 are reserved in the ABI for linking stubs. Any branch with target out of range is free to contaminate these.
The register allocator needs to ensure that either 1) no lclVar is allocated to those registers at block end or 2) they are being reserved (elsewhere) if a branch may be out of range.</Description>
    <Title_Description>Arm64: Verify that IP0/IP1 are reserved as needed for jumps IP0/IP1 are reserved in the ABI for linking stubs. Any branch with target out of range is free to contaminate these.
The register allocator needs to ensure that either 1) no lclVar is allocated to those registers at block end or 2) they are being reserved (elsewhere) if a branch may be out of range.</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19031</IssueLabelID>
    <Title>Update PreReleaseLabel</Title>
    <Description>to "alphautf8string" so it sorts before "preview1" and so it's under the nuget 20 character limit</Description>
    <Title_Description>Update PreReleaseLabel to "alphautf8string" so it sorts before "preview1" and so it's under the nuget 20 character limit</Title_Description>
    <Label>
    </Label>
    <Assignee>joshfree</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19030</IssueLabelID>
    <Title>R2R build failures - Error: compilation failed for Core_Root/netcoreapp2.0/R2RDump.dll</Title>
    <Description>This fails in master for Linux r2r test legs https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_release_ubuntu_r2r_tst/1812/consoleText
https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_checked_ubuntu_r2r_tst/1852/consoleText

```
Precompiling /mnt/j/workspace/dotnet_coreclr/master/x64_release_ubuntu_r2r_tst/bin/tests/Linux.x64.Release/Tests/Core_Root/netcoreapp2.0/R2RDump.dll
Unable to precompile /mnt/j/workspace/dotnet_coreclr/master/x64_release_ubuntu_r2r_tst/bin/tests/Linux.x64.Release/Tests/Core_Root/netcoreapp2.0/R2RDump.dll.
Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0
Copyright (c) Microsoft Corporation.  All rights reserved.

Error: Could not load file or assembly 'System.CommandLine Version=1.0.0.0 Culture=neutral PublicKeyToken=null'. The located assembly's manifest definition does not match the assembly reference. (Exception from HRESULT: 0x80131040)
Error compiling /mnt/j/workspace/dotnet_coreclr/master/x64_release_ubuntu_r2r_tst/bin/tests/Linux.x64.Release/Tests/Core_Root/netcoreapp2.0/R2RDump.dll: Could not find or load a specific file. (Exception from HRESULT: 0x80131621)
Error: compilation failed for "/mnt/j/workspace/dotnet_coreclr/master/x64_release_ubuntu_r2r_tst/bin/tests/Linux.x64.Release/Tests/Core_Root/netcoreapp2.0/R2RDump.dll" (0x80131621)
Build step 'Execute shell' marked build as failure
```
On Ubuntu arm as well (failed while testing PR #19013 https://ci.dot.net/job/dotnet_coreclr/job/master/job/arm_cross_checked_ubuntu_r2r_tst_prtest/8/consoleText)</Description>
    <Title_Description>R2R build failures - Error: compilation failed for Core_Root/netcoreapp2.0/R2RDump.dll This fails in master for Linux r2r test legs https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_release_ubuntu_r2r_tst/1812/consoleText
https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_checked_ubuntu_r2r_tst/1852/consoleText

```
Precompiling /mnt/j/workspace/dotnet_coreclr/master/x64_release_ubuntu_r2r_tst/bin/tests/Linux.x64.Release/Tests/Core_Root/netcoreapp2.0/R2RDump.dll
Unable to precompile /mnt/j/workspace/dotnet_coreclr/master/x64_release_ubuntu_r2r_tst/bin/tests/Linux.x64.Release/Tests/Core_Root/netcoreapp2.0/R2RDump.dll.
Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0
Copyright (c) Microsoft Corporation.  All rights reserved.

Error: Could not load file or assembly 'System.CommandLine Version=1.0.0.0 Culture=neutral PublicKeyToken=null'. The located assembly's manifest definition does not match the assembly reference. (Exception from HRESULT: 0x80131040)
Error compiling /mnt/j/workspace/dotnet_coreclr/master/x64_release_ubuntu_r2r_tst/bin/tests/Linux.x64.Release/Tests/Core_Root/netcoreapp2.0/R2RDump.dll: Could not find or load a specific file. (Exception from HRESULT: 0x80131621)
Error: compilation failed for "/mnt/j/workspace/dotnet_coreclr/master/x64_release_ubuntu_r2r_tst/bin/tests/Linux.x64.Release/Tests/Core_Root/netcoreapp2.0/R2RDump.dll" (0x80131621)
Build step 'Execute shell' marked build as failure
```
On Ubuntu arm as well (failed while testing PR #19013 https://ci.dot.net/job/dotnet_coreclr/job/master/job/arm_cross_checked_ubuntu_r2r_tst_prtest/8/consoleText)</Title_Description>
    <Label>
    </Label>
    <Assignee>acmyu</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19029</IssueLabelID>
    <Title>JitStressRegs=0x8 regressions</Title>
    <Description>The 512 tests started failing recently in JitStress=0x8 mode

Typical failure looks like
```
corerun DecimalMaxValue.exe
Beginning test case for Field:System.Decimal.MaxValue at 7/19/2018 1:46:59 PM
Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro

[Positive]

Assert failure(PID 17348 [0x000043c4] Thread: 17348 [0x43c4]): 
Assertion failed 'emitTypeActSz[TypeGet(type)] &gt; 0' in 'DecimalMaxValue:PosTest1():bool:this' (IL size 153)

    File: src/jit/emit.h Line: 2231
```

List of fails follows

```
baseservices/exceptions/regressions/V1/SEH/VJ/NestedEx1/NestedEx1.sh
baseservices/exceptions/regressions/V1/SEH/VJ/NestedEx2/NestedEx2.sh
baseservices/threading/paramthreadstart/ThreadStartDecimal_1/ThreadStartDecimal_1.sh
baseservices/threading/paramthreadstart/ThreadStartDecimal_2/ThreadStartDecimal_2.sh
baseservices/threading/paramthreadstart/ThreadStartDecimal/ThreadStartDecimal.sh
CoreMangLib/cti/system/array/ArrayGetLength/ArrayGetLength.sh
CoreMangLib/cti/system/array/ArrayGetValue2/ArrayGetValue2.sh
CoreMangLib/cti/system/array/ArrayIndexOf1b/ArrayIndexOf1b.sh
CoreMangLib/cti/system/array/ArrayLastIndexOf1b/ArrayLastIndexOf1b.sh
CoreMangLib/cti/system/array/ArraySetValue2/ArraySetValue2.sh
CoreMangLib/cti/system/collections/generic/dictionaryenumerator/DictEnumIDictEnumget_Entry/DictEnumIDictEnumget_Entry.sh
CoreMangLib/cti/system/collections/generic/dictionaryenumerator/DictEnumIDictEnumget_Key/DictEnumIDictEnumget_Key.sh
CoreMangLib/cti/system/collections/generic/dictionaryenumerator/DictEnumIDictEnumget_Value/DictEnumIDictEnumget_Value.sh
CoreMangLib/cti/system/convert/ConvertFromBase64String/ConvertFromBase64String.sh
CoreMangLib/cti/system/convert/ConvertToByte4/ConvertToByte4.sh
CoreMangLib/cti/system/convert/ConvertToDecimal14/ConvertToDecimal14.sh
CoreMangLib/cti/system/convert/ConvertToDecimal15/ConvertToDecimal15.sh
CoreMangLib/cti/system/convert/ConvertToDecimal/ConvertToDecimal.sh
CoreMangLib/cti/system/convert/ConvertToInt16_4/ConvertToInt16_4.sh
CoreMangLib/cti/system/convert/ConvertToInt64_4/ConvertToInt64_4.sh
CoreMangLib/cti/system/convert/ConvertToSByte4/ConvertToSByte4.sh
CoreMangLib/cti/system/convert/ConvertToUInt164/ConvertToUInt164.sh
CoreMangLib/cti/system/convert/ConvertToUInt324/ConvertToUInt324.sh
CoreMangLib/cti/system/convert/ConvertToUInt647/ConvertToUInt647.sh
CoreMangLib/cti/system/decimal/DecimaFloor/DecimaFloor.sh
CoreMangLib/cti/system/decimal/DecimalMaxValue/DecimalMaxValue.sh
CoreMangLib/cti/system/decimal/DecimalMinValue/DecimalMinValue.sh
CoreMangLib/cti/system/decimal/DecimalToByte/DecimalToByte.sh
CoreMangLib/cti/system/decimal/DecimalToInt16/DecimalToInt16.sh
CoreMangLib/cti/system/decimal/DecimalToInt64/DecimalToInt64.sh
CoreMangLib/cti/system/decimal/DecimalToSByte/DecimalToSByte.sh
CoreMangLib/cti/system/decimal/DecimalToUInt16/DecimalToUInt16.sh
CoreMangLib/cti/system/decimal/DecimalToUInt32/DecimalToUInt32.sh
CoreMangLib/cti/system/decimal/DecimalToUInt64/DecimalToUInt64.sh
CoreMangLib/cti/system/double/DoubleIConvertibleToDecimal/DoubleIConvertibleToDecimal.sh
CoreMangLib/cti/system/gc/GCCollect/GCCollect.sh
CoreMangLib/cti/system/gc/GCGetTotalMemory/GCGetTotalMemory.sh
CoreMangLib/cti/system/gc/GCKeepAlive/GCKeepAlive.sh
CoreMangLib/cti/system/gc/GCReRegisterForFinalize/GCReRegisterForFinalize.sh
CoreMangLib/cti/system/gc/GCSuppressFinalize/GCSuppressFinalize.sh
CoreMangLib/cti/system/gc/GCWaitForPendingFinalizers/GCWaitForPendingFinalizers.sh
CoreMangLib/cti/system/guid/GuidNewGuid/GuidNewGuid.sh
CoreMangLib/cti/system/int16/Int16IConvertibleToDecimal/Int16IConvertibleToDecimal.sh
CoreMangLib/cti/system/int64/Int64IConvertibleToDecimal/Int64IConvertibleToDecimal.sh
CoreMangLib/cti/system/int/Int32IConvertibleToDecimal/Int32IConvertibleToDecimal.sh
CoreMangLib/cti/system/mathf/MathFAcos/MathFAcos.sh
CoreMangLib/cti/system/mathf/MathFAtan2/MathFAtan2.sh
CoreMangLib/cti/system/mathf/MathFAtan/MathFAtan.sh
CoreMangLib/cti/system/mathf/MathFCosh/MathFCosh.sh
CoreMangLib/cti/system/mathf/MathFLog/MathFLog.sh
CoreMangLib/cti/system/mathf/MathFSinh/MathFSinh.sh
CoreMangLib/cti/system/mathf/MathFTanh/MathFTanh.sh
CoreMangLib/cti/system/mathf/MathFTan/MathFTan.sh
CoreMangLib/cti/system/math/MathAcos/MathAcos.sh
CoreMangLib/cti/system/math/MathAtan2/MathAtan2.sh
CoreMangLib/cti/system/math/MathAtan/MathAtan.sh
CoreMangLib/cti/system/math/MathCosh/MathCosh.sh
CoreMangLib/cti/system/math/MathLog/MathLog.sh
CoreMangLib/cti/system/math/mathRound1/mathRound1.sh
CoreMangLib/cti/system/math/MathRound2/MathRound2.sh
CoreMangLib/cti/system/math/MathSinh/MathSinh.sh
CoreMangLib/cti/system/math/MathTanh/MathTanh.sh
CoreMangLib/cti/system/math/MathTan/MathTan.sh
CoreMangLib/cti/system/object/ObjectFinalize/ObjectFinalize.sh
CoreMangLib/cti/system/sbyte/SByteIConvertibleToDecimal/SByteIConvertibleToDecimal.sh
CoreMangLib/cti/system/string/StringEquals6/StringEquals6.sh
CoreMangLib/cti/system/uint16/UInt16IConvertibleToDecimal/UInt16IConvertibleToDecimal.sh
CoreMangLib/cti/system/uint32/UInt32IConvertibleToDecimal/UInt32IConvertibleToDecimal.sh
CoreMangLib/cti/system/uint64/UInt64IConvertibleToDecimal/UInt64IConvertibleToDecimal.sh
CoreMangLib/cti/system/weakreference/WeakReferenceCtor2_PSC/WeakReferenceCtor2_PSC.sh
CoreMangLib/cti/system/weakreference/WeakReferenceIsAliveb_PSC/WeakReferenceIsAliveb_PSC.sh
CoreMangLib/cti/system/weakreference/WeakReferenceIsAlive_PSC/WeakReferenceIsAlive_PSC.sh
CoreMangLib/cti/system/weakreference/WeakReferenceTargetb_PSC/WeakReferenceTargetb_PSC.sh
CoreMangLib/system/delegate/miscellaneous/ClosedStatic/ClosedStatic.sh
CoreMangLib/system/guid/Guid_Parsing/Guid_Parsing.sh
CoreMangLib/system/span/RefStructWithSpan/RefStructWithSpan.sh
GC/API/GC/Collect_Forced_1/Collect_Forced_1.sh
GC/API/GC/Collect_Forced_2/Collect_Forced_2.sh
GC/API/GC/Collect_Forced_3/Collect_Forced_3.sh
GC/Features/HeapExpansion/bestfit_1/bestfit_1.sh
GC/Features/HeapExpansion/bestfit/bestfit.sh
GC/Features/HeapExpansion/bestfit-threaded/bestfit-threaded.sh
GC/Features/Pinning/PinningOther/PinnedCollect/PinnedCollect.sh
GC/Regressions/v2.0-beta2/471729/471729/471729.sh
GC/Scenarios/FinalizeTimeout/FinalizeTimeout/FinalizeTimeout.sh
Interop/SimpleStruct/SimpleStruct/SimpleStruct.sh
JIT/CheckProjects/CheckProjects/CheckProjects.sh
JIT/CodeGenBringUpTests/StructReturn/StructReturn.sh
JIT/Directed/coverage/oldtests/lclfldadd_cs_d/lclfldadd_cs_d.sh
JIT/Directed/coverage/oldtests/lclfldadd_cs_do/lclfldadd_cs_do.sh
JIT/Directed/coverage/oldtests/lclfldadd_cs_r/lclfldadd_cs_r.sh
JIT/Directed/coverage/oldtests/lclfldadd_cs_ro/lclfldadd_cs_ro.sh
JIT/Directed/coverage/oldtests/lclflddiv_cs_d/lclflddiv_cs_d.sh
JIT/Directed/coverage/oldtests/lclflddiv_cs_do/lclflddiv_cs_do.sh
JIT/Directed/coverage/oldtests/lclflddiv_cs_r/lclflddiv_cs_r.sh
JIT/Directed/coverage/oldtests/lclflddiv_cs_ro/lclflddiv_cs_ro.sh
JIT/Directed/coverage/oldtests/lclfldmul_cs_d/lclfldmul_cs_d.sh
JIT/Directed/coverage/oldtests/lclfldmul_cs_do/lclfldmul_cs_do.sh
JIT/Directed/coverage/oldtests/lclfldmul_cs_r/lclfldmul_cs_r.sh
JIT/Directed/coverage/oldtests/lclfldmul_cs_ro/lclfldmul_cs_ro.sh
JIT/Directed/coverage/oldtests/lclfldrem_cs_d/lclfldrem_cs_d.sh
JIT/Directed/coverage/oldtests/lclfldrem_cs_do/lclfldrem_cs_do.sh
JIT/Directed/coverage/oldtests/lclfldrem_cs_r/lclfldrem_cs_r.sh
JIT/Directed/coverage/oldtests/lclfldrem_cs_ro/lclfldrem_cs_ro.sh
JIT/Directed/coverage/oldtests/lclfldsub_cs_d/lclfldsub_cs_d.sh
JIT/Directed/coverage/oldtests/lclfldsub_cs_do/lclfldsub_cs_do.sh
JIT/Directed/coverage/oldtests/lclfldsub_cs_r/lclfldsub_cs_r.sh
JIT/Directed/coverage/oldtests/lclfldsub_cs_ro/lclfldsub_cs_ro.sh
JIT/Directed/coverage/oldtests/stfldstatic1_il_d/stfldstatic1_il_d.sh
JIT/Directed/coverage/oldtests/stfldstatic2_il_d/stfldstatic2_il_d.sh
JIT/Directed/nullabletypes/boxunboxinterface_d/boxunboxinterface_d.sh
JIT/Directed/nullabletypes/boxunboxinterface_r/boxunboxinterface_r.sh
JIT/Directed/nullabletypes/castclassinterface_d/castclassinterface_d.sh
JIT/Directed/nullabletypes/castclassinterface_r/castclassinterface_r.sh
JIT/Directed/nullabletypes/castclassvaluetype_d/castclassvaluetype_d.sh
JIT/Directed/nullabletypes/castclassvaluetype_r/castclassvaluetype_r.sh
JIT/Directed/nullabletypes/Desktop/boxunboxvaluetype_r/boxunboxvaluetype_r.sh
JIT/Directed/perffix/primitivevt/mixed1_cs_d/mixed1_cs_d.sh
JIT/Directed/perffix/primitivevt/mixed1_cs_do/mixed1_cs_do.sh
JIT/Directed/perffix/primitivevt/mixed1_cs_r/mixed1_cs_r.sh
JIT/Directed/perffix/primitivevt/mixed1_cs_ro/mixed1_cs_ro.sh
JIT/Directed/perffix/primitivevt/mixed2_cs_d/mixed2_cs_d.sh
JIT/Directed/perffix/primitivevt/mixed2_cs_do/mixed2_cs_do.sh
JIT/Directed/perffix/primitivevt/mixed2_cs_r/mixed2_cs_r.sh
JIT/Directed/perffix/primitivevt/mixed2_cs_ro/mixed2_cs_ro.sh
JIT/Generics/Fields/static_assignment_class01/static_assignment_class01.sh
JIT/Generics/Fields/static_assignment_struct01/static_assignment_struct01.sh
JIT/Generics/Fields/static_passing_class01/static_passing_class01.sh
JIT/Generics/Fields/static_passing_struct01/static_passing_struct01.sh
JIT/HardwareIntrinsics/Arm64/Crypto/Crypto.sh
JIT/HardwareIntrinsics/X86/Avx2/Avx2_r/Avx2_r.sh
JIT/HardwareIntrinsics/X86/Avx2/Avx2_ro/Avx2_ro.sh
JIT/HardwareIntrinsics/X86/Avx2/ConvertToVector256_r/ConvertToVector256_r.sh
JIT/HardwareIntrinsics/X86/Avx2/ShiftLeftLogicalVariable_r/ShiftLeftLogicalVariable_r.sh
JIT/HardwareIntrinsics/X86/Avx2/ShiftRightLogicalVariable_r/ShiftRightLogicalVariable_r.sh
JIT/HardwareIntrinsics/X86/Avx2_Vector128/Avx2_r/Avx2_r.sh
JIT/HardwareIntrinsics/X86/Avx2_Vector128/Avx2_ro/Avx2_ro.sh
JIT/HardwareIntrinsics/X86/Avx/Avx_r/Avx_r.sh
JIT/HardwareIntrinsics/X86/Avx/Avx_ro/Avx_ro.sh
JIT/HardwareIntrinsics/X86/Avx/BroadcastScalarToVector128_r/BroadcastScalarToVector128_r.sh
JIT/HardwareIntrinsics/X86/Avx/Compare_r/Compare_r.sh
JIT/HardwareIntrinsics/X86/Avx/CompareScalar_r/CompareScalar_r.sh
JIT/HardwareIntrinsics/X86/Avx/CompareScalar_ro/CompareScalar_ro.sh
JIT/HardwareIntrinsics/X86/Avx/ConvertToVector_r/ConvertToVector_r.sh
JIT/HardwareIntrinsics/X86/Avx/ConvertToVector_ro/ConvertToVector_ro.sh
JIT/HardwareIntrinsics/X86/Avx/InsertExtractVector128_r/InsertExtractVector128_r.sh
JIT/HardwareIntrinsics/X86/Avx/InsertExtractVector128_ro/InsertExtractVector128_ro.sh
JIT/HardwareIntrinsics/X86/Avx/MaskLoad_r/MaskLoad_r.sh
JIT/HardwareIntrinsics/X86/Bmi1/Bmi1_ro/Bmi1_ro.sh
JIT/HardwareIntrinsics/X86/Bmi2/Bmi2_ro/Bmi2_ro.sh
JIT/HardwareIntrinsics/X86/Fma_Vector128/Fma_r/Fma_r.sh
JIT/HardwareIntrinsics/X86/Fma_Vector128/Fma_ro/Fma_ro.sh
JIT/HardwareIntrinsics/X86/General/VectorArgs_r/VectorArgs_r.sh
JIT/HardwareIntrinsics/X86/General/VectorRet_r/VectorRet_r.sh
JIT/HardwareIntrinsics/X86/General/VectorUnused_r/VectorUnused_r.sh
JIT/HardwareIntrinsics/X86/Sse2/CompareEqualScalar_r/CompareEqualScalar_r.sh
JIT/HardwareIntrinsics/X86/Sse2/CompareGreaterThanOrEqualScalar_r/CompareGreaterThanOrEqualScalar_r.sh
JIT/HardwareIntrinsics/X86/Sse2/CompareGreaterThanOrEqualScalar_ro/CompareGreaterThanOrEqualScalar_ro.sh
JIT/HardwareIntrinsics/X86/Sse2/CompareGreaterThanScalar_r/CompareGreaterThanScalar_r.sh
JIT/HardwareIntrinsics/X86/Sse2/CompareLessThanOrEqualScalar_r/CompareLessThanOrEqualScalar_r.sh
JIT/HardwareIntrinsics/X86/Sse2/CompareLessThanScalar_r/CompareLessThanScalar_r.sh
JIT/HardwareIntrinsics/X86/Sse2/CompareNotEqualScalar_r/CompareNotEqualScalar_r.sh
JIT/HardwareIntrinsics/X86/Sse2/CompareNotGreaterThanOrEqualScalar_r/CompareNotGreaterThanOrEqualScalar_r.sh
JIT/HardwareIntrinsics/X86/Sse2/CompareNotGreaterThanScalar_r/CompareNotGreaterThanScalar_r.sh
JIT/HardwareIntrinsics/X86/Sse2/CompareNotLessThanOrEqualScalar_r/CompareNotLessThanOrEqualScalar_r.sh
JIT/HardwareIntrinsics/X86/Sse2/CompareNotLessThanScalar_r/CompareNotLessThanScalar_r.sh
JIT/HardwareIntrinsics/X86/Sse2/CompareOrderedScalar_r/CompareOrderedScalar_r.sh
JIT/HardwareIntrinsics/X86/Sse2/CompareUnorderedScalar_r/CompareUnorderedScalar_r.sh
JIT/HardwareIntrinsics/X86/Sse2/ConvertScalarToVector128Double_r/ConvertScalarToVector128Double_r.sh
JIT/HardwareIntrinsics/X86/Sse2/ConvertScalarToVector128Int32_r/ConvertScalarToVector128Int32_r.sh
JIT/HardwareIntrinsics/X86/Sse2/ConvertScalarToVector128Int64_r/ConvertScalarToVector128Int64_r.sh
JIT/HardwareIntrinsics/X86/Sse2/ConvertScalarToVector128Single_r/ConvertScalarToVector128Single_r.sh
JIT/HardwareIntrinsics/X86/Sse2/ConvertScalarToVector128UInt32_r/ConvertScalarToVector128UInt32_r.sh
JIT/HardwareIntrinsics/X86/Sse2/ConvertScalarToVector128UInt64_r/ConvertScalarToVector128UInt64_r.sh
JIT/HardwareIntrinsics/X86/Sse2/ConvertToInt32_r/ConvertToInt32_r.sh
JIT/HardwareIntrinsics/X86/Sse2/ConvertToVector128Double_r/ConvertToVector128Double_r.sh
JIT/HardwareIntrinsics/X86/Sse2/ConvertToVector128Int32_r/ConvertToVector128Int32_r.sh
JIT/HardwareIntrinsics/X86/Sse2/ConvertToVector128Int32WithTruncation_r/ConvertToVector128Int32WithTruncation_r.sh
JIT/HardwareIntrinsics/X86/Sse2/ConvertToVector128Single_r/ConvertToVector128Single_r.sh
JIT/HardwareIntrinsics/X86/Sse2/LoadAlignedVector128_r/LoadAlignedVector128_r.sh
JIT/HardwareIntrinsics/X86/Sse2/LoadHigh_r/LoadHigh_r.sh
JIT/HardwareIntrinsics/X86/Sse2/LoadLow_r/LoadLow_r.sh
JIT/HardwareIntrinsics/X86/Sse2/LoadScalarVector128_r/LoadScalarVector128_r.sh
JIT/HardwareIntrinsics/X86/Sse2/LoadVector128_r/LoadVector128_r.sh
JIT/HardwareIntrinsics/X86/Sse2/MultiplyHigh_r/MultiplyHigh_r.sh
JIT/HardwareIntrinsics/X86/Sse2/MultiplyHorizontalAdd_r/MultiplyHorizontalAdd_r.sh
JIT/HardwareIntrinsics/X86/Sse2/MultiplyLow_r/MultiplyLow_r.sh
JIT/HardwareIntrinsics/X86/Sse2/Multiply_r/Multiply_r.sh
JIT/HardwareIntrinsics/X86/Sse2/PackSignedSaturate_r/PackSignedSaturate_r.sh
JIT/HardwareIntrinsics/X86/Sse2/PackUnsignedSaturate_r/PackUnsignedSaturate_r.sh
JIT/HardwareIntrinsics/X86/Sse2/SetScalarVector128_r/SetScalarVector128_r.sh
JIT/HardwareIntrinsics/X86/Sse2/SetVector128_ro/SetVector128_ro.sh
JIT/HardwareIntrinsics/X86/Sse2/SetVector128_r/SetVector128_r.sh
JIT/HardwareIntrinsics/X86/Sse2/SetZeroVector128_r/SetZeroVector128_r.sh
JIT/HardwareIntrinsics/X86/Sse2/ShuffleHigh_r/ShuffleHigh_r.sh
JIT/HardwareIntrinsics/X86/Sse2/ShuffleLow_r/ShuffleLow_r.sh
JIT/HardwareIntrinsics/X86/Sse2/Shuffle_r/Shuffle_r.sh
JIT/HardwareIntrinsics/X86/Sse2/Sqrt_r/Sqrt_r.sh
JIT/HardwareIntrinsics/X86/Sse2/SqrtScalar_r/SqrtScalar_r.sh
JIT/HardwareIntrinsics/X86/Sse2/Sse2_ro/Sse2_ro.sh
JIT/HardwareIntrinsics/X86/Sse2/Sse2_r/Sse2_r.sh
JIT/HardwareIntrinsics/X86/Sse2/StoreAlignedNonTemporal_r/StoreAlignedNonTemporal_r.sh
JIT/HardwareIntrinsics/X86/Sse2/StoreAligned_r/StoreAligned_r.sh
JIT/HardwareIntrinsics/X86/Sse2/StoreHigh_r/StoreHigh_r.sh
JIT/HardwareIntrinsics/X86/Sse2/StoreLow_r/StoreLow_r.sh
JIT/HardwareIntrinsics/X86/Sse2/Store_r/Store_r.sh
JIT/HardwareIntrinsics/X86/Sse2/StoreScalar_r/StoreScalar_r.sh
JIT/HardwareIntrinsics/X86/Sse2/SumAbsoluteDifferences_r/SumAbsoluteDifferences_r.sh
JIT/HardwareIntrinsics/X86/Sse2/UnpackHigh_r/UnpackHigh_r.sh
JIT/HardwareIntrinsics/X86/Sse2/UnpackLow_r/UnpackLow_r.sh
JIT/HardwareIntrinsics/X86/Sse3/LoadAndDuplicateToVector128_r/LoadAndDuplicateToVector128_r.sh
JIT/HardwareIntrinsics/X86/Sse3/LoadDquVector128_r/LoadDquVector128_r.sh
JIT/HardwareIntrinsics/X86/Sse3/MoveAndDuplicate_r/MoveAndDuplicate_r.sh
JIT/HardwareIntrinsics/X86/Sse3/MoveHighAndDuplicate_r/MoveHighAndDuplicate_r.sh
JIT/HardwareIntrinsics/X86/Sse3/MoveLowAndDuplicate_r/MoveLowAndDuplicate_r.sh
JIT/HardwareIntrinsics/X86/Sse3/Sse3_ro/Sse3_ro.sh
JIT/HardwareIntrinsics/X86/Sse3/Sse3_r/Sse3_r.sh
JIT/HardwareIntrinsics/X86/Sse41/Blend_r/Blend_r.sh
JIT/HardwareIntrinsics/X86/Sse41/ConvertToVector128_r/ConvertToVector128_r.sh
JIT/HardwareIntrinsics/X86/Sse41/ConvertToVector128_ro/ConvertToVector128_ro.sh
JIT/HardwareIntrinsics/X86/Sse41/DotProduct_r/DotProduct_r.sh
JIT/HardwareIntrinsics/X86/Sse41/LoadAlignedVector128NonTemporal_r/LoadAlignedVector128NonTemporal_r.sh
JIT/HardwareIntrinsics/X86/Sse41/MinHorizontal_r/MinHorizontal_r.sh
JIT/HardwareIntrinsics/X86/Sse41/MinHorizontal_ro/MinHorizontal_ro.sh
JIT/HardwareIntrinsics/X86/Sse41/MultipleSumAbsoluteDifferences_r/MultipleSumAbsoluteDifferences_r.sh
JIT/HardwareIntrinsics/X86/Sse41/MultipleSumAbsoluteDifferences_ro/MultipleSumAbsoluteDifferences_ro.sh
JIT/HardwareIntrinsics/X86/Sse41/Multiply_r/Multiply_r.sh
JIT/HardwareIntrinsics/X86/Sse41/Sse41_ro/Sse41_ro.sh
JIT/HardwareIntrinsics/X86/Sse41/Sse41_r/Sse41_r.sh
JIT/HardwareIntrinsics/X86/Sse42/Sse42_ro/Sse42_ro.sh
JIT/HardwareIntrinsics/X86/Sse42/Sse42_r/Sse42_r.sh
JIT/HardwareIntrinsics/X86/Sse/ConvertScalarToVector128Single_r/ConvertScalarToVector128Single_r.sh
JIT/HardwareIntrinsics/X86/Sse/ConvertToInt32_r/ConvertToInt32_r.sh
JIT/HardwareIntrinsics/X86/Sse/ConvertToInt32WithTruncation_r/ConvertToInt32WithTruncation_r.sh
JIT/HardwareIntrinsics/X86/Sse/ConvertToInt64_r/ConvertToInt64_r.sh
JIT/HardwareIntrinsics/X86/Sse/ConvertToInt64WithTruncation_r/ConvertToInt64WithTruncation_r.sh
JIT/HardwareIntrinsics/X86/Sse/ConvertToSingle_r/ConvertToSingle_r.sh
JIT/HardwareIntrinsics/X86/Sse/LoadAlignedVector128_r/LoadAlignedVector128_r.sh
JIT/HardwareIntrinsics/X86/Sse/LoadHigh_r/LoadHigh_r.sh
JIT/HardwareIntrinsics/X86/Sse/LoadLow_r/LoadLow_r.sh
JIT/HardwareIntrinsics/X86/Sse/LoadScalarVector128_r/LoadScalarVector128_r.sh
JIT/HardwareIntrinsics/X86/Sse/LoadVector128_r/LoadVector128_r.sh
JIT/HardwareIntrinsics/X86/Sse/MoveHighToLow_r/MoveHighToLow_r.sh
JIT/HardwareIntrinsics/X86/Sse/MoveLowToHigh_r/MoveLowToHigh_r.sh
JIT/HardwareIntrinsics/X86/Sse/MoveMask_r/MoveMask_r.sh
JIT/HardwareIntrinsics/X86/Sse/MoveScalar_r/MoveScalar_r.sh
JIT/HardwareIntrinsics/X86/Sse/Reciprocal_r/Reciprocal_r.sh
JIT/HardwareIntrinsics/X86/Sse/ReciprocalScalar_r/ReciprocalScalar_r.sh
JIT/HardwareIntrinsics/X86/Sse/ReciprocalSqrt_r/ReciprocalSqrt_r.sh
JIT/HardwareIntrinsics/X86/Sse/ReciprocalSqrtScalar_r/ReciprocalSqrtScalar_r.sh
JIT/HardwareIntrinsics/X86/Sse/SetAllVector128_r/SetAllVector128_r.sh
JIT/HardwareIntrinsics/X86/Sse/SetScalarVector128_r/SetScalarVector128_r.sh
JIT/HardwareIntrinsics/X86/Sse/SetVector128_r/SetVector128_r.sh
JIT/HardwareIntrinsics/X86/Sse/SetZeroVector128_r/SetZeroVector128_r.sh
JIT/HardwareIntrinsics/X86/Sse/Shuffle_r/Shuffle_r.sh
JIT/HardwareIntrinsics/X86/Sse/Sqrt_r/Sqrt_r.sh
JIT/HardwareIntrinsics/X86/Sse/SqrtScalar_r/SqrtScalar_r.sh
JIT/HardwareIntrinsics/X86/Sse/Sse_ro/Sse_ro.sh
JIT/HardwareIntrinsics/X86/Sse/Sse_r/Sse_r.sh
JIT/HardwareIntrinsics/X86/Sse/StaticCast_ro/StaticCast_ro.sh
JIT/HardwareIntrinsics/X86/Sse/StaticCast_r/StaticCast_r.sh
JIT/HardwareIntrinsics/X86/Sse/StoreAlignedNonTemporal_r/StoreAlignedNonTemporal_r.sh
JIT/HardwareIntrinsics/X86/Sse/StoreAligned_r/StoreAligned_r.sh
JIT/HardwareIntrinsics/X86/Sse/StoreHigh_r/StoreHigh_r.sh
JIT/HardwareIntrinsics/X86/Sse/StoreLow_r/StoreLow_r.sh
JIT/HardwareIntrinsics/X86/Sse/Store_r/Store_r.sh
JIT/HardwareIntrinsics/X86/Sse/StoreScalar_r/StoreScalar_r.sh
JIT/HardwareIntrinsics/X86/Sse/UnpackHigh_r/UnpackHigh_r.sh
JIT/HardwareIntrinsics/X86/Sse/UnpackLow_r/UnpackLow_r.sh
JIT/HardwareIntrinsics/X86/Ssse3/AlignRight_r/AlignRight_r.sh
JIT/HardwareIntrinsics/X86/Ssse3/Ssse3_ro/Ssse3_ro.sh
JIT/HardwareIntrinsics/X86/Ssse3/Ssse3_r/Ssse3_r.sh
JIT/jit64/gc/misc/struct7_1/struct7_1.sh
JIT/jit64/gc/misc/test3/test3.sh
JIT/jit64/hfa/main/testE/hfa_nd0E_d/hfa_nd0E_d.sh
JIT/jit64/hfa/main/testE/hfa_nd1E_d/hfa_nd1E_d.sh
JIT/jit64/hfa/main/testE/hfa_nd2E_d/hfa_nd2E_d.sh
JIT/jit64/hfa/main/testE/hfa_nd2E_r/hfa_nd2E_r.sh
JIT/jit64/hfa/main/testE/hfa_nf0E_d/hfa_nf0E_d.sh
JIT/jit64/hfa/main/testE/hfa_nf1E_d/hfa_nf1E_d.sh
JIT/jit64/hfa/main/testE/hfa_nf2E_d/hfa_nf2E_d.sh
JIT/jit64/hfa/main/testE/hfa_nf2E_r/hfa_nf2E_r.sh
JIT/jit64/hfa/main/testE/hfa_sd0E_d/hfa_sd0E_d.sh
JIT/jit64/hfa/main/testE/hfa_sd1E_d/hfa_sd1E_d.sh
JIT/jit64/hfa/main/testE/hfa_sd2E_d/hfa_sd2E_d.sh
JIT/jit64/hfa/main/testE/hfa_sd2E_r/hfa_sd2E_r.sh
JIT/jit64/hfa/main/testE/hfa_sf0E_d/hfa_sf0E_d.sh
JIT/jit64/hfa/main/testE/hfa_sf1E_d/hfa_sf1E_d.sh
JIT/jit64/hfa/main/testE/hfa_sf2E_d/hfa_sf2E_d.sh
JIT/jit64/hfa/main/testE/hfa_sf2E_r/hfa_sf2E_r.sh
JIT/jit64/regress/vsw/471729/test/test.sh
JIT/jit64/regress/vsw/539509/test1/test1.sh
JIT/Methodical/divrem/div/decimaldiv_cs_d/decimaldiv_cs_d.sh
JIT/Methodical/divrem/div/decimaldiv_cs_do/decimaldiv_cs_do.sh
JIT/Methodical/divrem/div/decimaldiv_cs_r/decimaldiv_cs_r.sh
JIT/Methodical/divrem/div/decimaldiv_cs_ro/decimaldiv_cs_ro.sh
JIT/Methodical/divrem/div/i4div_cs_d/i4div_cs_d.sh
JIT/Methodical/divrem/div/i4div_cs_do/i4div_cs_do.sh
JIT/Methodical/divrem/div/i4div_cs_r/i4div_cs_r.sh
JIT/Methodical/divrem/div/i4div_cs_ro/i4div_cs_ro.sh
JIT/Methodical/divrem/div/i8div_cs_d/i8div_cs_d.sh
JIT/Methodical/divrem/div/i8div_cs_do/i8div_cs_do.sh
JIT/Methodical/divrem/div/i8div_cs_r/i8div_cs_r.sh
JIT/Methodical/divrem/div/i8div_cs_ro/i8div_cs_ro.sh
JIT/Methodical/divrem/div/overlddiv_cs_d/overlddiv_cs_d.sh
JIT/Methodical/divrem/div/overlddiv_cs_r/overlddiv_cs_r.sh
JIT/Methodical/divrem/div/r4div_cs_d/r4div_cs_d.sh
JIT/Methodical/divrem/div/r4div_cs_r/r4div_cs_r.sh
JIT/Methodical/divrem/div/r8div_cs_d/r8div_cs_d.sh
JIT/Methodical/divrem/div/r8div_cs_r/r8div_cs_r.sh
JIT/Methodical/divrem/div/u4div_cs_do/u4div_cs_do.sh
JIT/Methodical/divrem/div/u4div_cs_d/u4div_cs_d.sh
JIT/Methodical/divrem/div/u4div_cs_ro/u4div_cs_ro.sh
JIT/Methodical/divrem/div/u4div_cs_r/u4div_cs_r.sh
JIT/Methodical/divrem/div/u8div_cs_do/u8div_cs_do.sh
JIT/Methodical/divrem/div/u8div_cs_d/u8div_cs_d.sh
JIT/Methodical/divrem/div/u8div_cs_ro/u8div_cs_ro.sh
JIT/Methodical/divrem/div/u8div_cs_r/u8div_cs_r.sh
JIT/Methodical/divrem/rem/decimalrem_cs_d/decimalrem_cs_d.sh
JIT/Methodical/divrem/rem/decimalrem_cs_do/decimalrem_cs_do.sh
JIT/Methodical/divrem/rem/decimalrem_cs_r/decimalrem_cs_r.sh
JIT/Methodical/divrem/rem/decimalrem_cs_ro/decimalrem_cs_ro.sh
JIT/Methodical/divrem/rem/i4rem_cs_d/i4rem_cs_d.sh
JIT/Methodical/divrem/rem/i4rem_cs_do/i4rem_cs_do.sh
JIT/Methodical/divrem/rem/i4rem_cs_r/i4rem_cs_r.sh
JIT/Methodical/divrem/rem/i4rem_cs_ro/i4rem_cs_ro.sh
JIT/Methodical/divrem/rem/i8rem_cs_d/i8rem_cs_d.sh
JIT/Methodical/divrem/rem/i8rem_cs_do/i8rem_cs_do.sh
JIT/Methodical/divrem/rem/i8rem_cs_r/i8rem_cs_r.sh
JIT/Methodical/divrem/rem/i8rem_cs_ro/i8rem_cs_ro.sh
JIT/Methodical/divrem/rem/overldrem_cs_d/overldrem_cs_d.sh
JIT/Methodical/divrem/rem/overldrem_cs_r/overldrem_cs_r.sh
JIT/Methodical/divrem/rem/r4rem_cs_d/r4rem_cs_d.sh
JIT/Methodical/divrem/rem/r4rem_cs_r/r4rem_cs_r.sh
JIT/Methodical/divrem/rem/r8rem_cs_d/r8rem_cs_d.sh
JIT/Methodical/divrem/rem/r8rem_cs_r/r8rem_cs_r.sh
JIT/Methodical/divrem/rem/u4rem_cs_do/u4rem_cs_do.sh
JIT/Methodical/divrem/rem/u4rem_cs_d/u4rem_cs_d.sh
JIT/Methodical/divrem/rem/u4rem_cs_ro/u4rem_cs_ro.sh
JIT/Methodical/divrem/rem/u4rem_cs_r/u4rem_cs_r.sh
JIT/Methodical/divrem/rem/u8rem_cs_do/u8rem_cs_do.sh
JIT/Methodical/divrem/rem/u8rem_cs_d/u8rem_cs_d.sh
JIT/Methodical/divrem/rem/u8rem_cs_ro/u8rem_cs_ro.sh
JIT/Methodical/divrem/rem/u8rem_cs_r/u8rem_cs_r.sh
JIT/Methodical/fp/exgen/1000w1d_cs_d/1000w1d_cs_d.sh
JIT/Methodical/fp/exgen/1000w1d_cs_do/1000w1d_cs_do.sh
JIT/Methodical/fp/exgen/1000w1d_cs_r/1000w1d_cs_r.sh
JIT/Methodical/fp/exgen/1000w1d_cs_ro/1000w1d_cs_ro.sh
JIT/Methodical/fp/exgen/10w250d_cs_d/10w250d_cs_d.sh
JIT/Methodical/fp/exgen/10w250d_cs_do/10w250d_cs_do.sh
JIT/Methodical/fp/exgen/10w250d_cs_r/10w250d_cs_r.sh
JIT/Methodical/fp/exgen/10w250d_cs_ro/10w250d_cs_ro.sh
JIT/Methodical/fp/exgen/10w5d_cs_d/10w5d_cs_d.sh
JIT/Methodical/fp/exgen/10w5d_cs_do/10w5d_cs_do.sh
JIT/Methodical/fp/exgen/10w5d_cs_r/10w5d_cs_r.sh
JIT/Methodical/fp/exgen/10w5d_cs_ro/10w5d_cs_ro.sh
JIT/Methodical/fp/exgen/200w1d-02_cs_d/200w1d-02_cs_d.sh
JIT/Methodical/fp/exgen/200w1d-02_cs_do/200w1d-02_cs_do.sh
JIT/Methodical/fp/exgen/200w1d-02_cs_r/200w1d-02_cs_r.sh
JIT/Methodical/fp/exgen/200w1d-02_cs_ro/200w1d-02_cs_ro.sh
JIT/Methodical/fp/exgen/5w1d-03_cs_d/5w1d-03_cs_d.sh
JIT/Methodical/fp/exgen/5w1d-03_cs_do/5w1d-03_cs_do.sh
JIT/Methodical/fp/exgen/5w1d-03_cs_r/5w1d-03_cs_r.sh
JIT/Methodical/fp/exgen/5w1d-03_cs_ro/5w1d-03_cs_ro.sh
JIT/Methodical/inlining/bug505642/test/test.sh
JIT/Methodical/int64/superlong/_dbgsuperlong/_dbgsuperlong.sh
JIT/Methodical/int64/superlong/_il_dbgsuperlong/_il_dbgsuperlong.sh
JIT/Methodical/int64/superlong/_il_relsuperlong/_il_relsuperlong.sh
JIT/Methodical/int64/superlong/_relsuperlong/_relsuperlong.sh
JIT/Methodical/int64/superlong/_speed_dbgsuperlong/_speed_dbgsuperlong.sh
JIT/Methodical/int64/superlong/_speed_relsuperlong/_speed_relsuperlong.sh
JIT/Methodical/MDArray/DataTypes/byte_cs_d/byte_cs_d.sh
JIT/Methodical/MDArray/DataTypes/byte_cs_r/byte_cs_r.sh
JIT/Methodical/MDArray/DataTypes/decimal_cs_d/decimal_cs_d.sh
JIT/Methodical/MDArray/DataTypes/decimal_cs_do/decimal_cs_do.sh
JIT/Methodical/MDArray/DataTypes/decimal_cs_r/decimal_cs_r.sh
JIT/Methodical/MDArray/DataTypes/decimal_cs_ro/decimal_cs_ro.sh
JIT/Methodical/MDArray/DataTypes/double_cs_d/double_cs_d.sh
JIT/Methodical/MDArray/DataTypes/double_cs_r/double_cs_r.sh
JIT/Methodical/MDArray/DataTypes/float_cs_d/float_cs_d.sh
JIT/Methodical/MDArray/DataTypes/float_cs_r/float_cs_r.sh
JIT/Methodical/MDArray/DataTypes/int_cs_d/int_cs_d.sh
JIT/Methodical/MDArray/DataTypes/int_cs_r/int_cs_r.sh
JIT/Methodical/MDArray/DataTypes/long_cs_d/long_cs_d.sh
JIT/Methodical/MDArray/DataTypes/long_cs_r/long_cs_r.sh
JIT/Methodical/MDArray/DataTypes/sbyte_cs_d/sbyte_cs_d.sh
JIT/Methodical/MDArray/DataTypes/sbyte_cs_r/sbyte_cs_r.sh
JIT/Methodical/MDArray/DataTypes/short_cs_d/short_cs_d.sh
JIT/Methodical/MDArray/DataTypes/short_cs_r/short_cs_r.sh
JIT/Methodical/MDArray/DataTypes/uint_cs_d/uint_cs_d.sh
JIT/Methodical/MDArray/DataTypes/uint_cs_r/uint_cs_r.sh
JIT/Methodical/MDArray/DataTypes/ulong_cs_d/ulong_cs_d.sh
JIT/Methodical/MDArray/DataTypes/ulong_cs_r/ulong_cs_r.sh
JIT/Methodical/MDArray/DataTypes/ushort_cs_d/ushort_cs_d.sh
JIT/Methodical/MDArray/DataTypes/ushort_cs_r/ushort_cs_r.sh
JIT/Methodical/structs/ExplicitLayout/ExplicitLayout.sh
JIT/Methodical/structs/systemvbringup/structinregs/structinregs.sh
JIT/Methodical/tailcall/_il_dbggcval_nested/_il_dbggcval_nested.sh
JIT/Methodical/tailcall/_il_dbgtest_implicit/_il_dbgtest_implicit.sh
JIT/Methodical/tailcall/_il_relgcval_nested/_il_relgcval_nested.sh
JIT/Methodical/tailcall/_il_reltest_implicit/_il_reltest_implicit.sh
JIT/Methodical/tailcall_v4/smallFrame/smallFrame.sh
JIT/Methodical/VT/callconv/_dbgcall/_dbgcall.sh
JIT/Methodical/VT/callconv/_dbgjumper/_dbgjumper.sh
JIT/Methodical/VT/callconv/_dbgvtret/_dbgvtret.sh
JIT/Methodical/VT/callconv/_il_dbgaa/_il_dbgaa.sh
JIT/Methodical/VT/callconv/_il_dbgcalli/_il_dbgcalli.sh
JIT/Methodical/VT/callconv/_il_dbgdd/_il_dbgdd.sh
JIT/Methodical/VT/callconv/_il_dbgee/_il_dbgee.sh
JIT/Methodical/VT/callconv/_il_dbgjumper1/_il_dbgjumper1.sh
JIT/Methodical/VT/callconv/_il_dbgjumper2/_il_dbgjumper2.sh
JIT/Methodical/VT/callconv/_il_dbgjumper3/_il_dbgjumper3.sh
JIT/Methodical/VT/callconv/_il_dbgjumper4/_il_dbgjumper4.sh
JIT/Methodical/VT/callconv/_il_dbgjumper5/_il_dbgjumper5.sh
JIT/Methodical/VT/callconv/_il_dbgvtret2/_il_dbgvtret2.sh
JIT/Methodical/VT/callconv/_il_dbgvtret/_il_dbgvtret.sh
JIT/Methodical/VT/callconv/_il_relaa/_il_relaa.sh
JIT/Methodical/VT/callconv/_il_relcalli/_il_relcalli.sh
JIT/Methodical/VT/callconv/_il_reldd/_il_reldd.sh
JIT/Methodical/VT/callconv/_il_relee/_il_relee.sh
JIT/Methodical/VT/callconv/_il_reljumper2/_il_reljumper2.sh
JIT/Methodical/VT/callconv/_il_reljumper3/_il_reljumper3.sh
JIT/Methodical/VT/callconv/_il_reljumper4/_il_reljumper4.sh
JIT/Methodical/VT/callconv/_il_reljumper5/_il_reljumper5.sh
JIT/Methodical/VT/callconv/_il_relvtret2/_il_relvtret2.sh
JIT/Methodical/VT/callconv/_il_relvtret/_il_relvtret.sh
JIT/Methodical/VT/callconv/_relcall/_relcall.sh
JIT/Methodical/VT/callconv/_reljumper/_reljumper.sh
JIT/Methodical/VT/callconv/_relvtret/_relvtret.sh
JIT/Methodical/VT/callconv/_speed_dbgcall/_speed_dbgcall.sh
JIT/Methodical/VT/callconv/_speed_relcall/_speed_relcall.sh
JIT/Methodical/VT/port/_dbglcs_gcref/_dbglcs_gcref.sh
JIT/Methodical/VT/port/_rellcs_gcref/_rellcs_gcref.sh
JIT/Methodical/VT/port/_speed_dbglcs_gcref/_speed_dbglcs_gcref.sh
JIT/Methodical/VT/port/_speed_rellcs_gcref/_speed_rellcs_gcref.sh
JIT/opt/Inline/tests/struct_opcodes/struct_opcodes.sh
JIT/opt/virtualstubdispatch/hashcode/ctest1_cs_d/ctest1_cs_d.sh
JIT/opt/virtualstubdispatch/hashcode/ctest1_cs_r/ctest1_cs_r.sh
JIT/opt/virtualstubdispatch/manyintf/ctest_cs_d/ctest_cs_d.sh
JIT/opt/virtualstubdispatch/manyintf/ctest_cs_do/ctest_cs_do.sh
JIT/opt/virtualstubdispatch/manyintf/ctest_cs_r/ctest_cs_r.sh
JIT/opt/virtualstubdispatch/manyintf/ctest_cs_ro/ctest_cs_ro.sh
JIT/Performance/CodeQuality/BenchmarksGame/pidigits/pidigits-3/pidigits-3.sh
JIT/Performance/CodeQuality/Burgers/Burgers/Burgers.sh
JIT/Performance/CodeQuality/Linq/Linq/Linq.sh
JIT/Performance/CodeQuality/Roslyn/CscBench/CscBench.sh
JIT/Performance/CodeQuality/SIMD/RayTracer/RayTracer/RayTracer.sh
JIT/Performance/CodeQuality/Span/Indexer/Indexer.sh
JIT/Performance/CodeQuality/Span/SpanBench/SpanBench.sh
JIT/Regression/CLR-x86-JIT/V1.1-M1-Beta1/b140902/b140902/b140902.sh
JIT/Regression/CLR-x86-JIT/V1.2-M01/b02345/b02345/b02345.sh
JIT/Regression/CLR-x86-JIT/V1-M09.5-PDC/b14716/b14716/b14716.sh
JIT/Regression/CLR-x86-JIT/V1-M10/b02352/b02352/b02352.sh
JIT/Regression/Dev11/DevDiv2_10623/DevDiv2_10623/DevDiv2_10623.sh
JIT/Regression/Dev11/External/Dev11_90434/UseUnalignedDouble/UseUnalignedDouble.sh
JIT/Regression/JitBlue/DevDiv_546018/DevDiv_546018/DevDiv_546018.sh
JIT/Regression/JitBlue/GitHub_10481/GitHub_10481/GitHub_10481.sh
JIT/Regression/JitBlue/GitHub_1133/GitHub_1133/GitHub_1133.sh
JIT/Regression/JitBlue/GitHub_11814/GitHub_11814/GitHub_11814.sh
JIT/Regression/JitBlue/GitHub_11816/GitHub_11816/GitHub_11816.sh
JIT/Regression/JitBlue/GitHub_13057/GitHub_13057/GitHub_13057.sh
JIT/Regression/JitBlue/GitHub_16254/GitHub_16254/GitHub_16254.sh
JIT/Regression/JitBlue/GitHub_18497/GitHub_18497/GitHub_18497.sh
JIT/Regression/JitBlue/GitHub_4115/GitHub_4115/GitHub_4115.sh
JIT/Regression/JitBlue/GitHub_5164/GitHub_5164/GitHub_5164.sh
JIT/Regression/JitBlue/GitHub_7508/Vector3Test/Vector3Test.sh
JIT/Regression/JitBlue/GitHub_8220/GitHub_8220/GitHub_8220.sh
JIT/Regression/VS-ia64-JIT/V1.2-M02/b26496/b26496/b26496.sh
JIT/Regression/VS-ia64-JIT/V2.0-Beta2/b309539/b309539/b309539.sh
JIT/Regression/VS-ia64-JIT/V2.0-RTM/b539509/b539509/b539509.sh
JIT/SIMD/AbsSqrt_r/AbsSqrt_r.sh
JIT/SIMD/AddingSequence_r/AddingSequence_r.sh
JIT/SIMD/CircleInConvex_r/CircleInConvex_r.sh
JIT/SIMD/CircleInConvex_ro/CircleInConvex_ro.sh
JIT/SIMD/CreateGeneric_r/CreateGeneric_r.sh
JIT/SIMD/CreateGeneric_ro/CreateGeneric_ro.sh
JIT/SIMD/DivSignedUnsignedTest_r/DivSignedUnsignedTest_r.sh
JIT/SIMD/DivSignedUnsignedTest_ro/DivSignedUnsignedTest_ro.sh
JIT/SIMD/LdfldGeneric_r/LdfldGeneric_r.sh
JIT/SIMD/Ldfld_r/Ldfld_r.sh
JIT/SIMD/Matrix4x4_r/Matrix4x4_r.sh
JIT/SIMD/Plane_r/Plane_r.sh
JIT/SIMD/SqrtGeneric_ro/SqrtGeneric_ro.sh
JIT/SIMD/SqrtGeneric_r/SqrtGeneric_r.sh
JIT/SIMD/Sums_r/Sums_r.sh
JIT/SIMD/Vector3Interop_ro/Vector3Interop_ro.sh
JIT/SIMD/Vector3Interop_r/Vector3Interop_r.sh
JIT/SIMD/Vector3_r/Vector3_r.sh
JIT/SIMD/Vector4_r/Vector4_r.sh
JIT/SIMD/VectorArgs_ro/VectorArgs_ro.sh
JIT/SIMD/VectorArgs_r/VectorArgs_r.sh
JIT/SIMD/VectorCast_ro/VectorCast_ro.sh
JIT/SIMD/VectorCast_r/VectorCast_r.sh
JIT/SIMD/VectorConvert_ro/VectorConvert_ro.sh
JIT/SIMD/VectorConvert_r/VectorConvert_r.sh
JIT/SIMD/VectorDiv_ro/VectorDiv_ro.sh
JIT/SIMD/VectorDiv_r/VectorDiv_r.sh
JIT/SIMD/VectorExp_ro/VectorExp_ro.sh
JIT/SIMD/VectorExp_r/VectorExp_r.sh
JIT/SIMD/VectorMul_ro/VectorMul_ro.sh
JIT/SIMD/VectorMul_r/VectorMul_r.sh
JIT/SIMD/VectorReturn_ro/VectorReturn_ro.sh
JIT/SIMD/VectorReturn_r/VectorReturn_r.sh
JIT/SIMD/VectorUnused_r/VectorUnused_r.sh
Loader/classloader/regressions/208900/bug/bug.sh
Loader/classloader/v1/Beta1/Layout/Matrix/cs/L-2-5-3/L-2-5-3.sh
readytorun/r2rdump/R2RDumpTest/R2RDumpTest.sh
tracing/eventactivityidcontrol/eventactivityidcontrol/eventactivityidcontrol.sh
tracing/eventsource/eventsourcetrace/eventsourcetrace/eventsourcetrace.sh
tracing/tracevalidation/inducedgc/inducedgc/inducedgc.sh
tracing/tracevalidation/jittingstarted/JittingStarted/JittingStarted.sh
tracing/tracevalidation/rundown/rundown/rundown.sh
```</Description>
    <Title_Description>JitStressRegs=0x8 regressions The 512 tests started failing recently in JitStress=0x8 mode

Typical failure looks like
```
corerun DecimalMaxValue.exe
Beginning test case for Field:System.Decimal.MaxValue at 7/19/2018 1:46:59 PM
Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro

[Positive]

Assert failure(PID 17348 [0x000043c4] Thread: 17348 [0x43c4]): 
Assertion failed 'emitTypeActSz[TypeGet(type)] &gt; 0' in 'DecimalMaxValue:PosTest1():bool:this' (IL size 153)

    File: src/jit/emit.h Line: 2231
```

List of fails follows

```
baseservices/exceptions/regressions/V1/SEH/VJ/NestedEx1/NestedEx1.sh
baseservices/exceptions/regressions/V1/SEH/VJ/NestedEx2/NestedEx2.sh
baseservices/threading/paramthreadstart/ThreadStartDecimal_1/ThreadStartDecimal_1.sh
baseservices/threading/paramthreadstart/ThreadStartDecimal_2/ThreadStartDecimal_2.sh
baseservices/threading/paramthreadstart/ThreadStartDecimal/ThreadStartDecimal.sh
CoreMangLib/cti/system/array/ArrayGetLength/ArrayGetLength.sh
CoreMangLib/cti/system/array/ArrayGetValue2/ArrayGetValue2.sh
CoreMangLib/cti/system/array/ArrayIndexOf1b/ArrayIndexOf1b.sh
CoreMangLib/cti/system/array/ArrayLastIndexOf1b/ArrayLastIndexOf1b.sh
CoreMangLib/cti/system/array/ArraySetValue2/ArraySetValue2.sh
CoreMangLib/cti/system/collections/generic/dictionaryenumerator/DictEnumIDictEnumget_Entry/DictEnumIDictEnumget_Entry.sh
CoreMangLib/cti/system/collections/generic/dictionaryenumerator/DictEnumIDictEnumget_Key/DictEnumIDictEnumget_Key.sh
CoreMangLib/cti/system/collections/generic/dictionaryenumerator/DictEnumIDictEnumget_Value/DictEnumIDictEnumget_Value.sh
CoreMangLib/cti/system/convert/ConvertFromBase64String/ConvertFromBase64String.sh
CoreMangLib/cti/system/convert/ConvertToByte4/ConvertToByte4.sh
CoreMangLib/cti/system/convert/ConvertToDecimal14/ConvertToDecimal14.sh
CoreMangLib/cti/system/convert/ConvertToDecimal15/ConvertToDecimal15.sh
CoreMangLib/cti/system/convert/ConvertToDecimal/ConvertToDecimal.sh
CoreMangLib/cti/system/convert/ConvertToInt16_4/ConvertToInt16_4.sh
CoreMangLib/cti/system/convert/ConvertToInt64_4/ConvertToInt64_4.sh
CoreMangLib/cti/system/convert/ConvertToSByte4/ConvertToSByte4.sh
CoreMangLib/cti/system/convert/ConvertToUInt164/ConvertToUInt164.sh
CoreMangLib/cti/system/convert/ConvertToUInt324/ConvertToUInt324.sh
CoreMangLib/cti/system/convert/ConvertToUInt647/ConvertToUInt647.sh
CoreMangLib/cti/system/decimal/DecimaFloor/DecimaFloor.sh
CoreMangLib/cti/system/decimal/DecimalMaxValue/DecimalMaxValue.sh
CoreMangLib/cti/system/decimal/DecimalMinValue/DecimalMinValue.sh
CoreMangLib/cti/system/decimal/DecimalToByte/DecimalToByte.sh
CoreMangLib/cti/system/decimal/DecimalToInt16/DecimalToInt16.sh
CoreMangLib/cti/system/decimal/DecimalToInt64/DecimalToInt64.sh
CoreMangLib/cti/system/decimal/DecimalToSByte/DecimalToSByte.sh
CoreMangLib/cti/system/decimal/DecimalToUInt16/DecimalToUInt16.sh
CoreMangLib/cti/system/decimal/DecimalToUInt32/DecimalToUInt32.sh
CoreMangLib/cti/system/decimal/DecimalToUInt64/DecimalToUInt64.sh
CoreMangLib/cti/system/double/DoubleIConvertibleToDecimal/DoubleIConvertibleToDecimal.sh
CoreMangLib/cti/system/gc/GCCollect/GCCollect.sh
CoreMangLib/cti/system/gc/GCGetTotalMemory/GCGetTotalMemory.sh
CoreMangLib/cti/system/gc/GCKeepAlive/GCKeepAlive.sh
CoreMangLib/cti/system/gc/GCReRegisterForFinalize/GCReRegisterForFinalize.sh
CoreMangLib/cti/system/gc/GCSuppressFinalize/GCSuppressFinalize.sh
CoreMangLib/cti/system/gc/GCWaitForPendingFinalizers/GCWaitForPendingFinalizers.sh
CoreMangLib/cti/system/guid/GuidNewGuid/GuidNewGuid.sh
CoreMangLib/cti/system/int16/Int16IConvertibleToDecimal/Int16IConvertibleToDecimal.sh
CoreMangLib/cti/system/int64/Int64IConvertibleToDecimal/Int64IConvertibleToDecimal.sh
CoreMangLib/cti/system/int/Int32IConvertibleToDecimal/Int32IConvertibleToDecimal.sh
CoreMangLib/cti/system/mathf/MathFAcos/MathFAcos.sh
CoreMangLib/cti/system/mathf/MathFAtan2/MathFAtan2.sh
CoreMangLib/cti/system/mathf/MathFAtan/MathFAtan.sh
CoreMangLib/cti/system/mathf/MathFCosh/MathFCosh.sh
CoreMangLib/cti/system/mathf/MathFLog/MathFLog.sh
CoreMangLib/cti/system/mathf/MathFSinh/MathFSinh.sh
CoreMangLib/cti/system/mathf/MathFTanh/MathFTanh.sh
CoreMangLib/cti/system/mathf/MathFTan/MathFTan.sh
CoreMangLib/cti/system/math/MathAcos/MathAcos.sh
CoreMangLib/cti/system/math/MathAtan2/MathAtan2.sh
CoreMangLib/cti/system/math/MathAtan/MathAtan.sh
CoreMangLib/cti/system/math/MathCosh/MathCosh.sh
CoreMangLib/cti/system/math/MathLog/MathLog.sh
CoreMangLib/cti/system/math/mathRound1/mathRound1.sh
CoreMangLib/cti/system/math/MathRound2/MathRound2.sh
CoreMangLib/cti/system/math/MathSinh/MathSinh.sh
CoreMangLib/cti/system/math/MathTanh/MathTanh.sh
CoreMangLib/cti/system/math/MathTan/MathTan.sh
CoreMangLib/cti/system/object/ObjectFinalize/ObjectFinalize.sh
CoreMangLib/cti/system/sbyte/SByteIConvertibleToDecimal/SByteIConvertibleToDecimal.sh
CoreMangLib/cti/system/string/StringEquals6/StringEquals6.sh
CoreMangLib/cti/system/uint16/UInt16IConvertibleToDecimal/UInt16IConvertibleToDecimal.sh
CoreMangLib/cti/system/uint32/UInt32IConvertibleToDecimal/UInt32IConvertibleToDecimal.sh
CoreMangLib/cti/system/uint64/UInt64IConvertibleToDecimal/UInt64IConvertibleToDecimal.sh
CoreMangLib/cti/system/weakreference/WeakReferenceCtor2_PSC/WeakReferenceCtor2_PSC.sh
CoreMangLib/cti/system/weakreference/WeakReferenceIsAliveb_PSC/WeakReferenceIsAliveb_PSC.sh
CoreMangLib/cti/system/weakreference/WeakReferenceIsAlive_PSC/WeakReferenceIsAlive_PSC.sh
CoreMangLib/cti/system/weakreference/WeakReferenceTargetb_PSC/WeakReferenceTargetb_PSC.sh
CoreMangLib/system/delegate/miscellaneous/ClosedStatic/ClosedStatic.sh
CoreMangLib/system/guid/Guid_Parsing/Guid_Parsing.sh
CoreMangLib/system/span/RefStructWithSpan/RefStructWithSpan.sh
GC/API/GC/Collect_Forced_1/Collect_Forced_1.sh
GC/API/GC/Collect_Forced_2/Collect_Forced_2.sh
GC/API/GC/Collect_Forced_3/Collect_Forced_3.sh
GC/Features/HeapExpansion/bestfit_1/bestfit_1.sh
GC/Features/HeapExpansion/bestfit/bestfit.sh
GC/Features/HeapExpansion/bestfit-threaded/bestfit-threaded.sh
GC/Features/Pinning/PinningOther/PinnedCollect/PinnedCollect.sh
GC/Regressions/v2.0-beta2/471729/471729/471729.sh
GC/Scenarios/FinalizeTimeout/FinalizeTimeout/FinalizeTimeout.sh
Interop/SimpleStruct/SimpleStruct/SimpleStruct.sh
JIT/CheckProjects/CheckProjects/CheckProjects.sh
JIT/CodeGenBringUpTests/StructReturn/StructReturn.sh
JIT/Directed/coverage/oldtests/lclfldadd_cs_d/lclfldadd_cs_d.sh
JIT/Directed/coverage/oldtests/lclfldadd_cs_do/lclfldadd_cs_do.sh
JIT/Directed/coverage/oldtests/lclfldadd_cs_r/lclfldadd_cs_r.sh
JIT/Directed/coverage/oldtests/lclfldadd_cs_ro/lclfldadd_cs_ro.sh
JIT/Directed/coverage/oldtests/lclflddiv_cs_d/lclflddiv_cs_d.sh
JIT/Directed/coverage/oldtests/lclflddiv_cs_do/lclflddiv_cs_do.sh
JIT/Directed/coverage/oldtests/lclflddiv_cs_r/lclflddiv_cs_r.sh
JIT/Directed/coverage/oldtests/lclflddiv_cs_ro/lclflddiv_cs_ro.sh
JIT/Directed/coverage/oldtests/lclfldmul_cs_d/lclfldmul_cs_d.sh
JIT/Directed/coverage/oldtests/lclfldmul_cs_do/lclfldmul_cs_do.sh
JIT/Directed/coverage/oldtests/lclfldmul_cs_r/lclfldmul_cs_r.sh
JIT/Directed/coverage/oldtests/lclfldmul_cs_ro/lclfldmul_cs_ro.sh
JIT/Directed/coverage/oldtests/lclfldrem_cs_d/lclfldrem_cs_d.sh
JIT/Directed/coverage/oldtests/lclfldrem_cs_do/lclfldrem_cs_do.sh
JIT/Directed/coverage/oldtests/lclfldrem_cs_r/lclfldrem_cs_r.sh
JIT/Directed/coverage/oldtests/lclfldrem_cs_ro/lclfldrem_cs_ro.sh
JIT/Directed/coverage/oldtests/lclfldsub_cs_d/lclfldsub_cs_d.sh
JIT/Directed/coverage/oldtests/lclfldsub_cs_do/lclfldsub_cs_do.sh
JIT/Directed/coverage/oldtests/lclfldsub_cs_r/lclfldsub_cs_r.sh
JIT/Directed/coverage/oldtests/lclfldsub_cs_ro/lclfldsub_cs_ro.sh
JIT/Directed/coverage/oldtests/stfldstatic1_il_d/stfldstatic1_il_d.sh
JIT/Directed/coverage/oldtests/stfldstatic2_il_d/stfldstatic2_il_d.sh
JIT/Directed/nullabletypes/boxunboxinterface_d/boxunboxinterface_d.sh
JIT/Directed/nullabletypes/boxunboxinterface_r/boxunboxinterface_r.sh
JIT/Directed/nullabletypes/castclassinterface_d/castclassinterface_d.sh
JIT/Directed/nullabletypes/castclassinterface_r/castclassinterface_r.sh
JIT/Directed/nullabletypes/castclassvaluetype_d/castclassvaluetype_d.sh
JIT/Directed/nullabletypes/castclassvaluetype_r/castclassvaluetype_r.sh
JIT/Directed/nullabletypes/Desktop/boxunboxvaluetype_r/boxunboxvaluetype_r.sh
JIT/Directed/perffix/primitivevt/mixed1_cs_d/mixed1_cs_d.sh
JIT/Directed/perffix/primitivevt/mixed1_cs_do/mixed1_cs_do.sh
JIT/Directed/perffix/primitivevt/mixed1_cs_r/mixed1_cs_r.sh
JIT/Directed/perffix/primitivevt/mixed1_cs_ro/mixed1_cs_ro.sh
JIT/Directed/perffix/primitivevt/mixed2_cs_d/mixed2_cs_d.sh
JIT/Directed/perffix/primitivevt/mixed2_cs_do/mixed2_cs_do.sh
JIT/Directed/perffix/primitivevt/mixed2_cs_r/mixed2_cs_r.sh
JIT/Directed/perffix/primitivevt/mixed2_cs_ro/mixed2_cs_ro.sh
JIT/Generics/Fields/static_assignment_class01/static_assignment_class01.sh
JIT/Generics/Fields/static_assignment_struct01/static_assignment_struct01.sh
JIT/Generics/Fields/static_passing_class01/static_passing_class01.sh
JIT/Generics/Fields/static_passing_struct01/static_passing_struct01.sh
JIT/HardwareIntrinsics/Arm64/Crypto/Crypto.sh
JIT/HardwareIntrinsics/X86/Avx2/Avx2_r/Avx2_r.sh
JIT/HardwareIntrinsics/X86/Avx2/Avx2_ro/Avx2_ro.sh
JIT/HardwareIntrinsics/X86/Avx2/ConvertToVector256_r/ConvertToVector256_r.sh
JIT/HardwareIntrinsics/X86/Avx2/ShiftLeftLogicalVariable_r/ShiftLeftLogicalVariable_r.sh
JIT/HardwareIntrinsics/X86/Avx2/ShiftRightLogicalVariable_r/ShiftRightLogicalVariable_r.sh
JIT/HardwareIntrinsics/X86/Avx2_Vector128/Avx2_r/Avx2_r.sh
JIT/HardwareIntrinsics/X86/Avx2_Vector128/Avx2_ro/Avx2_ro.sh
JIT/HardwareIntrinsics/X86/Avx/Avx_r/Avx_r.sh
JIT/HardwareIntrinsics/X86/Avx/Avx_ro/Avx_ro.sh
JIT/HardwareIntrinsics/X86/Avx/BroadcastScalarToVector128_r/BroadcastScalarToVector128_r.sh
JIT/HardwareIntrinsics/X86/Avx/Compare_r/Compare_r.sh
JIT/HardwareIntrinsics/X86/Avx/CompareScalar_r/CompareScalar_r.sh
JIT/HardwareIntrinsics/X86/Avx/CompareScalar_ro/CompareScalar_ro.sh
JIT/HardwareIntrinsics/X86/Avx/ConvertToVector_r/ConvertToVector_r.sh
JIT/HardwareIntrinsics/X86/Avx/ConvertToVector_ro/ConvertToVector_ro.sh
JIT/HardwareIntrinsics/X86/Avx/InsertExtractVector128_r/InsertExtractVector128_r.sh
JIT/HardwareIntrinsics/X86/Avx/InsertExtractVector128_ro/InsertExtractVector128_ro.sh
JIT/HardwareIntrinsics/X86/Avx/MaskLoad_r/MaskLoad_r.sh
JIT/HardwareIntrinsics/X86/Bmi1/Bmi1_ro/Bmi1_ro.sh
JIT/HardwareIntrinsics/X86/Bmi2/Bmi2_ro/Bmi2_ro.sh
JIT/HardwareIntrinsics/X86/Fma_Vector128/Fma_r/Fma_r.sh
JIT/HardwareIntrinsics/X86/Fma_Vector128/Fma_ro/Fma_ro.sh
JIT/HardwareIntrinsics/X86/General/VectorArgs_r/VectorArgs_r.sh
JIT/HardwareIntrinsics/X86/General/VectorRet_r/VectorRet_r.sh
JIT/HardwareIntrinsics/X86/General/VectorUnused_r/VectorUnused_r.sh
JIT/HardwareIntrinsics/X86/Sse2/CompareEqualScalar_r/CompareEqualScalar_r.sh
JIT/HardwareIntrinsics/X86/Sse2/CompareGreaterThanOrEqualScalar_r/CompareGreaterThanOrEqualScalar_r.sh
JIT/HardwareIntrinsics/X86/Sse2/CompareGreaterThanOrEqualScalar_ro/CompareGreaterThanOrEqualScalar_ro.sh
JIT/HardwareIntrinsics/X86/Sse2/CompareGreaterThanScalar_r/CompareGreaterThanScalar_r.sh
JIT/HardwareIntrinsics/X86/Sse2/CompareLessThanOrEqualScalar_r/CompareLessThanOrEqualScalar_r.sh
JIT/HardwareIntrinsics/X86/Sse2/CompareLessThanScalar_r/CompareLessThanScalar_r.sh
JIT/HardwareIntrinsics/X86/Sse2/CompareNotEqualScalar_r/CompareNotEqualScalar_r.sh
JIT/HardwareIntrinsics/X86/Sse2/CompareNotGreaterThanOrEqualScalar_r/CompareNotGreaterThanOrEqualScalar_r.sh
JIT/HardwareIntrinsics/X86/Sse2/CompareNotGreaterThanScalar_r/CompareNotGreaterThanScalar_r.sh
JIT/HardwareIntrinsics/X86/Sse2/CompareNotLessThanOrEqualScalar_r/CompareNotLessThanOrEqualScalar_r.sh
JIT/HardwareIntrinsics/X86/Sse2/CompareNotLessThanScalar_r/CompareNotLessThanScalar_r.sh
JIT/HardwareIntrinsics/X86/Sse2/CompareOrderedScalar_r/CompareOrderedScalar_r.sh
JIT/HardwareIntrinsics/X86/Sse2/CompareUnorderedScalar_r/CompareUnorderedScalar_r.sh
JIT/HardwareIntrinsics/X86/Sse2/ConvertScalarToVector128Double_r/ConvertScalarToVector128Double_r.sh
JIT/HardwareIntrinsics/X86/Sse2/ConvertScalarToVector128Int32_r/ConvertScalarToVector128Int32_r.sh
JIT/HardwareIntrinsics/X86/Sse2/ConvertScalarToVector128Int64_r/ConvertScalarToVector128Int64_r.sh
JIT/HardwareIntrinsics/X86/Sse2/ConvertScalarToVector128Single_r/ConvertScalarToVector128Single_r.sh
JIT/HardwareIntrinsics/X86/Sse2/ConvertScalarToVector128UInt32_r/ConvertScalarToVector128UInt32_r.sh
JIT/HardwareIntrinsics/X86/Sse2/ConvertScalarToVector128UInt64_r/ConvertScalarToVector128UInt64_r.sh
JIT/HardwareIntrinsics/X86/Sse2/ConvertToInt32_r/ConvertToInt32_r.sh
JIT/HardwareIntrinsics/X86/Sse2/ConvertToVector128Double_r/ConvertToVector128Double_r.sh
JIT/HardwareIntrinsics/X86/Sse2/ConvertToVector128Int32_r/ConvertToVector128Int32_r.sh
JIT/HardwareIntrinsics/X86/Sse2/ConvertToVector128Int32WithTruncation_r/ConvertToVector128Int32WithTruncation_r.sh
JIT/HardwareIntrinsics/X86/Sse2/ConvertToVector128Single_r/ConvertToVector128Single_r.sh
JIT/HardwareIntrinsics/X86/Sse2/LoadAlignedVector128_r/LoadAlignedVector128_r.sh
JIT/HardwareIntrinsics/X86/Sse2/LoadHigh_r/LoadHigh_r.sh
JIT/HardwareIntrinsics/X86/Sse2/LoadLow_r/LoadLow_r.sh
JIT/HardwareIntrinsics/X86/Sse2/LoadScalarVector128_r/LoadScalarVector128_r.sh
JIT/HardwareIntrinsics/X86/Sse2/LoadVector128_r/LoadVector128_r.sh
JIT/HardwareIntrinsics/X86/Sse2/MultiplyHigh_r/MultiplyHigh_r.sh
JIT/HardwareIntrinsics/X86/Sse2/MultiplyHorizontalAdd_r/MultiplyHorizontalAdd_r.sh
JIT/HardwareIntrinsics/X86/Sse2/MultiplyLow_r/MultiplyLow_r.sh
JIT/HardwareIntrinsics/X86/Sse2/Multiply_r/Multiply_r.sh
JIT/HardwareIntrinsics/X86/Sse2/PackSignedSaturate_r/PackSignedSaturate_r.sh
JIT/HardwareIntrinsics/X86/Sse2/PackUnsignedSaturate_r/PackUnsignedSaturate_r.sh
JIT/HardwareIntrinsics/X86/Sse2/SetScalarVector128_r/SetScalarVector128_r.sh
JIT/HardwareIntrinsics/X86/Sse2/SetVector128_ro/SetVector128_ro.sh
JIT/HardwareIntrinsics/X86/Sse2/SetVector128_r/SetVector128_r.sh
JIT/HardwareIntrinsics/X86/Sse2/SetZeroVector128_r/SetZeroVector128_r.sh
JIT/HardwareIntrinsics/X86/Sse2/ShuffleHigh_r/ShuffleHigh_r.sh
JIT/HardwareIntrinsics/X86/Sse2/ShuffleLow_r/ShuffleLow_r.sh
JIT/HardwareIntrinsics/X86/Sse2/Shuffle_r/Shuffle_r.sh
JIT/HardwareIntrinsics/X86/Sse2/Sqrt_r/Sqrt_r.sh
JIT/HardwareIntrinsics/X86/Sse2/SqrtScalar_r/SqrtScalar_r.sh
JIT/HardwareIntrinsics/X86/Sse2/Sse2_ro/Sse2_ro.sh
JIT/HardwareIntrinsics/X86/Sse2/Sse2_r/Sse2_r.sh
JIT/HardwareIntrinsics/X86/Sse2/StoreAlignedNonTemporal_r/StoreAlignedNonTemporal_r.sh
JIT/HardwareIntrinsics/X86/Sse2/StoreAligned_r/StoreAligned_r.sh
JIT/HardwareIntrinsics/X86/Sse2/StoreHigh_r/StoreHigh_r.sh
JIT/HardwareIntrinsics/X86/Sse2/StoreLow_r/StoreLow_r.sh
JIT/HardwareIntrinsics/X86/Sse2/Store_r/Store_r.sh
JIT/HardwareIntrinsics/X86/Sse2/StoreScalar_r/StoreScalar_r.sh
JIT/HardwareIntrinsics/X86/Sse2/SumAbsoluteDifferences_r/SumAbsoluteDifferences_r.sh
JIT/HardwareIntrinsics/X86/Sse2/UnpackHigh_r/UnpackHigh_r.sh
JIT/HardwareIntrinsics/X86/Sse2/UnpackLow_r/UnpackLow_r.sh
JIT/HardwareIntrinsics/X86/Sse3/LoadAndDuplicateToVector128_r/LoadAndDuplicateToVector128_r.sh
JIT/HardwareIntrinsics/X86/Sse3/LoadDquVector128_r/LoadDquVector128_r.sh
JIT/HardwareIntrinsics/X86/Sse3/MoveAndDuplicate_r/MoveAndDuplicate_r.sh
JIT/HardwareIntrinsics/X86/Sse3/MoveHighAndDuplicate_r/MoveHighAndDuplicate_r.sh
JIT/HardwareIntrinsics/X86/Sse3/MoveLowAndDuplicate_r/MoveLowAndDuplicate_r.sh
JIT/HardwareIntrinsics/X86/Sse3/Sse3_ro/Sse3_ro.sh
JIT/HardwareIntrinsics/X86/Sse3/Sse3_r/Sse3_r.sh
JIT/HardwareIntrinsics/X86/Sse41/Blend_r/Blend_r.sh
JIT/HardwareIntrinsics/X86/Sse41/ConvertToVector128_r/ConvertToVector128_r.sh
JIT/HardwareIntrinsics/X86/Sse41/ConvertToVector128_ro/ConvertToVector128_ro.sh
JIT/HardwareIntrinsics/X86/Sse41/DotProduct_r/DotProduct_r.sh
JIT/HardwareIntrinsics/X86/Sse41/LoadAlignedVector128NonTemporal_r/LoadAlignedVector128NonTemporal_r.sh
JIT/HardwareIntrinsics/X86/Sse41/MinHorizontal_r/MinHorizontal_r.sh
JIT/HardwareIntrinsics/X86/Sse41/MinHorizontal_ro/MinHorizontal_ro.sh
JIT/HardwareIntrinsics/X86/Sse41/MultipleSumAbsoluteDifferences_r/MultipleSumAbsoluteDifferences_r.sh
JIT/HardwareIntrinsics/X86/Sse41/MultipleSumAbsoluteDifferences_ro/MultipleSumAbsoluteDifferences_ro.sh
JIT/HardwareIntrinsics/X86/Sse41/Multiply_r/Multiply_r.sh
JIT/HardwareIntrinsics/X86/Sse41/Sse41_ro/Sse41_ro.sh
JIT/HardwareIntrinsics/X86/Sse41/Sse41_r/Sse41_r.sh
JIT/HardwareIntrinsics/X86/Sse42/Sse42_ro/Sse42_ro.sh
JIT/HardwareIntrinsics/X86/Sse42/Sse42_r/Sse42_r.sh
JIT/HardwareIntrinsics/X86/Sse/ConvertScalarToVector128Single_r/ConvertScalarToVector128Single_r.sh
JIT/HardwareIntrinsics/X86/Sse/ConvertToInt32_r/ConvertToInt32_r.sh
JIT/HardwareIntrinsics/X86/Sse/ConvertToInt32WithTruncation_r/ConvertToInt32WithTruncation_r.sh
JIT/HardwareIntrinsics/X86/Sse/ConvertToInt64_r/ConvertToInt64_r.sh
JIT/HardwareIntrinsics/X86/Sse/ConvertToInt64WithTruncation_r/ConvertToInt64WithTruncation_r.sh
JIT/HardwareIntrinsics/X86/Sse/ConvertToSingle_r/ConvertToSingle_r.sh
JIT/HardwareIntrinsics/X86/Sse/LoadAlignedVector128_r/LoadAlignedVector128_r.sh
JIT/HardwareIntrinsics/X86/Sse/LoadHigh_r/LoadHigh_r.sh
JIT/HardwareIntrinsics/X86/Sse/LoadLow_r/LoadLow_r.sh
JIT/HardwareIntrinsics/X86/Sse/LoadScalarVector128_r/LoadScalarVector128_r.sh
JIT/HardwareIntrinsics/X86/Sse/LoadVector128_r/LoadVector128_r.sh
JIT/HardwareIntrinsics/X86/Sse/MoveHighToLow_r/MoveHighToLow_r.sh
JIT/HardwareIntrinsics/X86/Sse/MoveLowToHigh_r/MoveLowToHigh_r.sh
JIT/HardwareIntrinsics/X86/Sse/MoveMask_r/MoveMask_r.sh
JIT/HardwareIntrinsics/X86/Sse/MoveScalar_r/MoveScalar_r.sh
JIT/HardwareIntrinsics/X86/Sse/Reciprocal_r/Reciprocal_r.sh
JIT/HardwareIntrinsics/X86/Sse/ReciprocalScalar_r/ReciprocalScalar_r.sh
JIT/HardwareIntrinsics/X86/Sse/ReciprocalSqrt_r/ReciprocalSqrt_r.sh
JIT/HardwareIntrinsics/X86/Sse/ReciprocalSqrtScalar_r/ReciprocalSqrtScalar_r.sh
JIT/HardwareIntrinsics/X86/Sse/SetAllVector128_r/SetAllVector128_r.sh
JIT/HardwareIntrinsics/X86/Sse/SetScalarVector128_r/SetScalarVector128_r.sh
JIT/HardwareIntrinsics/X86/Sse/SetVector128_r/SetVector128_r.sh
JIT/HardwareIntrinsics/X86/Sse/SetZeroVector128_r/SetZeroVector128_r.sh
JIT/HardwareIntrinsics/X86/Sse/Shuffle_r/Shuffle_r.sh
JIT/HardwareIntrinsics/X86/Sse/Sqrt_r/Sqrt_r.sh
JIT/HardwareIntrinsics/X86/Sse/SqrtScalar_r/SqrtScalar_r.sh
JIT/HardwareIntrinsics/X86/Sse/Sse_ro/Sse_ro.sh
JIT/HardwareIntrinsics/X86/Sse/Sse_r/Sse_r.sh
JIT/HardwareIntrinsics/X86/Sse/StaticCast_ro/StaticCast_ro.sh
JIT/HardwareIntrinsics/X86/Sse/StaticCast_r/StaticCast_r.sh
JIT/HardwareIntrinsics/X86/Sse/StoreAlignedNonTemporal_r/StoreAlignedNonTemporal_r.sh
JIT/HardwareIntrinsics/X86/Sse/StoreAligned_r/StoreAligned_r.sh
JIT/HardwareIntrinsics/X86/Sse/StoreHigh_r/StoreHigh_r.sh
JIT/HardwareIntrinsics/X86/Sse/StoreLow_r/StoreLow_r.sh
JIT/HardwareIntrinsics/X86/Sse/Store_r/Store_r.sh
JIT/HardwareIntrinsics/X86/Sse/StoreScalar_r/StoreScalar_r.sh
JIT/HardwareIntrinsics/X86/Sse/UnpackHigh_r/UnpackHigh_r.sh
JIT/HardwareIntrinsics/X86/Sse/UnpackLow_r/UnpackLow_r.sh
JIT/HardwareIntrinsics/X86/Ssse3/AlignRight_r/AlignRight_r.sh
JIT/HardwareIntrinsics/X86/Ssse3/Ssse3_ro/Ssse3_ro.sh
JIT/HardwareIntrinsics/X86/Ssse3/Ssse3_r/Ssse3_r.sh
JIT/jit64/gc/misc/struct7_1/struct7_1.sh
JIT/jit64/gc/misc/test3/test3.sh
JIT/jit64/hfa/main/testE/hfa_nd0E_d/hfa_nd0E_d.sh
JIT/jit64/hfa/main/testE/hfa_nd1E_d/hfa_nd1E_d.sh
JIT/jit64/hfa/main/testE/hfa_nd2E_d/hfa_nd2E_d.sh
JIT/jit64/hfa/main/testE/hfa_nd2E_r/hfa_nd2E_r.sh
JIT/jit64/hfa/main/testE/hfa_nf0E_d/hfa_nf0E_d.sh
JIT/jit64/hfa/main/testE/hfa_nf1E_d/hfa_nf1E_d.sh
JIT/jit64/hfa/main/testE/hfa_nf2E_d/hfa_nf2E_d.sh
JIT/jit64/hfa/main/testE/hfa_nf2E_r/hfa_nf2E_r.sh
JIT/jit64/hfa/main/testE/hfa_sd0E_d/hfa_sd0E_d.sh
JIT/jit64/hfa/main/testE/hfa_sd1E_d/hfa_sd1E_d.sh
JIT/jit64/hfa/main/testE/hfa_sd2E_d/hfa_sd2E_d.sh
JIT/jit64/hfa/main/testE/hfa_sd2E_r/hfa_sd2E_r.sh
JIT/jit64/hfa/main/testE/hfa_sf0E_d/hfa_sf0E_d.sh
JIT/jit64/hfa/main/testE/hfa_sf1E_d/hfa_sf1E_d.sh
JIT/jit64/hfa/main/testE/hfa_sf2E_d/hfa_sf2E_d.sh
JIT/jit64/hfa/main/testE/hfa_sf2E_r/hfa_sf2E_r.sh
JIT/jit64/regress/vsw/471729/test/test.sh
JIT/jit64/regress/vsw/539509/test1/test1.sh
JIT/Methodical/divrem/div/decimaldiv_cs_d/decimaldiv_cs_d.sh
JIT/Methodical/divrem/div/decimaldiv_cs_do/decimaldiv_cs_do.sh
JIT/Methodical/divrem/div/decimaldiv_cs_r/decimaldiv_cs_r.sh
JIT/Methodical/divrem/div/decimaldiv_cs_ro/decimaldiv_cs_ro.sh
JIT/Methodical/divrem/div/i4div_cs_d/i4div_cs_d.sh
JIT/Methodical/divrem/div/i4div_cs_do/i4div_cs_do.sh
JIT/Methodical/divrem/div/i4div_cs_r/i4div_cs_r.sh
JIT/Methodical/divrem/div/i4div_cs_ro/i4div_cs_ro.sh
JIT/Methodical/divrem/div/i8div_cs_d/i8div_cs_d.sh
JIT/Methodical/divrem/div/i8div_cs_do/i8div_cs_do.sh
JIT/Methodical/divrem/div/i8div_cs_r/i8div_cs_r.sh
JIT/Methodical/divrem/div/i8div_cs_ro/i8div_cs_ro.sh
JIT/Methodical/divrem/div/overlddiv_cs_d/overlddiv_cs_d.sh
JIT/Methodical/divrem/div/overlddiv_cs_r/overlddiv_cs_r.sh
JIT/Methodical/divrem/div/r4div_cs_d/r4div_cs_d.sh
JIT/Methodical/divrem/div/r4div_cs_r/r4div_cs_r.sh
JIT/Methodical/divrem/div/r8div_cs_d/r8div_cs_d.sh
JIT/Methodical/divrem/div/r8div_cs_r/r8div_cs_r.sh
JIT/Methodical/divrem/div/u4div_cs_do/u4div_cs_do.sh
JIT/Methodical/divrem/div/u4div_cs_d/u4div_cs_d.sh
JIT/Methodical/divrem/div/u4div_cs_ro/u4div_cs_ro.sh
JIT/Methodical/divrem/div/u4div_cs_r/u4div_cs_r.sh
JIT/Methodical/divrem/div/u8div_cs_do/u8div_cs_do.sh
JIT/Methodical/divrem/div/u8div_cs_d/u8div_cs_d.sh
JIT/Methodical/divrem/div/u8div_cs_ro/u8div_cs_ro.sh
JIT/Methodical/divrem/div/u8div_cs_r/u8div_cs_r.sh
JIT/Methodical/divrem/rem/decimalrem_cs_d/decimalrem_cs_d.sh
JIT/Methodical/divrem/rem/decimalrem_cs_do/decimalrem_cs_do.sh
JIT/Methodical/divrem/rem/decimalrem_cs_r/decimalrem_cs_r.sh
JIT/Methodical/divrem/rem/decimalrem_cs_ro/decimalrem_cs_ro.sh
JIT/Methodical/divrem/rem/i4rem_cs_d/i4rem_cs_d.sh
JIT/Methodical/divrem/rem/i4rem_cs_do/i4rem_cs_do.sh
JIT/Methodical/divrem/rem/i4rem_cs_r/i4rem_cs_r.sh
JIT/Methodical/divrem/rem/i4rem_cs_ro/i4rem_cs_ro.sh
JIT/Methodical/divrem/rem/i8rem_cs_d/i8rem_cs_d.sh
JIT/Methodical/divrem/rem/i8rem_cs_do/i8rem_cs_do.sh
JIT/Methodical/divrem/rem/i8rem_cs_r/i8rem_cs_r.sh
JIT/Methodical/divrem/rem/i8rem_cs_ro/i8rem_cs_ro.sh
JIT/Methodical/divrem/rem/overldrem_cs_d/overldrem_cs_d.sh
JIT/Methodical/divrem/rem/overldrem_cs_r/overldrem_cs_r.sh
JIT/Methodical/divrem/rem/r4rem_cs_d/r4rem_cs_d.sh
JIT/Methodical/divrem/rem/r4rem_cs_r/r4rem_cs_r.sh
JIT/Methodical/divrem/rem/r8rem_cs_d/r8rem_cs_d.sh
JIT/Methodical/divrem/rem/r8rem_cs_r/r8rem_cs_r.sh
JIT/Methodical/divrem/rem/u4rem_cs_do/u4rem_cs_do.sh
JIT/Methodical/divrem/rem/u4rem_cs_d/u4rem_cs_d.sh
JIT/Methodical/divrem/rem/u4rem_cs_ro/u4rem_cs_ro.sh
JIT/Methodical/divrem/rem/u4rem_cs_r/u4rem_cs_r.sh
JIT/Methodical/divrem/rem/u8rem_cs_do/u8rem_cs_do.sh
JIT/Methodical/divrem/rem/u8rem_cs_d/u8rem_cs_d.sh
JIT/Methodical/divrem/rem/u8rem_cs_ro/u8rem_cs_ro.sh
JIT/Methodical/divrem/rem/u8rem_cs_r/u8rem_cs_r.sh
JIT/Methodical/fp/exgen/1000w1d_cs_d/1000w1d_cs_d.sh
JIT/Methodical/fp/exgen/1000w1d_cs_do/1000w1d_cs_do.sh
JIT/Methodical/fp/exgen/1000w1d_cs_r/1000w1d_cs_r.sh
JIT/Methodical/fp/exgen/1000w1d_cs_ro/1000w1d_cs_ro.sh
JIT/Methodical/fp/exgen/10w250d_cs_d/10w250d_cs_d.sh
JIT/Methodical/fp/exgen/10w250d_cs_do/10w250d_cs_do.sh
JIT/Methodical/fp/exgen/10w250d_cs_r/10w250d_cs_r.sh
JIT/Methodical/fp/exgen/10w250d_cs_ro/10w250d_cs_ro.sh
JIT/Methodical/fp/exgen/10w5d_cs_d/10w5d_cs_d.sh
JIT/Methodical/fp/exgen/10w5d_cs_do/10w5d_cs_do.sh
JIT/Methodical/fp/exgen/10w5d_cs_r/10w5d_cs_r.sh
JIT/Methodical/fp/exgen/10w5d_cs_ro/10w5d_cs_ro.sh
JIT/Methodical/fp/exgen/200w1d-02_cs_d/200w1d-02_cs_d.sh
JIT/Methodical/fp/exgen/200w1d-02_cs_do/200w1d-02_cs_do.sh
JIT/Methodical/fp/exgen/200w1d-02_cs_r/200w1d-02_cs_r.sh
JIT/Methodical/fp/exgen/200w1d-02_cs_ro/200w1d-02_cs_ro.sh
JIT/Methodical/fp/exgen/5w1d-03_cs_d/5w1d-03_cs_d.sh
JIT/Methodical/fp/exgen/5w1d-03_cs_do/5w1d-03_cs_do.sh
JIT/Methodical/fp/exgen/5w1d-03_cs_r/5w1d-03_cs_r.sh
JIT/Methodical/fp/exgen/5w1d-03_cs_ro/5w1d-03_cs_ro.sh
JIT/Methodical/inlining/bug505642/test/test.sh
JIT/Methodical/int64/superlong/_dbgsuperlong/_dbgsuperlong.sh
JIT/Methodical/int64/superlong/_il_dbgsuperlong/_il_dbgsuperlong.sh
JIT/Methodical/int64/superlong/_il_relsuperlong/_il_relsuperlong.sh
JIT/Methodical/int64/superlong/_relsuperlong/_relsuperlong.sh
JIT/Methodical/int64/superlong/_speed_dbgsuperlong/_speed_dbgsuperlong.sh
JIT/Methodical/int64/superlong/_speed_relsuperlong/_speed_relsuperlong.sh
JIT/Methodical/MDArray/DataTypes/byte_cs_d/byte_cs_d.sh
JIT/Methodical/MDArray/DataTypes/byte_cs_r/byte_cs_r.sh
JIT/Methodical/MDArray/DataTypes/decimal_cs_d/decimal_cs_d.sh
JIT/Methodical/MDArray/DataTypes/decimal_cs_do/decimal_cs_do.sh
JIT/Methodical/MDArray/DataTypes/decimal_cs_r/decimal_cs_r.sh
JIT/Methodical/MDArray/DataTypes/decimal_cs_ro/decimal_cs_ro.sh
JIT/Methodical/MDArray/DataTypes/double_cs_d/double_cs_d.sh
JIT/Methodical/MDArray/DataTypes/double_cs_r/double_cs_r.sh
JIT/Methodical/MDArray/DataTypes/float_cs_d/float_cs_d.sh
JIT/Methodical/MDArray/DataTypes/float_cs_r/float_cs_r.sh
JIT/Methodical/MDArray/DataTypes/int_cs_d/int_cs_d.sh
JIT/Methodical/MDArray/DataTypes/int_cs_r/int_cs_r.sh
JIT/Methodical/MDArray/DataTypes/long_cs_d/long_cs_d.sh
JIT/Methodical/MDArray/DataTypes/long_cs_r/long_cs_r.sh
JIT/Methodical/MDArray/DataTypes/sbyte_cs_d/sbyte_cs_d.sh
JIT/Methodical/MDArray/DataTypes/sbyte_cs_r/sbyte_cs_r.sh
JIT/Methodical/MDArray/DataTypes/short_cs_d/short_cs_d.sh
JIT/Methodical/MDArray/DataTypes/short_cs_r/short_cs_r.sh
JIT/Methodical/MDArray/DataTypes/uint_cs_d/uint_cs_d.sh
JIT/Methodical/MDArray/DataTypes/uint_cs_r/uint_cs_r.sh
JIT/Methodical/MDArray/DataTypes/ulong_cs_d/ulong_cs_d.sh
JIT/Methodical/MDArray/DataTypes/ulong_cs_r/ulong_cs_r.sh
JIT/Methodical/MDArray/DataTypes/ushort_cs_d/ushort_cs_d.sh
JIT/Methodical/MDArray/DataTypes/ushort_cs_r/ushort_cs_r.sh
JIT/Methodical/structs/ExplicitLayout/ExplicitLayout.sh
JIT/Methodical/structs/systemvbringup/structinregs/structinregs.sh
JIT/Methodical/tailcall/_il_dbggcval_nested/_il_dbggcval_nested.sh
JIT/Methodical/tailcall/_il_dbgtest_implicit/_il_dbgtest_implicit.sh
JIT/Methodical/tailcall/_il_relgcval_nested/_il_relgcval_nested.sh
JIT/Methodical/tailcall/_il_reltest_implicit/_il_reltest_implicit.sh
JIT/Methodical/tailcall_v4/smallFrame/smallFrame.sh
JIT/Methodical/VT/callconv/_dbgcall/_dbgcall.sh
JIT/Methodical/VT/callconv/_dbgjumper/_dbgjumper.sh
JIT/Methodical/VT/callconv/_dbgvtret/_dbgvtret.sh
JIT/Methodical/VT/callconv/_il_dbgaa/_il_dbgaa.sh
JIT/Methodical/VT/callconv/_il_dbgcalli/_il_dbgcalli.sh
JIT/Methodical/VT/callconv/_il_dbgdd/_il_dbgdd.sh
JIT/Methodical/VT/callconv/_il_dbgee/_il_dbgee.sh
JIT/Methodical/VT/callconv/_il_dbgjumper1/_il_dbgjumper1.sh
JIT/Methodical/VT/callconv/_il_dbgjumper2/_il_dbgjumper2.sh
JIT/Methodical/VT/callconv/_il_dbgjumper3/_il_dbgjumper3.sh
JIT/Methodical/VT/callconv/_il_dbgjumper4/_il_dbgjumper4.sh
JIT/Methodical/VT/callconv/_il_dbgjumper5/_il_dbgjumper5.sh
JIT/Methodical/VT/callconv/_il_dbgvtret2/_il_dbgvtret2.sh
JIT/Methodical/VT/callconv/_il_dbgvtret/_il_dbgvtret.sh
JIT/Methodical/VT/callconv/_il_relaa/_il_relaa.sh
JIT/Methodical/VT/callconv/_il_relcalli/_il_relcalli.sh
JIT/Methodical/VT/callconv/_il_reldd/_il_reldd.sh
JIT/Methodical/VT/callconv/_il_relee/_il_relee.sh
JIT/Methodical/VT/callconv/_il_reljumper2/_il_reljumper2.sh
JIT/Methodical/VT/callconv/_il_reljumper3/_il_reljumper3.sh
JIT/Methodical/VT/callconv/_il_reljumper4/_il_reljumper4.sh
JIT/Methodical/VT/callconv/_il_reljumper5/_il_reljumper5.sh
JIT/Methodical/VT/callconv/_il_relvtret2/_il_relvtret2.sh
JIT/Methodical/VT/callconv/_il_relvtret/_il_relvtret.sh
JIT/Methodical/VT/callconv/_relcall/_relcall.sh
JIT/Methodical/VT/callconv/_reljumper/_reljumper.sh
JIT/Methodical/VT/callconv/_relvtret/_relvtret.sh
JIT/Methodical/VT/callconv/_speed_dbgcall/_speed_dbgcall.sh
JIT/Methodical/VT/callconv/_speed_relcall/_speed_relcall.sh
JIT/Methodical/VT/port/_dbglcs_gcref/_dbglcs_gcref.sh
JIT/Methodical/VT/port/_rellcs_gcref/_rellcs_gcref.sh
JIT/Methodical/VT/port/_speed_dbglcs_gcref/_speed_dbglcs_gcref.sh
JIT/Methodical/VT/port/_speed_rellcs_gcref/_speed_rellcs_gcref.sh
JIT/opt/Inline/tests/struct_opcodes/struct_opcodes.sh
JIT/opt/virtualstubdispatch/hashcode/ctest1_cs_d/ctest1_cs_d.sh
JIT/opt/virtualstubdispatch/hashcode/ctest1_cs_r/ctest1_cs_r.sh
JIT/opt/virtualstubdispatch/manyintf/ctest_cs_d/ctest_cs_d.sh
JIT/opt/virtualstubdispatch/manyintf/ctest_cs_do/ctest_cs_do.sh
JIT/opt/virtualstubdispatch/manyintf/ctest_cs_r/ctest_cs_r.sh
JIT/opt/virtualstubdispatch/manyintf/ctest_cs_ro/ctest_cs_ro.sh
JIT/Performance/CodeQuality/BenchmarksGame/pidigits/pidigits-3/pidigits-3.sh
JIT/Performance/CodeQuality/Burgers/Burgers/Burgers.sh
JIT/Performance/CodeQuality/Linq/Linq/Linq.sh
JIT/Performance/CodeQuality/Roslyn/CscBench/CscBench.sh
JIT/Performance/CodeQuality/SIMD/RayTracer/RayTracer/RayTracer.sh
JIT/Performance/CodeQuality/Span/Indexer/Indexer.sh
JIT/Performance/CodeQuality/Span/SpanBench/SpanBench.sh
JIT/Regression/CLR-x86-JIT/V1.1-M1-Beta1/b140902/b140902/b140902.sh
JIT/Regression/CLR-x86-JIT/V1.2-M01/b02345/b02345/b02345.sh
JIT/Regression/CLR-x86-JIT/V1-M09.5-PDC/b14716/b14716/b14716.sh
JIT/Regression/CLR-x86-JIT/V1-M10/b02352/b02352/b02352.sh
JIT/Regression/Dev11/DevDiv2_10623/DevDiv2_10623/DevDiv2_10623.sh
JIT/Regression/Dev11/External/Dev11_90434/UseUnalignedDouble/UseUnalignedDouble.sh
JIT/Regression/JitBlue/DevDiv_546018/DevDiv_546018/DevDiv_546018.sh
JIT/Regression/JitBlue/GitHub_10481/GitHub_10481/GitHub_10481.sh
JIT/Regression/JitBlue/GitHub_1133/GitHub_1133/GitHub_1133.sh
JIT/Regression/JitBlue/GitHub_11814/GitHub_11814/GitHub_11814.sh
JIT/Regression/JitBlue/GitHub_11816/GitHub_11816/GitHub_11816.sh
JIT/Regression/JitBlue/GitHub_13057/GitHub_13057/GitHub_13057.sh
JIT/Regression/JitBlue/GitHub_16254/GitHub_16254/GitHub_16254.sh
JIT/Regression/JitBlue/GitHub_18497/GitHub_18497/GitHub_18497.sh
JIT/Regression/JitBlue/GitHub_4115/GitHub_4115/GitHub_4115.sh
JIT/Regression/JitBlue/GitHub_5164/GitHub_5164/GitHub_5164.sh
JIT/Regression/JitBlue/GitHub_7508/Vector3Test/Vector3Test.sh
JIT/Regression/JitBlue/GitHub_8220/GitHub_8220/GitHub_8220.sh
JIT/Regression/VS-ia64-JIT/V1.2-M02/b26496/b26496/b26496.sh
JIT/Regression/VS-ia64-JIT/V2.0-Beta2/b309539/b309539/b309539.sh
JIT/Regression/VS-ia64-JIT/V2.0-RTM/b539509/b539509/b539509.sh
JIT/SIMD/AbsSqrt_r/AbsSqrt_r.sh
JIT/SIMD/AddingSequence_r/AddingSequence_r.sh
JIT/SIMD/CircleInConvex_r/CircleInConvex_r.sh
JIT/SIMD/CircleInConvex_ro/CircleInConvex_ro.sh
JIT/SIMD/CreateGeneric_r/CreateGeneric_r.sh
JIT/SIMD/CreateGeneric_ro/CreateGeneric_ro.sh
JIT/SIMD/DivSignedUnsignedTest_r/DivSignedUnsignedTest_r.sh
JIT/SIMD/DivSignedUnsignedTest_ro/DivSignedUnsignedTest_ro.sh
JIT/SIMD/LdfldGeneric_r/LdfldGeneric_r.sh
JIT/SIMD/Ldfld_r/Ldfld_r.sh
JIT/SIMD/Matrix4x4_r/Matrix4x4_r.sh
JIT/SIMD/Plane_r/Plane_r.sh
JIT/SIMD/SqrtGeneric_ro/SqrtGeneric_ro.sh
JIT/SIMD/SqrtGeneric_r/SqrtGeneric_r.sh
JIT/SIMD/Sums_r/Sums_r.sh
JIT/SIMD/Vector3Interop_ro/Vector3Interop_ro.sh
JIT/SIMD/Vector3Interop_r/Vector3Interop_r.sh
JIT/SIMD/Vector3_r/Vector3_r.sh
JIT/SIMD/Vector4_r/Vector4_r.sh
JIT/SIMD/VectorArgs_ro/VectorArgs_ro.sh
JIT/SIMD/VectorArgs_r/VectorArgs_r.sh
JIT/SIMD/VectorCast_ro/VectorCast_ro.sh
JIT/SIMD/VectorCast_r/VectorCast_r.sh
JIT/SIMD/VectorConvert_ro/VectorConvert_ro.sh
JIT/SIMD/VectorConvert_r/VectorConvert_r.sh
JIT/SIMD/VectorDiv_ro/VectorDiv_ro.sh
JIT/SIMD/VectorDiv_r/VectorDiv_r.sh
JIT/SIMD/VectorExp_ro/VectorExp_ro.sh
JIT/SIMD/VectorExp_r/VectorExp_r.sh
JIT/SIMD/VectorMul_ro/VectorMul_ro.sh
JIT/SIMD/VectorMul_r/VectorMul_r.sh
JIT/SIMD/VectorReturn_ro/VectorReturn_ro.sh
JIT/SIMD/VectorReturn_r/VectorReturn_r.sh
JIT/SIMD/VectorUnused_r/VectorUnused_r.sh
Loader/classloader/regressions/208900/bug/bug.sh
Loader/classloader/v1/Beta1/Layout/Matrix/cs/L-2-5-3/L-2-5-3.sh
readytorun/r2rdump/R2RDumpTest/R2RDumpTest.sh
tracing/eventactivityidcontrol/eventactivityidcontrol/eventactivityidcontrol.sh
tracing/eventsource/eventsourcetrace/eventsourcetrace/eventsourcetrace.sh
tracing/tracevalidation/inducedgc/inducedgc/inducedgc.sh
tracing/tracevalidation/jittingstarted/JittingStarted/JittingStarted.sh
tracing/tracevalidation/rundown/rundown/rundown.sh
```</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19026</IssueLabelID>
    <Title>hi i use .net core 2.1in raspberry pi os raspbian 8 wil let CPU100%bug .net core 2.0 will not</Title>
    <Description>this is the arm linux 32 corclr tracing
https://github.com/AirleaderChina/Airleader-Open/blob/master/sampleTrace.trace.zip
bug i can't found any useful information.
the tracing display coreclr use many cpu times </Description>
    <Title_Description>hi i use .net core 2.1in raspberry pi os raspbian 8 wil let CPU100%,bug .net core 2.0 will not this is the arm linux 32 corclr tracing
https://github.com/AirleaderChina/Airleader-Open/blob/master/sampleTrace.trace.zip
bug i can't found any useful information.
the tracing display coreclr use many cpu times </Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>19/07/2018 2:40:59 PM +00:00</CreatedAt>
    <ClosedAt>16/08/2018 3:59:05 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19025</IssueLabelID>
    <Title>CoreCLR doesn't boot on a "modern" Linux/ARM image</Title>
    <Description>I'm able to compile .NET Core 2.1 for my Linux distribution based on Yocto for ARM. If I'm doing this for the "pyro" release from spring 2017 I can run the simple Hello World both when using the dotnet executable I've compiled with the just the dll as well as a self-contained publish for `linux-arm` coming from Windows.

With Yocto's "sumo" release from spring 2018 both methods of running the application hang indefinitely and don't printing anything. CTRL+C doesn't do anything and I have to kill -KILL from another shell.

As can be expected there are a couple of updates to the libraries included in the distribution. I'm listing the direct dependencies I've declared for my build in the following table

Library | pyro | sumo
------- | ---- | ----
clang | 4.0.1 | 6.0.1
cmake | 3.7.2 | 3.10.3
glibc | 2.25 | 2.27
libunwind | 1.1 | 1.2.1
icu | 58.2 | 60.2
openssl | 1.0.2n | 1.0.2o
util-linux | 2.29.1 | 2.31
lttng-ust | 2.9.0 | 2.10.1
krb5 | 1.15.1 | 1.16
curl | 7.53.1 | 7.58.0

I'm currently creating a Debug build and try to work with (against?) lldb to get some insight. Running with gdb also hangs and cannot be interrupted for a stack trace or the likes.

Any ideas?</Description>
    <Title_Description>CoreCLR doesn't boot on a "modern" Linux/ARM image I'm able to compile .NET Core 2.1 for my Linux distribution based on Yocto for ARM. If I'm doing this for the "pyro" release from spring 2017 I can run the simple Hello World both when using the dotnet executable I've compiled with the just the dll as well as a self-contained publish for `linux-arm` coming from Windows.

With Yocto's "sumo" release from spring 2018 both methods of running the application hang indefinitely and don't printing anything. CTRL+C doesn't do anything and I have to kill -KILL from another shell.

As can be expected there are a couple of updates to the libraries included in the distribution. I'm listing the direct dependencies I've declared for my build in the following table

Library | pyro | sumo
------- | ---- | ----
clang | 4.0.1 | 6.0.1
cmake | 3.7.2 | 3.10.3
glibc | 2.25 | 2.27
libunwind | 1.1 | 1.2.1
icu | 58.2 | 60.2
openssl | 1.0.2n | 1.0.2o
util-linux | 2.29.1 | 2.31
lttng-ust | 2.9.0 | 2.10.1
krb5 | 1.15.1 | 1.16
curl | 7.53.1 | 7.58.0

I'm currently creating a Debug build and try to work with (against?) lldb to get some insight. Running with gdb also hangs and cannot be interrupted for a stack trace or the likes.

Any ideas?</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>19/07/2018 2:32:50 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19023</IssueLabelID>
    <Title>Clarify calling conventions for profiler Enter callback</Title>
    <Description>@dotnet/jit-contrib @sywhang 

While investigating #18977 I'm seeing a number of things that look inconsistent and probably need to be fixed or better documented. Jit folks can you let me know what you think?

1) The [FunctionEnter3](https://docs.microsoft.com/en-us/dotnet/framework/unmanaged-api/profiling/functionenter3-function)/[FunctionLeave3](https://docs.microsoft.com/en-us/dotnet/framework/unmanaged-api/profiling/functionleave3-function)/[FunctionTailcall3](https://docs.microsoft.com/en-us/dotnet/framework/unmanaged-api/profiling/functiontailcall3-function) methods are a publicly exposed and have a documented ABI. On Linux x64 we pass FunctionIDOrClientID in R14 MSDN documentation doesn't mention a custom calling convention so developers would expect RDI. I believe we picked R14 for good reason so I propose we change MSDN to match.
2) The runtime sometimes provides the implementation of the ProfileEnter call as an intermediary between the jitted code and other forms of the profiler callback. On Linux x64 that gives us 4 non-agreeing definitions of the register preservation requirements:
  - The MSDN docs claim the caller must preserve all registers
  - The code comments above the runtime ProfileEnterNaked implementation suggest a number of registers are not preserved:
https://github.com/dotnet/coreclr/blob/master/src/vm/amd64/asmhelpers.S#L59
   (Incidentally the comments aren't self-consistent either xmm1 and rdx are both preserved and not preserved ; )
   - The implementation of the JIT has different expectations about what would be preserved (for example is it really safe to trash the argument registers in the prologue of the caller?)
   - The implementation of the assembly routine preserves all the integer argument registers
https://github.com/dotnet/coreclr/blob/master/src/vm/amd64/asmhelpers.S#L135

I don't have a good sense of exactly what the JIT expects to be preserved across this call for the code to run correctly but whatever it is I'd like to bring our own comments implementation and MSDN docs into alignment with it. I suspect there may be discrepancies for the register preservation requirements on other architectures but I'm happy to start with Linux x64.

Thanks!
 -Noah
</Description>
    <Title_Description>Clarify calling conventions for profiler Enter callback @dotnet/jit-contrib @sywhang 

While investigating #18977 I'm seeing a number of things that look inconsistent and probably need to be fixed or better documented. Jit folks can you let me know what you think?

1) The [FunctionEnter3](https://docs.microsoft.com/en-us/dotnet/framework/unmanaged-api/profiling/functionenter3-function)/[FunctionLeave3](https://docs.microsoft.com/en-us/dotnet/framework/unmanaged-api/profiling/functionleave3-function)/[FunctionTailcall3](https://docs.microsoft.com/en-us/dotnet/framework/unmanaged-api/profiling/functiontailcall3-function) methods are a publicly exposed and have a documented ABI. On Linux x64 we pass FunctionIDOrClientID in R14 MSDN documentation doesn't mention a custom calling convention so developers would expect RDI. I believe we picked R14 for good reason so I propose we change MSDN to match.
2) The runtime sometimes provides the implementation of the ProfileEnter call as an intermediary between the jitted code and other forms of the profiler callback. On Linux x64 that gives us 4 non-agreeing definitions of the register preservation requirements:
  - The MSDN docs claim the caller must preserve all registers
  - The code comments above the runtime ProfileEnterNaked implementation suggest a number of registers are not preserved:
https://github.com/dotnet/coreclr/blob/master/src/vm/amd64/asmhelpers.S#L59
   (Incidentally the comments aren't self-consistent either xmm1 and rdx are both preserved and not preserved ; )
   - The implementation of the JIT has different expectations about what would be preserved (for example is it really safe to trash the argument registers in the prologue of the caller?)
   - The implementation of the assembly routine preserves all the integer argument registers
https://github.com/dotnet/coreclr/blob/master/src/vm/amd64/asmhelpers.S#L135

I don't have a good sense of exactly what the JIT expects to be preserved across this call for the code to run correctly but whatever it is I'd like to bring our own comments implementation and MSDN docs into alignment with it. I suspect there may be discrepancies for the register preservation requirements on other architectures but I'm happy to start with Linux x64.

Thanks!
 -Noah
</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>sywhang</Assignee>
    <CreatedAt>19/07/2018 12:16:36 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19022</IssueLabelID>
    <Title>Access Violation Exception in clrjit.dll - lclvars.cpp - lvaMarkLocalVars </Title>
    <Description>Here's the callstack dump:

```
clrjit.dll!Compiler::lvaMarkLclRefs(GenTree * tree) Line 3692
	at f:\dd\ndp\clr\src\jit\lclvars.cpp(3692)
[Inline Frame] clrjit.dll!Compiler::lvaMarkLocalVars::__l2::MarkLocalVarsVisitor::PreOrderVisit(GenTree * *) Line 3925
	at f:\dd\ndp\clr\src\jit\lclvars.cpp(3925)
clrjit.dll!GenTreeVisitor&lt;`Compiler::lvaMarkLocalVars'::`2'::MarkLocalVarsVisitor&gt;::WalkTree(GenTree * * use GenTree *) Line 9637
	at f:\dd\ndp\clr\src\jit\compiler.h(9637)
[Inline Frame] clrjit.dll!Compiler::lvaMarkLocalVars(BasicBlock *) Line 3959
	at f:\dd\ndp\clr\src\jit\lclvars.cpp(3959)
clrjit.dll!Compiler::lvaMarkLocalVars() Line 4082
	at f:\dd\ndp\clr\src\jit\lclvars.cpp(4082)
clrjit.dll!Compiler::compCompile(void * * methodCodePtr unsigned long * methodCodeSize JitFlags * compileFlags) Line 4581
	at f:\dd\ndp\clr\src\jit\compiler.cpp(4581)
clrjit.dll!Compiler::compCompileHelper(CORINFO_MODULE_STRUCT_ * classPtr ICorJitInfo * compHnd CORINFO_METHOD_INFO * methodInfo void * * methodCodePtr unsigned long * methodCodeSize JitFlags * compileFlags CorInfoInstantiationVerification) Line 6025
	at f:\dd\ndp\clr\src\jit\compiler.cpp(6025)
clrjit.dll!Compiler::compCompile(CORINFO_METHOD_STRUCT_ * methodHnd CORINFO_MODULE_STRUCT_ * classPtr ICorJitInfo * compHnd CORINFO_METHOD_INFO * methodInfo void * * methodCodePtr unsigned long * methodCodeSize JitFlags * compileFlags) Line 5359
	at f:\dd\ndp\clr\src\jit\compiler.cpp(5359)
clrjit.dll!jitNativeCode(CORINFO_METHOD_STRUCT_ * methodHnd CORINFO_MODULE_STRUCT_ * classPtr ICorJitInfo * compHnd CORINFO_METHOD_INFO * methodInfo void * * methodCodePtr unsigned long * methodCodeSize JitFlags * compileFlags void * inlineInfoPtr) Line 6666
	at f:\dd\ndp\clr\src\jit\compiler.cpp(6666)
clrjit.dll!CILJit::compileMethod(ICorJitInfo * compHnd CORINFO_METHOD_INFO * methodInfo unsigned int flags unsigned char * * entryAddress unsigned long * nativeSizeOfCode) Line 315
	at f:\dd\ndp\clr\src\jit\ee_il_dll.cpp(315)
[External Code]
mscoreei.dll!00007ffc2b107b2d()
mscoree.dll!00007ffc2b50a4cc()
kernel32.dll!00007ffc42443034()
ntdll.dll!00007ffc44bb1431()
```

Assembly code:

```
--- f:\dd\ndp\clr\src\jit\lclvars.cpp ------------------------------------------
00007FFC2125E5B0  mov         raxrsp  
00007FFC2125E5B3  mov         qword ptr [rax+8]rbx  
00007FFC2125E5B7  mov         qword ptr [rax+10h]rbp  
00007FFC2125E5BB  mov         qword ptr [rax+18h]rsi  
00007FFC2125E5BF  mov         qword ptr [rax+20h]rdi  
00007FFC2125E5C3  push        r14  
00007FFC2125E5C5  sub         rsp20h  
00007FFC2125E5C9  mov         ebpedx  
00007FFC2125E5CB  mov         edir9d  
00007FFC2125E5CE  mov         r14dr8d  
00007FFC2125E5D1  mov         rsircx  
00007FFC2125E5D4  cmp         edx0FFFFFFFFh  
00007FFC2125E5D7  je          AliasSet::AliasSet+9D970h (07FFC212F4F28h)  
00007FFC2125E5DD  mov         r9d8  
00007FFC2125E5E3  cmp         r14dr9d  
00007FFC2125E5E6  jb          Compiler::lvaAllocLocalAndSetVirtualOffset+72h (07FFC2125E622h)  
00007FFC2125E5E8  mov         r8ddword ptr [rsi+2A84h]  
00007FFC2125E5EF  xor         ebxebx  
00007FFC2125E5F1  mov         r10b4  
00007FFC2125E5F4  cmp         r8d5  
00007FFC2125E5F8  jne         Compiler::lvaAllocLocalAndSetVirtualOffset+519A2h (07FFC212AFF52h)  
00007FFC2125E5FE  mov         eaxedi  
00007FFC2125E600  cdq  
00007FFC2125E601  idiv        eaxr9d  
00007FFC2125E604  test        edxedx  
00007FFC2125E606  jne         Compiler::lvaAllocLocalAndSetVirtualOffset+519A2h (07FFC212AFF52h)  
00007FFC2125E60C  mov         raxqword ptr [rsi+78h]  
00007FFC2125E610  mov         rcxrbp  
00007FFC2125E613  shl         rcx7  
00007FFC2125E617  test        byte ptr [rcx+rax+6]r10b  
00007FFC2125E61C  jne         Compiler::lvaAllocLocalAndSetVirtualOffset+519A2h (07FFC212AFF52h)  
00007FFC2125E622  mov         edx3FFFFFFFh  
00007FFC2125E627  cmp         r14dedx  
00007FFC2125E62A  ja          Compiler::lvaAllocLocalAndSetVirtualOffset+83D20h (07FFC212E22D0h)  
00007FFC2125E630  mov         ecxdword ptr [rsi+2BB4h]  
00007FFC2125E636  add         ecxr14d  
00007FFC2125E639  cmp         ecxedx  
00007FFC2125E63B  ja          Compiler::lvaAllocLocalAndSetVirtualOffset+83D20h (07FFC212E22D0h)  
00007FFC2125E641  mov         raxqword ptr [rsi+78h]  
00007FFC2125E645  sub         edir14d  
00007FFC2125E648  mov         rbxqword ptr [rsp+30h]  
00007FFC2125E64D  mov         dword ptr [rsi+2BB4h]ecx  
00007FFC2125E653  mov         rcxrbp  
00007FFC2125E656  mov         rbpqword ptr [rsp+38h]  
00007FFC2125E65B  mov         rsiqword ptr [rsp+40h]  
00007FFC2125E660  shl         rcx7  
00007FFC2125E664  mov         dword ptr [rcx+rax+20h]edi  
00007FFC2125E668  mov         eaxedi  
00007FFC2125E66A  mov         rdiqword ptr [rsp+48h]  
00007FFC2125E66F  add         rsp20h  
00007FFC2125E673  pop         r14  
00007FFC2125E675  ret  
00007FFC2125E676  movzx       eaxbyte ptr [rdi+1]  
00007FFC2125E67A  mov         rbpqword ptr [rdi+38h]  
00007FFC2125E67E  sub         al2  
00007FFC2125E680  mov         rbxqword ptr [rdi+40h]  
00007FFC2125E684  cmp         al2  
00007FFC2125E686  jbe         $NOT_BOOL+2B582h (07FFC21289C44h)  
00007FFC2125E68C  cmp         byte ptr [rbp]1  
00007FFC2125E690  jne         Compiler::lvaMarkLclRefs+32h (07FFC2123F632h)  

&gt;&gt;&gt;&gt;&gt;&gt;  00007FFC2125E696  cmp         byte ptr [rbx+1]2  

00007FFC2125E69A  je          Compiler::lvaMarkLclRefs+32h (07FFC2123F632h)  
00007FFC2125E6A0  cmp         byte ptr [rdi]3Fh  
00007FFC2125E6A3  jne         $NOT_BOOL (07FFC2125E6C2h)  
00007FFC2125E6A5  movzx       eaxbyte ptr [rbx]  
00007FFC2125E6A8  cmp         al0Bh  
00007FFC2125E6AA  je          $NOT_BOOL+14F71h (07FFC21273633h)  
00007FFC2125E6B0  movzx       eaxal  
00007FFC2125E6B3  test        byte ptr GenTree::gtOperKindTable (07FFC21322330h)[r15+rax*2-7FFC21230000h]10h  
00007FFC2125E6BC  jne         Compiler::lvaMarkLclRefs+32h (07FFC2123F632h)  
00007FFC2125E6C2  mov         ebxdword ptr [rbp+40h]  
00007FFC2125E6C5  cmp         ebxdword ptr [rsi+70h]  
00007FFC2125E6C8  jae         AliasSet::AliasSet+9DCC5h (07FFC212F527Dh)  
00007FFC2125E6CE  mov         raxqword ptr [rsi+78h]  
00007FFC2125E6D2  mov         rcxrbx  
00007FFC2125E6D5  shl         rcx7  
00007FFC2125E6D9  and         byte ptr [rcx+rax+3]0F7h  
00007FFC2125E6DE  jmp         Compiler::lvaMarkLclRefs+32h (07FFC2123F632h)  
00007FFC2125E6E3  int         3  
```

Other relevant info:

- Using Latest version of VS2017 community on a x64bit machine.
- The project is a classic Desktop Application
- It was using Net452 by default but it also crashes with Net471.
- Release mode crashes Debug mode works.
- It crashes with target platform x64
- It works well with target platform x86 for now we're going to force x86 as a temporary solution.

I'll post any other info I can get.</Description>
    <Title_Description>Access Violation Exception in clrjit.dll - lclvars.cpp - lvaMarkLocalVars  Here's the callstack dump:

```
clrjit.dll!Compiler::lvaMarkLclRefs(GenTree * tree) Line 3692
	at f:\dd\ndp\clr\src\jit\lclvars.cpp(3692)
[Inline Frame] clrjit.dll!Compiler::lvaMarkLocalVars::__l2::MarkLocalVarsVisitor::PreOrderVisit(GenTree * *) Line 3925
	at f:\dd\ndp\clr\src\jit\lclvars.cpp(3925)
clrjit.dll!GenTreeVisitor&lt;`Compiler::lvaMarkLocalVars'::`2'::MarkLocalVarsVisitor&gt;::WalkTree(GenTree * * use GenTree *) Line 9637
	at f:\dd\ndp\clr\src\jit\compiler.h(9637)
[Inline Frame] clrjit.dll!Compiler::lvaMarkLocalVars(BasicBlock *) Line 3959
	at f:\dd\ndp\clr\src\jit\lclvars.cpp(3959)
clrjit.dll!Compiler::lvaMarkLocalVars() Line 4082
	at f:\dd\ndp\clr\src\jit\lclvars.cpp(4082)
clrjit.dll!Compiler::compCompile(void * * methodCodePtr unsigned long * methodCodeSize JitFlags * compileFlags) Line 4581
	at f:\dd\ndp\clr\src\jit\compiler.cpp(4581)
clrjit.dll!Compiler::compCompileHelper(CORINFO_MODULE_STRUCT_ * classPtr ICorJitInfo * compHnd CORINFO_METHOD_INFO * methodInfo void * * methodCodePtr unsigned long * methodCodeSize JitFlags * compileFlags CorInfoInstantiationVerification) Line 6025
	at f:\dd\ndp\clr\src\jit\compiler.cpp(6025)
clrjit.dll!Compiler::compCompile(CORINFO_METHOD_STRUCT_ * methodHnd CORINFO_MODULE_STRUCT_ * classPtr ICorJitInfo * compHnd CORINFO_METHOD_INFO * methodInfo void * * methodCodePtr unsigned long * methodCodeSize JitFlags * compileFlags) Line 5359
	at f:\dd\ndp\clr\src\jit\compiler.cpp(5359)
clrjit.dll!jitNativeCode(CORINFO_METHOD_STRUCT_ * methodHnd CORINFO_MODULE_STRUCT_ * classPtr ICorJitInfo * compHnd CORINFO_METHOD_INFO * methodInfo void * * methodCodePtr unsigned long * methodCodeSize JitFlags * compileFlags void * inlineInfoPtr) Line 6666
	at f:\dd\ndp\clr\src\jit\compiler.cpp(6666)
clrjit.dll!CILJit::compileMethod(ICorJitInfo * compHnd CORINFO_METHOD_INFO * methodInfo unsigned int flags unsigned char * * entryAddress unsigned long * nativeSizeOfCode) Line 315
	at f:\dd\ndp\clr\src\jit\ee_il_dll.cpp(315)
[External Code]
mscoreei.dll!00007ffc2b107b2d()
mscoree.dll!00007ffc2b50a4cc()
kernel32.dll!00007ffc42443034()
ntdll.dll!00007ffc44bb1431()
```

Assembly code:

```
--- f:\dd\ndp\clr\src\jit\lclvars.cpp ------------------------------------------
00007FFC2125E5B0  mov         raxrsp  
00007FFC2125E5B3  mov         qword ptr [rax+8]rbx  
00007FFC2125E5B7  mov         qword ptr [rax+10h]rbp  
00007FFC2125E5BB  mov         qword ptr [rax+18h]rsi  
00007FFC2125E5BF  mov         qword ptr [rax+20h]rdi  
00007FFC2125E5C3  push        r14  
00007FFC2125E5C5  sub         rsp20h  
00007FFC2125E5C9  mov         ebpedx  
00007FFC2125E5CB  mov         edir9d  
00007FFC2125E5CE  mov         r14dr8d  
00007FFC2125E5D1  mov         rsircx  
00007FFC2125E5D4  cmp         edx0FFFFFFFFh  
00007FFC2125E5D7  je          AliasSet::AliasSet+9D970h (07FFC212F4F28h)  
00007FFC2125E5DD  mov         r9d8  
00007FFC2125E5E3  cmp         r14dr9d  
00007FFC2125E5E6  jb          Compiler::lvaAllocLocalAndSetVirtualOffset+72h (07FFC2125E622h)  
00007FFC2125E5E8  mov         r8ddword ptr [rsi+2A84h]  
00007FFC2125E5EF  xor         ebxebx  
00007FFC2125E5F1  mov         r10b4  
00007FFC2125E5F4  cmp         r8d5  
00007FFC2125E5F8  jne         Compiler::lvaAllocLocalAndSetVirtualOffset+519A2h (07FFC212AFF52h)  
00007FFC2125E5FE  mov         eaxedi  
00007FFC2125E600  cdq  
00007FFC2125E601  idiv        eaxr9d  
00007FFC2125E604  test        edxedx  
00007FFC2125E606  jne         Compiler::lvaAllocLocalAndSetVirtualOffset+519A2h (07FFC212AFF52h)  
00007FFC2125E60C  mov         raxqword ptr [rsi+78h]  
00007FFC2125E610  mov         rcxrbp  
00007FFC2125E613  shl         rcx7  
00007FFC2125E617  test        byte ptr [rcx+rax+6]r10b  
00007FFC2125E61C  jne         Compiler::lvaAllocLocalAndSetVirtualOffset+519A2h (07FFC212AFF52h)  
00007FFC2125E622  mov         edx3FFFFFFFh  
00007FFC2125E627  cmp         r14dedx  
00007FFC2125E62A  ja          Compiler::lvaAllocLocalAndSetVirtualOffset+83D20h (07FFC212E22D0h)  
00007FFC2125E630  mov         ecxdword ptr [rsi+2BB4h]  
00007FFC2125E636  add         ecxr14d  
00007FFC2125E639  cmp         ecxedx  
00007FFC2125E63B  ja          Compiler::lvaAllocLocalAndSetVirtualOffset+83D20h (07FFC212E22D0h)  
00007FFC2125E641  mov         raxqword ptr [rsi+78h]  
00007FFC2125E645  sub         edir14d  
00007FFC2125E648  mov         rbxqword ptr [rsp+30h]  
00007FFC2125E64D  mov         dword ptr [rsi+2BB4h]ecx  
00007FFC2125E653  mov         rcxrbp  
00007FFC2125E656  mov         rbpqword ptr [rsp+38h]  
00007FFC2125E65B  mov         rsiqword ptr [rsp+40h]  
00007FFC2125E660  shl         rcx7  
00007FFC2125E664  mov         dword ptr [rcx+rax+20h]edi  
00007FFC2125E668  mov         eaxedi  
00007FFC2125E66A  mov         rdiqword ptr [rsp+48h]  
00007FFC2125E66F  add         rsp20h  
00007FFC2125E673  pop         r14  
00007FFC2125E675  ret  
00007FFC2125E676  movzx       eaxbyte ptr [rdi+1]  
00007FFC2125E67A  mov         rbpqword ptr [rdi+38h]  
00007FFC2125E67E  sub         al2  
00007FFC2125E680  mov         rbxqword ptr [rdi+40h]  
00007FFC2125E684  cmp         al2  
00007FFC2125E686  jbe         $NOT_BOOL+2B582h (07FFC21289C44h)  
00007FFC2125E68C  cmp         byte ptr [rbp]1  
00007FFC2125E690  jne         Compiler::lvaMarkLclRefs+32h (07FFC2123F632h)  

&gt;&gt;&gt;&gt;&gt;&gt;  00007FFC2125E696  cmp         byte ptr [rbx+1]2  

00007FFC2125E69A  je          Compiler::lvaMarkLclRefs+32h (07FFC2123F632h)  
00007FFC2125E6A0  cmp         byte ptr [rdi]3Fh  
00007FFC2125E6A3  jne         $NOT_BOOL (07FFC2125E6C2h)  
00007FFC2125E6A5  movzx       eaxbyte ptr [rbx]  
00007FFC2125E6A8  cmp         al0Bh  
00007FFC2125E6AA  je          $NOT_BOOL+14F71h (07FFC21273633h)  
00007FFC2125E6B0  movzx       eaxal  
00007FFC2125E6B3  test        byte ptr GenTree::gtOperKindTable (07FFC21322330h)[r15+rax*2-7FFC21230000h]10h  
00007FFC2125E6BC  jne         Compiler::lvaMarkLclRefs+32h (07FFC2123F632h)  
00007FFC2125E6C2  mov         ebxdword ptr [rbp+40h]  
00007FFC2125E6C5  cmp         ebxdword ptr [rsi+70h]  
00007FFC2125E6C8  jae         AliasSet::AliasSet+9DCC5h (07FFC212F527Dh)  
00007FFC2125E6CE  mov         raxqword ptr [rsi+78h]  
00007FFC2125E6D2  mov         rcxrbx  
00007FFC2125E6D5  shl         rcx7  
00007FFC2125E6D9  and         byte ptr [rcx+rax+3]0F7h  
00007FFC2125E6DE  jmp         Compiler::lvaMarkLclRefs+32h (07FFC2123F632h)  
00007FFC2125E6E3  int         3  
```

Other relevant info:

- Using Latest version of VS2017 community on a x64bit machine.
- The project is a classic Desktop Application
- It was using Net452 by default but it also crashes with Net471.
- Release mode crashes Debug mode works.
- It crashes with target platform x64
- It works well with target platform x86 for now we're going to force x86 as a temporary solution.

I'll post any other info I can get.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>briansull</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19020</IssueLabelID>
    <Title>Build failure: ARM64 build of Interop\COM\NativeServer\COMNativeServer</Title>
    <Description>Opened on behalf of @RussKeldorph

Warnings: 1
Status Message: failed

Build : Master - 20180719.01 (Product Build)
Failing configurations:
- Windows
  - Build-Tests-R2R-Release-arm64
  - Build-Tests-Release-arm64
[Mission Control Build Info](https://mc.dot.net/#/product/netcore/master/source/official~2Fcoreclr~2Fmaster~2F/type/build~2Fproduct~2F/build/20180719.01/workItem/Orchestration/analysis/external/Link)
</Description>
    <Title_Description>Build failure: ARM64 build of Interop\COM\NativeServer\COMNativeServer Opened on behalf of @RussKeldorph

Warnings: 1
Status Message: failed

Build : Master - 20180719.01 (Product Build)
Failing configurations:
- Windows
  - Build-Tests-R2R-Release-arm64
  - Build-Tests-Release-arm64
[Mission Control Build Info](https://mc.dot.net/#/product/netcore/master/source/official~2Fcoreclr~2Fmaster~2F/type/build~2Fproduct~2F/build/20180719.01/workItem/Orchestration/analysis/external/Link)
</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19018</IssueLabelID>
    <Title>Test failure: Exceptions_Finalization._Finalizer_Finalizer_/_Finalizer_Finalizer_cmd</Title>
    <Description>Opened on behalf of @Sunny-pu

The test `Exceptions_Finalization._Finalizer_Finalizer_/_Finalizer_Finalizer_cmd` has failed.

Test Infrastructure Failure: Could not load file or assembly 'System.Diagnostics.Process Version=4.2.1.0 Culture=neutral PublicKeyToken=b03f5f7f11d50a3a'. The system cannot find the file specified.
    
    Expected: True
    Actual:   False

        Stack Trace:

        
Build : Master - 20180719.01 (Ready-To-Run Tests)
Failing configurations:
- opensuse.423.amd64
  - x64

Details: https://mc.dot.net/#/product/netcore/master/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fr2r~2Fcli~2F/build/20180719.01/workItem/Exceptions.Finalization.XUnitWrapper/analysis/xunit/Exceptions_Finalization._Finalizer_Finalizer_~2F_Finalizer_Finalizer_cmd</Description>
    <Title_Description>Test failure: Exceptions_Finalization._Finalizer_Finalizer_/_Finalizer_Finalizer_cmd Opened on behalf of @Sunny-pu

The test `Exceptions_Finalization._Finalizer_Finalizer_/_Finalizer_Finalizer_cmd` has failed.

Test Infrastructure Failure: Could not load file or assembly 'System.Diagnostics.Process Version=4.2.1.0 Culture=neutral PublicKeyToken=b03f5f7f11d50a3a'. The system cannot find the file specified.
    
    Expected: True
    Actual:   False

        Stack Trace:

        
Build : Master - 20180719.01 (Ready-To-Run Tests)
Failing configurations:
- opensuse.423.amd64
  - x64

Details: https://mc.dot.net/#/product/netcore/master/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fr2r~2Fcli~2F/build/20180719.01/workItem/Exceptions.Finalization.XUnitWrapper/analysis/xunit/Exceptions_Finalization._Finalizer_Finalizer_~2F_Finalizer_Finalizer_cmd</Title_Description>
    <Label>GCStress</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>19/07/2018 7:19:09 AM +00:00</CreatedAt>
    <ClosedAt>21/06/2019 11:05:53 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19017</IssueLabelID>
    <Title>Test failure: Interop_COM._NETClients_Primitives_NETClientPrimitives_NETClientPrimitives_/_NETClients_Primitives_NETClientPrimitives_NETClientPrimitives_cmd</Title>
    <Description>Opened on behalf of @Sunny-pu

The test `Interop_COM._NETClients_Primitives_NETClientPrimitives_NETClientPrimitives_/_NETClients_Primitives_NETClientPrimitives_NETClientPrimitives_cmd` has failed.


    
    Return code:      1
    Raw output file:      C:\\work\\3400b627-09fb-4f1a-bd33-2f4c2d5e051f\\Work\\c699e3df-3136-4654-9043-92d2f057c2b0\\Unzip\\Reports\\Interop.COM\\NETClients\\Primitives\\NETClientPrimitives\\NETClientPrimitives.output.txt
    Raw output:
    BEGIN EXECUTION\r
     \"C:\\work\\3400b627-09fb-4f1a-bd33-2f4c2d5e051f\\Payload\\corerun.exe\" NETClientPrimitives.exe \r
    Numeric RNG seed: 37\r
    Test Failure: Retrieving the COM class factory for component with CLSID {53169A33-E85D-4E3C-B668-24E438D0929B} failed due to the following error: 80040154 Class not registered (Exception from HRESULT: 0x80040154 (REGDB_E_CLASSNOTREG)).
       at NetClient.NumericTests..ctor(Int32 seed) in E:\\A\\_work\\124\\s\\tests\\src\\Interop\\COM\\NETClients\\Primitives\\NumericTests.cs:line 22\r
       at NetClient.Program.Main(String[] doNotUse) in E:\\A\\_work\\124\\s\\tests\\src\\Interop\\COM\\NETClients\\Primitives\\Program.cs:line 15\r
    Expected: 100\r
    Actual: 101\r
    END EXECUTION - FAILED\r
    FAILED\r
    Test Harness Exitcode is : 1\r
    
    To run the test:
    &gt; set CORE_ROOT=C:\\work\\3400b627-09fb-4f1a-bd33-2f4c2d5e051f\\Payload
    &gt; C:\\work\\3400b627-09fb-4f1a-bd33-2f4c2d5e051f\\Work\\c699e3df-3136-4654-9043-92d2f057c2b0\\Unzip\\NETClients\\Primitives\\NETClientPrimitives\\NETClientPrimitives.cmd
    \r
    Expected: True\r
    Actual:   False

        Stack Trace:

        
Build : Master - 20180719.01 (Core Tests)
Failing configurations:
- Windows.10.Nano.Amd64-x64
  - 
- sles.12.amd64-x64
  - 
- opensuse.423.amd64-x64
  - 
- ubuntu.1804.amd64-x64
  - 
- ubuntu.1710.amd64-x64
  - 
- ubuntu.1604.amd64-x64
  - 
- ubuntu.1404.amd64-x64
  - 
- redhat.73.amd64-x64
  - 
- fedora.27.amd64-x64
  - 
- fedora.26.amd64-x64
  - 
- debian.82.amd64-x64
  - 
- osx.1013.amd64-x64
  - 
- osx.1012.amd64-x64
  - 

Details: https://mc.dot.net/#/product/netcore/master/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fcli~2F/build/20180719.01/workItem/Interop.COM.XUnitWrapper/analysis/xunit/Interop_COM._NETClients_Primitives_NETClientPrimitives_NETClientPrimitives_~2F_NETClients_Primitives_NETClientPrimitives_NETClientPrimitives_cmd</Description>
    <Title_Description>Test failure: Interop_COM._NETClients_Primitives_NETClientPrimitives_NETClientPrimitives_/_NETClients_Primitives_NETClientPrimitives_NETClientPrimitives_cmd Opened on behalf of @Sunny-pu

The test `Interop_COM._NETClients_Primitives_NETClientPrimitives_NETClientPrimitives_/_NETClients_Primitives_NETClientPrimitives_NETClientPrimitives_cmd` has failed.


    
    Return code:      1
    Raw output file:      C:\\work\\3400b627-09fb-4f1a-bd33-2f4c2d5e051f\\Work\\c699e3df-3136-4654-9043-92d2f057c2b0\\Unzip\\Reports\\Interop.COM\\NETClients\\Primitives\\NETClientPrimitives\\NETClientPrimitives.output.txt
    Raw output:
    BEGIN EXECUTION\r
     \"C:\\work\\3400b627-09fb-4f1a-bd33-2f4c2d5e051f\\Payload\\corerun.exe\" NETClientPrimitives.exe \r
    Numeric RNG seed: 37\r
    Test Failure: Retrieving the COM class factory for component with CLSID {53169A33-E85D-4E3C-B668-24E438D0929B} failed due to the following error: 80040154 Class not registered (Exception from HRESULT: 0x80040154 (REGDB_E_CLASSNOTREG)).
       at NetClient.NumericTests..ctor(Int32 seed) in E:\\A\\_work\\124\\s\\tests\\src\\Interop\\COM\\NETClients\\Primitives\\NumericTests.cs:line 22\r
       at NetClient.Program.Main(String[] doNotUse) in E:\\A\\_work\\124\\s\\tests\\src\\Interop\\COM\\NETClients\\Primitives\\Program.cs:line 15\r
    Expected: 100\r
    Actual: 101\r
    END EXECUTION - FAILED\r
    FAILED\r
    Test Harness Exitcode is : 1\r
    
    To run the test:
    &gt; set CORE_ROOT=C:\\work\\3400b627-09fb-4f1a-bd33-2f4c2d5e051f\\Payload
    &gt; C:\\work\\3400b627-09fb-4f1a-bd33-2f4c2d5e051f\\Work\\c699e3df-3136-4654-9043-92d2f057c2b0\\Unzip\\NETClients\\Primitives\\NETClientPrimitives\\NETClientPrimitives.cmd
    \r
    Expected: True\r
    Actual:   False

        Stack Trace:

        
Build : Master - 20180719.01 (Core Tests)
Failing configurations:
- Windows.10.Nano.Amd64-x64
  - 
- sles.12.amd64-x64
  - 
- opensuse.423.amd64-x64
  - 
- ubuntu.1804.amd64-x64
  - 
- ubuntu.1710.amd64-x64
  - 
- ubuntu.1604.amd64-x64
  - 
- ubuntu.1404.amd64-x64
  - 
- redhat.73.amd64-x64
  - 
- fedora.27.amd64-x64
  - 
- fedora.26.amd64-x64
  - 
- debian.82.amd64-x64
  - 
- osx.1013.amd64-x64
  - 
- osx.1012.amd64-x64
  - 

Details: https://mc.dot.net/#/product/netcore/master/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fcli~2F/build/20180719.01/workItem/Interop.COM.XUnitWrapper/analysis/xunit/Interop_COM._NETClients_Primitives_NETClientPrimitives_NETClientPrimitives_~2F_NETClients_Primitives_NETClientPrimitives_NETClientPrimitives_cmd</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19013</IssueLabelID>
    <Title>[ARM32] Handle MovRelocatableImmediate as a special case (IF_T2_N3)</Title>
    <Description>`IF_T2_N` instruction form now can be used in the three following cases:
1. *emitIns_R_I* mov =&gt; movw instruction conversion https://github.com/dotnet/coreclr/blob/47e106edc305c68651291d3862891ec6ad9f3ad6/src/jit/emitarm.cpp#L1845-L1851

2. *emitIns_R_I* for 16-bit immediates **or** relocatable immediates  https://github.com/dotnet/coreclr/blob/47e106edc305c68651291d3862891ec6ad9f3ad6/src/jit/emitarm.cpp#L1862-L1865

3. *emitIns_R_S* referencing a stack-based local variable
https://github.com/dotnet/coreclr/blob/47e106edc305c68651291d3862891ec6ad9f3ad6/src/jit/emitarm.cpp#L3516-L3519

The case 2 causes troubles for cross-bitness scenario (#16513) since we would have to use `ssize_t imm` almost everywhere in emitter and do explicit casting to `target_size_t` in many places as well. 

This PR introduces new `IF_T2_N3` instruction form which is used **only** for relocatable immediates. This also needs adding new instruction descriptor structure (`instrDescReloc` - the only one that can carry relocatable immediates in ARM32 emitter) and changing many places to be `target_ssize_t` instead of `ssize_t`

Running *jit-diff --pmi --altjit* and *jit-diff --crossgen x86_arm/crossgen.exe* shows no diffs for framework assemblies. 

Ubuntu arm pri1 and corefx tests have passed for these changes.
</Description>
    <Title_Description>[ARM32] Handle MovRelocatableImmediate as a special case (IF_T2_N3) `IF_T2_N` instruction form now can be used in the three following cases:
1. *emitIns_R_I* mov =&gt; movw instruction conversion https://github.com/dotnet/coreclr/blob/47e106edc305c68651291d3862891ec6ad9f3ad6/src/jit/emitarm.cpp#L1845-L1851

2. *emitIns_R_I* for 16-bit immediates **or** relocatable immediates  https://github.com/dotnet/coreclr/blob/47e106edc305c68651291d3862891ec6ad9f3ad6/src/jit/emitarm.cpp#L1862-L1865

3. *emitIns_R_S* referencing a stack-based local variable
https://github.com/dotnet/coreclr/blob/47e106edc305c68651291d3862891ec6ad9f3ad6/src/jit/emitarm.cpp#L3516-L3519

The case 2 causes troubles for cross-bitness scenario (#16513) since we would have to use `ssize_t imm` almost everywhere in emitter and do explicit casting to `target_size_t` in many places as well. 

This PR introduces new `IF_T2_N3` instruction form which is used **only** for relocatable immediates. This also needs adding new instruction descriptor structure (`instrDescReloc` - the only one that can carry relocatable immediates in ARM32 emitter) and changing many places to be `target_ssize_t` instead of `ssize_t`

Running *jit-diff --pmi --altjit* and *jit-diff --crossgen x86_arm/crossgen.exe* shows no diffs for framework assemblies. 

Ubuntu arm pri1 and corefx tests have passed for these changes.
</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>dotnet-bot</Assignee>
    <CreatedAt>19/07/2018 1:29:43 AM +00:00</CreatedAt>
    <ClosedAt>3/08/2018 7:35:34 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19011</IssueLabelID>
    <Title>Test failure in r2rdump test</Title>
    <Description>Test failure in x64 Checked Windows with `COMPlus_TailCallStress=1`.

I realize this is a new test. It may be it fails in more configurations or it may be that I got (un)lucky to see a failed job that happened to pick up the new test and that failed job was a particular JIT stress mode.

https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64/job/jitstress/job/x64_checked_windows_nt_tailcallstress/470/consoleFull

```
15:51:17   BEGIN EXECUTION
15:51:17         ..\..\..\..\..\..\tests\src\readytorun\r2rdump\files\Windows_NT.x64.Checked\GcInfoTransitions.xml
15:51:17         ..\..\..\..\..\..\tests\src\readytorun\r2rdump\files\Windows_NT.x64.Checked\GenericFunctions.xml
15:51:17         ..\..\..\..\..\..\tests\src\readytorun\r2rdump\files\Windows_NT.x64.Checked\HelloWorld.xml
15:51:17         ..\..\..\..\..\..\tests\src\readytorun\r2rdump\files\Windows_NT.x64.Checked\MultipleRuntimeFunctions.xml
15:51:17                 4 file(s) copied.
15:51:17         Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0
15:51:17         Copyright (c) Microsoft Corporation.  All rights reserved.
15:51:17         
15:51:17         Native image HelloWorld.ni.dll generated successfully.
15:51:17         Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0
15:51:17         Copyright (c) Microsoft Corporation.  All rights reserved.
15:51:17         
15:51:17         Native image GcInfoTransitions.ni.dll generated successfully.
15:51:17         Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0
15:51:17         Copyright (c) Microsoft Corporation.  All rights reserved.
15:51:17         
15:51:17         Native image GenericFunctions.ni.dll generated successfully.
15:51:17         Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0
15:51:17         Copyright (c) Microsoft Corporation.  All rights reserved.
15:51:17         
15:51:17         Native image MultipleRuntimeFunctions.ni.dll generated successfully.
15:51:17          "D:\j\workspace\x64_checked_w---c5ba3367\tests\..\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root\corerun.exe" R2RDumpTest.exe 
15:51:17         Starting the test
15:51:17         Expected:
15:51:17         	R2RDump.Sections.SectionREADYTORUN_SECTION_IMPORT_SECTIONS.Contents.R2RImportSection4120.Entries.ImportSectionEntry10262.SignatureSample.: FQQQAQICAn4=
15:51:17         Test:
15:51:17         	R2RDump.Sections.SectionREADYTORUN_SECTION_IMPORT_SECTIONS.Contents.R2RImportSection4120.Entries.ImportSectionEntry10262.SignatureSample.: FQQQAQICAmY=
15:51:17         
15:51:17         Expected:
15:51:17         	R2RDump.Sections.SectionREADYTORUN_SECTION_IMPORT_SECTIONS.Contents.ImportSectionEntry10262.SignatureSample.: FQQQAQICAn4=
15:51:17         Test:
15:51:17         	R2RDump.Sections.SectionREADYTORUN_SECTION_IMPORT_SECTIONS.Contents.ImportSectionEntry10262.SignatureSample.: FQQQAQICAmY=
15:51:17         
15:51:17         Expected:
15:51:17         	R2RDump.Sections.SectionREADYTORUN_SECTION_DEBUG_INFO.R2RSectionREADYTORUN_SECTION_DEBUG_INFO.Size.: 31
15:51:17         Test:
15:51:17         	R2RDump.Sections.SectionREADYTORUN_SECTION_DEBUG_INFO.R2RSectionREADYTORUN_SECTION_DEBUG_INFO.Size.: 26
15:51:17         
15:51:17         Expected:
15:51:17         	R2RDump.Sections.SectionREADYTORUN_SECTION_INLINING_INFO.R2RSectionREADYTORUN_SECTION_INLINING_INFO.RelativeVirtualAddress.: 10296
15:51:17         Test:
15:51:17         	R2RDump.Sections.SectionREADYTORUN_SECTION_INLINING_INFO.R2RSectionREADYTORUN_SECTION_INLINING_INFO.RelativeVirtualAddress.: 10292
15:51:17         
15:51:17         
15:51:17         
15:51:17         
15:51:17         
15:51:17         Expected: 100
15:51:17         Actual: -532462766
15:51:17         END EXECUTION - FAILED
15:51:17         FAILED
15:51:17         Test Harness Exitcode is : 1
15:51:17         
15:51:17   To run the test:
15:51:17   &gt; set CORE_ROOT=D:\j\workspace\x64_checked_w---c5ba3367\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root
15:51:17   &gt; D:\j\workspace\x64_checked_w---c5ba3367\bin\tests\Windows_NT.x64.Checked\readytorun\r2rdump\R2RDumpTest\R2RDumpTest.cmd
15:51:17   
15:51:17         Expected: True
15:51:17         Actual:   False
15:51:17           D:\j\workspace\x64_checked_w---c5ba3367\bin\tests\Windows_NT.x64.Checked\TestWrappers\readytorun.r2rdump\readytorun.r2rdump.XUnitWrapper.cs(1070): at readytorun_r2rdump._R2RDumpTest_R2RDumpTest_._R2RDumpTest_R2RDumpTest_cmd()
```
</Description>
    <Title_Description>Test failure in r2rdump test Test failure in x64 Checked Windows with `COMPlus_TailCallStress=1`.

I realize this is a new test. It may be it fails in more configurations or it may be that I got (un)lucky to see a failed job that happened to pick up the new test and that failed job was a particular JIT stress mode.

https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64/job/jitstress/job/x64_checked_windows_nt_tailcallstress/470/consoleFull

```
15:51:17   BEGIN EXECUTION
15:51:17         ..\..\..\..\..\..\tests\src\readytorun\r2rdump\files\Windows_NT.x64.Checked\GcInfoTransitions.xml
15:51:17         ..\..\..\..\..\..\tests\src\readytorun\r2rdump\files\Windows_NT.x64.Checked\GenericFunctions.xml
15:51:17         ..\..\..\..\..\..\tests\src\readytorun\r2rdump\files\Windows_NT.x64.Checked\HelloWorld.xml
15:51:17         ..\..\..\..\..\..\tests\src\readytorun\r2rdump\files\Windows_NT.x64.Checked\MultipleRuntimeFunctions.xml
15:51:17                 4 file(s) copied.
15:51:17         Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0
15:51:17         Copyright (c) Microsoft Corporation.  All rights reserved.
15:51:17         
15:51:17         Native image HelloWorld.ni.dll generated successfully.
15:51:17         Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0
15:51:17         Copyright (c) Microsoft Corporation.  All rights reserved.
15:51:17         
15:51:17         Native image GcInfoTransitions.ni.dll generated successfully.
15:51:17         Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0
15:51:17         Copyright (c) Microsoft Corporation.  All rights reserved.
15:51:17         
15:51:17         Native image GenericFunctions.ni.dll generated successfully.
15:51:17         Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0
15:51:17         Copyright (c) Microsoft Corporation.  All rights reserved.
15:51:17         
15:51:17         Native image MultipleRuntimeFunctions.ni.dll generated successfully.
15:51:17          "D:\j\workspace\x64_checked_w---c5ba3367\tests\..\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root\corerun.exe" R2RDumpTest.exe 
15:51:17         Starting the test
15:51:17         Expected:
15:51:17         	R2RDump.Sections.SectionREADYTORUN_SECTION_IMPORT_SECTIONS.Contents.R2RImportSection4120.Entries.ImportSectionEntry10262.SignatureSample.: FQQQAQICAn4=
15:51:17         Test:
15:51:17         	R2RDump.Sections.SectionREADYTORUN_SECTION_IMPORT_SECTIONS.Contents.R2RImportSection4120.Entries.ImportSectionEntry10262.SignatureSample.: FQQQAQICAmY=
15:51:17         
15:51:17         Expected:
15:51:17         	R2RDump.Sections.SectionREADYTORUN_SECTION_IMPORT_SECTIONS.Contents.ImportSectionEntry10262.SignatureSample.: FQQQAQICAn4=
15:51:17         Test:
15:51:17         	R2RDump.Sections.SectionREADYTORUN_SECTION_IMPORT_SECTIONS.Contents.ImportSectionEntry10262.SignatureSample.: FQQQAQICAmY=
15:51:17         
15:51:17         Expected:
15:51:17         	R2RDump.Sections.SectionREADYTORUN_SECTION_DEBUG_INFO.R2RSectionREADYTORUN_SECTION_DEBUG_INFO.Size.: 31
15:51:17         Test:
15:51:17         	R2RDump.Sections.SectionREADYTORUN_SECTION_DEBUG_INFO.R2RSectionREADYTORUN_SECTION_DEBUG_INFO.Size.: 26
15:51:17         
15:51:17         Expected:
15:51:17         	R2RDump.Sections.SectionREADYTORUN_SECTION_INLINING_INFO.R2RSectionREADYTORUN_SECTION_INLINING_INFO.RelativeVirtualAddress.: 10296
15:51:17         Test:
15:51:17         	R2RDump.Sections.SectionREADYTORUN_SECTION_INLINING_INFO.R2RSectionREADYTORUN_SECTION_INLINING_INFO.RelativeVirtualAddress.: 10292
15:51:17         
15:51:17         
15:51:17         
15:51:17         
15:51:17         
15:51:17         Expected: 100
15:51:17         Actual: -532462766
15:51:17         END EXECUTION - FAILED
15:51:17         FAILED
15:51:17         Test Harness Exitcode is : 1
15:51:17         
15:51:17   To run the test:
15:51:17   &gt; set CORE_ROOT=D:\j\workspace\x64_checked_w---c5ba3367\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root
15:51:17   &gt; D:\j\workspace\x64_checked_w---c5ba3367\bin\tests\Windows_NT.x64.Checked\readytorun\r2rdump\R2RDumpTest\R2RDumpTest.cmd
15:51:17   
15:51:17         Expected: True
15:51:17         Actual:   False
15:51:17           D:\j\workspace\x64_checked_w---c5ba3367\bin\tests\Windows_NT.x64.Checked\TestWrappers\readytorun.r2rdump\readytorun.r2rdump.XUnitWrapper.cs(1070): at readytorun_r2rdump._R2RDumpTest_R2RDumpTest_._R2RDumpTest_R2RDumpTest_cmd()
```
</Title_Description>
    <Label>arch-x64</Label>
    <Assignee>acmyu</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19010</IssueLabelID>
    <Title>Script warning in init-tools.sh</Title>
    <Description>```
Running init-tools.sh
Tools are already initialized
/mnt/j/workspace/dotnet_coreclr/master/checked_ubuntu_tst/tests/../init-tools.sh: line 20: return: can only `return' from a function or sourced script
```

This corresponds to this code in the root of the repo in init-tools.sh:
```
if [ -e "$__BUILD_TOOLS_SEMAPHORE" ]; then
    echo "Tools are already initialized"
    return #return instead of exit because this script is inlined in other scripts which we don't want to exit
fi
```

It appears there are some places that invoke init-tools.sh via "source" and some invoke it directly:
```
tests\setup-stress-dependencies.sh:$scriptDir/../init-tools.sh
build.sh:            source "$__ProjectRoot/init-tools.sh"
run.sh:source $working_tree_root/init-tools.sh
```

Perhaps setup-stress-dependencies.sh should also invoke it using "source"?</Description>
    <Title_Description>Script warning in init-tools.sh ```
Running init-tools.sh
Tools are already initialized
/mnt/j/workspace/dotnet_coreclr/master/checked_ubuntu_tst/tests/../init-tools.sh: line 20: return: can only `return' from a function or sourced script
```

This corresponds to this code in the root of the repo in init-tools.sh:
```
if [ -e "$__BUILD_TOOLS_SEMAPHORE" ]; then
    echo "Tools are already initialized"
    return #return instead of exit because this script is inlined in other scripts which we don't want to exit
fi
```

It appears there are some places that invoke init-tools.sh via "source" and some invoke it directly:
```
tests\setup-stress-dependencies.sh:$scriptDir/../init-tools.sh
build.sh:            source "$__ProjectRoot/init-tools.sh"
run.sh:source $working_tree_root/init-tools.sh
```

Perhaps setup-stress-dependencies.sh should also invoke it using "source"?</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>19/07/2018 12:40:39 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19009</IssueLabelID>
    <Title>Syntax error in build-test.sh script</Title>
    <Description>```
+ ./build-test.sh x64 Checked generatelayoutonly
Setting __HostDistroRid to linux-x64
./build-test.sh: line 763: [: too many arguments
./build-test.sh: line 763: [: /mnt/j/workspace/dotnet_coreclr/master/checked_ubuntu_tst/bin/Product/Linux.x64.Checked/bin: binary operator expected
__DistroRid:  linux-x64
```

E.g. in a CI job: https://ci.dot.net/job/dotnet_coreclr/job/master/job/checked_ubuntu_tst/4929/consoleText

This corresponds to the first "if" line in this code:
```
if [ [ ! -d "$__BinDir" ] || [ ! -d "$__BinDir/bin" ] ]; then
    if [ [ -z "$__GenerateLayoutOnly" ] &amp;&amp; [ -z "$__GenerateTestHostOnly" ] ]; then

        echo "Cannot find build directory for the CoreCLR native tests."
        echo "Please make sure native tests are built before building managed tests."
        echo "Example use: './build.sh $__BuildArch $__BuildType' without -skiptests switch"
    else
        echo "Cannot find build directory for the CoreCLR Product."
        echo "Please make sure CoreCLR and native tests are built before building managed tests."
        echo "Example use: './build.sh $__BuildArch $__BuildType' "
        fi
    exit 1
fi
```</Description>
    <Title_Description>Syntax error in build-test.sh script ```
+ ./build-test.sh x64 Checked generatelayoutonly
Setting __HostDistroRid to linux-x64
./build-test.sh: line 763: [: too many arguments
./build-test.sh: line 763: [: /mnt/j/workspace/dotnet_coreclr/master/checked_ubuntu_tst/bin/Product/Linux.x64.Checked/bin: binary operator expected
__DistroRid:  linux-x64
```

E.g. in a CI job: https://ci.dot.net/job/dotnet_coreclr/job/master/job/checked_ubuntu_tst/4929/consoleText

This corresponds to the first "if" line in this code:
```
if [ [ ! -d "$__BinDir" ] || [ ! -d "$__BinDir/bin" ] ]; then
    if [ [ -z "$__GenerateLayoutOnly" ] &amp;&amp; [ -z "$__GenerateTestHostOnly" ] ]; then

        echo "Cannot find build directory for the CoreCLR native tests."
        echo "Please make sure native tests are built before building managed tests."
        echo "Example use: './build.sh $__BuildArch $__BuildType' without -skiptests switch"
    else
        echo "Cannot find build directory for the CoreCLR Product."
        echo "Please make sure CoreCLR and native tests are built before building managed tests."
        echo "Example use: './build.sh $__BuildArch $__BuildType' "
        fi
    exit 1
fi
```</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>19/07/2018 12:25:03 AM +00:00</CreatedAt>
    <ClosedAt>21/03/2019 5:12:59 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19008</IssueLabelID>
    <Title>Many x64 checked Ubuntu GCStress=0xC test failures</Title>
    <Description>https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64/job/jitstress/job/x64_checked_ubuntu_gcstress0xc_flow/91/


```
FAILED   - CoreMangLib/cti/system/collections/generic/dictionary/DictionaryICollectionCopyTo/DictionaryICollectionCopyTo.sh
FAILED   - CoreMangLib/cti/system/collections/generic/dictionary/DictionaryICollectionCopyTo2/DictionaryICollectionCopyTo2.sh
FAILED   - CoreMangLib/cti/system/collections/generic/dictionaryenumerator/DictEnumIDictEnumget_Key/DictEnumIDictEnumget_Key.sh
FAILED   - JIT/HardwareIntrinsics/X86/Avx2/ConvertToVector256_r/ConvertToVector256_r.sh
FAILED   - JIT/HardwareIntrinsics/X86/Avx/ConvertToVector_r/ConvertToVector_r.sh
FAILED   - JIT/HardwareIntrinsics/X86/Avx2/Avx2_ro/Avx2_ro.sh
FAILED   - JIT/HardwareIntrinsics/X86/Avx/Avx_ro/Avx_ro.sh
FAILED   - JIT/HardwareIntrinsics/X86/Avx/Permute2x128.Avx_r/Permute2x128.Avx_r.sh
FAILED   - JIT/HardwareIntrinsics/X86/Bmi1/Bmi1_r/Bmi1_r.sh
FAILED   - JIT/HardwareIntrinsics/X86/Fma_Vector256/Fma_r/Fma_r.sh
FAILED   - JIT/HardwareIntrinsics/X86/Fma_Vector128/Fma_r/Fma_r.sh
FAILED   - JIT/HardwareIntrinsics/X86/Sse2/Sse2_ro/Sse2_ro.sh
FAILED   - JIT/HardwareIntrinsics/X86/Sse41/ConvertToVector128_r/ConvertToVector128_r.sh
FAILED   - JIT/HardwareIntrinsics/X86/Sse41/Sse41_ro/Sse41_ro.sh
FAILED   - JIT/HardwareIntrinsics/X86/Avx/Avx_r/Avx_r.sh
FAILED   - JIT/HardwareIntrinsics/X86/Ssse3/Ssse3_r/Ssse3_r.sh
FAILED   - JIT/HardwareIntrinsics/X86/Sse/Sse_r/Sse_r.sh
FAILED   - JIT/HardwareIntrinsics/X86/Avx2/Avx2_r/Avx2_r.sh
FAILED   - JIT/HardwareIntrinsics/X86/Sse2/Sse2_r/Sse2_r.sh
FAILED   - JIT/Methodical/ELEMENT_TYPE_IU/_il_dbgu_fld/_il_dbgu_fld.sh
FAILED   - JIT/Methodical/fp/exgen/1000w1d_cs_d/1000w1d_cs_d.sh
FAILED   - JIT/Methodical/fp/exgen/10w5d_cs_d/10w5d_cs_d.sh
FAILED   - JIT/Methodical/fp/exgen/10w5d_cs_r/10w5d_cs_r.sh
FAILED   - JIT/Methodical/fp/exgen/1000w1d_cs_r/1000w1d_cs_r.sh
FAILED   - JIT/Methodical/xxobj/ldobj/_il_relldobj_V/_il_relldobj_V.sh
FAILED   - JIT/Regression/JitBlue/DevDiv_461649/DevDiv_461649/DevDiv_461649.sh
FAILED   - tracing/runtimeeventsource/runtimeeventsource/runtimeeventsource.sh
```</Description>
    <Title_Description>Many x64 checked Ubuntu GCStress=0xC test failures https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64/job/jitstress/job/x64_checked_ubuntu_gcstress0xc_flow/91/


```
FAILED   - CoreMangLib/cti/system/collections/generic/dictionary/DictionaryICollectionCopyTo/DictionaryICollectionCopyTo.sh
FAILED   - CoreMangLib/cti/system/collections/generic/dictionary/DictionaryICollectionCopyTo2/DictionaryICollectionCopyTo2.sh
FAILED   - CoreMangLib/cti/system/collections/generic/dictionaryenumerator/DictEnumIDictEnumget_Key/DictEnumIDictEnumget_Key.sh
FAILED   - JIT/HardwareIntrinsics/X86/Avx2/ConvertToVector256_r/ConvertToVector256_r.sh
FAILED   - JIT/HardwareIntrinsics/X86/Avx/ConvertToVector_r/ConvertToVector_r.sh
FAILED   - JIT/HardwareIntrinsics/X86/Avx2/Avx2_ro/Avx2_ro.sh
FAILED   - JIT/HardwareIntrinsics/X86/Avx/Avx_ro/Avx_ro.sh
FAILED   - JIT/HardwareIntrinsics/X86/Avx/Permute2x128.Avx_r/Permute2x128.Avx_r.sh
FAILED   - JIT/HardwareIntrinsics/X86/Bmi1/Bmi1_r/Bmi1_r.sh
FAILED   - JIT/HardwareIntrinsics/X86/Fma_Vector256/Fma_r/Fma_r.sh
FAILED   - JIT/HardwareIntrinsics/X86/Fma_Vector128/Fma_r/Fma_r.sh
FAILED   - JIT/HardwareIntrinsics/X86/Sse2/Sse2_ro/Sse2_ro.sh
FAILED   - JIT/HardwareIntrinsics/X86/Sse41/ConvertToVector128_r/ConvertToVector128_r.sh
FAILED   - JIT/HardwareIntrinsics/X86/Sse41/Sse41_ro/Sse41_ro.sh
FAILED   - JIT/HardwareIntrinsics/X86/Avx/Avx_r/Avx_r.sh
FAILED   - JIT/HardwareIntrinsics/X86/Ssse3/Ssse3_r/Ssse3_r.sh
FAILED   - JIT/HardwareIntrinsics/X86/Sse/Sse_r/Sse_r.sh
FAILED   - JIT/HardwareIntrinsics/X86/Avx2/Avx2_r/Avx2_r.sh
FAILED   - JIT/HardwareIntrinsics/X86/Sse2/Sse2_r/Sse2_r.sh
FAILED   - JIT/Methodical/ELEMENT_TYPE_IU/_il_dbgu_fld/_il_dbgu_fld.sh
FAILED   - JIT/Methodical/fp/exgen/1000w1d_cs_d/1000w1d_cs_d.sh
FAILED   - JIT/Methodical/fp/exgen/10w5d_cs_d/10w5d_cs_d.sh
FAILED   - JIT/Methodical/fp/exgen/10w5d_cs_r/10w5d_cs_r.sh
FAILED   - JIT/Methodical/fp/exgen/1000w1d_cs_r/1000w1d_cs_r.sh
FAILED   - JIT/Methodical/xxobj/ldobj/_il_relldobj_V/_il_relldobj_V.sh
FAILED   - JIT/Regression/JitBlue/DevDiv_461649/DevDiv_461649/DevDiv_461649.sh
FAILED   - tracing/runtimeeventsource/runtimeeventsource/runtimeeventsource.sh
```</Title_Description>
    <Label>GCStress</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>19/07/2018 12:20:04 AM +00:00</CreatedAt>
    <ClosedAt>12/01/2019 12:59:41 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19007</IssueLabelID>
    <Title>Ubuntu IL linker test failures in CI</Title>
    <Description>This job is failing every test:

https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64/job/illink/job/x64_checked_ubuntu_illink_flow/

e.g.:
```
FAILED   - baseservices/compilerservices/dynamicobjectproperties/Dev10_535767/Dev10_535767.sh
               BEGIN EXECUTION
               Illink executable [/mnt/j/workspace/dotnet_coreclr/master/illink/x64_checked_ubuntu_illink_tst/linker/linker/bin/netcore_Release/netcoreapp2.0/ubuntu-x64/publish/illink] Invalid
```

Note that there is also a non-flow Ubuntu x64 IL linker test job:

https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64/job/illink/job/x64_checked_ubuntu_illink/

This one passes but it doesn't look like it's actually doing any interesting testing. I'm not sure this is a related issue or not. If not create a new issue to address removing one of them (if necessary).</Description>
    <Title_Description>Ubuntu IL linker test failures in CI This job is failing every test:

https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64/job/illink/job/x64_checked_ubuntu_illink_flow/

e.g.:
```
FAILED   - baseservices/compilerservices/dynamicobjectproperties/Dev10_535767/Dev10_535767.sh
               BEGIN EXECUTION
               Illink executable [/mnt/j/workspace/dotnet_coreclr/master/illink/x64_checked_ubuntu_illink_tst/linker/linker/bin/netcore_Release/netcoreapp2.0/ubuntu-x64/publish/illink] Invalid
```

Note that there is also a non-flow Ubuntu x64 IL linker test job:

https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64/job/illink/job/x64_checked_ubuntu_illink/

This one passes but it doesn't look like it's actually doing any interesting testing. I'm not sure this is a related issue or not. If not create a new issue to address removing one of them (if necessary).</Title_Description>
    <Label>arch-x64</Label>
    <Assignee>sbomer</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19005</IssueLabelID>
    <Title>Minor interop code changes</Title>
    <Description>
    </Description>
    <Title_Description>Minor interop code changes </Title_Description>
    <Label>area-Interop</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>18/07/2018 11:57:19 PM +00:00</CreatedAt>
    <ClosedAt>20/07/2018 7:48:07 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19003</IssueLabelID>
    <Title>x86 Ubuntu CI jobs are failing</Title>
    <Description>Namely

https://ci.dot.net/job/dotnet_coreclr/job/master/job/x86_debug_ubuntu_flow/
https://ci.dot.net/job/dotnet_coreclr/job/master/job/x86_checked_ubuntu_flow/
https://ci.dot.net/job/dotnet_coreclr/job/master/job/x86_release_ubuntu_flow/

There are several problems:
1. A missing "mkdir" leads to:
```
23:13:10 + tar -xf ./bin/CoreFxNative/bin/build.tar.gz -C ./bin/CoreFxBinDir
23:13:10 tar: bin/CoreFxBinDir: Cannot open: No such file or directory
```
2. It appears these jobs have (inadvertently?) been partially updated to the "new" way of running which uses "build-test.sh x86 Checked generatelayoutonly" to generate a Core_Root and download packages. But apparently there are no x86 Linux packages in the official build to pull down. Perhaps the "tst" job needs to revert to the previous method of invoking runtest.sh? Or we need to get the correct packages built and published?
</Description>
    <Title_Description>x86 Ubuntu CI jobs are failing Namely

https://ci.dot.net/job/dotnet_coreclr/job/master/job/x86_debug_ubuntu_flow/
https://ci.dot.net/job/dotnet_coreclr/job/master/job/x86_checked_ubuntu_flow/
https://ci.dot.net/job/dotnet_coreclr/job/master/job/x86_release_ubuntu_flow/

There are several problems:
1. A missing "mkdir" leads to:
```
23:13:10 + tar -xf ./bin/CoreFxNative/bin/build.tar.gz -C ./bin/CoreFxBinDir
23:13:10 tar: bin/CoreFxBinDir: Cannot open: No such file or directory
```
2. It appears these jobs have (inadvertently?) been partially updated to the "new" way of running which uses "build-test.sh x86 Checked generatelayoutonly" to generate a Core_Root and download packages. But apparently there are no x86 Linux packages in the official build to pull down. Perhaps the "tst" job needs to revert to the previous method of invoking runtest.sh? Or we need to get the correct packages built and published?
</Title_Description>
    <Label>arch-x86</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>18/07/2018 11:29:45 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19001</IssueLabelID>
    <Title>JIT.HardwareIntrinsics.X86.Avx.Avx_ro.Avx_ro failed in CI on macOS</Title>
    <Description>https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_checked_osx10.12_innerloop_tst_prtest/4234/
```
FAILED   - JIT/HardwareIntrinsics/X86/Avx/Avx_ro/Avx_ro.sh
               BEGIN EXECUTION
               /Users/dotnet-bot/j/workspace/dotnet_coreclr/master/x64_checked_osx10.12_innerloop_tst_prtest/bin/tests/OSX.x64.Checked/Tests/Core_Root/corerun Avx_ro.exe
               Running Add.Double test...
               Running Add.Single test...
               Running AddSubtract.Double test...
               Running AddSubtract.Single test...
               Running And.Double test...
               Running And.Single test...
               Running AndNot.Double test...
               Running AndNot.Single test...
               Running BlendVariable.Double test...
               Running BlendVariable.Single test...
               Running Ceiling.Double test...
               Running Ceiling.Single test...
               Running Divide.Double test...
               Running Divide.Single test...
               Running DuplicateEvenIndexed.Double test...
               Running DuplicateEvenIndexed.Single test...
               Running DuplicateOddIndexed.Single test...
               Running Extract.Byte.1 test...
               ./Avx_ro.sh: line 244: 94463 Abort trap: 6           (core dumped) $_DebuggerFullPath "$CORE_ROOT/corerun" $ExePath $CLRTestExecutionArguments
               Expected: 100
               Actual: 134
```</Description>
    <Title_Description>JIT.HardwareIntrinsics.X86.Avx.Avx_ro.Avx_ro failed in CI on macOS https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_checked_osx10.12_innerloop_tst_prtest/4234/
```
FAILED   - JIT/HardwareIntrinsics/X86/Avx/Avx_ro/Avx_ro.sh
               BEGIN EXECUTION
               /Users/dotnet-bot/j/workspace/dotnet_coreclr/master/x64_checked_osx10.12_innerloop_tst_prtest/bin/tests/OSX.x64.Checked/Tests/Core_Root/corerun Avx_ro.exe
               Running Add.Double test...
               Running Add.Single test...
               Running AddSubtract.Double test...
               Running AddSubtract.Single test...
               Running And.Double test...
               Running And.Single test...
               Running AndNot.Double test...
               Running AndNot.Single test...
               Running BlendVariable.Double test...
               Running BlendVariable.Single test...
               Running Ceiling.Double test...
               Running Ceiling.Single test...
               Running Divide.Double test...
               Running Divide.Single test...
               Running DuplicateEvenIndexed.Double test...
               Running DuplicateEvenIndexed.Single test...
               Running DuplicateOddIndexed.Single test...
               Running Extract.Byte.1 test...
               ./Avx_ro.sh: line 244: 94463 Abort trap: 6           (core dumped) $_DebuggerFullPath "$CORE_ROOT/corerun" $ExePath $CLRTestExecutionArguments
               Expected: 100
               Actual: 134
```</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>18/07/2018 9:18:55 PM +00:00</CreatedAt>
    <ClosedAt>6/12/2018 7:50:19 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19000</IssueLabelID>
    <Title>[x86/Windows] Failure in JIT\HardwareIntrinsics\X86\Sse2\MaskMove_r\MaskMove_r.cmd</Title>
    <Description>x86 Windows JitStress=2 JitStressRegs=3 failure

https://ci.dot.net/job/dotnet_coreclr/job/master/view/x86/job/jitstress/job/x86_checked_windows_nt_jitstress2_jitstressregs3/555/consoleText

```
  BEGIN EXECUTION
         "D:\j\workspace\x86_checked_w---508bfa85\tests\..\bin\tests\Windows_NT.x86.Checked\Tests\Core_Root\corerun.exe" MaskMove_r.exe 
        Expected: 100
        Actual: 85026320
        END EXECUTION - FAILED
        FAILED
        Test Harness Exitcode is : 1
        
  To run the test:
  &gt; set CORE_ROOT=D:\j\workspace\x86_checked_w---508bfa85\bin\tests\Windows_NT.x86.Checked\Tests\Core_Root
  &gt; D:\j\workspace\x86_checked_w---508bfa85\bin\tests\Windows_NT.x86.Checked\JIT\HardwareIntrinsics\X86\Sse2\MaskMove_r\MaskMove_r.cmd
  
        Expected: True
        Actual:   False
          D:\j\workspace\x86_checked_w---508bfa85\bin\tests\Windows_NT.x86.Checked\TestWrappers\JIT.HardwareIntrinsics\JIT.HardwareIntrinsics.XUnitWrapper.cs(147370): at JIT_HardwareIntrinsics._X86_Sse2_MaskMove_r_MaskMove_r_._X86_Sse2_MaskMove_r_MaskMove_r_cmd()
```

Same test failure previously: https://github.com/dotnet/coreclr/issues/17634
</Description>
    <Title_Description>[x86/Windows] Failure in JIT\HardwareIntrinsics\X86\Sse2\MaskMove_r\MaskMove_r.cmd x86 Windows JitStress=2 JitStressRegs=3 failure

https://ci.dot.net/job/dotnet_coreclr/job/master/view/x86/job/jitstress/job/x86_checked_windows_nt_jitstress2_jitstressregs3/555/consoleText

```
  BEGIN EXECUTION
         "D:\j\workspace\x86_checked_w---508bfa85\tests\..\bin\tests\Windows_NT.x86.Checked\Tests\Core_Root\corerun.exe" MaskMove_r.exe 
        Expected: 100
        Actual: 85026320
        END EXECUTION - FAILED
        FAILED
        Test Harness Exitcode is : 1
        
  To run the test:
  &gt; set CORE_ROOT=D:\j\workspace\x86_checked_w---508bfa85\bin\tests\Windows_NT.x86.Checked\Tests\Core_Root
  &gt; D:\j\workspace\x86_checked_w---508bfa85\bin\tests\Windows_NT.x86.Checked\JIT\HardwareIntrinsics\X86\Sse2\MaskMove_r\MaskMove_r.cmd
  
        Expected: True
        Actual:   False
          D:\j\workspace\x86_checked_w---508bfa85\bin\tests\Windows_NT.x86.Checked\TestWrappers\JIT.HardwareIntrinsics\JIT.HardwareIntrinsics.XUnitWrapper.cs(147370): at JIT_HardwareIntrinsics._X86_Sse2_MaskMove_r_MaskMove_r_._X86_Sse2_MaskMove_r_MaskMove_r_cmd()
```

Same test failure previously: https://github.com/dotnet/coreclr/issues/17634
</Title_Description>
    <Label>arch-x86</Label>
    <Assignee>4creators</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18997</IssueLabelID>
    <Title>GCStress test failure in JIT\HardwareIntrinsics\X86\Bmi1\Bmi1_r\Bmi1_r.cmd</Title>
    <Description>x86 Checked Windows GCStress=0xc failure

https://ci.dot.net/job/dotnet_coreclr/job/master/view/x86/job/jitstress/job/x86_checked_windows_nt_gcstress0xc/91/consoleText


```
D:\j\workspace\x86_checked_w---e5963ece\bin\tests\Windows_NT.x86.Checked\TestWrappers\JIT.HardwareIntrinsics\JIT.HardwareIntrinsics.XUnitWrapper.cs(6547): error : JIT_HardwareIntrinsics._X86_Bmi1_Bmi1_r_Bmi1_r_._X86_Bmi1_Bmi1_r_Bmi1_r_cmd [FAIL] [D:\j\workspace\x86_checked_w---e5963ece\tests\runtest.proj]
        
        Assert failure(PID 13384 [0x00003448] Thread: 12348 [0x303c]): !CREATE_CHECK_STRING(!"Detected use of a corrupted OBJECTREF. Possible GC hole.")
        
        CORECLR! Object::ValidateInner + 0x25F (0x72454def)
        CORECLR! Object::Validate + 0x15C (0x72454adc)
        CORECLR! Object::ValidatePromote + 0xB (0x72455148)
        CORECLR! WKS::GCHeap::Promote + 0x7A (0x72979b8a)
        CORECLR! GcEnumObject + 0x62 (0x728b6112)
        CORECLR! EECodeManager::EnumGcRefs + 0x572 (0x726dda32)
        CORECLR! GcStackCrawlCallBack + 0x169 (0x728b6379)
        CORECLR! Thread::MakeStackwalkerCallback + 0x45 (0x725373ef)
        CORECLR! Thread::StackWalkFramesEx + 0x177 (0x72538a92)
        CORECLR! Thread::StackWalkFrames + 0x15E (0x72538898)
            File: d:\j\workspace\x86_checked_w---e5963ece\src\vm\object.cpp Line: 806
            Image: D:\j\workspace\x86_checked_w---e5963ece\bin\tests\Windows_NT.x86.Checked\Tests\Core_Root\CoreRun.exe
        
        
  
  Return code:      1
  Raw output file:      D:\j\workspace\x86_checked_w---e5963ece\bin\tests\Windows_NT.x86.Checked\Reports\JIT.HardwareIntrinsics\X86\Bmi1\Bmi1_r\Bmi1_r.output.txt
  Raw output:
  BEGIN EXECUTION
         "D:\j\workspace\x86_checked_w---e5963ece\tests\..\bin\tests\Windows_NT.x86.Checked\Tests\Core_Root\corerun.exe" Bmi1_r.exe 
        Running AndNot.UInt32 test...
        Running AndNot.UInt64 test...
        Running ExtractLowestSetBit.UInt32 test...
        Expected: 100
        Actual: 123456789
        END EXECUTION - FAILED
        FAILED
        Test Harness Exitcode is : 1
        
  To run the test:
  &gt; set CORE_ROOT=D:\j\workspace\x86_checked_w---e5963ece\bin\tests\Windows_NT.x86.Checked\Tests\Core_Root
  &gt; D:\j\workspace\x86_checked_w---e5963ece\bin\tests\Windows_NT.x86.Checked\JIT\HardwareIntrinsics\X86\Bmi1\Bmi1_r\Bmi1_r.cmd
  
        Expected: True
        Actual:   False
          D:\j\workspace\x86_checked_w---e5963ece\bin\tests\Windows_NT.x86.Checked\TestWrappers\JIT.HardwareIntrinsics\JIT.HardwareIntrinsics.XUnitWrapper.cs(65470): at JIT_HardwareIntrinsics._X86_Bmi1_Bmi1_r_Bmi1_r_._X86_Bmi1_Bmi1_r_Bmi1_r_cmd()
```
</Description>
    <Title_Description>GCStress test failure in JIT\HardwareIntrinsics\X86\Bmi1\Bmi1_r\Bmi1_r.cmd x86 Checked Windows GCStress=0xc failure

https://ci.dot.net/job/dotnet_coreclr/job/master/view/x86/job/jitstress/job/x86_checked_windows_nt_gcstress0xc/91/consoleText


```
D:\j\workspace\x86_checked_w---e5963ece\bin\tests\Windows_NT.x86.Checked\TestWrappers\JIT.HardwareIntrinsics\JIT.HardwareIntrinsics.XUnitWrapper.cs(6547): error : JIT_HardwareIntrinsics._X86_Bmi1_Bmi1_r_Bmi1_r_._X86_Bmi1_Bmi1_r_Bmi1_r_cmd [FAIL] [D:\j\workspace\x86_checked_w---e5963ece\tests\runtest.proj]
        
        Assert failure(PID 13384 [0x00003448] Thread: 12348 [0x303c]): !CREATE_CHECK_STRING(!"Detected use of a corrupted OBJECTREF. Possible GC hole.")
        
        CORECLR! Object::ValidateInner + 0x25F (0x72454def)
        CORECLR! Object::Validate + 0x15C (0x72454adc)
        CORECLR! Object::ValidatePromote + 0xB (0x72455148)
        CORECLR! WKS::GCHeap::Promote + 0x7A (0x72979b8a)
        CORECLR! GcEnumObject + 0x62 (0x728b6112)
        CORECLR! EECodeManager::EnumGcRefs + 0x572 (0x726dda32)
        CORECLR! GcStackCrawlCallBack + 0x169 (0x728b6379)
        CORECLR! Thread::MakeStackwalkerCallback + 0x45 (0x725373ef)
        CORECLR! Thread::StackWalkFramesEx + 0x177 (0x72538a92)
        CORECLR! Thread::StackWalkFrames + 0x15E (0x72538898)
            File: d:\j\workspace\x86_checked_w---e5963ece\src\vm\object.cpp Line: 806
            Image: D:\j\workspace\x86_checked_w---e5963ece\bin\tests\Windows_NT.x86.Checked\Tests\Core_Root\CoreRun.exe
        
        
  
  Return code:      1
  Raw output file:      D:\j\workspace\x86_checked_w---e5963ece\bin\tests\Windows_NT.x86.Checked\Reports\JIT.HardwareIntrinsics\X86\Bmi1\Bmi1_r\Bmi1_r.output.txt
  Raw output:
  BEGIN EXECUTION
         "D:\j\workspace\x86_checked_w---e5963ece\tests\..\bin\tests\Windows_NT.x86.Checked\Tests\Core_Root\corerun.exe" Bmi1_r.exe 
        Running AndNot.UInt32 test...
        Running AndNot.UInt64 test...
        Running ExtractLowestSetBit.UInt32 test...
        Expected: 100
        Actual: 123456789
        END EXECUTION - FAILED
        FAILED
        Test Harness Exitcode is : 1
        
  To run the test:
  &gt; set CORE_ROOT=D:\j\workspace\x86_checked_w---e5963ece\bin\tests\Windows_NT.x86.Checked\Tests\Core_Root
  &gt; D:\j\workspace\x86_checked_w---e5963ece\bin\tests\Windows_NT.x86.Checked\JIT\HardwareIntrinsics\X86\Bmi1\Bmi1_r\Bmi1_r.cmd
  
        Expected: True
        Actual:   False
          D:\j\workspace\x86_checked_w---e5963ece\bin\tests\Windows_NT.x86.Checked\TestWrappers\JIT.HardwareIntrinsics\JIT.HardwareIntrinsics.XUnitWrapper.cs(65470): at JIT_HardwareIntrinsics._X86_Bmi1_Bmi1_r_Bmi1_r_._X86_Bmi1_Bmi1_r_Bmi1_r_cmd()
```
</Title_Description>
    <Label>GCStress</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>18/07/2018 8:30:07 PM +00:00</CreatedAt>
    <ClosedAt>27/07/2018 10:01:15 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18991</IssueLabelID>
    <Title>[arm64][R2R] Test failure: VectorDot_ro.cmd_9267</Title>
    <Description>In R2R tests with JitStress=1 or JitStress=2 there is a failure in:
```
Tests.lst=VectorDot_ro.cmd_9267   Smrt00000001  # JIT\SIMD\VectorDot_ro\VectorDot_ro.cmd  CATS: EXPECTED_PASS
```

https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm64/job/jitstress/job/arm64_cross_checked_windows_nt_r2r_jitstress1_tst/14/
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm64/job/jitstress/job/arm64_cross_checked_windows_nt_r2r_jitstress2_flow/15/

```
TEST_CMD_LINE: JIT\SIMD\VectorDot_ro&gt; C:\Users\robox\j\workspace\arm64_cross_c---9f0d91aa\bin\tests\Windows_NT.arm64.Checked\JIT\SIMD\VectorDot_ro\VectorDot_ro.cmd 

BEGIN EXECUTION
        1 file(s) copied.
" C:\Users\robox\j\workspace\arm64_cross_c---9f0d91aa\bin\tests\Windows_NT.arm64.Checked\Tests\Core_Root\crossgen.exe" /Platform_Assemblies_Paths C:\Users\robox\j\workspace\arm64_cross_c---9f0d91aa\bin\tests\Windows_NT.arm64.Checked\Tests\Core_Root;C:\Users\robox\j\workspace\arm64_cross_c---9f0d91aa\bin\tests\Windows_NT.arm64.Checked\JIT\SIMD\VectorDot_ro\IL;C:\Users\robox\j\workspace\arm64_cross_c---9f0d91aa\bin\tests\Windows_NT.arm64.Checked\JIT\SIMD\VectorDot_ro /in VectorDot_ro.org /out VectorDot_ro.exe
Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0
Copyright (c) Microsoft Corporation.  All rights reserved.

ReadyToRun: JIT helper not supported: CORINFO_HELP_CHECK_OBJ
ReadyToRun: JIT helper not supported: CORINFO_HELP_CHECK_OBJ
ReadyToRun: JIT helper not supported: CORINFO_HELP_CHECK_OBJ
Native image VectorDot_ro.exe generated successfully.
 "C:\Users\robox\j\workspace\arm64_cross_c---9f0d91aa\bin\tests\Windows_NT.arm64.Checked\Tests\Core_Root\corerun.exe" VectorDot_ro.exe 
Method System.Numerics.Vector`1[Single][System.Single]:Dot was compiled but should not have been
Method System.Numerics.Vector`1[Double][System.Double]:Dot was compiled but should not have been
Expected: 100
Actual: -1
END EXECUTION - FAILED
FAILED


TEXT_EXPECTED_RETURN_CODE = 0
TEXT_ACTUAL_RETURN_CODE = 1 (0x1)
```
</Description>
    <Title_Description>[arm64][R2R] Test failure: VectorDot_ro.cmd_9267 In R2R tests with JitStress=1 or JitStress=2 there is a failure in:
```
Tests.lst=VectorDot_ro.cmd_9267   Smrt00000001  # JIT\SIMD\VectorDot_ro\VectorDot_ro.cmd  CATS: EXPECTED_PASS
```

https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm64/job/jitstress/job/arm64_cross_checked_windows_nt_r2r_jitstress1_tst/14/
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm64/job/jitstress/job/arm64_cross_checked_windows_nt_r2r_jitstress2_flow/15/

```
TEST_CMD_LINE: JIT\SIMD\VectorDot_ro&gt; C:\Users\robox\j\workspace\arm64_cross_c---9f0d91aa\bin\tests\Windows_NT.arm64.Checked\JIT\SIMD\VectorDot_ro\VectorDot_ro.cmd 

BEGIN EXECUTION
        1 file(s) copied.
" C:\Users\robox\j\workspace\arm64_cross_c---9f0d91aa\bin\tests\Windows_NT.arm64.Checked\Tests\Core_Root\crossgen.exe" /Platform_Assemblies_Paths C:\Users\robox\j\workspace\arm64_cross_c---9f0d91aa\bin\tests\Windows_NT.arm64.Checked\Tests\Core_Root;C:\Users\robox\j\workspace\arm64_cross_c---9f0d91aa\bin\tests\Windows_NT.arm64.Checked\JIT\SIMD\VectorDot_ro\IL;C:\Users\robox\j\workspace\arm64_cross_c---9f0d91aa\bin\tests\Windows_NT.arm64.Checked\JIT\SIMD\VectorDot_ro /in VectorDot_ro.org /out VectorDot_ro.exe
Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0
Copyright (c) Microsoft Corporation.  All rights reserved.

ReadyToRun: JIT helper not supported: CORINFO_HELP_CHECK_OBJ
ReadyToRun: JIT helper not supported: CORINFO_HELP_CHECK_OBJ
ReadyToRun: JIT helper not supported: CORINFO_HELP_CHECK_OBJ
Native image VectorDot_ro.exe generated successfully.
 "C:\Users\robox\j\workspace\arm64_cross_c---9f0d91aa\bin\tests\Windows_NT.arm64.Checked\Tests\Core_Root\corerun.exe" VectorDot_ro.exe 
Method System.Numerics.Vector`1[Single][System.Single]:Dot was compiled but should not have been
Method System.Numerics.Vector`1[Double][System.Double]:Dot was compiled but should not have been
Expected: 100
Actual: -1
END EXECUTION - FAILED
FAILED


TEXT_EXPECTED_RETURN_CODE = 0
TEXT_ACTUAL_RETURN_CODE = 1 (0x1)
```
</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>AndyAyersMS</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18989</IssueLabelID>
    <Title>[arm64] Assertion failed '(sizeDif == 4) || (sizeDif == 8)' in 'floatMDArrTest:Main():int'</Title>
    <Description>Failure in
```
Tests.lst=float_cs_ro.cmd_7350   Smrt00000001  # JIT\Methodical\MDArray\DataTypes\float_cs_ro\float_cs_ro.cmd  CATS: JIT;EXPECTED_PASS;Pri1
```

with:
```
COMPlus_JitStress -&gt; 2
COMPlus_JitStressRegs -&gt; 4
COMPlus_TieredCompilation -&gt; 0
```

https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm64/job/jitstress/job/arm64_cross_checked_windows_nt_jitstress2_jitstressregs4_tst/32/

```
TEST_CMD_LINE: JIT\Methodical\MDArray\DataTypes\float_cs_ro&gt; C:\Users\robox\j\workspace\arm64_cross_c---0ae079d7\bin\tests\Windows_NT.arm64.Checked\JIT\Methodical\MDArray\DataTypes\float_cs_ro\float_cs_ro.cmd 

BEGIN EXECUTION
 "C:\Users\robox\j\workspace\arm64_cross_c---0ae079d7\bin\tests\Windows_NT.arm64.Checked\Tests\Core_Root\corerun.exe" float_cs_ro.exe 

Assert failure(PID 24364 [0x00005f2c] Thread: 18392 [0x47d8]): Assertion failed '(sizeDif == 4) || (sizeDif == 8)' in 'floatMDArrTest:Main():int' (IL size 9417)

    File: d:\j\workspace\arm64_cross_c---0aaef436\src\jit\emit.cpp Line: 4033
    Image: C:\Users\robox\j\workspace\arm64_cross_c---0ae079d7\bin\tests\Windows_NT.arm64.Checked\Tests\Core_Root\CoreRun.exe

Expected: 100
Actual: 123456789
END EXECUTION - FAILED
FAILED
```
</Description>
    <Title_Description>[arm64] Assertion failed '(sizeDif == 4) || (sizeDif == 8)' in 'floatMDArrTest:Main():int' Failure in
```
Tests.lst=float_cs_ro.cmd_7350   Smrt00000001  # JIT\Methodical\MDArray\DataTypes\float_cs_ro\float_cs_ro.cmd  CATS: JIT;EXPECTED_PASS;Pri1
```

with:
```
COMPlus_JitStress -&gt; 2
COMPlus_JitStressRegs -&gt; 4
COMPlus_TieredCompilation -&gt; 0
```

https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm64/job/jitstress/job/arm64_cross_checked_windows_nt_jitstress2_jitstressregs4_tst/32/

```
TEST_CMD_LINE: JIT\Methodical\MDArray\DataTypes\float_cs_ro&gt; C:\Users\robox\j\workspace\arm64_cross_c---0ae079d7\bin\tests\Windows_NT.arm64.Checked\JIT\Methodical\MDArray\DataTypes\float_cs_ro\float_cs_ro.cmd 

BEGIN EXECUTION
 "C:\Users\robox\j\workspace\arm64_cross_c---0ae079d7\bin\tests\Windows_NT.arm64.Checked\Tests\Core_Root\corerun.exe" float_cs_ro.exe 

Assert failure(PID 24364 [0x00005f2c] Thread: 18392 [0x47d8]): Assertion failed '(sizeDif == 4) || (sizeDif == 8)' in 'floatMDArrTest:Main():int' (IL size 9417)

    File: d:\j\workspace\arm64_cross_c---0aaef436\src\jit\emit.cpp Line: 4033
    Image: C:\Users\robox\j\workspace\arm64_cross_c---0ae079d7\bin\tests\Windows_NT.arm64.Checked\Tests\Core_Root\CoreRun.exe

Expected: 100
Actual: 123456789
END EXECUTION - FAILED
FAILED
```
</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>briansull</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18988</IssueLabelID>
    <Title>[Windows/arm32] Test failure: 10w5d_cs_do.cmd </Title>
    <Description>With JitStress=1

https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_jitstress1_tst/33/

```
TEST_CMD_LINE: JIT\Methodical\fp\exgen\10w5d_cs_do&gt; C:\Users\robox\j\workspace\arm_cross_che---9b14f1d9\bin\tests\Windows_NT.arm.Checked\JIT\Methodical\fp\exgen\10w5d_cs_do\10w5d_cs_do.cmd 

BEGIN EXECUTION
 "C:\Users\robox\j\workspace\arm_cross_che---9b14f1d9\bin\tests\Windows_NT.arm.Checked\Tests\Core_Root\corerun.exe" 10w5d_cs_do.exe 
Func_0_6_5_6_3: != true
Func_0_6_5_4_6: &lt;= true
Func_0_6_5_4_5: &gt; true
Func_0_6_5_4_3: == false
Func_0_6_4_6_2: != true
Func_0_6_4_5_4: &lt; true
Func_0_6_4_5_1: &lt; true
Func_0_6_4_4: &lt;= true
Func_0_6_3_6_5: == false
Func_0_6_3_4_4: &lt;= true
Func_0_6_3_4_3: &lt; true
Func_0_6_3_3: &lt; true
Func_0_6_3_2_3: &gt;= true
Func_0_6_3_1_5: &lt; true
Func_0_6_3_1: &lt;= false
Func_0_6_3: != true
Func_0_6_2_5: != true
Func_0_6_2_1: &gt; false
Func_0_6_1_6_4: &lt; false
Func_0_6_1_6_3: &gt; false
Func_0_6_1_5_4: &gt; true
Func_0_6_1_3: == false
Func_0_5_6_6_6: &lt;= true
Func_0_5_6_6_1: &gt; true
Func_0_5_6_4_6: &lt;= false
Func_0_5_6_4_2: &gt;= false
Func_0_5_6_3_6: &lt; false
Func_0_5_6_3_1: == false
Func_0_5_6_3: &lt;= true
Func_0_5_6_2_1: &gt;= false
Func_0_5_6_1_3: &gt; true
Func_0_5_6_1: &lt;= false
Func_0_5_5_6: != true
Func_0_5_5_5_6: != true
Func_0_5_5_5_4: == false
Func_0_5_5_5_2: == false
Func_0_5_5_4_5: &lt; true
Func_0_5_5_4: &gt; true
Func_0_5_5_3_4: != true
Func_0_5_5_3_2: &lt;= true
Func_0_5_5_3_1: &gt; true
Func_0_5_5_1: &lt; false
Func_0_5_4_5: &gt;= false
Func_0_5_4_1_3: &lt;= false
Func_0_5_4_1_2: == false
Func_0_5_4: != true
Func_0_5_3_6: != true
Func_0_5_3_5_3: &lt; true
Func_0_5_3_4_2: == false
Func_0_5_3_4_1: &gt;= true
Func_0_5_3_4: &lt;= true
Func_0_5_3_1_2: &lt; true
Func_0_5_3: &gt;= false
Func_0_5_2_6_6: != true
Func_0_5_2_6_3: != true
Func_0_5_2_5_6: != true
Func_0_5_2_5_4: == false
Func_0_5_2_5_3: &lt;= true
Func_0_5_2_5_2: != true
Func_0_5_2_4_5: &gt; false
Func_0_5_2_4_2: &lt;= true
Func_0_5_2_2_5: &gt; true
Func_0_5_2_1_6: &gt; false
Func_0_5_2_1_1: != true
Func_0_5_1: != true
Func_0_4_6_6_5: &lt;= true
Func_0_4_6_6: == false
Func_0_4_6_5_6: &lt;= true
Func_0_4_6_5_5: != true
Func_0_4_6_5_2: &lt;= true
Func_0_4_6_5: == false
Func_0_4_6_3_6: &gt;= true
Func_0_4_6_3_3: == false
Func_0_4_6_3_2: &lt;= false
Func_0_4_6_2: == false
Func_0_4_5_6: &gt;= false
Func_0_4_5_5: &lt; true
Func_0_4_5_3_5: == false
Func_0_4_5_2_6: &gt; false
Func_0_4_5_2_4: &gt;= true
Func_0_4_5_2_1: &lt;= false
Func_0_4_5_2: &gt;= true
Func_0_4_5_1_5: == false
Func_0_4_5_1_2: &gt; true
Func_0_4_4_5: != true
Func_0_4_4_2_6: &lt; true
Func_0_4_4_2_5: != false
Func_0_4_4_2_3: &lt;= true
Func_0_4_4_2: == false
Func_0_4_4_1_4: &gt;= false
Func_0_4_3_6_6: &lt;= true
Func_0_4_3_6_5: &lt;= true
Func_0_4_3_6_2: &gt;= true
Func_0_4_3_6_1: == true
Func_0_4_3_4: &gt;= true
Func_0_4_3_2_2: == false
Func_0_4_3_1_3: &gt; true
Func_0_4_3_1_1: != true
Func_0_4_2_5_4: &lt;= true
Func_0_4_2_5_1: != true
Func_0_4_1_4: &gt;= true
Func_0_4_1_3_1: &gt;= true
Func_0_4_1_2_3: &lt; false
Func_0_4_1_1_1: &gt;= true
Func_0_3_6_6_5: &gt;= true
Func_0_3_6_6_1: &lt; true
Func_0_3_6_5_5: &gt; false
Func_0_3_6_4_1: &lt; false
Func_0_3_6_3_4: != true
Func_0_3_5_6_6: == true
Func_0_3_5_6_5: &lt;= true
Func_0_3_5_6_2: != true
Func_0_3_5_4: == false
Func_0_3_5_3: &gt; false
Func_0_3_5_2_6: != true
Func_0_3_5_2_5: &lt;= true
Func_0_3_5_2_4: &gt; false
Func_0_3_5_2_2: == false
Func_0_3_5_1_1: != true
Func_0_3_4_1_1: &lt; true
Func_0_3_4_1: &lt; true
Func_0_3_3_6_4: &lt;= false
Func_0_3_3_6_1: &lt;= true
Func_0_3_3_5_6: != true
Func_0_3_3_5_1: != true
Func_0_3_3_4_6: &lt;= true
Func_0_3_3_4_5: &lt;= true
Func_0_3_3_4_2: &lt; true
Func_0_3_2_6_6: &lt;= true
Func_0_3_2_6_3: &gt;= false
Func_0_3_2_6_1: &gt;= true
Func_0_3_2_5_6: &lt; true
Func_0_3_2_5_3: &gt;= true
Func_0_3_2_5_1: &gt; true
Func_0_3_2_4_3: &gt; true
Func_0_3_2_3_3: &gt; true
Func_0_3_2_3_2: &lt;= false
Func_0_3_2_1_5: != true
Func_0_3_1_6_6: &gt; true
Func_0_3_1_6_4: &gt;= false
Func_0_3_1_4_4: &lt;= true
Func_0_3_1_4_3: == true
Func_0_3_1_4_2: == false
Func_0_3_1_4_1: &lt;= true
Func_0_3_1_3_5: == false
Func_0_3_1_3_4: &lt; true
Func_0_3_1_2_3: &lt; true
Func_0_2_6_6_4: != false
Func_0_2_6_6_3: &lt; true
Func_0_2_6_6_2: != true
Func_0_2_6_5_2: &gt; true
Func_0_2_6_4_5: != true
Func_0_2_6_3_1: &gt;= true
Func_0_2_6_1_3: &lt;= true
Func_0_2_6_1_2: == false
Func_0_2_5_6_6: == false
Func_0_2_5_6_1: &gt;= false
Func_0_2_5_5_2: &lt;= false
Func_0_2_5_5_1: != true
Func_0_2_5_4_3: &lt;= true
Func_0_2_5_4_1: &gt; true
Func_0_2_3_6_5: != true
Func_0_2_3_6_4: &lt;= true
Func_0_2_3_6_1: &gt;= false
Func_0_2_3_4_5: &lt; true
Func_0_2_3_4_3: &lt; false
Func_0_2_3_3_4: == false
Func_0_2_3_3_1: &lt; true
Func_0_2_3_2_4: &lt; true
Func_0_2_3_1_6: &lt;= true
Func_0_2_3_1_2: &lt;= false
Func_0_2_3_1_1: &gt;= true
Func_0_2_3_1: == true
Func_0_2_2_6: != true
Func_0_2_2_3_5: &gt; false
Func_0_2_2_3_3: != true
Func_0_2_2_3_1: &lt; true
Func_0_2_2_2: != true
Func_0_2_2_1_5: &gt; true
Func_0_2_2_1_3: &lt; true
Func_0_2_2_1_2: &gt; true
Func_0_2_2_1: &lt; true
Func_0_2_1_2_2: &gt;= true
Func_0_1_6_6_5: == false
Func_0_1_6_2_4: &lt; true
Func_0_1_6_2_2: &lt;= true
Func_0_1_6_1_6: != true
Func_0_1_6_1_3: &gt; false
Func_0_1_6_1_2: != true
Func_0_1_6: &gt;= true
Func_0_1_5_5_1: != true
Func_0_1_5_4_6: == false
Func_0_1_5_4_5: == false
Func_0_1_5_4_4: &lt; true
Func_0_1_5_4_1: == false
Func_0_1_5_3_3: == false
Func_0_1_4_2_3: &gt; true
Func_0_1_1_6_5: &gt; true
Func_0_1_1_6_3: &gt;= false
Func_0_1_1_6_2: != true
Func_0_1_1_6_1: &lt;= false
Func_0_1_1_5_2: != true
Func_0_1_1_2_6: &lt; true
Func_0_1_1_2_4: &gt; true
Func_0_1_1_2_3: == false
Func_0_1_1_2_1: &lt; false
Func_0_1_1_1_5: &gt;= true
Expected: 100
Actual: -532462766
END EXECUTION - FAILED
FAILED


TEXT_EXPECTED_RETURN_CODE = 0
TEXT_ACTUAL_RETURN_CODE = 1 (0x1)
```
</Description>
    <Title_Description>[Windows/arm32] Test failure: 10w5d_cs_do.cmd  With JitStress=1

https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_jitstress1_tst/33/

```
TEST_CMD_LINE: JIT\Methodical\fp\exgen\10w5d_cs_do&gt; C:\Users\robox\j\workspace\arm_cross_che---9b14f1d9\bin\tests\Windows_NT.arm.Checked\JIT\Methodical\fp\exgen\10w5d_cs_do\10w5d_cs_do.cmd 

BEGIN EXECUTION
 "C:\Users\robox\j\workspace\arm_cross_che---9b14f1d9\bin\tests\Windows_NT.arm.Checked\Tests\Core_Root\corerun.exe" 10w5d_cs_do.exe 
Func_0_6_5_6_3: != true
Func_0_6_5_4_6: &lt;= true
Func_0_6_5_4_5: &gt; true
Func_0_6_5_4_3: == false
Func_0_6_4_6_2: != true
Func_0_6_4_5_4: &lt; true
Func_0_6_4_5_1: &lt; true
Func_0_6_4_4: &lt;= true
Func_0_6_3_6_5: == false
Func_0_6_3_4_4: &lt;= true
Func_0_6_3_4_3: &lt; true
Func_0_6_3_3: &lt; true
Func_0_6_3_2_3: &gt;= true
Func_0_6_3_1_5: &lt; true
Func_0_6_3_1: &lt;= false
Func_0_6_3: != true
Func_0_6_2_5: != true
Func_0_6_2_1: &gt; false
Func_0_6_1_6_4: &lt; false
Func_0_6_1_6_3: &gt; false
Func_0_6_1_5_4: &gt; true
Func_0_6_1_3: == false
Func_0_5_6_6_6: &lt;= true
Func_0_5_6_6_1: &gt; true
Func_0_5_6_4_6: &lt;= false
Func_0_5_6_4_2: &gt;= false
Func_0_5_6_3_6: &lt; false
Func_0_5_6_3_1: == false
Func_0_5_6_3: &lt;= true
Func_0_5_6_2_1: &gt;= false
Func_0_5_6_1_3: &gt; true
Func_0_5_6_1: &lt;= false
Func_0_5_5_6: != true
Func_0_5_5_5_6: != true
Func_0_5_5_5_4: == false
Func_0_5_5_5_2: == false
Func_0_5_5_4_5: &lt; true
Func_0_5_5_4: &gt; true
Func_0_5_5_3_4: != true
Func_0_5_5_3_2: &lt;= true
Func_0_5_5_3_1: &gt; true
Func_0_5_5_1: &lt; false
Func_0_5_4_5: &gt;= false
Func_0_5_4_1_3: &lt;= false
Func_0_5_4_1_2: == false
Func_0_5_4: != true
Func_0_5_3_6: != true
Func_0_5_3_5_3: &lt; true
Func_0_5_3_4_2: == false
Func_0_5_3_4_1: &gt;= true
Func_0_5_3_4: &lt;= true
Func_0_5_3_1_2: &lt; true
Func_0_5_3: &gt;= false
Func_0_5_2_6_6: != true
Func_0_5_2_6_3: != true
Func_0_5_2_5_6: != true
Func_0_5_2_5_4: == false
Func_0_5_2_5_3: &lt;= true
Func_0_5_2_5_2: != true
Func_0_5_2_4_5: &gt; false
Func_0_5_2_4_2: &lt;= true
Func_0_5_2_2_5: &gt; true
Func_0_5_2_1_6: &gt; false
Func_0_5_2_1_1: != true
Func_0_5_1: != true
Func_0_4_6_6_5: &lt;= true
Func_0_4_6_6: == false
Func_0_4_6_5_6: &lt;= true
Func_0_4_6_5_5: != true
Func_0_4_6_5_2: &lt;= true
Func_0_4_6_5: == false
Func_0_4_6_3_6: &gt;= true
Func_0_4_6_3_3: == false
Func_0_4_6_3_2: &lt;= false
Func_0_4_6_2: == false
Func_0_4_5_6: &gt;= false
Func_0_4_5_5: &lt; true
Func_0_4_5_3_5: == false
Func_0_4_5_2_6: &gt; false
Func_0_4_5_2_4: &gt;= true
Func_0_4_5_2_1: &lt;= false
Func_0_4_5_2: &gt;= true
Func_0_4_5_1_5: == false
Func_0_4_5_1_2: &gt; true
Func_0_4_4_5: != true
Func_0_4_4_2_6: &lt; true
Func_0_4_4_2_5: != false
Func_0_4_4_2_3: &lt;= true
Func_0_4_4_2: == false
Func_0_4_4_1_4: &gt;= false
Func_0_4_3_6_6: &lt;= true
Func_0_4_3_6_5: &lt;= true
Func_0_4_3_6_2: &gt;= true
Func_0_4_3_6_1: == true
Func_0_4_3_4: &gt;= true
Func_0_4_3_2_2: == false
Func_0_4_3_1_3: &gt; true
Func_0_4_3_1_1: != true
Func_0_4_2_5_4: &lt;= true
Func_0_4_2_5_1: != true
Func_0_4_1_4: &gt;= true
Func_0_4_1_3_1: &gt;= true
Func_0_4_1_2_3: &lt; false
Func_0_4_1_1_1: &gt;= true
Func_0_3_6_6_5: &gt;= true
Func_0_3_6_6_1: &lt; true
Func_0_3_6_5_5: &gt; false
Func_0_3_6_4_1: &lt; false
Func_0_3_6_3_4: != true
Func_0_3_5_6_6: == true
Func_0_3_5_6_5: &lt;= true
Func_0_3_5_6_2: != true
Func_0_3_5_4: == false
Func_0_3_5_3: &gt; false
Func_0_3_5_2_6: != true
Func_0_3_5_2_5: &lt;= true
Func_0_3_5_2_4: &gt; false
Func_0_3_5_2_2: == false
Func_0_3_5_1_1: != true
Func_0_3_4_1_1: &lt; true
Func_0_3_4_1: &lt; true
Func_0_3_3_6_4: &lt;= false
Func_0_3_3_6_1: &lt;= true
Func_0_3_3_5_6: != true
Func_0_3_3_5_1: != true
Func_0_3_3_4_6: &lt;= true
Func_0_3_3_4_5: &lt;= true
Func_0_3_3_4_2: &lt; true
Func_0_3_2_6_6: &lt;= true
Func_0_3_2_6_3: &gt;= false
Func_0_3_2_6_1: &gt;= true
Func_0_3_2_5_6: &lt; true
Func_0_3_2_5_3: &gt;= true
Func_0_3_2_5_1: &gt; true
Func_0_3_2_4_3: &gt; true
Func_0_3_2_3_3: &gt; true
Func_0_3_2_3_2: &lt;= false
Func_0_3_2_1_5: != true
Func_0_3_1_6_6: &gt; true
Func_0_3_1_6_4: &gt;= false
Func_0_3_1_4_4: &lt;= true
Func_0_3_1_4_3: == true
Func_0_3_1_4_2: == false
Func_0_3_1_4_1: &lt;= true
Func_0_3_1_3_5: == false
Func_0_3_1_3_4: &lt; true
Func_0_3_1_2_3: &lt; true
Func_0_2_6_6_4: != false
Func_0_2_6_6_3: &lt; true
Func_0_2_6_6_2: != true
Func_0_2_6_5_2: &gt; true
Func_0_2_6_4_5: != true
Func_0_2_6_3_1: &gt;= true
Func_0_2_6_1_3: &lt;= true
Func_0_2_6_1_2: == false
Func_0_2_5_6_6: == false
Func_0_2_5_6_1: &gt;= false
Func_0_2_5_5_2: &lt;= false
Func_0_2_5_5_1: != true
Func_0_2_5_4_3: &lt;= true
Func_0_2_5_4_1: &gt; true
Func_0_2_3_6_5: != true
Func_0_2_3_6_4: &lt;= true
Func_0_2_3_6_1: &gt;= false
Func_0_2_3_4_5: &lt; true
Func_0_2_3_4_3: &lt; false
Func_0_2_3_3_4: == false
Func_0_2_3_3_1: &lt; true
Func_0_2_3_2_4: &lt; true
Func_0_2_3_1_6: &lt;= true
Func_0_2_3_1_2: &lt;= false
Func_0_2_3_1_1: &gt;= true
Func_0_2_3_1: == true
Func_0_2_2_6: != true
Func_0_2_2_3_5: &gt; false
Func_0_2_2_3_3: != true
Func_0_2_2_3_1: &lt; true
Func_0_2_2_2: != true
Func_0_2_2_1_5: &gt; true
Func_0_2_2_1_3: &lt; true
Func_0_2_2_1_2: &gt; true
Func_0_2_2_1: &lt; true
Func_0_2_1_2_2: &gt;= true
Func_0_1_6_6_5: == false
Func_0_1_6_2_4: &lt; true
Func_0_1_6_2_2: &lt;= true
Func_0_1_6_1_6: != true
Func_0_1_6_1_3: &gt; false
Func_0_1_6_1_2: != true
Func_0_1_6: &gt;= true
Func_0_1_5_5_1: != true
Func_0_1_5_4_6: == false
Func_0_1_5_4_5: == false
Func_0_1_5_4_4: &lt; true
Func_0_1_5_4_1: == false
Func_0_1_5_3_3: == false
Func_0_1_4_2_3: &gt; true
Func_0_1_1_6_5: &gt; true
Func_0_1_1_6_3: &gt;= false
Func_0_1_1_6_2: != true
Func_0_1_1_6_1: &lt;= false
Func_0_1_1_5_2: != true
Func_0_1_1_2_6: &lt; true
Func_0_1_1_2_4: &gt; true
Func_0_1_1_2_3: == false
Func_0_1_1_2_1: &lt; false
Func_0_1_1_1_5: &gt;= true
Expected: 100
Actual: -532462766
END EXECUTION - FAILED
FAILED


TEXT_EXPECTED_RETURN_CODE = 0
TEXT_ACTUAL_RETURN_CODE = 1 (0x1)
```
</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>sandreenko</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18987</IssueLabelID>
    <Title>Infrastructure failure in ubuntu arm32 corefx Jenkins jobs</Title>
    <Description>It looks like all the ubuntu arm32 corefx jobs I kicked off yesterday passed all tests but failed at the end with what looks like an infrastructure failure e.g.:

```
[xUnit] [ERROR] - The plugin hasn't been performed correctly: remote file operation failed: /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstress2_tst at hudson.remoting.Channel@23dfcb56:JNLP4-connect connection from 131.107.58.90/131.107.58.90:42892: java.io.IOException: Remote call on JNLP4-connect connection from 131.107.58.90/131.107.58.90:42892 failed
Build step 'Publish xUnit test result report' changed build result to FAILURE
```

example jobs:

https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstress2_tst/17/consoleText
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstressregs2_tst/12/consoleText

Other (non-corefx) jobs I kicked off did not have this issue.

Ideas? Is there a reason it might be transient and I should just try again?

@mmitche 
cc @jashook @RussKeldorph </Description>
    <Title_Description>Infrastructure failure in ubuntu arm32 corefx Jenkins jobs It looks like all the ubuntu arm32 corefx jobs I kicked off yesterday passed all tests but failed at the end with what looks like an infrastructure failure e.g.:

```
[xUnit] [ERROR] - The plugin hasn't been performed correctly: remote file operation failed: /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstress2_tst at hudson.remoting.Channel@23dfcb56:JNLP4-connect connection from 131.107.58.90/131.107.58.90:42892: java.io.IOException: Remote call on JNLP4-connect connection from 131.107.58.90/131.107.58.90:42892 failed
Build step 'Publish xUnit test result report' changed build result to FAILURE
```

example jobs:

https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstress2_tst/17/consoleText
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstressregs2_tst/12/consoleText

Other (non-corefx) jobs I kicked off did not have this issue.

Ideas? Is there a reason it might be transient and I should just try again?

@mmitche 
cc @jashook @RussKeldorph </Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>mmitche</Assignee>
    <CreatedAt>18/07/2018 4:06:32 PM +00:00</CreatedAt>
    <ClosedAt>2/01/2019 7:44:12 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18986</IssueLabelID>
    <Title>Assertion failed 'rhs-&gt;OperGet() == GT_LONG'</Title>
    <Description>This is a recent regression.

Every Ubuntu arm32 JitStress=2 with JitStressRegs failed with:
```
FAILED   - JIT/Methodical/fp/exgen/10w250d_cs_ro/10w250d_cs_ro.sh
               BEGIN EXECUTION
               /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_jitstress2_jitstressregs1_tst/bin/tests/Linux.arm.Checked/Tests/Core_Root/corerun 10w250d_cs_ro.exe
               
               Assert failure(PID 23405 [0x00005b6d] Thread: 23405 [0x5b6d]): Assertion failed 'rhs-&gt;OperGet() == GT_LONG' in 'testout1:Func_0_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1():double' (IL size 788)
               
                   File: /mnt/j/workspace/dotnet_coreclr/master/arm_cross_checked_ubuntu/src/jit/decomposelongs.cpp Line: 433
                   Image: /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_jitstress2_jitstressregs1_tst/bin/tests/Linux.arm.Checked/Tests/Core_Root/corerun
               
               ./10w250d_cs_ro.sh: line 244: 23405 Aborted                 $_DebuggerFullPath "$CORE_ROOT/corerun" $ExePath $CLRTestExecutionArguments
               Expected: 100
               Actual: 134
               END EXECUTION - FAILED
...
FAILED   - JIT/Methodical/fp/exgen/10w5d_cs_ro/10w5d_cs_ro.sh
               BEGIN EXECUTION
               /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_jitstress2_jitstressregs1_tst/bin/tests/Linux.arm.Checked/Tests/Core_Root/corerun 10w5d_cs_ro.exe
               Func_0_6_5_6_3: != true
               Func_0_6_5_4_6: &lt;= true
               Func_0_6_5_4_5: &gt; true
               Func_0_6_5_4_3: == false
               Func_0_6_4_6_2: != true
               Func_0_6_4_5_4: &lt; true
               Func_0_6_4_5_1: &lt; true
               Func_0_6_4_4: &lt;= true
               Func_0_6_3_6_5: == false
               Func_0_6_3_4_4: &lt;= true
               Func_0_6_3_4_3: &lt; true
               Func_0_6_3_3: &lt; true
               Func_0_6_3_2_3: &gt;= true
               Func_0_6_3_1_5: &lt; true
               Func_0_6_3_1: &lt;= false
               Func_0_6_3: != true
               Func_0_6_2_5: != true
               Func_0_6_2_1: &gt; false
               Func_0_6_1_6_4: &lt; false
               Func_0_6_1_6_3: &gt; false
               Func_0_6_1_5_4: &gt; true
               
               Assert failure(PID 23525 [0x00005be5] Thread: 23525 [0x5be5]): Assertion failed 'rhs-&gt;OperGet() == GT_LONG' in 'testout1:Func_0_6_1_3_3():double' (IL size 157)
               
                   File: /mnt/j/workspace/dotnet_coreclr/master/arm_cross_checked_ubuntu/src/jit/decomposelongs.cpp Line: 433
                   Image: /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_jitstress2_jitstressregs1_tst/bin/tests/Linux.arm.Checked/Tests/Core_Root/corerun
               
               ./10w5d_cs_ro.sh: line 244: 23525 Aborted                 $_DebuggerFullPath "$CORE_ROOT/corerun" $ExePath $CLRTestExecutionArguments
               Expected: 100
               Actual: 134
               END EXECUTION - FAILED
```

e.g. https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_jitstress2_jitstressregs1_tst/15/consoleText.

There is currently no recent run without JitStressRegs to see if it fails with just JitStress=2 (https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_jitstress2_flow/)

@dotnet/arm32-contrib @dotnet/jit-contrib </Description>
    <Title_Description>Assertion failed 'rhs-&gt;OperGet() == GT_LONG' This is a recent regression.

Every Ubuntu arm32 JitStress=2 with JitStressRegs failed with:
```
FAILED   - JIT/Methodical/fp/exgen/10w250d_cs_ro/10w250d_cs_ro.sh
               BEGIN EXECUTION
               /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_jitstress2_jitstressregs1_tst/bin/tests/Linux.arm.Checked/Tests/Core_Root/corerun 10w250d_cs_ro.exe
               
               Assert failure(PID 23405 [0x00005b6d] Thread: 23405 [0x5b6d]): Assertion failed 'rhs-&gt;OperGet() == GT_LONG' in 'testout1:Func_0_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1():double' (IL size 788)
               
                   File: /mnt/j/workspace/dotnet_coreclr/master/arm_cross_checked_ubuntu/src/jit/decomposelongs.cpp Line: 433
                   Image: /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_jitstress2_jitstressregs1_tst/bin/tests/Linux.arm.Checked/Tests/Core_Root/corerun
               
               ./10w250d_cs_ro.sh: line 244: 23405 Aborted                 $_DebuggerFullPath "$CORE_ROOT/corerun" $ExePath $CLRTestExecutionArguments
               Expected: 100
               Actual: 134
               END EXECUTION - FAILED
...
FAILED   - JIT/Methodical/fp/exgen/10w5d_cs_ro/10w5d_cs_ro.sh
               BEGIN EXECUTION
               /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_jitstress2_jitstressregs1_tst/bin/tests/Linux.arm.Checked/Tests/Core_Root/corerun 10w5d_cs_ro.exe
               Func_0_6_5_6_3: != true
               Func_0_6_5_4_6: &lt;= true
               Func_0_6_5_4_5: &gt; true
               Func_0_6_5_4_3: == false
               Func_0_6_4_6_2: != true
               Func_0_6_4_5_4: &lt; true
               Func_0_6_4_5_1: &lt; true
               Func_0_6_4_4: &lt;= true
               Func_0_6_3_6_5: == false
               Func_0_6_3_4_4: &lt;= true
               Func_0_6_3_4_3: &lt; true
               Func_0_6_3_3: &lt; true
               Func_0_6_3_2_3: &gt;= true
               Func_0_6_3_1_5: &lt; true
               Func_0_6_3_1: &lt;= false
               Func_0_6_3: != true
               Func_0_6_2_5: != true
               Func_0_6_2_1: &gt; false
               Func_0_6_1_6_4: &lt; false
               Func_0_6_1_6_3: &gt; false
               Func_0_6_1_5_4: &gt; true
               
               Assert failure(PID 23525 [0x00005be5] Thread: 23525 [0x5be5]): Assertion failed 'rhs-&gt;OperGet() == GT_LONG' in 'testout1:Func_0_6_1_3_3():double' (IL size 157)
               
                   File: /mnt/j/workspace/dotnet_coreclr/master/arm_cross_checked_ubuntu/src/jit/decomposelongs.cpp Line: 433
                   Image: /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_jitstress2_jitstressregs1_tst/bin/tests/Linux.arm.Checked/Tests/Core_Root/corerun
               
               ./10w5d_cs_ro.sh: line 244: 23525 Aborted                 $_DebuggerFullPath "$CORE_ROOT/corerun" $ExePath $CLRTestExecutionArguments
               Expected: 100
               Actual: 134
               END EXECUTION - FAILED
```

e.g. https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_jitstress2_jitstressregs1_tst/15/consoleText.

There is currently no recent run without JitStressRegs to see if it fails with just JitStress=2 (https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_jitstress2_flow/)

@dotnet/arm32-contrib @dotnet/jit-contrib </Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>sandreenko</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18984</IssueLabelID>
    <Title>FriendAccessAllowedAttribute public?</Title>
    <Description>Would it be possible to make the System.Runtime.CompilerServices.FriendAccessAllowedAttribute public to be more explicit and clearly state intent of what exactly should be visible to a friend assembly?</Description>
    <Title_Description>FriendAccessAllowedAttribute public? Would it be possible to make the System.Runtime.CompilerServices.FriendAccessAllowedAttribute public to be more explicit and clearly state intent of what exactly should be visible to a friend assembly?</Title_Description>
    <Label>area-TypeSystem</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>18/07/2018 7:44:20 AM +00:00</CreatedAt>
    <ClosedAt>24/05/2019 4:37:55 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18977</IssueLabelID>
    <Title>ELT call stub issues on Linux</Title>
    <Description>Hi @noahfalk  - this is to continue the discussion from a closed issue prior.

I'm (slowly) porting our windows CLR profiler to linux. Everything was going spectacularly well until I tried to use the ICorProfilerInfo3::GetFunctionEnter3Info method. Calling this immediately results in a segmentation fault:
```
HRESULT hr;
COR_PRF_FRAME_INFO pFrameInfo;
ULONG pcbArgumentInfo = 0;
hr = profilerInfo-&gt;GetFunctionEnter3Info(functionId eltInfo &amp;pFrameInfo &amp;pcbArgumentInfo NULL);
```

I'm smart enough to know the issue is probably a bad pointer for eltInfo which of course is going to be the enter stub code. Let's pretend for a moment that I don't know or understand assembly or calling conventions enough to and that I only got my windows version working with the help of some really great samples that magically worked. 

Here's my setup of the ELT hooks:
```
hr = profilerInfo-&gt;SetEnterLeaveFunctionHooks3WithInfo((FunctionEnter3WithInfo*)MethodEntered3
		(FunctionLeave3WithInfo*)MethodLeft3 (FunctionTailcall3WithInfo*)MethodLeft3);
```

These are defined as:
```
extern "C" {
    void MethodEntered3(FunctionID function_id_or_client_id COR_PRF_ELT_INFO elt_info);
    void MethodLeft3(FunctionID function_id_or_client_id COR_PRF_ELT_INFO elt_info);
}

```

And finally the assembly behind all this which is pretty much a straight lift of `AsmHelpers.S` but with method names changed:

```
.intel_syntax noprefix
#include "unixasmmacrosamd64.inc"

#define real4 dword
#define real8 qword

.equ SIZEOF_PROFILE_PLATFORM_SPECIFIC_DATA 0x8*22 + 0x8   // includes fudge to make FP_SPILL right
.equ SIZEOF_FP_ARG_SPILL 0x10*2

.equ SIZEOF_STACK_FRAME SIZEOF_PROFILE_PLATFORM_SPECIFIC_DATA + SIZEOF_FP_ARG_SPILL

.equ PROFILE_ENTER 0x1
.equ PROFILE_LEAVE 0x2
.equ PROFILE_TAILCALL 0x4

// ***********************************************************
//   NOTE:
//
//   Register preservation scheme:
//
//       Preserved:
//           - all non-volatile registers
//           - rax rdx
//           - xmm0 xmm1
//
//       Not Preserved:
//           - integer argument registers (rcx rdx r8 r9)
//           - floating point argument registers (xmm1-3)
//           - volatile integer registers (r10 r11)
//           - volatile floating point registers (xmm4-5)
//           - upper halves of ymm registers on AVX (which are volatile)
//
// ***********************************************************

// EXTERN_C void MethodEntered3(FunctionIDOrClientID functionIDOrClientID size_t profiledRsp);
// &lt;NOTE&gt;
//
// &lt;/NOTE&gt;
NESTED_ENTRY MethodEntered3 _TEXT NoHandler
  //       Upon entry :
  //           r14 = clientInfo
  //           r15 = profiledRsp

  push_nonvol_reg         rax

  lea                     rax [rsp + 0x10]    // caller rsp
  mov                     r10 [rax - 0x8]     // return address

  push_argument_register  rdx
  alloc_stack             SIZEOF_STACK_FRAME

  // correctness of return value in structure doesn't matter for enter probe

  // setup ProfilePlatformSpecificData structure
  xor                     r11 r11 // nullify r11
  mov                     [rsp +  0x0] r11    // r11 is null     -- struct functionId field
  save_reg_postrsp        rbp 0x8             //                 -- struct rbp field
  mov                     [rsp + 0x10] rax    // caller rsp      -- struct probeRsp field
  mov                     [rsp + 0x18] r10    // return address  -- struct ip field
  mov                     [rsp + 0x20] r15    //                 -- struct profiledRsp field
  mov                     [rsp + 0x28] r11    // return value    -- struct rax field
  mov                     [rsp + 0x30] r11    // r11 is null     -- struct hiddenArg field
  movsd                   real8 ptr [rsp + 0x38] xmm0    //      -- struct flt0 field
  movsd                   real8 ptr [rsp + 0x40] xmm1    //      -- struct flt1 field
  movsd                   real8 ptr [rsp + 0x48] xmm2    //      -- struct flt2 field
  movsd                   real8 ptr [rsp + 0x50] xmm3    //      -- struct flt3 field
  movsd                   real8 ptr [rsp + 0x58] xmm4    //      -- struct flt4 field
  movsd                   real8 ptr [rsp + 0x60] xmm5    //      -- struct flt5 field
  movsd                   real8 ptr [rsp + 0x68] xmm6    //      -- struct flt6 field
  movsd                   real8 ptr [rsp + 0x70] xmm7    //      -- struct flt7 field
  mov                     [rsp + 0x78] rdi     //                -- struct rdi field
  mov                     [rsp + 0x80] rsi     //                -- struct rsi field
  mov                     [rsp + 0x88] rdx     //                -- struct rdx field
  mov                     [rsp + 0x90] rcx     //                -- struct rcx field
  mov                     [rsp + 0x98] r8      //                -- struct r8 field
  mov                     [rsp + 0xa0] r9      //                -- struct r9 field
  mov                     r10 0x1 // PROFILE_ENTER
  mov                     [rsp + 0xa8] r10d   //                -- struct flags field

  // get aligned stack ptr (rsp + FRAME_SIZE) &amp; (-16)
  lea                     rax [rsp + 0xb8]
  and                     rax -16

  // we need to be able to restore the fp return register
  // save fp return registers
  movdqa                  [rax + 0x00] xmm0
  movdqa                  [rax + 0x10] xmm1

  END_PROLOGUE

  // rdi already contains the clientInfo
  mov                     rdi r14
  lea                     rsi [rsp + 0x0]
  call                    C_PLTFUNC(EnterMethodStub)

  // restore fp return registers
  lea                     rax [rsp + 0xb8]
  and                     rax -16
  movdqa                  xmm0 [rax + 0x00]
  movdqa                  xmm1 [rax + 0x10]

  // restore arg registers
  mov                     rdi [rsp + 0x78]
  mov                     rsi [rsp + 0x80]
  mov                     rdx [rsp + 0x88]
  mov                     rcx [rsp + 0x90]
  mov                     r8 [rsp + 0x98]
  mov                     r9 [rsp + 0xa0]

  // begin epilogue
  free_stack              SIZEOF_STACK_FRAME
  pop_argument_register   rdx

  pop_nonvol_reg          rax

  ret
NESTED_END MethodEntered3 _TEXT

// EXTERN_C void MethodLeft3(FunctionIDOrClientID functionIDOrClientID size_t profiledRsp);
// &lt;NOTE&gt;
//
// &lt;/NOTE&gt;
NESTED_ENTRY MethodLeft3 _TEXT NoHandler
//       Upon entry :
//           rdi = clientInfo
//           rsi = profiledRsp

  push_nonvol_reg         rbx

  lea                     rbx [rsp + 0x10]    // caller rsp
  mov                     r10 [rbx - 0x8]     // return address

  // rdx should be saved here because it can be used for returning struct values
  push_argument_register  rdx
  alloc_stack             SIZEOF_STACK_FRAME

  // correctness of argument registers in structure doesn't matter for leave probe

  // setup ProfilePlatformSpecificData structure
  xor                     r11 r11  // nullify r11
  mov                     [rsp +  0x0] r11    // r11 is null     -- struct functionId field
  save_reg_postrsp        rbp 0x8             //                 -- struct rbp field
  mov                     [rsp + 0x10] rbx    // caller rsp      -- struct probeRsp field
  mov                     [rsp + 0x18] r10    // return address  -- struct ip field
  mov                     [rsp + 0x20] rsi    //                 -- struct profiledRsp field
  mov                     [rsp + 0x28] rax    // return value    -- struct rax field
  mov                     [rsp + 0x30] r11    // r11 is null     -- struct hiddenArg field
  movsd                   real8 ptr [rsp + 0x38] xmm0    //      -- struct flt0 field
  movsd                   real8 ptr [rsp + 0x40] xmm1    //      -- struct flt1 field
  movsd                   real8 ptr [rsp + 0x48] xmm2    //      -- struct flt2 field
  movsd                   real8 ptr [rsp + 0x50] xmm3    //      -- struct flt3 field
  movsd                   real8 ptr [rsp + 0x58] xmm4    //      -- struct flt4 field
  movsd                   real8 ptr [rsp + 0x60] xmm5    //      -- struct flt5 field
  movsd                   real8 ptr [rsp + 0x68] xmm6    //      -- struct flt6 field
  movsd                   real8 ptr [rsp + 0x70] xmm7    //      -- struct flt7 field
  mov                     [rsp + 0x78] r11     //                -- struct rdi field
  mov                     [rsp + 0x80] r11     //                -- struct rsi field
  mov                     [rsp + 0x88] r11     //                -- struct rdx field
  mov                     [rsp + 0x90] r11     //                -- struct rcx field
  mov                     [rsp + 0x98] r11     //                -- struct r8 field
  mov                     [rsp + 0xa0] r11    //                -- struct r9 field
  mov                     r10 0x2  // PROFILE_LEAVE
  mov                     [rsp + 0xa8] r10d   // flags           -- struct flags field

  // get aligned stack ptr (rsp + FRAME_SIZE) &amp; (-16)
  lea                     rax [rsp + 0xb8]
  and                     rax -16

  // we need to be able to restore the fp return register
  // save fp return registers
  movdqa                  [rax + 0x00] xmm0
  movdqa                  [rax + 0x10] xmm1

  END_PROLOGUE

  // rdi already contains the clientInfo
  lea                     rsi [rsp + 0x0]
  call                    C_PLTFUNC(LeaveMethodStub)

  // restore fp return registers
  lea                     rax [rsp + 0xb8]
  and                     rax -16
  movdqa                  xmm0 [rax + 0x00]
  movdqa                  xmm1 [rax + 0x10]

  // restore int return register
  mov                     rax [rsp + 0x28]

  // begin epilogue
  free_stack              SIZEOF_STACK_FRAME
  pop_argument_register   rdx

  pop_nonvol_reg          rbx

  ret
NESTED_END MethodLeft3 _TEXT
```

It seems to me like the frame isn't being set up right but I just have no idea where to begin. Help? Thanks in advance for any insight.



</Description>
    <Title_Description>ELT call stub issues on Linux Hi @noahfalk  - this is to continue the discussion from a closed issue prior.

I'm (slowly) porting our windows CLR profiler to linux. Everything was going spectacularly well until I tried to use the ICorProfilerInfo3::GetFunctionEnter3Info method. Calling this immediately results in a segmentation fault:
```
HRESULT hr;
COR_PRF_FRAME_INFO pFrameInfo;
ULONG pcbArgumentInfo = 0;
hr = profilerInfo-&gt;GetFunctionEnter3Info(functionId eltInfo &amp;pFrameInfo &amp;pcbArgumentInfo NULL);
```

I'm smart enough to know the issue is probably a bad pointer for eltInfo which of course is going to be the enter stub code. Let's pretend for a moment that I don't know or understand assembly or calling conventions enough to and that I only got my windows version working with the help of some really great samples that magically worked. 

Here's my setup of the ELT hooks:
```
hr = profilerInfo-&gt;SetEnterLeaveFunctionHooks3WithInfo((FunctionEnter3WithInfo*)MethodEntered3
		(FunctionLeave3WithInfo*)MethodLeft3 (FunctionTailcall3WithInfo*)MethodLeft3);
```

These are defined as:
```
extern "C" {
    void MethodEntered3(FunctionID function_id_or_client_id COR_PRF_ELT_INFO elt_info);
    void MethodLeft3(FunctionID function_id_or_client_id COR_PRF_ELT_INFO elt_info);
}

```

And finally the assembly behind all this which is pretty much a straight lift of `AsmHelpers.S` but with method names changed:

```
.intel_syntax noprefix
#include "unixasmmacrosamd64.inc"

#define real4 dword
#define real8 qword

.equ SIZEOF_PROFILE_PLATFORM_SPECIFIC_DATA 0x8*22 + 0x8   // includes fudge to make FP_SPILL right
.equ SIZEOF_FP_ARG_SPILL 0x10*2

.equ SIZEOF_STACK_FRAME SIZEOF_PROFILE_PLATFORM_SPECIFIC_DATA + SIZEOF_FP_ARG_SPILL

.equ PROFILE_ENTER 0x1
.equ PROFILE_LEAVE 0x2
.equ PROFILE_TAILCALL 0x4

// ***********************************************************
//   NOTE:
//
//   Register preservation scheme:
//
//       Preserved:
//           - all non-volatile registers
//           - rax rdx
//           - xmm0 xmm1
//
//       Not Preserved:
//           - integer argument registers (rcx rdx r8 r9)
//           - floating point argument registers (xmm1-3)
//           - volatile integer registers (r10 r11)
//           - volatile floating point registers (xmm4-5)
//           - upper halves of ymm registers on AVX (which are volatile)
//
// ***********************************************************

// EXTERN_C void MethodEntered3(FunctionIDOrClientID functionIDOrClientID size_t profiledRsp);
// &lt;NOTE&gt;
//
// &lt;/NOTE&gt;
NESTED_ENTRY MethodEntered3 _TEXT NoHandler
  //       Upon entry :
  //           r14 = clientInfo
  //           r15 = profiledRsp

  push_nonvol_reg         rax

  lea                     rax [rsp + 0x10]    // caller rsp
  mov                     r10 [rax - 0x8]     // return address

  push_argument_register  rdx
  alloc_stack             SIZEOF_STACK_FRAME

  // correctness of return value in structure doesn't matter for enter probe

  // setup ProfilePlatformSpecificData structure
  xor                     r11 r11 // nullify r11
  mov                     [rsp +  0x0] r11    // r11 is null     -- struct functionId field
  save_reg_postrsp        rbp 0x8             //                 -- struct rbp field
  mov                     [rsp + 0x10] rax    // caller rsp      -- struct probeRsp field
  mov                     [rsp + 0x18] r10    // return address  -- struct ip field
  mov                     [rsp + 0x20] r15    //                 -- struct profiledRsp field
  mov                     [rsp + 0x28] r11    // return value    -- struct rax field
  mov                     [rsp + 0x30] r11    // r11 is null     -- struct hiddenArg field
  movsd                   real8 ptr [rsp + 0x38] xmm0    //      -- struct flt0 field
  movsd                   real8 ptr [rsp + 0x40] xmm1    //      -- struct flt1 field
  movsd                   real8 ptr [rsp + 0x48] xmm2    //      -- struct flt2 field
  movsd                   real8 ptr [rsp + 0x50] xmm3    //      -- struct flt3 field
  movsd                   real8 ptr [rsp + 0x58] xmm4    //      -- struct flt4 field
  movsd                   real8 ptr [rsp + 0x60] xmm5    //      -- struct flt5 field
  movsd                   real8 ptr [rsp + 0x68] xmm6    //      -- struct flt6 field
  movsd                   real8 ptr [rsp + 0x70] xmm7    //      -- struct flt7 field
  mov                     [rsp + 0x78] rdi     //                -- struct rdi field
  mov                     [rsp + 0x80] rsi     //                -- struct rsi field
  mov                     [rsp + 0x88] rdx     //                -- struct rdx field
  mov                     [rsp + 0x90] rcx     //                -- struct rcx field
  mov                     [rsp + 0x98] r8      //                -- struct r8 field
  mov                     [rsp + 0xa0] r9      //                -- struct r9 field
  mov                     r10 0x1 // PROFILE_ENTER
  mov                     [rsp + 0xa8] r10d   //                -- struct flags field

  // get aligned stack ptr (rsp + FRAME_SIZE) &amp; (-16)
  lea                     rax [rsp + 0xb8]
  and                     rax -16

  // we need to be able to restore the fp return register
  // save fp return registers
  movdqa                  [rax + 0x00] xmm0
  movdqa                  [rax + 0x10] xmm1

  END_PROLOGUE

  // rdi already contains the clientInfo
  mov                     rdi r14
  lea                     rsi [rsp + 0x0]
  call                    C_PLTFUNC(EnterMethodStub)

  // restore fp return registers
  lea                     rax [rsp + 0xb8]
  and                     rax -16
  movdqa                  xmm0 [rax + 0x00]
  movdqa                  xmm1 [rax + 0x10]

  // restore arg registers
  mov                     rdi [rsp + 0x78]
  mov                     rsi [rsp + 0x80]
  mov                     rdx [rsp + 0x88]
  mov                     rcx [rsp + 0x90]
  mov                     r8 [rsp + 0x98]
  mov                     r9 [rsp + 0xa0]

  // begin epilogue
  free_stack              SIZEOF_STACK_FRAME
  pop_argument_register   rdx

  pop_nonvol_reg          rax

  ret
NESTED_END MethodEntered3 _TEXT

// EXTERN_C void MethodLeft3(FunctionIDOrClientID functionIDOrClientID size_t profiledRsp);
// &lt;NOTE&gt;
//
// &lt;/NOTE&gt;
NESTED_ENTRY MethodLeft3 _TEXT NoHandler
//       Upon entry :
//           rdi = clientInfo
//           rsi = profiledRsp

  push_nonvol_reg         rbx

  lea                     rbx [rsp + 0x10]    // caller rsp
  mov                     r10 [rbx - 0x8]     // return address

  // rdx should be saved here because it can be used for returning struct values
  push_argument_register  rdx
  alloc_stack             SIZEOF_STACK_FRAME

  // correctness of argument registers in structure doesn't matter for leave probe

  // setup ProfilePlatformSpecificData structure
  xor                     r11 r11  // nullify r11
  mov                     [rsp +  0x0] r11    // r11 is null     -- struct functionId field
  save_reg_postrsp        rbp 0x8             //                 -- struct rbp field
  mov                     [rsp + 0x10] rbx    // caller rsp      -- struct probeRsp field
  mov                     [rsp + 0x18] r10    // return address  -- struct ip field
  mov                     [rsp + 0x20] rsi    //                 -- struct profiledRsp field
  mov                     [rsp + 0x28] rax    // return value    -- struct rax field
  mov                     [rsp + 0x30] r11    // r11 is null     -- struct hiddenArg field
  movsd                   real8 ptr [rsp + 0x38] xmm0    //      -- struct flt0 field
  movsd                   real8 ptr [rsp + 0x40] xmm1    //      -- struct flt1 field
  movsd                   real8 ptr [rsp + 0x48] xmm2    //      -- struct flt2 field
  movsd                   real8 ptr [rsp + 0x50] xmm3    //      -- struct flt3 field
  movsd                   real8 ptr [rsp + 0x58] xmm4    //      -- struct flt4 field
  movsd                   real8 ptr [rsp + 0x60] xmm5    //      -- struct flt5 field
  movsd                   real8 ptr [rsp + 0x68] xmm6    //      -- struct flt6 field
  movsd                   real8 ptr [rsp + 0x70] xmm7    //      -- struct flt7 field
  mov                     [rsp + 0x78] r11     //                -- struct rdi field
  mov                     [rsp + 0x80] r11     //                -- struct rsi field
  mov                     [rsp + 0x88] r11     //                -- struct rdx field
  mov                     [rsp + 0x90] r11     //                -- struct rcx field
  mov                     [rsp + 0x98] r11     //                -- struct r8 field
  mov                     [rsp + 0xa0] r11    //                -- struct r9 field
  mov                     r10 0x2  // PROFILE_LEAVE
  mov                     [rsp + 0xa8] r10d   // flags           -- struct flags field

  // get aligned stack ptr (rsp + FRAME_SIZE) &amp; (-16)
  lea                     rax [rsp + 0xb8]
  and                     rax -16

  // we need to be able to restore the fp return register
  // save fp return registers
  movdqa                  [rax + 0x00] xmm0
  movdqa                  [rax + 0x10] xmm1

  END_PROLOGUE

  // rdi already contains the clientInfo
  lea                     rsi [rsp + 0x0]
  call                    C_PLTFUNC(LeaveMethodStub)

  // restore fp return registers
  lea                     rax [rsp + 0xb8]
  and                     rax -16
  movdqa                  xmm0 [rax + 0x00]
  movdqa                  xmm1 [rax + 0x10]

  // restore int return register
  mov                     rax [rsp + 0x28]

  // begin epilogue
  free_stack              SIZEOF_STACK_FRAME
  pop_argument_register   rdx

  pop_nonvol_reg          rbx

  ret
NESTED_END MethodLeft3 _TEXT
```

It seems to me like the frame isn't being set up right but I just have no idea where to begin. Help? Thanks in advance for any insight.



</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>sywhang</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18973</IssueLabelID>
    <Title>Enable tiered compilation by default</Title>
    <Description># Enable tiered compilation by default

Tiered compilation was added as an optional feature in .NET Core 2.1. It has been demonstrated that the [feature has a lot of value](https://github.com/dotnet/coreclr/issues/18361#issuecomment-396402549). We have done additional test runs that show similar gains.

There have been some reports of [degradation due to tiered compilation](https://github.com/dotnet/coreclr/issues/18361). We believe that these cases are in the narrow minority.

We would like to do the following:

- Enable tiered compilation by default in the first .NET Core 2.2 preview.
- Enable an opt-out of the feature. It is opt-in right now.
- Collect user feedback on the feature to make a decision if the feature works well enough to ship in 2.2 enabled.

We would make the same changes in master (AKA .NET Core 3.0) at the same time.

If that doesn't work out we could keep the feature as opt-in and enable it in some set of templates. This option isn't a proposal and would be dissapointing

Relevant links:

* https://github.com/dotnet/coreclr/issues/4331
* https://github.com/dotnet/coreclr/pull/17840
* https://github.com/dotnet/sdk/pull/2201
* https://github.com/dotnet/coreclr/issues/18361
</Description>
    <Title_Description>Enable tiered compilation by default # Enable tiered compilation by default

Tiered compilation was added as an optional feature in .NET Core 2.1. It has been demonstrated that the [feature has a lot of value](https://github.com/dotnet/coreclr/issues/18361#issuecomment-396402549). We have done additional test runs that show similar gains.

There have been some reports of [degradation due to tiered compilation](https://github.com/dotnet/coreclr/issues/18361). We believe that these cases are in the narrow minority.

We would like to do the following:

- Enable tiered compilation by default in the first .NET Core 2.2 preview.
- Enable an opt-out of the feature. It is opt-in right now.
- Collect user feedback on the feature to make a decision if the feature works well enough to ship in 2.2 enabled.

We would make the same changes in master (AKA .NET Core 3.0) at the same time.

If that doesn't work out we could keep the feature as opt-in and enable it in some set of templates. This option isn't a proposal and would be dissapointing

Relevant links:

* https://github.com/dotnet/coreclr/issues/4331
* https://github.com/dotnet/coreclr/pull/17840
* https://github.com/dotnet/sdk/pull/2201
* https://github.com/dotnet/coreclr/issues/18361
</Title_Description>
    <Label>area-TieredCompilation</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18971</IssueLabelID>
    <Title>Ensure .NET Core respects and plays nicely with Docker limits</Title>
    <Description>Docker enables you to [limit a container's resources](https://docs.docker.com/config/containers/resource_constraints/). This control is great for high-density hosting and other low-resource scenarios. Developers have the expectation that the application platform respects these limits and does its best to work within them.

I wrote a [crude test framework](https://github.com/richlander/dotnet-docker-limits) to determine how .NET Core behaves when various resource limits are set. You can see the [test results](https://gist.github.com/richlander/48bb0ad51a2406937b61bea01de7cf87).

The results I saw made some sense -- workstation performed better than server gc in this environment -- however some other characteristics were surprising. It could be that my tests were flawed.

Our first goal is to provide developers with guidance. For example if there a minimum memory limit that is required to run an app in production? Is server gc currently safe to run with docker limits?

Our next goal is to update the product as appropriate to ensure that it works well with Docker limits and then to update guidance appropriately.

Once we are done I'd like to re-run this test suite following the guidance. I/we should be able to pick a lower bound number (this app is very simple) and expect it to run w/o memory exhaustion.

[My app](https://github.com/richlander/dotnet-docker-limits/tree/master/src/aspnetapi) is very simple. There will be apps run in containers that require running on multiple cores and take advantage of server GC. Is that appropriate for docker limits or is there a minimum memory level of 250mb for example for that scenario? We should probably find a different test app that better exhibits the behavior of this type of app.
</Description>
    <Title_Description>Ensure .NET Core respects and plays nicely with Docker limits Docker enables you to [limit a container's resources](https://docs.docker.com/config/containers/resource_constraints/). This control is great for high-density hosting and other low-resource scenarios. Developers have the expectation that the application platform respects these limits and does its best to work within them.

I wrote a [crude test framework](https://github.com/richlander/dotnet-docker-limits) to determine how .NET Core behaves when various resource limits are set. You can see the [test results](https://gist.github.com/richlander/48bb0ad51a2406937b61bea01de7cf87).

The results I saw made some sense -- workstation performed better than server gc in this environment -- however some other characteristics were surprising. It could be that my tests were flawed.

Our first goal is to provide developers with guidance. For example if there a minimum memory limit that is required to run an app in production? Is server gc currently safe to run with docker limits?

Our next goal is to update the product as appropriate to ensure that it works well with Docker limits and then to update guidance appropriately.

Once we are done I'd like to re-run this test suite following the guidance. I/we should be able to pick a lower bound number (this app is very simple) and expect it to run w/o memory exhaustion.

[My app](https://github.com/richlander/dotnet-docker-limits/tree/master/src/aspnetapi) is very simple. There will be apps run in containers that require running on multiple cores and take advantage of server GC. Is that appropriate for docker limits or is there a minimum memory level of 250mb for example for that scenario? We should probably find a different test app that better exhibits the behavior of this type of app.
</Title_Description>
    <Label>area-VM</Label>
    <Assignee>sergiy-k</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18969</IssueLabelID>
    <Title>JIT: overview of proposed local var reference count changes</Title>
    <Description>This issue proposes a series of changes to reduce the overhead and increase the fidelity of local variable reference counts in the jit. The main idea is to get rid of the current costly and buggy incremental count maintenance in favor of batch updates that are done just before accurate ref counts are needed.

See discussion in #13280 for background.

Expected impact is:
* 4-5% improvement in tier0 / minopts / debug throughput
* minimal impact to optimized jit throughput
* smaller frame sizes in some cases where reference counts are currently inflated
* removal of workarounds to artificially inflate reference counts to avoid asserts

The more accurate reference counts and weighted counts are likely to cause widespread codegen diffs. Hopefully these will mostly be improvements but some regressions are certainly possible.

Proposed steps are:
- [x] encapsulate accesses to `lvRefCnt` and `lvRefCntWtd` in an API make backing fields private (#18979)
- [x] characterize when ref count access and update is invalid and update API to flag invalid access (#19068)
- [x] classify invalid accesses and figure out strategies for removing them (#19012)
- [x] once all invalid accesses are removed add appropriate asserts to catch invalid accesses (#19068)
- [x] figure out what actions under `lvaMarkRefs` are required for all compilations vs only needed when optimizing (#19103 #19240)
- [x] figure out minopts / debug codegen approach (#19103)
- [x] ensure we have an algorithm that can properly recompute counts from scratch (#19240)
- [x] recompute counts after lower (#19325)
- [x] change from incremental updates to batched updates (#19345)
- [x] decide how often counts need to be made current (or track if they've possibly gone stale) (#19345)
- [x] sort through codegen diffs resulting from more accurate ref counts and fix what can be fixed (#19345)
- [ ] try and clean up the logic in `lvaMarkRefs` to split out ref counting from other activities

cc @dotnet/jit-contrib 


category:implementation
theme:ir
skill-level:expert
cost:large</Description>
    <Title_Description>JIT: overview of proposed local var reference count changes This issue proposes a series of changes to reduce the overhead and increase the fidelity of local variable reference counts in the jit. The main idea is to get rid of the current costly and buggy incremental count maintenance in favor of batch updates that are done just before accurate ref counts are needed.

See discussion in #13280 for background.

Expected impact is:
* 4-5% improvement in tier0 / minopts / debug throughput
* minimal impact to optimized jit throughput
* smaller frame sizes in some cases where reference counts are currently inflated
* removal of workarounds to artificially inflate reference counts to avoid asserts

The more accurate reference counts and weighted counts are likely to cause widespread codegen diffs. Hopefully these will mostly be improvements but some regressions are certainly possible.

Proposed steps are:
- [x] encapsulate accesses to `lvRefCnt` and `lvRefCntWtd` in an API make backing fields private (#18979)
- [x] characterize when ref count access and update is invalid and update API to flag invalid access (#19068)
- [x] classify invalid accesses and figure out strategies for removing them (#19012)
- [x] once all invalid accesses are removed add appropriate asserts to catch invalid accesses (#19068)
- [x] figure out what actions under `lvaMarkRefs` are required for all compilations vs only needed when optimizing (#19103 #19240)
- [x] figure out minopts / debug codegen approach (#19103)
- [x] ensure we have an algorithm that can properly recompute counts from scratch (#19240)
- [x] recompute counts after lower (#19325)
- [x] change from incremental updates to batched updates (#19345)
- [x] decide how often counts need to be made current (or track if they've possibly gone stale) (#19345)
- [x] sort through codegen diffs resulting from more accurate ref counts and fix what can be fixed (#19345)
- [ ] try and clean up the logic in `lvaMarkRefs` to split out ref counting from other activities

cc @dotnet/jit-contrib 


category:implementation
theme:ir
skill-level:expert
cost:large</Title_Description>
    <Label>JitThroughput</Label>
    <Assignee>AndyAyersMS</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18968</IssueLabelID>
    <Title>EventWaitHandle.OpenExisting("".PadLeft(512)) is throwing ArgumentException instead of </Title>
    <Description>The following test outputted "Pass" in .NET Core 2.1 and is now outputting "Fail" with the latest CoreCLR in the master branch.

```
using System;
using System.Threading;

namespace Event
{
    internal static class Program
    {
        static void Main(string[] args)
        {
            try
            {
                EventWaitHandle.OpenExisting("".PadLeft(512));
            }
            catch (ArgumentException)
            {
                Console.WriteLine("Pass");
            }
            catch (WaitHandleCannotBeOpenedException)
            {
                Console.WriteLine("Fail");
            }
        }
    }
}
```

It is probably caused by the removal of the validation on path length:
https://github.com/dotnet/coreclr/commit/422b0e81797d5428812c6ef825e22565e2dc63f3

To reproduce it:

1. Create a .NET Core application
2. Modify the csproj to add `&lt;RuntimeIdentifier&gt;win-x64&lt;/RuntimeIdentifier&gt;` under the PropertyGroup tag.
3. `dotnet publish --self-contained`
4. Run the build executable it should output "Pass".
5. Build the latest master CoreCLR and copy the new binaries on top of the published ones.
6. Run the build executable it should output "Fail".</Description>
    <Title_Description>EventWaitHandle.OpenExisting("".PadLeft(512)) is throwing ArgumentException instead of  The following test outputted "Pass" in .NET Core 2.1 and is now outputting "Fail" with the latest CoreCLR in the master branch.

```
using System;
using System.Threading;

namespace Event
{
    internal static class Program
    {
        static void Main(string[] args)
        {
            try
            {
                EventWaitHandle.OpenExisting("".PadLeft(512));
            }
            catch (ArgumentException)
            {
                Console.WriteLine("Pass");
            }
            catch (WaitHandleCannotBeOpenedException)
            {
                Console.WriteLine("Fail");
            }
        }
    }
}
```

It is probably caused by the removal of the validation on path length:
https://github.com/dotnet/coreclr/commit/422b0e81797d5428812c6ef825e22565e2dc63f3

To reproduce it:

1. Create a .NET Core application
2. Modify the csproj to add `&lt;RuntimeIdentifier&gt;win-x64&lt;/RuntimeIdentifier&gt;` under the PropertyGroup tag.
3. `dotnet publish --self-contained`
4. Run the build executable it should output "Pass".
5. Build the latest master CoreCLR and copy the new binaries on top of the published ones.
6. Run the build executable it should output "Fail".</Title_Description>
    <Label>area-System.Threading</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18966</IssueLabelID>
    <Title>[x64] Assertion failed '!s_pagePool.isPoolPage(page)'</Title>
    <Description>From x64 corefx JitStressRegs=0x1000 run: https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64/job/jitstress/job/x64_checked_windows_nt_corefx_jitstressregs0x1000/462/consoleText

```
  Assert failure(PID 6016 [0x00001780] Thread: 6216 [0x1848]): Assertion failed '!s_pagePool.isPoolPage(page)' in 'System.Data.SqlClient.SqlClientDiagnosticListenerExtensions:WriteConnectionOpenError(refstructrefrefref)' (IL size 46)
  
      File: d:\j\workspace\x64_checked_w---5e38e6b2\src\jit\alloc.cpp Line: 301
      Image: D:\j\workspace\x64_checked_w---5e38e6b2\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-x64\dotnet.exe
```

</Description>
    <Title_Description>[x64] Assertion failed '!s_pagePool.isPoolPage(page)' From x64 corefx JitStressRegs=0x1000 run: https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64/job/jitstress/job/x64_checked_windows_nt_corefx_jitstressregs0x1000/462/consoleText

```
  Assert failure(PID 6016 [0x00001780] Thread: 6216 [0x1848]): Assertion failed '!s_pagePool.isPoolPage(page)' in 'System.Data.SqlClient.SqlClientDiagnosticListenerExtensions:WriteConnectionOpenError(refstructrefrefref)' (IL size 46)
  
      File: d:\j\workspace\x64_checked_w---5e38e6b2\src\jit\alloc.cpp Line: 301
      Image: D:\j\workspace\x64_checked_w---5e38e6b2\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-x64\dotnet.exe
```

</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>17/07/2018 6:57:44 PM +00:00</CreatedAt>
    <ClosedAt>17/07/2018 7:12:20 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18965</IssueLabelID>
    <Title>[NO MERGE] Dummy PR for testing IncreaseTimeOutInRegexMatchTestsMatch_ExcessPrefixTest</Title>
    <Description>**NO MERGE**</Description>
    <Title_Description>[NO MERGE] Dummy PR for testing IncreaseTimeOutInRegexMatchTestsMatch_ExcessPrefixTest **NO MERGE**</Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>echesakovMSFT</Assignee>
    <CreatedAt>17/07/2018 6:49:01 PM +00:00</CreatedAt>
    <ClosedAt>20/07/2018 5:55:14 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18963</IssueLabelID>
    <Title>[x64] Assertion failed '!BitVecOps::IsMember(&amp;nodesVecTraits uniqueNodes gtTreeID)'</Title>
    <Description>Failure in CI in x64 corefx minopts tests. E.g. https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64/job/jitstress/job/x64_checked_windows_nt_corefx_minopts/581/consoleText

There are 60 occurrences of this assert in this run.

```
----- start  9:56:58.02 ===============  To repro directly: ===================================================== 
  pushd D:\j\workspace\x64_checked_w---f0b6fff8\_\fx\bin\tests\System.Buffers.Tests\netcoreapp-Windows_NT-Release-x64\
  set COMPlus_TieredCompilation=0 
  call D:\j\workspace\x64_checked_w---f0b6fff8\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-x64\\dotnet.exe xunit.console.netcore.exe System.Buffers.Tests.dll  -xml testResults.xml -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonwindowstests  -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing
  popd
  ===========================================================================================================
  xUnit.net console test runner (64-bit .NET Core)
  Copyright (C) 2014 Outercurve Foundation.
  
  Discovering: System.Buffers.Tests
  [Microsoft (R) .NET Core Xml Serialization Generation Utility Version 2.0.0-preview1]
  Discovered:  System.Buffers.Tests
  Copyright (C) Microsoft Corporation. All rights reserved.
  Starting:    System.Buffers.Tests
  Serialization Code File Name: D:\j\workspace\x64_checked_w---f0b6fff8\_\fx\bin\tests\Microsoft.XmlSerializer.Generator.Tests\netcoreapp-Windows_NT-Release-x64\Microsoft.XmlSerializer.Generator.Tests.XmlSerializers.cs.
  Discovered:  System.Collections.Concurrent.Tests
  Generated serialization code for assembly D:\j\workspace\x64_checked_w---f0b6fff8\_\fx\bin\tests\Microsoft.XmlSerializer.Generator.Tests\netcoreapp-Windows_NT-Release-x64\Microsoft.XmlSerializer.Generator.Tests.dll --&gt; 'D:\j\workspace\x64_checked_w---f0b6fff8\_\fx\bin\tests\Microsoft.XmlSerializer.Generator.Tests\netcoreapp-Windows_NT-Release-x64\Microsoft.XmlSerializer.Generator.Tests.XmlSerializers.cs'.
  
  Assert failure(PID 3144 [0x00000c48] Thread: 4960 [0x1360]): Assertion failed '!BitVecOps::IsMember(&amp;nodesVecTraits uniqueNodes gtTreeID)' in 'System.Uri:PrivateParseMinimal():int:this' (IL size 1208)
  
      File: d:\j\workspace\x64_checked_w---f0b6fff8\src\jit\flowgraph.cpp Line: 21774
      Image: D:\j\workspace\x64_checked_w---f0b6fff8\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-x64\dotnet.exe
  
  ----- end  9:57:05.41 ----- exit code 123456789 ----------------------------------------------------------

```
</Description>
    <Title_Description>[x64] Assertion failed '!BitVecOps::IsMember(&amp;nodesVecTraits, uniqueNodes, gtTreeID)' Failure in CI in x64 corefx minopts tests. E.g. https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64/job/jitstress/job/x64_checked_windows_nt_corefx_minopts/581/consoleText

There are 60 occurrences of this assert in this run.

```
----- start  9:56:58.02 ===============  To repro directly: ===================================================== 
  pushd D:\j\workspace\x64_checked_w---f0b6fff8\_\fx\bin\tests\System.Buffers.Tests\netcoreapp-Windows_NT-Release-x64\
  set COMPlus_TieredCompilation=0 
  call D:\j\workspace\x64_checked_w---f0b6fff8\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-x64\\dotnet.exe xunit.console.netcore.exe System.Buffers.Tests.dll  -xml testResults.xml -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonwindowstests  -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing
  popd
  ===========================================================================================================
  xUnit.net console test runner (64-bit .NET Core)
  Copyright (C) 2014 Outercurve Foundation.
  
  Discovering: System.Buffers.Tests
  [Microsoft (R) .NET Core Xml Serialization Generation Utility Version 2.0.0-preview1]
  Discovered:  System.Buffers.Tests
  Copyright (C) Microsoft Corporation. All rights reserved.
  Starting:    System.Buffers.Tests
  Serialization Code File Name: D:\j\workspace\x64_checked_w---f0b6fff8\_\fx\bin\tests\Microsoft.XmlSerializer.Generator.Tests\netcoreapp-Windows_NT-Release-x64\Microsoft.XmlSerializer.Generator.Tests.XmlSerializers.cs.
  Discovered:  System.Collections.Concurrent.Tests
  Generated serialization code for assembly D:\j\workspace\x64_checked_w---f0b6fff8\_\fx\bin\tests\Microsoft.XmlSerializer.Generator.Tests\netcoreapp-Windows_NT-Release-x64\Microsoft.XmlSerializer.Generator.Tests.dll --&gt; 'D:\j\workspace\x64_checked_w---f0b6fff8\_\fx\bin\tests\Microsoft.XmlSerializer.Generator.Tests\netcoreapp-Windows_NT-Release-x64\Microsoft.XmlSerializer.Generator.Tests.XmlSerializers.cs'.
  
  Assert failure(PID 3144 [0x00000c48] Thread: 4960 [0x1360]): Assertion failed '!BitVecOps::IsMember(&amp;nodesVecTraits uniqueNodes gtTreeID)' in 'System.Uri:PrivateParseMinimal():int:this' (IL size 1208)
  
      File: d:\j\workspace\x64_checked_w---f0b6fff8\src\jit\flowgraph.cpp Line: 21774
      Image: D:\j\workspace\x64_checked_w---f0b6fff8\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-x64\dotnet.exe
  
  ----- end  9:57:05.41 ----- exit code 123456789 ----------------------------------------------------------

```
</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>17/07/2018 6:41:29 PM +00:00</CreatedAt>
    <ClosedAt>20/07/2018 10:37:26 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18960</IssueLabelID>
    <Title>Test failure: CoreMangLib_system._span_SlowTailCallArgs_SlowTailCallArgs_/_span_SlowTailCallArgs_SlowTailCallArgs_cmd</Title>
    <Description>Opened on behalf of @Sunny-pu

The test `CoreMangLib_system._span_SlowTailCallArgs_SlowTailCallArgs_/_span_SlowTailCallArgs_SlowTailCallArgs_cmd` has failed.


    Unhandled Exception: System.IO.FileNotFoundException: Could not load file or assembly 'System.Reflection.Emit.ILGeneration Version=4.0.3.0 Culture=neutral PublicKeyToken=b03f5f7f11d50a3a'. The system cannot find the file specified.
    
       at SpanTest.Run()
       at Program.Main()
    /home/helixbot/dotnetbuild/work/829eb0a1-744b-4dd3-8627-616125703d53/Work/3938d767-5cf7-42d2-8619-5e5ef7623a10/Unzip/span/SlowTailCallArgs/SlowTailCallArgs.sh: line 251: 48570 Aborted                 (core dumped) $_DebuggerFullPath \"$CORE_ROOT/corerun\" $ExePath $CLRTestExecutionArguments
    
    
    Return code:      1
    Raw output file:      /home/helixbot/dotnetbuild/work/829eb0a1-744b-4dd3-8627-616125703d53/Work/3938d767-5cf7-42d2-8619-5e5ef7623a10/Unzip/Reports\\CoreMangLib.system\\span\\SlowTailCallArgs\\SlowTailCallArgs.output.txt
    Raw output:
    BEGIN EXECUTION
    /home/helixbot/dotnetbuild/work/829eb0a1-744b-4dd3-8627-616125703d53/Payload/corerun SlowTailCallArgs.exe
        SpanTest: Expected: 100
    Actual: 134
    END EXECUTION - FAILED
    Test Harness Exitcode is : 1
    
    To run the test:
    &gt; set CORE_ROOT=/home/helixbot/dotnetbuild/work/829eb0a1-744b-4dd3-8627-616125703d53/Payload
    &gt; /home/helixbot/dotnetbuild/work/829eb0a1-744b-4dd3-8627-616125703d53/Work/3938d767-5cf7-42d2-8619-5e5ef7623a10/Unzip/span/SlowTailCallArgs/SlowTailCallArgs.sh
    
    Expected: True
    Actual:   False

        Stack Trace:

        
Build : Master - 20180716.04 (Ready-To-Run Tests)
Failing configurations:
- opensuse.423.amd64
  - x64

Details: https://mc.dot.net/#/product/netcore/master/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fr2r~2Fcli~2F/build/20180716.04/workItem/CoreMangLib.system.XUnitWrapper/analysis/xunit/CoreMangLib_system._span_SlowTailCallArgs_SlowTailCallArgs_~2F_span_SlowTailCallArgs_SlowTailCallArgs_cmd</Description>
    <Title_Description>Test failure: CoreMangLib_system._span_SlowTailCallArgs_SlowTailCallArgs_/_span_SlowTailCallArgs_SlowTailCallArgs_cmd Opened on behalf of @Sunny-pu

The test `CoreMangLib_system._span_SlowTailCallArgs_SlowTailCallArgs_/_span_SlowTailCallArgs_SlowTailCallArgs_cmd` has failed.


    Unhandled Exception: System.IO.FileNotFoundException: Could not load file or assembly 'System.Reflection.Emit.ILGeneration Version=4.0.3.0 Culture=neutral PublicKeyToken=b03f5f7f11d50a3a'. The system cannot find the file specified.
    
       at SpanTest.Run()
       at Program.Main()
    /home/helixbot/dotnetbuild/work/829eb0a1-744b-4dd3-8627-616125703d53/Work/3938d767-5cf7-42d2-8619-5e5ef7623a10/Unzip/span/SlowTailCallArgs/SlowTailCallArgs.sh: line 251: 48570 Aborted                 (core dumped) $_DebuggerFullPath \"$CORE_ROOT/corerun\" $ExePath $CLRTestExecutionArguments
    
    
    Return code:      1
    Raw output file:      /home/helixbot/dotnetbuild/work/829eb0a1-744b-4dd3-8627-616125703d53/Work/3938d767-5cf7-42d2-8619-5e5ef7623a10/Unzip/Reports\\CoreMangLib.system\\span\\SlowTailCallArgs\\SlowTailCallArgs.output.txt
    Raw output:
    BEGIN EXECUTION
    /home/helixbot/dotnetbuild/work/829eb0a1-744b-4dd3-8627-616125703d53/Payload/corerun SlowTailCallArgs.exe
        SpanTest: Expected: 100
    Actual: 134
    END EXECUTION - FAILED
    Test Harness Exitcode is : 1
    
    To run the test:
    &gt; set CORE_ROOT=/home/helixbot/dotnetbuild/work/829eb0a1-744b-4dd3-8627-616125703d53/Payload
    &gt; /home/helixbot/dotnetbuild/work/829eb0a1-744b-4dd3-8627-616125703d53/Work/3938d767-5cf7-42d2-8619-5e5ef7623a10/Unzip/span/SlowTailCallArgs/SlowTailCallArgs.sh
    
    Expected: True
    Actual:   False

        Stack Trace:

        
Build : Master - 20180716.04 (Ready-To-Run Tests)
Failing configurations:
- opensuse.423.amd64
  - x64

Details: https://mc.dot.net/#/product/netcore/master/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fr2r~2Fcli~2F/build/20180716.04/workItem/CoreMangLib.system.XUnitWrapper/analysis/xunit/CoreMangLib_system._span_SlowTailCallArgs_SlowTailCallArgs_~2F_span_SlowTailCallArgs_SlowTailCallArgs_cmd</Title_Description>
    <Label>area-ReadyToRun</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>17/07/2018 8:44:49 AM +00:00</CreatedAt>
    <ClosedAt>20/06/2019 12:24:03 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18959</IssueLabelID>
    <Title>Test failure: baseservices_regression._v1_threads_functional_threadpool_cs_threadpoolnullchecks_CS_ThreadPoolNullChecks_CS_ThreadPoolNullChecks_/_v1_threads_functional_threadpool_cs_threadpoolnullchecks_CS_ThreadPoolNullChecks_CS_ThreadPoolNullChecks_cmd</Title>
    <Description>Opened on behalf of @Sunny-pu

The test `baseservices_regression._v1_threads_functional_threadpool_cs_threadpoolnullchecks_CS_ThreadPoolNullChecks_CS_ThreadPoolNullChecks_/_v1_threads_functional_threadpool_cs_threadpoolnullchecks_CS_ThreadPoolNullChecks_CS_ThreadPoolNullChecks_cmd` has failed.

Error: Could not load file or assembly 'System.Threading.ThreadPool Version=4.1.1.0 Culture=neutral PublicKeyToken=b03f5f7f11d50a3a'. The system cannot find the file specified.
     (Exception from HRESULT: 0x80070002)
    Error compiling CS_ThreadPoolNullChecks.org: Could not find or load a specific file. (Exception from HRESULT: 0x80131621)
    Error: compilation failed for \"CS_ThreadPoolNullChecks.org\" (0x80131621)
    
    
    Return code:      1
    Raw output file:      /home/helixbot/dotnetbuild/work/829eb0a1-744b-4dd3-8627-616125703d53/Work/b03a8239-5170-4a4b-a231-f0b855577e56/Unzip/Reports\\baseservices.regression\\v1\\threads\\functional\\threadpool\\cs_threadpoolnullchecks\\CS_ThreadPoolNullChecks\\CS_ThreadPoolNullChecks.output.txt
    Raw output:
    BEGIN EXECUTION
    in takeLock
    /home/helixbot/dotnetbuild/work/829eb0a1-744b-4dd3-8627-616125703d53/Payload/crossgen /Platform_Assemblies_Paths /home/helixbot/dotnetbuild/work/829eb0a1-744b-4dd3-8627-616125703d53/Payload:/home/helixbot/dotnetbuild/work/829eb0a1-744b-4dd3-8627-616125703d53/Work/b03a8239-5170-4a4b-a231-f0b855577e56/Unzip/v1/threads/functional/threadpool/cs_threadpoolnullchecks/CS_ThreadPoolNullChecks/IL:/home/helixbot/dotnetbuild/work/829eb0a1-744b-4dd3-8627-616125703d53/Work/b03a8239-5170-4a4b-a231-f0b855577e56/Unzip/v1/threads/functional/threadpool/cs_threadpoolnullchecks/CS_ThreadPoolNullChecks /in CS_ThreadPoolNullChecks.org /out CS_ThreadPoolNullChecks.exe
    Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0
    Copyright (c) Microsoft Corporation.  All rights reserved.
    
    Crossgen failed with exitcode: 33
    in ReleaseLock
    Test Harness Exitcode is : 1
    
    To run the test:
    &gt; set CORE_ROOT=/home/helixbot/dotnetbuild/work/829eb0a1-744b-4dd3-8627-616125703d53/Payload
    &gt; /home/helixbot/dotnetbuild/work/829eb0a1-744b-4dd3-8627-616125703d53/Work/b03a8239-5170-4a4b-a231-f0b855577e56/Unzip/v1/threads/functional/threadpool/cs_threadpoolnullchecks/CS_ThreadPoolNullChecks/CS_ThreadPoolNullChecks.sh
    
    Expected: True
    Actual:   False

        Stack Trace:

        
Build : Master - 20180716.04 (Ready-To-Run Tests)
Failing configurations:
- opensuse.423.amd64
  - x64

Details: https://mc.dot.net/#/product/netcore/master/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fr2r~2Fcli~2F/build/20180716.04/workItem/baseservices.regression.XUnitWrapper/analysis/xunit/baseservices_regression._v1_threads_functional_threadpool_cs_threadpoolnullchecks_CS_ThreadPoolNullChecks_CS_ThreadPoolNullChecks_~2F_v1_threads_functional_threadpool_cs_threadpoolnullchecks_CS_ThreadPoolNullChecks_CS_ThreadPoolNullChecks_cmd</Description>
    <Title_Description>Test failure: baseservices_regression._v1_threads_functional_threadpool_cs_threadpoolnullchecks_CS_ThreadPoolNullChecks_CS_ThreadPoolNullChecks_/_v1_threads_functional_threadpool_cs_threadpoolnullchecks_CS_ThreadPoolNullChecks_CS_ThreadPoolNullChecks_cmd Opened on behalf of @Sunny-pu

The test `baseservices_regression._v1_threads_functional_threadpool_cs_threadpoolnullchecks_CS_ThreadPoolNullChecks_CS_ThreadPoolNullChecks_/_v1_threads_functional_threadpool_cs_threadpoolnullchecks_CS_ThreadPoolNullChecks_CS_ThreadPoolNullChecks_cmd` has failed.

Error: Could not load file or assembly 'System.Threading.ThreadPool Version=4.1.1.0 Culture=neutral PublicKeyToken=b03f5f7f11d50a3a'. The system cannot find the file specified.
     (Exception from HRESULT: 0x80070002)
    Error compiling CS_ThreadPoolNullChecks.org: Could not find or load a specific file. (Exception from HRESULT: 0x80131621)
    Error: compilation failed for \"CS_ThreadPoolNullChecks.org\" (0x80131621)
    
    
    Return code:      1
    Raw output file:      /home/helixbot/dotnetbuild/work/829eb0a1-744b-4dd3-8627-616125703d53/Work/b03a8239-5170-4a4b-a231-f0b855577e56/Unzip/Reports\\baseservices.regression\\v1\\threads\\functional\\threadpool\\cs_threadpoolnullchecks\\CS_ThreadPoolNullChecks\\CS_ThreadPoolNullChecks.output.txt
    Raw output:
    BEGIN EXECUTION
    in takeLock
    /home/helixbot/dotnetbuild/work/829eb0a1-744b-4dd3-8627-616125703d53/Payload/crossgen /Platform_Assemblies_Paths /home/helixbot/dotnetbuild/work/829eb0a1-744b-4dd3-8627-616125703d53/Payload:/home/helixbot/dotnetbuild/work/829eb0a1-744b-4dd3-8627-616125703d53/Work/b03a8239-5170-4a4b-a231-f0b855577e56/Unzip/v1/threads/functional/threadpool/cs_threadpoolnullchecks/CS_ThreadPoolNullChecks/IL:/home/helixbot/dotnetbuild/work/829eb0a1-744b-4dd3-8627-616125703d53/Work/b03a8239-5170-4a4b-a231-f0b855577e56/Unzip/v1/threads/functional/threadpool/cs_threadpoolnullchecks/CS_ThreadPoolNullChecks /in CS_ThreadPoolNullChecks.org /out CS_ThreadPoolNullChecks.exe
    Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0
    Copyright (c) Microsoft Corporation.  All rights reserved.
    
    Crossgen failed with exitcode: 33
    in ReleaseLock
    Test Harness Exitcode is : 1
    
    To run the test:
    &gt; set CORE_ROOT=/home/helixbot/dotnetbuild/work/829eb0a1-744b-4dd3-8627-616125703d53/Payload
    &gt; /home/helixbot/dotnetbuild/work/829eb0a1-744b-4dd3-8627-616125703d53/Work/b03a8239-5170-4a4b-a231-f0b855577e56/Unzip/v1/threads/functional/threadpool/cs_threadpoolnullchecks/CS_ThreadPoolNullChecks/CS_ThreadPoolNullChecks.sh
    
    Expected: True
    Actual:   False

        Stack Trace:

        
Build : Master - 20180716.04 (Ready-To-Run Tests)
Failing configurations:
- opensuse.423.amd64
  - x64

Details: https://mc.dot.net/#/product/netcore/master/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fr2r~2Fcli~2F/build/20180716.04/workItem/baseservices.regression.XUnitWrapper/analysis/xunit/baseservices_regression._v1_threads_functional_threadpool_cs_threadpoolnullchecks_CS_ThreadPoolNullChecks_CS_ThreadPoolNullChecks_~2F_v1_threads_functional_threadpool_cs_threadpoolnullchecks_CS_ThreadPoolNullChecks_CS_ThreadPoolNullChecks_cmd</Title_Description>
    <Label>area-ReadyToRun</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>17/07/2018 8:17:23 AM +00:00</CreatedAt>
    <ClosedAt>20/06/2019 12:26:10 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18958</IssueLabelID>
    <Title>.NET CORE console appliation crashes randomly on RaspberryPi (mode: 3B+ Linux ARM32)</Title>
    <Description># Issue Title

My .NET CORE (runtime version 2.1.1) console application crashes randomly on RaspberryPi (mode: 3B+ Linux ARM32 Debian 9)

# General
I have an application that just open 8 tcp connections for read and write the data rate for each connection is about 200Byte/second in most case the application can runs well but sometime later like 7 or 8 hours it randomly crashes I have attached the `AppDomain.CurrentDomain.UnhandledException` with logging but in these cases it never get called and I have seem some extra info shown in console before application crashes and quit they are:

&gt; ./myApp: relocation error: /pathToMyApp/libclrjit.so: symbol pthread_ version GLIBC_2.4 not defined in file libpthread.so.0 with link time reference

and

&gt;Bus error

and

&gt;Aborted

Later I've add my app to daemon mode and this time I can see sth in syslog:

&gt; Jul 17 08:30:51 raspberrypi systemd[1]: myApp.service: Main process exited code=killed status=6/ABRT
&gt; Jul 17 08:30:51 raspberrypi systemd[1]: myApp.service: Unit entered failed state.
&gt; Jul 17 08:30:51 raspberrypi systemd[1]: myApp.service: Failed with result 'signal'.
&gt; Jul 17 08:31:01 raspberrypi systemd[1]: myApp.service: Service hold-off time over scheduling restart.

I've logged the performance counters all the way can see the CPU and memory are all stable.
I've tried followed the [enable core dump on linux](http://blogs.microsoft.co.il/sasha/2017/02/26/analyzing-a-net-core-core-dump-on-linux/) but could never see any dump files generated please help.</Description>
    <Title_Description>.NET CORE console appliation crashes randomly on RaspberryPi (mode: 3B+, Linux ARM32) # Issue Title

My .NET CORE (runtime version 2.1.1) console application crashes randomly on RaspberryPi (mode: 3B+ Linux ARM32 Debian 9)

# General
I have an application that just open 8 tcp connections for read and write the data rate for each connection is about 200Byte/second in most case the application can runs well but sometime later like 7 or 8 hours it randomly crashes I have attached the `AppDomain.CurrentDomain.UnhandledException` with logging but in these cases it never get called and I have seem some extra info shown in console before application crashes and quit they are:

&gt; ./myApp: relocation error: /pathToMyApp/libclrjit.so: symbol pthread_ version GLIBC_2.4 not defined in file libpthread.so.0 with link time reference

and

&gt;Bus error

and

&gt;Aborted

Later I've add my app to daemon mode and this time I can see sth in syslog:

&gt; Jul 17 08:30:51 raspberrypi systemd[1]: myApp.service: Main process exited code=killed status=6/ABRT
&gt; Jul 17 08:30:51 raspberrypi systemd[1]: myApp.service: Unit entered failed state.
&gt; Jul 17 08:30:51 raspberrypi systemd[1]: myApp.service: Failed with result 'signal'.
&gt; Jul 17 08:31:01 raspberrypi systemd[1]: myApp.service: Service hold-off time over scheduling restart.

I've logged the performance counters all the way can see the CPU and memory are all stable.
I've tried followed the [enable core dump on linux](http://blogs.microsoft.co.il/sasha/2017/02/26/analyzing-a-net-core-core-dump-on-linux/) but could never see any dump files generated please help.</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>17/07/2018 7:27:12 AM +00:00</CreatedAt>
    <ClosedAt>14/01/2019 5:56:57 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18953</IssueLabelID>
    <Title>Enable the no tiered compilation innerloop PR legs</Title>
    <Description>Also using this PR to manually trigger test jobs. Marking no merge until manual testing is complete.</Description>
    <Title_Description>Enable the no tiered compilation innerloop PR legs Also using this PR to manually trigger test jobs. Marking no merge until manual testing is complete.</Title_Description>
    <Label>area-TieredCompilation</Label>
    <Assignee>noahfalk</Assignee>
    <CreatedAt>17/07/2018 2:09:11 AM +00:00</CreatedAt>
    <ClosedAt>19/07/2018 11:36:35 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18951</IssueLabelID>
    <Title>[WIP] dummy change in dev/unix_test_workflow</Title>
    <Description>
    </Description>
    <Title_Description>[WIP] dummy change in dev/unix_test_workflow </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>16/07/2018 11:23:00 PM +00:00</CreatedAt>
    <ClosedAt>24/07/2018 6:39:19 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18946</IssueLabelID>
    <Title>Update NativeCallable attribute tests</Title>
    <Description>Fix tests for the NativeCallableAttribute. #18906 

cc @jkotas @luqunl </Description>
    <Title_Description>Update NativeCallable attribute tests Fix tests for the NativeCallableAttribute. #18906 

cc @jkotas @luqunl </Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>16/07/2018 9:32:46 PM +00:00</CreatedAt>
    <ClosedAt>17/07/2018 6:12:03 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18945</IssueLabelID>
    <Title>Assertion failure on Unixes in JIT/SIMD/VectorExp_ro with tiering enabled</Title>
    <Description>```
11:35:59 FAILED   - JIT/SIMD/VectorExp_ro/VectorExp_ro.sh
11:35:59                BEGIN EXECUTION
11:35:59                /mnt/j/workspace/dotnet_coreclr/master/x64_checked_ubuntu_innerloop_tst_prtest/bin/tests/Linux.x64.Checked/Tests/Core_Root/corerun VectorExp_ro.exe
11:35:59                
11:35:59 
               Assert failure(PID 117174 [0x0001c9b6] Thread: 117174 [0x1c9b6]): Assertion failed 'arg-&gt;OperGet() == GT_LCL_VAR' in 'VectorExpTest`1[Int64][System.Int64]:VectorExp(structlonglonglong):int' (IL size 148)
11:35:59                
11:35:59                    File: /mnt/j/workspace/dotnet_coreclr/master/x64_checked_ubuntu_innerloop_prtest/src/jit/morph.cpp Line: 4628
11:35:59                    Image: /mnt/j/workspace/dotnet_coreclr/master/x64_checked_ubuntu_innerloop_tst_prtest/bin/tests/Linux.x64.Checked/Tests/Core_Root/corerun
11:35:59                
11:35:59                ./VectorExp_ro.sh: line 248: 117174 Aborted                 (core dumped) $_DebuggerFullPath "$CORE_ROOT/corerun" $ExePath $CLRTestExecutionArguments
11:35:59                Expected: 100
11:35:59                Actual: 134
11:35:59                END EXECUTION - FAILED
```

Examples from test PR https://github.com/dotnet/coreclr/pull/18611:
- https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_checked_ubuntu_innerloop_tst_prtest/4533/consoleFull#-372034708f66db340-b3cd-4e23-8190-9b52cb916333
- https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_checked_osx10.12_innerloop_tst_prtest/4117/consoleFull#692939362f66db340-b3cd-4e23-8190-9b52cb916333
- https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_checked_centos7.1_innerloop_tst_prtest/4492/consoleFull#1121768594f66db340-b3cd-4e23-8190-9b52cb916333

Seems to repro consistently at the moment seems unrelated to tiering and other changes in the PR above. Use last commit from PR above to repro it may also repro with the equivalent environment variables. In one run `arg-&gt;gtOper == GT_COMMA`.</Description>
    <Title_Description>Assertion failure on Unixes in JIT/SIMD/VectorExp_ro with tiering enabled ```
11:35:59 FAILED   - JIT/SIMD/VectorExp_ro/VectorExp_ro.sh
11:35:59                BEGIN EXECUTION
11:35:59                /mnt/j/workspace/dotnet_coreclr/master/x64_checked_ubuntu_innerloop_tst_prtest/bin/tests/Linux.x64.Checked/Tests/Core_Root/corerun VectorExp_ro.exe
11:35:59                
11:35:59 
               Assert failure(PID 117174 [0x0001c9b6] Thread: 117174 [0x1c9b6]): Assertion failed 'arg-&gt;OperGet() == GT_LCL_VAR' in 'VectorExpTest`1[Int64][System.Int64]:VectorExp(structlonglonglong):int' (IL size 148)
11:35:59                
11:35:59                    File: /mnt/j/workspace/dotnet_coreclr/master/x64_checked_ubuntu_innerloop_prtest/src/jit/morph.cpp Line: 4628
11:35:59                    Image: /mnt/j/workspace/dotnet_coreclr/master/x64_checked_ubuntu_innerloop_tst_prtest/bin/tests/Linux.x64.Checked/Tests/Core_Root/corerun
11:35:59                
11:35:59                ./VectorExp_ro.sh: line 248: 117174 Aborted                 (core dumped) $_DebuggerFullPath "$CORE_ROOT/corerun" $ExePath $CLRTestExecutionArguments
11:35:59                Expected: 100
11:35:59                Actual: 134
11:35:59                END EXECUTION - FAILED
```

Examples from test PR https://github.com/dotnet/coreclr/pull/18611:
- https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_checked_ubuntu_innerloop_tst_prtest/4533/consoleFull#-372034708f66db340-b3cd-4e23-8190-9b52cb916333
- https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_checked_osx10.12_innerloop_tst_prtest/4117/consoleFull#692939362f66db340-b3cd-4e23-8190-9b52cb916333
- https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_checked_centos7.1_innerloop_tst_prtest/4492/consoleFull#1121768594f66db340-b3cd-4e23-8190-9b52cb916333

Seems to repro consistently at the moment seems unrelated to tiering and other changes in the PR above. Use last commit from PR above to repro it may also repro with the equivalent environment variables. In one run `arg-&gt;gtOper == GT_COMMA`.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>kouvel</Assignee>
    <CreatedAt>16/07/2018 7:38:47 PM +00:00</CreatedAt>
    <ClosedAt>26/07/2018 10:39:43 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18944</IssueLabelID>
    <Title>LSRA: Consider a stress mode that trashes registers</Title>
    <Description>The issue https://github.com/dotnet/coreclr/issues/18943 is a case where it appears a register is being incorrectly copied to the wrong register before its intended use. If we had a `COMPlus_JitStressRegs` mode that would write some trash value to each register when it goes dead a case like this might have been caught.

category:implementation
theme:register-allocator
skill-level:beginner
cost:small</Description>
    <Title_Description>LSRA: Consider a stress mode that trashes registers The issue https://github.com/dotnet/coreclr/issues/18943 is a case where it appears a register is being incorrectly copied to the wrong register before its intended use. If we had a `COMPlus_JitStressRegs` mode that would write some trash value to each register when it goes dead a case like this might have been caught.

category:implementation
theme:register-allocator
skill-level:beginner
cost:small</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
    <CreatedAt>16/07/2018 7:37:05 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18943</IssueLabelID>
    <Title>Inconsistent reg assignment for tailcall Stub Addr Arg</Title>
    <Description>`fgMorphTailCall()` puts `REG_R11` on the node that is created by `Compiler::fgGetStubAddrArg()` but in `Lowering` the `PUTARG_REG` for this node puts the value in `REG_R8`. This results in the following in codegen:
```
Generating: N071 (  3 10) [000028] ------------        t28 =    CNS_INT(h) long   0x7ffa8aa20020 ftn REG r11 $c2
IN0010:        mov      r11 0x7FFA8AA20020
                                                             /--*  t28    long   
Generating: N073 (??????) [000063] ------------        t63 = *  PUTARG_REG long   REG r8
IN0011:        mov      r8 r11
```
It is apparently the case that r11 is the correct register but the argEntry gets r8 which is what `Lowering` uses. As it happens r11 is still valid at the call but there is no guarantee that will be the case and the `mov` is apparently unnecessary.</Description>
    <Title_Description>Inconsistent reg assignment for tailcall Stub Addr Arg `fgMorphTailCall()` puts `REG_R11` on the node that is created by `Compiler::fgGetStubAddrArg()` but in `Lowering` the `PUTARG_REG` for this node puts the value in `REG_R8`. This results in the following in codegen:
```
Generating: N071 (  3 10) [000028] ------------        t28 =    CNS_INT(h) long   0x7ffa8aa20020 ftn REG r11 $c2
IN0010:        mov      r11 0x7FFA8AA20020
                                                             /--*  t28    long   
Generating: N073 (??????) [000063] ------------        t63 = *  PUTARG_REG long   REG r8
IN0011:        mov      r8 r11
```
It is apparently the case that r11 is the correct register but the argEntry gets r8 which is what `Lowering` uses. As it happens r11 is still valid at the call but there is no guarantee that will be the case and the `mov` is apparently unnecessary.</Title_Description>
    <Label>arch-x64</Label>
    <Assignee>AndyAyersMS</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18937</IssueLabelID>
    <Title>Assert failure in JIT.Methodical.xxobj.ldobj._il_relldobj_V._il_relldobj_V 'arg0VN == VNNormVal(arg0VN)'</Title>
    <Description>Found this regression introduced between [Build #9949 (Jul 13 2018 11:03:21 AM)](https://ci.dot.net/job/dotnet_coreclr/job/master/view/Windows_NT/job/checked_windows_nt/9949/) and [Build #9950 (Jul 13 2018 1:21:43 PM)](https://ci.dot.net/job/dotnet_coreclr/job/master/view/Windows_NT/job/checked_windows_nt/9950/) which corresponds to 

Changes: 
1. JIT: optimize some cases of unused structs (#18819) (commit: dc7492e)
```
               BEGIN EXECUTION
               /ssd/j/workspace/dotnet_coreclr/master/arm_cross_checked_ubuntu_tst/bin/tests/Linux.arm.Checked/Tests/Core_Root/corerun _il_relldobj_V.exe
               
               Assert failure(PID 10489 [0x000028f9] Thread: 10489 [0x28f9]): Assertion failed 'arg0VN == VNNormVal(arg0VN)' in 'JitTest.Test:Main():int' (IL size 338)
               
                   File: /mnt/j/workspace/dotnet_coreclr/master/arm_cross_checked_ubuntu/src/jit/valuenum.cpp Line: 1010
                   Image: /ssd/j/workspace/dotnet_coreclr/master/arm_cross_checked_ubuntu_tst/bin/tests/Linux.arm.Checked/Tests/Core_Root/corerun
               
               ./_il_relldobj_V.sh: line 244: 10489 Aborted                 $_DebuggerFullPath "$CORE_ROOT/corerun" $ExePath $CLRTestExecutionArguments
               Expected: 100
               Actual: 134
               END EXECUTION - FAILED
```
Reproduced on Windows and Linux x64 and arm</Description>
    <Title_Description>Assert failure in JIT.Methodical.xxobj.ldobj._il_relldobj_V._il_relldobj_V 'arg0VN == VNNormVal(arg0VN)' Found this regression introduced between [Build #9949 (Jul 13 2018 11:03:21 AM)](https://ci.dot.net/job/dotnet_coreclr/job/master/view/Windows_NT/job/checked_windows_nt/9949/) and [Build #9950 (Jul 13 2018 1:21:43 PM)](https://ci.dot.net/job/dotnet_coreclr/job/master/view/Windows_NT/job/checked_windows_nt/9950/) which corresponds to 

Changes: 
1. JIT: optimize some cases of unused structs (#18819) (commit: dc7492e)
```
               BEGIN EXECUTION
               /ssd/j/workspace/dotnet_coreclr/master/arm_cross_checked_ubuntu_tst/bin/tests/Linux.arm.Checked/Tests/Core_Root/corerun _il_relldobj_V.exe
               
               Assert failure(PID 10489 [0x000028f9] Thread: 10489 [0x28f9]): Assertion failed 'arg0VN == VNNormVal(arg0VN)' in 'JitTest.Test:Main():int' (IL size 338)
               
                   File: /mnt/j/workspace/dotnet_coreclr/master/arm_cross_checked_ubuntu/src/jit/valuenum.cpp Line: 1010
                   Image: /ssd/j/workspace/dotnet_coreclr/master/arm_cross_checked_ubuntu_tst/bin/tests/Linux.arm.Checked/Tests/Core_Root/corerun
               
               ./_il_relldobj_V.sh: line 244: 10489 Aborted                 $_DebuggerFullPath "$CORE_ROOT/corerun" $ExePath $CLRTestExecutionArguments
               Expected: 100
               Actual: 134
               END EXECUTION - FAILED
```
Reproduced on Windows and Linux x64 and arm</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>pgavlin</Assignee>
    <CreatedAt>16/07/2018 4:35:56 PM +00:00</CreatedAt>
    <ClosedAt>17/07/2018 1:48:25 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18934</IssueLabelID>
    <Title>[JIT] Emitted bounds check comparing a constant index against a constant length</Title>
    <Description>From #18926 the JIT mostly does an impressively good job of optimizing this code:
```cs
	public class SpanTest
	{
		private struct Data { public int a b c d; }
		private static Data _data = default;

		public void IncrementA() =&gt; IncrementWrapper(MemoryMarshal.CreateSpan(ref _data.a 4));
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static void IncrementWrapper(Span&lt;int&gt; span)
		{
			if ((uint)span.Length &lt; 4) throw new IndexOutOfRangeException();
			Increment(ref span[0]);
		}
		private static void Increment(ref int val) =&gt; val++;
	}
```

```asm
TestHarness.SpanTest.IncrementA()
	mov     rcx7FFBF8E206B0h
	mov     edx5
	call    coreclr!coreclr_shutdown_2+0x10560
	mov     rax1A0E5407108h
	mov     raxqword ptr [rax]
	add     rax8
	mov     edx4 ;&lt;--------
	cmp     edx0 ;&lt;--------
	jbe     00007ffb`f8d627da
	inc     dword ptr [rax]
	add     rsp28h
	ret
```

That... seems like a rather easy bounds check to cut out.

category:cq
theme:bounds-checks
skill-level:intermediate
cost:small</Description>
    <Title_Description>[JIT] Emitted bounds check comparing a constant index against a constant length From #18926 the JIT mostly does an impressively good job of optimizing this code:
```cs
	public class SpanTest
	{
		private struct Data { public int a b c d; }
		private static Data _data = default;

		public void IncrementA() =&gt; IncrementWrapper(MemoryMarshal.CreateSpan(ref _data.a 4));
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static void IncrementWrapper(Span&lt;int&gt; span)
		{
			if ((uint)span.Length &lt; 4) throw new IndexOutOfRangeException();
			Increment(ref span[0]);
		}
		private static void Increment(ref int val) =&gt; val++;
	}
```

```asm
TestHarness.SpanTest.IncrementA()
	mov     rcx7FFBF8E206B0h
	mov     edx5
	call    coreclr!coreclr_shutdown_2+0x10560
	mov     rax1A0E5407108h
	mov     raxqword ptr [rax]
	add     rax8
	mov     edx4 ;&lt;--------
	cmp     edx0 ;&lt;--------
	jbe     00007ffb`f8d627da
	inc     dword ptr [rax]
	add     rsp28h
	ret
```

That... seems like a rather easy bounds check to cut out.

category:cq
theme:bounds-checks
skill-level:intermediate
cost:small</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
    <CreatedAt>16/07/2018 4:07:29 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18926</IssueLabelID>
    <Title>Hardware Intrinsics: Reading out SSE vector values without unsafe or Sse4.1?</Title>
    <Description>Loading values into a Vector128&lt;&gt; is easy enough lots of safe options there. But my options seem rather limited when it comes to reading them back out again... the only choices I've found are `Sse41.Extract` or `Sse.Store` with an `unsafe` pointer parameter. Is there any safe option that doesn't affect minimum hardware requirements?</Description>
    <Title_Description>Hardware Intrinsics: Reading out SSE vector values without unsafe or Sse4.1? Loading values into a Vector128&lt;&gt; is easy enough lots of safe options there. But my options seem rather limited when it comes to reading them back out again... the only choices I've found are `Sse41.Extract` or `Sse.Store` with an `unsafe` pointer parameter. Is there any safe option that doesn't affect minimum hardware requirements?</Title_Description>
    <Label>area-System.Runtime</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>15/07/2018 7:36:05 PM +00:00</CreatedAt>
    <ClosedAt>9/12/2018 7:42:39 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18925</IssueLabelID>
    <Title>Hardware Intrinsics:  Non-volatile xmm regs unnecessarily spilled to stack</Title>
    <Description>Even though my code only actually needs a total of 4 SSE registers in some cases the JIT is deciding to use `xmm6``xmm7` and `xmm8` spilling them to the stack.

```asm
DelimitedFileParser.SpanXxHash32.SSEImpl(System.ReadOnlySpan`1&lt;Byte&gt; ByRef)
	sub     rsp68h
	vmovaps xmmword ptr [rsp+50h]xmm6
	vmovaps xmmword ptr [rsp+40h]xmm7
	vmovaps xmmword ptr [rsp+30h]xmm8
	xor     eaxeax
	mov     qword ptr [rsp+20h]rax
	mov     qword ptr [rsp+28h]rax
	mov     rdxrcx
;				var vals = Sse2.SetVector128(0 - PRIME32_1 0 PRIME32_2 PRIME32_1 + PRIME32_2);
	xor     ecxecx
	vmovd   xmm0ecx
	mov     ecx85EBCA77h
	vmovd   xmm1ecx
	mov     ecx24234428h
	vmovd   xmm2ecx
	vpunpckldq xmm2xmm2xmm0
	mov     ecx61C8864Fh
	vmovd   xmm0ecx
	vpunpckldq xmm1xmm1xmm0
	vpunpckldq xmm6xmm2xmm1
;				var prime32_1 = Sse2.SetAllVector128(PRIME32_1);
	mov     ecx9E3779B1h
	vmovd   xmm0ecx
	vpshufd xmm7xmm00
;				var prime32_2 = Sse2.SetAllVector128(PRIME32_2);
	mov     ecx85EBCA77h
	vmovd   xmm0ecx
	vpshufd xmm8xmm00
	lea     rcx[rsp+20h]
	call    DelimitedFileParser.SpanXxHash32.TakeFrom[[System.Runtime.Intrinsics.Vector128`1[[System.UInt32 System.Private.CoreLib]] System.Private.CoreLib][System.Byte System.Private.CoreLib]](System.ReadOnlySpan`1&lt;Byte&gt; ByRef)
	cmp     dword ptr [rsp+28h]0
	jne     M14_L00
;				if (vecBuff.IsEmpty) { return PRIME32_5; }
;				                       ^^^^^^^^^^^^^^^^^
	mov     eax165667B1h
	vmovaps xmm6xmmword ptr [rsp+50h]
	vmovaps xmm7xmmword ptr [rsp+40h]
	vmovaps xmm8xmmword ptr [rsp+30h]
	add     rsp68h
	ret
;				for (int i = 0; i &lt; vecBuff.Length; i++)
;				     ^^^^^^^^^
M14_L00
	xor     eaxeax
	cmp     dword ptr [rsp+28h]0
	jle     M14_L02
;					var buffVals = vecBuff[i];
M14_L01
	mov     rdxqword ptr [rsp+20h]
	movsxd  rcxeax
	shl     rcx4
	vmovupd xmm0xmmword ptr [rdx+rcx]
;					var buffMult = Sse.StaticCast&lt;int uint&gt;(Sse41.MultiplyLow(
;											Sse.StaticCast&lt;uint int&gt;(buffVals)
;											Sse.StaticCast&lt;uint int&gt;(prime32_2)));
	vpmulld xmm0xmm0xmm8
;					vals = Sse2.Add(vals buffMult);
	vpaddd  xmm6xmm6xmm0
;					var toTheLeft = Sse2.ShiftLeftLogical(vals 13);
	vpslld  xmm0xmm60Dh
;					var toTheRight = Sse2.ShiftRightLogical(vals 32 - 13);
	vpsrld  xmm1xmm613h
;					vals = Sse2.Or(toTheLeft toTheRight);
	vpor    xmm6xmm0xmm1
;					vals = Sse.StaticCast&lt;int uint&gt;(Sse41.MultiplyLow(
;											Sse.StaticCast&lt;uint int&gt;(vals)
;											Sse.StaticCast&lt;uint int&gt;(prime32_1)));
	vpmulld xmm6xmm6xmm7
;				for (int i = 0; i &lt; vecBuff.Length; i++)
;				                                    ^^^
	inc     eax
	cmp     eaxdword ptr [rsp+28h]
	jl      M14_L01
;				uint v1 = Sse41.Extract(vals 0);
M14_L02
	vpextrd eaxxmm60
;				uint v2 = Sse41.Extract(vals 1);
	vpextrd edxxmm61
;				uint v3 = Sse41.Extract(vals 2);
	vpextrd ecxxmm62
;				uint v4 = Sse41.Extract(vals 3);
	vpextrd r8dxmm63
;				return MergeValues(v1 v2 v3 v4);
	rol     eax1
	rol     edx7
	add     eaxedx
	rol     ecx0Ch
	add     eaxecx
	rol     r8d12h
	add     eaxr8d
	vmovaps xmm6xmmword ptr [rsp+50h]
	vmovaps xmm7xmmword ptr [rsp+40h]
	vmovaps xmm8xmmword ptr [rsp+30h]
	add     rsp68h
	ret
```
Full code: [SpanXxHash32.cs.txt](https://github.com/dotnet/coreclr/files/2195999/SpanXxHash32.cs.txt)

</Description>
    <Title_Description>Hardware Intrinsics:  Non-volatile xmm regs unnecessarily spilled to stack Even though my code only actually needs a total of 4 SSE registers in some cases the JIT is deciding to use `xmm6``xmm7` and `xmm8` spilling them to the stack.

```asm
DelimitedFileParser.SpanXxHash32.SSEImpl(System.ReadOnlySpan`1&lt;Byte&gt; ByRef)
	sub     rsp68h
	vmovaps xmmword ptr [rsp+50h]xmm6
	vmovaps xmmword ptr [rsp+40h]xmm7
	vmovaps xmmword ptr [rsp+30h]xmm8
	xor     eaxeax
	mov     qword ptr [rsp+20h]rax
	mov     qword ptr [rsp+28h]rax
	mov     rdxrcx
;				var vals = Sse2.SetVector128(0 - PRIME32_1 0 PRIME32_2 PRIME32_1 + PRIME32_2);
	xor     ecxecx
	vmovd   xmm0ecx
	mov     ecx85EBCA77h
	vmovd   xmm1ecx
	mov     ecx24234428h
	vmovd   xmm2ecx
	vpunpckldq xmm2xmm2xmm0
	mov     ecx61C8864Fh
	vmovd   xmm0ecx
	vpunpckldq xmm1xmm1xmm0
	vpunpckldq xmm6xmm2xmm1
;				var prime32_1 = Sse2.SetAllVector128(PRIME32_1);
	mov     ecx9E3779B1h
	vmovd   xmm0ecx
	vpshufd xmm7xmm00
;				var prime32_2 = Sse2.SetAllVector128(PRIME32_2);
	mov     ecx85EBCA77h
	vmovd   xmm0ecx
	vpshufd xmm8xmm00
	lea     rcx[rsp+20h]
	call    DelimitedFileParser.SpanXxHash32.TakeFrom[[System.Runtime.Intrinsics.Vector128`1[[System.UInt32 System.Private.CoreLib]] System.Private.CoreLib][System.Byte System.Private.CoreLib]](System.ReadOnlySpan`1&lt;Byte&gt; ByRef)
	cmp     dword ptr [rsp+28h]0
	jne     M14_L00
;				if (vecBuff.IsEmpty) { return PRIME32_5; }
;				                       ^^^^^^^^^^^^^^^^^
	mov     eax165667B1h
	vmovaps xmm6xmmword ptr [rsp+50h]
	vmovaps xmm7xmmword ptr [rsp+40h]
	vmovaps xmm8xmmword ptr [rsp+30h]
	add     rsp68h
	ret
;				for (int i = 0; i &lt; vecBuff.Length; i++)
;				     ^^^^^^^^^
M14_L00
	xor     eaxeax
	cmp     dword ptr [rsp+28h]0
	jle     M14_L02
;					var buffVals = vecBuff[i];
M14_L01
	mov     rdxqword ptr [rsp+20h]
	movsxd  rcxeax
	shl     rcx4
	vmovupd xmm0xmmword ptr [rdx+rcx]
;					var buffMult = Sse.StaticCast&lt;int uint&gt;(Sse41.MultiplyLow(
;											Sse.StaticCast&lt;uint int&gt;(buffVals)
;											Sse.StaticCast&lt;uint int&gt;(prime32_2)));
	vpmulld xmm0xmm0xmm8
;					vals = Sse2.Add(vals buffMult);
	vpaddd  xmm6xmm6xmm0
;					var toTheLeft = Sse2.ShiftLeftLogical(vals 13);
	vpslld  xmm0xmm60Dh
;					var toTheRight = Sse2.ShiftRightLogical(vals 32 - 13);
	vpsrld  xmm1xmm613h
;					vals = Sse2.Or(toTheLeft toTheRight);
	vpor    xmm6xmm0xmm1
;					vals = Sse.StaticCast&lt;int uint&gt;(Sse41.MultiplyLow(
;											Sse.StaticCast&lt;uint int&gt;(vals)
;											Sse.StaticCast&lt;uint int&gt;(prime32_1)));
	vpmulld xmm6xmm6xmm7
;				for (int i = 0; i &lt; vecBuff.Length; i++)
;				                                    ^^^
	inc     eax
	cmp     eaxdword ptr [rsp+28h]
	jl      M14_L01
;				uint v1 = Sse41.Extract(vals 0);
M14_L02
	vpextrd eaxxmm60
;				uint v2 = Sse41.Extract(vals 1);
	vpextrd edxxmm61
;				uint v3 = Sse41.Extract(vals 2);
	vpextrd ecxxmm62
;				uint v4 = Sse41.Extract(vals 3);
	vpextrd r8dxmm63
;				return MergeValues(v1 v2 v3 v4);
	rol     eax1
	rol     edx7
	add     eaxedx
	rol     ecx0Ch
	add     eaxecx
	rol     r8d12h
	add     eaxr8d
	vmovaps xmm6xmmword ptr [rsp+50h]
	vmovaps xmm7xmmword ptr [rsp+40h]
	vmovaps xmm8xmmword ptr [rsp+30h]
	add     rsp68h
	ret
```
Full code: [SpanXxHash32.cs.txt](https://github.com/dotnet/coreclr/files/2195999/SpanXxHash32.cs.txt)

</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
    <CreatedAt>15/07/2018 6:54:18 PM +00:00</CreatedAt>
    <ClosedAt>16/07/2018 5:17:46 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18920</IssueLabelID>
    <Title>Clean coreclr build incurs ~100 warnings from R2RDump.csproj</Title>
    <Description>```
c:\Users\stoub\Source\repos\coreclr\src\tools\r2rdump\R2RDump.csproj : warning NU1701: Package 'System.CommandLine 0.1.
0-e160119-1' was restored using '.NETFrameworkVersion=v4.6.1' instead of the project target framework '.NETCoreAppVer
sion=v2.0'. This package may not be fully compatible with your project. [c:\Users\stoub\Source\repos\coreclr\src\build.
proj]
c:\Users\stoub\Source\repos\coreclr\src\tools\r2rdump\R2RDump.csproj : warning NU1701: Package 'System.CommandLine 0.1.
0-e160119-1' was restored using '.NETFrameworkVersion=v4.6.1' instead of the project target framework '.NETCoreAppVer
sion=v2.0'. This package may not be fully compatible with your project. [c:\Users\stoub\Source\repos\coreclr\src\build.
proj]
c:\Users\stoub\Source\repos\coreclr\src\tools\r2rdump\R2RDump.csproj : warning NU1701: Package 'System.CommandLine 0.1.
0-e160119-1' was restored using '.NETFrameworkVersion=v4.6.1' instead of the project target framework '.NETCoreAppVer
sion=v2.0'. This package may not be fully compatible with your project. [c:\Users\stoub\Source\repos\coreclr\src\build.
proj]
Amd64\UnwindInfo.cs(7121): warning CS3003: Type of 'UnwindInfo.PersonalityRoutineRVA' is not CLS-compliant [c:\Users\s
toub\Source\repos\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCInfo.cs(3725): warning CS3003: Type of 'GcInfo.InterruptibleRange.StartOffset' is not CLS-compliant [c:\Users\stoub\
Source\repos\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCInfo.cs(3825): warning CS3003: Type of 'GcInfo.InterruptibleRange.StopOffset' is not CLS-compliant [c:\Users\stoub\S
ource\repos\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCInfo.cs(3944): warning CS3001: Argument type 'uint' is not CLS-compliant [c:\Users\stoub\Source\repos\coreclr\src\to
ols\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCInfo.cs(3956): warning CS3001: Argument type 'uint' is not CLS-compliant [c:\Users\stoub\Source\repos\coreclr\src\to
ols\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCInfo.cs(11321): warning CS3003: Type of 'GcInfo.ValidRangeStart' is not CLS-compliant [c:\Users\stoub\Source\repos\c
oreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RReader.cs(8424): warning CS3003: Type of 'R2RReader.Machine' is not CLS-compliant [c:\Users\stoub\Source\repos\core
clr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCInfo.cs(11421): warning CS3003: Type of 'GcInfo.ValidRangeEnd' is not CLS-compliant [c:\Users\stoub\Source\repos\cor
eclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RReader.cs(9022): warning CS3003: Type of 'R2RReader.ImageBase' is not CLS-compliant [c:\Users\stoub\Source\repos\co
reclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCInfo.cs(11921): warning CS3003: Type of 'GcInfo.StackBaseRegister' is not CLS-compliant [c:\Users\stoub\Source\repos
\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCInfo.cs(12021): warning CS3003: Type of 'GcInfo.SizeOfEditAndContinuePreservedArea' is not CLS-compliant [c:\Users\s
toub\Source\repos\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCInfo.cs(12221): warning CS3003: Type of 'GcInfo.SizeOfStackOutgoingAndScratchArea' is not CLS-compliant [c:\Users\st
oub\Source\repos\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCInfo.cs(12321): warning CS3003: Type of 'GcInfo.NumSafePoints' is not CLS-compliant [c:\Users\stoub\Source\repos\cor
eclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCInfo.cs(12421): warning CS3003: Type of 'GcInfo.NumInterruptibleRanges' is not CLS-compliant [c:\Users\stoub\Source\
repos\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RReader.cs(44764): warning CS3001: Argument type 'MetadataReader' is not CLS-compliant [c:\Users\stoub\Source\repos\
coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RReader.cs(44795): warning CS3001: Argument type 'TypeDefinitionHandle' is not CLS-compliant [c:\Users\stoub\Source\
repos\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RReader.cs(4621): warning CS3003: Type of 'FixupCell.TableIndex' is not CLS-compliant [c:\Users\stoub\Source\repos\c
oreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RReader.cs(5221): warning CS3003: Type of 'FixupCell.CellOffset' is not CLS-compliant [c:\Users\stoub\Source\repos\c
oreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RReader.cs(5431): warning CS3001: Argument type 'uint' is not CLS-compliant [c:\Users\stoub\Source\repos\coreclr\src
\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RReader.cs(5448): warning CS3001: Argument type 'uint' is not CLS-compliant [c:\Users\stoub\Source\repos\coreclr\src
\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RMethod.cs(11640): warning CS3003: Type of 'R2RMethod.Signature' is not CLS-compliant [c:\Users\stoub\Source\repos\c
oreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RMethod.cs(12621): warning CS3003: Type of 'R2RMethod.Token' is not CLS-compliant [c:\Users\stoub\Source\repos\corec
lr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RMethod.cs(13121): warning CS3003: Type of 'R2RMethod.Rid' is not CLS-compliant [c:\Users\stoub\Source\repos\coreclr
\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RHeader.cs(2427): warning CS3003: Type of 'R2RHeader.READYTORUN_SIGNATURE' is not CLS-compliant [c:\Users\stoub\Sour
ce\repos\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RHeader.cs(4021): warning CS3003: Type of 'R2RHeader.Signature' is not CLS-compliant [c:\Users\stoub\Source\repos\co
reclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RHeader.cs(4523): warning CS3003: Type of 'R2RHeader.MajorVersion' is not CLS-compliant [c:\Users\stoub\Source\repos
\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RHeader.cs(4623): warning CS3003: Type of 'R2RHeader.MinorVersion' is not CLS-compliant [c:\Users\stoub\Source\repos
\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RHeader.cs(5221): warning CS3003: Type of 'R2RHeader.Flags' is not CLS-compliant [c:\Users\stoub\Source\repos\corecl
r\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RMethod.cs(16813): warning CS3008: Identifier '__Canon' is not CLS-compliant [c:\Users\stoub\Source\repos\coreclr\sr
c\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RMethod.cs(19341): warning CS3001: Argument type 'MetadataReader' is not CLS-compliant [c:\Users\stoub\Source\repos\
coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RMethod.cs(19356): warning CS3001: Argument type 'uint' is not CLS-compliant [c:\Users\stoub\Source\repos\coreclr\sr
c\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RMethod.cs(193122): warning CS3001: Argument type 'uint[]' is not CLS-compliant [c:\Users\stoub\Source\repos\coreclr
\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
Amd64\UnwindInfo.cs(4221): warning CS3003: Type of 'UnwindCode.FrameOffset' is not CLS-compliant [c:\Users\stoub\Sourc
e\repos\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCSlotTable.cs(5321): warning CS3003: Type of 'GcSlotTable.NumRegisters' is not CLS-compliant [c:\Users\stoub\Source\r
epos\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCSlotTable.cs(5421): warning CS3003: Type of 'GcSlotTable.NumStackSlots' is not CLS-compliant [c:\Users\stoub\Source\
repos\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCSlotTable.cs(5521): warning CS3003: Type of 'GcSlotTable.NumUntracked' is not CLS-compliant [c:\Users\stoub\Source\r
epos\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCSlotTable.cs(5621): warning CS3003: Type of 'GcSlotTable.NumSlots' is not CLS-compliant [c:\Users\stoub\Source\repos
\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RImportSection.cs(3725): warning CS3003: Type of 'R2RImportSection.ImportSectionEntry.SignatureRVA' is not CLS-compl
iant [c:\Users\stoub\Source\repos\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\bu
ild.proj]
R2RImportSection.cs(3975): warning CS3001: Argument type 'uint' is not CLS-compliant [c:\Users\stoub\Source\repos\core
clr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCInfo.cs(12527): warning CS3003: Type of 'GcInfo.SafePointOffsets' is not CLS-compliant [c:\Users\stoub\Source\repos\
coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCSlotTable.cs(6150): warning CS3001: Argument type 'Machine' is not CLS-compliant [c:\Users\stoub\Source\repos\corecl
r\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RImportSection.cs(93217): warning CS3001: Argument type 'Machine' is not CLS-compliant [c:\Users\stoub\Source\repos\
coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RImportSection.cs(93233): warning CS3001: Argument type 'ushort' is not CLS-compliant [c:\Users\stoub\Source\repos\c
oreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCInfo.cs(13657): warning CS3001: Argument type 'Machine' is not CLS-compliant [c:\Users\stoub\Source\repos\coreclr\sr
c\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCInfo.cs(13673): warning CS3001: Argument type 'ushort' is not CLS-compliant [c:\Users\stoub\Source\repos\coreclr\src
\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
CSC : warning CS8002: Referenced assembly 'System.CommandLine Version=1.0.0.0 Culture=neutral PublicKeyToken=null' d
oes not have a strong name. [c:\Users\stoub\Source\repos\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Sour
ce\repos\coreclr\src\build.proj]
c:\Users\stoub\Source\repos\coreclr\src\tools\r2rdump\R2RDump.csproj : warning NU1701: Package 'System.CommandLine 0.1.
0-e160119-1' was restored using '.NETFrameworkVersion=v4.6.1' instead of the project target framework '.NETCoreAppVer
sion=v2.0'. This package may not be fully compatible with your project. [c:\Users\stoub\Source\repos\coreclr\src\build.
proj]
c:\Users\stoub\Source\repos\coreclr\src\tools\r2rdump\R2RDump.csproj : warning NU1701: Package 'System.CommandLine 0.1.
0-e160119-1' was restored using '.NETFrameworkVersion=v4.6.1' instead of the project target framework '.NETCoreAppVer
sion=v2.0'. This package may not be fully compatible with your project. [c:\Users\stoub\Source\repos\coreclr\src\build.
proj]
Amd64\UnwindInfo.cs(7121): warning CS3003: Type of 'UnwindInfo.PersonalityRoutineRVA' is not CLS-compliant [c:\Users\s
toub\Source\repos\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCInfo.cs(3725): warning CS3003: Type of 'GcInfo.InterruptibleRange.StartOffset' is not CLS-compliant [c:\Users\stoub\
Source\repos\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCInfo.cs(3825): warning CS3003: Type of 'GcInfo.InterruptibleRange.StopOffset' is not CLS-compliant [c:\Users\stoub\S
ource\repos\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCInfo.cs(3944): warning CS3001: Argument type 'uint' is not CLS-compliant [c:\Users\stoub\Source\repos\coreclr\src\to
ols\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCInfo.cs(3956): warning CS3001: Argument type 'uint' is not CLS-compliant [c:\Users\stoub\Source\repos\coreclr\src\to
ols\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCInfo.cs(11321): warning CS3003: Type of 'GcInfo.ValidRangeStart' is not CLS-compliant [c:\Users\stoub\Source\repos\c
oreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RReader.cs(8424): warning CS3003: Type of 'R2RReader.Machine' is not CLS-compliant [c:\Users\stoub\Source\repos\core
clr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCInfo.cs(11421): warning CS3003: Type of 'GcInfo.ValidRangeEnd' is not CLS-compliant [c:\Users\stoub\Source\repos\cor
eclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RReader.cs(9022): warning CS3003: Type of 'R2RReader.ImageBase' is not CLS-compliant [c:\Users\stoub\Source\repos\co
reclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCInfo.cs(11921): warning CS3003: Type of 'GcInfo.StackBaseRegister' is not CLS-compliant [c:\Users\stoub\Source\repos
\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCInfo.cs(12021): warning CS3003: Type of 'GcInfo.SizeOfEditAndContinuePreservedArea' is not CLS-compliant [c:\Users\s
toub\Source\repos\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCInfo.cs(12221): warning CS3003: Type of 'GcInfo.SizeOfStackOutgoingAndScratchArea' is not CLS-compliant [c:\Users\st
oub\Source\repos\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCInfo.cs(12321): warning CS3003: Type of 'GcInfo.NumSafePoints' is not CLS-compliant [c:\Users\stoub\Source\repos\cor
eclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCInfo.cs(12421): warning CS3003: Type of 'GcInfo.NumInterruptibleRanges' is not CLS-compliant [c:\Users\stoub\Source\
repos\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RReader.cs(44764): warning CS3001: Argument type 'MetadataReader' is not CLS-compliant [c:\Users\stoub\Source\repos\
coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RReader.cs(44795): warning CS3001: Argument type 'TypeDefinitionHandle' is not CLS-compliant [c:\Users\stoub\Source\
repos\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RReader.cs(4621): warning CS3003: Type of 'FixupCell.TableIndex' is not CLS-compliant [c:\Users\stoub\Source\repos\c
oreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RReader.cs(5221): warning CS3003: Type of 'FixupCell.CellOffset' is not CLS-compliant [c:\Users\stoub\Source\repos\c
oreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RReader.cs(5431): warning CS3001: Argument type 'uint' is not CLS-compliant [c:\Users\stoub\Source\repos\coreclr\src
\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RReader.cs(5448): warning CS3001: Argument type 'uint' is not CLS-compliant [c:\Users\stoub\Source\repos\coreclr\src
\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RMethod.cs(11640): warning CS3003: Type of 'R2RMethod.Signature' is not CLS-compliant [c:\Users\stoub\Source\repos\c
oreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RMethod.cs(12621): warning CS3003: Type of 'R2RMethod.Token' is not CLS-compliant [c:\Users\stoub\Source\repos\corec
lr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RMethod.cs(13121): warning CS3003: Type of 'R2RMethod.Rid' is not CLS-compliant [c:\Users\stoub\Source\repos\coreclr
\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RHeader.cs(2427): warning CS3003: Type of 'R2RHeader.READYTORUN_SIGNATURE' is not CLS-compliant [c:\Users\stoub\Sour
ce\repos\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RHeader.cs(4021): warning CS3003: Type of 'R2RHeader.Signature' is not CLS-compliant [c:\Users\stoub\Source\repos\co
reclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RHeader.cs(4523): warning CS3003: Type of 'R2RHeader.MajorVersion' is not CLS-compliant [c:\Users\stoub\Source\repos
\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RHeader.cs(4623): warning CS3003: Type of 'R2RHeader.MinorVersion' is not CLS-compliant [c:\Users\stoub\Source\repos
\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RHeader.cs(5221): warning CS3003: Type of 'R2RHeader.Flags' is not CLS-compliant [c:\Users\stoub\Source\repos\corecl
r\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RMethod.cs(16813): warning CS3008: Identifier '__Canon' is not CLS-compliant [c:\Users\stoub\Source\repos\coreclr\sr
c\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RMethod.cs(19341): warning CS3001: Argument type 'MetadataReader' is not CLS-compliant [c:\Users\stoub\Source\repos\
coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RMethod.cs(19356): warning CS3001: Argument type 'uint' is not CLS-compliant [c:\Users\stoub\Source\repos\coreclr\sr
c\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RMethod.cs(193122): warning CS3001: Argument type 'uint[]' is not CLS-compliant [c:\Users\stoub\Source\repos\coreclr
\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
Amd64\UnwindInfo.cs(4221): warning CS3003: Type of 'UnwindCode.FrameOffset' is not CLS-compliant [c:\Users\stoub\Sourc
e\repos\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCSlotTable.cs(5321): warning CS3003: Type of 'GcSlotTable.NumRegisters' is not CLS-compliant [c:\Users\stoub\Source\r
epos\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCSlotTable.cs(5421): warning CS3003: Type of 'GcSlotTable.NumStackSlots' is not CLS-compliant [c:\Users\stoub\Source\
repos\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCSlotTable.cs(5521): warning CS3003: Type of 'GcSlotTable.NumUntracked' is not CLS-compliant [c:\Users\stoub\Source\r
epos\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCSlotTable.cs(5621): warning CS3003: Type of 'GcSlotTable.NumSlots' is not CLS-compliant [c:\Users\stoub\Source\repos
\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RImportSection.cs(3725): warning CS3003: Type of 'R2RImportSection.ImportSectionEntry.SignatureRVA' is not CLS-compl
iant [c:\Users\stoub\Source\repos\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\bu
ild.proj]
R2RImportSection.cs(3975): warning CS3001: Argument type 'uint' is not CLS-compliant [c:\Users\stoub\Source\repos\core
clr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCInfo.cs(12527): warning CS3003: Type of 'GcInfo.SafePointOffsets' is not CLS-compliant [c:\Users\stoub\Source\repos\
coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCSlotTable.cs(6150): warning CS3001: Argument type 'Machine' is not CLS-compliant [c:\Users\stoub\Source\repos\corecl
r\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RImportSection.cs(93217): warning CS3001: Argument type 'Machine' is not CLS-compliant [c:\Users\stoub\Source\repos\
coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RImportSection.cs(93233): warning CS3001: Argument type 'ushort' is not CLS-compliant [c:\Users\stoub\Source\repos\c
oreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCInfo.cs(13657): warning CS3001: Argument type 'Machine' is not CLS-compliant [c:\Users\stoub\Source\repos\coreclr\sr
c\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCInfo.cs(13673): warning CS3001: Argument type 'ushort' is not CLS-compliant [c:\Users\stoub\Source\repos\coreclr\src
\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
CSC : warning CS8002: Referenced assembly 'System.CommandLine Version=1.0.0.0 Culture=neutral PublicKeyToken=null' d
oes not have a strong name. [c:\Users\stoub\Source\repos\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Sour
ce\repos\coreclr\src\build.proj]
```</Description>
    <Title_Description>Clean coreclr build incurs ~100 warnings from R2RDump.csproj ```
c:\Users\stoub\Source\repos\coreclr\src\tools\r2rdump\R2RDump.csproj : warning NU1701: Package 'System.CommandLine 0.1.
0-e160119-1' was restored using '.NETFrameworkVersion=v4.6.1' instead of the project target framework '.NETCoreAppVer
sion=v2.0'. This package may not be fully compatible with your project. [c:\Users\stoub\Source\repos\coreclr\src\build.
proj]
c:\Users\stoub\Source\repos\coreclr\src\tools\r2rdump\R2RDump.csproj : warning NU1701: Package 'System.CommandLine 0.1.
0-e160119-1' was restored using '.NETFrameworkVersion=v4.6.1' instead of the project target framework '.NETCoreAppVer
sion=v2.0'. This package may not be fully compatible with your project. [c:\Users\stoub\Source\repos\coreclr\src\build.
proj]
c:\Users\stoub\Source\repos\coreclr\src\tools\r2rdump\R2RDump.csproj : warning NU1701: Package 'System.CommandLine 0.1.
0-e160119-1' was restored using '.NETFrameworkVersion=v4.6.1' instead of the project target framework '.NETCoreAppVer
sion=v2.0'. This package may not be fully compatible with your project. [c:\Users\stoub\Source\repos\coreclr\src\build.
proj]
Amd64\UnwindInfo.cs(7121): warning CS3003: Type of 'UnwindInfo.PersonalityRoutineRVA' is not CLS-compliant [c:\Users\s
toub\Source\repos\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCInfo.cs(3725): warning CS3003: Type of 'GcInfo.InterruptibleRange.StartOffset' is not CLS-compliant [c:\Users\stoub\
Source\repos\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCInfo.cs(3825): warning CS3003: Type of 'GcInfo.InterruptibleRange.StopOffset' is not CLS-compliant [c:\Users\stoub\S
ource\repos\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCInfo.cs(3944): warning CS3001: Argument type 'uint' is not CLS-compliant [c:\Users\stoub\Source\repos\coreclr\src\to
ols\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCInfo.cs(3956): warning CS3001: Argument type 'uint' is not CLS-compliant [c:\Users\stoub\Source\repos\coreclr\src\to
ols\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCInfo.cs(11321): warning CS3003: Type of 'GcInfo.ValidRangeStart' is not CLS-compliant [c:\Users\stoub\Source\repos\c
oreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RReader.cs(8424): warning CS3003: Type of 'R2RReader.Machine' is not CLS-compliant [c:\Users\stoub\Source\repos\core
clr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCInfo.cs(11421): warning CS3003: Type of 'GcInfo.ValidRangeEnd' is not CLS-compliant [c:\Users\stoub\Source\repos\cor
eclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RReader.cs(9022): warning CS3003: Type of 'R2RReader.ImageBase' is not CLS-compliant [c:\Users\stoub\Source\repos\co
reclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCInfo.cs(11921): warning CS3003: Type of 'GcInfo.StackBaseRegister' is not CLS-compliant [c:\Users\stoub\Source\repos
\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCInfo.cs(12021): warning CS3003: Type of 'GcInfo.SizeOfEditAndContinuePreservedArea' is not CLS-compliant [c:\Users\s
toub\Source\repos\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCInfo.cs(12221): warning CS3003: Type of 'GcInfo.SizeOfStackOutgoingAndScratchArea' is not CLS-compliant [c:\Users\st
oub\Source\repos\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCInfo.cs(12321): warning CS3003: Type of 'GcInfo.NumSafePoints' is not CLS-compliant [c:\Users\stoub\Source\repos\cor
eclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCInfo.cs(12421): warning CS3003: Type of 'GcInfo.NumInterruptibleRanges' is not CLS-compliant [c:\Users\stoub\Source\
repos\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RReader.cs(44764): warning CS3001: Argument type 'MetadataReader' is not CLS-compliant [c:\Users\stoub\Source\repos\
coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RReader.cs(44795): warning CS3001: Argument type 'TypeDefinitionHandle' is not CLS-compliant [c:\Users\stoub\Source\
repos\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RReader.cs(4621): warning CS3003: Type of 'FixupCell.TableIndex' is not CLS-compliant [c:\Users\stoub\Source\repos\c
oreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RReader.cs(5221): warning CS3003: Type of 'FixupCell.CellOffset' is not CLS-compliant [c:\Users\stoub\Source\repos\c
oreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RReader.cs(5431): warning CS3001: Argument type 'uint' is not CLS-compliant [c:\Users\stoub\Source\repos\coreclr\src
\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RReader.cs(5448): warning CS3001: Argument type 'uint' is not CLS-compliant [c:\Users\stoub\Source\repos\coreclr\src
\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RMethod.cs(11640): warning CS3003: Type of 'R2RMethod.Signature' is not CLS-compliant [c:\Users\stoub\Source\repos\c
oreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RMethod.cs(12621): warning CS3003: Type of 'R2RMethod.Token' is not CLS-compliant [c:\Users\stoub\Source\repos\corec
lr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RMethod.cs(13121): warning CS3003: Type of 'R2RMethod.Rid' is not CLS-compliant [c:\Users\stoub\Source\repos\coreclr
\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RHeader.cs(2427): warning CS3003: Type of 'R2RHeader.READYTORUN_SIGNATURE' is not CLS-compliant [c:\Users\stoub\Sour
ce\repos\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RHeader.cs(4021): warning CS3003: Type of 'R2RHeader.Signature' is not CLS-compliant [c:\Users\stoub\Source\repos\co
reclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RHeader.cs(4523): warning CS3003: Type of 'R2RHeader.MajorVersion' is not CLS-compliant [c:\Users\stoub\Source\repos
\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RHeader.cs(4623): warning CS3003: Type of 'R2RHeader.MinorVersion' is not CLS-compliant [c:\Users\stoub\Source\repos
\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RHeader.cs(5221): warning CS3003: Type of 'R2RHeader.Flags' is not CLS-compliant [c:\Users\stoub\Source\repos\corecl
r\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RMethod.cs(16813): warning CS3008: Identifier '__Canon' is not CLS-compliant [c:\Users\stoub\Source\repos\coreclr\sr
c\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RMethod.cs(19341): warning CS3001: Argument type 'MetadataReader' is not CLS-compliant [c:\Users\stoub\Source\repos\
coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RMethod.cs(19356): warning CS3001: Argument type 'uint' is not CLS-compliant [c:\Users\stoub\Source\repos\coreclr\sr
c\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RMethod.cs(193122): warning CS3001: Argument type 'uint[]' is not CLS-compliant [c:\Users\stoub\Source\repos\coreclr
\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
Amd64\UnwindInfo.cs(4221): warning CS3003: Type of 'UnwindCode.FrameOffset' is not CLS-compliant [c:\Users\stoub\Sourc
e\repos\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCSlotTable.cs(5321): warning CS3003: Type of 'GcSlotTable.NumRegisters' is not CLS-compliant [c:\Users\stoub\Source\r
epos\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCSlotTable.cs(5421): warning CS3003: Type of 'GcSlotTable.NumStackSlots' is not CLS-compliant [c:\Users\stoub\Source\
repos\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCSlotTable.cs(5521): warning CS3003: Type of 'GcSlotTable.NumUntracked' is not CLS-compliant [c:\Users\stoub\Source\r
epos\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCSlotTable.cs(5621): warning CS3003: Type of 'GcSlotTable.NumSlots' is not CLS-compliant [c:\Users\stoub\Source\repos
\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RImportSection.cs(3725): warning CS3003: Type of 'R2RImportSection.ImportSectionEntry.SignatureRVA' is not CLS-compl
iant [c:\Users\stoub\Source\repos\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\bu
ild.proj]
R2RImportSection.cs(3975): warning CS3001: Argument type 'uint' is not CLS-compliant [c:\Users\stoub\Source\repos\core
clr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCInfo.cs(12527): warning CS3003: Type of 'GcInfo.SafePointOffsets' is not CLS-compliant [c:\Users\stoub\Source\repos\
coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCSlotTable.cs(6150): warning CS3001: Argument type 'Machine' is not CLS-compliant [c:\Users\stoub\Source\repos\corecl
r\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RImportSection.cs(93217): warning CS3001: Argument type 'Machine' is not CLS-compliant [c:\Users\stoub\Source\repos\
coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RImportSection.cs(93233): warning CS3001: Argument type 'ushort' is not CLS-compliant [c:\Users\stoub\Source\repos\c
oreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCInfo.cs(13657): warning CS3001: Argument type 'Machine' is not CLS-compliant [c:\Users\stoub\Source\repos\coreclr\sr
c\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCInfo.cs(13673): warning CS3001: Argument type 'ushort' is not CLS-compliant [c:\Users\stoub\Source\repos\coreclr\src
\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
CSC : warning CS8002: Referenced assembly 'System.CommandLine Version=1.0.0.0 Culture=neutral PublicKeyToken=null' d
oes not have a strong name. [c:\Users\stoub\Source\repos\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Sour
ce\repos\coreclr\src\build.proj]
c:\Users\stoub\Source\repos\coreclr\src\tools\r2rdump\R2RDump.csproj : warning NU1701: Package 'System.CommandLine 0.1.
0-e160119-1' was restored using '.NETFrameworkVersion=v4.6.1' instead of the project target framework '.NETCoreAppVer
sion=v2.0'. This package may not be fully compatible with your project. [c:\Users\stoub\Source\repos\coreclr\src\build.
proj]
c:\Users\stoub\Source\repos\coreclr\src\tools\r2rdump\R2RDump.csproj : warning NU1701: Package 'System.CommandLine 0.1.
0-e160119-1' was restored using '.NETFrameworkVersion=v4.6.1' instead of the project target framework '.NETCoreAppVer
sion=v2.0'. This package may not be fully compatible with your project. [c:\Users\stoub\Source\repos\coreclr\src\build.
proj]
Amd64\UnwindInfo.cs(7121): warning CS3003: Type of 'UnwindInfo.PersonalityRoutineRVA' is not CLS-compliant [c:\Users\s
toub\Source\repos\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCInfo.cs(3725): warning CS3003: Type of 'GcInfo.InterruptibleRange.StartOffset' is not CLS-compliant [c:\Users\stoub\
Source\repos\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCInfo.cs(3825): warning CS3003: Type of 'GcInfo.InterruptibleRange.StopOffset' is not CLS-compliant [c:\Users\stoub\S
ource\repos\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCInfo.cs(3944): warning CS3001: Argument type 'uint' is not CLS-compliant [c:\Users\stoub\Source\repos\coreclr\src\to
ols\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCInfo.cs(3956): warning CS3001: Argument type 'uint' is not CLS-compliant [c:\Users\stoub\Source\repos\coreclr\src\to
ols\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCInfo.cs(11321): warning CS3003: Type of 'GcInfo.ValidRangeStart' is not CLS-compliant [c:\Users\stoub\Source\repos\c
oreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RReader.cs(8424): warning CS3003: Type of 'R2RReader.Machine' is not CLS-compliant [c:\Users\stoub\Source\repos\core
clr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCInfo.cs(11421): warning CS3003: Type of 'GcInfo.ValidRangeEnd' is not CLS-compliant [c:\Users\stoub\Source\repos\cor
eclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RReader.cs(9022): warning CS3003: Type of 'R2RReader.ImageBase' is not CLS-compliant [c:\Users\stoub\Source\repos\co
reclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCInfo.cs(11921): warning CS3003: Type of 'GcInfo.StackBaseRegister' is not CLS-compliant [c:\Users\stoub\Source\repos
\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCInfo.cs(12021): warning CS3003: Type of 'GcInfo.SizeOfEditAndContinuePreservedArea' is not CLS-compliant [c:\Users\s
toub\Source\repos\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCInfo.cs(12221): warning CS3003: Type of 'GcInfo.SizeOfStackOutgoingAndScratchArea' is not CLS-compliant [c:\Users\st
oub\Source\repos\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCInfo.cs(12321): warning CS3003: Type of 'GcInfo.NumSafePoints' is not CLS-compliant [c:\Users\stoub\Source\repos\cor
eclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCInfo.cs(12421): warning CS3003: Type of 'GcInfo.NumInterruptibleRanges' is not CLS-compliant [c:\Users\stoub\Source\
repos\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RReader.cs(44764): warning CS3001: Argument type 'MetadataReader' is not CLS-compliant [c:\Users\stoub\Source\repos\
coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RReader.cs(44795): warning CS3001: Argument type 'TypeDefinitionHandle' is not CLS-compliant [c:\Users\stoub\Source\
repos\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RReader.cs(4621): warning CS3003: Type of 'FixupCell.TableIndex' is not CLS-compliant [c:\Users\stoub\Source\repos\c
oreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RReader.cs(5221): warning CS3003: Type of 'FixupCell.CellOffset' is not CLS-compliant [c:\Users\stoub\Source\repos\c
oreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RReader.cs(5431): warning CS3001: Argument type 'uint' is not CLS-compliant [c:\Users\stoub\Source\repos\coreclr\src
\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RReader.cs(5448): warning CS3001: Argument type 'uint' is not CLS-compliant [c:\Users\stoub\Source\repos\coreclr\src
\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RMethod.cs(11640): warning CS3003: Type of 'R2RMethod.Signature' is not CLS-compliant [c:\Users\stoub\Source\repos\c
oreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RMethod.cs(12621): warning CS3003: Type of 'R2RMethod.Token' is not CLS-compliant [c:\Users\stoub\Source\repos\corec
lr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RMethod.cs(13121): warning CS3003: Type of 'R2RMethod.Rid' is not CLS-compliant [c:\Users\stoub\Source\repos\coreclr
\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RHeader.cs(2427): warning CS3003: Type of 'R2RHeader.READYTORUN_SIGNATURE' is not CLS-compliant [c:\Users\stoub\Sour
ce\repos\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RHeader.cs(4021): warning CS3003: Type of 'R2RHeader.Signature' is not CLS-compliant [c:\Users\stoub\Source\repos\co
reclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RHeader.cs(4523): warning CS3003: Type of 'R2RHeader.MajorVersion' is not CLS-compliant [c:\Users\stoub\Source\repos
\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RHeader.cs(4623): warning CS3003: Type of 'R2RHeader.MinorVersion' is not CLS-compliant [c:\Users\stoub\Source\repos
\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RHeader.cs(5221): warning CS3003: Type of 'R2RHeader.Flags' is not CLS-compliant [c:\Users\stoub\Source\repos\corecl
r\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RMethod.cs(16813): warning CS3008: Identifier '__Canon' is not CLS-compliant [c:\Users\stoub\Source\repos\coreclr\sr
c\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RMethod.cs(19341): warning CS3001: Argument type 'MetadataReader' is not CLS-compliant [c:\Users\stoub\Source\repos\
coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RMethod.cs(19356): warning CS3001: Argument type 'uint' is not CLS-compliant [c:\Users\stoub\Source\repos\coreclr\sr
c\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RMethod.cs(193122): warning CS3001: Argument type 'uint[]' is not CLS-compliant [c:\Users\stoub\Source\repos\coreclr
\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
Amd64\UnwindInfo.cs(4221): warning CS3003: Type of 'UnwindCode.FrameOffset' is not CLS-compliant [c:\Users\stoub\Sourc
e\repos\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCSlotTable.cs(5321): warning CS3003: Type of 'GcSlotTable.NumRegisters' is not CLS-compliant [c:\Users\stoub\Source\r
epos\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCSlotTable.cs(5421): warning CS3003: Type of 'GcSlotTable.NumStackSlots' is not CLS-compliant [c:\Users\stoub\Source\
repos\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCSlotTable.cs(5521): warning CS3003: Type of 'GcSlotTable.NumUntracked' is not CLS-compliant [c:\Users\stoub\Source\r
epos\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCSlotTable.cs(5621): warning CS3003: Type of 'GcSlotTable.NumSlots' is not CLS-compliant [c:\Users\stoub\Source\repos
\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RImportSection.cs(3725): warning CS3003: Type of 'R2RImportSection.ImportSectionEntry.SignatureRVA' is not CLS-compl
iant [c:\Users\stoub\Source\repos\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\bu
ild.proj]
R2RImportSection.cs(3975): warning CS3001: Argument type 'uint' is not CLS-compliant [c:\Users\stoub\Source\repos\core
clr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCInfo.cs(12527): warning CS3003: Type of 'GcInfo.SafePointOffsets' is not CLS-compliant [c:\Users\stoub\Source\repos\
coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCSlotTable.cs(6150): warning CS3001: Argument type 'Machine' is not CLS-compliant [c:\Users\stoub\Source\repos\corecl
r\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RImportSection.cs(93217): warning CS3001: Argument type 'Machine' is not CLS-compliant [c:\Users\stoub\Source\repos\
coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
R2RImportSection.cs(93233): warning CS3001: Argument type 'ushort' is not CLS-compliant [c:\Users\stoub\Source\repos\c
oreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCInfo.cs(13657): warning CS3001: Argument type 'Machine' is not CLS-compliant [c:\Users\stoub\Source\repos\coreclr\sr
c\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
GCInfo.cs(13673): warning CS3001: Argument type 'ushort' is not CLS-compliant [c:\Users\stoub\Source\repos\coreclr\src
\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Source\repos\coreclr\src\build.proj]
CSC : warning CS8002: Referenced assembly 'System.CommandLine Version=1.0.0.0 Culture=neutral PublicKeyToken=null' d
oes not have a strong name. [c:\Users\stoub\Source\repos\coreclr\src\tools\r2rdump\R2RDump.csproj] [c:\Users\stoub\Sour
ce\repos\coreclr\src\build.proj]
```</Title_Description>
    <Label>area-ReadyToRun</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>15/07/2018 3:05:02 AM +00:00</CreatedAt>
    <ClosedAt>26/07/2018 6:19:22 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18914</IssueLabelID>
    <Title>[Windows/arm64] corefx System.Runtime.Tests test failure</Title>
    <Description>Happens in baseline and all JIT stress runs.

```
----- start 17:45:13.31 ===============  To repro directly: ===================================================== 
pushd C:\Users\robox\j\workspace\arm64_cross_c---c55e6c4b\_\fx\bin\tests\System.Runtime.Tests\netcoreapp-Windows_NT-Release-arm64\
set COMPlus_TieredCompilation=0
call C:\Users\robox\j\workspace\arm64_cross_c---c55e6c4b\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm64\dotnet.exe xunit.console.netcore.exe System.Runtime.Tests.dll  -xml testResults.xml -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonwindowstests  -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing
popd
===========================================================================================================

C:\Users\robox\j\workspace\arm64_cross_c---c55e6c4b\_\fx\bin\tests\System.Runtime.Tests\netcoreapp-Windows_NT-Release-arm64&gt;set COMPlus_TieredCompilation=0 

C:\Users\robox\j\workspace\arm64_cross_c---c55e6c4b\_\fx\bin\tests\System.Runtime.Tests\netcoreapp-Windows_NT-Release-arm64&gt;call C:\Users\robox\j\workspace\arm64_cross_c---c55e6c4b\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm64\dotnet.exe xunit.console.netcore.exe System.Runtime.Tests.dll  -xml testResults.xml -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonwindowstests  -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing 
xUnit.net console test runner (64-bit .NET Core)
Copyright (C) 2014 Outercurve Foundation.

Discovering: System.Runtime.Tests
Discovered:  System.Runtime.Tests
Starting:    System.Runtime.Tests
   System.Tests.EnumTests.GetName(enumType: typeof(System.UInt32Enum) value: 4294967295 expected: \"Max\") [FAIL]
      Assert.Equal() Failure
      Expected: Max
      Actual:   (null)
      Stack Trace:
         D:\j\workspace\arm64_cross_c---999e2d10\_\fx\src\System.Runtime\tests\System\EnumTests.cs(3150): at System.Tests.EnumTests.GetName(Type enumType Object value String expected)
   System.Tests.EnumTests.GetName(enumType: typeof(System.UInt32Enum) value: 4294967295 expected: \"Max\") [FAIL]
      Assert.Equal() Failure
      Expected: Max
      Actual:   (null)
      Stack Trace:
         D:\j\workspace\arm64_cross_c---999e2d10\_\fx\src\System.Runtime\tests\System\EnumTests.cs(3150): at System.Tests.EnumTests.GetName(Type enumType Object value String expected)
   System.Tests.EnumTests.ToString_Format(e: 4294967295 format: \"F\" expected: \"Max\") [FAIL]
      Assert.Equal() Failure
                ↓ (pos 0)
      Expected: Max
      Actual:   4294967295
                ↑ (pos 0)
      Stack Trace:
         D:\j\workspace\arm64_cross_c---999e2d10\_\fx\src\System.Runtime\tests\System\EnumTests.cs(14710): at System.Tests.EnumTests.ToString_Format(Enum e String format String expected)
   System.Tests.EnumTests.ToString_Format(e: 4294967295 format: \"G\" expected: \"Max\") [FAIL]
      Assert.Equal() Failure
                ↓ (pos 0)
      Expected: Max
      Actual:   4294967295
                ↑ (pos 0)
      Stack Trace:
         D:\j\workspace\arm64_cross_c---999e2d10\_\fx\src\System.Runtime\tests\System\EnumTests.cs(14630): at System.Tests.EnumTests.ToString_Format(Enum e String format String expected)
WARNING: System.Tests.DecimalTests+BigIntegerMod.Test is running for 333s.
Finished:    System.Runtime.Tests

=== TEST EXECUTION SUMMARY ===
   System.Runtime.Tests  Total: 16388 Errors: 0 Failed: 4 Skipped: 0 Time: 366.937s
----- end 17:53:31.00 ----- exit code 1 ----------------------------------------------------------
```

e.g. https://ci.dot.net/job/dotnet_coreclr/job/dev_unix_test_workflow/job/jitstress/job/arm64_cross_checked_windows_nt_corefx_baseline_tst_prtest/3/consoleText
</Description>
    <Title_Description>[Windows/arm64] corefx System.Runtime.Tests test failure Happens in baseline and all JIT stress runs.

```
----- start 17:45:13.31 ===============  To repro directly: ===================================================== 
pushd C:\Users\robox\j\workspace\arm64_cross_c---c55e6c4b\_\fx\bin\tests\System.Runtime.Tests\netcoreapp-Windows_NT-Release-arm64\
set COMPlus_TieredCompilation=0
call C:\Users\robox\j\workspace\arm64_cross_c---c55e6c4b\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm64\dotnet.exe xunit.console.netcore.exe System.Runtime.Tests.dll  -xml testResults.xml -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonwindowstests  -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing
popd
===========================================================================================================

C:\Users\robox\j\workspace\arm64_cross_c---c55e6c4b\_\fx\bin\tests\System.Runtime.Tests\netcoreapp-Windows_NT-Release-arm64&gt;set COMPlus_TieredCompilation=0 

C:\Users\robox\j\workspace\arm64_cross_c---c55e6c4b\_\fx\bin\tests\System.Runtime.Tests\netcoreapp-Windows_NT-Release-arm64&gt;call C:\Users\robox\j\workspace\arm64_cross_c---c55e6c4b\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm64\dotnet.exe xunit.console.netcore.exe System.Runtime.Tests.dll  -xml testResults.xml -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonwindowstests  -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing 
xUnit.net console test runner (64-bit .NET Core)
Copyright (C) 2014 Outercurve Foundation.

Discovering: System.Runtime.Tests
Discovered:  System.Runtime.Tests
Starting:    System.Runtime.Tests
   System.Tests.EnumTests.GetName(enumType: typeof(System.UInt32Enum) value: 4294967295 expected: \"Max\") [FAIL]
      Assert.Equal() Failure
      Expected: Max
      Actual:   (null)
      Stack Trace:
         D:\j\workspace\arm64_cross_c---999e2d10\_\fx\src\System.Runtime\tests\System\EnumTests.cs(3150): at System.Tests.EnumTests.GetName(Type enumType Object value String expected)
   System.Tests.EnumTests.GetName(enumType: typeof(System.UInt32Enum) value: 4294967295 expected: \"Max\") [FAIL]
      Assert.Equal() Failure
      Expected: Max
      Actual:   (null)
      Stack Trace:
         D:\j\workspace\arm64_cross_c---999e2d10\_\fx\src\System.Runtime\tests\System\EnumTests.cs(3150): at System.Tests.EnumTests.GetName(Type enumType Object value String expected)
   System.Tests.EnumTests.ToString_Format(e: 4294967295 format: \"F\" expected: \"Max\") [FAIL]
      Assert.Equal() Failure
                ↓ (pos 0)
      Expected: Max
      Actual:   4294967295
                ↑ (pos 0)
      Stack Trace:
         D:\j\workspace\arm64_cross_c---999e2d10\_\fx\src\System.Runtime\tests\System\EnumTests.cs(14710): at System.Tests.EnumTests.ToString_Format(Enum e String format String expected)
   System.Tests.EnumTests.ToString_Format(e: 4294967295 format: \"G\" expected: \"Max\") [FAIL]
      Assert.Equal() Failure
                ↓ (pos 0)
      Expected: Max
      Actual:   4294967295
                ↑ (pos 0)
      Stack Trace:
         D:\j\workspace\arm64_cross_c---999e2d10\_\fx\src\System.Runtime\tests\System\EnumTests.cs(14630): at System.Tests.EnumTests.ToString_Format(Enum e String format String expected)
WARNING: System.Tests.DecimalTests+BigIntegerMod.Test is running for 333s.
Finished:    System.Runtime.Tests

=== TEST EXECUTION SUMMARY ===
   System.Runtime.Tests  Total: 16388 Errors: 0 Failed: 4 Skipped: 0 Time: 366.937s
----- end 17:53:31.00 ----- exit code 1 ----------------------------------------------------------
```

e.g. https://ci.dot.net/job/dotnet_coreclr/job/dev_unix_test_workflow/job/jitstress/job/arm64_cross_checked_windows_nt_corefx_baseline_tst_prtest/3/consoleText
</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>sandreenko</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18913</IssueLabelID>
    <Title>[arm64] corefx System.ComponentModel.Composition.Tests failure</Title>
    <Description>While scouting Windows arm64 corefx testing: https://ci.dot.net/job/dotnet_coreclr/job/dev_unix_test_workflow/job/jitstress/job/arm64_cross_checked_windows_nt_corefx_baseline_tst_prtest/3/consoleText


```
----- start 14:37:47.47 ===============  To repro directly: ===================================================== 
pushd C:\Users\robox\j\workspace\arm64_cross_c---c55e6c4b\_\fx\bin\tests\System.ComponentModel.Composition.Tests\netcoreapp-Windows_NT-Release-arm64\
set COMPlus_TieredCompilation=0
call C:\Users\robox\j\workspace\arm64_cross_c---c55e6c4b\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm64\dotnet.exe xunit.console.netcore.exe System.ComponentModel.Composition.Tests.dll  -xml testResults.xml -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonwindowstests  -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing
popd
===========================================================================================================

C:\Users\robox\j\workspace\arm64_cross_c---c55e6c4b\_\fx\bin\tests\System.ComponentModel.Composition.Tests\netcoreapp-Windows_NT-Release-arm64&gt;set COMPlus_TieredCompilation=0 

C:\Users\robox\j\workspace\arm64_cross_c---c55e6c4b\_\fx\bin\tests\System.ComponentModel.Composition.Tests\netcoreapp-Windows_NT-Release-arm64&gt;call C:\Users\robox\j\workspace\arm64_cross_c---c55e6c4b\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm64\dotnet.exe xunit.console.netcore.exe System.ComponentModel.Composition.Tests.dll  -xml testResults.xml -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonwindowstests  -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing 
xUnit.net console test runner (64-bit .NET Core)
Copyright (C) 2014 Outercurve Foundation.

Discovering: System.ComponentModel.Composition.Tests
Discovered:  System.ComponentModel.Composition.Tests
Starting:    System.ComponentModel.Composition.Tests

Assert failure(PID 8880 [0x000022b0] Thread: 11324 [0x2c3c]): Precondition failure: FAILED: !(section-&gt;Characteristics &amp; ~((0x00000020 | 0x00000040 | 0x00000080| 0x02000000 | 0x04000000 | 0x08000000 | 0x20000000 | 0x40000000 | 0x80000000 | 0x10000000)))
	 FAILED: CheckNTHeaders()
		d:\j\workspace\arm64_cross_c---999e2d10\src\inc\pedecoder.inl line: 713

CORECLR! coreclr_shutdown_2 + 0xFA20 (0x00007ffc`d854ed50)
CORECLR! coreclr_shutdown_2 + 0x5E1BC (0x00007ffc`d859d4ec)
CORECLR! GetCLRRuntimeHost + 0x183018 (0x00007ffc`d8742078)
CORECLR! GC_VersionInfo + 0x1441DC (0x00007ffc`d8cc651c)
SYSTEM.PRIVATE.CORELIB! &lt;no symbol&gt; + 0x0 (0x00007ffc`d8011900)
&lt;no module&gt;! &lt;no symbol&gt; + 0x0 (0x00007ffc`7a493f08)
    File: d:\j\workspace\arm64_cross_c---999e2d10\src\utilcode\pedecoder.cpp Line: 356
    Image: C:\Users\robox\j\workspace\arm64_cross_c---c55e6c4b\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm64\dotnet.exe

----- end 14:39:18.36 ----- exit code 123456789 ----------------------------------------------------------
```

Remove exclusion from arm64\corefx_test_exclusions.txt when fixed.
</Description>
    <Title_Description>[arm64] corefx System.ComponentModel.Composition.Tests failure While scouting Windows arm64 corefx testing: https://ci.dot.net/job/dotnet_coreclr/job/dev_unix_test_workflow/job/jitstress/job/arm64_cross_checked_windows_nt_corefx_baseline_tst_prtest/3/consoleText


```
----- start 14:37:47.47 ===============  To repro directly: ===================================================== 
pushd C:\Users\robox\j\workspace\arm64_cross_c---c55e6c4b\_\fx\bin\tests\System.ComponentModel.Composition.Tests\netcoreapp-Windows_NT-Release-arm64\
set COMPlus_TieredCompilation=0
call C:\Users\robox\j\workspace\arm64_cross_c---c55e6c4b\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm64\dotnet.exe xunit.console.netcore.exe System.ComponentModel.Composition.Tests.dll  -xml testResults.xml -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonwindowstests  -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing
popd
===========================================================================================================

C:\Users\robox\j\workspace\arm64_cross_c---c55e6c4b\_\fx\bin\tests\System.ComponentModel.Composition.Tests\netcoreapp-Windows_NT-Release-arm64&gt;set COMPlus_TieredCompilation=0 

C:\Users\robox\j\workspace\arm64_cross_c---c55e6c4b\_\fx\bin\tests\System.ComponentModel.Composition.Tests\netcoreapp-Windows_NT-Release-arm64&gt;call C:\Users\robox\j\workspace\arm64_cross_c---c55e6c4b\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm64\dotnet.exe xunit.console.netcore.exe System.ComponentModel.Composition.Tests.dll  -xml testResults.xml -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonwindowstests  -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing 
xUnit.net console test runner (64-bit .NET Core)
Copyright (C) 2014 Outercurve Foundation.

Discovering: System.ComponentModel.Composition.Tests
Discovered:  System.ComponentModel.Composition.Tests
Starting:    System.ComponentModel.Composition.Tests

Assert failure(PID 8880 [0x000022b0] Thread: 11324 [0x2c3c]): Precondition failure: FAILED: !(section-&gt;Characteristics &amp; ~((0x00000020 | 0x00000040 | 0x00000080| 0x02000000 | 0x04000000 | 0x08000000 | 0x20000000 | 0x40000000 | 0x80000000 | 0x10000000)))
	 FAILED: CheckNTHeaders()
		d:\j\workspace\arm64_cross_c---999e2d10\src\inc\pedecoder.inl line: 713

CORECLR! coreclr_shutdown_2 + 0xFA20 (0x00007ffc`d854ed50)
CORECLR! coreclr_shutdown_2 + 0x5E1BC (0x00007ffc`d859d4ec)
CORECLR! GetCLRRuntimeHost + 0x183018 (0x00007ffc`d8742078)
CORECLR! GC_VersionInfo + 0x1441DC (0x00007ffc`d8cc651c)
SYSTEM.PRIVATE.CORELIB! &lt;no symbol&gt; + 0x0 (0x00007ffc`d8011900)
&lt;no module&gt;! &lt;no symbol&gt; + 0x0 (0x00007ffc`7a493f08)
    File: d:\j\workspace\arm64_cross_c---999e2d10\src\utilcode\pedecoder.cpp Line: 356
    Image: C:\Users\robox\j\workspace\arm64_cross_c---c55e6c4b\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm64\dotnet.exe

----- end 14:39:18.36 ----- exit code 123456789 ----------------------------------------------------------
```

Remove exclusion from arm64\corefx_test_exclusions.txt when fixed.
</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>sandreenko</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18912</IssueLabelID>
    <Title>System.Text.RegularExpressions.Tests JitMinOpts only timeout</Title>
    <Description>```
----- start 19:14:03.62 ===============  To repro directly: ===================================================== 
pushd C:\Users\robox\j\workspace\arm64_cross_c---f75df612\_\fx\bin\tests\System.Text.RegularExpressions.Tests\netcoreapp-Windows_NT-Release-arm64\
set COMPlus_TieredCompilation=0 
call C:\Users\robox\j\workspace\arm64_cross_c---f75df612\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm64\dotnet.exe xunit.console.netcore.exe System.Text.RegularExpressions.Tests.dll  -xml testResults.xml -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonwindowstests  -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing
popd
===========================================================================================================

C:\Users\robox\j\workspace\arm64_cross_c---f75df612\_\fx\bin\tests\System.Text.RegularExpressions.Tests\netcoreapp-Windows_NT-Release-arm64&gt;set COMPlus_TieredCompilation=0  

C:\Users\robox\j\workspace\arm64_cross_c---f75df612\_\fx\bin\tests\System.Text.RegularExpressions.Tests\netcoreapp-Windows_NT-Release-arm64&gt;set COMPlus_JITMinOpts=1 

C:\Users\robox\j\workspace\arm64_cross_c---f75df612\_\fx\bin\tests\System.Text.RegularExpressions.Tests\netcoreapp-Windows_NT-Release-arm64&gt;call C:\Users\robox\j\workspace\arm64_cross_c---f75df612\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm64\dotnet.exe xunit.console.netcore.exe System.Text.RegularExpressions.Tests.dll  -xml testResults.xml -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonwindowstests  -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing 
xUnit.net console test runner (64-bit .NET Core)
Copyright (C) 2014 Outercurve Foundation.

Discovering: System.Text.RegularExpressions.Tests
Discovered:  System.Text.RegularExpressions.Tests
Starting:    System.Text.RegularExpressions.Tests
   System.Text.RegularExpressions.Tests.RegexMatchTests.Match_ExcessPrefix [FAIL]
      Timed out after 60000ms waiting for remote process 5512
      Expected: True
      Actual:   False
      Stack Trace:
         D:\j\workspace\arm64_cross_c---101bec61\_\fx\src\CoreFx.Private.TestUtilities\src\System\Diagnostics\RemoteExecutorTestBase.cs(3080): at System.Diagnostics.RemoteExecutorTestBase.RemoteInvokeHandle.Dispose(Boolean disposing)
         D:\j\workspace\arm64_cross_c---101bec61\_\fx\src\CoreFx.Private.TestUtilities\src\System\Diagnostics\RemoteExecutorTestBase.cs(2950): at System.Diagnostics.RemoteExecutorTestBase.RemoteInvokeHandle.Dispose()
         D:\j\workspace\arm64_cross_c---101bec61\_\fx\src\System.Text.RegularExpressions\tests\Regex.Match.Tests.cs(7950): at System.Text.RegularExpressions.Tests.RegexMatchTests.Match_ExcessPrefix()
Finished:    System.Text.RegularExpressions.Tests

=== TEST EXECUTION SUMMARY ===
   System.Text.RegularExpressions.Tests  Total: 1498 Errors: 0 Failed: 1 Skipped: 0 Time: 197.040s
----- end 19:17:36.82 ----- exit code 1 ----------------------------------------------------------
```

Related: https://github.com/dotnet/coreclr/issues/17754

category:testing
theme:minopts
skill-level:intermediate
cost:medium</Description>
    <Title_Description>System.Text.RegularExpressions.Tests JitMinOpts only timeout ```
----- start 19:14:03.62 ===============  To repro directly: ===================================================== 
pushd C:\Users\robox\j\workspace\arm64_cross_c---f75df612\_\fx\bin\tests\System.Text.RegularExpressions.Tests\netcoreapp-Windows_NT-Release-arm64\
set COMPlus_TieredCompilation=0 
call C:\Users\robox\j\workspace\arm64_cross_c---f75df612\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm64\dotnet.exe xunit.console.netcore.exe System.Text.RegularExpressions.Tests.dll  -xml testResults.xml -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonwindowstests  -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing
popd
===========================================================================================================

C:\Users\robox\j\workspace\arm64_cross_c---f75df612\_\fx\bin\tests\System.Text.RegularExpressions.Tests\netcoreapp-Windows_NT-Release-arm64&gt;set COMPlus_TieredCompilation=0  

C:\Users\robox\j\workspace\arm64_cross_c---f75df612\_\fx\bin\tests\System.Text.RegularExpressions.Tests\netcoreapp-Windows_NT-Release-arm64&gt;set COMPlus_JITMinOpts=1 

C:\Users\robox\j\workspace\arm64_cross_c---f75df612\_\fx\bin\tests\System.Text.RegularExpressions.Tests\netcoreapp-Windows_NT-Release-arm64&gt;call C:\Users\robox\j\workspace\arm64_cross_c---f75df612\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm64\dotnet.exe xunit.console.netcore.exe System.Text.RegularExpressions.Tests.dll  -xml testResults.xml -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonwindowstests  -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing 
xUnit.net console test runner (64-bit .NET Core)
Copyright (C) 2014 Outercurve Foundation.

Discovering: System.Text.RegularExpressions.Tests
Discovered:  System.Text.RegularExpressions.Tests
Starting:    System.Text.RegularExpressions.Tests
   System.Text.RegularExpressions.Tests.RegexMatchTests.Match_ExcessPrefix [FAIL]
      Timed out after 60000ms waiting for remote process 5512
      Expected: True
      Actual:   False
      Stack Trace:
         D:\j\workspace\arm64_cross_c---101bec61\_\fx\src\CoreFx.Private.TestUtilities\src\System\Diagnostics\RemoteExecutorTestBase.cs(3080): at System.Diagnostics.RemoteExecutorTestBase.RemoteInvokeHandle.Dispose(Boolean disposing)
         D:\j\workspace\arm64_cross_c---101bec61\_\fx\src\CoreFx.Private.TestUtilities\src\System\Diagnostics\RemoteExecutorTestBase.cs(2950): at System.Diagnostics.RemoteExecutorTestBase.RemoteInvokeHandle.Dispose()
         D:\j\workspace\arm64_cross_c---101bec61\_\fx\src\System.Text.RegularExpressions\tests\Regex.Match.Tests.cs(7950): at System.Text.RegularExpressions.Tests.RegexMatchTests.Match_ExcessPrefix()
Finished:    System.Text.RegularExpressions.Tests

=== TEST EXECUTION SUMMARY ===
   System.Text.RegularExpressions.Tests  Total: 1498 Errors: 0 Failed: 1 Skipped: 0 Time: 197.040s
----- end 19:17:36.82 ----- exit code 1 ----------------------------------------------------------
```

Related: https://github.com/dotnet/coreclr/issues/17754

category:testing
theme:minopts
skill-level:intermediate
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>13/07/2018 10:33:22 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18910</IssueLabelID>
    <Title>Add all integer overloads for Avx2.BlendVariable</Title>
    <Description>Now we only have the `byte/sbyte` overload for `Avx2.BlendVariable` since the instruction uses the mask vector as a byte sequence.
However `Avx2.BlendVariable` is very common to use adding all integer overloads (`short/ushort/int/uint/long/ulong`) will significantly improve the user experience.

cc @tannergooding @CarolEidt @eerhardt </Description>
    <Title_Description>Add all integer overloads for Avx2.BlendVariable Now we only have the `byte/sbyte` overload for `Avx2.BlendVariable` since the instruction uses the mask vector as a byte sequence.
However `Avx2.BlendVariable` is very common to use adding all integer overloads (`short/ushort/int/uint/long/ulong`) will significantly improve the user experience.

cc @tannergooding @CarolEidt @eerhardt </Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>tannergooding</Assignee>
    <CreatedAt>13/07/2018 9:43:20 PM +00:00</CreatedAt>
    <ClosedAt>20/09/2018 8:42:35 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18908</IssueLabelID>
    <Title>Add tests for DECIMAL PInvoke marshaling</Title>
    <Description>https://github.com/dotnet/coreclr/pull/18868#discussion_r202166213
https://github.com/dotnet/corert/issues/4994</Description>
    <Title_Description>Add tests for DECIMAL PInvoke marshaling https://github.com/dotnet/coreclr/pull/18868#discussion_r202166213
https://github.com/dotnet/corert/issues/4994</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>13/07/2018 6:57:54 PM +00:00</CreatedAt>
    <ClosedAt>17/11/2018 12:25:43 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18907</IssueLabelID>
    <Title>[Linux/arm32][GCStress=0xc] RuntimeEventSourceTest 'listener.EventCount &gt; 0' Assertion Failure</Title>
    <Description>All the recent Ubuntu arm32 GCStress=0xc runs failed the same way in recently added RuntimeEventSourceTest in #18649 

```
...
 System.Exception: Condition 'listener.EventCount &gt; 0' is not true at Tracing.Tests.Common.Assert.True(String name Boolean condition) at Tracing.Tests.RuntimeEventSourceTest.Main(String[] args) ./runtimeeventsource.sh: line 244: 9975 Aborted $_DebuggerFullPath "$CORE_ROOT/corerun" $ExePath $CLRTestExecutionArguments Expected: 100 Actual: 134 END EXECUTION - FAILED
```

[arm_cross_checked_ubuntu_gcstress0xc_flow #19](https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_gcstress0xc_flow/19/)
[arm_cross_checked_ubuntu_gcstress0xc_jitstress1_flow #18](https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_gcstress0xc_jitstress1_flow/18/)
[arm_cross_checked_ubuntu_gcstress0xc_jitstress2_flow #16](https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_gcstress0xc_jitstress2_flow/16/)
[arm_cross_checked_ubuntu_gcstress0xc_minopts_heapverify1_flow #18](https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_gcstress0xc_minopts_heapverify1_flow/18/)
[arm_cross_checked_ubuntu_gcstress0xc_zapdisable_flow #19](https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_gcstress0xc_zapdisable_flow/19/)
[arm_cross_checked_ubuntu_gcstress0xc_zapdisable_heapverify1_flow #20](https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_gcstress0xc_zapdisable_heapverify1_flow/20/)
[arm_cross_checked_ubuntu_gcstress0xc_zapdisable_jitstress2_flow #17](https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_gcstress0xc_zapdisable_jitstress2_flow/17/)


**Update:** when the issue resolved please remove `&lt;GCStressIncompatible&gt;true&lt;/GCStressIncompatible&gt;` added in #18911</Description>
    <Title_Description>[Linux/arm32][GCStress=0xc] RuntimeEventSourceTest 'listener.EventCount &gt; 0' Assertion Failure All the recent Ubuntu arm32 GCStress=0xc runs failed the same way in recently added RuntimeEventSourceTest in #18649 

```
...
 System.Exception: Condition 'listener.EventCount &gt; 0' is not true at Tracing.Tests.Common.Assert.True(String name Boolean condition) at Tracing.Tests.RuntimeEventSourceTest.Main(String[] args) ./runtimeeventsource.sh: line 244: 9975 Aborted $_DebuggerFullPath "$CORE_ROOT/corerun" $ExePath $CLRTestExecutionArguments Expected: 100 Actual: 134 END EXECUTION - FAILED
```

[arm_cross_checked_ubuntu_gcstress0xc_flow #19](https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_gcstress0xc_flow/19/)
[arm_cross_checked_ubuntu_gcstress0xc_jitstress1_flow #18](https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_gcstress0xc_jitstress1_flow/18/)
[arm_cross_checked_ubuntu_gcstress0xc_jitstress2_flow #16](https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_gcstress0xc_jitstress2_flow/16/)
[arm_cross_checked_ubuntu_gcstress0xc_minopts_heapverify1_flow #18](https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_gcstress0xc_minopts_heapverify1_flow/18/)
[arm_cross_checked_ubuntu_gcstress0xc_zapdisable_flow #19](https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_gcstress0xc_zapdisable_flow/19/)
[arm_cross_checked_ubuntu_gcstress0xc_zapdisable_heapverify1_flow #20](https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_gcstress0xc_zapdisable_heapverify1_flow/20/)
[arm_cross_checked_ubuntu_gcstress0xc_zapdisable_jitstress2_flow #17](https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_gcstress0xc_zapdisable_jitstress2_flow/17/)


**Update:** when the issue resolved please remove `&lt;GCStressIncompatible&gt;true&lt;/GCStressIncompatible&gt;` added in #18911</Title_Description>
    <Label>GCStress</Label>
    <Assignee>echesakovMSFT</Assignee>
    <CreatedAt>13/07/2018 6:35:09 PM +00:00</CreatedAt>
    <ClosedAt>27/02/2019 9:43:08 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18906</IssueLabelID>
    <Title>Improve NativeCallable tests</Title>
    <Description>Some of the cases in the [`NativeCallableAttribute` tests](https://github.com/dotnet/coreclr/tree/master/tests/src/Interop/NativeCallable) are commented out without details as to why. These should be uncommented and the edge cases of `NativeCallableAttribute` should be covered.

cc @jaredpar @jeffschwMSFT @luqunl </Description>
    <Title_Description>Improve NativeCallable tests Some of the cases in the [`NativeCallableAttribute` tests](https://github.com/dotnet/coreclr/tree/master/tests/src/Interop/NativeCallable) are commented out without details as to why. These should be uncommented and the edge cases of `NativeCallableAttribute` should be covered.

cc @jaredpar @jeffschwMSFT @luqunl </Title_Description>
    <Label>area-Interop</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18904</IssueLabelID>
    <Title>Add prefix to DAC's PAL exports for alpine</Title>
    <Description>Added some cmake logic to create assembly include mapping files. One that maps the
prefixed name (DAC_foo) to the actual name (foo) which is included in the DAC module
and another that maps the actual name to the prefixed name that is included in the SOS
DBI and createdump modules.

The data exports like IID_IUnknown are not prefixed and don't need to be (immutable static data).

There were some C++ exports functions exported with their decorated names in
the CatchHardwareExceptionHolder and NativeExceptionHolderBase classes. Created
PAL_* style export functions that implements the code.

Fix lldb plugin cmake file to use LLDB_H/LLDB_LIB env vars to build it.</Description>
    <Title_Description>Add prefix to DAC's PAL exports for alpine Added some cmake logic to create assembly include mapping files. One that maps the
prefixed name (DAC_foo) to the actual name (foo) which is included in the DAC module
and another that maps the actual name to the prefixed name that is included in the SOS
DBI and createdump modules.

The data exports like IID_IUnknown are not prefixed and don't need to be (immutable static data).

There were some C++ exports functions exported with their decorated names in
the CatchHardwareExceptionHolder and NativeExceptionHolderBase classes. Created
PAL_* style export functions that implements the code.

Fix lldb plugin cmake file to use LLDB_H/LLDB_LIB env vars to build it.</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>mikem8361</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18903</IssueLabelID>
    <Title>Assembly.LoadFrom("System.Threading.Tasks.Extensions.dll") fails with FileLoadException</Title>
    <Description>We (PostSharp) noticed a weird behavior of .NET Core CLR and are asking for clarifications so we can implement a proper solution.

Consider the following program:

```
   class Program
    {
        static void Main(string[] args)
        {
           Assembly.LoadFrom(@"C:\Users\gael\.nuget\packages\system.threading.tasks.extensions\4.5.1\lib\netstandard2.0\System.Threading.Tasks.Extensions.dll");
   
        }
    }
```

When executed with the default command line with .NET Core 2.0.9 this program throws:

```
Unhandled Exception: System.IO.FileLoadException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'.
   at System.Runtime.Loader.AssemblyLoadContext.LoadFromPath(IntPtr ptrNativeAssemblyLoadContext String ilPath String niPath ObjectHandleOnStack retAssembly)
   at System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyPath(String assemblyPath)
   at System.Reflection.Assembly.LoadFrom(String assemblyFile)
   at ConsoleApp2.Program.Main(String[] args) in c:\users\gael\documents\visual studio 2017\ConsoleApp2\Program.cs:line 10
```

We found the following workaround. First define a file `my.deps.json` with the following content:

```
{
  "runtimeTarget": {
    "name": ".NETCoreAppVersion=v2.0"
    "signature": "fc666d3b05189566bb68c07fa9bfb9b94dbee726"
  }
  "targets": {
    ".NETCoreAppVersion=v2.0": {
      "System.Threading.Tasks.Extensions/4.5.1": {
        "dependencies": {
          "System.Runtime.CompilerServices.Unsafe": "4.5.0"
        }
        "runtime": {
          "C:/Users/gael/.nuget/packages/system.threading.tasks.extensions/4.5.1/lib/netstandard2.0/System.Threading.Tasks.Extensions.dll": {
            "assemblyVersion": "4.2.0.0"
            "fileVersion": "4.6.26606.5"
          }
        }
      }
    }
  }
  "libraries": {
    "System.Threading.Tasks.Extensions/4.5.1": {
      "type": "package"
      "serviceable": true
      "sha512": "sha512-rckdhLJtzQ3EI+0BGuq7dUVtCSnerqAoAmL3S6oMRZ4VMZTL3Rq9DS8IDW57c6PYVebA4O0NbSA1BDvyE18UMA=="
      "path": "system.threading.tasks.extensions/4.5.1"
      "hashPath": "system.threading.tasks.extensions.4.5.1.nupkg.sha512"
    }
  }
}
```

Then use the following command line:

```
dotnet --additional-deps my.deps.json ConsoleApp2.dll
```

Our hypothesis is that `Assembly.LoadFrom` is not allowed for assemblies that are shipped with .NET Core (i.e. those under the directory `C:\Program Files\dotnet\shared\Microsoft.NETCore.App\2.0.9`). A viable workaround is to generate an additional `deps.json` file and include any assembly that we need to load at runtime but that are not a build-time dependency.

Could you please spread some light on this situation?

Thank you.

-gael
</Description>
    <Title_Description>Assembly.LoadFrom("System.Threading.Tasks.Extensions.dll") fails with FileLoadException We (PostSharp) noticed a weird behavior of .NET Core CLR and are asking for clarifications so we can implement a proper solution.

Consider the following program:

```
   class Program
    {
        static void Main(string[] args)
        {
           Assembly.LoadFrom(@"C:\Users\gael\.nuget\packages\system.threading.tasks.extensions\4.5.1\lib\netstandard2.0\System.Threading.Tasks.Extensions.dll");
   
        }
    }
```

When executed with the default command line with .NET Core 2.0.9 this program throws:

```
Unhandled Exception: System.IO.FileLoadException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'.
   at System.Runtime.Loader.AssemblyLoadContext.LoadFromPath(IntPtr ptrNativeAssemblyLoadContext String ilPath String niPath ObjectHandleOnStack retAssembly)
   at System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyPath(String assemblyPath)
   at System.Reflection.Assembly.LoadFrom(String assemblyFile)
   at ConsoleApp2.Program.Main(String[] args) in c:\users\gael\documents\visual studio 2017\ConsoleApp2\Program.cs:line 10
```

We found the following workaround. First define a file `my.deps.json` with the following content:

```
{
  "runtimeTarget": {
    "name": ".NETCoreAppVersion=v2.0"
    "signature": "fc666d3b05189566bb68c07fa9bfb9b94dbee726"
  }
  "targets": {
    ".NETCoreAppVersion=v2.0": {
      "System.Threading.Tasks.Extensions/4.5.1": {
        "dependencies": {
          "System.Runtime.CompilerServices.Unsafe": "4.5.0"
        }
        "runtime": {
          "C:/Users/gael/.nuget/packages/system.threading.tasks.extensions/4.5.1/lib/netstandard2.0/System.Threading.Tasks.Extensions.dll": {
            "assemblyVersion": "4.2.0.0"
            "fileVersion": "4.6.26606.5"
          }
        }
      }
    }
  }
  "libraries": {
    "System.Threading.Tasks.Extensions/4.5.1": {
      "type": "package"
      "serviceable": true
      "sha512": "sha512-rckdhLJtzQ3EI+0BGuq7dUVtCSnerqAoAmL3S6oMRZ4VMZTL3Rq9DS8IDW57c6PYVebA4O0NbSA1BDvyE18UMA=="
      "path": "system.threading.tasks.extensions/4.5.1"
      "hashPath": "system.threading.tasks.extensions.4.5.1.nupkg.sha512"
    }
  }
}
```

Then use the following command line:

```
dotnet --additional-deps my.deps.json ConsoleApp2.dll
```

Our hypothesis is that `Assembly.LoadFrom` is not allowed for assemblies that are shipped with .NET Core (i.e. those under the directory `C:\Program Files\dotnet\shared\Microsoft.NETCore.App\2.0.9`). A viable workaround is to generate an additional `deps.json` file and include any assembly that we need to load at runtime but that are not a build-time dependency.

Could you please spread some light on this situation?

Thank you.

-gael
</Title_Description>
    <Label>area-AssemblyLoader</Label>
    <Assignee>jeffschwMSFT</Assignee>
    <CreatedAt>13/07/2018 4:03:23 PM +00:00</CreatedAt>
    <ClosedAt>16/07/2018 4:52:52 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18901</IssueLabelID>
    <Title>WIP Fix bit-rot when '#define MEASURE_CLRAPI_CALLS' is used</Title>
    <Description>When I was writing [.NET JIT and CLR - Joined at the Hip](http://mattwarren.org/2018/07/05/.NET-JIT-and-CLR-Joined-at-the-Hip/) I noticed that the JIT wrapper apis had got out of sync although it's only noticeable with `#define MEASURE_CLRAPI_CALLS 1`. (BTW thanks to @pkukol for writing [this comment](https://github.com/dotnet/coreclr/blob/b89e2305a2c953272c997242d01b66b1bb1e661e/src/jit/compiler.cpp#L6563-L6566) it did its job)

I plan to revert my changes to `jit.h` I just wanted to make sure all the builds passed first (hence WIP).</Description>
    <Title_Description>WIP Fix bit-rot when '#define MEASURE_CLRAPI_CALLS' is used When I was writing [.NET JIT and CLR - Joined at the Hip](http://mattwarren.org/2018/07/05/.NET-JIT-and-CLR-Joined-at-the-Hip/) I noticed that the JIT wrapper apis had got out of sync although it's only noticeable with `#define MEASURE_CLRAPI_CALLS 1`. (BTW thanks to @pkukol for writing [this comment](https://github.com/dotnet/coreclr/blob/b89e2305a2c953272c997242d01b66b1bb1e661e/src/jit/compiler.cpp#L6563-L6566) it did its job)

I plan to revert my changes to `jit.h` I just wanted to make sure all the builds passed first (hence WIP).</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>pkukol</Assignee>
    <CreatedAt>13/07/2018 2:10:58 PM +00:00</CreatedAt>
    <ClosedAt>4/10/2019 11:16:27 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18900</IssueLabelID>
    <Title>Implement GetComObjectData and SetComObjectData</Title>
    <Description>Contributes to https://github.com/dotnet/corefx/issues/31015</Description>
    <Title_Description>Implement GetComObjectData and SetComObjectData Contributes to https://github.com/dotnet/corefx/issues/31015</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>13/07/2018 10:43:28 AM +00:00</CreatedAt>
    <ClosedAt>19/07/2018 3:29:31 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18898</IssueLabelID>
    <Title>Test failure: CoreMangLib_cti._system_guid_GuidEquals2_GuidEquals2_/_system_guid_GuidEquals2_GuidEquals2_cmd</Title>
    <Description>Opened on behalf of @Sunny-pu

The test `CoreMangLib_cti._system_guid_GuidEquals2_GuidEquals2_/_system_guid_GuidEquals2_GuidEquals2_cmd` has failed.

mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    
    cmdLine:/home/helixbot/dotnetbuild/work/c0463900-787c-47e6-bdc5-f2cc35669145/Work/0316fdb5-17c7-4801-9101-89b220f9360a/Unzip/system/guid/GuidEquals2/GuidEquals2.sh Timed Out
    
    
    Return code:      -100
    Raw output file:      /home/helixbot/dotnetbuild/work/c0463900-787c-47e6-bdc5-f2cc35669145/Work/0316fdb5-17c7-4801-9101-89b220f9360a/Unzip/Reports\\CoreMangLib.cti\\system\\guid\\GuidEquals2\\GuidEquals2.output.txt
    Raw output:
    BEGIN EXECUTION
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    
    cmdLine:/home/helixbot/dotnetbuild/work/c0463900-787c-47e6-bdc5-f2cc35669145/Work/0316fdb5-17c7-4801-9101-89b220f9360a/Unzip/system/guid/GuidEquals2/GuidEquals2.sh Timed Out
    Test Harness Exitcode is : -100
    
    To run the test:
    &gt; set CORE_ROOT=/home/helixbot/dotnetbuild/work/c0463900-787c-47e6-bdc5-f2cc35669145/Payload
    &gt; /home/helixbot/dotnetbuild/work/c0463900-787c-47e6-bdc5-f2cc35669145/Work/0316fdb5-17c7-4801-9101-89b220f9360a/Unzip/system/guid/GuidEquals2/GuidEquals2.sh
    
    Expected: True
    Actual:   False

        Stack Trace:

        
Build : Master - 20180712.06 (Ready-To-Run Tests)
Failing configurations:
- ubuntu.1710.amd64
  - x64

Details: https://mc.dot.net/#/product/netcore/master/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fr2r~2Fcli~2F/build/20180712.06/workItem/CoreMangLib.cti.XUnitWrapper/analysis/xunit/CoreMangLib_cti._system_guid_GuidEquals2_GuidEquals2_~2F_system_guid_GuidEquals2_GuidEquals2_cmd</Description>
    <Title_Description>Test failure: CoreMangLib_cti._system_guid_GuidEquals2_GuidEquals2_/_system_guid_GuidEquals2_GuidEquals2_cmd Opened on behalf of @Sunny-pu

The test `CoreMangLib_cti._system_guid_GuidEquals2_GuidEquals2_/_system_guid_GuidEquals2_GuidEquals2_cmd` has failed.

mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    mkdir: cannot create directory ‘lock’: File exists
    
    cmdLine:/home/helixbot/dotnetbuild/work/c0463900-787c-47e6-bdc5-f2cc35669145/Work/0316fdb5-17c7-4801-9101-89b220f9360a/Unzip/system/guid/GuidEquals2/GuidEquals2.sh Timed Out
    
    
    Return code:      -100
    Raw output file:      /home/helixbot/dotnetbuild/work/c0463900-787c-47e6-bdc5-f2cc35669145/Work/0316fdb5-17c7-4801-9101-89b220f9360a/Unzip/Reports\\CoreMangLib.cti\\system\\guid\\GuidEquals2\\GuidEquals2.output.txt
    Raw output:
    BEGIN EXECUTION
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    in takeLock
    
    cmdLine:/home/helixbot/dotnetbuild/work/c0463900-787c-47e6-bdc5-f2cc35669145/Work/0316fdb5-17c7-4801-9101-89b220f9360a/Unzip/system/guid/GuidEquals2/GuidEquals2.sh Timed Out
    Test Harness Exitcode is : -100
    
    To run the test:
    &gt; set CORE_ROOT=/home/helixbot/dotnetbuild/work/c0463900-787c-47e6-bdc5-f2cc35669145/Payload
    &gt; /home/helixbot/dotnetbuild/work/c0463900-787c-47e6-bdc5-f2cc35669145/Work/0316fdb5-17c7-4801-9101-89b220f9360a/Unzip/system/guid/GuidEquals2/GuidEquals2.sh
    
    Expected: True
    Actual:   False

        Stack Trace:

        
Build : Master - 20180712.06 (Ready-To-Run Tests)
Failing configurations:
- ubuntu.1710.amd64
  - x64

Details: https://mc.dot.net/#/product/netcore/master/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fr2r~2Fcli~2F/build/20180712.06/workItem/CoreMangLib.cti.XUnitWrapper/analysis/xunit/CoreMangLib_cti._system_guid_GuidEquals2_GuidEquals2_~2F_system_guid_GuidEquals2_GuidEquals2_cmd</Title_Description>
    <Label>area-ReadyToRun</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>13/07/2018 7:16:05 AM +00:00</CreatedAt>
    <ClosedAt>23/05/2019 9:35:23 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18895</IssueLabelID>
    <Title>[arm64] Assertion failed '(allRegs(theInterval-&gt;registerType) &amp; mask) != 0'</Title>
    <Description>Running JIT\HardwareIntrinsics\Arm64\Simd\Simd.cmd test:

```
Running: C:\brucefo\tests\Windows_NT.arm64.Debug.2018-07-06\JIT\HardwareIntrinsics\Arm64\Simd\Simd.cmd -coreroot C:\brucefo\core_root\Windows_NT.arm64.Debug.2018-07-12

Assert failure(PID 1272 [0x000004f8] Thread: 1096 [0x0448]): Assertion failed '(allRegs(theInterval-&gt;registerType) &amp; mask) != 0' in 'System.Activator:CreateInstance():struct' (IL size 58)

    File: f:\gh\coreclr11\src\jit\lsrabuild.cpp Line: 594
    Image: C:\brucefo\core_root\Windows_NT.arm64.Debug.2018-07-12\CoreRun.exe
```

e.g. https://ci.dot.net/job/dotnet_coreclr/job/master/job/arm64_cross_debug_windows_nt_tst/566
</Description>
    <Title_Description>[arm64] Assertion failed '(allRegs(theInterval-&gt;registerType) &amp; mask) != 0' Running JIT\HardwareIntrinsics\Arm64\Simd\Simd.cmd test:

```
Running: C:\brucefo\tests\Windows_NT.arm64.Debug.2018-07-06\JIT\HardwareIntrinsics\Arm64\Simd\Simd.cmd -coreroot C:\brucefo\core_root\Windows_NT.arm64.Debug.2018-07-12

Assert failure(PID 1272 [0x000004f8] Thread: 1096 [0x0448]): Assertion failed '(allRegs(theInterval-&gt;registerType) &amp; mask) != 0' in 'System.Activator:CreateInstance():struct' (IL size 58)

    File: f:\gh\coreclr11\src\jit\lsrabuild.cpp Line: 594
    Image: C:\brucefo\core_root\Windows_NT.arm64.Debug.2018-07-12\CoreRun.exe
```

e.g. https://ci.dot.net/job/dotnet_coreclr/job/master/job/arm64_cross_debug_windows_nt_tst/566
</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>sandreenko</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18894</IssueLabelID>
    <Title>Investigate: can we improve docs or diagnostics when 64 bit .NET Core app fails on Azure App Service</Title>
    <Description>@noahfalk commented on [Thu Jun 07 2018](https://github.com/dotnet/core/issues/1670)

This issue is forked from #1622 where @joseclament reported that he was getting an unexplained BadImageFormatException. The limitation from Azure App Service is by design but perhaps we could offer better guidance in docs or diagnostic error messages so that developers will more quickly discover the right path forward. Thanks @joseclament for raising the issue!

&gt; @noahfalk  and @nil4  I got the bottom of the problem. It took couple of days to get the bottom of the issue and made me bit nut. I was able to dig and find this link: https://tutel.me/c/programming/questions/42726350/how+to+change+azure+app+service+to+64bit
&gt; 
&gt; Your core should be built on x86 version even if the deploying server(Azure) is based on 64 bit architecture. Because the 64 bit .NET core processes using the .NET core runtime (as opposed to the .NET Framework runtime) are not yet supported on Azure but is planned to be coming in the future. You can verify this by go to the kudu and type  dotnet --info. You can see something like this below:
&gt; 
&gt; .NET Core SDK (reflecting any global.json):
&gt;  Version:   2.1.300
&gt;  Commit:    32f29b6eb9
&gt; 
&gt; Runtime Environment:
&gt;  OS Name:     Windows
&gt;  OS Version:  10.0.14393
&gt;  OS Platform: Windows
&gt;  RID:         win10-x86
&gt;  _Base Path:   D:\Program Files (x86)\dotnet\sdk\2.1.300\_ [**You  can see only the x86 version here**]
&gt; 
&gt; Host (useful for support):
&gt;   Version: 2.1.0
&gt;   Commit:  caa7b7e2ba
&gt; 
&gt; .NET Core SDKs installed:
&gt;   1.1.8 [D:\Program Files (x86)\dotnet\sdk]
&gt;   2.1.101 [D:\Program Files (x86)\dotnet\sdk]
&gt;   2.1.300 [D:\Program Files (x86)\dotnet\sdk]
&gt; 
&gt; You may be able to debug this locally "Any CPU" option as you might have x86 and x64 based libraries installed on your machine. I could not find any documentation on MSDN about this. I was assumed it would have been automatically support x64 version. Also make sure that the application setting is enabled for the "32" bit.
&gt; 


---

@bcisnero commented on [Fri Jun 08 2018](https://github.com/dotnet/core/issues/1670#issuecomment-395922622)

Probably a fast solution to this will be to add a note in the document explaining just what are the Azure limitations and the the workaround at this point because and this is going to change at some point in the future.

</Description>
    <Title_Description>Investigate: can we improve docs or diagnostics when 64 bit .NET Core app fails on Azure App Service @noahfalk commented on [Thu Jun 07 2018](https://github.com/dotnet/core/issues/1670)

This issue is forked from #1622 where @joseclament reported that he was getting an unexplained BadImageFormatException. The limitation from Azure App Service is by design but perhaps we could offer better guidance in docs or diagnostic error messages so that developers will more quickly discover the right path forward. Thanks @joseclament for raising the issue!

&gt; @noahfalk  and @nil4  I got the bottom of the problem. It took couple of days to get the bottom of the issue and made me bit nut. I was able to dig and find this link: https://tutel.me/c/programming/questions/42726350/how+to+change+azure+app+service+to+64bit
&gt; 
&gt; Your core should be built on x86 version even if the deploying server(Azure) is based on 64 bit architecture. Because the 64 bit .NET core processes using the .NET core runtime (as opposed to the .NET Framework runtime) are not yet supported on Azure but is planned to be coming in the future. You can verify this by go to the kudu and type  dotnet --info. You can see something like this below:
&gt; 
&gt; .NET Core SDK (reflecting any global.json):
&gt;  Version:   2.1.300
&gt;  Commit:    32f29b6eb9
&gt; 
&gt; Runtime Environment:
&gt;  OS Name:     Windows
&gt;  OS Version:  10.0.14393
&gt;  OS Platform: Windows
&gt;  RID:         win10-x86
&gt;  _Base Path:   D:\Program Files (x86)\dotnet\sdk\2.1.300\_ [**You  can see only the x86 version here**]
&gt; 
&gt; Host (useful for support):
&gt;   Version: 2.1.0
&gt;   Commit:  caa7b7e2ba
&gt; 
&gt; .NET Core SDKs installed:
&gt;   1.1.8 [D:\Program Files (x86)\dotnet\sdk]
&gt;   2.1.101 [D:\Program Files (x86)\dotnet\sdk]
&gt;   2.1.300 [D:\Program Files (x86)\dotnet\sdk]
&gt; 
&gt; You may be able to debug this locally "Any CPU" option as you might have x86 and x64 based libraries installed on your machine. I could not find any documentation on MSDN about this. I was assumed it would have been automatically support x64 version. Also make sure that the application setting is enabled for the "32" bit.
&gt; 


---

@bcisnero commented on [Fri Jun 08 2018](https://github.com/dotnet/core/issues/1670#issuecomment-395922622)

Probably a fast solution to this will be to add a note in the document explaining just what are the Azure limitations and the the workaround at this point because and this is going to change at some point in the future.

</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>noahfalk</Assignee>
    <CreatedAt>12/07/2018 9:48:21 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18893</IssueLabelID>
    <Title>createdump is missing on ARM and ARM64</Title>
    <Description>X86 runtime has utility `createdump` and there are instructions out there how to use to collect debug info. It is missing in arm runtime. 

This is probably packaging issue. I build it and run it on me RPI and it seems to function.
It did create dump as well as it prints reasonable output when executed with -d flag. 

&gt; src/.nuget/Microsoft.NETCore.Runtime.CoreCLR/runtime.Linux.Microsoft.NETCore.Runtime.CoreCLR.props


```
 &lt;_PlatformDoesNotSupportCreatedump Condition="'$(Platform)' == 'arm'"&gt;true&lt;/_PlatformDoesNotSupportCreatedump&gt;
 &lt;NativeBinary Condition="'$(_PlatformDoesNotSupportCreatedump)' != 'true'" Include="$(BinDir)createdump" /&gt;
 ```
</Description>
    <Title_Description>createdump is missing on ARM and ARM64 X86 runtime has utility `createdump` and there are instructions out there how to use to collect debug info. It is missing in arm runtime. 

This is probably packaging issue. I build it and run it on me RPI and it seems to function.
It did create dump as well as it prints reasonable output when executed with -d flag. 

&gt; src/.nuget/Microsoft.NETCore.Runtime.CoreCLR/runtime.Linux.Microsoft.NETCore.Runtime.CoreCLR.props


```
 &lt;_PlatformDoesNotSupportCreatedump Condition="'$(Platform)' == 'arm'"&gt;true&lt;/_PlatformDoesNotSupportCreatedump&gt;
 &lt;NativeBinary Condition="'$(_PlatformDoesNotSupportCreatedump)' != 'true'" Include="$(BinDir)createdump" /&gt;
 ```
</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>hoyosjs</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18889</IssueLabelID>
    <Title>sosplugin is not working on ARM</Title>
    <Description>
I tested this in my RP3 as well as Ubuntu on Qemu. I'm not even  able to get list of commands. 


```
pi@raspberrypi:~/aa $ lldb-4.0 ../dotnet-2.1.302/dotnet -- bin/Debug/netcoreapp2.1/aa.dll
(lldb) target create "../dotnet-2.1.302/dotnet"
Current executable set to '../dotnet-2.1.302/dotnet' (arm).
(lldb) settings set -- target.run-args  "bin/Debug/netcoreapp2.1/aa.dll"
(lldb) r
Process 16576 launched: '../dotnet-2.1.302/dotnet' (arm)
Hello World!
Going to sleep!
Process 16576 stopped
* thread #1 name = 'dotnet' stop reason = signal SIGSTOP
    frame #0: 0x76f88ce8
-&gt;  0x76f88ce8: svc    #0x0
    0x76f88cec: cmn    r0 #4096
    0x76f88cf0: mov    r5 r0
    0x76f88cf4: ldrls  r4 [sp]
(lldb) plugin load ../dotnet-2.1.302/shared/Microsoft.NETCore.App/2.1.2/libsosplugin.so
(lldb) sos
(lldb) sos help
Stack dump:
0.	HandleCommand(command = "sos help")
Segmentation fault
```

I did same steps on x64 and lldb-4.0
(lldb) sos
-------------------------------------------------------------------------------
SOS is a debugger extension DLL designed to aid in the debugging of managed
programs. Functions are listed by category then roughly in order of
...
...

(lldb) sos help
SOS command 'help' not found /home/furt/dotnet-2.1/shared/Microsoft.NETCore.App/2.1.0/libsos.so: undefined symbol: help
```</Description>
    <Title_Description>sosplugin is not working on ARM 
I tested this in my RP3 as well as Ubuntu on Qemu. I'm not even  able to get list of commands. 


```
pi@raspberrypi:~/aa $ lldb-4.0 ../dotnet-2.1.302/dotnet -- bin/Debug/netcoreapp2.1/aa.dll
(lldb) target create "../dotnet-2.1.302/dotnet"
Current executable set to '../dotnet-2.1.302/dotnet' (arm).
(lldb) settings set -- target.run-args  "bin/Debug/netcoreapp2.1/aa.dll"
(lldb) r
Process 16576 launched: '../dotnet-2.1.302/dotnet' (arm)
Hello World!
Going to sleep!
Process 16576 stopped
* thread #1 name = 'dotnet' stop reason = signal SIGSTOP
    frame #0: 0x76f88ce8
-&gt;  0x76f88ce8: svc    #0x0
    0x76f88cec: cmn    r0 #4096
    0x76f88cf0: mov    r5 r0
    0x76f88cf4: ldrls  r4 [sp]
(lldb) plugin load ../dotnet-2.1.302/shared/Microsoft.NETCore.App/2.1.2/libsosplugin.so
(lldb) sos
(lldb) sos help
Stack dump:
0.	HandleCommand(command = "sos help")
Segmentation fault
```

I did same steps on x64 and lldb-4.0
(lldb) sos
-------------------------------------------------------------------------------
SOS is a debugger extension DLL designed to aid in the debugging of managed
programs. Functions are listed by category then roughly in order of
...
...

(lldb) sos help
SOS command 'help' not found /home/furt/dotnet-2.1/shared/Microsoft.NETCore.App/2.1.0/libsos.so: undefined symbol: help
```</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>mikem8361</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18886</IssueLabelID>
    <Title>ARM64 corefx test failures</Title>
    <Description>The following tests fail in corefx CI runs and have been disabled. There are some similar failures for ARM in #16001.

E.g. https://ci.dot.net/job/dotnet_coreclr/job/dev_unix_test_workflow/job/jitstress/job/arm64_cross_checked_windows_nt_corefx_baseline_tst_prtest/2/consoleText

</Description>
    <Title_Description>ARM64 corefx test failures The following tests fail in corefx CI runs and have been disabled. There are some similar failures for ARM in #16001.

E.g. https://ci.dot.net/job/dotnet_coreclr/job/dev_unix_test_workflow/job/jitstress/job/arm64_cross_checked_windows_nt_corefx_baseline_tst_prtest/2/consoleText

</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>sandreenko</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18885</IssueLabelID>
    <Title>ILDASM - Wrong exit code</Title>
    <Description>I'm using ILDASM to inspect all files in a folder (project build output) and in somes cases i have configuration/text files. In those edge cases i caught a bug although i received an exit code 0 the process output was "Image is either too small or contains an invalid byte offset or count.\n". According to the process output i was expecting to receive an exit 1.

I'm migrating to this version of ILDASM (before i was using https://docs.microsoft.com/en-us/dotnet/framework/tools/ildasm-exe-il-disassembler) because i couldn't run in Docker container with mono.</Description>
    <Title_Description>ILDASM - Wrong exit code I'm using ILDASM to inspect all files in a folder (project build output) and in somes cases i have configuration/text files. In those edge cases i caught a bug although i received an exit code 0 the process output was "Image is either too small or contains an invalid byte offset or count.\n". According to the process output i was expecting to receive an exit 1.

I'm migrating to this version of ILDASM (before i was using https://docs.microsoft.com/en-us/dotnet/framework/tools/ildasm-exe-il-disassembler) because i couldn't run in Docker container with mono.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18884</IssueLabelID>
    <Title>RyuJIT fails to preserve variable allocated to RCX around shift on x64 in release</Title>
    <Description>On Linux the following example prints a weird result:
```csharp
public class Program
{
    static ushort s_3;
    static long s_5;
    public static void Main()
    {
        s_3 = 0; // avoid runtime checks in M15
        M15(0 0 1 0);
    }

    static short[] M15(ulong arg0 long arg1 ushort arg2 byte arg3)
    {
        s_5 &gt;&gt;= 50 / arg2;  // the value shifted by here
        if (arg3 != 0)
        {
            s_3 = s_3;
        }

        System.Console.WriteLine(arg3); // ..is printed here
        return new short[]{0};
    }
}
```

The disassembly shows that `arg3` gets allocated to RCX but it is not restored after the shift (which requires the shift-value to be in cl):
```asm
; Assembly listing for method Program:M15(longlongushortubyte):ref
; Emitting BLENDED_CODE for X64 CPU with AVX
; optimized code
; rsp based frame
; partially interruptible
; Final local variable assignments
;
;* V00 arg0         [V00    ] (  0  0   )    long  -&gt;  zero-ref
;* V01 arg1         [V01    ] (  0  0   )    long  -&gt;  zero-ref
;  V02 arg2         [V02T02] (  3  3   )  ushort  -&gt;  rdx
;  V03 arg3         [V03T01] (  4  4   )   ubyte  -&gt;  rcx         ; allocated to rcx
;# V04 OutArgs      [V04    ] (  1  1   )  lclBlk ( 0) [rsp+0x00]
;  V05 cse0         [V05T00] (  6  6   )     int  -&gt;  rdi
;
; Lcl frame size = 8

G_M58758_IG01:
       50                   push     rax

G_M58758_IG02:
       B832000000           mov      eax 50
       0FB7FA               movzx    rdi dx
       99                   cdq
       F7FF                 idiv     edx:eax edi
       48BFC046295C0D7F0000 mov      rdi 0x7F0D5C2946C0
       8BC8                 mov      ecx eax
       48D33F               sar      qword ptr [rdi] cl
       400FB6F9             movzx    rdi cl              ; arg3 reloaded from shift value
       85FF                 test     edi edi
       741A                 je       SHORT G_M58758_IG03
       48B8C846295C0D7F0000 mov      rax 0x7F0D5C2946C8
       0FB700               movzx    rax word  ptr [rax]
       48BEC846295C0D7F0000 mov      rsi 0x7F0D5C2946C8
       668906               mov      word  ptr [rsi] ax

G_M58758_IG03:
       E896FBFFFF           call     System.Console:WriteLine(int)
       48BFB048625D0D7F0000 mov      rdi 0x7F0D5D6248B0
       BE01000000           mov      esi 1
       E81A148A78           call     CORINFO_HELP_NEWARR_1_VC
       90                   nop

G_M58758_IG04:
       4883C408             add      rsp 8
       C3                   ret

; Total bytes of code 92 prolog size 1 for method Program:M15(longlongushortubyte):ref
; ============================================================
```

It repros on Windows as well (see next comment).</Description>
    <Title_Description>RyuJIT fails to preserve variable allocated to RCX around shift on x64 in release On Linux the following example prints a weird result:
```csharp
public class Program
{
    static ushort s_3;
    static long s_5;
    public static void Main()
    {
        s_3 = 0; // avoid runtime checks in M15
        M15(0 0 1 0);
    }

    static short[] M15(ulong arg0 long arg1 ushort arg2 byte arg3)
    {
        s_5 &gt;&gt;= 50 / arg2;  // the value shifted by here
        if (arg3 != 0)
        {
            s_3 = s_3;
        }

        System.Console.WriteLine(arg3); // ..is printed here
        return new short[]{0};
    }
}
```

The disassembly shows that `arg3` gets allocated to RCX but it is not restored after the shift (which requires the shift-value to be in cl):
```asm
; Assembly listing for method Program:M15(longlongushortubyte):ref
; Emitting BLENDED_CODE for X64 CPU with AVX
; optimized code
; rsp based frame
; partially interruptible
; Final local variable assignments
;
;* V00 arg0         [V00    ] (  0  0   )    long  -&gt;  zero-ref
;* V01 arg1         [V01    ] (  0  0   )    long  -&gt;  zero-ref
;  V02 arg2         [V02T02] (  3  3   )  ushort  -&gt;  rdx
;  V03 arg3         [V03T01] (  4  4   )   ubyte  -&gt;  rcx         ; allocated to rcx
;# V04 OutArgs      [V04    ] (  1  1   )  lclBlk ( 0) [rsp+0x00]
;  V05 cse0         [V05T00] (  6  6   )     int  -&gt;  rdi
;
; Lcl frame size = 8

G_M58758_IG01:
       50                   push     rax

G_M58758_IG02:
       B832000000           mov      eax 50
       0FB7FA               movzx    rdi dx
       99                   cdq
       F7FF                 idiv     edx:eax edi
       48BFC046295C0D7F0000 mov      rdi 0x7F0D5C2946C0
       8BC8                 mov      ecx eax
       48D33F               sar      qword ptr [rdi] cl
       400FB6F9             movzx    rdi cl              ; arg3 reloaded from shift value
       85FF                 test     edi edi
       741A                 je       SHORT G_M58758_IG03
       48B8C846295C0D7F0000 mov      rax 0x7F0D5C2946C8
       0FB700               movzx    rax word  ptr [rax]
       48BEC846295C0D7F0000 mov      rsi 0x7F0D5C2946C8
       668906               mov      word  ptr [rsi] ax

G_M58758_IG03:
       E896FBFFFF           call     System.Console:WriteLine(int)
       48BFB048625D0D7F0000 mov      rdi 0x7F0D5D6248B0
       BE01000000           mov      esi 1
       E81A148A78           call     CORINFO_HELP_NEWARR_1_VC
       90                   nop

G_M58758_IG04:
       4883C408             add      rsp 8
       C3                   ret

; Total bytes of code 92 prolog size 1 for method Program:M15(longlongushortubyte):ref
; ============================================================
```

It repros on Windows as well (see next comment).</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18877</IssueLabelID>
    <Title>[RyuJIT] Ensure all the VEX.vvvv instructions in IsDstDstSrc/DstSrcSrcAVXInstruction</Title>
    <Description>Logging the conversation https://github.com/dotnet/coreclr/pull/18876#pullrequestreview-136452081

We should double check that all the instructions that use `VEX.vvvv` field (VEX encoded 256-bit and 128-bit instructions both) properly exist in `IsDstDstSrc/DstSrcSrcAVXInstruction`.</Description>
    <Title_Description>[RyuJIT] Ensure all the VEX.vvvv instructions in IsDstDstSrc/DstSrcSrcAVXInstruction Logging the conversation https://github.com/dotnet/coreclr/pull/18876#pullrequestreview-136452081

We should double check that all the instructions that use `VEX.vvvv` field (VEX encoded 256-bit and 128-bit instructions both) properly exist in `IsDstDstSrc/DstSrcSrcAVXInstruction`.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18873</IssueLabelID>
    <Title>Add prefix to DAC's PAL exports for alpine</Title>
    <Description>Added some cmake logic to create assembly include mapping files. One that maps the
prefixed name (DAC_foo) to the actual name (foo) which is included in the DAC module
and another that maps the actual name to the prefixed name that is included in the SOS
DBI and createdump modules.

The data exports like IID_IUnknown are not prefixed and don't need to be (immutable static data).

There were some C++ exports functions exported with their decorated names in
the CatchHardwareExceptionHolder and NativeExceptionHolderBase classes. Created
PAL_* style export functions that implements the code.

Fix lldb plugin cmake file to use LLDB_H/LLDB_LIB env vars to build it.</Description>
    <Title_Description>Add prefix to DAC's PAL exports for alpine Added some cmake logic to create assembly include mapping files. One that maps the
prefixed name (DAC_foo) to the actual name (foo) which is included in the DAC module
and another that maps the actual name to the prefixed name that is included in the SOS
DBI and createdump modules.

The data exports like IID_IUnknown are not prefixed and don't need to be (immutable static data).

There were some C++ exports functions exported with their decorated names in
the CatchHardwareExceptionHolder and NativeExceptionHolderBase classes. Created
PAL_* style export functions that implements the code.

Fix lldb plugin cmake file to use LLDB_H/LLDB_LIB env vars to build it.</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>mikem8361</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18872</IssueLabelID>
    <Title>Suspicious move possible use after move?</Title>
    <Description>I think there might be a use after move in `src/jit/lower.cpp`

See: https://github.com/dotnet/coreclr/blob/master/src/jit/lower.cpp#L561

The variable `condRange` might have been moved just before its use.

category:implementation
theme:jit-coding-style
skill-level:beginner
cost:small</Description>
    <Title_Description>Suspicious move, possible use after move? I think there might be a use after move in `src/jit/lower.cpp`

See: https://github.com/dotnet/coreclr/blob/master/src/jit/lower.cpp#L561

The variable `condRange` might have been moved just before its use.

category:implementation
theme:jit-coding-style
skill-level:beginner
cost:small</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>11/07/2018 8:37:33 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18869</IssueLabelID>
    <Title>LclVar sorting throughput improvements</Title>
    <Description>Follow-up from #18504 discussion. There are a few inefficiencies around lclvar sorting (`lvaSortByRefCount`) that may worth addressing:
* `lvaSortByRefCount` is called 2-3 times during compilation of a method and every time it allocates memory for the `lvaRefSorted` array. The array could be cached and reused provided that potential increases of the lclvar count are considered.
* unlike `lvaSortByRefCount` `lvaTrackedToVarNum` is allocated only once. But its size is hardcoded to `lclMAX_TRACKED` and that's extremely large for many methods. The number of tracked variables is available before allocating so a more reasonably size can be used (again accounting for the fact that the number of lclvars may increase).
* `lvaTrackedToVarNum` is actually redundant `lvaSortByRefCount` contains the same information. `lvaTrackedToVarNum` does have an advantage on 64 bit hosts in that it's half the size of `lvaSortByRefCount`. It's not clear what's the best solution `lvaSortByRefCount` does have the advantage that it contains direct pointers to lclvars so it should be faster.
* Actual sorting is done using the standard C library `qsort`. This implies an indirect call to the comparer function that blocks inlining and also pays the cost of `/guard:cf`. And the comparer code required by `qsort` is slightly more costly than the C++ style `less` predicate. A `std::sort`-like experimental implementation that avoids the indirect calls shows an improvement of ~0.45% in instructions retired.
* All lclvars are sorted but only first `lclMAX_TRACKED` lclvars need be. A partial sort algorithm could be beneficial in those cases where the JIT internally generates large number of lclvars (I think there was an issue with like 10000 lclvars). But such cases seem to be rare in corelib there are only a couple of methods with ~600 lclvars and the rest are below 512.
* Do we actually need to sort the lclvars? Or is it enough to just take the top 512 lclvars in no particular order? It's obvious that as far as liveness is concerned the order of the tracked variables is irrelevant. So far I only found a case (CSE heuristic) that appears to depend on the order.
</Description>
    <Title_Description>LclVar sorting throughput improvements Follow-up from #18504 discussion. There are a few inefficiencies around lclvar sorting (`lvaSortByRefCount`) that may worth addressing:
* `lvaSortByRefCount` is called 2-3 times during compilation of a method and every time it allocates memory for the `lvaRefSorted` array. The array could be cached and reused provided that potential increases of the lclvar count are considered.
* unlike `lvaSortByRefCount` `lvaTrackedToVarNum` is allocated only once. But its size is hardcoded to `lclMAX_TRACKED` and that's extremely large for many methods. The number of tracked variables is available before allocating so a more reasonably size can be used (again accounting for the fact that the number of lclvars may increase).
* `lvaTrackedToVarNum` is actually redundant `lvaSortByRefCount` contains the same information. `lvaTrackedToVarNum` does have an advantage on 64 bit hosts in that it's half the size of `lvaSortByRefCount`. It's not clear what's the best solution `lvaSortByRefCount` does have the advantage that it contains direct pointers to lclvars so it should be faster.
* Actual sorting is done using the standard C library `qsort`. This implies an indirect call to the comparer function that blocks inlining and also pays the cost of `/guard:cf`. And the comparer code required by `qsort` is slightly more costly than the C++ style `less` predicate. A `std::sort`-like experimental implementation that avoids the indirect calls shows an improvement of ~0.45% in instructions retired.
* All lclvars are sorted but only first `lclMAX_TRACKED` lclvars need be. A partial sort algorithm could be beneficial in those cases where the JIT internally generates large number of lclvars (I think there was an issue with like 10000 lclvars). But such cases seem to be rare in corelib there are only a couple of methods with ~600 lclvars and the rest are below 512.
* Do we actually need to sort the lclvars? Or is it enough to just take the top 512 lclvars in no particular order? It's obvious that as far as liveness is concerned the order of the tracked variables is irrelevant. So far I only found a case (CSE heuristic) that appears to depend on the order.
</Title_Description>
    <Label>JitThroughput</Label>
    <Assignee>AndyAyersMS</Assignee>
    <CreatedAt>11/07/2018 6:03:25 PM +00:00</CreatedAt>
    <ClosedAt>13/09/2019 2:45:05 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18867</IssueLabelID>
    <Title>RyuJIT spills 16 bit value but reloads as 32 bits in ARM32/x86 in release</Title>
    <Description>For ARM32 the example is:
```csharp
interface IRT { void WriteLine&lt;T&gt;(T val); }
class CRT : IRT { public void WriteLine&lt;T&gt;(T val) =&gt; System.Console.WriteLine(val); }
public class Program
{
    static IRT s_rt;
    static byte[] s_1 = new byte[] { 0 };
    static int s_3;
    static ushort[] s_8 = new ushort[] { 1 };

    public static void Main()
    {
        s_rt = new CRT();
        M11(s_8 0 0 0 true s_1);
    }

    static ushort M11(ushort[] arg0 ushort arg1 ushort arg3 byte arg4 bool arg7 byte[] arg10)
    {
        if (arg7)
        {
            ulong var4 = (ulong)s_3;
            arg3 = s_8[0];
            ushort var5 = arg3;
            s_rt.WriteLine(var4);
            s_rt.WriteLine((int)var5); // prints large negative value on my machine
        }
		
        if (!arg7)
        {
            var vr7 = arg0[0];
        }

        arg10[0] = arg4;
        return arg1;
    }
}
```

This does not repro on x64. With AltJit I get the following disassembly which shows `(int)var5` loading the argument as 32 bits:
```asm
; Assembly listing for method Program:M11(refushortushortubyteboolref):ushort
; Emitting BLENDED_CODE for generic ARM CPU
; optimized code
; r11 based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00T00] (  5  3.50)     ref  -&gt;   r4         class-hnd
;  V01 arg1         [V01T05] (  3  3   )  ushort  -&gt;   r7
;  V02 arg2         [V02T04] (  5  3.50)  ushort  -&gt;  [sp+0x0C]
;  V03 arg3         [V03T03] (  4  4   )   ubyte  -&gt;   r5
;  V04 arg4         [V04T10] (  2  2   )    bool  -&gt;   r0
;  V05 arg5         [V05T06] (  4  4   )     ref  -&gt;   r8         class-hnd
;* V06 loc0         [V06    ] (  0  0   )    long  -&gt;  zero-ref
;* V07 loc1         [V07    ] (  0  0   )  ushort  -&gt;  zero-ref
;# V08 OutArgs      [V08    ] (  1  1   )  lclBlk ( 0) [sp+0x00]
;  V09 tmp1         [V09T07] (  3  3   )     ref  -&gt;  [sp+0x00]
;  V10 tmp2         [V10T11] (  2  2   )     int  -&gt;  [sp+0x08]
;  V11 tmp3         [V11T08] (  3  3   )     ref  -&gt;   r6
;  V12 tmp4         [V12T12] (  2  2   )     int  -&gt;  [sp+0x04]
;  V13 tmp5         [V13T01] (  6  6   )     ref  -&gt;   r0
;  V14 cse0         [V14T02] (  6  6   )     int  -&gt;   r9
;  V15 rat0         [V15T13] (  2  1   )     int  -&gt;   r6         V06.lo(offs=0x00)
;  V16 rat1         [V16T14] (  2  1   )     int  -&gt;  r10         V06.hi(offs=0x04)
;  V17 rat2         [V17T09] (  3  3   )     int  -&gt;   r0
;
; Lcl frame size = 20

G_M58754_IG01:
000000  E92D 4FF0      push    {r4r5r6r7r8r9r10r11lr}
000004  B085           sub     sp 20
000006  F10D 0B30      add     r11 sp 48
00000A  4604           mov     r4 r0
00000C  460F           mov     r7 r1
00000E  4616           mov     r6 r2
000010  461D           mov     r5 r3
000012  980E           ldr     r0 [sp+0x38]    // [V04 arg4]
000014  F8DD 803C      ldr     r8 [sp+0x3c]    // [V05 arg5]

G_M58754_IG02:
000018  FA5F F980      uxtb    r9 r0
00001C  F1B9 0F00      cmp     r9 0
000020  D047           beq     SHORT G_M58754_IG03
000022  F244 008C      movw    r0 0x408c
000026  F2C0 00EF      movt    r0 0xef
00002A  6800           ldr     r0 [r0]
00002C  EA4F 7AE0      asr     r10 r0 31
000030  4606           mov     r6 r0
000032  F641 40B4      movw    r0 0x1cb4
000036  F2C0 6024      movt    r0 0x624
00003A  6800           ldr     r0 [r0]
00003C  2100           movs    r1 0
00003E  6842           ldr     r2 [r0+4]
000040  4291           cmp     r1 r2
000042  D248           bhs     SHORT G_M58754_IG06
000044  8900           ldrh    r0 [r0+8]
000046  F8AD 000C      strh    r0 [sp+0x0c]    // [V02 arg2]  &lt;------------------ store as 16 bits
00004A  F641 40AC      movw    r0 0x1cac
00004E  F2C0 6024      movt    r0 0x624
000052  F8D0 E000      ldr     lr [r0]
000056  F8CD E000      str     lr [sp] // [V09 tmp1]
00005A  4670           mov     r0 lr
00005C  F644 1194      movw    r1 0x4994
000060  F2C0 01EF      movt    r1 0xef
000064  F644 3210      movw    r2 0x4b10
000068  F2C0 02EF      movt    r2 0xef
00006C  F245 5CA0      movw    r12 0x55a0
000070  F6C0 7CCB      movt    r12 0xfcb
000074  47E0           blx     r12              // CORINFO_HELP_VIRTUAL_FUNC_PTR
000076  9002           str     r0 [sp+0x08]    // [V10 tmp2]
000078  9800           ldr     r0 [sp] // [V09 tmp1]
00007A  4632           mov     r2 r6
00007C  4653           mov     r3 r10
00007E  9902           ldr     r1 [sp+0x08]    // [V10 tmp2]
000080  4788           blx     r1
000082  F641 40AC      movw    r0 0x1cac
000086  F2C0 6024      movt    r0 0x624
00008A  6806           ldr     r6 [r0]
00008C  4630           mov     r0 r6
00008E  F644 1194      movw    r1 0x4994
000092  F2C0 01EF      movt    r1 0xef
000096  F644 3274      movw    r2 0x4b74
00009A  F2C0 02EF      movt    r2 0xef
00009E  F245 53A0      movw    r3 0x55a0
0000A2  F6C0 73CB      movt    r3 0xfcb
0000A6  4798           blx     r3               // CORINFO_HELP_VIRTUAL_FUNC_PTR
0000A8  9001           str     r0 [sp+0x04]    // [V12 tmp4]
0000AA  4630           mov     r0 r6
0000AC  9903           ldr     r1 [sp+0x0c]    // [V02 arg2]   &lt;------------------ load as 32 bits
0000AE  9B01           ldr     r3 [sp+0x04]    // [V12 tmp4]
0000B0  4798           blx     r3

G_M58754_IG03:
0000B2  F1B9 0F00      cmp     r9 0
0000B6  D103           bne     SHORT G_M58754_IG04
0000B8  2000           movs    r0 0
0000BA  6863           ldr     r3 [r4+4]
0000BC  4298           cmp     r0 r3
0000BE  D20A           bhs     SHORT G_M58754_IG06

G_M58754_IG04:
0000C0  2000           movs    r0 0
0000C2  F8D8 3004      ldr     r3 [r8+4]
0000C6  4298           cmp     r0 r3
0000C8  D205           bhs     SHORT G_M58754_IG06
0000CA  F888 5008      strb    r5 [r8+8]
0000CE  B2B8           uxth    r0 r7

G_M58754_IG05:
0000D0  B005           add     sp 20
0000D2  E8BD 8FF0      pop     {r4r5r6r7r8r9r10r11pc}

G_M58754_IG06:
0000D6  F647 33B0      movw    r3 0x7bb0
0000DA  F6C0 73CB      movt    r3 0xfcb
0000DE  4798           blx     r3               // CORINFO_HELP_RNGCHKFAIL
0000E0  DEFE           bkpt

; Total bytes of code 226 prolog size 10 for method Program:M11(refushortushortubyteboolref):ushort
; ============================================================
```

It seems most of the example is only necessary to ensure that `arg3` get spilled to the stack. Without the spill the example runs correctly.

AltJit dump: https://gist.github.com/jakobbotsch/6ebc59af5e0a90df73c8c109a58bd301

EDIT: With the help of @mikedn here is an adapted example which shows the same problem on x86. On my machine this prints the result correctly but the disassembly shows that it potentially passes garbage to the `WriteLine` call:

```csharp
interface IRT { void WriteLine&lt;T&gt;(T val); }
class CRT : IRT { public void WriteLine&lt;T&gt;(T val) =&gt; System.Console.WriteLine(val); }
public class Program
{
    static IRT s_rt;
    static byte[] s_1 = new byte[] { 0 };
    static int s_3;
    static ushort[] s_8 = new ushort[] { 1 };

    public static void Main()
    {
        s_rt = new CRT();
        M11(0 s_8 0 0 true s_1);
    }

    static ushort M11(ushort arg3 ushort[] arg0 ushort arg1 byte arg4 bool arg7 byte[] arg10)
    {
        arg1 += arg4;
        arg1 += (byte)(arg7 ? 1 : 0);
        arg1 += arg10[0];
        arg4 += arg10[0];
        if (arg7)
        {
            ulong var4 = (ulong)s_3;
            arg3 = s_8[0];
            ushort var5 = arg3;
            s_rt.WriteLine(var4);
            s_rt.WriteLine((int)var5); // potential garbage passed in upper half
        }
		
        if (!arg7)
        {
            var vr7 = arg0[0];
        }

        arg10[0] = arg4;
        return arg1;
    }
}
```</Description>
    <Title_Description>RyuJIT spills 16 bit value but reloads as 32 bits in ARM32/x86 in release For ARM32 the example is:
```csharp
interface IRT { void WriteLine&lt;T&gt;(T val); }
class CRT : IRT { public void WriteLine&lt;T&gt;(T val) =&gt; System.Console.WriteLine(val); }
public class Program
{
    static IRT s_rt;
    static byte[] s_1 = new byte[] { 0 };
    static int s_3;
    static ushort[] s_8 = new ushort[] { 1 };

    public static void Main()
    {
        s_rt = new CRT();
        M11(s_8 0 0 0 true s_1);
    }

    static ushort M11(ushort[] arg0 ushort arg1 ushort arg3 byte arg4 bool arg7 byte[] arg10)
    {
        if (arg7)
        {
            ulong var4 = (ulong)s_3;
            arg3 = s_8[0];
            ushort var5 = arg3;
            s_rt.WriteLine(var4);
            s_rt.WriteLine((int)var5); // prints large negative value on my machine
        }
		
        if (!arg7)
        {
            var vr7 = arg0[0];
        }

        arg10[0] = arg4;
        return arg1;
    }
}
```

This does not repro on x64. With AltJit I get the following disassembly which shows `(int)var5` loading the argument as 32 bits:
```asm
; Assembly listing for method Program:M11(refushortushortubyteboolref):ushort
; Emitting BLENDED_CODE for generic ARM CPU
; optimized code
; r11 based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00T00] (  5  3.50)     ref  -&gt;   r4         class-hnd
;  V01 arg1         [V01T05] (  3  3   )  ushort  -&gt;   r7
;  V02 arg2         [V02T04] (  5  3.50)  ushort  -&gt;  [sp+0x0C]
;  V03 arg3         [V03T03] (  4  4   )   ubyte  -&gt;   r5
;  V04 arg4         [V04T10] (  2  2   )    bool  -&gt;   r0
;  V05 arg5         [V05T06] (  4  4   )     ref  -&gt;   r8         class-hnd
;* V06 loc0         [V06    ] (  0  0   )    long  -&gt;  zero-ref
;* V07 loc1         [V07    ] (  0  0   )  ushort  -&gt;  zero-ref
;# V08 OutArgs      [V08    ] (  1  1   )  lclBlk ( 0) [sp+0x00]
;  V09 tmp1         [V09T07] (  3  3   )     ref  -&gt;  [sp+0x00]
;  V10 tmp2         [V10T11] (  2  2   )     int  -&gt;  [sp+0x08]
;  V11 tmp3         [V11T08] (  3  3   )     ref  -&gt;   r6
;  V12 tmp4         [V12T12] (  2  2   )     int  -&gt;  [sp+0x04]
;  V13 tmp5         [V13T01] (  6  6   )     ref  -&gt;   r0
;  V14 cse0         [V14T02] (  6  6   )     int  -&gt;   r9
;  V15 rat0         [V15T13] (  2  1   )     int  -&gt;   r6         V06.lo(offs=0x00)
;  V16 rat1         [V16T14] (  2  1   )     int  -&gt;  r10         V06.hi(offs=0x04)
;  V17 rat2         [V17T09] (  3  3   )     int  -&gt;   r0
;
; Lcl frame size = 20

G_M58754_IG01:
000000  E92D 4FF0      push    {r4r5r6r7r8r9r10r11lr}
000004  B085           sub     sp 20
000006  F10D 0B30      add     r11 sp 48
00000A  4604           mov     r4 r0
00000C  460F           mov     r7 r1
00000E  4616           mov     r6 r2
000010  461D           mov     r5 r3
000012  980E           ldr     r0 [sp+0x38]    // [V04 arg4]
000014  F8DD 803C      ldr     r8 [sp+0x3c]    // [V05 arg5]

G_M58754_IG02:
000018  FA5F F980      uxtb    r9 r0
00001C  F1B9 0F00      cmp     r9 0
000020  D047           beq     SHORT G_M58754_IG03
000022  F244 008C      movw    r0 0x408c
000026  F2C0 00EF      movt    r0 0xef
00002A  6800           ldr     r0 [r0]
00002C  EA4F 7AE0      asr     r10 r0 31
000030  4606           mov     r6 r0
000032  F641 40B4      movw    r0 0x1cb4
000036  F2C0 6024      movt    r0 0x624
00003A  6800           ldr     r0 [r0]
00003C  2100           movs    r1 0
00003E  6842           ldr     r2 [r0+4]
000040  4291           cmp     r1 r2
000042  D248           bhs     SHORT G_M58754_IG06
000044  8900           ldrh    r0 [r0+8]
000046  F8AD 000C      strh    r0 [sp+0x0c]    // [V02 arg2]  &lt;------------------ store as 16 bits
00004A  F641 40AC      movw    r0 0x1cac
00004E  F2C0 6024      movt    r0 0x624
000052  F8D0 E000      ldr     lr [r0]
000056  F8CD E000      str     lr [sp] // [V09 tmp1]
00005A  4670           mov     r0 lr
00005C  F644 1194      movw    r1 0x4994
000060  F2C0 01EF      movt    r1 0xef
000064  F644 3210      movw    r2 0x4b10
000068  F2C0 02EF      movt    r2 0xef
00006C  F245 5CA0      movw    r12 0x55a0
000070  F6C0 7CCB      movt    r12 0xfcb
000074  47E0           blx     r12              // CORINFO_HELP_VIRTUAL_FUNC_PTR
000076  9002           str     r0 [sp+0x08]    // [V10 tmp2]
000078  9800           ldr     r0 [sp] // [V09 tmp1]
00007A  4632           mov     r2 r6
00007C  4653           mov     r3 r10
00007E  9902           ldr     r1 [sp+0x08]    // [V10 tmp2]
000080  4788           blx     r1
000082  F641 40AC      movw    r0 0x1cac
000086  F2C0 6024      movt    r0 0x624
00008A  6806           ldr     r6 [r0]
00008C  4630           mov     r0 r6
00008E  F644 1194      movw    r1 0x4994
000092  F2C0 01EF      movt    r1 0xef
000096  F644 3274      movw    r2 0x4b74
00009A  F2C0 02EF      movt    r2 0xef
00009E  F245 53A0      movw    r3 0x55a0
0000A2  F6C0 73CB      movt    r3 0xfcb
0000A6  4798           blx     r3               // CORINFO_HELP_VIRTUAL_FUNC_PTR
0000A8  9001           str     r0 [sp+0x04]    // [V12 tmp4]
0000AA  4630           mov     r0 r6
0000AC  9903           ldr     r1 [sp+0x0c]    // [V02 arg2]   &lt;------------------ load as 32 bits
0000AE  9B01           ldr     r3 [sp+0x04]    // [V12 tmp4]
0000B0  4798           blx     r3

G_M58754_IG03:
0000B2  F1B9 0F00      cmp     r9 0
0000B6  D103           bne     SHORT G_M58754_IG04
0000B8  2000           movs    r0 0
0000BA  6863           ldr     r3 [r4+4]
0000BC  4298           cmp     r0 r3
0000BE  D20A           bhs     SHORT G_M58754_IG06

G_M58754_IG04:
0000C0  2000           movs    r0 0
0000C2  F8D8 3004      ldr     r3 [r8+4]
0000C6  4298           cmp     r0 r3
0000C8  D205           bhs     SHORT G_M58754_IG06
0000CA  F888 5008      strb    r5 [r8+8]
0000CE  B2B8           uxth    r0 r7

G_M58754_IG05:
0000D0  B005           add     sp 20
0000D2  E8BD 8FF0      pop     {r4r5r6r7r8r9r10r11pc}

G_M58754_IG06:
0000D6  F647 33B0      movw    r3 0x7bb0
0000DA  F6C0 73CB      movt    r3 0xfcb
0000DE  4798           blx     r3               // CORINFO_HELP_RNGCHKFAIL
0000E0  DEFE           bkpt

; Total bytes of code 226 prolog size 10 for method Program:M11(refushortushortubyteboolref):ushort
; ============================================================
```

It seems most of the example is only necessary to ensure that `arg3` get spilled to the stack. Without the spill the example runs correctly.

AltJit dump: https://gist.github.com/jakobbotsch/6ebc59af5e0a90df73c8c109a58bd301

EDIT: With the help of @mikedn here is an adapted example which shows the same problem on x86. On my machine this prints the result correctly but the disassembly shows that it potentially passes garbage to the `WriteLine` call:

```csharp
interface IRT { void WriteLine&lt;T&gt;(T val); }
class CRT : IRT { public void WriteLine&lt;T&gt;(T val) =&gt; System.Console.WriteLine(val); }
public class Program
{
    static IRT s_rt;
    static byte[] s_1 = new byte[] { 0 };
    static int s_3;
    static ushort[] s_8 = new ushort[] { 1 };

    public static void Main()
    {
        s_rt = new CRT();
        M11(0 s_8 0 0 true s_1);
    }

    static ushort M11(ushort arg3 ushort[] arg0 ushort arg1 byte arg4 bool arg7 byte[] arg10)
    {
        arg1 += arg4;
        arg1 += (byte)(arg7 ? 1 : 0);
        arg1 += arg10[0];
        arg4 += arg10[0];
        if (arg7)
        {
            ulong var4 = (ulong)s_3;
            arg3 = s_8[0];
            ushort var5 = arg3;
            s_rt.WriteLine(var4);
            s_rt.WriteLine((int)var5); // potential garbage passed in upper half
        }
		
        if (!arg7)
        {
            var vr7 = arg0[0];
        }

        arg10[0] = arg4;
        return arg1;
    }
}
```</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>11/07/2018 11:51:18 AM +00:00</CreatedAt>
    <ClosedAt>27/11/2018 12:31:38 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18865</IssueLabelID>
    <Title>"SIGSEGV: address access protected" on Debian 9</Title>
    <Description>Unfortunately I don't have a consistent repro of this problem and only have had this happen very rarely where the app aborted with no info. Last night I started it in lldb and left it running over night and it crashed with "address access protected".

```
Process 24736 stopped
* thread #356: tid = 7611 0x00007fff80790c54 name = 'dotnet' stop reason = signal SIGSEGV: address access protected (fault address: 0x7fff5986e300)
    frame #0: 0x00007fff80790c54
-&gt;  0x7fff80790c54: movq   (%r14) %rdi
    0x7fff80790c57: testq  %rdi %rdi
    0x7fff80790c5a: jne    0x7fff80790c71
    0x7fff80790c5c: xorl   %r14d %r14d
```

bt:
```
* thread #356: tid = 7611 0x00007fff80790c54 name = 'dotnet' stop reason = signal SIGSEGV: address access protected (fault address: 0x7fff5986e300)
  * frame #0: 0x00007fff80790c54
    frame #1: 0x00007fff8039b5d4
    frame #2: 0x00007fff7cb2cf9d
    frame #3: 0x00007fff8039c180
    frame #4: 0x00007fff7cbba637
    frame #5: 0x00007fff7cb7098e
    frame #6: 0x00007fff7cbf641c
    frame #7: 0x00007fff7cbc93bf
    frame #8: 0x00007fff7d0ea47c
    frame #9: 0x00007fff7cb2cf9d
    frame #10: 0x00007fff803868d0
    frame #11: 0x00007fff7cbba637
    frame #12: 0x00007fff7cb7098e
    frame #13: 0x00007fff7cbbfd46
    frame #14: 0x00007fff7cbfc60b
    frame #15: 0x00007fff7eea1415
    frame #16: 0x00007fff7cb2cf9d
    frame #17: 0x00007fff80385f41
    frame #18: 0x00007fff7cbba637
    frame #19: 0x00007fff7cb7098e
    frame #20: 0x00007fff7cbbfd46
    frame #21: 0x00007fff7cbfc60b
    frame #22: 0x00007fff7eea8abb
    frame #23: 0x00007fff7cb2cf9d
    frame #24: 0x00007fff80385871
    frame #25: 0x00007fff7cbba637
    frame #26: 0x00007fff7cb7098e
    frame #27: 0x00007fff7cc0fc1a
    frame #28: 0x00007fff7cbf7dbf
    frame #29: 0x00007fff7eece4f5
    frame #30: 0x00007fff7cb2cf9d
    frame #31: 0x00007fff803851c0
    frame #32: 0x00007fff7cbba637
    frame #33: 0x00007fff7cb7098e
    frame #34: 0x00007fff7cb6eda1
    frame #35: 0x00007fff7cb6f6b1
    frame #36: 0x00007fff7ccc49f8
    frame #37: 0x00007fff7cbaca40
    frame #38: 0x00007fff7cbf27d5
    frame #39: 0x00007fff7cb709b3
    frame #40: 0x00007fff7eef083a
    frame #41: 0x00007fff7eef0672
    frame #42: 0x00007fff7eef41c0
    frame #43: 0x00007fff7cb2cf9d
    frame #44: 0x00007fff7feffd50
    frame #45: 0x00007fff7cbba637
    frame #46: 0x00007fff7cb7098e
    frame #47: 0x00007fff7eef399a
    frame #48: 0x00007fff7eef3744
    frame #49: 0x00007fff7eef2128
    frame #50: 0x00007fff7cb2cf9d
    frame #51: 0x00007fff7eef32e0
    frame #52: 0x00007fff7cbba637
    frame #53: 0x00007fff7cb7098e
    frame #54: 0x00007fff7eef083a
    frame #55: 0x00007fff7eef0672
    frame #56: 0x00007fff7eeb3799
    frame #57: 0x00007fff7cb2cf9d
    frame #58: 0x00007fff7eeefd70
    frame #59: 0x00007fff7cbba637
    frame #60: 0x00007fff7cb7098e
    frame #61: 0x00007fff7cb77a5a
    frame #62: 0x00007fff7cbf8ebe
    frame #63: 0x00007fff7eee6a4a
    frame #64: 0x00007fff7cb2cf9d
    frame #65: 0x00007fff7eeeeb70
    frame #66: 0x00007fff7f026d73
    frame #67: 0x00007fff7cb2cf9d
    frame #68: 0x00007fff7f028169
    frame #69: 0x00007fff7f0295a4
    frame #70: 0x00007fff7f028686
    frame #71: 0x00007fff7f035d1b
    frame #72: 0x00007fff7f036318
    frame #73: 0x00007ffff6269ecf libcoreclr.so`??? + 124
    frame #74: 0x00007ffff618a5fc libcoreclr.so`??? + 940
    frame #75: 0x00007ffff630a845 libcoreclr.so`??? + 181
    frame #76: 0x00007ffff615bf2d libcoreclr.so`??? + 413
    frame #77: 0x00007ffff615c690 libcoreclr.so`??? + 64
    frame #78: 0x00007ffff62eea47 libcoreclr.so`??? + 295
    frame #79: 0x00007ffff617ad23 libcoreclr.so`??? + 1267
    frame #80: 0x00007ffff64f0f62 libcoreclr.so`??? + 306
    frame #81: 0x00007ffff79bf494 libpthread.so.0`start_thread + 196
    frame #82: 0x00007ffff6e64acf libc.so.6`clone + 63
```

dotnet-sdk is 2.1.301-1 and dotnet-runtime is 2.1.1-1.

```
$ uname -a
Linux bellevue 4.9.0-5-amd64 #1 SMP Debian 4.9.65-3+deb9u2 (2018-01-04) x86_64 GNU/Linux
```

Unfortunately it seems there's no debug symbols loaded so the stacktrace seems rather unhelpful. What would be my next step here?</Description>
    <Title_Description>"SIGSEGV: address access protected" on Debian 9 Unfortunately I don't have a consistent repro of this problem and only have had this happen very rarely where the app aborted with no info. Last night I started it in lldb and left it running over night and it crashed with "address access protected".

```
Process 24736 stopped
* thread #356: tid = 7611 0x00007fff80790c54 name = 'dotnet' stop reason = signal SIGSEGV: address access protected (fault address: 0x7fff5986e300)
    frame #0: 0x00007fff80790c54
-&gt;  0x7fff80790c54: movq   (%r14) %rdi
    0x7fff80790c57: testq  %rdi %rdi
    0x7fff80790c5a: jne    0x7fff80790c71
    0x7fff80790c5c: xorl   %r14d %r14d
```

bt:
```
* thread #356: tid = 7611 0x00007fff80790c54 name = 'dotnet' stop reason = signal SIGSEGV: address access protected (fault address: 0x7fff5986e300)
  * frame #0: 0x00007fff80790c54
    frame #1: 0x00007fff8039b5d4
    frame #2: 0x00007fff7cb2cf9d
    frame #3: 0x00007fff8039c180
    frame #4: 0x00007fff7cbba637
    frame #5: 0x00007fff7cb7098e
    frame #6: 0x00007fff7cbf641c
    frame #7: 0x00007fff7cbc93bf
    frame #8: 0x00007fff7d0ea47c
    frame #9: 0x00007fff7cb2cf9d
    frame #10: 0x00007fff803868d0
    frame #11: 0x00007fff7cbba637
    frame #12: 0x00007fff7cb7098e
    frame #13: 0x00007fff7cbbfd46
    frame #14: 0x00007fff7cbfc60b
    frame #15: 0x00007fff7eea1415
    frame #16: 0x00007fff7cb2cf9d
    frame #17: 0x00007fff80385f41
    frame #18: 0x00007fff7cbba637
    frame #19: 0x00007fff7cb7098e
    frame #20: 0x00007fff7cbbfd46
    frame #21: 0x00007fff7cbfc60b
    frame #22: 0x00007fff7eea8abb
    frame #23: 0x00007fff7cb2cf9d
    frame #24: 0x00007fff80385871
    frame #25: 0x00007fff7cbba637
    frame #26: 0x00007fff7cb7098e
    frame #27: 0x00007fff7cc0fc1a
    frame #28: 0x00007fff7cbf7dbf
    frame #29: 0x00007fff7eece4f5
    frame #30: 0x00007fff7cb2cf9d
    frame #31: 0x00007fff803851c0
    frame #32: 0x00007fff7cbba637
    frame #33: 0x00007fff7cb7098e
    frame #34: 0x00007fff7cb6eda1
    frame #35: 0x00007fff7cb6f6b1
    frame #36: 0x00007fff7ccc49f8
    frame #37: 0x00007fff7cbaca40
    frame #38: 0x00007fff7cbf27d5
    frame #39: 0x00007fff7cb709b3
    frame #40: 0x00007fff7eef083a
    frame #41: 0x00007fff7eef0672
    frame #42: 0x00007fff7eef41c0
    frame #43: 0x00007fff7cb2cf9d
    frame #44: 0x00007fff7feffd50
    frame #45: 0x00007fff7cbba637
    frame #46: 0x00007fff7cb7098e
    frame #47: 0x00007fff7eef399a
    frame #48: 0x00007fff7eef3744
    frame #49: 0x00007fff7eef2128
    frame #50: 0x00007fff7cb2cf9d
    frame #51: 0x00007fff7eef32e0
    frame #52: 0x00007fff7cbba637
    frame #53: 0x00007fff7cb7098e
    frame #54: 0x00007fff7eef083a
    frame #55: 0x00007fff7eef0672
    frame #56: 0x00007fff7eeb3799
    frame #57: 0x00007fff7cb2cf9d
    frame #58: 0x00007fff7eeefd70
    frame #59: 0x00007fff7cbba637
    frame #60: 0x00007fff7cb7098e
    frame #61: 0x00007fff7cb77a5a
    frame #62: 0x00007fff7cbf8ebe
    frame #63: 0x00007fff7eee6a4a
    frame #64: 0x00007fff7cb2cf9d
    frame #65: 0x00007fff7eeeeb70
    frame #66: 0x00007fff7f026d73
    frame #67: 0x00007fff7cb2cf9d
    frame #68: 0x00007fff7f028169
    frame #69: 0x00007fff7f0295a4
    frame #70: 0x00007fff7f028686
    frame #71: 0x00007fff7f035d1b
    frame #72: 0x00007fff7f036318
    frame #73: 0x00007ffff6269ecf libcoreclr.so`??? + 124
    frame #74: 0x00007ffff618a5fc libcoreclr.so`??? + 940
    frame #75: 0x00007ffff630a845 libcoreclr.so`??? + 181
    frame #76: 0x00007ffff615bf2d libcoreclr.so`??? + 413
    frame #77: 0x00007ffff615c690 libcoreclr.so`??? + 64
    frame #78: 0x00007ffff62eea47 libcoreclr.so`??? + 295
    frame #79: 0x00007ffff617ad23 libcoreclr.so`??? + 1267
    frame #80: 0x00007ffff64f0f62 libcoreclr.so`??? + 306
    frame #81: 0x00007ffff79bf494 libpthread.so.0`start_thread + 196
    frame #82: 0x00007ffff6e64acf libc.so.6`clone + 63
```

dotnet-sdk is 2.1.301-1 and dotnet-runtime is 2.1.1-1.

```
$ uname -a
Linux bellevue 4.9.0-5-amd64 #1 SMP Debian 4.9.65-3+deb9u2 (2018-01-04) x86_64 GNU/Linux
```

Unfortunately it seems there's no debug symbols loaded so the stacktrace seems rather unhelpful. What would be my next step here?</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18864</IssueLabelID>
    <Title>Add no tiered compilation test jobs</Title>
    <Description>With the upcoming switch to make tiered compilation on by default we want to preserve some JIT testing that will not enable tiered compilation.
1) Add 'no_tiered_compilation_pri0' jit stress job logically the non-tiered variant of current 'Innerloop' jobs
   - This job runs on all PRs for Checked x (Windows x86 Windows x64 Ubuntu arm)
2) Add 'no_tiered_compilation' jit stress job logically the non-tiered variant of the current 'normal' job
   - This job has the same periodic schedule as other jit stress jobs
3) Add 'r2r_no_tiered_compilation' r2r stress job logically the non-tiered variant of the current 'r2r' job
   - This job has the same periodic schedule as other r2r stress jobs

Misc adjustments:
a) Added isPri0TestScenario because 'innerloop' is no longer the only scenario name which has this property + eliminated various comments that implied 'innerloop' IFF pri0
b) updated the contxtString generation for arm jobs to make it more consistent with the naming computed for other architectures

This is a continuation of the work that started in #18828</Description>
    <Title_Description>Add no tiered compilation test jobs With the upcoming switch to make tiered compilation on by default we want to preserve some JIT testing that will not enable tiered compilation.
1) Add 'no_tiered_compilation_pri0' jit stress job logically the non-tiered variant of current 'Innerloop' jobs
   - This job runs on all PRs for Checked x (Windows x86 Windows x64 Ubuntu arm)
2) Add 'no_tiered_compilation' jit stress job logically the non-tiered variant of the current 'normal' job
   - This job has the same periodic schedule as other jit stress jobs
3) Add 'r2r_no_tiered_compilation' r2r stress job logically the non-tiered variant of the current 'r2r' job
   - This job has the same periodic schedule as other r2r stress jobs

Misc adjustments:
a) Added isPri0TestScenario because 'innerloop' is no longer the only scenario name which has this property + eliminated various comments that implied 'innerloop' IFF pri0
b) updated the contxtString generation for arm jobs to make it more consistent with the naming computed for other architectures

This is a continuation of the work that started in #18828</Title_Description>
    <Label>area-TieredCompilation</Label>
    <Assignee>kouvel</Assignee>
    <CreatedAt>11/07/2018 4:31:44 AM +00:00</CreatedAt>
    <ClosedAt>16/07/2018 8:48:38 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18863</IssueLabelID>
    <Title>JIT Hints- Parameter conditional inlining directives or improve call-site inlining of funcs with constant args feeding structs</Title>
    <Description>In dotnet/corefx#30934 we have this code:

```cs
        public static bool TryParse(ReadOnlySpan&lt;byte&gt; source out int value out int bytesConsumed char standardFormat = default)
        {
            switch (standardFormat)
            {
                case default(char):
                case 'g':
                case 'G':
                case 'd':
                case 'D':
                    return TryParseInt32D(source out value out bytesConsumed);

                case 'n':
                case 'N':
                    return TryParseInt32N(source out value out bytesConsumed);

                case 'x':
                case 'X':
                    value = default;
                    return TryParseUInt32X(source out Unsafe.As&lt;int uint&gt;(ref value) out bytesConsumed);

                default:
                    return ThrowHelper.TryParseThrowFormatException(out value out bytesConsumed);
            }
        }
```

If the `standardFormat` parameter has a constant value at the callsite we definitely want this function inlined; it can be entirely evaluated by the JIT and inlined to a call slightly smaller than the original. But if it's not it's not a particularly small function to be inlining; it's going to be the wrong choice in at least some cases. `[MethodImpl(MethodImplOptions.AggressiveInlining)]` is a rather blunt tool for this kind of scenario. It would be much better if we could do something like `public static bool TryParse(ReadOnlySpan&lt;byte&gt; source out int value out int bytesConsumed [ParamImpl(ParamImplOptions.InlineMethodWhenConstant)] char standardFormat = default)` to give more nuance to the JIT hints.

category:cq
theme:inlining
skill-level:expert
cost:extra-large</Description>
    <Title_Description>JIT Hints- Parameter conditional inlining directives, or, improve call-site inlining of funcs with constant args feeding structs In dotnet/corefx#30934 we have this code:

```cs
        public static bool TryParse(ReadOnlySpan&lt;byte&gt; source out int value out int bytesConsumed char standardFormat = default)
        {
            switch (standardFormat)
            {
                case default(char):
                case 'g':
                case 'G':
                case 'd':
                case 'D':
                    return TryParseInt32D(source out value out bytesConsumed);

                case 'n':
                case 'N':
                    return TryParseInt32N(source out value out bytesConsumed);

                case 'x':
                case 'X':
                    value = default;
                    return TryParseUInt32X(source out Unsafe.As&lt;int uint&gt;(ref value) out bytesConsumed);

                default:
                    return ThrowHelper.TryParseThrowFormatException(out value out bytesConsumed);
            }
        }
```

If the `standardFormat` parameter has a constant value at the callsite we definitely want this function inlined; it can be entirely evaluated by the JIT and inlined to a call slightly smaller than the original. But if it's not it's not a particularly small function to be inlining; it's going to be the wrong choice in at least some cases. `[MethodImpl(MethodImplOptions.AggressiveInlining)]` is a rather blunt tool for this kind of scenario. It would be much better if we could do something like `public static bool TryParse(ReadOnlySpan&lt;byte&gt; source out int value out int bytesConsumed [ParamImpl(ParamImplOptions.InlineMethodWhenConstant)] char standardFormat = default)` to give more nuance to the JIT hints.

category:cq
theme:inlining
skill-level:expert
cost:extra-large</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
    <CreatedAt>11/07/2018 4:24:06 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18859</IssueLabelID>
    <Title>GS cookie check fix for debugger stackwalks port</Title>
    <Description>This bug fix is a port from the equivalent fix in framework. The debugger tried performing a stackwalk in the epilog due to the JIT incorrectly reporting epilogue information. This caused an invalid GS cookie to be checked and caused the debugger to crash. A flag was added to allow debug stackwalks to skip the cookie check.

@noahfalk @sbomer</Description>
    <Title_Description>GS cookie check fix for debugger stackwalks port This bug fix is a port from the equivalent fix in framework. The debugger tried performing a stackwalk in the epilog due to the JIT incorrectly reporting epilogue information. This caused an invalid GS cookie to be checked and caused the debugger to crash. A flag was added to allow debug stackwalks to skip the cookie check.

@noahfalk @sbomer</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>hoyosjs</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18858</IssueLabelID>
    <Title>[OSX] JIT/HardwareIntrinsics/X86/Avx/Avx_ro Intermittent failures</Title>
    <Description>The following test failure
```
Stacktrace
MESSAGE:
BEGIN EXECUTION /Users/dotnet-bot/j/workspace/dotnet_coreclr/master/x64_checked_osx10.12_innerloop_tst_prtest/bin/tests/OSX.x64.Checked/Tests/Core_Root/corerun Avx_ro.exe Running Add.Double test... Running Add.Single test... Running AddSubtract.Double test... Running AddSubtract.Single test... Running And.Double test... Running And.Single test... Running AndNot.Double test... Running AndNot.Single test... Running BlendVariable.Double test... Running BlendVariable.Single test... Running Ceiling.Double test... Running Ceiling.Single test... Running Divide.Double test... Running Divide.Single test... Running DuplicateEvenIndexed.Double test... Running DuplicateEvenIndexed.Single test... Running DuplicateOddIndexed.Single test... Running Extract.Byte.1 test... ./Avx_ro.sh: line 244: 4647 Abort trap: 6 (core dumped) $_DebuggerFullPath "$CORE_ROOT/corerun" $ExePath $CLRTestExecutionArguments Expected: 100 Actual: 134 END EXECUTION - FAILED
+++++++++++++++++++
STACK TRACE:
```
happened in different PRs over the last couple days
https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_checked_osx10.12_innerloop_tst_prtest/4002/
https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_checked_osx10.12_innerloop_tst_prtest/4019/
https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_checked_osx10.12_innerloop_tst_prtest/4020/
https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_checked_osx10.12_innerloop_tst_prtest/4021/
https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_checked_osx10.12_innerloop_tst_prtest/4025/

The earlies I could track it was [Build #4002 (Jul 9 2018 8:10:43 PM)](https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_checked_osx10.12_innerloop_tst_prtest/4002/)


Seems that problem always occurs right after *Running Extract.Byte.1 test...* message</Description>
    <Title_Description>[OSX] JIT/HardwareIntrinsics/X86/Avx/Avx_ro Intermittent failures The following test failure
```
Stacktrace
MESSAGE:
BEGIN EXECUTION /Users/dotnet-bot/j/workspace/dotnet_coreclr/master/x64_checked_osx10.12_innerloop_tst_prtest/bin/tests/OSX.x64.Checked/Tests/Core_Root/corerun Avx_ro.exe Running Add.Double test... Running Add.Single test... Running AddSubtract.Double test... Running AddSubtract.Single test... Running And.Double test... Running And.Single test... Running AndNot.Double test... Running AndNot.Single test... Running BlendVariable.Double test... Running BlendVariable.Single test... Running Ceiling.Double test... Running Ceiling.Single test... Running Divide.Double test... Running Divide.Single test... Running DuplicateEvenIndexed.Double test... Running DuplicateEvenIndexed.Single test... Running DuplicateOddIndexed.Single test... Running Extract.Byte.1 test... ./Avx_ro.sh: line 244: 4647 Abort trap: 6 (core dumped) $_DebuggerFullPath "$CORE_ROOT/corerun" $ExePath $CLRTestExecutionArguments Expected: 100 Actual: 134 END EXECUTION - FAILED
+++++++++++++++++++
STACK TRACE:
```
happened in different PRs over the last couple days
https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_checked_osx10.12_innerloop_tst_prtest/4002/
https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_checked_osx10.12_innerloop_tst_prtest/4019/
https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_checked_osx10.12_innerloop_tst_prtest/4020/
https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_checked_osx10.12_innerloop_tst_prtest/4021/
https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_checked_osx10.12_innerloop_tst_prtest/4025/

The earlies I could track it was [Build #4002 (Jul 9 2018 8:10:43 PM)](https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_checked_osx10.12_innerloop_tst_prtest/4002/)


Seems that problem always occurs right after *Running Extract.Byte.1 test...* message</Title_Description>
    <Label>arch-x64</Label>
    <Assignee>echesakovMSFT</Assignee>
    <CreatedAt>10/07/2018 9:26:24 PM +00:00</CreatedAt>
    <ClosedAt>20/07/2018 6:40:30 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18855</IssueLabelID>
    <Title>The `perf.groovy` script is not escaping the PR title properly when it contains double-quotes</Title>
    <Description>This issue was causing failures in https://github.com/dotnet/coreclr/pull/18849

For example: https://ci2.dot.net/job/dotnet_coreclr/job/perf/job/master/job/perf_perflab_Windows_NT_x64_min_opt_ryujit_smoketest_prtest/2556/</Description>
    <Title_Description>The `perf.groovy` script is not escaping the PR title properly when it contains double-quotes This issue was causing failures in https://github.com/dotnet/coreclr/pull/18849

For example: https://ci2.dot.net/job/dotnet_coreclr/job/perf/job/master/job/perf_perflab_Windows_NT_x64_min_opt_ryujit_smoketest_prtest/2556/</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>jorive</Assignee>
    <CreatedAt>10/07/2018 7:52:34 PM +00:00</CreatedAt>
    <ClosedAt>23/05/2019 9:36:22 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18852</IssueLabelID>
    <Title>coreclr Windows build broken in master branch with several compiler errors and MASM warnings</Title>
    <Description>Build of coreclr master branch dab0d7108e8b0091e1d7f526cab7dc9bcb71710a on Windows 10 x64 for Windows_NT x64 Checked target fails with the following errors:

```

MASM : warning A4018: invalid command-line option : /Yustdafx.h [E:\src\ms\dotnet\coreclr\bin\obj\Windows_NT.x64.Checked\src\debug\di\cordbdi.vcxproj]
MASM : warning A4018: invalid command-line option : /FpE:/src/ms/dotnet/coreclr/bin/obj/Windows_NT.x64.Checked/src/debug/di/Checked/stdafx.pch [E:\src\ms\dotnet\coreclr\bin\obj\Windows_NT.x64.Checked\
src\debug\di\cordbdi.vcxproj]
c:\program files (x86)\windows kits\10\include\10.0.17134.0\winrt\windows.storage.fileproperties.h(483): error C2882: 'Windows': illegal use of namespace identifier in expression (compiling source fil
e E:\src\ms\dotnet\coreclr\src\vm\comdelegate.cpp) [E:\src\ms\dotnet\coreclr\bin\obj\Windows_NT.x64.Checked\src\vm\wks\cee_wks.vcxproj]
c:\program files (x86)\windows kits\10\include\10.0.17134.0\winrt\windows.storage.fileproperties.h(483): error C2059: syntax error: ':' (compiling source file E:\src\ms\dotnet\coreclr\src\vm\comdelega
te.cpp) [E:\src\ms\dotnet\coreclr\bin\obj\Windows_NT.x64.Checked\src\vm\wks\cee_wks.vcxproj]
c:\program files (x86)\windows kits\10\include\10.0.17134.0\winrt\windows.storage.fileproperties.h(483): error C2653: 'zStorage': is not a class or namespace name (compiling source file E:\src\ms\dotn
et\coreclr\src\vm\comdelegate.cpp) [E:\src\ms\dotnet\coreclr\bin\obj\Windows_NT.x64.Checked\src\vm\wks\cee_wks.vcxproj]
c:\program files (x86)\windows kits\10\include\10.0.17134.0\winrt\windows.storage.fileproperties.h(483): error C2974: 'ABI::Windows::Foundation::Internal::AggregateType': invalid template argument for
 'LogicalType' type expected (compiling source file E:\src\ms\dotnet\coreclr\src\vm\comdelegate.cpp) [E:\src\ms\dotnet\coreclr\bin\obj\Windows_NT.x64.Checked\src\vm\wks\cee_wks.vcxproj]
c:\program files (x86)\windows kits\10\include\10.0.17134.0\winrt\windows.storage.fileproperties.h(483): error C3203: 'AggregateType': unspecialized class template can't be used as a template argument
 for template parameter 'TResult' expected a real type (compiling source file E:\src\ms\dotnet\coreclr\src\vm\comdelegate.cpp) [E:\src\ms\dotnet\coreclr\bin\obj\Windows_NT.x64.Checked\src\vm\wks\cee_
wks.vcxproj]
c:\program files (x86)\windows kits\10\include\10.0.17134.0\winrt\windows.storage.provider.h(2365): error C2144: syntax error: 'WCHAR' should be preceded by ';' (compiling source file E:\src\ms\dotnet
\coreclr\src\vm\comdelegate.cpp) [E:\src\ms\dotnet\coreclr\bin\obj\Windows_NT.x64.Checked\src\vm\wks\cee_wks.vcxproj]
c:\program files (x86)\windows kits\10\include\10.0.17134.0\winrt\windows.storage.provider.h(2365): error C4430: missing type specifier - int assumed. Note: C++ does not support default-int (compiling
 source file E:\src\ms\dotnet\coreclr\src\vm\comdelegate.cpp) [E:\src\ms\dotnet\coreclr\bin\obj\Windows_NT.x64.Checked\src\vm\wks\cee_wks.vcxproj]
e:\src\ms\dotnet\coreclr\src\md\inc\metamodelrw.h(405): error C2065: 'TBL_AssemblyRefProcessor': undeclared identifier [E:\src\ms\dotnet\coreclr\bin\obj\Windows_NT.x64.Checked\src\debug\daccess\dacces
s.vcxproj]
c:\program files (x86)\windows kits\10\include\10.0.17134.0\winrt\windows.foundation.collections.h(1129): fatal error C1001: An internal error has occurred in the compiler. [E:\src\ms\dotnet\coreclr\b
in\obj\Windows_NT.x64.Checked\src\vm\wks\cee_wks.vcxproj]
cl : Command line error D8040: error creating or communicating with child process [E:\src\ms\dotnet\coreclr\bin\obj\Windows_NT.x64.Checked\src\vm\wks\cee_wks.vcxproj]
    2 Warning(s)
    10 Error(s)

Time Elapsed 00:12:05.32
Command execution failed with exit code 1.
BUILD: Error: native component build failed. Refer to the build log files for details:
    "e:\src\ms\dotnet\coreclr\bin\Logs\CoreCLR_Windows_NT__x64__Checked.log"
    "e:\src\ms\dotnet\coreclr\bin\Logs\CoreCLR_Windows_NT__x64__Checked.wrn"
    "e:\src\ms\dotnet\coreclr\bin\Logs\CoreCLR_Windows_NT__x64__Checked.err"

e:\src\ms\dotnet\coreclr&gt;
```

Visual Studio v15.7.4 command: `build x64 Checked -skiptests`
Windows 10 Pro x64 PL with EN lang pack active version 1803</Description>
    <Title_Description>coreclr Windows build broken in master branch with several compiler errors and MASM warnings Build of coreclr master branch dab0d7108e8b0091e1d7f526cab7dc9bcb71710a on Windows 10 x64 for Windows_NT x64 Checked target fails with the following errors:

```

MASM : warning A4018: invalid command-line option : /Yustdafx.h [E:\src\ms\dotnet\coreclr\bin\obj\Windows_NT.x64.Checked\src\debug\di\cordbdi.vcxproj]
MASM : warning A4018: invalid command-line option : /FpE:/src/ms/dotnet/coreclr/bin/obj/Windows_NT.x64.Checked/src/debug/di/Checked/stdafx.pch [E:\src\ms\dotnet\coreclr\bin\obj\Windows_NT.x64.Checked\
src\debug\di\cordbdi.vcxproj]
c:\program files (x86)\windows kits\10\include\10.0.17134.0\winrt\windows.storage.fileproperties.h(483): error C2882: 'Windows': illegal use of namespace identifier in expression (compiling source fil
e E:\src\ms\dotnet\coreclr\src\vm\comdelegate.cpp) [E:\src\ms\dotnet\coreclr\bin\obj\Windows_NT.x64.Checked\src\vm\wks\cee_wks.vcxproj]
c:\program files (x86)\windows kits\10\include\10.0.17134.0\winrt\windows.storage.fileproperties.h(483): error C2059: syntax error: ':' (compiling source file E:\src\ms\dotnet\coreclr\src\vm\comdelega
te.cpp) [E:\src\ms\dotnet\coreclr\bin\obj\Windows_NT.x64.Checked\src\vm\wks\cee_wks.vcxproj]
c:\program files (x86)\windows kits\10\include\10.0.17134.0\winrt\windows.storage.fileproperties.h(483): error C2653: 'zStorage': is not a class or namespace name (compiling source file E:\src\ms\dotn
et\coreclr\src\vm\comdelegate.cpp) [E:\src\ms\dotnet\coreclr\bin\obj\Windows_NT.x64.Checked\src\vm\wks\cee_wks.vcxproj]
c:\program files (x86)\windows kits\10\include\10.0.17134.0\winrt\windows.storage.fileproperties.h(483): error C2974: 'ABI::Windows::Foundation::Internal::AggregateType': invalid template argument for
 'LogicalType' type expected (compiling source file E:\src\ms\dotnet\coreclr\src\vm\comdelegate.cpp) [E:\src\ms\dotnet\coreclr\bin\obj\Windows_NT.x64.Checked\src\vm\wks\cee_wks.vcxproj]
c:\program files (x86)\windows kits\10\include\10.0.17134.0\winrt\windows.storage.fileproperties.h(483): error C3203: 'AggregateType': unspecialized class template can't be used as a template argument
 for template parameter 'TResult' expected a real type (compiling source file E:\src\ms\dotnet\coreclr\src\vm\comdelegate.cpp) [E:\src\ms\dotnet\coreclr\bin\obj\Windows_NT.x64.Checked\src\vm\wks\cee_
wks.vcxproj]
c:\program files (x86)\windows kits\10\include\10.0.17134.0\winrt\windows.storage.provider.h(2365): error C2144: syntax error: 'WCHAR' should be preceded by ';' (compiling source file E:\src\ms\dotnet
\coreclr\src\vm\comdelegate.cpp) [E:\src\ms\dotnet\coreclr\bin\obj\Windows_NT.x64.Checked\src\vm\wks\cee_wks.vcxproj]
c:\program files (x86)\windows kits\10\include\10.0.17134.0\winrt\windows.storage.provider.h(2365): error C4430: missing type specifier - int assumed. Note: C++ does not support default-int (compiling
 source file E:\src\ms\dotnet\coreclr\src\vm\comdelegate.cpp) [E:\src\ms\dotnet\coreclr\bin\obj\Windows_NT.x64.Checked\src\vm\wks\cee_wks.vcxproj]
e:\src\ms\dotnet\coreclr\src\md\inc\metamodelrw.h(405): error C2065: 'TBL_AssemblyRefProcessor': undeclared identifier [E:\src\ms\dotnet\coreclr\bin\obj\Windows_NT.x64.Checked\src\debug\daccess\dacces
s.vcxproj]
c:\program files (x86)\windows kits\10\include\10.0.17134.0\winrt\windows.foundation.collections.h(1129): fatal error C1001: An internal error has occurred in the compiler. [E:\src\ms\dotnet\coreclr\b
in\obj\Windows_NT.x64.Checked\src\vm\wks\cee_wks.vcxproj]
cl : Command line error D8040: error creating or communicating with child process [E:\src\ms\dotnet\coreclr\bin\obj\Windows_NT.x64.Checked\src\vm\wks\cee_wks.vcxproj]
    2 Warning(s)
    10 Error(s)

Time Elapsed 00:12:05.32
Command execution failed with exit code 1.
BUILD: Error: native component build failed. Refer to the build log files for details:
    "e:\src\ms\dotnet\coreclr\bin\Logs\CoreCLR_Windows_NT__x64__Checked.log"
    "e:\src\ms\dotnet\coreclr\bin\Logs\CoreCLR_Windows_NT__x64__Checked.wrn"
    "e:\src\ms\dotnet\coreclr\bin\Logs\CoreCLR_Windows_NT__x64__Checked.err"

e:\src\ms\dotnet\coreclr&gt;
```

Visual Studio v15.7.4 command: `build x64 Checked -skiptests`
Windows 10 Pro x64 PL with EN lang pack active version 1803</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>10/07/2018 4:29:29 PM +00:00</CreatedAt>
    <ClosedAt>10/07/2018 9:16:31 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18850</IssueLabelID>
    <Title>Invalid value numbering when morphing casts that change signedness after global morph</Title>
    <Description>The example is
```csharp
// Generated by Fuzzlyn on 2018-07-07 14:53:26
// Seed: 3545793482977672966
// Reduced from 5.7 KiB to 0.6 KiB
// Debug: Outputs 32779
// Release: Outputs 4294934539
struct S0
{
    public bool F0;
    public short F1;
    public S0(short f1): this()
    {
        F1 = f1;
    }
}

public class Program
{
    static S0 s_1;
    static sbyte s_2;
    public static void Main()
    {
        s_2 = 0;
        M3();
    }

    static sbyte M3()
    {
        char var0 = default(char);
        s_1 = new S0(-32767);
        var vr6 = s_1.F0;
        M4(var0 0 (ushort)(10L | s_1.F1) vr6 s_1.F1);
        return s_2;
    }

    static byte[] M4(char arg0 long arg1 uint arg2 bool arg3 short arg4)
    {
        System.GC.KeepAlive(arg2);
        System.Console.WriteLine(arg2);
        return new byte[]{0};
    }
}
```

Details here: https://github.com/dotnet/coreclr/pull/18816#issuecomment-403649790</Description>
    <Title_Description>Invalid value numbering when morphing casts that change signedness after global morph The example is
```csharp
// Generated by Fuzzlyn on 2018-07-07 14:53:26
// Seed: 3545793482977672966
// Reduced from 5.7 KiB to 0.6 KiB
// Debug: Outputs 32779
// Release: Outputs 4294934539
struct S0
{
    public bool F0;
    public short F1;
    public S0(short f1): this()
    {
        F1 = f1;
    }
}

public class Program
{
    static S0 s_1;
    static sbyte s_2;
    public static void Main()
    {
        s_2 = 0;
        M3();
    }

    static sbyte M3()
    {
        char var0 = default(char);
        s_1 = new S0(-32767);
        var vr6 = s_1.F0;
        M4(var0 0 (ushort)(10L | s_1.F1) vr6 s_1.F1);
        return s_2;
    }

    static byte[] M4(char arg0 long arg1 uint arg2 bool arg3 short arg4)
    {
        System.GC.KeepAlive(arg2);
        System.Console.WriteLine(arg2);
        return new byte[]{0};
    }
}
```

Details here: https://github.com/dotnet/coreclr/pull/18816#issuecomment-403649790</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>erozenfeld</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18847</IssueLabelID>
    <Title>Failed to initialize CoreCLR HRESULT: 0x80131500 (Ubuntu 18.04)</Title>
    <Description>Error: `Failed to initialize CoreCLR HRESULT: 0x80131500`
I have a project which using `dotnet 1.1.2` and it works in `Window` well but when I move the environment to Ubuntu and then install the latest version `2.1.301`.

After that once I create new project like as `dotnet new webapi` and then use `dotnet run` it works well. But when I run the old project (`1.1.2`) it always throw the above `error`

Here is my logfile `strace`
[logfile.txt](https://github.com/dotnet/coreclr/files/2178758/logfile.txt)

Thanks.

# OS
No LSB modules are available.
Distributor ID:	Ubuntu
Description:	Ubuntu 18.04 LTS
Release:	18.04
Codename:	bionic
</Description>
    <Title_Description>Failed to initialize CoreCLR, HRESULT: 0x80131500 (Ubuntu 18.04) Error: `Failed to initialize CoreCLR HRESULT: 0x80131500`
I have a project which using `dotnet 1.1.2` and it works in `Window` well but when I move the environment to Ubuntu and then install the latest version `2.1.301`.

After that once I create new project like as `dotnet new webapi` and then use `dotnet run` it works well. But when I run the old project (`1.1.2`) it always throw the above `error`

Here is my logfile `strace`
[logfile.txt](https://github.com/dotnet/coreclr/files/2178758/logfile.txt)

Thanks.

# OS
No LSB modules are available.
Distributor ID:	Ubuntu
Description:	Ubuntu 18.04 LTS
Release:	18.04
Codename:	bionic
</Title_Description>
    <Label>os-linux</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>10/07/2018 3:49:31 AM +00:00</CreatedAt>
    <ClosedAt>12/07/2018 4:16:01 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18846</IssueLabelID>
    <Title>An assembly specified in the application dependencies manifest (Example.deps.json) was not found</Title>
    <Description>I am developing a web application using Asp.NET Core 2.1 on Visual Studio 17.7 the problem is when I publish the web app as a Framework-Dependent and I try to run the app on production machine I get this error message:

`Error:
An assembly specified in the application dependencies manifest (Example.deps.json) was not found:
package: 'Cronos' version: '0.6.3'
path: 'lib/netstandard1.0/Cronos.dll'`

Cronos.dll is a dependency of Hangfire library which I am using in the web app in the Example.deps.json file I found this:

`"Cronos/0.6.3": {
    "dependencies": {
      "NETStandard.Library": "2.0.3"
    }
    "runtime": {
      "lib/netstandard1.0/Cronos.dll": {
        "assemblyVersion": "0.6.3.0"
        "fileVersion": "0.6.3.0"
      }
    }
    "compile": {
      "lib/netstandard1.0/Cronos.dll": {}
    }
  }`

The problem is that it's referencing the libraries in the runtime store which will work on the developemnt machine but when I deploy to another machine the error happens.

I have tried the suggested solution in this article:

https://docs.microsoft.com/en-us/dotnet/core/deploying/runtime-store

By setting:-

`&lt;PropertyGroup&gt;
    &lt;PublishWithAspNetCoreTargetManifest&gt;false&lt;/PublishWithAspNetCoreTargetManifest&gt;
&lt;/PropertyGroup&gt;`

and I have also tried solutions in this github issue with no success:

https://github.com/dotnet/coreclr/issues/13542</Description>
    <Title_Description>An assembly specified in the application dependencies manifest (Example.deps.json) was not found I am developing a web application using Asp.NET Core 2.1 on Visual Studio 17.7 the problem is when I publish the web app as a Framework-Dependent and I try to run the app on production machine I get this error message:

`Error:
An assembly specified in the application dependencies manifest (Example.deps.json) was not found:
package: 'Cronos' version: '0.6.3'
path: 'lib/netstandard1.0/Cronos.dll'`

Cronos.dll is a dependency of Hangfire library which I am using in the web app in the Example.deps.json file I found this:

`"Cronos/0.6.3": {
    "dependencies": {
      "NETStandard.Library": "2.0.3"
    }
    "runtime": {
      "lib/netstandard1.0/Cronos.dll": {
        "assemblyVersion": "0.6.3.0"
        "fileVersion": "0.6.3.0"
      }
    }
    "compile": {
      "lib/netstandard1.0/Cronos.dll": {}
    }
  }`

The problem is that it's referencing the libraries in the runtime store which will work on the developemnt machine but when I deploy to another machine the error happens.

I have tried the suggested solution in this article:

https://docs.microsoft.com/en-us/dotnet/core/deploying/runtime-store

By setting:-

`&lt;PropertyGroup&gt;
    &lt;PublishWithAspNetCoreTargetManifest&gt;false&lt;/PublishWithAspNetCoreTargetManifest&gt;
&lt;/PropertyGroup&gt;`

and I have also tried solutions in this github issue with no success:

https://github.com/dotnet/coreclr/issues/13542</Title_Description>
    <Label>area-AssemblyLoader</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>10/07/2018 3:47:55 AM +00:00</CreatedAt>
    <ClosedAt>11/07/2018 4:40:08 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18843</IssueLabelID>
    <Title>Basic .NET client tests</Title>
    <Description>Adding basic testing for .NET client testing. see #18673. 

Removes some placeholder activation tests that will be added back in another PR.
Creates new native COM server - contract generated manually via TlbExp. See accompanying readme.md.
Creates a .NET client that tests marshaling of primitives (i.e. byte int array strings etc.)

Tests are only for Windows.
</Description>
    <Title_Description>Basic .NET client tests Adding basic testing for .NET client testing. see #18673. 

Removes some placeholder activation tests that will be added back in another PR.
Creates new native COM server - contract generated manually via TlbExp. See accompanying readme.md.
Creates a .NET client that tests marshaling of primitives (i.e. byte int array strings etc.)

Tests are only for Windows.
</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18842</IssueLabelID>
    <Title>Array bounds check is not eliminated if index passed by reference</Title>
    <Description>The x64 code generated for FastJsonParser.ReadNull using .NET Core v2.1.301 SDK generate following assembly instruction which include two almost identical array bound checks. If I modify program to pass offset parameter by value (not functionally correct) it will eliminate one of array bound checks correctly.

```csharp
namespace JsonParser
{
    public class Person
    {
        public static Person Deserialize(string json)
        {
            var pos = 0;
            return Person.Deserialize(json ref pos);
        }

        private static Person Deserialize(string json ref int offset)
        {
            return FastJsonParser.ReadNull(json ref offset) ? null : new Person { };
        }
    }

    public static class FastJsonParser
    {
        public static bool ReadNull(string json ref int offset)
        {
            if ((uint)offset &lt; (uint)json.Length &amp;&amp; json[offset] == 'n')
            {
                offset += 4;
                return true;
            }

            return false;
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            System.Console.WriteLine(null != Person.Deserialize("null"));
        }
    }
}
```


```assembly
//            if ((uint)offset &lt; (uint)json.Length &amp;&amp; json[offset] == 'n')
00007FF909380920  sub         rsp28h  
00007FF909380924  mov         eaxdword ptr [rdx]  
00007FF909380926  cmp         eaxdword ptr [rcx+8]  
00007FF909380929  jae         00007FF90938094F  
00007FF90938092B  mov         r8deax  
redundant ==&gt; 00007FF90938092E  cmp         r8ddword ptr [rcx+8]  
redundant ==&gt; 00007FF909380932  jae         00007FF909380956  
00007FF909380934  movsxd      r8r8d  
00007FF909380937  cmp         word ptr [rcx+r8*2+0Ch]6Eh  
00007FF90938093E  jne         00007FF90938094F  
//            {
//                offset += 4;
00007FF909380940  add         eax4  
00007FF909380943  mov         dword ptr [rdx]eax  
//                return true;
00007FF909380945  mov         eax1  
00007FF90938094A  add         rsp28h  
00007FF90938094E  ret  
//            }
//
//            return false;
00007FF90938094F  xor         eaxeax  
00007FF909380951  add         rsp28h  
00007FF909380955  ret  
00007FF909380956  call        00007FF969004F60  
00007FF90938095B  int         3
```

category:cq
theme:range-check
skill-level:expert
cost:medium</Description>
    <Title_Description>Array bounds check is not eliminated if index passed by reference The x64 code generated for FastJsonParser.ReadNull using .NET Core v2.1.301 SDK generate following assembly instruction which include two almost identical array bound checks. If I modify program to pass offset parameter by value (not functionally correct) it will eliminate one of array bound checks correctly.

```csharp
namespace JsonParser
{
    public class Person
    {
        public static Person Deserialize(string json)
        {
            var pos = 0;
            return Person.Deserialize(json ref pos);
        }

        private static Person Deserialize(string json ref int offset)
        {
            return FastJsonParser.ReadNull(json ref offset) ? null : new Person { };
        }
    }

    public static class FastJsonParser
    {
        public static bool ReadNull(string json ref int offset)
        {
            if ((uint)offset &lt; (uint)json.Length &amp;&amp; json[offset] == 'n')
            {
                offset += 4;
                return true;
            }

            return false;
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            System.Console.WriteLine(null != Person.Deserialize("null"));
        }
    }
}
```


```assembly
//            if ((uint)offset &lt; (uint)json.Length &amp;&amp; json[offset] == 'n')
00007FF909380920  sub         rsp28h  
00007FF909380924  mov         eaxdword ptr [rdx]  
00007FF909380926  cmp         eaxdword ptr [rcx+8]  
00007FF909380929  jae         00007FF90938094F  
00007FF90938092B  mov         r8deax  
redundant ==&gt; 00007FF90938092E  cmp         r8ddword ptr [rcx+8]  
redundant ==&gt; 00007FF909380932  jae         00007FF909380956  
00007FF909380934  movsxd      r8r8d  
00007FF909380937  cmp         word ptr [rcx+r8*2+0Ch]6Eh  
00007FF90938093E  jne         00007FF90938094F  
//            {
//                offset += 4;
00007FF909380940  add         eax4  
00007FF909380943  mov         dword ptr [rdx]eax  
//                return true;
00007FF909380945  mov         eax1  
00007FF90938094A  add         rsp28h  
00007FF90938094E  ret  
//            }
//
//            return false;
00007FF90938094F  xor         eaxeax  
00007FF909380951  add         rsp28h  
00007FF909380955  ret  
00007FF909380956  call        00007FF969004F60  
00007FF90938095B  int         3
```

category:cq
theme:range-check
skill-level:expert
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>9/07/2018 11:21:18 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18841</IssueLabelID>
    <Title>Add Utf8String class</Title>
    <Description>
    </Description>
    <Title_Description>Add Utf8String class </Title_Description>
    <Label>area-System.Runtime</Label>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18842</IssueLabelID>
    <Title>Array bounds check is not eliminated if index passed by reference</Title>
    <Description>The x64 code generated for FastJsonParser.ReadNull using .NET Core v2.1.301 SDK generate following assembly instruction which include two almost identical array bound checks. If I modify program to pass offset parameter by value (not functionally correct) it will eliminate one of array bound checks correctly.

```csharp
namespace JsonParser
{
    public class Person
    {
        public static Person Deserialize(string json)
        {
            var pos = 0;
            return Person.Deserialize(json ref pos);
        }

        private static Person Deserialize(string json ref int offset)
        {
            return FastJsonParser.ReadNull(json ref offset) ? null : new Person { };
        }
    }

    public static class FastJsonParser
    {
        public static bool ReadNull(string json ref int offset)
        {
            if ((uint)offset &lt; (uint)json.Length &amp;&amp; json[offset] == 'n')
            {
                offset += 4;
                return true;
            }

            return false;
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            System.Console.WriteLine(null != Person.Deserialize("null"));
        }
    }
}
```


```assembly
//            if ((uint)offset &lt; (uint)json.Length &amp;&amp; json[offset] == 'n')
00007FF909380920  sub         rsp28h  
00007FF909380924  mov         eaxdword ptr [rdx]  
00007FF909380926  cmp         eaxdword ptr [rcx+8]  
00007FF909380929  jae         00007FF90938094F  
00007FF90938092B  mov         r8deax  
redundant ==&gt; 00007FF90938092E  cmp         r8ddword ptr [rcx+8]  
redundant ==&gt; 00007FF909380932  jae         00007FF909380956  
00007FF909380934  movsxd      r8r8d  
00007FF909380937  cmp         word ptr [rcx+r8*2+0Ch]6Eh  
00007FF90938093E  jne         00007FF90938094F  
//            {
//                offset += 4;
00007FF909380940  add         eax4  
00007FF909380943  mov         dword ptr [rdx]eax  
//                return true;
00007FF909380945  mov         eax1  
00007FF90938094A  add         rsp28h  
00007FF90938094E  ret  
//            }
//
//            return false;
00007FF90938094F  xor         eaxeax  
00007FF909380951  add         rsp28h  
00007FF909380955  ret  
00007FF909380956  call        00007FF969004F60  
00007FF90938095B  int         3
```

category:cq
theme:range-check
skill-level:expert
cost:medium</Description>
    <Title_Description>Array bounds check is not eliminated if index passed by reference The x64 code generated for FastJsonParser.ReadNull using .NET Core v2.1.301 SDK generate following assembly instruction which include two almost identical array bound checks. If I modify program to pass offset parameter by value (not functionally correct) it will eliminate one of array bound checks correctly.

```csharp
namespace JsonParser
{
    public class Person
    {
        public static Person Deserialize(string json)
        {
            var pos = 0;
            return Person.Deserialize(json ref pos);
        }

        private static Person Deserialize(string json ref int offset)
        {
            return FastJsonParser.ReadNull(json ref offset) ? null : new Person { };
        }
    }

    public static class FastJsonParser
    {
        public static bool ReadNull(string json ref int offset)
        {
            if ((uint)offset &lt; (uint)json.Length &amp;&amp; json[offset] == 'n')
            {
                offset += 4;
                return true;
            }

            return false;
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            System.Console.WriteLine(null != Person.Deserialize("null"));
        }
    }
}
```


```assembly
//            if ((uint)offset &lt; (uint)json.Length &amp;&amp; json[offset] == 'n')
00007FF909380920  sub         rsp28h  
00007FF909380924  mov         eaxdword ptr [rdx]  
00007FF909380926  cmp         eaxdword ptr [rcx+8]  
00007FF909380929  jae         00007FF90938094F  
00007FF90938092B  mov         r8deax  
redundant ==&gt; 00007FF90938092E  cmp         r8ddword ptr [rcx+8]  
redundant ==&gt; 00007FF909380932  jae         00007FF909380956  
00007FF909380934  movsxd      r8r8d  
00007FF909380937  cmp         word ptr [rcx+r8*2+0Ch]6Eh  
00007FF90938093E  jne         00007FF90938094F  
//            {
//                offset += 4;
00007FF909380940  add         eax4  
00007FF909380943  mov         dword ptr [rdx]eax  
//                return true;
00007FF909380945  mov         eax1  
00007FF90938094A  add         rsp28h  
00007FF90938094E  ret  
//            }
//
//            return false;
00007FF90938094F  xor         eaxeax  
00007FF909380951  add         rsp28h  
00007FF909380955  ret  
00007FF909380956  call        00007FF969004F60  
00007FF90938095B  int         3
```

category:cq
theme:range-check
skill-level:expert
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>9/07/2018 11:21:18 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18841</IssueLabelID>
    <Title>Add Utf8String class</Title>
    <Description>
    </Description>
    <Title_Description>Add Utf8String class </Title_Description>
    <Label>area-System.Runtime</Label>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18842</IssueLabelID>
    <Title>Array bounds check is not eliminated if index passed by reference</Title>
    <Description>The x64 code generated for FastJsonParser.ReadNull using .NET Core v2.1.301 SDK generate following assembly instruction which include two almost identical array bound checks. If I modify program to pass offset parameter by value (not functionally correct) it will eliminate one of array bound checks correctly.

```csharp
namespace JsonParser
{
    public class Person
    {
        public static Person Deserialize(string json)
        {
            var pos = 0;
            return Person.Deserialize(json ref pos);
        }

        private static Person Deserialize(string json ref int offset)
        {
            return FastJsonParser.ReadNull(json ref offset) ? null : new Person { };
        }
    }

    public static class FastJsonParser
    {
        public static bool ReadNull(string json ref int offset)
        {
            if ((uint)offset &lt; (uint)json.Length &amp;&amp; json[offset] == 'n')
            {
                offset += 4;
                return true;
            }

            return false;
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            System.Console.WriteLine(null != Person.Deserialize("null"));
        }
    }
}
```


```assembly
//            if ((uint)offset &lt; (uint)json.Length &amp;&amp; json[offset] == 'n')
00007FF909380920  sub         rsp28h  
00007FF909380924  mov         eaxdword ptr [rdx]  
00007FF909380926  cmp         eaxdword ptr [rcx+8]  
00007FF909380929  jae         00007FF90938094F  
00007FF90938092B  mov         r8deax  
redundant ==&gt; 00007FF90938092E  cmp         r8ddword ptr [rcx+8]  
redundant ==&gt; 00007FF909380932  jae         00007FF909380956  
00007FF909380934  movsxd      r8r8d  
00007FF909380937  cmp         word ptr [rcx+r8*2+0Ch]6Eh  
00007FF90938093E  jne         00007FF90938094F  
//            {
//                offset += 4;
00007FF909380940  add         eax4  
00007FF909380943  mov         dword ptr [rdx]eax  
//                return true;
00007FF909380945  mov         eax1  
00007FF90938094A  add         rsp28h  
00007FF90938094E  ret  
//            }
//
//            return false;
00007FF90938094F  xor         eaxeax  
00007FF909380951  add         rsp28h  
00007FF909380955  ret  
00007FF909380956  call        00007FF969004F60  
00007FF90938095B  int         3
```

category:cq
theme:range-check
skill-level:expert
cost:medium</Description>
    <Title_Description>Array bounds check is not eliminated if index passed by reference The x64 code generated for FastJsonParser.ReadNull using .NET Core v2.1.301 SDK generate following assembly instruction which include two almost identical array bound checks. If I modify program to pass offset parameter by value (not functionally correct) it will eliminate one of array bound checks correctly.

```csharp
namespace JsonParser
{
    public class Person
    {
        public static Person Deserialize(string json)
        {
            var pos = 0;
            return Person.Deserialize(json ref pos);
        }

        private static Person Deserialize(string json ref int offset)
        {
            return FastJsonParser.ReadNull(json ref offset) ? null : new Person { };
        }
    }

    public static class FastJsonParser
    {
        public static bool ReadNull(string json ref int offset)
        {
            if ((uint)offset &lt; (uint)json.Length &amp;&amp; json[offset] == 'n')
            {
                offset += 4;
                return true;
            }

            return false;
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            System.Console.WriteLine(null != Person.Deserialize("null"));
        }
    }
}
```


```assembly
//            if ((uint)offset &lt; (uint)json.Length &amp;&amp; json[offset] == 'n')
00007FF909380920  sub         rsp28h  
00007FF909380924  mov         eaxdword ptr [rdx]  
00007FF909380926  cmp         eaxdword ptr [rcx+8]  
00007FF909380929  jae         00007FF90938094F  
00007FF90938092B  mov         r8deax  
redundant ==&gt; 00007FF90938092E  cmp         r8ddword ptr [rcx+8]  
redundant ==&gt; 00007FF909380932  jae         00007FF909380956  
00007FF909380934  movsxd      r8r8d  
00007FF909380937  cmp         word ptr [rcx+r8*2+0Ch]6Eh  
00007FF90938093E  jne         00007FF90938094F  
//            {
//                offset += 4;
00007FF909380940  add         eax4  
00007FF909380943  mov         dword ptr [rdx]eax  
//                return true;
00007FF909380945  mov         eax1  
00007FF90938094A  add         rsp28h  
00007FF90938094E  ret  
//            }
//
//            return false;
00007FF90938094F  xor         eaxeax  
00007FF909380951  add         rsp28h  
00007FF909380955  ret  
00007FF909380956  call        00007FF969004F60  
00007FF90938095B  int         3
```

category:cq
theme:range-check
skill-level:expert
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>9/07/2018 11:21:18 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18841</IssueLabelID>
    <Title>Add Utf8String class</Title>
    <Description>
    </Description>
    <Title_Description>Add Utf8String class </Title_Description>
    <Label>area-System.Runtime</Label>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18836</IssueLabelID>
    <Title>Consider adding a stress mode which prefers registers with different encoding characteristics</Title>
    <Description>On various architecturesthere exist registers that require different encoding characteristics. For example on x64 there are additional registers available (`R8-R15` and `XMM8-XMM15`) which require the use of the REX prefix (or a VEX-encoded instruction).

Given that these change how the instruction is encoded it would be beneficial if there was a stress-mode that would prefer these registers in order to help validate that the emitter has them properly handled.

category:testing
theme:emitter
skill-level:beginner
cost:small</Description>
    <Title_Description>Consider adding a stress mode which prefers registers with different encoding characteristics On various architecturesthere exist registers that require different encoding characteristics. For example on x64 there are additional registers available (`R8-R15` and `XMM8-XMM15`) which require the use of the REX prefix (or a VEX-encoded instruction).

Given that these change how the instruction is encoded it would be beneficial if there was a stress-mode that would prefer these registers in order to help validate that the emitter has them properly handled.

category:testing
theme:emitter
skill-level:beginner
cost:small</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
    <CreatedAt>9/07/2018 7:38:20 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18834</IssueLabelID>
    <Title>[WIP] Test build tools used in master</Title>
    <Description>
    </Description>
    <Title_Description>[WIP] Test build tools used in master </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>9/07/2018 6:09:38 PM +00:00</CreatedAt>
    <ClosedAt>7/08/2018 12:10:19 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18833</IssueLabelID>
    <Title>Fix serialization type in NotFiniteNumberException</Title>
    <Description>Good news: This is the only serializable type that passes a different type than the value's type in.
Bad news: No bad news today :)</Description>
    <Title_Description>Fix serialization type in NotFiniteNumberException Good news: This is the only serializable type that passes a different type than the value's type in.
Bad news: No bad news today :)</Title_Description>
    <Label>area-System.Runtime</Label>
    <Assignee>ViktorHofer</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18831</IssueLabelID>
    <Title>HW intrinsics - PopCount() returns int/long while Leading/TrailingZeroCount() returns uint/ulong</Title>
    <Description>Is this difference in return type by design?
Also `MoveMask()` returns `int` which may be less convenient than `uint` when one has to shift the result obtained from 256-bit vector right for some reason</Description>
    <Title_Description>HW intrinsics - PopCount() returns int/long, while Leading/TrailingZeroCount() returns uint/ulong Is this difference in return type by design?
Also `MoveMask()` returns `int` which may be less convenient than `uint` when one has to shift the result obtained from 256-bit vector right for some reason</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>9/07/2018 8:21:28 AM +00:00</CreatedAt>
    <ClosedAt>17/09/2018 8:54:42 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18829</IssueLabelID>
    <Title>[JIT] Redundant Span&lt;&gt; bounds check not elided for fields in ref structs</Title>
    <Description>From my review of various issues around bounds checks the length check here should be sufficient to elide the span's bounds check:
```cs
private readonly ReadOnlySpan&lt;int&gt; _colStarts;
public int? TryParseInt(int col)
{
	if ((uint)col &lt; (uint)_colStarts.Length)
	{
		var parseSpan = _span.Slice(_colStarts[col]);

		Utf8Parser.TryParse(parseSpan out int result out _);
		return result;
	}

	return null;
}
```
(Full code available here: https://gist.github.com/Zhentar/6464a6190c0007d83c95634d1a9889ed )

But it is still present in the jitted code with the latest nightly `(CoreCLR 4.6.26709.01 CoreFX 4.6.26606.05) 64bit RyuJIT`
```asm
DelimitedFileParser.StrictFileParser+SpanLineParser.TryParseInt(Int32)
	push    rdi
	push    rsi
	sub     rsp58h
	mov     rsircx
	lea     rdi[rsp+28h]
	mov     ecx0Ch
	xor     eaxeax
	rep     stos dword ptr [rdi]
	mov     rcxrsi
;				if ((uint)col &lt; (uint)_colStarts.Length)
;				^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	cmp     dword ptr [rcx]ecx
	lea     r8[rcx+10h]
	cmp     edxdword ptr [r8+8]
	jae     M04_L00
;					var parseSpan = _span.Slice(_colStarts[col]);
;					^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	mov     r8rcx
	cmp     dword ptr [r8]r8d
	add     r810h
	cmp     edxdword ptr [r8+8]
	jae     M04_L02
	mov     r8qword ptr [r8]
	movsxd  rdxedx
	mov     edxdword ptr [r8+rdx*4]
	mov     r8ddword ptr [rcx+8]
	cmp     edxr8d
	ja      M04_L01
	mov     rcxqword ptr [rcx]
	sub     r8dedx
	movsxd  rdxedx
	add     rcxrdx```

category:cq
theme:bounds-checks
skill-level:expert
cost:medium</Description>
    <Title_Description>[JIT] Redundant Span&lt;&gt; bounds check not elided for fields in ref structs From my review of various issues around bounds checks the length check here should be sufficient to elide the span's bounds check:
```cs
private readonly ReadOnlySpan&lt;int&gt; _colStarts;
public int? TryParseInt(int col)
{
	if ((uint)col &lt; (uint)_colStarts.Length)
	{
		var parseSpan = _span.Slice(_colStarts[col]);

		Utf8Parser.TryParse(parseSpan out int result out _);
		return result;
	}

	return null;
}
```
(Full code available here: https://gist.github.com/Zhentar/6464a6190c0007d83c95634d1a9889ed )

But it is still present in the jitted code with the latest nightly `(CoreCLR 4.6.26709.01 CoreFX 4.6.26606.05) 64bit RyuJIT`
```asm
DelimitedFileParser.StrictFileParser+SpanLineParser.TryParseInt(Int32)
	push    rdi
	push    rsi
	sub     rsp58h
	mov     rsircx
	lea     rdi[rsp+28h]
	mov     ecx0Ch
	xor     eaxeax
	rep     stos dword ptr [rdi]
	mov     rcxrsi
;				if ((uint)col &lt; (uint)_colStarts.Length)
;				^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	cmp     dword ptr [rcx]ecx
	lea     r8[rcx+10h]
	cmp     edxdword ptr [r8+8]
	jae     M04_L00
;					var parseSpan = _span.Slice(_colStarts[col]);
;					^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	mov     r8rcx
	cmp     dword ptr [r8]r8d
	add     r810h
	cmp     edxdword ptr [r8+8]
	jae     M04_L02
	mov     r8qword ptr [r8]
	movsxd  rdxedx
	mov     edxdword ptr [r8+rdx*4]
	mov     r8ddword ptr [rcx+8]
	cmp     edxr8d
	ja      M04_L01
	mov     rcxqword ptr [rcx]
	sub     r8dedx
	movsxd  rdxedx
	add     rcxrdx```

category:cq
theme:bounds-checks
skill-level:expert
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>9/07/2018 1:17:08 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18827</IssueLabelID>
    <Title>Debugging Linux Apps - Dump Analysis Clarification</Title>
    <Description>I have hanging app on linux and was attempting to get take a memory dump... upon reading the docs for memory dump analysis I found nothing talking about mention **hung** **deadlocks** or **memory leaks**: they are mostly geared to crash analysis.

the way i see it there are 2 types of dumps: 
1. Crash (created by operating system/debugger event) for crash analysis
2. Live / On Demand (created by user) for memory lock hang analysis

I think this link needs to be updated to at least mention the second category of memory dump analysis is also possible  (and any deviation in steps required)

https://github.com/dotnet/coreclr/blob/master/Documentation/building/debugging-instructions.md

Example text from above link that should be modified:

`It is also possible to debug .NET Core crash dumps` (what about hung processes?)
(NOTE: this is not an exhaust list of text that needs to be updated)

What is **CreateDump**?

`On Linux there is an utility called **createdump** (see doc) that can be setup to generate core dumps when a managed app throws an unhandled exception or faults.` ?

The current wording seems to imply a 'separate utility' - but I can't find it in the (linux/arm) sdk

According to the following links it seems that it might be a seprate util or part of sos?

(Command Line Options)?
https://github.com/dotnet/coreclr/blob/master/Documentation/botr/xplat-minidump-generation.md

(SOS Plugin Command?)
https://github.com/dotnet/coreclr/blob/master/Documentation/building/debugging-instructions.md

Please Clarify the following:

1. Are dumps only able to be analyzed if they are created via lldb + sos ? 
2. What is 'create dump' utility and where is it?  (contradictory docs)
3. Update the above linked docs since they seem have no mention that memory dumps from 'live' processes are supported.
4. a quick how to guide for creating a dump of a live process would be nice if the steps vastly are different from crash dump analysis.

regarding item 1 - I attempted to create memory dumps using 'gcore' and load them in lldb but this just caused lldb to crash so i posted a bug with lldb and sought guidance on coreclr glitter for more input  

@karelz - also sent me the links above but I if you read my above notes: I think more clarity is needed to deal with the second class of dumps that I want to analyze on linux/arm hardware.



</Description>
    <Title_Description>Debugging Linux Apps - Dump Analysis Clarification I have hanging app on linux and was attempting to get take a memory dump... upon reading the docs for memory dump analysis I found nothing talking about mention **hung** **deadlocks** or **memory leaks**: they are mostly geared to crash analysis.

the way i see it there are 2 types of dumps: 
1. Crash (created by operating system/debugger event) for crash analysis
2. Live / On Demand (created by user) for memory lock hang analysis

I think this link needs to be updated to at least mention the second category of memory dump analysis is also possible  (and any deviation in steps required)

https://github.com/dotnet/coreclr/blob/master/Documentation/building/debugging-instructions.md

Example text from above link that should be modified:

`It is also possible to debug .NET Core crash dumps` (what about hung processes?)
(NOTE: this is not an exhaust list of text that needs to be updated)

What is **CreateDump**?

`On Linux there is an utility called **createdump** (see doc) that can be setup to generate core dumps when a managed app throws an unhandled exception or faults.` ?

The current wording seems to imply a 'separate utility' - but I can't find it in the (linux/arm) sdk

According to the following links it seems that it might be a seprate util or part of sos?

(Command Line Options)?
https://github.com/dotnet/coreclr/blob/master/Documentation/botr/xplat-minidump-generation.md

(SOS Plugin Command?)
https://github.com/dotnet/coreclr/blob/master/Documentation/building/debugging-instructions.md

Please Clarify the following:

1. Are dumps only able to be analyzed if they are created via lldb + sos ? 
2. What is 'create dump' utility and where is it?  (contradictory docs)
3. Update the above linked docs since they seem have no mention that memory dumps from 'live' processes are supported.
4. a quick how to guide for creating a dump of a live process would be nice if the steps vastly are different from crash dump analysis.

regarding item 1 - I attempted to create memory dumps using 'gcore' and load them in lldb but this just caused lldb to crash so i posted a bug with lldb and sought guidance on coreclr glitter for more input  

@karelz - also sent me the links above but I if you read my above notes: I think more clarity is needed to deal with the second class of dumps that I want to analyze on linux/arm hardware.



</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>karelz</Assignee>
    <CreatedAt>8/07/2018 8:46:06 PM +00:00</CreatedAt>
    <ClosedAt>22/02/2019 10:48:46 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18826</IssueLabelID>
    <Title>LastIndexOf corner case fix when span is empty</Title>
    <Description>Fixes https://github.com/dotnet/corefx/pull/30896#discussion_r200843575

Thanks for spotting! I shouldn't have rushed fixing the initial issue.</Description>
    <Title_Description>LastIndexOf corner case fix when span is empty Fixes https://github.com/dotnet/corefx/pull/30896#discussion_r200843575

Thanks for spotting! I shouldn't have rushed fixing the initial issue.</Title_Description>
    <Label>area-System.Memory</Label>
    <Assignee>ViktorHofer</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18824</IssueLabelID>
    <Title>BinaryReader should also accept String as path filename for contructor</Title>
    <Description>Hello

following same comparison of `StreamWriter`/`StreamReader` and `BinaryWriter/BinaryReader` exposed in #18823

I noticed that `StreamReader` can be construct with a `String` but not `BinaryReader` it will be nice to have a similar API ie also accept `BinaryReader` to be construct using `String`

Kind regards



https://github.com/dotnet/coreclr/blob/0fbd855e38bc3ec269479b5f6bf561dcfd67cbb6/src/System.Private.CoreLib/shared/System/IO/StreamReader.cs#L170

https://github.com/dotnet/coreclr/blob/26d4004e90f47036d6393222522cf529aa41c6bb/src/mscorlib/src/System/IO/BinaryReader.cs#L49

same for writer

https://github.com/dotnet/coreclr/blob/0fbd855e38bc3ec269479b5f6bf561dcfd67cbb6/src/System.Private.CoreLib/shared/System/IO/StreamWriter.cs#L132

https://github.com/dotnet/coreclr/blob/0fbd855e38bc3ec269479b5f6bf561dcfd67cbb6/src/System.Private.CoreLib/shared/System/IO/BinaryWriter.cs#L50</Description>
    <Title_Description>BinaryReader should also accept String as path filename for contructor Hello

following same comparison of `StreamWriter`/`StreamReader` and `BinaryWriter/BinaryReader` exposed in #18823

I noticed that `StreamReader` can be construct with a `String` but not `BinaryReader` it will be nice to have a similar API ie also accept `BinaryReader` to be construct using `String`

Kind regards



https://github.com/dotnet/coreclr/blob/0fbd855e38bc3ec269479b5f6bf561dcfd67cbb6/src/System.Private.CoreLib/shared/System/IO/StreamReader.cs#L170

https://github.com/dotnet/coreclr/blob/26d4004e90f47036d6393222522cf529aa41c6bb/src/mscorlib/src/System/IO/BinaryReader.cs#L49

same for writer

https://github.com/dotnet/coreclr/blob/0fbd855e38bc3ec269479b5f6bf561dcfd67cbb6/src/System.Private.CoreLib/shared/System/IO/StreamWriter.cs#L132

https://github.com/dotnet/coreclr/blob/0fbd855e38bc3ec269479b5f6bf561dcfd67cbb6/src/System.Private.CoreLib/shared/System/IO/BinaryWriter.cs#L50</Title_Description>
    <Label>area-System.IO</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>7/07/2018 7:25:12 PM +00:00</CreatedAt>
    <ClosedAt>10/07/2018 8:36:03 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18823</IssueLabelID>
    <Title>Add EndOfStream property to BinaryReader</Title>
    <Description>Hello

I'm comparing saving/reading data using either `StreamWriter`/`StreamReader` and `BinaryWriter/BinaryReader`.

With `StreamReader` to read data we can do:

```vb
Imports System.IO

ioReader = New StreamReader(fname)

Do While Not ioReader.EndOfStream

        Dim substrings() As String = chaine.Split(";")
        ...
Loop

ioReader.Close()
```

but with `BinaryReader` it's a bit more complicated with

```vb
ioReader = New BinaryReader(File.Open(fname FileMode.Open))

Do While ioReader.BaseStream.Position &lt;&gt; ioReader.BaseStream.Length
    t = ioReader.ReadSingle()
    y = ioReader.ReadSingle()
    ...
Loop

ioReader.Close()
```

I wonder if an `EndOfStream` property couldn't be added to `BinaryReader`

Kind regards</Description>
    <Title_Description>Add EndOfStream property to BinaryReader Hello

I'm comparing saving/reading data using either `StreamWriter`/`StreamReader` and `BinaryWriter/BinaryReader`.

With `StreamReader` to read data we can do:

```vb
Imports System.IO

ioReader = New StreamReader(fname)

Do While Not ioReader.EndOfStream

        Dim substrings() As String = chaine.Split(";")
        ...
Loop

ioReader.Close()
```

but with `BinaryReader` it's a bit more complicated with

```vb
ioReader = New BinaryReader(File.Open(fname FileMode.Open))

Do While ioReader.BaseStream.Position &lt;&gt; ioReader.BaseStream.Length
    t = ioReader.ReadSingle()
    y = ioReader.ReadSingle()
    ...
Loop

ioReader.Close()
```

I wonder if an `EndOfStream` property couldn't be added to `BinaryReader`

Kind regards</Title_Description>
    <Label>area-System.IO</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>7/07/2018 7:23:11 PM +00:00</CreatedAt>
    <ClosedAt>10/07/2018 8:57:21 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18822</IssueLabelID>
    <Title>[RyuJIT] Seeing suboptimal codegen for various AVX HWIntrinsics</Title>
    <Description>The Windows calling convention marks the upper 128-bits of YMM6 through YMM15 as volatile/caller preserved. This can cause codegen issues when using 256-bit HWIntrinsics that are interspersed with other calls as the JIT must currently insert code to save/restore the upper bits.

It may be possible for the JIT to do something "smart" here to allow eliding the save/restore when the target call would not touch the registers.
* An example would be a general flag that indicates whether the method being called uses any XMM register which would allow the JIT to elide the save/restore entirely in some cases.
* A more complex example would be tracking individual XMM registers used.

However the JIT doing something "smart" may be expensive. This is also a case where simply refactoring the code may vastly improve codegen (if the calls can be made to no longer be interspersed). As such an analyzer may be able to help catch these cases as would profiling.

An example of this problem is the following code snippet:
* NOTE: This probably doesn't represent real world code where you would likely be operating on an entire array. A real world example of interspersed calls would likely involve helper methods that abstracts away the ARM vs x86 differences and which themselves use other hardware intrinsics
```C#
public void RunBasicScenario_Load()
{
    var result = Avx.BlendVariable(
        Avx.LoadVector256((Single*)(_dataTable.inArray1Ptr))
        Avx.LoadVector256((Single*)(_dataTable.inArray2Ptr))
        Avx.LoadVector256((Single*)(_dataTable.inArray3Ptr))
    );

    Unsafe.Write(_dataTable.outArrayPtr result);
    ValidateResult(_dataTable.inArray1Ptr _dataTable.inArray2Ptr _dataTable.inArray3Ptr _dataTable.outArrayPtr);
}
```

&lt;details&gt;
&lt;summary&gt;This generates the following assembly (click to view):&lt;/summary&gt;

JitDump is here: [JitDump.txt](https://github.com/dotnet/coreclr/files/2173010/JitDump.txt)
```asm
; Assembly listing for method JIT.HardwareIntrinsics.X86.SimpleTernaryOpTest__BlendVariableSingle:RunBasicScenario_Load():this
; Emitting BLENDED_CODE for X64 CPU with AVX
; optimized code
; rsp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 this         [V00T01] (  8  8   )     ref  -&gt;  rsi         this class-hnd
;  V01 loc0         [V01T09] (  3  3   )  simd32  -&gt;  mm6        
;  V02 OutArgs      [V02    ] (  1  1   )  lclBlk (48) [rsp+0x00]  
;  V03 tmp1         [V03T02] (  4  8   )  simd32  -&gt;  mm6        
;  V04 tmp2         [V04T03] (  4  8   )  simd32  -&gt;  mm7        
;  V05 tmp3         [V05T04] (  4  8   )    long  -&gt;  rbx        
;  V06 tmp4         [V06T05] (  4  8   )    long  -&gt;  rbp        
;  V07 tmp5         [V07T06] (  4  8   )    long  -&gt;  r14        
;  V08 tmp6         [V08T08] (  3  6   )    long  -&gt;  rax        
;* V09 tmp7         [V09    ] (  0  0   )  simd32  -&gt;  zero-ref   
;  V10 tmp8         [V10T07] (  4  8   )    long  -&gt;  rax        
;  V11 cse0         [V11T00] ( 18 18   )   byref  -&gt;  rdi        
;
; Lcl frame size = 112

G_M14836_IG01:
       4156                 push     r14
       57                   push     rdi
       56                   push     rsi
       55                   push     rbp
       53                   push     rbx
       4883EC70             sub      rsp 112
       C5F877               vzeroupper 
       C4E17829742460       vmovaps  qword ptr [rsp+60H] xmm6
       C4E178297C2450       vmovaps  qword ptr [rsp+50H] xmm7
       C4617829442440       vmovaps  qword ptr [rsp+40H] xmm8
       C46178294C2430       vmovaps  qword ptr [rsp+30H] xmm9
       488BF1               mov      rsi rcx

G_M14836_IG02:
       3936                 cmp      dword ptr [rsi] esi
       488D7E70             lea      rdi bword ptr [rsi+112]
       488BCF               mov      rcx rdi
       E866F6FFFF           call     JIT.HardwareIntrinsics.X86.SimpleTernaryOpTest__DataTable`4[SingleSingleSingleSingle][System.SingleSystem.SingleSystem.SingleSystem.Single]:get_inArray1Ptr():long:this
       C4E17C1030           vmovups  ymm6 ymmword ptr[rax]
       488BCF               mov      rcx rdi
       C4E37D19F701         vextractf128 ymm7 ymm6 1
       E893F6FFFF           call     JIT.HardwareIntrinsics.X86.SimpleTernaryOpTest__DataTable`4[SingleSingleSingleSingle][System.SingleSystem.SingleSystem.SingleSystem.Single]:get_inArray2Ptr():long:this
       C4E34D18F701         vinsertf128 ymm6 ymm7 1
       C4E17C1038           vmovups  ymm7 ymmword ptr[rax]
       488BCF               mov      rcx rdi
       C4C37D19F001         vextractf128 ymm8 ymm6 1
       C4C37D19F901         vextractf128 ymm9 ymm7 1
       E8B4F6FFFF           call     JIT.HardwareIntrinsics.X86.SimpleTernaryOpTest__DataTable`4[SingleSingleSingleSingle][System.SingleSystem.SingleSystem.SingleSystem.Single]:get_inArray3Ptr():long:this
       C4C34518F901         vinsertf128 ymm7 ymm9 1
       C4C34D18F001         vinsertf128 ymm6 ymm8 1
       C4E17C1000           vmovups  ymm0 ymmword ptr[rax]
       C4E34D4AF700         vblendvps ymm6 ymm6 ymm7 ymm0
       488BCF               mov      rcx rdi
       C4E37D19F701         vextractf128 ymm7 ymm6 1
       E81FF8FFFF           call     JIT.HardwareIntrinsics.X86.SimpleTernaryOpTest__DataTable`4[SingleSingleSingleSingle][System.SingleSystem.SingleSystem.SingleSystem.Single]:get_outArrayPtr():long:this
       C4E34D18F701         vinsertf128 ymm6 ymm7 1
       C4E17D1130           vmovupd  ymmword ptr[rax] ymm6
       488BCF               mov      rcx rdi
       E8FCF5FFFF           call     JIT.HardwareIntrinsics.X86.SimpleTernaryOpTest__DataTable`4[SingleSingleSingleSingle][System.SingleSystem.SingleSystem.SingleSystem.Single]:get_inArray1Ptr():long:this
       488BD8               mov      rbx rax
       488BCF               mov      rcx rdi
       E831F6FFFF           call     JIT.HardwareIntrinsics.X86.SimpleTernaryOpTest__DataTable`4[SingleSingleSingleSingle][System.SingleSystem.SingleSystem.SingleSystem.Single]:get_inArray2Ptr():long:this
       488BE8               mov      rbp rax
       488BCF               mov      rcx rdi
       E866F6FFFF           call     JIT.HardwareIntrinsics.X86.SimpleTernaryOpTest__DataTable`4[SingleSingleSingleSingle][System.SingleSystem.SingleSystem.SingleSystem.Single]:get_inArray3Ptr():long:this
       4C8BF0               mov      r14 rax
       488BCF               mov      rcx rdi
       E8EBF7FFFF           call     JIT.HardwareIntrinsics.X86.SimpleTernaryOpTest__DataTable`4[SingleSingleSingleSingle][System.SingleSystem.SingleSystem.SingleSystem.Single]:get_outArrayPtr():long:this
       48BA2096C0CDBE010000 mov      rdx 0x1BECDC09620
       488B12               mov      rdx gword ptr [rdx]
       4889542428           mov      gword ptr [rsp+28H] rdx
       4889442420           mov      qword ptr [rsp+20H] rax
       488BD3               mov      rdx rbx
       4C8BC5               mov      r8 rbp
       4D8BCE               mov      r9 r14
       488BCE               mov      rcx rsi
       E803F8FFFF           call     JIT.HardwareIntrinsics.X86.SimpleTernaryOpTest__BlendVariableSingle:ValidateResult(longlonglonglongref):this
       90                   nop      

G_M14836_IG03:
       C4E17828742460       vmovaps  xmm6 qword ptr [rsp+60H]
       C4E178287C2450       vmovaps  xmm7 qword ptr [rsp+50H]
       C4617828442440       vmovaps  xmm8 qword ptr [rsp+40H]
       C46178284C2430       vmovaps  xmm9 qword ptr [rsp+30H]
       C5F877               vzeroupper 
       4883C470             add      rsp 112
       5B                   pop      rbx
       5D                   pop      rbp
       5E                   pop      rsi
       5F                   pop      rdi
       415E                 pop      r14
       C3                   ret      

; Total bytes of code 280 prolog size 41 for method JIT.HardwareIntrinsics.X86.SimpleTernaryOpTest__BlendVariableSingle:RunBasicScenario_Load():this
; ============================================================
```

&lt;/details&gt;


Where a small refactoring:
```C#
public void RunBasicScenario_Load()
{
    var inArray1Ptr = (Single*)(_dataTable.inArray1Ptr);
    var inArray2Ptr = (Single*)(_dataTable.inArray2Ptr);
    var inArray3Ptr = (Single*)(_dataTable.inArray3Ptr);

    var result = Avx.BlendVariable(
        Avx.LoadVector256(inArray1Ptr)
        Avx.LoadVector256(inArray2Ptr)
        Avx.LoadVector256(inArray3Ptr)
    );

    Unsafe.Write(_dataTable.outArrayPtr result);
    ValidateResult(_dataTable.inArray1Ptr _dataTable.inArray2Ptr _dataTable.inArray3Ptr _dataTable.outArrayPtr);
}
```

&lt;details&gt;
&lt;summary&gt;Instead produces the following assembly (click to view):&lt;/summary&gt;

```asm
; Assembly listing for method JIT.HardwareIntrinsics.X86.SimpleTernaryOpTest__BlendVariableSingle:RunBasicScenario_Load():this
; Emitting BLENDED_CODE for X64 CPU with AVX
; optimized code
; rsp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 this         [V00T01] (  8  8   )     ref  -&gt;  rsi         this class-hnd
;  V01 loc0         [V01T07] (  3  3   )    long  -&gt;  rbx        
;  V02 loc1         [V02T08] (  3  3   )    long  -&gt;  rbp        
;  V03 loc2         [V03T09] (  3  3   )    long  -&gt;  rax        
;  V04 loc3         [V04T10] (  2  2   )  simd32  -&gt;  mm6        
;  V05 OutArgs      [V05    ] (  1  1   )  lclBlk (48) [rsp+0x00]  
;  V06 tmp1         [V06T02] (  4  8   )    long  -&gt;  rbx        
;  V07 tmp2         [V07T03] (  4  8   )    long  -&gt;  rbp        
;  V08 tmp3         [V08T04] (  4  8   )    long  -&gt;  r14        
;  V09 tmp4         [V09T06] (  3  6   )    long  -&gt;  rax        
;* V10 tmp5         [V10    ] (  0  0   )  simd32  -&gt;  zero-ref   
;  V11 tmp6         [V11T05] (  4  8   )    long  -&gt;  rax        
;  V12 cse0         [V12T00] ( 18 18   )   byref  -&gt;  rdi        
;
; Lcl frame size = 80

G_M14836_IG01:
       4156                 push     r14
       57                   push     rdi
       56                   push     rsi
       55                   push     rbp
       53                   push     rbx
       4883EC50             sub      rsp 80
       C5F877               vzeroupper 
       C4E17829742440       vmovaps  qword ptr [rsp+40H] xmm6
       C4E178297C2430       vmovaps  qword ptr [rsp+30H] xmm7
       488BF1               mov      rsi rcx

G_M14836_IG02:
       3936                 cmp      dword ptr [rsi] esi
       488D7E70             lea      rdi bword ptr [rsi+112]
       488BCF               mov      rcx rdi
       E874F6FFFF           call     JIT.HardwareIntrinsics.X86.SimpleTernaryOpTest__DataTable`4[SingleSingleSingleSingle][System.SingleSystem.SingleSystem.SingleSystem.Single]:get_inArray1Ptr():long:this
       488BD8               mov      rbx rax
       488BCF               mov      rcx rdi
       E8A9F6FFFF           call     JIT.HardwareIntrinsics.X86.SimpleTernaryOpTest__DataTable`4[SingleSingleSingleSingle][System.SingleSystem.SingleSystem.SingleSystem.Single]:get_inArray2Ptr():long:this
       488BE8               mov      rbp rax
       488BCF               mov      rcx rdi
       E8DEF6FFFF           call     JIT.HardwareIntrinsics.X86.SimpleTernaryOpTest__DataTable`4[SingleSingleSingleSingle][System.SingleSystem.SingleSystem.SingleSystem.Single]:get_inArray3Ptr():long:this
       C4E17C1003           vmovups  ymm0 ymmword ptr[rbx]
       C4E17C1008           vmovups  ymm1 ymmword ptr[rax]
       C4E37D4A750010       vblendvps ymm6 ymm0 [rbp] ymm1
       488BCF               mov      rcx rdi
       C4E37D19F701         vextractf128 ymm7 ymm6 1
       E84FF8FFFF           call     JIT.HardwareIntrinsics.X86.SimpleTernaryOpTest__DataTable`4[SingleSingleSingleSingle][System.SingleSystem.SingleSystem.SingleSystem.Single]:get_outArrayPtr():long:this
       C4E34D18F701         vinsertf128 ymm6 ymm7 1
       C4E17D1130           vmovupd  ymmword ptr[rax] ymm6
       488BCF               mov      rcx rdi
       E82CF6FFFF           call     JIT.HardwareIntrinsics.X86.SimpleTernaryOpTest__DataTable`4[SingleSingleSingleSingle][System.SingleSystem.SingleSystem.SingleSystem.Single]:get_inArray1Ptr():long:this
       488BD8               mov      rbx rax
       488BCF               mov      rcx rdi
       E861F6FFFF           call     JIT.HardwareIntrinsics.X86.SimpleTernaryOpTest__DataTable`4[SingleSingleSingleSingle][System.SingleSystem.SingleSystem.SingleSystem.Single]:get_inArray2Ptr():long:this
       488BE8               mov      rbp rax
       488BCF               mov      rcx rdi
       E896F6FFFF           call     JIT.HardwareIntrinsics.X86.SimpleTernaryOpTest__DataTable`4[SingleSingleSingleSingle][System.SingleSystem.SingleSystem.SingleSystem.Single]:get_inArray3Ptr():long:this
       4C8BF0               mov      r14 rax
       488BCF               mov      rcx rdi
       E81BF8FFFF           call     JIT.HardwareIntrinsics.X86.SimpleTernaryOpTest__DataTable`4[SingleSingleSingleSingle][System.SingleSystem.SingleSystem.SingleSystem.Single]:get_outArrayPtr():long:this
       48BA20960090F9010000 mov      rdx 0x1F990009620
       488B12               mov      rdx gword ptr [rdx]
       4889542428           mov      gword ptr [rsp+28H] rdx
       4889442420           mov      qword ptr [rsp+20H] rax
       488BD3               mov      rdx rbx
       4C8BC5               mov      r8 rbp
       4D8BCE               mov      r9 r14
       488BCE               mov      rcx rsi
       E833F8FFFF           call     JIT.HardwareIntrinsics.X86.SimpleTernaryOpTest__BlendVariableSingle:ValidateResult(longlonglonglongref):this
       90                   nop      

G_M14836_IG03:
       C4E17828742440       vmovaps  xmm6 qword ptr [rsp+40H]
       C4E178287C2430       vmovaps  xmm7 qword ptr [rsp+30H]
       C5F877               vzeroupper 
       4883C450             add      rsp 80
       5B                   pop      rbx
       5D                   pop      rbp
       5E                   pop      rsi
       5F                   pop      rdi
       415E                 pop      r14
       C3                   ret      

; Total bytes of code 218 prolog size 27 for method JIT.HardwareIntrinsics.X86.SimpleTernaryOpTest__BlendVariableSingle:RunBasicScenario_Load():this
; ============================================================
```

&lt;/details&gt;

category:cq
theme:vector-codegen
skill-level:expert
cost:large</Description>
    <Title_Description>[RyuJIT] Seeing suboptimal codegen for various AVX HWIntrinsics The Windows calling convention marks the upper 128-bits of YMM6 through YMM15 as volatile/caller preserved. This can cause codegen issues when using 256-bit HWIntrinsics that are interspersed with other calls as the JIT must currently insert code to save/restore the upper bits.

It may be possible for the JIT to do something "smart" here to allow eliding the save/restore when the target call would not touch the registers.
* An example would be a general flag that indicates whether the method being called uses any XMM register which would allow the JIT to elide the save/restore entirely in some cases.
* A more complex example would be tracking individual XMM registers used.

However the JIT doing something "smart" may be expensive. This is also a case where simply refactoring the code may vastly improve codegen (if the calls can be made to no longer be interspersed). As such an analyzer may be able to help catch these cases as would profiling.

An example of this problem is the following code snippet:
* NOTE: This probably doesn't represent real world code where you would likely be operating on an entire array. A real world example of interspersed calls would likely involve helper methods that abstracts away the ARM vs x86 differences and which themselves use other hardware intrinsics
```C#
public void RunBasicScenario_Load()
{
    var result = Avx.BlendVariable(
        Avx.LoadVector256((Single*)(_dataTable.inArray1Ptr))
        Avx.LoadVector256((Single*)(_dataTable.inArray2Ptr))
        Avx.LoadVector256((Single*)(_dataTable.inArray3Ptr))
    );

    Unsafe.Write(_dataTable.outArrayPtr result);
    ValidateResult(_dataTable.inArray1Ptr _dataTable.inArray2Ptr _dataTable.inArray3Ptr _dataTable.outArrayPtr);
}
```

&lt;details&gt;
&lt;summary&gt;This generates the following assembly (click to view):&lt;/summary&gt;

JitDump is here: [JitDump.txt](https://github.com/dotnet/coreclr/files/2173010/JitDump.txt)
```asm
; Assembly listing for method JIT.HardwareIntrinsics.X86.SimpleTernaryOpTest__BlendVariableSingle:RunBasicScenario_Load():this
; Emitting BLENDED_CODE for X64 CPU with AVX
; optimized code
; rsp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 this         [V00T01] (  8  8   )     ref  -&gt;  rsi         this class-hnd
;  V01 loc0         [V01T09] (  3  3   )  simd32  -&gt;  mm6        
;  V02 OutArgs      [V02    ] (  1  1   )  lclBlk (48) [rsp+0x00]  
;  V03 tmp1         [V03T02] (  4  8   )  simd32  -&gt;  mm6        
;  V04 tmp2         [V04T03] (  4  8   )  simd32  -&gt;  mm7        
;  V05 tmp3         [V05T04] (  4  8   )    long  -&gt;  rbx        
;  V06 tmp4         [V06T05] (  4  8   )    long  -&gt;  rbp        
;  V07 tmp5         [V07T06] (  4  8   )    long  -&gt;  r14        
;  V08 tmp6         [V08T08] (  3  6   )    long  -&gt;  rax        
;* V09 tmp7         [V09    ] (  0  0   )  simd32  -&gt;  zero-ref   
;  V10 tmp8         [V10T07] (  4  8   )    long  -&gt;  rax        
;  V11 cse0         [V11T00] ( 18 18   )   byref  -&gt;  rdi        
;
; Lcl frame size = 112

G_M14836_IG01:
       4156                 push     r14
       57                   push     rdi
       56                   push     rsi
       55                   push     rbp
       53                   push     rbx
       4883EC70             sub      rsp 112
       C5F877               vzeroupper 
       C4E17829742460       vmovaps  qword ptr [rsp+60H] xmm6
       C4E178297C2450       vmovaps  qword ptr [rsp+50H] xmm7
       C4617829442440       vmovaps  qword ptr [rsp+40H] xmm8
       C46178294C2430       vmovaps  qword ptr [rsp+30H] xmm9
       488BF1               mov      rsi rcx

G_M14836_IG02:
       3936                 cmp      dword ptr [rsi] esi
       488D7E70             lea      rdi bword ptr [rsi+112]
       488BCF               mov      rcx rdi
       E866F6FFFF           call     JIT.HardwareIntrinsics.X86.SimpleTernaryOpTest__DataTable`4[SingleSingleSingleSingle][System.SingleSystem.SingleSystem.SingleSystem.Single]:get_inArray1Ptr():long:this
       C4E17C1030           vmovups  ymm6 ymmword ptr[rax]
       488BCF               mov      rcx rdi
       C4E37D19F701         vextractf128 ymm7 ymm6 1
       E893F6FFFF           call     JIT.HardwareIntrinsics.X86.SimpleTernaryOpTest__DataTable`4[SingleSingleSingleSingle][System.SingleSystem.SingleSystem.SingleSystem.Single]:get_inArray2Ptr():long:this
       C4E34D18F701         vinsertf128 ymm6 ymm7 1
       C4E17C1038           vmovups  ymm7 ymmword ptr[rax]
       488BCF               mov      rcx rdi
       C4C37D19F001         vextractf128 ymm8 ymm6 1
       C4C37D19F901         vextractf128 ymm9 ymm7 1
       E8B4F6FFFF           call     JIT.HardwareIntrinsics.X86.SimpleTernaryOpTest__DataTable`4[SingleSingleSingleSingle][System.SingleSystem.SingleSystem.SingleSystem.Single]:get_inArray3Ptr():long:this
       C4C34518F901         vinsertf128 ymm7 ymm9 1
       C4C34D18F001         vinsertf128 ymm6 ymm8 1
       C4E17C1000           vmovups  ymm0 ymmword ptr[rax]
       C4E34D4AF700         vblendvps ymm6 ymm6 ymm7 ymm0
       488BCF               mov      rcx rdi
       C4E37D19F701         vextractf128 ymm7 ymm6 1
       E81FF8FFFF           call     JIT.HardwareIntrinsics.X86.SimpleTernaryOpTest__DataTable`4[SingleSingleSingleSingle][System.SingleSystem.SingleSystem.SingleSystem.Single]:get_outArrayPtr():long:this
       C4E34D18F701         vinsertf128 ymm6 ymm7 1
       C4E17D1130           vmovupd  ymmword ptr[rax] ymm6
       488BCF               mov      rcx rdi
       E8FCF5FFFF           call     JIT.HardwareIntrinsics.X86.SimpleTernaryOpTest__DataTable`4[SingleSingleSingleSingle][System.SingleSystem.SingleSystem.SingleSystem.Single]:get_inArray1Ptr():long:this
       488BD8               mov      rbx rax
       488BCF               mov      rcx rdi
       E831F6FFFF           call     JIT.HardwareIntrinsics.X86.SimpleTernaryOpTest__DataTable`4[SingleSingleSingleSingle][System.SingleSystem.SingleSystem.SingleSystem.Single]:get_inArray2Ptr():long:this
       488BE8               mov      rbp rax
       488BCF               mov      rcx rdi
       E866F6FFFF           call     JIT.HardwareIntrinsics.X86.SimpleTernaryOpTest__DataTable`4[SingleSingleSingleSingle][System.SingleSystem.SingleSystem.SingleSystem.Single]:get_inArray3Ptr():long:this
       4C8BF0               mov      r14 rax
       488BCF               mov      rcx rdi
       E8EBF7FFFF           call     JIT.HardwareIntrinsics.X86.SimpleTernaryOpTest__DataTable`4[SingleSingleSingleSingle][System.SingleSystem.SingleSystem.SingleSystem.Single]:get_outArrayPtr():long:this
       48BA2096C0CDBE010000 mov      rdx 0x1BECDC09620
       488B12               mov      rdx gword ptr [rdx]
       4889542428           mov      gword ptr [rsp+28H] rdx
       4889442420           mov      qword ptr [rsp+20H] rax
       488BD3               mov      rdx rbx
       4C8BC5               mov      r8 rbp
       4D8BCE               mov      r9 r14
       488BCE               mov      rcx rsi
       E803F8FFFF           call     JIT.HardwareIntrinsics.X86.SimpleTernaryOpTest__BlendVariableSingle:ValidateResult(longlonglonglongref):this
       90                   nop      

G_M14836_IG03:
       C4E17828742460       vmovaps  xmm6 qword ptr [rsp+60H]
       C4E178287C2450       vmovaps  xmm7 qword ptr [rsp+50H]
       C4617828442440       vmovaps  xmm8 qword ptr [rsp+40H]
       C46178284C2430       vmovaps  xmm9 qword ptr [rsp+30H]
       C5F877               vzeroupper 
       4883C470             add      rsp 112
       5B                   pop      rbx
       5D                   pop      rbp
       5E                   pop      rsi
       5F                   pop      rdi
       415E                 pop      r14
       C3                   ret      

; Total bytes of code 280 prolog size 41 for method JIT.HardwareIntrinsics.X86.SimpleTernaryOpTest__BlendVariableSingle:RunBasicScenario_Load():this
; ============================================================
```

&lt;/details&gt;


Where a small refactoring:
```C#
public void RunBasicScenario_Load()
{
    var inArray1Ptr = (Single*)(_dataTable.inArray1Ptr);
    var inArray2Ptr = (Single*)(_dataTable.inArray2Ptr);
    var inArray3Ptr = (Single*)(_dataTable.inArray3Ptr);

    var result = Avx.BlendVariable(
        Avx.LoadVector256(inArray1Ptr)
        Avx.LoadVector256(inArray2Ptr)
        Avx.LoadVector256(inArray3Ptr)
    );

    Unsafe.Write(_dataTable.outArrayPtr result);
    ValidateResult(_dataTable.inArray1Ptr _dataTable.inArray2Ptr _dataTable.inArray3Ptr _dataTable.outArrayPtr);
}
```

&lt;details&gt;
&lt;summary&gt;Instead produces the following assembly (click to view):&lt;/summary&gt;

```asm
; Assembly listing for method JIT.HardwareIntrinsics.X86.SimpleTernaryOpTest__BlendVariableSingle:RunBasicScenario_Load():this
; Emitting BLENDED_CODE for X64 CPU with AVX
; optimized code
; rsp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 this         [V00T01] (  8  8   )     ref  -&gt;  rsi         this class-hnd
;  V01 loc0         [V01T07] (  3  3   )    long  -&gt;  rbx        
;  V02 loc1         [V02T08] (  3  3   )    long  -&gt;  rbp        
;  V03 loc2         [V03T09] (  3  3   )    long  -&gt;  rax        
;  V04 loc3         [V04T10] (  2  2   )  simd32  -&gt;  mm6        
;  V05 OutArgs      [V05    ] (  1  1   )  lclBlk (48) [rsp+0x00]  
;  V06 tmp1         [V06T02] (  4  8   )    long  -&gt;  rbx        
;  V07 tmp2         [V07T03] (  4  8   )    long  -&gt;  rbp        
;  V08 tmp3         [V08T04] (  4  8   )    long  -&gt;  r14        
;  V09 tmp4         [V09T06] (  3  6   )    long  -&gt;  rax        
;* V10 tmp5         [V10    ] (  0  0   )  simd32  -&gt;  zero-ref   
;  V11 tmp6         [V11T05] (  4  8   )    long  -&gt;  rax        
;  V12 cse0         [V12T00] ( 18 18   )   byref  -&gt;  rdi        
;
; Lcl frame size = 80

G_M14836_IG01:
       4156                 push     r14
       57                   push     rdi
       56                   push     rsi
       55                   push     rbp
       53                   push     rbx
       4883EC50             sub      rsp 80
       C5F877               vzeroupper 
       C4E17829742440       vmovaps  qword ptr [rsp+40H] xmm6
       C4E178297C2430       vmovaps  qword ptr [rsp+30H] xmm7
       488BF1               mov      rsi rcx

G_M14836_IG02:
       3936                 cmp      dword ptr [rsi] esi
       488D7E70             lea      rdi bword ptr [rsi+112]
       488BCF               mov      rcx rdi
       E874F6FFFF           call     JIT.HardwareIntrinsics.X86.SimpleTernaryOpTest__DataTable`4[SingleSingleSingleSingle][System.SingleSystem.SingleSystem.SingleSystem.Single]:get_inArray1Ptr():long:this
       488BD8               mov      rbx rax
       488BCF               mov      rcx rdi
       E8A9F6FFFF           call     JIT.HardwareIntrinsics.X86.SimpleTernaryOpTest__DataTable`4[SingleSingleSingleSingle][System.SingleSystem.SingleSystem.SingleSystem.Single]:get_inArray2Ptr():long:this
       488BE8               mov      rbp rax
       488BCF               mov      rcx rdi
       E8DEF6FFFF           call     JIT.HardwareIntrinsics.X86.SimpleTernaryOpTest__DataTable`4[SingleSingleSingleSingle][System.SingleSystem.SingleSystem.SingleSystem.Single]:get_inArray3Ptr():long:this
       C4E17C1003           vmovups  ymm0 ymmword ptr[rbx]
       C4E17C1008           vmovups  ymm1 ymmword ptr[rax]
       C4E37D4A750010       vblendvps ymm6 ymm0 [rbp] ymm1
       488BCF               mov      rcx rdi
       C4E37D19F701         vextractf128 ymm7 ymm6 1
       E84FF8FFFF           call     JIT.HardwareIntrinsics.X86.SimpleTernaryOpTest__DataTable`4[SingleSingleSingleSingle][System.SingleSystem.SingleSystem.SingleSystem.Single]:get_outArrayPtr():long:this
       C4E34D18F701         vinsertf128 ymm6 ymm7 1
       C4E17D1130           vmovupd  ymmword ptr[rax] ymm6
       488BCF               mov      rcx rdi
       E82CF6FFFF           call     JIT.HardwareIntrinsics.X86.SimpleTernaryOpTest__DataTable`4[SingleSingleSingleSingle][System.SingleSystem.SingleSystem.SingleSystem.Single]:get_inArray1Ptr():long:this
       488BD8               mov      rbx rax
       488BCF               mov      rcx rdi
       E861F6FFFF           call     JIT.HardwareIntrinsics.X86.SimpleTernaryOpTest__DataTable`4[SingleSingleSingleSingle][System.SingleSystem.SingleSystem.SingleSystem.Single]:get_inArray2Ptr():long:this
       488BE8               mov      rbp rax
       488BCF               mov      rcx rdi
       E896F6FFFF           call     JIT.HardwareIntrinsics.X86.SimpleTernaryOpTest__DataTable`4[SingleSingleSingleSingle][System.SingleSystem.SingleSystem.SingleSystem.Single]:get_inArray3Ptr():long:this
       4C8BF0               mov      r14 rax
       488BCF               mov      rcx rdi
       E81BF8FFFF           call     JIT.HardwareIntrinsics.X86.SimpleTernaryOpTest__DataTable`4[SingleSingleSingleSingle][System.SingleSystem.SingleSystem.SingleSystem.Single]:get_outArrayPtr():long:this
       48BA20960090F9010000 mov      rdx 0x1F990009620
       488B12               mov      rdx gword ptr [rdx]
       4889542428           mov      gword ptr [rsp+28H] rdx
       4889442420           mov      qword ptr [rsp+20H] rax
       488BD3               mov      rdx rbx
       4C8BC5               mov      r8 rbp
       4D8BCE               mov      r9 r14
       488BCE               mov      rcx rsi
       E833F8FFFF           call     JIT.HardwareIntrinsics.X86.SimpleTernaryOpTest__BlendVariableSingle:ValidateResult(longlonglonglongref):this
       90                   nop      

G_M14836_IG03:
       C4E17828742440       vmovaps  xmm6 qword ptr [rsp+40H]
       C4E178287C2430       vmovaps  xmm7 qword ptr [rsp+30H]
       C5F877               vzeroupper 
       4883C450             add      rsp 80
       5B                   pop      rbx
       5D                   pop      rbp
       5E                   pop      rsi
       5F                   pop      rdi
       415E                 pop      r14
       C3                   ret      

; Total bytes of code 218 prolog size 27 for method JIT.HardwareIntrinsics.X86.SimpleTernaryOpTest__BlendVariableSingle:RunBasicScenario_Load():this
; ============================================================
```

&lt;/details&gt;

category:cq
theme:vector-codegen
skill-level:expert
cost:large</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
    <CreatedAt>7/07/2018 6:58:44 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18815</IssueLabelID>
    <Title>[RyuJIT] Assert failure "unexpected operand size" when folding LCL_FLD into Avx.BlendVariable </Title>
    <Description>The assert failture happens
```
Assert failure(PID 2324 [0x00000914] Thread: 8032 [0x1f60]): Assertion failed '!"unexpected operand size"' in 'Packet256Tracer:GetNaturalColor(structstructstructstructref):struct:this' (IL size 830)

    File: d:\workspace\coreclr\src\jit\emitxarch.cpp Line: 10343
    Image: C:\Program Files\dotnet\dotnet.exe
```
when RyuJIT tries to generate the below `vblendvps`
```
IN00cd:        vinsertf128 ymm8 ymm9 1
Added IP mapping: 0x0095 STACK_EMPTY (G_M18437_IG06ins#34ofs#229)
Generating: N583 (  0  3) [000182] ------------                 IL_OFFSET void   IL offset: 0x95 REG NA
Generating: N585 (  0  0) [000178] ------------       t178 =    HWIntrinsic simd32 float SetZeroVector256 REG mm7 $626
IN00ce:        vxorps   ymm7 ymm7 ymm7
                                                             /--*  t178   simd32 
Generating: N587 (  0  3) [000181] DA----------              *  STORE_LCL_VAR simd32 V17 loc10        d:3 mm7 REG mm7
							V17 in reg mm7 is becoming live  [000181]
							Live regs: 0000F0E8 {rbx rbp rsi rdi r12 r13 r14 r15 xmm8} =&gt; 0000F0E8 {rbx rbp rsi rdi r12 r13 r14 r15 xmm7 xmm8}
							Live vars: {V00 V01 V02 V03 V04 V05 V06 V07 V08 V14 V15 V21 V24 V25 V31} =&gt; {V00 V01 V02 V03 V04 V05 V06 V07 V08 V14 V15 V17 V21 V24 V25 V31}
Added IP mapping: 0x009C STACK_EMPTY (G_M18437_IG06ins#35ofs#234)
Generating: N589 (  8  9) [000195] ------------                 IL_OFFSET void   IL offset: 0x9c REG NA
Generating: N591 (  1  1) [000183] ------------       t183 =    LCL_VAR   simd32 V17 loc10        u:3 mm7 REG mm7 $7cb
Generating: N593 (  3  4) [000184] -c----------       t184 =    LCL_FLD   simd32 V16 loc9         u:3[+0] Fseq[Xs] NA REG NA &lt;l:$764 c:$765&gt;
Generating: N595 (  1  1) [000187] ------------       t187 =    LCL_VAR   simd32 V15 loc8         u:3 mm8 REG mm8 $6ff
                                                             /--*  t183   simd32 
                                                             +--*  t184   simd32 
                                                             +--*  t187   simd32 
Generating: N597 (  8  9) [000191] ------------       t191 = *  HWIntrinsic simd32 float BlendVariable REG mm0 $627
IN00cf:        vblendvps ymm0 ymm7 [V16 rsp+1190H] ymm8
```

This bug is detected in the work of https://github.com/dotnet/coreclr/issues/17798 and .NET Core 2.1 works fine so it seems introduced by the recent containment change.

@tannergooding @CarolEidt </Description>
    <Title_Description>[RyuJIT] Assert failure "unexpected operand size" when folding LCL_FLD into Avx.BlendVariable  The assert failture happens
```
Assert failure(PID 2324 [0x00000914] Thread: 8032 [0x1f60]): Assertion failed '!"unexpected operand size"' in 'Packet256Tracer:GetNaturalColor(structstructstructstructref):struct:this' (IL size 830)

    File: d:\workspace\coreclr\src\jit\emitxarch.cpp Line: 10343
    Image: C:\Program Files\dotnet\dotnet.exe
```
when RyuJIT tries to generate the below `vblendvps`
```
IN00cd:        vinsertf128 ymm8 ymm9 1
Added IP mapping: 0x0095 STACK_EMPTY (G_M18437_IG06ins#34ofs#229)
Generating: N583 (  0  3) [000182] ------------                 IL_OFFSET void   IL offset: 0x95 REG NA
Generating: N585 (  0  0) [000178] ------------       t178 =    HWIntrinsic simd32 float SetZeroVector256 REG mm7 $626
IN00ce:        vxorps   ymm7 ymm7 ymm7
                                                             /--*  t178   simd32 
Generating: N587 (  0  3) [000181] DA----------              *  STORE_LCL_VAR simd32 V17 loc10        d:3 mm7 REG mm7
							V17 in reg mm7 is becoming live  [000181]
							Live regs: 0000F0E8 {rbx rbp rsi rdi r12 r13 r14 r15 xmm8} =&gt; 0000F0E8 {rbx rbp rsi rdi r12 r13 r14 r15 xmm7 xmm8}
							Live vars: {V00 V01 V02 V03 V04 V05 V06 V07 V08 V14 V15 V21 V24 V25 V31} =&gt; {V00 V01 V02 V03 V04 V05 V06 V07 V08 V14 V15 V17 V21 V24 V25 V31}
Added IP mapping: 0x009C STACK_EMPTY (G_M18437_IG06ins#35ofs#234)
Generating: N589 (  8  9) [000195] ------------                 IL_OFFSET void   IL offset: 0x9c REG NA
Generating: N591 (  1  1) [000183] ------------       t183 =    LCL_VAR   simd32 V17 loc10        u:3 mm7 REG mm7 $7cb
Generating: N593 (  3  4) [000184] -c----------       t184 =    LCL_FLD   simd32 V16 loc9         u:3[+0] Fseq[Xs] NA REG NA &lt;l:$764 c:$765&gt;
Generating: N595 (  1  1) [000187] ------------       t187 =    LCL_VAR   simd32 V15 loc8         u:3 mm8 REG mm8 $6ff
                                                             /--*  t183   simd32 
                                                             +--*  t184   simd32 
                                                             +--*  t187   simd32 
Generating: N597 (  8  9) [000191] ------------       t191 = *  HWIntrinsic simd32 float BlendVariable REG mm0 $627
IN00cf:        vblendvps ymm0 ymm7 [V16 rsp+1190H] ymm8
```

This bug is detected in the work of https://github.com/dotnet/coreclr/issues/17798 and .NET Core 2.1 works fine so it seems introduced by the recent containment change.

@tannergooding @CarolEidt </Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>tannergooding</Assignee>
    <CreatedAt>6/07/2018 11:45:37 PM +00:00</CreatedAt>
    <ClosedAt>10/07/2018 9:34:13 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18810</IssueLabelID>
    <Title>Allow test projects to be SDK style</Title>
    <Description>This change updates the associated targets and props files in the test directory to allow the test csproj's to be built as SDK style projects alongside traditional style projects.

It does not yet upgrade any of the projects I'll submit a seperate batch of PRs for that so that these changes aren't lost in a ton of mechanical refactoring.

While these changes allow the csproj's to be upgraded there is still work to be done to allow depproj and ilproj's to be converted over to the new style. By allowing a mix of projects styles this change allows us to upgrade piece-meal rather than in a single big bang hopefully allowing us to easier figure out bugs if they arise. 

- Remove CodeTaskFactory:
  - Allows the projects to be built using the core version of msbuild/dotnet build
  - Converted to using msbuild property expansion instead
- Add directory.build.{propstargets}:
  - Currently we just import the dirs.props and targets but means SDK style projects don't need to explicitly include these files
   - We probably want to move all projects over to using these in the future but this keeps the changes smaller for now
- Specific code for SDK projects:
  - There are a several changes required to build an SDK project. This change guards them behind conditionals so that only the new style projects see them. When we get to the point that there are only new projects we can remove the guards (probably at the same time as ditching the dir.props)
- Reordered build targets:
  - Because SDK projects implicitly import the build targets we can no longer re-define the build targets unconditionally knowing they will likely be overwritten. 
  - Instead we move the overwritten targets to seperate files and include these conditionally based on properties. In this way there is always a build defined for SDK projects which can then be overwritten to do nothing as needed.</Description>
    <Title_Description>Allow test projects to be SDK style This change updates the associated targets and props files in the test directory to allow the test csproj's to be built as SDK style projects alongside traditional style projects.

It does not yet upgrade any of the projects I'll submit a seperate batch of PRs for that so that these changes aren't lost in a ton of mechanical refactoring.

While these changes allow the csproj's to be upgraded there is still work to be done to allow depproj and ilproj's to be converted over to the new style. By allowing a mix of projects styles this change allows us to upgrade piece-meal rather than in a single big bang hopefully allowing us to easier figure out bugs if they arise. 

- Remove CodeTaskFactory:
  - Allows the projects to be built using the core version of msbuild/dotnet build
  - Converted to using msbuild property expansion instead
- Add directory.build.{propstargets}:
  - Currently we just import the dirs.props and targets but means SDK style projects don't need to explicitly include these files
   - We probably want to move all projects over to using these in the future but this keeps the changes smaller for now
- Specific code for SDK projects:
  - There are a several changes required to build an SDK project. This change guards them behind conditionals so that only the new style projects see them. When we get to the point that there are only new projects we can remove the guards (probably at the same time as ditching the dir.props)
- Reordered build targets:
  - Because SDK projects implicitly import the build targets we can no longer re-define the build targets unconditionally knowing they will likely be overwritten. 
  - Instead we move the overwritten targets to seperate files and include these conditionally based on properties. In this way there is always a build defined for SDK projects which can then be overwritten to do nothing as needed.</Title_Description>
    <Label>test enhancement</Label>
    <Assignee>chsienki</Assignee>
    <CreatedAt>6/07/2018 7:11:35 PM +00:00</CreatedAt>
    <ClosedAt>19/07/2018 9:35:04 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18809</IssueLabelID>
    <Title>Correct AssemblyLoadContext comment</Title>
    <Description>- This existing comment appears to be incorrectly narrow.
- My testing validates this.</Description>
    <Title_Description>Correct AssemblyLoadContext comment - This existing comment appears to be incorrectly narrow.
- My testing validates this.</Title_Description>
    <Label>area-AssemblyLoader</Label>
    <Assignee>jeffschwMSFT</Assignee>
    <CreatedAt>6/07/2018 6:56:04 PM +00:00</CreatedAt>
    <ClosedAt>8/07/2018 9:56:42 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18807</IssueLabelID>
    <Title>Remove System.Security.Cryptography.X509Certificates.Tests from exclusion list</Title>
    <Description>The troublesome machine `ARM64-AMD-053` was taking offline and will be re-imaged before connecting back. Since the issue #17801 was the machine specific I am removing `System.Security.Cryptography.X509Certificates.Tests` from Windows/arm tests exclusion list.

Closes #17801</Description>
    <Title_Description>Remove System.Security.Cryptography.X509Certificates.Tests from exclusion list The troublesome machine `ARM64-AMD-053` was taking offline and will be re-imaged before connecting back. Since the issue #17801 was the machine specific I am removing `System.Security.Cryptography.X509Certificates.Tests` from Windows/arm tests exclusion list.

Closes #17801</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>echesakovMSFT</Assignee>
    <CreatedAt>6/07/2018 4:30:26 PM +00:00</CreatedAt>
    <ClosedAt>13/07/2018 4:10:26 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18791</IssueLabelID>
    <Title>Update certain Marshal APIs to match exception thrown on .NET Framework</Title>
    <Description>See [corefx#30830](https://github.com/dotnet/corefx/issues/30830)</Description>
    <Title_Description>Update certain Marshal APIs to match exception thrown on .NET Framework See [corefx#30830](https://github.com/dotnet/corefx/issues/30830)</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>5/07/2018 5:30:03 PM +00:00</CreatedAt>
    <ClosedAt>5/07/2018 9:29:28 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18790</IssueLabelID>
    <Title>Enable COMPlus_GCHighMemPercent ENV</Title>
    <Description>.NET Framework exposes COMPlus_GCHighMemPercent. This enables configuration of the GC for testing and other things. It is not enabled in Core but should be. Please expose it.

I was doing testing of Docker resource limits. This ENV could be used to determine if the current GC policy for Docker resource limits could be improved. The data suggests that this is the case.

Results of Docker resource limits experiment: https://gist.github.com/richlander/48bb0ad51a2406937b61bea01de7cf87

Please enable this in both 2.2 and 3.0 branches.</Description>
    <Title_Description>Enable COMPlus_GCHighMemPercent ENV .NET Framework exposes COMPlus_GCHighMemPercent. This enables configuration of the GC for testing and other things. It is not enabled in Core but should be. Please expose it.

I was doing testing of Docker resource limits. This ENV could be used to determine if the current GC policy for Docker resource limits could be improved. The data suggests that this is the case.

Results of Docker resource limits experiment: https://gist.github.com/richlander/48bb0ad51a2406937b61bea01de7cf87

Please enable this in both 2.2 and 3.0 branches.</Title_Description>
    <Label>area-GC</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>5/07/2018 5:13:58 PM +00:00</CreatedAt>
    <ClosedAt>17/07/2018 10:13:29 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18789</IssueLabelID>
    <Title>[Arm64/Linux] runtimeeventsource fails gcStress=0x2</Title>
    <Description>@brianrob The new test runtimeeventsource introduced recently is failing gcStress=0x2 consistently.  It also fails gcStress=0x1 occasionally.

Typical failure looks like this

```
corerun runtimeeventsource.exe

Assert failure(PID 5353 [0x000014e9] Thread: 5353 [0x14e9]): CORProfilerStackSnapshotEnabled() || !IsStackWalkerThread()
    File: /home/vmjenkins/workspace/Dotnet/build_coreclr/src/vm/stackwalk.cpp Line: 932
```
</Description>
    <Title_Description>[Arm64/Linux] runtimeeventsource fails gcStress=0x2 @brianrob The new test runtimeeventsource introduced recently is failing gcStress=0x2 consistently.  It also fails gcStress=0x1 occasionally.

Typical failure looks like this

```
corerun runtimeeventsource.exe

Assert failure(PID 5353 [0x000014e9] Thread: 5353 [0x14e9]): CORProfilerStackSnapshotEnabled() || !IsStackWalkerThread()
    File: /home/vmjenkins/workspace/Dotnet/build_coreclr/src/vm/stackwalk.cpp Line: 932
```
</Title_Description>
    <Label>area-Tracing</Label>
    <Assignee>brianrob</Assignee>
    <CreatedAt>5/07/2018 4:51:55 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18788</IssueLabelID>
    <Title>Core CLR Build-Tests definition is ignoring build failures</Title>
    <Description>There's a couple things going on here @RussKeldorph  @jashook FYI.

- ILAsm commands are (seemingly randomly) failing in the build
- Build-test.cmd does not successfully fail the VSTS Task phase it's in if it throws errors.

Build : Master - 20180705.05 (Product Build)
Failing configurations:
- Windows
  - Build-Tests-R2R-Release
[Mission Control Build Info](https://mc.dot.net/#/product/netcore/master/source/official~2Fcoreclr~2Fmaster~2F/type/build~2Fproduct~2F/build/20180705.05/workItem/Orchestration/analysis/external/Link)</Description>
    <Title_Description>Core CLR Build-Tests definition is ignoring build failures There's a couple things going on here @RussKeldorph  @jashook FYI.

- ILAsm commands are (seemingly randomly) failing in the build
- Build-test.cmd does not successfully fail the VSTS Task phase it's in if it throws errors.

Build : Master - 20180705.05 (Product Build)
Failing configurations:
- Windows
  - Build-Tests-R2R-Release
[Mission Control Build Info](https://mc.dot.net/#/product/netcore/master/source/official~2Fcoreclr~2Fmaster~2F/type/build~2Fproduct~2F/build/20180705.05/workItem/Orchestration/analysis/external/Link)</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>MattGal</Assignee>
    <CreatedAt>5/07/2018 4:42:27 PM +00:00</CreatedAt>
    <ClosedAt>6/12/2018 7:08:17 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18786</IssueLabelID>
    <Title>Sub-optimal codegen with C# `switch` statement handling for some simple cases</Title>
    <Description>The check for `switch` statement input value range is duplicated in JIT for some simple cases.
Consider the following repro code:

```
static readonly ulong v = 2;
static ulong result = 0;

static void Main(string[] args)
{
    switch (v)
    {
        case 2: ++result; goto case 1;
        case 1: ++result; goto case 0;
        case 0: ++result; goto default;
        default: break;
    }

    Console.WriteLine("v={0} =&gt; result={1}" v result);
}
```
--------------------
**IL produced:**

```
.method private hidebysig static void  Main(string[] args) cil managed
{
  .entrypoint
  // Code size       105 (0x69)
  .maxstack  3
  .locals init (uint64 V_0)
  IL_0000:  ldsfld     uint64 _100GbSort.Program2::v
  IL_0005:  stloc.0
  IL_0006:  ldloc.0
  IL_0007:  dup
  IL_0008:  ldc.i4.2
  IL_0009:  conv.i8
  IL_000a:  ble.un.s   IL_000f    &lt;=== **range check from C# compiler**
  IL_000c:  pop
  IL_000d:  br.s       IL_004a    &lt;=== **range check from C# compiler**
  IL_000f:  conv.u4
  IL_0010:  switch     ( 
                        IL_003d
                        IL_0030
                        IL_0023)
  IL_0021:  br.s       IL_004a
  IL_0023:  ldsfld     uint64 _100GbSort.Program2::result
  IL_0028:  ldc.i4.1
  IL_0029:  conv.i8
  IL_002a:  add
  IL_002b:  stsfld     uint64 _100GbSort.Program2::result
  IL_0030:  ldsfld     uint64 _100GbSort.Program2::result
  IL_0035:  ldc.i4.1
  IL_0036:  conv.i8
  IL_0037:  add
  IL_0038:  stsfld     uint64 _100GbSort.Program2::result
  IL_003d:  ldsfld     uint64 _100GbSort.Program2::result
  IL_0042:  ldc.i4.1
  IL_0043:  conv.i8
  IL_0044:  add
  IL_0045:  stsfld     uint64 _100GbSort.Program2::result
  IL_004a:  ldstr      "v={0} =&gt; result={1}"
  IL_004f:  ldsfld     uint64 _100GbSort.Program2::v
  IL_0054:  box        [System.Runtime]System.UInt64
  IL_0059:  ldsfld     uint64 _100GbSort.Program2::result
  IL_005e:  box        [System.Runtime]System.UInt64
  IL_0063:  call       void [System.Console]System.Console::WriteLine(string
                                                                      object
                                                                      object)
  IL_0068:  ret
} // end of method Program2::Main
```
--------------------------
**Disasm:**
```
--- Program2.cs ---
    switch (v)
000007FE74D51450  push        rdi  
000007FE74D51451  push        rsi  
000007FE74D51452  sub         rsp28h  
000007FE74D51456  mov         rcx7FE74C34B30h  
000007FE74D51460  mov         edx1  
000007FE74D51465  call        000007FED48404F0  
000007FE74D5146A  mov         rsiqword ptr [7FE74C34B68h]  
000007FE74D51471  mov         rdirsi  
000007FE74D51474  cmp         rdi2               &lt;======== **range check from C# compiler**
000007FE74D51478  ja          000007FE74D514AC  
000007FE74D5147A  cmp         edi2               &lt;========= **unneeded check**
000007FE74D5147D  ja          000007FE74D514AC    &lt;========= **unneeded check**
000007FE74D5147F  mov         eaxedi  
000007FE74D51481  lea         rdx[7FE74D51500h]  
000007FE74D51488  mov         edxdword ptr [rdx+rax*4]  
000007FE74D5148B  lea         rcx[7FE74D51456h]  
000007FE74D51492  add         rdxrcx  
000007FE74D51495  jmp         rdx  
    {
        case 2: ++result; goto case 1;
000007FE74D51497  inc         qword ptr [7FE74C34B70h]  
        case 1: ++result; goto case 0;
000007FE74D5149E  inc         qword ptr [7FE74C34B70h]  
        case 0: ++result; goto default;
000007FE74D514A5  inc         qword ptr [7FE74C34B70h]  
        default: break;
    }

    Console.WriteLine("v={0} =&gt; result={1}" v result);
000007FE74D514AC  mov         rcx7FED4171B00h  
000007FE74D514B6  call        000007FED48400F0  
000007FE74D514BB  mov         rdirax  
000007FE74D514BE  mov         qword ptr [rdi+8]rsi  
000007FE74D514C2  mov         rcx7FED4171B00h  
000007FE74D514CC  call        000007FED48400F0  
000007FE74D514D1  mov         r8rax  
000007FE74D514D4  mov         rdxqword ptr [7FE74C34B70h]  
000007FE74D514DB  mov         qword ptr [r8+8]rdx  
000007FE74D514DF  mov         rdxrdi  
000007FE74D514E2  mov         rcxqword ptr [12533068h]  
000007FE74D514EA  call        000007FE74D51308  
000007FE74D514EF  nop  
000007FE74D514F0  add         rsp28h  
000007FE74D514F4  pop         rsi  
000007FE74D514F5  pop         rdi  
000007FE74D514F6  ret 
```


category:cq
theme:inlining
skill-level:intermediate
cost:medium</Description>
    <Title_Description>Sub-optimal codegen with C# `switch` statement handling for some simple cases The check for `switch` statement input value range is duplicated in JIT for some simple cases.
Consider the following repro code:

```
static readonly ulong v = 2;
static ulong result = 0;

static void Main(string[] args)
{
    switch (v)
    {
        case 2: ++result; goto case 1;
        case 1: ++result; goto case 0;
        case 0: ++result; goto default;
        default: break;
    }

    Console.WriteLine("v={0} =&gt; result={1}" v result);
}
```
--------------------
**IL produced:**

```
.method private hidebysig static void  Main(string[] args) cil managed
{
  .entrypoint
  // Code size       105 (0x69)
  .maxstack  3
  .locals init (uint64 V_0)
  IL_0000:  ldsfld     uint64 _100GbSort.Program2::v
  IL_0005:  stloc.0
  IL_0006:  ldloc.0
  IL_0007:  dup
  IL_0008:  ldc.i4.2
  IL_0009:  conv.i8
  IL_000a:  ble.un.s   IL_000f    &lt;=== **range check from C# compiler**
  IL_000c:  pop
  IL_000d:  br.s       IL_004a    &lt;=== **range check from C# compiler**
  IL_000f:  conv.u4
  IL_0010:  switch     ( 
                        IL_003d
                        IL_0030
                        IL_0023)
  IL_0021:  br.s       IL_004a
  IL_0023:  ldsfld     uint64 _100GbSort.Program2::result
  IL_0028:  ldc.i4.1
  IL_0029:  conv.i8
  IL_002a:  add
  IL_002b:  stsfld     uint64 _100GbSort.Program2::result
  IL_0030:  ldsfld     uint64 _100GbSort.Program2::result
  IL_0035:  ldc.i4.1
  IL_0036:  conv.i8
  IL_0037:  add
  IL_0038:  stsfld     uint64 _100GbSort.Program2::result
  IL_003d:  ldsfld     uint64 _100GbSort.Program2::result
  IL_0042:  ldc.i4.1
  IL_0043:  conv.i8
  IL_0044:  add
  IL_0045:  stsfld     uint64 _100GbSort.Program2::result
  IL_004a:  ldstr      "v={0} =&gt; result={1}"
  IL_004f:  ldsfld     uint64 _100GbSort.Program2::v
  IL_0054:  box        [System.Runtime]System.UInt64
  IL_0059:  ldsfld     uint64 _100GbSort.Program2::result
  IL_005e:  box        [System.Runtime]System.UInt64
  IL_0063:  call       void [System.Console]System.Console::WriteLine(string
                                                                      object
                                                                      object)
  IL_0068:  ret
} // end of method Program2::Main
```
--------------------------
**Disasm:**
```
--- Program2.cs ---
    switch (v)
000007FE74D51450  push        rdi  
000007FE74D51451  push        rsi  
000007FE74D51452  sub         rsp28h  
000007FE74D51456  mov         rcx7FE74C34B30h  
000007FE74D51460  mov         edx1  
000007FE74D51465  call        000007FED48404F0  
000007FE74D5146A  mov         rsiqword ptr [7FE74C34B68h]  
000007FE74D51471  mov         rdirsi  
000007FE74D51474  cmp         rdi2               &lt;======== **range check from C# compiler**
000007FE74D51478  ja          000007FE74D514AC  
000007FE74D5147A  cmp         edi2               &lt;========= **unneeded check**
000007FE74D5147D  ja          000007FE74D514AC    &lt;========= **unneeded check**
000007FE74D5147F  mov         eaxedi  
000007FE74D51481  lea         rdx[7FE74D51500h]  
000007FE74D51488  mov         edxdword ptr [rdx+rax*4]  
000007FE74D5148B  lea         rcx[7FE74D51456h]  
000007FE74D51492  add         rdxrcx  
000007FE74D51495  jmp         rdx  
    {
        case 2: ++result; goto case 1;
000007FE74D51497  inc         qword ptr [7FE74C34B70h]  
        case 1: ++result; goto case 0;
000007FE74D5149E  inc         qword ptr [7FE74C34B70h]  
        case 0: ++result; goto default;
000007FE74D514A5  inc         qword ptr [7FE74C34B70h]  
        default: break;
    }

    Console.WriteLine("v={0} =&gt; result={1}" v result);
000007FE74D514AC  mov         rcx7FED4171B00h  
000007FE74D514B6  call        000007FED48400F0  
000007FE74D514BB  mov         rdirax  
000007FE74D514BE  mov         qword ptr [rdi+8]rsi  
000007FE74D514C2  mov         rcx7FED4171B00h  
000007FE74D514CC  call        000007FED48400F0  
000007FE74D514D1  mov         r8rax  
000007FE74D514D4  mov         rdxqword ptr [7FE74C34B70h]  
000007FE74D514DB  mov         qword ptr [r8+8]rdx  
000007FE74D514DF  mov         rdxrdi  
000007FE74D514E2  mov         rcxqword ptr [12533068h]  
000007FE74D514EA  call        000007FE74D51308  
000007FE74D514EF  nop  
000007FE74D514F0  add         rsp28h  
000007FE74D514F4  pop         rsi  
000007FE74D514F5  pop         rdi  
000007FE74D514F6  ret 
```


category:cq
theme:inlining
skill-level:intermediate
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>5/07/2018 11:05:36 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18784</IssueLabelID>
    <Title>Add missing FlushInstructionCache to CommitGCStressInstructionUpdate</Title>
    <Description>It's my understanding that missing `FlushInstructionCache` in `Thread::CommitGCStressInstructionUpdate` was the reason of the assertion failures we observed in https://github.com/dotnet/coreclr/issues/17570#issuecomment-382913069. 
```
BEGIN EXECUTION
 "C:\Users\robox\j\workspace\arm_cross_che---88fcf6b1\bin\tests\Windows_NT.arm.Checked\Tests\Core_Root\corerun.exe" thread22.exe 

Assert failure(PID 16144 [0x00003f10] Thread: 17188 [0x4324]): instrVal32 == *(DWORD*)(gcCover-&gt;savedCode + offset)

&lt;no module&gt;! &lt;no symbol&gt; + 0x0 (0x00000000)
    File: d:\j\workspace\arm_cross_che---9fe37e18\src\vm\gccover.cpp Line: 1451
    Image: C:\Users\robox\j\workspace\arm_cross_che---88fcf6b1\bin\tests\Windows_NT.arm.Checked\Tests\Core_Root\CoreRun.exe

Expected: 100
Actual: 123456789
END EXECUTION - FAILED
FAILED
```
I have done proper testing of this change with threading tests (running them 10000 times in a loop) previous failing under `GCStress=0xC` and the issue is not reproducible anymore.

Fixes #17570</Description>
    <Title_Description>Add missing FlushInstructionCache to CommitGCStressInstructionUpdate It's my understanding that missing `FlushInstructionCache` in `Thread::CommitGCStressInstructionUpdate` was the reason of the assertion failures we observed in https://github.com/dotnet/coreclr/issues/17570#issuecomment-382913069. 
```
BEGIN EXECUTION
 "C:\Users\robox\j\workspace\arm_cross_che---88fcf6b1\bin\tests\Windows_NT.arm.Checked\Tests\Core_Root\corerun.exe" thread22.exe 

Assert failure(PID 16144 [0x00003f10] Thread: 17188 [0x4324]): instrVal32 == *(DWORD*)(gcCover-&gt;savedCode + offset)

&lt;no module&gt;! &lt;no symbol&gt; + 0x0 (0x00000000)
    File: d:\j\workspace\arm_cross_che---9fe37e18\src\vm\gccover.cpp Line: 1451
    Image: C:\Users\robox\j\workspace\arm_cross_che---88fcf6b1\bin\tests\Windows_NT.arm.Checked\Tests\Core_Root\CoreRun.exe

Expected: 100
Actual: 123456789
END EXECUTION - FAILED
FAILED
```
I have done proper testing of this change with threading tests (running them 10000 times in a loop) previous failing under `GCStress=0xC` and the issue is not reproducible anymore.

Fixes #17570</Title_Description>
    <Label>GCStress</Label>
    <Assignee>echesakovMSFT</Assignee>
    <CreatedAt>5/07/2018 3:48:42 AM +00:00</CreatedAt>
    <ClosedAt>23/07/2018 9:15:08 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18780</IssueLabelID>
    <Title>RyuJIT incorrectly narrows value on ARM32/x86 in release</Title>
    <Description>On ARM32 and x86 with .NET core 2.1 the following program prints `4294967295` in debug but `255` in release:

```csharp
// Generated by Fuzzlyn on 2018-07-03 07:50:20
// Seed: 10009979209080502034
// Reduced from 429.6 KiB to 0.4 KiB
// Debug: Outputs 4294967295
// Release: Outputs 255
public class Program
{
    public static void Main()
    {
        M1(0);
    }

    static void M1(byte arg2)
    {
        byte vr23 = arg2++;
        uint vr13 = uint.MaxValue * arg2;
        ulong vr40 = vr13;
        System.Console.WriteLine(vr40);
    }
}
```

It does not repro on AMD64 (Windows or Linux). Also changing `byte vr23 = arg2++;` to `arg2++;` fixes it.</Description>
    <Title_Description>RyuJIT incorrectly narrows value on ARM32/x86 in release On ARM32 and x86 with .NET core 2.1 the following program prints `4294967295` in debug but `255` in release:

```csharp
// Generated by Fuzzlyn on 2018-07-03 07:50:20
// Seed: 10009979209080502034
// Reduced from 429.6 KiB to 0.4 KiB
// Debug: Outputs 4294967295
// Release: Outputs 255
public class Program
{
    public static void Main()
    {
        M1(0);
    }

    static void M1(byte arg2)
    {
        byte vr23 = arg2++;
        uint vr13 = uint.MaxValue * arg2;
        ulong vr40 = vr13;
        System.Console.WriteLine(vr40);
    }
}
```

It does not repro on AMD64 (Windows or Linux). Also changing `byte vr23 = arg2++;` to `arg2++;` fixes it.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>jakobbotsch</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18779</IssueLabelID>
    <Title>General protection fault on Linux</Title>
    <Description>I'm running a pretty standard ASP.NET Core application in Kubernetes on the Google Cloud.  
I'm using self-contained deployment with the `linux-x64` runtime identifier the target framework is `2.1` and I'm using the `microsoft/dotnet:2.1-runtime-deps` base image.  
The host distro is the Container-Optimized OS by Google.

I have 100 instances running on 100 separate host nodes. The cluster is heavily loaded with traffic due to executing some load tests so the application is using 100% of the host CPU most of the time.

What I see is that out of my 100 instances a handful of them were restarted a couple of times which means that their Docker container on the host node crashed. With `docker ls -a` I can see that the exit code was `137`.

```
$ docker ls -a
CONTAINER ID        IMAGE                COMMAND                  CREATED             STATUS                     PORTS               NAMES
...
4545b28f19ed        d64b5a13e8c5         "./Travix.RulesApi..."   5 hours ago         Exited (137) 4 hours ago                       k8s_rulesapi-core-afd_rulesapi-core-afd-7699764656-s6vm8_production_357bf42c-7ed0-11e8-b092-42010a840012_16
...
```

But if I check the logs of the container I don't see any errors or exceptions printed by the framework the last output message is a normal log message of my application.

The only error message I could find was by running `dmesg` the last event reported is a general protection fault in `libcoreclr.so`.

```
$ dmesg
[41603.315141] traps: Travix.RulesApi[2509] general protection ip:7f9fa121724e sp:7f9fa2d66e00 error:0 in libcoreclr.so[7f9fa1122000+353000]
```

If I check the resource usage of the currently running container it reports 99% CPU-usage.

```
$ docker top 193e4
UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD
root                947                 929                 99                  Jul03               ?                   2-17:02:25          ./Travix.RulesApi.WebService
```

Which is expected under our current stress test but this should not cause the process to crash right?

How could I investigate what is causing this issue?</Description>
    <Title_Description>General protection fault on Linux I'm running a pretty standard ASP.NET Core application in Kubernetes on the Google Cloud.  
I'm using self-contained deployment with the `linux-x64` runtime identifier the target framework is `2.1` and I'm using the `microsoft/dotnet:2.1-runtime-deps` base image.  
The host distro is the Container-Optimized OS by Google.

I have 100 instances running on 100 separate host nodes. The cluster is heavily loaded with traffic due to executing some load tests so the application is using 100% of the host CPU most of the time.

What I see is that out of my 100 instances a handful of them were restarted a couple of times which means that their Docker container on the host node crashed. With `docker ls -a` I can see that the exit code was `137`.

```
$ docker ls -a
CONTAINER ID        IMAGE                COMMAND                  CREATED             STATUS                     PORTS               NAMES
...
4545b28f19ed        d64b5a13e8c5         "./Travix.RulesApi..."   5 hours ago         Exited (137) 4 hours ago                       k8s_rulesapi-core-afd_rulesapi-core-afd-7699764656-s6vm8_production_357bf42c-7ed0-11e8-b092-42010a840012_16
...
```

But if I check the logs of the container I don't see any errors or exceptions printed by the framework the last output message is a normal log message of my application.

The only error message I could find was by running `dmesg` the last event reported is a general protection fault in `libcoreclr.so`.

```
$ dmesg
[41603.315141] traps: Travix.RulesApi[2509] general protection ip:7f9fa121724e sp:7f9fa2d66e00 error:0 in libcoreclr.so[7f9fa1122000+353000]
```

If I check the resource usage of the currently running container it reports 99% CPU-usage.

```
$ docker top 193e4
UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD
root                947                 929                 99                  Jul03               ?                   2-17:02:25          ./Travix.RulesApi.WebService
```

Which is expected under our current stress test but this should not cause the process to crash right?

How could I investigate what is causing this issue?</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>mikem8361</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18777</IssueLabelID>
    <Title>JIT alloc assert "!s_pagePool.isPoolPage(page)" running corefx tests in CI</Title>
    <Description>https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_checked_windows_nt_corefx_innerloop_prtest/388/consoleText
```
Assert failure(PID 7036 [0x00001b7c] Thread: 6744 [0x1a58]): Assertion failed '!s_pagePool.isPoolPage(page)' in 'Xunit.Sdk.ExtensibilityPointFactory:Dispose()' (IL size 21)

    File: d:\j\workspace\x64_checked_w---43686a05\src\jit\alloc.cpp Line: 301
    Image: D:\j\workspace\x64_checked_w---43686a05\bin\tests\Windows_NT.x64.Checked\testhost\dotnet.exe
```</Description>
    <Title_Description>JIT alloc assert "!s_pagePool.isPoolPage(page)" running corefx tests in CI https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_checked_windows_nt_corefx_innerloop_prtest/388/consoleText
```
Assert failure(PID 7036 [0x00001b7c] Thread: 6744 [0x1a58]): Assertion failed '!s_pagePool.isPoolPage(page)' in 'Xunit.Sdk.ExtensibilityPointFactory:Dispose()' (IL size 21)

    File: d:\j\workspace\x64_checked_w---43686a05\src\jit\alloc.cpp Line: 301
    Image: D:\j\workspace\x64_checked_w---43686a05\bin\tests\Windows_NT.x64.Checked\testhost\dotnet.exe
```</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>mikedn</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18772</IssueLabelID>
    <Title>Set ActivityId and RelatedActivityId on EventWrittenEventArgs for Native Events</Title>
    <Description>
    </Description>
    <Title_Description>Set ActivityId and RelatedActivityId on EventWrittenEventArgs for Native Events </Title_Description>
    <Label>area-Tracing</Label>
    <Assignee>brianrob</Assignee>
    <CreatedAt>3/07/2018 11:04:20 PM +00:00</CreatedAt>
    <ClosedAt>1/08/2018 6:41:34 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18771</IssueLabelID>
    <Title>Improve DateTime{Offset}.ParseExact{Multiple} performance for RFC1123 ("r")</Title>
    <Description>Significantly improves the performance of `DateTime.ParseExact(... "r" ...)` by porting and adapting the `Utf8Parser` code from corefx for a **15-20x** throughput increase (and also saving three string allocations totaling ~80bytes... which more generally we should subsequently look at getting rid of for other formats).  This optimizes for the (default) case of a `DateTimeStyles.None`; specifying any other style falls back to the normal parsing support as that requires handling things such as arbitrary whitespace anywhere in the string.

Benchmark:
```C#
using System;
using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Attributes.Jobs;
using BenchmarkDotNet.Running;

[MemoryDiagnoser]
[InProcess]
public class Benchmark
{
    private static void Main() =&gt; BenchmarkRunner.Run&lt;Benchmark&gt;();

    [Benchmark] public DateTime DT_ParseExactR() =&gt; DateTime.ParseExact("Wed 15 Aug 1906 07:24:05 GMT" "r" null);
    [Benchmark] public DateTimeOffset DTO_ParseExactR() =&gt; DateTimeOffset.ParseExact("Wed 15 Aug 1906 07:24:05 GMT" "r" null);

    private static readonly string[] s_formats = new string[] { "R" };
    [Benchmark] public DateTime DT_ParseExactMultipleR() =&gt; DateTime.ParseExact("Wed 15 Aug 1906 07:24:05 GMT" s_formats null);
    [Benchmark] public DateTimeOffset DTO_ParseExactMultipleR() =&gt; DateTimeOffset.ParseExact("Wed 15 Aug 1906 07:24:05 GMT" s_formats null);
}
```

Before:
```
                  Method |     Mean |     Error |    StdDev |  Gen 0 | Allocated |
------------------------ |---------:|----------:|----------:|-------:|----------:|
          DT_ParseExactR | 1.922 us | 0.0377 us | 0.0888 us | 0.0172 |      80 B |
         DTO_ParseExactR | 1.948 us | 0.0374 us | 0.0511 us | 0.0153 |      80 B |
  DT_ParseExactMultipleR | 1.922 us | 0.0265 us | 0.0221 us | 0.0172 |      80 B |
 DTO_ParseExactMultipleR | 1.934 us | 0.0349 us | 0.0292 us | 0.0153 |      80 B |
```

After:
```
                  Method |      Mean |     Error |    StdDev | Allocated |
------------------------ |----------:|----------:|----------:|----------:|
          DT_ParseExactR |  98.38 ns | 0.9119 ns | 0.7119 ns |       0 B |
         DTO_ParseExactR | 123.87 ns | 0.4554 ns | 0.3012 ns |       0 B |
  DT_ParseExactMultipleR | 112.05 ns | 2.3175 ns | 4.6284 ns |       0 B |
 DTO_ParseExactMultipleR | 120.27 ns | 1.3823 ns | 1.2930 ns |       0 B |
```

cc: @ahsonkhan @jkotas @pjanotti @joperezr 
Contributes to https://github.com/dotnet/corefx/issues/30612</Description>
    <Title_Description>Improve DateTime{Offset}.ParseExact{Multiple} performance for RFC1123 ("r") Significantly improves the performance of `DateTime.ParseExact(... "r" ...)` by porting and adapting the `Utf8Parser` code from corefx for a **15-20x** throughput increase (and also saving three string allocations totaling ~80bytes... which more generally we should subsequently look at getting rid of for other formats).  This optimizes for the (default) case of a `DateTimeStyles.None`; specifying any other style falls back to the normal parsing support as that requires handling things such as arbitrary whitespace anywhere in the string.

Benchmark:
```C#
using System;
using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Attributes.Jobs;
using BenchmarkDotNet.Running;

[MemoryDiagnoser]
[InProcess]
public class Benchmark
{
    private static void Main() =&gt; BenchmarkRunner.Run&lt;Benchmark&gt;();

    [Benchmark] public DateTime DT_ParseExactR() =&gt; DateTime.ParseExact("Wed 15 Aug 1906 07:24:05 GMT" "r" null);
    [Benchmark] public DateTimeOffset DTO_ParseExactR() =&gt; DateTimeOffset.ParseExact("Wed 15 Aug 1906 07:24:05 GMT" "r" null);

    private static readonly string[] s_formats = new string[] { "R" };
    [Benchmark] public DateTime DT_ParseExactMultipleR() =&gt; DateTime.ParseExact("Wed 15 Aug 1906 07:24:05 GMT" s_formats null);
    [Benchmark] public DateTimeOffset DTO_ParseExactMultipleR() =&gt; DateTimeOffset.ParseExact("Wed 15 Aug 1906 07:24:05 GMT" s_formats null);
}
```

Before:
```
                  Method |     Mean |     Error |    StdDev |  Gen 0 | Allocated |
------------------------ |---------:|----------:|----------:|-------:|----------:|
          DT_ParseExactR | 1.922 us | 0.0377 us | 0.0888 us | 0.0172 |      80 B |
         DTO_ParseExactR | 1.948 us | 0.0374 us | 0.0511 us | 0.0153 |      80 B |
  DT_ParseExactMultipleR | 1.922 us | 0.0265 us | 0.0221 us | 0.0172 |      80 B |
 DTO_ParseExactMultipleR | 1.934 us | 0.0349 us | 0.0292 us | 0.0153 |      80 B |
```

After:
```
                  Method |      Mean |     Error |    StdDev | Allocated |
------------------------ |----------:|----------:|----------:|----------:|
          DT_ParseExactR |  98.38 ns | 0.9119 ns | 0.7119 ns |       0 B |
         DTO_ParseExactR | 123.87 ns | 0.4554 ns | 0.3012 ns |       0 B |
  DT_ParseExactMultipleR | 112.05 ns | 2.3175 ns | 4.6284 ns |       0 B |
 DTO_ParseExactMultipleR | 120.27 ns | 1.3823 ns | 1.2930 ns |       0 B |
```

cc: @ahsonkhan @jkotas @pjanotti @joperezr 
Contributes to https://github.com/dotnet/corefx/issues/30612</Title_Description>
    <Label>area-System.Runtime</Label>
    <Assignee>ahsonkhan</Assignee>
    <CreatedAt>3/07/2018 8:08:29 PM +00:00</CreatedAt>
    <ClosedAt>5/07/2018 1:38:06 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18770</IssueLabelID>
    <Title>RyuJIT incorrectly reorders expression containing a CSE resulting in exception thrown in release</Title>
    <Description>The following example throws `NullReferenceException` in release but not in debug:
```csharp
// Generated by Fuzzlyn on 2018-07-02 17:44:35
// Seed: 7883145904562184282
// Reduced from 39.4 KiB to 0.4 KiB
// Debug: Runs successfully
// Release: Throws 'System.NullReferenceException'
class C0
{
    public sbyte F0;
    public ushort F7;
    public uint F8;
}

public class Program
{
    static int s_0;
    static C0 s_1 = new C0();

    public static void Main()
    {
        s_0 = 0; // ensure no runtime checks in M0
        M0();
    }

    static void M0()
    {
        bool vr0 = (s_1.F7 &lt; s_1.F0) ^ (s_1.F8 != s_1.F8);
        if (vr0)
        {
            s_1.F7 = s_1.F7;
        }
    }
}
```

Some more information can be found in https://github.com/dotnet/coreclr/issues/18232#issuecomment-402198147.</Description>
    <Title_Description>RyuJIT incorrectly reorders expression containing a CSE, resulting in exception thrown in release The following example throws `NullReferenceException` in release but not in debug:
```csharp
// Generated by Fuzzlyn on 2018-07-02 17:44:35
// Seed: 7883145904562184282
// Reduced from 39.4 KiB to 0.4 KiB
// Debug: Runs successfully
// Release: Throws 'System.NullReferenceException'
class C0
{
    public sbyte F0;
    public ushort F7;
    public uint F8;
}

public class Program
{
    static int s_0;
    static C0 s_1 = new C0();

    public static void Main()
    {
        s_0 = 0; // ensure no runtime checks in M0
        M0();
    }

    static void M0()
    {
        bool vr0 = (s_1.F7 &lt; s_1.F0) ^ (s_1.F8 != s_1.F8);
        if (vr0)
        {
            s_1.F7 = s_1.F7;
        }
    }
}
```

Some more information can be found in https://github.com/dotnet/coreclr/issues/18232#issuecomment-402198147.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>3/07/2018 6:53:10 PM +00:00</CreatedAt>
    <ClosedAt>14/09/2018 11:58:04 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18769</IssueLabelID>
    <Title>spmi: exclude methods using a file with saved md5 hashes.</Title>
    <Description>Exclude methods are presented in a file with the same name as `*.mc\*.mch` that we are running but with `*.exc` extension.
For example: `chaos2131.mc` and `chaos2131.exc`.

We do not expect many methods to be excluded right now we need to exclude at maximum 1 method for 10% of our '*.mch` files. It is why we can start with a linear search and fix it later if we need to.

The '*.exc' file has to contain MD5 hashes with `MD5_HASH_BUFFER_SIZE-1` length they should be separated with newlines or spaces if we find a value with incorrect length then we ignore this value.</Description>
    <Title_Description>spmi: exclude methods using a file with saved md5 hashes. Exclude methods are presented in a file with the same name as `*.mc\*.mch` that we are running but with `*.exc` extension.
For example: `chaos2131.mc` and `chaos2131.exc`.

We do not expect many methods to be excluded right now we need to exclude at maximum 1 method for 10% of our '*.mch` files. It is why we can start with a linear search and fix it later if we need to.

The '*.exc' file has to contain MD5 hashes with `MD5_HASH_BUFFER_SIZE-1` length they should be separated with newlines or spaces if we find a value with incorrect length then we ignore this value.</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>3/07/2018 5:43:07 PM +00:00</CreatedAt>
    <ClosedAt>28/07/2018 1:44:33 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18765</IssueLabelID>
    <Title>Regression in arm64 r2r jobs.  'defList.IsEmpty()' </Title>
    <Description>Many x64_arm64_altjit_checked_windows_nt_r2r test are failing with:

```
Assertion failed 'defList.IsEmpty()' in 'Gen:Target():this' (IL size 33)

    File: c:\git\coreclr\src\jit\lsrabuild.cpp Line: 2094.
```

The regression is caused by #18130 [ci example](https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_arm64_altjit_checked_windows_nt_r2r_prtest/13/testReport/baseservices_threading/_generics_threadstart_GThread18_GThread18_/_generics_threadstart_GThread18_GThread18_cmd/).

</Description>
    <Title_Description>Regression in arm64 r2r jobs.  'defList.IsEmpty()'  Many x64_arm64_altjit_checked_windows_nt_r2r test are failing with:

```
Assertion failed 'defList.IsEmpty()' in 'Gen:Target():this' (IL size 33)

    File: c:\git\coreclr\src\jit\lsrabuild.cpp Line: 2094.
```

The regression is caused by #18130 [ci example](https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_arm64_altjit_checked_windows_nt_r2r_prtest/13/testReport/baseservices_threading/_generics_threadstart_GThread18_GThread18_/_generics_threadstart_GThread18_GThread18_cmd/).

</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18764</IssueLabelID>
    <Title>add missing files to package properly on FreeBSD</Title>
    <Description>This is my best guess based on existing Linux and OSX files. 
It creates missing packages expected by core-setup.</Description>
    <Title_Description>add missing files to package properly on FreeBSD This is my best guess based on existing Linux and OSX files. 
It creates missing packages expected by core-setup.</Title_Description>
    <Label>os-freebsd</Label>
    <Assignee>wfurt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18762</IssueLabelID>
    <Title>Enable profiler attach on Windows</Title>
    <Description>This is an ongoing work to enable profiler attach on CoreCLR. This PR enables the profiler attach feature on Windows. I am in process of working on Unix port. </Description>
    <Title_Description>Enable profiler attach on Windows This is an ongoing work to enable profiler attach on CoreCLR. This PR enables the profiler attach feature on Windows. I am in process of working on Unix port. </Title_Description>
    <Label>
    </Label>
    <Assignee>sywhang</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18759</IssueLabelID>
    <Title>Expose Thread ID and TimeStamp on EventWrittenEventArgs</Title>
    <Description>Historically these could always be fetched when the event was dispatched because EventSource does direct dispatch in real-time.  However now that EventPipe can dispatch to EventListeners the Thread ID and TimeStamp aren't known for these events and needs to be plumbed through.</Description>
    <Title_Description>Expose Thread ID and TimeStamp on EventWrittenEventArgs Historically these could always be fetched when the event was dispatched because EventSource does direct dispatch in real-time.  However now that EventPipe can dispatch to EventListeners the Thread ID and TimeStamp aren't known for these events and needs to be plumbed through.</Title_Description>
    <Label>area-Tracing</Label>
    <Assignee>brianrob</Assignee>
    <CreatedAt>2/07/2018 10:14:55 PM +00:00</CreatedAt>
    <ClosedAt>3/08/2018 6:04:53 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18758</IssueLabelID>
    <Title>Implement Efficient Dispatch Polling Mechanism for EventPipe</Title>
    <Description>Context: https://github.com/dotnet/coreclr/pull/18649#discussion_r199631486

We should consider replacing the polling loop when there are no new events with an AutoResetEvent to ensure that the CPU can go quiescent when there are no events.</Description>
    <Title_Description>Implement Efficient Dispatch Polling Mechanism for EventPipe Context: https://github.com/dotnet/coreclr/pull/18649#discussion_r199631486

We should consider replacing the polling loop when there are no new events with an AutoResetEvent to ensure that the CPU can go quiescent when there are no events.</Title_Description>
    <Label>EventPipe</Label>
    <Assignee>davmason</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18756</IssueLabelID>
    <Title>Port perf infrastructure to Azure Pipelines</Title>
    <Description>
    </Description>
    <Title_Description>Port perf infrastructure to Azure Pipelines </Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>billwert</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18755</IssueLabelID>
    <Title>Support Tracing and EventListener Dispatch Concurrently in EventPipe</Title>
    <Description>Right now it's only possible to do one of the following at any given time:

 - Collect a trace using EventPipe.
 - Dispatch events to EventListener.

This issue tracks making it possible to do these concurrently.</Description>
    <Title_Description>Support Tracing and EventListener Dispatch Concurrently in EventPipe Right now it's only possible to do one of the following at any given time:

 - Collect a trace using EventPipe.
 - Dispatch events to EventListener.

This issue tracks making it possible to do these concurrently.</Title_Description>
    <Label>EventPipe</Label>
    <Assignee>brianrob</Assignee>
    <CreatedAt>2/07/2018 8:49:08 PM +00:00</CreatedAt>
    <ClosedAt>15/04/2019 5:43:38 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18754</IssueLabelID>
    <Title>Implement Efficient EventPipeBuffer Reading in Managed Code</Title>
    <Description>EventPipeBuffers can be read when EventListener consumes events from EventPipe.  Right now this is done with a pinvoke per event.  This issue tracks improving this scheme.</Description>
    <Title_Description>Implement Efficient EventPipeBuffer Reading in Managed Code EventPipeBuffers can be read when EventListener consumes events from EventPipe.  Right now this is done with a pinvoke per event.  This issue tracks improving this scheme.</Title_Description>
    <Label>EventPipe</Label>
    <Assignee>brianrob</Assignee>
    <CreatedAt>2/07/2018 8:46:45 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18752</IssueLabelID>
    <Title>Merge EventPipePayloadDecoder.DecodePayload and EventProvider.DecodeObject</Title>
    <Description>There are two event decoder paths in EventSource.  We should look to merge them.</Description>
    <Title_Description>Merge EventPipePayloadDecoder.DecodePayload and EventProvider.DecodeObject There are two event decoder paths in EventSource.  We should look to merge them.</Title_Description>
    <Label>EventPipe</Label>
    <Assignee>sywhang</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18748</IssueLabelID>
    <Title>RyuJIT sometimes drops volatile reads</Title>
    <Description>Morph issue:
```C#
static volatile int x;

[MethodImpl(MethodImplOptions.NoInlining)]
static int Test(int a) =&gt; x &amp; 0;
```
generates
```asm
G_M55886_IG01:
G_M55886_IG02:
       33C0                 xor      eax eax
G_M55886_IG03:
       C3                   ret
```
Similar issue but involving VN/assertion propagation:
```C#
static int Test(int a)
{
    int k = a &gt; 42 ? 0 : 0;
    return x &amp; k;
}
```
generates the same code as above.
In this case VN assigned `x &amp; k` the VN of constant 0 and then assertion propagation drops the `x` load because it only considers persistent side effects.

Found while working on #18257. Initially I thought that we can simple make assertion propagation use `GTF_ALL_EFFECT` only to discover that it doesn't work because `gtNodeHasSideEffects` doesn't pay attention to side effects other than `GTF_SIDE_EFFECT`. So who's paying attention to `GTF_ORDER_SIDEEFF` and `GTF_GLOB_REF`?!

category:correctness
theme:volatile
skill-level:expert
cost:large</Description>
    <Title_Description>RyuJIT sometimes drops volatile reads Morph issue:
```C#
static volatile int x;

[MethodImpl(MethodImplOptions.NoInlining)]
static int Test(int a) =&gt; x &amp; 0;
```
generates
```asm
G_M55886_IG01:
G_M55886_IG02:
       33C0                 xor      eax eax
G_M55886_IG03:
       C3                   ret
```
Similar issue but involving VN/assertion propagation:
```C#
static int Test(int a)
{
    int k = a &gt; 42 ? 0 : 0;
    return x &amp; k;
}
```
generates the same code as above.
In this case VN assigned `x &amp; k` the VN of constant 0 and then assertion propagation drops the `x` load because it only considers persistent side effects.

Found while working on #18257. Initially I thought that we can simple make assertion propagation use `GTF_ALL_EFFECT` only to discover that it doesn't work because `gtNodeHasSideEffects` doesn't pay attention to side effects other than `GTF_SIDE_EFFECT`. So who's paying attention to `GTF_ORDER_SIDEEFF` and `GTF_GLOB_REF`?!

category:correctness
theme:volatile
skill-level:expert
cost:large</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>2/07/2018 7:32:28 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18746</IssueLabelID>
    <Title>regressions in arm64_altjit r2r jobs: temp != nullptr</Title>
    <Description>Some tests are failing after #18346 for example [b393481](https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_arm64_altjit_checked_windows_nt_r2r_prtest/12/testReport/junit/JIT_Regression/_CLR_x86_JIT_dev10_b393481_b393481_b393481_/_CLR_x86_JIT_dev10_b393481_b393481_b393481_cmd/) fails with `Assertion failed 'temp != nullptr' in 'TestAnonymousTypes.Program:Main(ref):int' (IL size 534)\r\n\r\n File: d:\\j\\workspace\\x64_arm64_alt---840786b4\\src\\jit\\regset.cpp Line: 676`.</Description>
    <Title_Description>regressions in arm64_altjit r2r jobs: temp != nullptr Some tests are failing after #18346 for example [b393481](https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_arm64_altjit_checked_windows_nt_r2r_prtest/12/testReport/junit/JIT_Regression/_CLR_x86_JIT_dev10_b393481_b393481_b393481_/_CLR_x86_JIT_dev10_b393481_b393481_b393481_cmd/) fails with `Assertion failed 'temp != nullptr' in 'TestAnonymousTypes.Program:Main(ref):int' (IL size 534)\r\n\r\n File: d:\\j\\workspace\\x64_arm64_alt---840786b4\\src\\jit\\regset.cpp Line: 676`.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18744</IssueLabelID>
    <Title>Determine how to expose hwintrinsics that are only supported in 64-bit mode</Title>
    <Description>There are several hwintrinsics exposed that are only emittable in 64-bit mode and throw a PNSE exception if invoked in 32-bit mode (regardless of the fact that the general `Isa.IsSupported` check returns true).

We should have a deeper discussion on how to properly expose this data to the consumer of these APIs.</Description>
    <Title_Description>Determine how to expose hwintrinsics that are only supported in 64-bit mode There are several hwintrinsics exposed that are only emittable in 64-bit mode and throw a PNSE exception if invoked in 32-bit mode (regardless of the fact that the general `Isa.IsSupported` check returns true).

We should have a deeper discussion on how to properly expose this data to the consumer of these APIs.</Title_Description>
    <Label>Design Discussion</Label>
    <Assignee>CarolEidt</Assignee>
    <CreatedAt>2/07/2018 4:57:21 PM +00:00</CreatedAt>
    <ClosedAt>9/11/2018 4:35:39 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18743</IssueLabelID>
    <Title>Ensure that the indirect call fallback for HWIntrinsics executes the same instructions as the inlined version</Title>
    <Description>There are a few `Avx` helper functions (namely `Extract` and `Insert`) which are emitting a managed software implementation rather than a switch table fallback.

These should be updated to use the switch table fallback instead.</Description>
    <Title_Description>Ensure that the indirect call fallback for HWIntrinsics executes the same instructions as the inlined version There are a few `Avx` helper functions (namely `Extract` and `Insert`) which are emitting a managed software implementation rather than a switch table fallback.

These should be updated to use the switch table fallback instead.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
    <CreatedAt>2/07/2018 4:54:51 PM +00:00</CreatedAt>
    <ClosedAt>6/12/2018 8:00:16 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18742</IssueLabelID>
    <Title>Add back DefinePInvokeMethod</Title>
    <Description>https://github.com/dotnet/corefx/issues/30355</Description>
    <Title_Description>Add back DefinePInvokeMethod https://github.com/dotnet/corefx/issues/30355 </Title_Description>
    <Label>area-System.Reflection</Label>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18741</IssueLabelID>
    <Title>Question about software protection</Title>
    <Description>There is a question about software protection. We used confusing software to compiling and then obscure the code and then deploying。we use hardware key to protection secret algorithms so that the software could be prevented from being copied. Now deployed in the container if a customer asks us to deploy a private cloud to them the file is easily copied by . Whether the container can be restricted can not be mounted or can not be copied.</Description>
    <Title_Description>Question about software protection There is a question about software protection. We used confusing software to compiling and then obscure the code and then deploying。we use hardware key to protection secret algorithms so that the software could be prevented from being copied. Now deployed in the container if a customer asks us to deploy a private cloud to them the file is easily copied by . Whether the container can be restricted can not be mounted or can not be copied.</Title_Description>
    <Label>question</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>2/07/2018 10:49:42 AM +00:00</CreatedAt>
    <ClosedAt>2/07/2018 7:00:39 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18739</IssueLabelID>
    <Title>CoreCLR Test Build Broken</Title>
    <Description>Opened on behalf of @RussKeldorph

Warnings: 1
Status Message: failed

Build : Master - 20180701.03 (Product Build)
Failing configurations:
- Alpine3.6
  - Build-Tests-R2R-Release
  - Build-Tests-Release
- RedHat6
  - Build-Tests-R2R-Release
  - Build-Tests-Release
- RedHat 7
  - Build-Tests-R2R-Release
  - Build-Tests-Release
- OSX
  - Build-Tests-R2R-Release
  - Build-Tests-Release
- Windows
  - Build-Tests-R2R-Release-arm64
  - Build-Tests-Release-arm64
  - Build-Tests-R2R-Release
  - Build-Tests-Release
[Mission Control Build Info](https://mc.dot.net/#/product/netcore/master/source/official~2Fcoreclr~2Fmaster~2F/type/build~2Fproduct~2F/build/20180701.03/workItem/Orchestration/analysis/external/Link)
</Description>
    <Title_Description>CoreCLR Test Build Broken Opened on behalf of @RussKeldorph

Warnings: 1
Status Message: failed

Build : Master - 20180701.03 (Product Build)
Failing configurations:
- Alpine3.6
  - Build-Tests-R2R-Release
  - Build-Tests-Release
- RedHat6
  - Build-Tests-R2R-Release
  - Build-Tests-Release
- RedHat 7
  - Build-Tests-R2R-Release
  - Build-Tests-Release
- OSX
  - Build-Tests-R2R-Release
  - Build-Tests-Release
- Windows
  - Build-Tests-R2R-Release-arm64
  - Build-Tests-Release-arm64
  - Build-Tests-R2R-Release
  - Build-Tests-Release
[Mission Control Build Info](https://mc.dot.net/#/product/netcore/master/source/official~2Fcoreclr~2Fmaster~2F/type/build~2Fproduct~2F/build/20180701.03/workItem/Orchestration/analysis/external/Link)
</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>A-And</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18732</IssueLabelID>
    <Title>Create package for Raspbian OS (ARM32)</Title>
    <Description>While there is a working binary download for dotnet (.NET Core) for ARM32 that works on a Raspberry Pi B 3+ with a current Raspbian OS there are no instructions how to install it. And there are no packages for the OS too. So it's a bit of a mystery how to actually make .NET Core work on a Raspi.

I think there should be a package for that OS. It should be as simple as that:

    sudo apt install dotnet

Maybe a custom package source needs to be added but definitely no manual tar file works. Mono was easier to install when it was current like 5 years ago.

Since the docker support on the Raspi with dotnet-runtime packages is very poor (multi-arch fails need to select arm32 image specifically can't get my app in a custom image) I need to install .NET Core on the Raspi OS itself.</Description>
    <Title_Description>Create package for Raspbian OS (ARM32) While there is a working binary download for dotnet (.NET Core) for ARM32 that works on a Raspberry Pi B 3+ with a current Raspbian OS there are no instructions how to install it. And there are no packages for the OS too. So it's a bit of a mystery how to actually make .NET Core work on a Raspi.

I think there should be a package for that OS. It should be as simple as that:

    sudo apt install dotnet

Maybe a custom package source needs to be added but definitely no manual tar file works. Mono was easier to install when it was current like 5 years ago.

Since the docker support on the Raspi with dotnet-runtime packages is very poor (multi-arch fails need to select arm32 image specifically can't get my app in a custom image) I need to install .NET Core on the Raspi OS itself.</Title_Description>
    <Label>
    </Label>
    <Assignee>richlander</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18727</IssueLabelID>
    <Title>JIT : PMI now failing on System.Private.CoreLib on an x64 AES intrinsic</Title>
    <Description>The x64 windows run of PMI over System.Private.Corelib is now failing when trying to jit `X86.Aes.Decrypt` as this method exists in metadata and is marked as an intrinsic but the jit does not recognize it. This is relatively new (~ last few days) behavior.

Would be nice to fix this by (say) adding in the names to the recognizer and then (for now) just compiling in the not supported variant.

cc @dotnet/jit-contrib </Description>
    <Title_Description>JIT : PMI now failing on System.Private.CoreLib on an x64 AES intrinsic The x64 windows run of PMI over System.Private.Corelib is now failing when trying to jit `X86.Aes.Decrypt` as this method exists in metadata and is marked as an intrinsic but the jit does not recognize it. This is relatively new (~ last few days) behavior.

Would be nice to fix this by (say) adding in the names to the recognizer and then (for now) just compiling in the not supported variant.

cc @dotnet/jit-contrib </Title_Description>
    <Label>arch-x64</Label>
    <Assignee>AndyAyersMS</Assignee>
    <CreatedAt>30/06/2018 12:11:59 AM +00:00</CreatedAt>
    <ClosedAt>2/08/2018 4:41:12 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18723</IssueLabelID>
    <Title>Failure in arm32/arm64 corefx altjit tests</Title>
    <Description>I'm seeing:
```
10:14:48 Running: D:\j\workspace\x64_arm64_alt---734a66f6\_\fx\Tools\dotnetcli\dotnet msbuild /nologo /verbosity:minimal /clp:Summary /maxcpucount /nodeReuse:false /l:BinClashLoggerTools\Microsoft.DotNet.Build.Tasks.dll;LogFile=binclash.log /p:OSGroup=Windows_NT /p:ConfigurationGroup=Release /p:ArchGroup=x64 /p:BuildPackages=false  /flp:v=normal;LogFile=build-tests.log  /flp2:warningsonly;logfile=msbuild.wrn  /flp3:errorsonly;logfile=msbuild.err  src/tests.builds /p:WithoutCategories="IgnoreForCI;XsltcExeRequired" /p:PreExecutionTestScript=D:\j\workspace\x64_arm64_alt---734a66f6\SetStressModes.bat
10:14:48 
MSBUILD : error MSB1006: Property is not valid.
10:14:48 Switch: XsltcExeRequired
10:14:48 
10:14:48 For switch syntax type "MSBuild /help"
10:14:49 Command execution failed with exit code 1.
10:14:49 
10:14:49 D:\j\workspace\x64_arm64_alt---734a66f6&gt;exit 1
```

Did something change in the corefx tools (msbuild etc.) that makes this syntax invalid now?

This syntax is constructed in coreclr: tests\scripts\run-corefx-tests.py

e.g.: https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64_arm64_altjit/job/jitstress/job/x64_arm64_altjit_checked_windows_nt_corefx_baseline/230/consoleFull#-165810470383554902-aff0-4799-9e92-0ada24ce2a06
</Description>
    <Title_Description>Failure in arm32/arm64 corefx altjit tests I'm seeing:
```
10:14:48 Running: D:\j\workspace\x64_arm64_alt---734a66f6\_\fx\Tools\dotnetcli\dotnet msbuild /nologo /verbosity:minimal /clp:Summary /maxcpucount /nodeReuse:false /l:BinClashLoggerTools\Microsoft.DotNet.Build.Tasks.dll;LogFile=binclash.log /p:OSGroup=Windows_NT /p:ConfigurationGroup=Release /p:ArchGroup=x64 /p:BuildPackages=false  /flp:v=normal;LogFile=build-tests.log  /flp2:warningsonly;logfile=msbuild.wrn  /flp3:errorsonly;logfile=msbuild.err  src/tests.builds /p:WithoutCategories="IgnoreForCI;XsltcExeRequired" /p:PreExecutionTestScript=D:\j\workspace\x64_arm64_alt---734a66f6\SetStressModes.bat
10:14:48 
MSBUILD : error MSB1006: Property is not valid.
10:14:48 Switch: XsltcExeRequired
10:14:48 
10:14:48 For switch syntax type "MSBuild /help"
10:14:49 Command execution failed with exit code 1.
10:14:49 
10:14:49 D:\j\workspace\x64_arm64_alt---734a66f6&gt;exit 1
```

Did something change in the corefx tools (msbuild etc.) that makes this syntax invalid now?

This syntax is constructed in coreclr: tests\scripts\run-corefx-tests.py

e.g.: https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64_arm64_altjit/job/jitstress/job/x64_arm64_altjit_checked_windows_nt_corefx_baseline/230/consoleFull#-165810470383554902-aff0-4799-9e92-0ada24ce2a06
</Title_Description>
    <Label>
    </Label>
    <Assignee>BruceForstall</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18722</IssueLabelID>
    <Title>reenable fixed arm64 altjit tests</Title>
    <Description>
    </Description>
    <Title_Description>reenable fixed arm64 altjit tests </Title_Description>
    <Label>disabled-test</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>29/06/2018 11:19:56 PM +00:00</CreatedAt>
    <ClosedAt>2/07/2018 5:21:37 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18721</IssueLabelID>
    <Title>SuperPMI: add ability to exclude failing method contexts from replays</Title>
    <Description>The first 3 commits are only refactoring.
The fourth adds a stub and ability to print number of excluded methods.</Description>
    <Title_Description>SuperPMI: add ability to exclude failing method contexts from replays The first 3 commits are only refactoring.
The fourth adds a stub and ability to print number of excluded methods.</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>29/06/2018 11:19:09 PM +00:00</CreatedAt>
    <ClosedAt>3/07/2018 12:32:59 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18719</IssueLabelID>
    <Title>Proposal to add classification info to area-CodeGen issues</Title>
    <Description>There are currently 652 open are-CodeGen issues. To help with triage the jit team went through the issues and compiled classification info for each issue: category theme skill-level and cost. Each issue got one tag from each of the following sets:

category: {cq correctness implementation throughput proposal reach design. documentation testing engsys usability security portability}

theme: {basic-cq register-allocator arm64 jit-coding-style testing inlining optimization benchmarks ir loop-opt vector-codegen hw-intrinsics x86 importer first-class-structs arm32 throughput jit-stress intrinsics sysV helpers bounds-checks runtime flowgraph promotion gc-stress emitter gc-info big-bets large-methods value-numbering debug-dumps ilasm assertion-prop devirtualization block-opts ref-counts profile-feedback barriers msil cse eh ildasm tail-call super-pmi div-mod-rem zero-init stack-allocation type-intrinsics structs morph span&lt;t&gt; jit-ee-interface lower md-arrays invalid-il spmi ssa block-layout alignment range-check liveness copy-prop volatile delegates web-assembly pinning interpreter generics build class-init linux}

skill-level: {beginner intermediate expert}

cost: {small medium large extra-large}

This info is currently in an excel spreadsheet and we would like to propagate it to the issues.
We think adding a label for each of the tags above would be excessive. The proposal is to append this information to the end of the issue description e.g.
```
category:correctness
theme:interpreper
skill-level:intermediate
cost:small
```
Any feedback on this plan is appreciated.

@dotnet/jit-contrib @karelz </Description>
    <Title_Description>Proposal to add classification info to area-CodeGen issues There are currently 652 open are-CodeGen issues. To help with triage the jit team went through the issues and compiled classification info for each issue: category theme skill-level and cost. Each issue got one tag from each of the following sets:

category: {cq correctness implementation throughput proposal reach design. documentation testing engsys usability security portability}

theme: {basic-cq register-allocator arm64 jit-coding-style testing inlining optimization benchmarks ir loop-opt vector-codegen hw-intrinsics x86 importer first-class-structs arm32 throughput jit-stress intrinsics sysV helpers bounds-checks runtime flowgraph promotion gc-stress emitter gc-info big-bets large-methods value-numbering debug-dumps ilasm assertion-prop devirtualization block-opts ref-counts profile-feedback barriers msil cse eh ildasm tail-call super-pmi div-mod-rem zero-init stack-allocation type-intrinsics structs morph span&lt;t&gt; jit-ee-interface lower md-arrays invalid-il spmi ssa block-layout alignment range-check liveness copy-prop volatile delegates web-assembly pinning interpreter generics build class-init linux}

skill-level: {beginner intermediate expert}

cost: {small medium large extra-large}

This info is currently in an excel spreadsheet and we would like to propagate it to the issues.
We think adding a label for each of the tags above would be excessive. The proposal is to append this information to the end of the issue description e.g.
```
category:correctness
theme:interpreper
skill-level:intermediate
cost:small
```
Any feedback on this plan is appreciated.

@dotnet/jit-contrib @karelz </Title_Description>
    <Label>Design Discussion</Label>
    <Assignee>karelz</Assignee>
    <CreatedAt>29/06/2018 8:49:01 PM +00:00</CreatedAt>
    <ClosedAt>10/08/2018 11:37:13 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18717</IssueLabelID>
    <Title>RyuJIT32 performs unnecessary round-trip through double when converting float to byte</Title>
    <Description>Given the following method

```C#
void AdjustBrightness(byte[] pixelsin byte[] pixelsout float amount)
{
    if ((uint)pixelsin.Length &gt;= (uint)pixelsout.Length)
    {
        for (int i = 0; i &lt; pixelsout.Length; i++)
            pixelsout[i] = (byte)(pixelsin[i] * amount);
    }
}
```

RyuJIT32 produces this:

```asm
07999168 AdjustBrightness(Byte[] Byte[] Single)
0799917a 8b4a04          mov     ecxdword ptr [edx+4]
0799917d 8b7004          mov     esidword ptr [eax+4]
07999180 3bce            cmp     ecxesi
07999182 7234            jb      079991b8
07999184 33ff            xor     ediedi
07999186 85f6            test    esiesi
07999188 7e2e            jle     079991b8
0799918a 3bf9            cmp     ediecx
0799918c 7331            jae     079991bf
0799918e 0fb65c3a08      movzx   ebxbyte ptr [edx+edi+8]
07999193 c4e17057c9      vxorps  xmm1xmm1xmm1
07999198 c4e1722acb      vcvtsi2ss xmm1xmm1ebx
0799919d c4e17259c8      vmulss  xmm1xmm1xmm0
079991a2 c4e1725ac9      vcvtss2sd xmm1xmm1xmm1
079991a7 c4e17b2cd9      vcvttsd2si ebxxmm1
079991ac 0fb6db          movzx   ebxbl
079991af 885c3808        mov     byte ptr [eax+edi+8]bl
079991b3 47              inc     edi
079991b4 3bf7            cmp     esiedi
079991b6 7fd2            jg      0799918a
079991b8 5b              pop     ebx
```

Note the `vcvtss2sd` followed by `vcvttsd2si`.  RyuJIT64 produces the expected code:

```asm
00007ffc`2eb52910 AdjustBrightness(Byte[] Byte[] Single)
00007ffc`2eb52917 8b4208          mov     eaxdword ptr [rdx+8]
00007ffc`2eb5291a 418b4808        mov     ecxdword ptr [r8+8]
00007ffc`2eb5291e 3bc1            cmp     eaxecx
00007ffc`2eb52920 723a            jb      00007ffc`2eb5295c
00007ffc`2eb52922 4533c9          xor     r9dr9d
00007ffc`2eb52925 85c9            test    ecxecx
00007ffc`2eb52927 7e33            jle     00007ffc`2eb5295c
00007ffc`2eb52929 443bc8          cmp     r9deax
00007ffc`2eb5292c 7333            jae     00007ffc`2eb52961
00007ffc`2eb5292e 4d63d1          movsxd  r10r9d
00007ffc`2eb52931 460fb65c1210    movzx   r11dbyte ptr [rdx+r10+10h]
00007ffc`2eb52937 c4e17857c0      vxorps  xmm0xmm0xmm0
00007ffc`2eb5293c c4c17a2ac3      vcvtsi2ss xmm0xmm0r11d
00007ffc`2eb52941 c4e17a59c3      vmulss  xmm0xmm0xmm3
00007ffc`2eb52946 c4617a2cd8      vcvttss2si r11dxmm0
00007ffc`2eb5294b 450fb6db        movzx   r11dr11b
00007ffc`2eb5294f 47885c1010      mov     byte ptr [r8+r10+10h]r11b
00007ffc`2eb52954 41ffc1          inc     r9d
00007ffc`2eb52957 413bc9          cmp     ecxr9d
00007ffc`2eb5295a 7fcd            jg      00007ffc`2eb52929
00007ffc`2eb5295c 4883c428        add     rsp28h
```

That makes for a 13% speed difference in this method.

I also just noticed the bounds check is not elided here just moved.  I can't seem to get it to elide the check.  Any ideas @mikedn?</Description>
    <Title_Description>RyuJIT32 performs unnecessary round-trip through double when converting float to byte Given the following method

```C#
void AdjustBrightness(byte[] pixelsin byte[] pixelsout float amount)
{
    if ((uint)pixelsin.Length &gt;= (uint)pixelsout.Length)
    {
        for (int i = 0; i &lt; pixelsout.Length; i++)
            pixelsout[i] = (byte)(pixelsin[i] * amount);
    }
}
```

RyuJIT32 produces this:

```asm
07999168 AdjustBrightness(Byte[] Byte[] Single)
0799917a 8b4a04          mov     ecxdword ptr [edx+4]
0799917d 8b7004          mov     esidword ptr [eax+4]
07999180 3bce            cmp     ecxesi
07999182 7234            jb      079991b8
07999184 33ff            xor     ediedi
07999186 85f6            test    esiesi
07999188 7e2e            jle     079991b8
0799918a 3bf9            cmp     ediecx
0799918c 7331            jae     079991bf
0799918e 0fb65c3a08      movzx   ebxbyte ptr [edx+edi+8]
07999193 c4e17057c9      vxorps  xmm1xmm1xmm1
07999198 c4e1722acb      vcvtsi2ss xmm1xmm1ebx
0799919d c4e17259c8      vmulss  xmm1xmm1xmm0
079991a2 c4e1725ac9      vcvtss2sd xmm1xmm1xmm1
079991a7 c4e17b2cd9      vcvttsd2si ebxxmm1
079991ac 0fb6db          movzx   ebxbl
079991af 885c3808        mov     byte ptr [eax+edi+8]bl
079991b3 47              inc     edi
079991b4 3bf7            cmp     esiedi
079991b6 7fd2            jg      0799918a
079991b8 5b              pop     ebx
```

Note the `vcvtss2sd` followed by `vcvttsd2si`.  RyuJIT64 produces the expected code:

```asm
00007ffc`2eb52910 AdjustBrightness(Byte[] Byte[] Single)
00007ffc`2eb52917 8b4208          mov     eaxdword ptr [rdx+8]
00007ffc`2eb5291a 418b4808        mov     ecxdword ptr [r8+8]
00007ffc`2eb5291e 3bc1            cmp     eaxecx
00007ffc`2eb52920 723a            jb      00007ffc`2eb5295c
00007ffc`2eb52922 4533c9          xor     r9dr9d
00007ffc`2eb52925 85c9            test    ecxecx
00007ffc`2eb52927 7e33            jle     00007ffc`2eb5295c
00007ffc`2eb52929 443bc8          cmp     r9deax
00007ffc`2eb5292c 7333            jae     00007ffc`2eb52961
00007ffc`2eb5292e 4d63d1          movsxd  r10r9d
00007ffc`2eb52931 460fb65c1210    movzx   r11dbyte ptr [rdx+r10+10h]
00007ffc`2eb52937 c4e17857c0      vxorps  xmm0xmm0xmm0
00007ffc`2eb5293c c4c17a2ac3      vcvtsi2ss xmm0xmm0r11d
00007ffc`2eb52941 c4e17a59c3      vmulss  xmm0xmm0xmm3
00007ffc`2eb52946 c4617a2cd8      vcvttss2si r11dxmm0
00007ffc`2eb5294b 450fb6db        movzx   r11dr11b
00007ffc`2eb5294f 47885c1010      mov     byte ptr [r8+r10+10h]r11b
00007ffc`2eb52954 41ffc1          inc     r9d
00007ffc`2eb52957 413bc9          cmp     ecxr9d
00007ffc`2eb5295a 7fcd            jg      00007ffc`2eb52929
00007ffc`2eb5295c 4883c428        add     rsp28h
```

That makes for a 13% speed difference in this method.

I also just noticed the bounds check is not elided here just moved.  I can't seem to get it to elide the check.  Any ideas @mikedn?</Title_Description>
    <Label>arch-x86</Label>
    <Assignee>mikedn</Assignee>
    <CreatedAt>29/06/2018 8:39:06 PM +00:00</CreatedAt>
    <ClosedAt>14/09/2018 5:47:07 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18712</IssueLabelID>
    <Title>Implement BMI1 and BMI2 intrinsics</Title>
    <Description>Pending BMI1:
- [x] AndNot
- [ ] BitFieldExtract
- [x] ExtractLowestSetBit
- [x] GetMaskUptoLowestSetBit
- [x] ResetLowestSetBit
- [x] TrailingZeroCount

Pending BMI2:
- [ ] MultiplyNoFlags
- [x] ParallelBitDeposit
- [x] ParallelBitExtract
- [ ] ZeroHighBits</Description>
    <Title_Description>Implement BMI1 and BMI2 intrinsics Pending BMI1:
- [x] AndNot
- [ ] BitFieldExtract
- [x] ExtractLowestSetBit
- [x] GetMaskUptoLowestSetBit
- [x] ResetLowestSetBit
- [x] TrailingZeroCount

Pending BMI2:
- [ ] MultiplyNoFlags
- [x] ParallelBitDeposit
- [x] ParallelBitExtract
- [ ] ZeroHighBits</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>tannergooding</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18710</IssueLabelID>
    <Title>Strange codegen with structure fields accesses</Title>
    <Description>The C# repro code below shows non-uniformity in .NET Core 2.1 JIT behavior regarding (de)optimization of memory accesses having potential side effects. In short test methods attempt to access all three fields of the structure instance of which only two first values are used.

```
[StructLayout(LayoutKind.Sequential)]
struct VT
{
    public static readonly int Size = Marshal.SizeOf&lt;VT&gt;();

    public int F1 F2 F3;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Get(out int v1 out int v2 out int v3)
    {
        v1 = F1;
        v2 = F2;
        v3 = F3;
    }
}

[MethodImpl(MethodImplOptions.NoInlining)]
static void TestMethodInlining(VT* pVT)
{
    int v1 v2 v3;
    pVT-&gt;Get(out v1 out v2 out v3);
    Do(v1 v2);
}

[MethodImpl(MethodImplOptions.NoInlining)]
static void TestByRef(ref VT VTRef)
{
    int v1 v2 v3;
    v1 = VTRef.F1;
    v2 = VTRef.F2;
    v3 = VTRef.F3;
    Do(v1 v2);
}

[MethodImpl(MethodImplOptions.NoInlining)]
static void TestByPtr(VT* pVT)
{
    int v1 v2 v3;
    v1 = pVT-&gt;F1;
    v2 = pVT-&gt;F2;
    v3 = pVT-&gt;F3;
    Do(v1 v2);
}

static void Main(string[] args)
{
    byte* pDataBytes = stackalloc byte[VT.Size];
    VT* pVT = (VT*)pDataBytes;
    pVT-&gt;F1 = 1;
    pVT-&gt;F2 = 2;
    pVT-&gt;F3 = 3;

    TestMethodInlining(pVT);
    TestByRef(ref *pVT);
    TestByPtr(pVT);
}

[MethodImpl(MethodImplOptions.NoInlining)]
static void Do(int v1 int v2)
{
    Console.WriteLine("v1={0} v2={1}" v1 v2);
}
```

Disasm listings follow
------------------------------------------
**`TestMethodInlining()`**
Accesses all three fields. Access to 3rd field is still there even when `out v3` is replaced with `out _` . A side question - is it mandatory to adjust RSP anyhow for such methods?
```
--- Program2.cs ---
    pVT-&gt;Get(out v1 out v2 out v3);
000007FE78721590  sub         rsp28h  
000007FE78721594  mov         edxdword ptr [rcx]  
000007FE78721596  mov         eaxdword ptr [rcx+4]  
000007FE78721599  mov         ecxdword ptr [rcx+8]  
    Do(v1 v2);
000007FE7872159C  mov         ecxedx  
000007FE7872159E  mov         edxeax  
000007FE787215A0  call        000007FE78721040  
000007FE787215A5  nop  
000007FE787215A6  add         rsp28h  
000007FE787215AA  ret  
--- No source file -------------------------------------------------------------
```

------------------------------------------
**`TestByRef()`**
Access to the 3rd field is dropped. This looks strange to me since the side effects are supposedly the same as in previous case. Also field access is generated if I wrap it with `Volatile.Read(ref VTRef.F3)`. Also the same question regarding RSP as in previous case.
```
--- Program2.cs ---
    v1 = VTRef.F1;
000007FE78722AE0  sub         rsp28h  
000007FE78722AE4  mov         edxdword ptr [rcx]  
000007FE78722AE6  mov         eaxdword ptr [rcx+4]  
000007FE78722AE9  mov         ecxedx  
000007FE78722AEB  mov         edxeax  
000007FE78722AED  call        000007FE787215C0  
000007FE78722AF2  nop  
000007FE78722AF3  add         rsp28h  
000007FE78722AF7  ret  
--- No source file -------------------------------------------------------------
```

------------------------------------------
**`TestByPtr()`**
Quite a mess! First two fields are accessed and copied to EDX + EAX like in case 2 (and unlike in case 1). And then it looks like entire structure is copied on stack for the reason quite obscure. [I believe I've seen other cases when the structure passed as method arg with **ref/in** modifiers is copied but this could be separate issue]
```
--- Program2.cs ---
    v1 = pVT-&gt;F1;
000007FE78712B10  sub         rsp38h  
000007FE78712B14  mov         edxdword ptr [rcx]  
000007FE78712B16  mov         eaxdword ptr [rcx+4]  
000007FE78712B19  mov         r8ddword ptr [rcx]  
000007FE78712B1C  mov         dword ptr [rsp+28h]r8d  
000007FE78712B21  mov         r8ddword ptr [rcx+4]  
000007FE78712B25  mov         dword ptr [rsp+2Ch]r8d  
000007FE78712B2A  mov         ecxdword ptr [rcx+8]  
000007FE78712B2D  mov         dword ptr [rsp+30h]ecx  
000007FE78712B31  mov         ecxedx  
000007FE78712B33  mov         edxeax  
000007FE78712B35  call        000007FE787115C0  
000007FE78712B3A  nop  
000007FE78712B3B  add         rsp38h  
000007FE78712B3F  ret  
--- No source file -------------------------------------------------------------
```

-----------------------------------------

One observation is that JIT produces the same code for all three methods when I add `volatile` modifier to all three fields.</Description>
    <Title_Description>Strange codegen with structure fields accesses The C# repro code below shows non-uniformity in .NET Core 2.1 JIT behavior regarding (de)optimization of memory accesses having potential side effects. In short test methods attempt to access all three fields of the structure instance of which only two first values are used.

```
[StructLayout(LayoutKind.Sequential)]
struct VT
{
    public static readonly int Size = Marshal.SizeOf&lt;VT&gt;();

    public int F1 F2 F3;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Get(out int v1 out int v2 out int v3)
    {
        v1 = F1;
        v2 = F2;
        v3 = F3;
    }
}

[MethodImpl(MethodImplOptions.NoInlining)]
static void TestMethodInlining(VT* pVT)
{
    int v1 v2 v3;
    pVT-&gt;Get(out v1 out v2 out v3);
    Do(v1 v2);
}

[MethodImpl(MethodImplOptions.NoInlining)]
static void TestByRef(ref VT VTRef)
{
    int v1 v2 v3;
    v1 = VTRef.F1;
    v2 = VTRef.F2;
    v3 = VTRef.F3;
    Do(v1 v2);
}

[MethodImpl(MethodImplOptions.NoInlining)]
static void TestByPtr(VT* pVT)
{
    int v1 v2 v3;
    v1 = pVT-&gt;F1;
    v2 = pVT-&gt;F2;
    v3 = pVT-&gt;F3;
    Do(v1 v2);
}

static void Main(string[] args)
{
    byte* pDataBytes = stackalloc byte[VT.Size];
    VT* pVT = (VT*)pDataBytes;
    pVT-&gt;F1 = 1;
    pVT-&gt;F2 = 2;
    pVT-&gt;F3 = 3;

    TestMethodInlining(pVT);
    TestByRef(ref *pVT);
    TestByPtr(pVT);
}

[MethodImpl(MethodImplOptions.NoInlining)]
static void Do(int v1 int v2)
{
    Console.WriteLine("v1={0} v2={1}" v1 v2);
}
```

Disasm listings follow
------------------------------------------
**`TestMethodInlining()`**
Accesses all three fields. Access to 3rd field is still there even when `out v3` is replaced with `out _` . A side question - is it mandatory to adjust RSP anyhow for such methods?
```
--- Program2.cs ---
    pVT-&gt;Get(out v1 out v2 out v3);
000007FE78721590  sub         rsp28h  
000007FE78721594  mov         edxdword ptr [rcx]  
000007FE78721596  mov         eaxdword ptr [rcx+4]  
000007FE78721599  mov         ecxdword ptr [rcx+8]  
    Do(v1 v2);
000007FE7872159C  mov         ecxedx  
000007FE7872159E  mov         edxeax  
000007FE787215A0  call        000007FE78721040  
000007FE787215A5  nop  
000007FE787215A6  add         rsp28h  
000007FE787215AA  ret  
--- No source file -------------------------------------------------------------
```

------------------------------------------
**`TestByRef()`**
Access to the 3rd field is dropped. This looks strange to me since the side effects are supposedly the same as in previous case. Also field access is generated if I wrap it with `Volatile.Read(ref VTRef.F3)`. Also the same question regarding RSP as in previous case.
```
--- Program2.cs ---
    v1 = VTRef.F1;
000007FE78722AE0  sub         rsp28h  
000007FE78722AE4  mov         edxdword ptr [rcx]  
000007FE78722AE6  mov         eaxdword ptr [rcx+4]  
000007FE78722AE9  mov         ecxedx  
000007FE78722AEB  mov         edxeax  
000007FE78722AED  call        000007FE787215C0  
000007FE78722AF2  nop  
000007FE78722AF3  add         rsp28h  
000007FE78722AF7  ret  
--- No source file -------------------------------------------------------------
```

------------------------------------------
**`TestByPtr()`**
Quite a mess! First two fields are accessed and copied to EDX + EAX like in case 2 (and unlike in case 1). And then it looks like entire structure is copied on stack for the reason quite obscure. [I believe I've seen other cases when the structure passed as method arg with **ref/in** modifiers is copied but this could be separate issue]
```
--- Program2.cs ---
    v1 = pVT-&gt;F1;
000007FE78712B10  sub         rsp38h  
000007FE78712B14  mov         edxdword ptr [rcx]  
000007FE78712B16  mov         eaxdword ptr [rcx+4]  
000007FE78712B19  mov         r8ddword ptr [rcx]  
000007FE78712B1C  mov         dword ptr [rsp+28h]r8d  
000007FE78712B21  mov         r8ddword ptr [rcx+4]  
000007FE78712B25  mov         dword ptr [rsp+2Ch]r8d  
000007FE78712B2A  mov         ecxdword ptr [rcx+8]  
000007FE78712B2D  mov         dword ptr [rsp+30h]ecx  
000007FE78712B31  mov         ecxedx  
000007FE78712B33  mov         edxeax  
000007FE78712B35  call        000007FE787115C0  
000007FE78712B3A  nop  
000007FE78712B3B  add         rsp38h  
000007FE78712B3F  ret  
--- No source file -------------------------------------------------------------
```

-----------------------------------------

One observation is that JIT produces the same code for all three methods when I add `volatile` modifier to all three fields.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>erozenfeld</Assignee>
    <CreatedAt>29/06/2018 11:53:34 AM +00:00</CreatedAt>
    <ClosedAt>13/07/2018 8:21:28 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18709</IssueLabelID>
    <Title>Issue with large arrays</Title>
    <Description>Have some Machine Learning code which works on .NET and allocates a large array double[6553665536].
To make this working I had to enable gcAllowVeryLargeObjects .

How to do the same in .NET Core?

Right now getting following exception:
System.OutOfMemoryException: 'Array dimensions exceeded supported range.'

Thanks</Description>
    <Title_Description>Issue with large arrays Have some Machine Learning code which works on .NET and allocates a large array double[6553665536].
To make this working I had to enable gcAllowVeryLargeObjects .

How to do the same in .NET Core?

Right now getting following exception:
System.OutOfMemoryException: 'Array dimensions exceeded supported range.'

Thanks</Title_Description>
    <Label>area-GC</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>29/06/2018 10:36:08 AM +00:00</CreatedAt>
    <ClosedAt>1/02/2019 2:40:21 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18705</IssueLabelID>
    <Title>Huge slowdowns on threaded operations when debugger attached (macOS)</Title>
    <Description>When debugging our application (with attached debugger no breakpoints) performance can drop to a point it becomes frustrating to do anything. On occasion we are also seeing OS level hard locking for seconds to minutes which *may* be related.

Reproducible in both VSCode and Jetbrains Rider. This is exclusive to netcore (2.0 and 2.1) – does not occur under mono or net471 runtime environments. It also seems limited to macOS as I have not been able to reproduce on windows.

This can easily be reproduced on our game framework project: https://github.com/ppy/osu-framework (building should require not extra steps beyond checking it out).

- Start in `VisualTests` configuration
- Switch to `DelayedLoad` in the left menu
- Observe severe frame drops when threaded load events occur

Testing with debugger attached should drop to less than 1fps while it is easy to maintain hundreds without a debugger attached.

It seems to be directly related to creation of threads specifically with the `TaskCreationOptions.LongRunning` flag. On removing this flag from hot paths ([#1](https://github.com/ppy/osu-framework/blob/2fb9404792f0d7c39bed1272419e53683d6cb747/osu.Framework/IO/Network/WebRequest.cs#L229) [#2](https://github.com/ppy/osu-framework/blob/5a4bbc322d7d7e334fc1056550d2e3943b24e9c9/osu.Framework/Graphics/Drawable.cs#L145)) performance will return to normal.

I've been trying to reproduce this with a more isolated test case but have not succeeded yet. Some pointers on moving forward in diagnosing this issue would be appreciated!

</Description>
    <Title_Description>Huge slowdowns on threaded operations when debugger attached (macOS) When debugging our application (with attached debugger no breakpoints) performance can drop to a point it becomes frustrating to do anything. On occasion we are also seeing OS level hard locking for seconds to minutes which *may* be related.

Reproducible in both VSCode and Jetbrains Rider. This is exclusive to netcore (2.0 and 2.1) – does not occur under mono or net471 runtime environments. It also seems limited to macOS as I have not been able to reproduce on windows.

This can easily be reproduced on our game framework project: https://github.com/ppy/osu-framework (building should require not extra steps beyond checking it out).

- Start in `VisualTests` configuration
- Switch to `DelayedLoad` in the left menu
- Observe severe frame drops when threaded load events occur

Testing with debugger attached should drop to less than 1fps while it is easy to maintain hundreds without a debugger attached.

It seems to be directly related to creation of threads specifically with the `TaskCreationOptions.LongRunning` flag. On removing this flag from hot paths ([#1](https://github.com/ppy/osu-framework/blob/2fb9404792f0d7c39bed1272419e53683d6cb747/osu.Framework/IO/Network/WebRequest.cs#L229) [#2](https://github.com/ppy/osu-framework/blob/5a4bbc322d7d7e334fc1056550d2e3943b24e9c9/osu.Framework/Graphics/Drawable.cs#L145)) performance will return to normal.

I've been trying to reproduce this with a more isolated test case but have not succeeded yet. Some pointers on moving forward in diagnosing this issue would be appreciated!

</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>mikem8361</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18704</IssueLabelID>
    <Title>System.Net.Primitives.Functional.Tests Failures</Title>
    <Description>The following tests fail in System.Net.Primitives.Functional.Tests with an EntryPointNotFoundException
```
    CookieCollectionTest.Clear_Success
    CookieCollectionTest.Remove_Success
    CookieCollectionTest.Contains_Success
    CookieCollectionTest.Remove_NonExistantCookie_ReturnsFalse
```

### To reproduce failing 

1. `build x64 [release/debug] skiptests`
2. `.\build-test.cmd x64 [release/debug] buildtesthostonly`
3. Navigate to `&lt;repo-root&gt;\bin\tests\&lt;Configuration&gt;\CoreFX\tests_downloaded\System.Net.Primitives.Functional.Tests`
4. Run `&lt;repo-root&gt;\bin\tests\&lt;Configuration&gt;\testhost\dotnet.exe .\xunit.console.netcore.exe .\System.Net.Primitives.Functional.Tests.dll -method [name of method to debug] `


</Description>
    <Title_Description>System.Net.Primitives.Functional.Tests Failures The following tests fail in System.Net.Primitives.Functional.Tests with an EntryPointNotFoundException
```
    CookieCollectionTest.Clear_Success
    CookieCollectionTest.Remove_Success
    CookieCollectionTest.Contains_Success
    CookieCollectionTest.Remove_NonExistantCookie_ReturnsFalse
```

### To reproduce failing 

1. `build x64 [release/debug] skiptests`
2. `.\build-test.cmd x64 [release/debug] buildtesthostonly`
3. Navigate to `&lt;repo-root&gt;\bin\tests\&lt;Configuration&gt;\CoreFX\tests_downloaded\System.Net.Primitives.Functional.Tests`
4. Run `&lt;repo-root&gt;\bin\tests\&lt;Configuration&gt;\testhost\dotnet.exe .\xunit.console.netcore.exe .\System.Net.Primitives.Functional.Tests.dll -method [name of method to debug] `


</Title_Description>
    <Label>arch-x64</Label>
    <Assignee>A-And</Assignee>
    <CreatedAt>29/06/2018 1:04:55 AM +00:00</CreatedAt>
    <ClosedAt>3/07/2018 4:35:01 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18703</IssueLabelID>
    <Title>System.Net.Http.Functional.Tests Failures</Title>
    <Description>Three "*Uppercased" tests fail in System.Net.Http.Functional.Tests
Test:
    SocketsHttpHandler_HttpProtocolTests_Dribble.CustomMethod_SentUppercasedIfKnown
Error:
    Xunit.Sdk.StartsWithException Assert.StartsWith() Failure:\\r\\nExpected: GET \\r\\nActual:   get ..

Test:
    SocketsHttpHandler_HttpProtocolTests.CustomMethod_SentUppercasedIfKnown_Additional
Error:
    Xunit.Sdk.StartsWithException Assert.StartsWith() Failure:\\r\\nExpected: DELETE \\r\\nActual:   delete ...

Test:
    SocketsHttpHandler_HttpProtocolTests.CustomMethod_SentUppercasedIfKnown
Error:
    Xunit.Sdk.StartsWithException Assert.StartsWith() Failure:\\r\\nExpected: GET \\r\\nActual:   get ...


### To reproduce failing 

1. `build x64 [release/debug] skiptests`
2. `.\build-test.cmd x64 [release/debug] buildtesthostonly`
3. Navigate to `&lt;repo-root&gt;\bin\tests\&lt;Configuration&gt;\CoreFX\tests_downloaded\System.Net.Http.Functional.Tests`
4. Run `&lt;repo-root&gt;\bin\tests\&lt;Configuration&gt;\testhost\dotnet.exe .\xunit.console.netcore.exe .\System.Net.Http.Functional.Tests.dll -method [name of method to debug] `
</Description>
    <Title_Description>System.Net.Http.Functional.Tests Failures Three "*Uppercased" tests fail in System.Net.Http.Functional.Tests
Test:
    SocketsHttpHandler_HttpProtocolTests_Dribble.CustomMethod_SentUppercasedIfKnown
Error:
    Xunit.Sdk.StartsWithException Assert.StartsWith() Failure:\\r\\nExpected: GET \\r\\nActual:   get ..

Test:
    SocketsHttpHandler_HttpProtocolTests.CustomMethod_SentUppercasedIfKnown_Additional
Error:
    Xunit.Sdk.StartsWithException Assert.StartsWith() Failure:\\r\\nExpected: DELETE \\r\\nActual:   delete ...

Test:
    SocketsHttpHandler_HttpProtocolTests.CustomMethod_SentUppercasedIfKnown
Error:
    Xunit.Sdk.StartsWithException Assert.StartsWith() Failure:\\r\\nExpected: GET \\r\\nActual:   get ...


### To reproduce failing 

1. `build x64 [release/debug] skiptests`
2. `.\build-test.cmd x64 [release/debug] buildtesthostonly`
3. Navigate to `&lt;repo-root&gt;\bin\tests\&lt;Configuration&gt;\CoreFX\tests_downloaded\System.Net.Http.Functional.Tests`
4. Run `&lt;repo-root&gt;\bin\tests\&lt;Configuration&gt;\testhost\dotnet.exe .\xunit.console.netcore.exe .\System.Net.Http.Functional.Tests.dll -method [name of method to debug] `
</Title_Description>
    <Label>arch-x64</Label>
    <Assignee>A-And</Assignee>
    <CreatedAt>29/06/2018 12:56:08 AM +00:00</CreatedAt>
    <ClosedAt>3/07/2018 4:35:24 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18702</IssueLabelID>
    <Title>System.Linq.Expressions.Tests Failures</Title>
    <Description>Multiple tests in Linq.Expressions.Tests fail. 

With all of the below only some elements in the collections don't pass the test.

```

GroupJoinTests.GroupJoin_CustomComparator_LeftWithOrderingColisions

GroupJoinTests.GroupJoin_Multiple_LeftWithOrderingColisions

GroupJoinTests.GroupJoin_CustomComparator

GroupJoinTests.GroupJoin_Multiple

JoinTests.Join_CustomComparator_LeftWithOrderingColisions_UnorderedRight

JoinTests.Join_CustomComparator

JoinTests.Join_Multiple_LeftWithOrderingColisions_UnorderedRight

JoinTests.Join_CustomComparator_LeftWithOrderingColisions

JoinTests.Join_Multiple_LeftWithOrderingColisions

```

The `LeftWithOrderingCollisions` `CustomComparator` and `GroupJoin` patterns seem to stand out.

### To reproduce failing 

1. `build x64 [release/debug] skiptests`
2. `.\build-test.cmd x64 [release/debug] buildtesthostonly`
3. Navigate to `&lt;repo-root&gt;\bin\tests\&lt;Configuration&gt;\CoreFX\tests_downloaded\System.Linq.Expressions.Tests`
4. Run `&lt;repo-root&gt;\bin\tests\&lt;Configuration&gt;\testhost\dotnet.exe .\xunit.console.netcore.exe .\System.Linq.Expressions.Tests.dll -method [name of method to debug] `</Description>
    <Title_Description>System.Linq.Expressions.Tests Failures Multiple tests in Linq.Expressions.Tests fail. 

With all of the below only some elements in the collections don't pass the test.

```

GroupJoinTests.GroupJoin_CustomComparator_LeftWithOrderingColisions

GroupJoinTests.GroupJoin_Multiple_LeftWithOrderingColisions

GroupJoinTests.GroupJoin_CustomComparator

GroupJoinTests.GroupJoin_Multiple

JoinTests.Join_CustomComparator_LeftWithOrderingColisions_UnorderedRight

JoinTests.Join_CustomComparator

JoinTests.Join_Multiple_LeftWithOrderingColisions_UnorderedRight

JoinTests.Join_CustomComparator_LeftWithOrderingColisions

JoinTests.Join_Multiple_LeftWithOrderingColisions

```

The `LeftWithOrderingCollisions` `CustomComparator` and `GroupJoin` patterns seem to stand out.

### To reproduce failing 

1. `build x64 [release/debug] skiptests`
2. `.\build-test.cmd x64 [release/debug] buildtesthostonly`
3. Navigate to `&lt;repo-root&gt;\bin\tests\&lt;Configuration&gt;\CoreFX\tests_downloaded\System.Linq.Expressions.Tests`
4. Run `&lt;repo-root&gt;\bin\tests\&lt;Configuration&gt;\testhost\dotnet.exe .\xunit.console.netcore.exe .\System.Linq.Expressions.Tests.dll -method [name of method to debug] `</Title_Description>
    <Label>arch-x64</Label>
    <Assignee>A-And</Assignee>
    <CreatedAt>29/06/2018 12:53:14 AM +00:00</CreatedAt>
    <ClosedAt>3/07/2018 4:35:34 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18701</IssueLabelID>
    <Title>System.Security.Principal.Tests Failure</Title>
    <Description>The following error is hit when running System.Security.Principal.Tests - this also crashes the .NET Core Host running the XUnit runner. 
There is a substantial number of tests which fail with `ObjectDisposedException`
```

Test:
Error:
    System.ObjectDisposedException: Safe handle has been closed
       at System.Runtime.InteropServices.SafeHandle.DangerousAddRef(Boolean&amp; success)
       at System.StubHelpers.StubHelpers.SafeHandleAddRef(SafeHandle pHandle Boolean&amp; success)
       at Interop.Advapi32.ImpersonateLoggedOnUser(SafeAccessTokenHandle userToken)
       at System.Security.Principal.WindowsIdentity.CurrentImpersonatedTokenChanged(AsyncLocalValueChangedArgs`1 args)
       at System.Threading.AsyncLocal`1.System.Threading.IAsyncLocal.OnValueChanged(Object previousValueObj Object currentValueObj Boolean contextChanged)
       at System.Threading.ExecutionContext.OnValuesChanged(ExecutionContext previousExecutionCtx ExecutionContext nextExecutionCtx)
```

### To reproduce failing 

1. `build x64 [release/debug] skiptests`
2. `.\build-test.cmd x64 [release/debug] buildtesthostonly`
3. Navigate to `&lt;repo-root&gt;\bin\tests\&lt;Configuration&gt;\CoreFX\tests_downloaded\System.Security.Principal.Tests`
4. Run `&lt;repo-root&gt;\bin\tests\&lt;Configuration&gt;\testhost\dotnet.exe .\xunit.console.netcore.exe .\System.Security.Principal.Tests.dll `</Description>
    <Title_Description>System.Security.Principal.Tests Failure The following error is hit when running System.Security.Principal.Tests - this also crashes the .NET Core Host running the XUnit runner. 
There is a substantial number of tests which fail with `ObjectDisposedException`
```

Test:
Error:
    System.ObjectDisposedException: Safe handle has been closed
       at System.Runtime.InteropServices.SafeHandle.DangerousAddRef(Boolean&amp; success)
       at System.StubHelpers.StubHelpers.SafeHandleAddRef(SafeHandle pHandle Boolean&amp; success)
       at Interop.Advapi32.ImpersonateLoggedOnUser(SafeAccessTokenHandle userToken)
       at System.Security.Principal.WindowsIdentity.CurrentImpersonatedTokenChanged(AsyncLocalValueChangedArgs`1 args)
       at System.Threading.AsyncLocal`1.System.Threading.IAsyncLocal.OnValueChanged(Object previousValueObj Object currentValueObj Boolean contextChanged)
       at System.Threading.ExecutionContext.OnValuesChanged(ExecutionContext previousExecutionCtx ExecutionContext nextExecutionCtx)
```

### To reproduce failing 

1. `build x64 [release/debug] skiptests`
2. `.\build-test.cmd x64 [release/debug] buildtesthostonly`
3. Navigate to `&lt;repo-root&gt;\bin\tests\&lt;Configuration&gt;\CoreFX\tests_downloaded\System.Security.Principal.Tests`
4. Run `&lt;repo-root&gt;\bin\tests\&lt;Configuration&gt;\testhost\dotnet.exe .\xunit.console.netcore.exe .\System.Security.Principal.Tests.dll `</Title_Description>
    <Label>arch-x64</Label>
    <Assignee>A-And</Assignee>
    <CreatedAt>29/06/2018 12:49:35 AM +00:00</CreatedAt>
    <ClosedAt>3/07/2018 4:35:42 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18700</IssueLabelID>
    <Title>System.Linq.Expressions.Tests TypeLoadException in System.Private.CoreLib</Title>
    <Description>A TypeLoadException is hit when running System.Linq.Expressions.
```
Test:
    GetDelegateTypeTests.CantBeFunc
Result:
    System.TypeLoadException System.TypeLoadException : The generic type 'System.Func`1' was used with an invalid instantiation in assembly 'System.Private.CoreLib Version=4.0.0.0 Culture=neutral PublicKeyToken=7cec85d7bea7798e'.

Test:
    GetDelegateTypeTests.CantBeAction
Result:
    System.TypeLoadException System.TypeLoadException: The generic type 'System.Action`1' was used with an invalid instantiation in assembly 'System.Private.CoreLib Version=4.0.0.0 Culture=neutral PublicKeyToken=7cec85d7bea7798e'
```


### To reproduce failing 

1. `build x64 [release/debug] skiptests`
2. `.\build-test.cmd x64 [release/debug] buildtesthostonly`
3. Navigate to `&lt;repo-root&gt;\bin\tests\&lt;Configuration&gt;\CoreFX\tests_downloaded\System.Linq.Expressions.Tests`
4. Run `&lt;repo-root&gt;\bin\tests\&lt;Configuration&gt;\testhost\dotnet.exe .\xunit.console.netcore.exe .\System.Linq.Expressions.Tests -method [name of method to debug] `</Description>
    <Title_Description>System.Linq.Expressions.Tests TypeLoadException in System.Private.CoreLib A TypeLoadException is hit when running System.Linq.Expressions.
```
Test:
    GetDelegateTypeTests.CantBeFunc
Result:
    System.TypeLoadException System.TypeLoadException : The generic type 'System.Func`1' was used with an invalid instantiation in assembly 'System.Private.CoreLib Version=4.0.0.0 Culture=neutral PublicKeyToken=7cec85d7bea7798e'.

Test:
    GetDelegateTypeTests.CantBeAction
Result:
    System.TypeLoadException System.TypeLoadException: The generic type 'System.Action`1' was used with an invalid instantiation in assembly 'System.Private.CoreLib Version=4.0.0.0 Culture=neutral PublicKeyToken=7cec85d7bea7798e'
```


### To reproduce failing 

1. `build x64 [release/debug] skiptests`
2. `.\build-test.cmd x64 [release/debug] buildtesthostonly`
3. Navigate to `&lt;repo-root&gt;\bin\tests\&lt;Configuration&gt;\CoreFX\tests_downloaded\System.Linq.Expressions.Tests`
4. Run `&lt;repo-root&gt;\bin\tests\&lt;Configuration&gt;\testhost\dotnet.exe .\xunit.console.netcore.exe .\System.Linq.Expressions.Tests -method [name of method to debug] `</Title_Description>
    <Label>arch-x64</Label>
    <Assignee>A-And</Assignee>
    <CreatedAt>29/06/2018 12:47:40 AM +00:00</CreatedAt>
    <ClosedAt>3/07/2018 4:35:11 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18699</IssueLabelID>
    <Title>System.Drawing.Common.Tests Failures</Title>
    <Description>Some System.Drawing tests are failing with invalid Enum values. The disabled tests failing from the same cause are 

```
Test:
    GraphicsTests.InterpolationMode_SetInvalid_ThrowsInvalidEnumArgumentException`
Error:
    Expected: typeof(System.ComponentModel.InvalidEnumArgumentException)
    Actual:   typeof(System.ComponentModel.InvalidEnumArgumentException): The value of argument 'value' (-2) is invalid for Enum type 'InterpolationMode'.

Test:
    `GraphicsTests.CompositingQuality_SetInvalid_ThrowsInvalidEnumArgumentException`
Error:
    Expected: typeof(System.ComponentModel.InvalidEnumArgumentException)
    Actual:   typeof(System.ComponentModel.InvalidEnumArgumentException): The value of argument 'value' (-2) is invalid for Enum type 'CompositingQuality'.

Test:
    `GraphicsTests.PixelOffsetMode_SetInvalid_ThrowsInvalidEnumArgumentException`
Error:
    Expected: typeof(System.ComponentModel.InvalidEnumArgumentException)
    Actual:   typeof(System.ComponentModel.InvalidEnumArgumentException): The value of argument 'value' (-2) is invalid for Enum type 'PixelOffsetM

Test:
    `GraphicsTests.PageUnit_SetInvalid_ThrowsInvalidEnumArgumentException`
Error:
    Expected: typeof(System.ComponentModel.InvalidEnumArgumentException)
    Actual:   typeof(System.ComponentModel.InvalidEnumArgumentException): The value of argument 'value' (-1) is invalid for Enum type 'GraphicsUnit'

Test:
    `GraphicsTests.SmoothingMode_SetInvalid_ThrowsInvalidEnumArgumentException`
Error:
    Expected: typeof(System.ComponentModel.InvalidEnumArgumentException)
    Actual:   typeof(System.ComponentModel.InvalidEnumArgumentException): The value of argument 'value' (-2) is invalid for Enum type 'SmoothingMode'

Test:
    `GraphicsTests.CompositingMode_SetInvalid_ThrowsInvalidEnumArgumentException`
Error:
    Expected: typeof(System.ComponentModel.InvalidEnumArgumentException)
    Actual:   typeof(System.ComponentModel.InvalidEnumArgumentException): The value of argument 'value' (-1) is invalid for Enum type 'CompositingMode'

Test:
    `GraphicsTests.TextRenderingHint_SetInvalid_ThrowsInvalidEnumArgumentException`
Error:
    Expected: typeof(System.ComponentModel.InvalidEnumArgumentException)
    Actual:   typeof(System.ComponentModel.InvalidEnumArgumentException): The value of argument 'value' (-1) is invalid for Enum type 'TextRenderingHint'

### To reproduce failing 

1. `build x64 [release/debug] skiptests`
2. `.\build-test.cmd x64 [release/debug] buildtesthostonly `
3. Navigate to `&lt;repo-root&gt;\bin\tests\&lt;Configuration&gt;\CoreFX\tests_downloaded\System.Drawing.Common.Tests.dll`
4. Run `&lt;repo-root&gt;\bin\tests\&lt;Configuration&gt;\testhost\dotnet.exe .\xunit.console.netcore.exe .\System.Drawing.Common.Tests.dll -method [name of method to debug] `</Description>
    <Title_Description>System.Drawing.Common.Tests Failures Some System.Drawing tests are failing with invalid Enum values. The disabled tests failing from the same cause are 

```
Test:
    GraphicsTests.InterpolationMode_SetInvalid_ThrowsInvalidEnumArgumentException`
Error:
    Expected: typeof(System.ComponentModel.InvalidEnumArgumentException)
    Actual:   typeof(System.ComponentModel.InvalidEnumArgumentException): The value of argument 'value' (-2) is invalid for Enum type 'InterpolationMode'.

Test:
    `GraphicsTests.CompositingQuality_SetInvalid_ThrowsInvalidEnumArgumentException`
Error:
    Expected: typeof(System.ComponentModel.InvalidEnumArgumentException)
    Actual:   typeof(System.ComponentModel.InvalidEnumArgumentException): The value of argument 'value' (-2) is invalid for Enum type 'CompositingQuality'.

Test:
    `GraphicsTests.PixelOffsetMode_SetInvalid_ThrowsInvalidEnumArgumentException`
Error:
    Expected: typeof(System.ComponentModel.InvalidEnumArgumentException)
    Actual:   typeof(System.ComponentModel.InvalidEnumArgumentException): The value of argument 'value' (-2) is invalid for Enum type 'PixelOffsetM

Test:
    `GraphicsTests.PageUnit_SetInvalid_ThrowsInvalidEnumArgumentException`
Error:
    Expected: typeof(System.ComponentModel.InvalidEnumArgumentException)
    Actual:   typeof(System.ComponentModel.InvalidEnumArgumentException): The value of argument 'value' (-1) is invalid for Enum type 'GraphicsUnit'

Test:
    `GraphicsTests.SmoothingMode_SetInvalid_ThrowsInvalidEnumArgumentException`
Error:
    Expected: typeof(System.ComponentModel.InvalidEnumArgumentException)
    Actual:   typeof(System.ComponentModel.InvalidEnumArgumentException): The value of argument 'value' (-2) is invalid for Enum type 'SmoothingMode'

Test:
    `GraphicsTests.CompositingMode_SetInvalid_ThrowsInvalidEnumArgumentException`
Error:
    Expected: typeof(System.ComponentModel.InvalidEnumArgumentException)
    Actual:   typeof(System.ComponentModel.InvalidEnumArgumentException): The value of argument 'value' (-1) is invalid for Enum type 'CompositingMode'

Test:
    `GraphicsTests.TextRenderingHint_SetInvalid_ThrowsInvalidEnumArgumentException`
Error:
    Expected: typeof(System.ComponentModel.InvalidEnumArgumentException)
    Actual:   typeof(System.ComponentModel.InvalidEnumArgumentException): The value of argument 'value' (-1) is invalid for Enum type 'TextRenderingHint'

### To reproduce failing 

1. `build x64 [release/debug] skiptests`
2. `.\build-test.cmd x64 [release/debug] buildtesthostonly `
3. Navigate to `&lt;repo-root&gt;\bin\tests\&lt;Configuration&gt;\CoreFX\tests_downloaded\System.Drawing.Common.Tests.dll`
4. Run `&lt;repo-root&gt;\bin\tests\&lt;Configuration&gt;\testhost\dotnet.exe .\xunit.console.netcore.exe .\System.Drawing.Common.Tests.dll -method [name of method to debug] `</Title_Description>
    <Label>arch-x64</Label>
    <Assignee>A-And</Assignee>
    <CreatedAt>29/06/2018 12:45:36 AM +00:00</CreatedAt>
    <ClosedAt>23/05/2019 9:38:41 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18698</IssueLabelID>
    <Title>Change CancellationTokenRegistration.Unregister visibility from internal to public</Title>
    <Description>Add a CancellationTokenRegistrationSupport to access CancellationTokenRegistration.Unregister(0 method.

After https://github.com/dotnet/corefx/issues/14903 is fixed  We can remove this public implementation

Corefx repro: https://github.com/dotnet/corefx/pull/30745</Description>
    <Title_Description>Change CancellationTokenRegistration.Unregister visibility from internal to public Add a CancellationTokenRegistrationSupport to access CancellationTokenRegistration.Unregister(0 method.

After https://github.com/dotnet/corefx/issues/14903 is fixed  We can remove this public implementation

Corefx repro: https://github.com/dotnet/corefx/pull/30745</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>luqunl</Assignee>
    <CreatedAt>29/06/2018 12:07:11 AM +00:00</CreatedAt>
    <ClosedAt>29/06/2018 5:59:08 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18692</IssueLabelID>
    <Title>Proposal: Re-introduce support for multi-module assemblies</Title>
    <Description>Is there a technical reason or downside to having multi-module assemblies in CoreCLR?

https://github.com/dotnet/coreclr/commit/1aa7d6b8796f7e28a63162117c5bb16a207a472b removed the code associated with FEATURE_MULTIMODULE_ASSEMBLIES since it was never defined.

If there isn't I'd like to propose we bring this feature back.</Description>
    <Title_Description>Proposal: Re-introduce support for multi-module assemblies Is there a technical reason or downside to having multi-module assemblies in CoreCLR?

https://github.com/dotnet/coreclr/commit/1aa7d6b8796f7e28a63162117c5bb16a207a472b removed the code associated with FEATURE_MULTIMODULE_ASSEMBLIES since it was never defined.

If there isn't I'd like to propose we bring this feature back.</Title_Description>
    <Label>area-AssemblyLoader</Label>
    <Assignee>mjsabby</Assignee>
    <CreatedAt>28/06/2018 9:11:52 PM +00:00</CreatedAt>
    <ClosedAt>9/05/2019 2:53:37 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18691</IssueLabelID>
    <Title>Add public implementation CultureDataSupport</Title>
    <Description>WindowsRuntimeResourceManager  need to access CultureData to see whether a language is supported or not.
Add a public implementation CultureDataSupport for WindowsRuntimeResourceManager  </Description>
    <Title_Description>Add public implementation CultureDataSupport WindowsRuntimeResourceManager  need to access CultureData to see whether a language is supported or not.
Add a public implementation CultureDataSupport for WindowsRuntimeResourceManager  </Title_Description>
    <Label>area-Interop</Label>
    <Assignee>luqunl</Assignee>
    <CreatedAt>28/06/2018 8:09:52 PM +00:00</CreatedAt>
    <ClosedAt>29/06/2018 4:24:45 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18690</IssueLabelID>
    <Title>SuperPmi: add ability to exclude failing methods</Title>
    <Description>SuperPMI is used to collect method context files and replay them using only JIT.
It is also possible to collect plain *.mc but replay with set of `COMPLUS_stress` variables in this case we can have some methods that are failing with `stack overflow` or `bad code` that are correct and do not represent any problems in the jit. For this scenario we need to be able exclude such methods from the replays.

So I am planning to teach spmi to exclude methods based on their names.
For example if you run `spmi.exe FOLDER\collection.mch` and  there is file `collection.exclude` in `FOLDER` then `spmi.exe` will read method names from this file and skip these methods.</Description>
    <Title_Description>SuperPmi: add ability to exclude failing methods SuperPMI is used to collect method context files and replay them using only JIT.
It is also possible to collect plain *.mc but replay with set of `COMPLUS_stress` variables in this case we can have some methods that are failing with `stack overflow` or `bad code` that are correct and do not represent any problems in the jit. For this scenario we need to be able exclude such methods from the replays.

So I am planning to teach spmi to exclude methods based on their names.
For example if you run `spmi.exe FOLDER\collection.mch` and  there is file `collection.exclude` in `FOLDER` then `spmi.exe` will read method names from this file and skip these methods.</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>sandreenko</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18688</IssueLabelID>
    <Title>Bounds checks on array/span not eliminated after length check</Title>
    <Description>I've got code similar to the following repro:
```C#
using System;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;

public class C
{
    public static void Main() =&gt; new C().TryFormat(new char[4] out _);

    public bool TryFormat(Span&lt;char&gt; dst out int charsWritten)
    {
        if (dst.Length &gt;= 4)
        {
            dst[0] = 't';
            dst[1] = 'r';
            dst[2] = 'u';
            dst[3] = 'e';
            charsWritten = 4;
            return true;
        }
        charsWritten = 0;
        return false;
    }
}
```
I was hoping/expecting the bounds checks on each of those four writes to dst to be eliminated but they’re not:
```
G_M404_IG02:
       488B02               mov      rax bword ptr [rdx]
       8B5208               mov      edx dword ptr [rdx+8]
       83FA04               cmp      edx 4
       7C3C                 jl       SHORT G_M404_IG04
       83FA00               cmp      edx 0
       7641                 jbe      SHORT G_M404_IG06
       66C7007400           mov      word  ptr [rax] 116
       83FA01               cmp      edx 1
       7637                 jbe      SHORT G_M404_IG06
       66C740027200         mov      word  ptr [rax+2] 114
       83FA02               cmp      edx 2
       762C                 jbe      SHORT G_M404_IG06
       66C740047500         mov      word  ptr [rax+4] 117
       83FA03               cmp      edx 3
       7621                 jbe      SHORT G_M404_IG06
       66C740066500         mov      word  ptr [rax+6] 101
       41C70004000000       mov      dword ptr [r8] 4
       B801000000           mov      eax 1
```
To work around that I can use Unsafe.Add and MemoryMarshal.GetReference e.g.
```C#
public bool TryFormat(Span&lt;char&gt; dst out int charsWritten)
{
    if (dst.Length &gt;= 4)
    {
        ref char c = ref MemoryMarshal.GetReference(dst);
        c = 't';
        Unsafe.Add(ref c 1) = 'r';
        Unsafe.Add(ref c 2) = 'u';
        Unsafe.Add(ref c 3) = 'e';
        charsWritten = 4;
        return true;
    }
    charsWritten = 0;
    return false;
}
```
in which case I get the better:
```
G_M408_IG02:
       837A0804             cmp      dword ptr [rdx+8] 4
       7C27                 jl       SHORT G_M408_IG04
       488B02               mov      rax bword ptr [rdx]
       66C7007400           mov      word  ptr [rax] 116
       66C740027200         mov      word  ptr [rax+2] 114
       66C740047500         mov      word  ptr [rax+4] 117
       66C740066500         mov      word  ptr [rax+6] 101
       41C70004000000       mov      dword ptr [r8] 4
       B801000000           mov      eax 1
```
but it’d be nice not to have to use Unsafe for cases like this.

cc: @AndyAyersMS 
Related: https://github.com/dotnet/coreclr/issues/12639

category:cq
theme:range-check
skill-level:intermediate
cost:medium</Description>
    <Title_Description>Bounds checks on array/span not eliminated after length check I've got code similar to the following repro:
```C#
using System;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;

public class C
{
    public static void Main() =&gt; new C().TryFormat(new char[4] out _);

    public bool TryFormat(Span&lt;char&gt; dst out int charsWritten)
    {
        if (dst.Length &gt;= 4)
        {
            dst[0] = 't';
            dst[1] = 'r';
            dst[2] = 'u';
            dst[3] = 'e';
            charsWritten = 4;
            return true;
        }
        charsWritten = 0;
        return false;
    }
}
```
I was hoping/expecting the bounds checks on each of those four writes to dst to be eliminated but they’re not:
```
G_M404_IG02:
       488B02               mov      rax bword ptr [rdx]
       8B5208               mov      edx dword ptr [rdx+8]
       83FA04               cmp      edx 4
       7C3C                 jl       SHORT G_M404_IG04
       83FA00               cmp      edx 0
       7641                 jbe      SHORT G_M404_IG06
       66C7007400           mov      word  ptr [rax] 116
       83FA01               cmp      edx 1
       7637                 jbe      SHORT G_M404_IG06
       66C740027200         mov      word  ptr [rax+2] 114
       83FA02               cmp      edx 2
       762C                 jbe      SHORT G_M404_IG06
       66C740047500         mov      word  ptr [rax+4] 117
       83FA03               cmp      edx 3
       7621                 jbe      SHORT G_M404_IG06
       66C740066500         mov      word  ptr [rax+6] 101
       41C70004000000       mov      dword ptr [r8] 4
       B801000000           mov      eax 1
```
To work around that I can use Unsafe.Add and MemoryMarshal.GetReference e.g.
```C#
public bool TryFormat(Span&lt;char&gt; dst out int charsWritten)
{
    if (dst.Length &gt;= 4)
    {
        ref char c = ref MemoryMarshal.GetReference(dst);
        c = 't';
        Unsafe.Add(ref c 1) = 'r';
        Unsafe.Add(ref c 2) = 'u';
        Unsafe.Add(ref c 3) = 'e';
        charsWritten = 4;
        return true;
    }
    charsWritten = 0;
    return false;
}
```
in which case I get the better:
```
G_M408_IG02:
       837A0804             cmp      dword ptr [rdx+8] 4
       7C27                 jl       SHORT G_M408_IG04
       488B02               mov      rax bword ptr [rdx]
       66C7007400           mov      word  ptr [rax] 116
       66C740027200         mov      word  ptr [rax+2] 114
       66C740047500         mov      word  ptr [rax+4] 117
       66C740066500         mov      word  ptr [rax+6] 101
       41C70004000000       mov      dword ptr [r8] 4
       B801000000           mov      eax 1
```
but it’d be nice not to have to use Unsafe for cases like this.

cc: @AndyAyersMS 
Related: https://github.com/dotnet/coreclr/issues/12639

category:cq
theme:range-check
skill-level:intermediate
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
    <CreatedAt>28/06/2018 5:13:50 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18687</IssueLabelID>
    <Title>Port to 2.1: Fix alternate stack cleanup on MUSL</Title>
    <Description>The MUSL implementation of sigaltstack checks that the ss.ss_size is
larger or equal than the MINSIGSTKSZ even when the ss_flags is set
to SS_DISABLE even though Linux man page for sigaltstack states that
when this flag is set all other ss fields are ignored.

We were not setting the ss_size in this case and it was causing a memory
leak for each thread that has terminated on MUSL based Linux distros
like Alpine.

Glibc implementation doesn't check the ss_size when the SS_DISABLE is set
so the problem was really MUSL specific.</Description>
    <Title_Description>Port to 2.1: Fix alternate stack cleanup on MUSL The MUSL implementation of sigaltstack checks that the ss.ss_size is
larger or equal than the MINSIGSTKSZ even when the ss_flags is set
to SS_DISABLE even though Linux man page for sigaltstack states that
when this flag is set all other ss fields are ignored.

We were not setting the ss_size in this case and it was causing a memory
leak for each thread that has terminated on MUSL based Linux distros
like Alpine.

Glibc implementation doesn't check the ss_size when the SS_DISABLE is set
so the problem was really MUSL specific.</Title_Description>
    <Label>area-PAL</Label>
    <Assignee>janvorli</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18685</IssueLabelID>
    <Title>Fix alternate stack cleanup on MUSL</Title>
    <Description>The MUSL implementation of sigaltstack checks that the ss.ss_size is
larger or equal than the MINSIGSTKSZ even when the ss_flags is set
to SS_DISABLE even though Linux man page for sigaltstack states that
when this flag is set all other ss fields are ignored.

We were not setting the ss_size in this case and it was causing a memory
leak for each thread that has terminated on MUSL based Linux distros
like Alpine.

Glibc implementation doesn't check the ss_size when the SS_DISABLE is set
so the problem was really MUSL specific.</Description>
    <Title_Description>Fix alternate stack cleanup on MUSL The MUSL implementation of sigaltstack checks that the ss.ss_size is
larger or equal than the MINSIGSTKSZ even when the ss_flags is set
to SS_DISABLE even though Linux man page for sigaltstack states that
when this flag is set all other ss fields are ignored.

We were not setting the ss_size in this case and it was causing a memory
leak for each thread that has terminated on MUSL based Linux distros
like Alpine.

Glibc implementation doesn't check the ss_size when the SS_DISABLE is set
so the problem was really MUSL specific.</Title_Description>
    <Label>area-PAL</Label>
    <Assignee>janvorli</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18683</IssueLabelID>
    <Title>Option additionalProbingPaths is not working</Title>
    <Description>According to documentation this parameter should allow the placement of libraries in a different location for example a subdirectory. However the parameter fails to work as advised.

I'm running into the same behavior explained in this posting on StackOverflow: 
https://stackoverflow.com/questions/48650348/additionalprobingpaths-not-respected-after-dotnet-publish

Basically if you put the additional path into the json file it is ignored and moving a library to the new location will produce an error:
"An assembly specified in the application dependencies manifest ([referencedLibrary].deps.json) was not found"

This either does not work at all or it's documentation needs to be greatly improved.</Description>
    <Title_Description>Option additionalProbingPaths is not working According to documentation this parameter should allow the placement of libraries in a different location for example a subdirectory. However the parameter fails to work as advised.

I'm running into the same behavior explained in this posting on StackOverflow: 
https://stackoverflow.com/questions/48650348/additionalprobingpaths-not-respected-after-dotnet-publish

Basically if you put the additional path into the json file it is ignored and moving a library to the new location will produce an error:
"An assembly specified in the application dependencies manifest ([referencedLibrary].deps.json) was not found"

This either does not work at all or it's documentation needs to be greatly improved.</Title_Description>
    <Label>area-AssemblyLoader</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>28/06/2018 7:03:33 AM +00:00</CreatedAt>
    <ClosedAt>3/07/2018 3:32:03 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18682</IssueLabelID>
    <Title>ASP.NET Core application terminates with Segmentation fault on ARM.</Title>
    <Description>I've published my ASP.NET Core application with `-c release -r linux-arm` option.
My application is running on Linux (Debian 9) in Docker (version 18.05.0-ce build f150324) on ARM (Cavium ThunderX (2x) Armv8).
This application works as ASP.NET Core SignalR hub and handles many requests from SignalR clients. However sometimes dies and outputs core dump file.

I've read this issue and tried .NET Core 2.1 but the application still dies.

[Segmentation fault during GC when running on ARM](https://github.com/dotnet/coreclr/issues/13500)

Following is output of gdb from the core dump file:

`Program terminated with signal SIGSEGV Segmentation fault.
#0  0xf6d40716 in VirtualCallStubManager::ResolveWorker(StubCallSite* Object** DispatchToken VirtualCallStubManager::StubKind) ()
   from /root/rm/publish/libcoreclr.so
[Current thread is 1 (Thread 0xa1dff450 (LWP 37946))]
(gdb) where
#0  0xf6d40716 in VirtualCallStubManager::ResolveWorker(StubCallSite* Object** DispatchToken VirtualCallStubManager::StubKind) ()
   from /root/rm/publish/libcoreclr.so
#1  0xf6e41478 in ExternalMethodFixupWorker ()
   from /root/rm/publish/libcoreclr.so
#2  0xf6de42e2 in DelayLoad_MethodCall_FakeProlog ()
   from /root/rm/publish/libcoreclr.so
#3  0xbf0b5bb6 in ?? ()
Backtrace stopped: previous frame identical to this frame (corrupt stack?)
`</Description>
    <Title_Description>ASP.NET Core application terminates with Segmentation fault on ARM. I've published my ASP.NET Core application with `-c release -r linux-arm` option.
My application is running on Linux (Debian 9) in Docker (version 18.05.0-ce build f150324) on ARM (Cavium ThunderX (2x) Armv8).
This application works as ASP.NET Core SignalR hub and handles many requests from SignalR clients. However sometimes dies and outputs core dump file.

I've read this issue and tried .NET Core 2.1 but the application still dies.

[Segmentation fault during GC when running on ARM](https://github.com/dotnet/coreclr/issues/13500)

Following is output of gdb from the core dump file:

`Program terminated with signal SIGSEGV Segmentation fault.
#0  0xf6d40716 in VirtualCallStubManager::ResolveWorker(StubCallSite* Object** DispatchToken VirtualCallStubManager::StubKind) ()
   from /root/rm/publish/libcoreclr.so
[Current thread is 1 (Thread 0xa1dff450 (LWP 37946))]
(gdb) where
#0  0xf6d40716 in VirtualCallStubManager::ResolveWorker(StubCallSite* Object** DispatchToken VirtualCallStubManager::StubKind) ()
   from /root/rm/publish/libcoreclr.so
#1  0xf6e41478 in ExternalMethodFixupWorker ()
   from /root/rm/publish/libcoreclr.so
#2  0xf6de42e2 in DelayLoad_MethodCall_FakeProlog ()
   from /root/rm/publish/libcoreclr.so
#3  0xbf0b5bb6 in ?? ()
Backtrace stopped: previous frame identical to this frame (corrupt stack?)
`</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>28/06/2018 3:16:34 AM +00:00</CreatedAt>
    <ClosedAt>17/06/2019 9:09:17 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18681</IssueLabelID>
    <Title>Move Is AppDomainUnloadedException check from S.R.WR into S.P.Corelib</Title>
    <Description>Type AppDomainUnloadedException in S.P.Corelib is internal only. Also I can't use public type AppDomainUnloadedException in System.Runtime.Extensions since Type AppDomainUnloadedException in S.P.Corelib and Type AppDomainUnloadedException in System.Runtime.Extensions are two different types.</Description>
    <Title_Description>Move Is AppDomainUnloadedException check from S.R.WR into S.P.Corelib Type AppDomainUnloadedException in S.P.Corelib is internal only. Also I can't use public type AppDomainUnloadedException in System.Runtime.Extensions since Type AppDomainUnloadedException in S.P.Corelib and Type AppDomainUnloadedException in System.Runtime.Extensions are two different types.</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>luqunl</Assignee>
    <CreatedAt>28/06/2018 12:24:49 AM +00:00</CreatedAt>
    <ClosedAt>28/06/2018 6:50:37 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18680</IssueLabelID>
    <Title>Hung .NET Core console app - F5 launch from VS </Title>
    <Description>A .NET Core 2.1 console app hung (right after I pressed Ctrl+C which the console app handles) and inspection suggests the code required to exit the app never executed because the method could not be JITted.

[Dump file](https://microsoft-my.sharepoint.com/:u:/p/andarno/Eahy34c1IvpOgtMkgCPvKQAB2QNonNUbsvL3LcORNs62BQ?e=iA5Cop)

```
#  8  Id: 3fb4.63ac Suspend: 0 Teb: 00000075`fbb6a000 Unfrozen
 # Child-SP          RetAddr           Call Site
00 00000075`fcdfd428 00007ffa`16c89252 ntdll!NtWaitForSingleObject+0x14
01 00000075`fcdfd430 00007ff9`944d7778 KERNELBASE!WaitForSingleObjectEx+0xa2
02 (Inline Function) --------`-------- coreclr!CLREventWaitHelper2+0x6 [e:\a\_work\31\s\src\vm\synch.cpp @ 385] 
03 00000075`fcdfd4d0 00007ff9`9472765d coreclr!CLREventWaitHelper+0x20 [e:\a\_work\31\s\src\vm\synch.cpp @ 411] 
04 (Inline Function) --------`-------- coreclr!CLREventBase::WaitEx+0x12 [e:\a\_work\31\s\src\vm\synch.cpp @ 483] 
05 (Inline Function) --------`-------- coreclr!CLREventBase::Wait+0x12 [e:\a\_work\31\s\src\vm\synch.cpp @ 426] 
06 00000075`fcdfd530 00007ff9`946547c0 coreclr!Thread::WaitSuspendEventsHelper+0xa9 [e:\a\_work\31\s\src\vm\threadsuspend.cpp @ 5954] 
07 (Inline Function) --------`-------- coreclr!Thread::WaitSuspendEvents+0x8 [e:\a\_work\31\s\src\vm\threadsuspend.cpp @ 5991] 
08 00000075`fcdfd5f0 00007ff9`944e1e81 coreclr!Thread::RareEnablePreemptiveGC+0x172bd0 [e:\a\_work\31\s\src\vm\threadsuspend.cpp @ 3514] 
09 (Inline Function) --------`-------- coreclr!Thread::EnablePreemptiveGC+0x126 [e:\a\_work\31\s\src\vm\threads.h @ 2163] 
0a 00000075`fcdfd630 00007ff9`94519191 coreclr!Thread::RareDisablePreemptiveGC+0x215 [e:\a\_work\31\s\src\vm\threadsuspend.cpp @ 3036] 
0b (Inline Function) --------`-------- coreclr!Thread::DisablePreemptiveGC+0x5b [e:\a\_work\31\s\src\vm\threads.h @ 2107] 
0c (Inline Function) --------`-------- coreclr!GCHolderBase::PopInternal+0x6c [e:\a\_work\31\s\src\vm\threads.h @ 5949] 
0d (Inline Function) --------`-------- coreclr!GCPreemp::{dtor}+0x6c [e:\a\_work\31\s\src\vm\threads.h @ 6307] 
0e 00000075`fcdfd680 00007ff9`94517e12 coreclr!invokeCompileMethod+0x18d [e:\a\_work\31\s\src\vm\jitinterface.cpp @ 12263] 
0f 00000075`fcdfd710 00007ff9`944ed178 coreclr!CallCompileMethodWithSEHWrapper+0x52 [e:\a\_work\31\s\src\vm\jitinterface.cpp @ 12306] 
10 00000075`fcdfd7a0 00007ff9`94596272 coreclr!UnsafeJitFunction+0x4e8 [e:\a\_work\31\s\src\vm\jitinterface.cpp @ 12803] 
11 00000075`fcdfdd70 00007ff9`946ae8fd coreclr!MethodDesc::JitCompileCodeLocked+0x1fe [e:\a\_work\31\s\src\vm\prestub.cpp @ 841] 
12 00000075`fcdfdf10 00007ff9`945966ee coreclr!MethodDesc::JitCompileCodeLockedEventWrapper+0x118b39 [e:\a\_work\31\s\src\vm\prestub.cpp @ 716] 
13 00000075`fcdfe030 00007ff9`945956e8 coreclr!MethodDesc::JitCompileCode+0x36e [e:\a\_work\31\s\src\vm\prestub.cpp @ 636] 
14 (Inline Function) --------`-------- coreclr!MethodDesc::PrepareILBasedCode+0x13a [e:\a\_work\31\s\src\vm\prestub.cpp @ 310] 
15 (Inline Function) --------`-------- coreclr!MethodDesc::PrepareCode+0x13a [e:\a\_work\31\s\src\vm\prestub.cpp @ 292] 
16 (Inline Function) --------`-------- coreclr!MethodDesc::PrepareInitialCode+0x163 [e:\a\_work\31\s\src\vm\prestub.cpp @ 248] 
17 00000075`fcdfe130 00007ff9`9450ba1a coreclr!MethodDesc::DoPrestub+0x5b8 [e:\a\_work\31\s\src\vm\prestub.cpp @ 1812] 
18 00000075`fcdfe280 00007ff9`9461e955 coreclr!PreStubWorker+0x37a [e:\a\_work\31\s\src\vm\prestub.cpp @ 1548] 
19 00000075`fcdfe510 00007ff9`34b70e7a coreclr!ThePreStub+0x55 [E:\A\_work\31\s\src\vm\amd64\ThePreStubAMD64.asm @ 22] 
1a 00000075`fcdfe5c0 00007ff9`8bfbcb39 StreamJsonRpc!StreamJsonRpc.HeaderDelimitedMessageHandler+&lt;ReadCoreAsync&gt;d__20.MoveNext()+0x33a*** WARNING: Unable to verify checksum for StreamJsonRpc.dll
 [D:\git\streamjsonrpc\src\StreamJsonRpc\HeaderDelimitedMessageHandler.cs @ 111] 
1b 00000075`fcdfe880 00007ff9`8c236340 System_Private_CoreLib!System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext System.Threading.ContextCallback System.Object)+0x89
1c 00000075`fcdfe900 00007ff9`8c0d7c80 System_Private_CoreLib!System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.__Canon System.Private.CoreLib][System.__Canon System.Private.CoreLib]].MoveNext()+0xa0
1d 00000075`fcdfe970 00007ff9`8c0a4579 System_Private_CoreLib!System.Runtime.CompilerServices.TaskAwaiter+&lt;&gt;c.&lt;OutputWaitEtwEvents&gt;b__12_0(System.Action System.Threading.Tasks.Task)+0x140
1e 00000075`fcdfea00 00007ff9`8c0707a4 System_Private_CoreLib!System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(System.Action Boolean)+0x79
1f 00000075`fcdfea60 00007ff9`8c0d5d0d System_Private_CoreLib!System.Threading.Tasks.Task.RunContinuations(System.Object)+0x184
20 00000075`fcdfeb30 00007ff9`8c0b2df9 System_Private_CoreLib!System.Threading.Tasks.Task`1[[System.__Canon System.Private.CoreLib]].TrySetResult(System.__Canon)+0x2c5fd
21 00000075`fcdfeb70 00007ff9`8c18fc23 System_Private_CoreLib!System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.Int32 System.Private.CoreLib]].SetExistingTaskResult(Int32)+0xffffffff`fffda7a9
22 00000075`fcdfebb0 00007ff9`34b7235b System_Private_CoreLib!System.Runtime.CompilerServices.AsyncTaskMethodBuilder.SetResult()+0x43
23 00000075`fcdfebf0 00007ff9`8bfbcb39 StreamJsonRpc!StreamJsonRpc.ReadBufferingStream+&lt;FillBufferAsync&gt;d__27.MoveNext()+0x3ab [D:\git\streamjsonrpc\src\StreamJsonRpc\Reflection\MethodSignature.cs @ 39] 
24 00000075`fcdfece0 00007ff9`8c239200 System_Private_CoreLib!System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext System.Threading.ContextCallback System.Object)+0x89
25 00000075`fcdfed60 00007ff9`8c0d7c80 System_Private_CoreLib!System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.__Canon System.Private.CoreLib][System.__Canon System.Private.CoreLib]].MoveNext()+0x2f60
26 00000075`fcdfedd0 00007ff9`8c0a4579 System_Private_CoreLib!System.Runtime.CompilerServices.TaskAwaiter+&lt;&gt;c.&lt;OutputWaitEtwEvents&gt;b__12_0(System.Action System.Threading.Tasks.Task)+0x140
27 00000075`fcdfee60 00007ff9`8c0707a4 System_Private_CoreLib!System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(System.Action Boolean)+0x79
28 00000075`fcdfeec0 00007ff9`8c076c44 System_Private_CoreLib!System.Threading.Tasks.Task.RunContinuations(System.Object)+0x184
29 00000075`fcdfef90 00007ff9`8c0d7d14 System_Private_CoreLib!System.Threading.Tasks.Task`1[[System.__Canon System.Private.CoreLib]].TrySetResult(System.__Canon)+0xffffffff`fffcd534
2a 00000075`fcdfefd0 00007ff9`8c0d7e92 System_Private_CoreLib!System.Threading.Tasks.TaskFactory`1+FromAsyncTrimPromise`1[[System.Threading.Tasks.VoidTaskResult System.Private.CoreLib][System.__Canon System.Private.CoreLib]].Complete(System.__Canon System.Func`3&lt;System.__CanonSystem.IAsyncResultSystem.Threading.Tasks.VoidTaskResult&gt; System.IAsyncResult Boolean)+0xffffffff`ffe99854
2b 00000075`fcdff010 00007ff9`8bfbcb39 System_Private_CoreLib!System.Threading.Tasks.TaskFactory`1+FromAsyncTrimPromise`1[[System.Threading.Tasks.VoidTaskResult System.Private.CoreLib][System.__Canon System.Private.CoreLib]].CompleteFromAsyncResult(System.IAsyncResult)+0xffffffff`ffe998a2
2c 00000075`fcdff070 00007ff9`8c0707ff System_Private_CoreLib!System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext System.Threading.ContextCallback System.Object)+0x89
2d 00000075`fcdff0f0 00007ff9`8c06f52e System_Private_CoreLib!System.Threading.Tasks.Task.RunContinuations(System.Object)+0x1df
2e 00000075`fcdff1c0 00007ff9`8c0a66ac System_Private_CoreLib!System.Threading.Tasks.Task.ExecuteWithThreadLocal(System.Threading.Tasks.Task ByRef)+0x1be
2f 00000075`fcdff260 00007ff9`9461f3b3 System_Private_CoreLib!System.Threading.ThreadPoolWorkQueue.Dispatch()+0x19c
30 00000075`fcdff300 00007ff9`94589e41 coreclr!CallDescrWorkerInternal+0x83 [E:\A\_work\31\s\src\vm\amd64\CallDescrWorkerAMD64.asm @ 101] 
31 (Inline Function) --------`-------- coreclr!CallDescrWorkerWithHandler+0x53 [e:\a\_work\31\s\src\vm\callhelpers.cpp @ 78] 
32 00000075`fcdff340 00007ff9`9458933f coreclr!MethodDescCallSite::CallTargetWorker+0x2b5 [e:\a\_work\31\s\src\vm\callhelpers.cpp @ 628] 
33 (Inline Function) --------`-------- coreclr!MethodDescCallSite::Call_RetBool+0x15 [e:\a\_work\31\s\src\vm\callhelpers.h @ 433] 
34 00000075`fcdff490 00007ff9`945a37f6 coreclr!QueueUserWorkItemManagedCallback+0x7f [e:\a\_work\31\s\src\vm\comthreadpool.cpp @ 451] 
35 00000075`fcdff580 00007ff9`945a3652 coreclr!ManagedThreadBase_DispatchInner+0x5a [e:\a\_work\31\s\src\vm\threads.cpp @ 8852] 
36 00000075`fcdff5c0 00007ff9`945a3551 coreclr!ManagedThreadBase_DispatchMiddle+0x76 [e:\a\_work\31\s\src\vm\threads.cpp @ 8901] 
37 00000075`fcdff6c0 00007ff9`945a2e10 coreclr!ManagedThreadBase_DispatchOuter+0x91 [e:\a\_work\31\s\src\vm\threads.cpp @ 9140] 
38 (Inline Function) --------`-------- coreclr!ManagedThreadBase_FullTransitionWithAD+0x56 [e:\a\_work\31\s\src\vm\threads.cpp @ 9199] 
39 (Inline Function) --------`-------- coreclr!ManagedThreadBase::ThreadPool+0x56 [e:\a\_work\31\s\src\vm\threads.cpp @ 9241] 
3a 00000075`fcdff730 00007ff9`945a2695 coreclr!ManagedPerAppDomainTPCount::DispatchWorkItem+0xe0 [e:\a\_work\31\s\src\vm\threadpoolrequest.cpp @ 757] 
3b (Inline Function) --------`-------- coreclr!ThreadpoolMgr::ExecuteWorkRequest+0x47 [e:\a\_work\31\s\src\vm\win32threadpool.cpp @ 1560] 
3c 00000075`fcdff890 00007ff9`944d3678 coreclr!ThreadpoolMgr::WorkerThreadStart+0x1d5 [e:\a\_work\31\s\src\vm\win32threadpool.cpp @ 2024] 
3d 00000075`fcdffa90 00007ffa`197a3034 coreclr!Thread::intermediateThreadProc+0x88 [e:\a\_work\31\s\src\vm\threads.cpp @ 2255] 
3e 00000075`fcdffc50 00007ffa`19e01431 kernel32!BaseThreadInitThunk+0x14
3f 00000075`fcdffc80 00000000`00000000 ntdll!RtlUserThreadStart+0x21

   9  Id: 3fb4.b958 Suspend: 0 Teb: 00000075`fbb6c000 Unfrozen
 # Child-SP          RetAddr           Call Site
00 00000075`fcf7b8f8 00007ffa`19dadc63 ntdll!NtWaitForAlertByThreadId+0x14
01 00000075`fcf7b900 00007ffa`19dada64 ntdll!RtlpWaitOnAddressWithTimeout+0x43
02 00000075`fcf7b930 00007ffa`19da83e7 ntdll!RtlpWaitOnCriticalSection+0x164
03 00000075`fcf7b9e0 00007ffa`19da8300 ntdll!RtlpEnterCriticalSectionContended+0xd7
04 00000075`fcf7ba10 00007ff9`944e19b3 ntdll!RtlEnterCriticalSection+0x40
05 (Inline Function) --------`-------- coreclr!UnsafeEnterCriticalSection+0x9 [e:\a\_work\31\s\src\inc\unsafe.h @ 19] 
06 00000075`fcf7ba40 00007ff9`94518fad coreclr!CrstBase::Enter+0x67 [e:\a\_work\31\s\src\vm\crst.cpp @ 319] 
07 00000075`fcf7ba80 00007ff9`948eb919 coreclr!Debugger::DoNotCallDirectlyPrivateLock+0x39 [e:\a\_work\31\s\src\debug\ee\debugger.cpp @ 365] 
08 (Inline Function) --------`-------- coreclr!Debugger::AcquireDebuggerLock+0x5 [e:\a\_work\31\s\src\debug\ee\debugger.h @ 2313] 
09 (Inline Function) --------`-------- coreclr!FunctionBase&lt;Debugger *&amp;Debugger::AcquireDebuggerLock&amp;Debugger::ReleaseDebuggerLock2&gt;::DoAcquire+0x5 [e:\a\_work\31\s\src\inc\holder.h @ 750] 
0a (Inline Function) --------`-------- coreclr!BaseHolder&lt;Debugger *FunctionBase&lt;Debugger *&amp;Debugger::AcquireDebuggerLock&amp;Debugger::ReleaseDebuggerLock2&gt;0&amp;CompareDefault&lt;Debugger *&gt;2&gt;::Acquire+0xd [e:\a\_work\31\s\src\inc\holder.h @ 296] 
0b 00000075`fcf7bab0 00007ff9`948ea26b coreclr!Debugger::LockForEventSending+0x25 [e:\a\_work\31\s\src\debug\ee\debugger.cpp @ 6467] 
0c 00000075`fcf7bae0 00007ff9`947b09cb coreclr!Debugger::LoadClass+0x7b [e:\a\_work\31\s\src\debug\ee\debugger.cpp @ 10210] 
0d 00000075`fcf7bb50 00007ff9`9466df7b coreclr!TypeHandle::NotifyDebuggerLoad+0x127 [e:\a\_work\31\s\src\vm\class.cpp @ 1539] 
0e 00000075`fcf7bb90 00007ff9`94508622 coreclr!ClassLoader::LoadTypeHandleForTypeKey_Body+0x16876b [e:\a\_work\31\s\src\vm\clsload.cpp @ 4325] 
0f 00000075`fcf7c7e0 00007ff9`9458ae5b coreclr!ClassLoader::LoadTypeHandleForTypeKey+0x9e [e:\a\_work\31\s\src\vm\clsload.cpp @ 4044] 
10 00000075`fcf7c870 00007ff9`9458d912 coreclr!ClassLoader::LoadTypeDefThrowing+0x24b [e:\a\_work\31\s\src\vm\clsload.cpp @ 2887] 
11 00000075`fcf7ca40 00007ff9`9458c6ae coreclr!ClassLoader::LoadTypeDefOrRefThrowing+0x442 [e:\a\_work\31\s\src\vm\clsload.cpp @ 3065] 
12 00000075`fcf7cb90 00007ff9`9452470c coreclr!SigPointer::GetTypeHandleThrowing+0x79e [e:\a\_work\31\s\src\vm\siginfo.cpp @ 1507] 
13 00000075`fcf7cf00 00007ff9`bfb18a5c coreclr!CEEInfo::getArgClass+0x1bc [e:\a\_work\31\s\src\vm\jitinterface.cpp @ 9688] 
14 00000075`fcf7d0d0 00007ff9`bfb1a2d0 clrjit!Compiler::lvaInitTypeRef+0x3ac [e:\a\_work\31\s\src\jit\lclvars.cpp @ 262] 
15 00000075`fcf7d170 00007ff9`bfb1a703 clrjit!Compiler::compCompileHelper+0x1d0 [e:\a\_work\31\s\src\jit\compiler.cpp @ 6116] 
16 00000075`fcf7d220 00007ff9`bfb09347 clrjit!Compiler::compCompile+0x253 [e:\a\_work\31\s\src\jit\compiler.cpp @ 5599] 
17 00000075`fcf7d2e0 00007ff9`bfb09d62 clrjit!jitNativeCode+0x267 [e:\a\_work\31\s\src\jit\compiler.cpp @ 6908] 
18 00000075`fcf7d4a0 00007ff9`945190e9 clrjit!CILJit::compileMethod+0xa2 [e:\a\_work\31\s\src\jit\ee_il_dll.cpp @ 303] 
19 (Inline Function) --------`-------- coreclr!invokeCompileMethodHelper+0x6b [e:\a\_work\31\s\src\vm\jitinterface.cpp @ 12187] 
1a 00000075`fcf7d510 00007ff9`94517e12 coreclr!invokeCompileMethod+0xe5 [e:\a\_work\31\s\src\vm\jitinterface.cpp @ 12254] 
1b 00000075`fcf7d5a0 00007ff9`944ed178 coreclr!CallCompileMethodWithSEHWrapper+0x52 [e:\a\_work\31\s\src\vm\jitinterface.cpp @ 12306] 
1c 00000075`fcf7d630 00007ff9`94596272 coreclr!UnsafeJitFunction+0x4e8 [e:\a\_work\31\s\src\vm\jitinterface.cpp @ 12803] 
1d 00000075`fcf7dc00 00007ff9`946ae8fd coreclr!MethodDesc::JitCompileCodeLocked+0x1fe [e:\a\_work\31\s\src\vm\prestub.cpp @ 841] 
1e 00000075`fcf7dda0 00007ff9`945966ee coreclr!MethodDesc::JitCompileCodeLockedEventWrapper+0x118b39 [e:\a\_work\31\s\src\vm\prestub.cpp @ 716] 
1f 00000075`fcf7dec0 00007ff9`945956e8 coreclr!MethodDesc::JitCompileCode+0x36e [e:\a\_work\31\s\src\vm\prestub.cpp @ 636] 
20 (Inline Function) --------`-------- coreclr!MethodDesc::PrepareILBasedCode+0x13a [e:\a\_work\31\s\src\vm\prestub.cpp @ 310] 
21 (Inline Function) --------`-------- coreclr!MethodDesc::PrepareCode+0x13a [e:\a\_work\31\s\src\vm\prestub.cpp @ 292] 
22 (Inline Function) --------`-------- coreclr!MethodDesc::PrepareInitialCode+0x163 [e:\a\_work\31\s\src\vm\prestub.cpp @ 248] 
23 00000075`fcf7dfc0 00007ff9`9450ba1a coreclr!MethodDesc::DoPrestub+0x5b8 [e:\a\_work\31\s\src\vm\prestub.cpp @ 1812] 
24 00000075`fcf7e110 00007ff9`9461e955 coreclr!PreStubWorker+0x37a [e:\a\_work\31\s\src\vm\prestub.cpp @ 1548] 
25 00000075`fcf7e3a0 00007ff9`8c0c1d25 coreclr!ThePreStub+0x55 [E:\A\_work\31\s\src\vm\amd64\ThePreStubAMD64.asm @ 22] 
26 00000075`fcf7e450 00007ff9`8c0958e0 System_Private_CoreLib!System.Threading.CancellationTokenSource.InternalRegister(System.Action`1&lt;System.Object&gt; System.Object System.Threading.SynchronizationContext System.Threading.ExecutionContext)+0x2c5
27 00000075`fcf7e4e0 00007ff9`8c095813 System_Private_CoreLib!System.Threading.CancellationToken.Register(System.Action`1&lt;System.Object&gt; System.Object Boolean Boolean)+0x90
28 00000075`fcf7e550 00007ff9`34b75ae1 System_Private_CoreLib!System.Threading.CancellationToken.Register(System.Action`1&lt;System.Object&gt; System.Object Boolean)+0x23
29 00000075`fcf7e590 00007ff9`8bfbcb39 StreamJsonRpc!StreamJsonRpc.JsonRpc+&lt;InvokeCoreAsync&gt;d__89`1[[System.__Canon System.Private.CoreLib]].MoveNext()+0xdd1 [D:\git\streamjsonrpc\src\StreamJsonRpc\JsonRpc.cs @ 948] 
2a 00000075`fcf7e950 00007ff9`8c236340 System_Private_CoreLib!System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext System.Threading.ContextCallback System.Object)+0x89
2b 00000075`fcf7e9d0 00007ff9`8c0d7c80 System_Private_CoreLib!System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.__Canon System.Private.CoreLib][System.__Canon System.Private.CoreLib]].MoveNext()+0xa0
2c 00000075`fcf7ea40 00007ff9`8c0a4579 System_Private_CoreLib!System.Runtime.CompilerServices.TaskAwaiter+&lt;&gt;c.&lt;OutputWaitEtwEvents&gt;b__12_0(System.Action System.Threading.Tasks.Task)+0x140
2d 00000075`fcf7ead0 00007ff9`8c0707a4 System_Private_CoreLib!System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(System.Action Boolean)+0x79
2e 00000075`fcf7eb30 00007ff9`8c0d5d0d System_Private_CoreLib!System.Threading.Tasks.Task.RunContinuations(System.Object)+0x184
2f 00000075`fcf7ec00 00007ff9`8c0b2df9 System_Private_CoreLib!System.Threading.Tasks.Task`1[[System.__Canon System.Private.CoreLib]].TrySetResult(System.__Canon)+0x2c5fd
30 00000075`fcf7ec40 00007ff9`8c18fc23 System_Private_CoreLib!System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.Int32 System.Private.CoreLib]].SetExistingTaskResult(Int32)+0xffffffff`fffda7a9
31 00000075`fcf7ec80 00007ff9`34ba7792 System_Private_CoreLib!System.Runtime.CompilerServices.AsyncTaskMethodBuilder.SetResult()+0x43
32 00000075`fcf7ecc0 00007ff9`8bfbcb39 StreamJsonRpc!StreamJsonRpc.DelimitedMessageHandler+&lt;WriteAsync&gt;d__23.MoveNext()+0x742 [D:\git\streamjsonrpc\src\StreamJsonRpc\HeaderDelimitedMessageHandler.cs @ 93] 
33 00000075`fcf7eea0 00007ff9`8c239200 System_Private_CoreLib!System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext System.Threading.ContextCallback System.Object)+0x89
34 00000075`fcf7ef20 00007ff9`8c0d7c80 System_Private_CoreLib!System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.__Canon System.Private.CoreLib][System.__Canon System.Private.CoreLib]].MoveNext()+0x2f60
35 00000075`fcf7ef90 00007ff9`8c0a4579 System_Private_CoreLib!System.Runtime.CompilerServices.TaskAwaiter+&lt;&gt;c.&lt;OutputWaitEtwEvents&gt;b__12_0(System.Action System.Threading.Tasks.Task)+0x140
36 00000075`fcf7f020 00007ff9`8c0707a4 System_Private_CoreLib!System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(System.Action Boolean)+0x79
37 00000075`fcf7f080 00007ff9`8c06f52e System_Private_CoreLib!System.Threading.Tasks.Task.RunContinuations(System.Object)+0x184
38 00000075`fcf7f150 00007ff9`8c0a66ac System_Private_CoreLib!System.Threading.Tasks.Task.ExecuteWithThreadLocal(System.Threading.Tasks.Task ByRef)+0x1be
39 00000075`fcf7f1f0 00007ff9`9461f3b3 System_Private_CoreLib!System.Threading.ThreadPoolWorkQueue.Dispatch()+0x19c
3a 00000075`fcf7f290 00007ff9`94589e41 coreclr!CallDescrWorkerInternal+0x83 [E:\A\_work\31\s\src\vm\amd64\CallDescrWorkerAMD64.asm @ 101] 
3b (Inline Function) --------`-------- coreclr!CallDescrWorkerWithHandler+0x53 [e:\a\_work\31\s\src\vm\callhelpers.cpp @ 78] 
3c 00000075`fcf7f2d0 00007ff9`9458933f coreclr!MethodDescCallSite::CallTargetWorker+0x2b5 [e:\a\_work\31\s\src\vm\callhelpers.cpp @ 628] 
3d (Inline Function) --------`-------- coreclr!MethodDescCallSite::Call_RetBool+0x15 [e:\a\_work\31\s\src\vm\callhelpers.h @ 433] 
3e 00000075`fcf7f420 00007ff9`945a37f6 coreclr!QueueUserWorkItemManagedCallback+0x7f [e:\a\_work\31\s\src\vm\comthreadpool.cpp @ 451] 
3f 00000075`fcf7f510 00007ff9`945a3652 coreclr!ManagedThreadBase_DispatchInner+0x5a [e:\a\_work\31\s\src\vm\threads.cpp @ 8852] 
40 00000075`fcf7f550 00007ff9`945a3551 coreclr!ManagedThreadBase_DispatchMiddle+0x76 [e:\a\_work\31\s\src\vm\threads.cpp @ 8901] 
41 00000075`fcf7f650 00007ff9`945a2e10 coreclr!ManagedThreadBase_DispatchOuter+0x91 [e:\a\_work\31\s\src\vm\threads.cpp @ 9140] 
42 (Inline Function) --------`-------- coreclr!ManagedThreadBase_FullTransitionWithAD+0x56 [e:\a\_work\31\s\src\vm\threads.cpp @ 9199] 
43 (Inline Function) --------`-------- coreclr!ManagedThreadBase::ThreadPool+0x56 [e:\a\_work\31\s\src\vm\threads.cpp @ 9241] 
44 00000075`fcf7f6c0 00007ff9`945a2695 coreclr!ManagedPerAppDomainTPCount::DispatchWorkItem+0xe0 [e:\a\_work\31\s\src\vm\threadpoolrequest.cpp @ 757] 
45 (Inline Function) --------`-------- coreclr!ThreadpoolMgr::ExecuteWorkRequest+0x47 [e:\a\_work\31\s\src\vm\win32threadpool.cpp @ 1560] 
46 00000075`fcf7f820 00007ff9`944d3678 coreclr!ThreadpoolMgr::WorkerThreadStart+0x1d5 [e:\a\_work\31\s\src\vm\win32threadpool.cpp @ 2024] 
47 00000075`fcf7fa20 00007ffa`197a3034 coreclr!Thread::intermediateThreadProc+0x88 [e:\a\_work\31\s\src\vm\threads.cpp @ 2255] 
48 00000075`fcf7fc60 00007ffa`19e01431 kernel32!BaseThreadInitThunk+0x14
49 00000075`fcf7fc90 00000000`00000000 ntdll!RtlUserThreadStart+0x21
```</Description>
    <Title_Description>Hung .NET Core console app - F5 launch from VS  A .NET Core 2.1 console app hung (right after I pressed Ctrl+C which the console app handles) and inspection suggests the code required to exit the app never executed because the method could not be JITted.

[Dump file](https://microsoft-my.sharepoint.com/:u:/p/andarno/Eahy34c1IvpOgtMkgCPvKQAB2QNonNUbsvL3LcORNs62BQ?e=iA5Cop)

```
#  8  Id: 3fb4.63ac Suspend: 0 Teb: 00000075`fbb6a000 Unfrozen
 # Child-SP          RetAddr           Call Site
00 00000075`fcdfd428 00007ffa`16c89252 ntdll!NtWaitForSingleObject+0x14
01 00000075`fcdfd430 00007ff9`944d7778 KERNELBASE!WaitForSingleObjectEx+0xa2
02 (Inline Function) --------`-------- coreclr!CLREventWaitHelper2+0x6 [e:\a\_work\31\s\src\vm\synch.cpp @ 385] 
03 00000075`fcdfd4d0 00007ff9`9472765d coreclr!CLREventWaitHelper+0x20 [e:\a\_work\31\s\src\vm\synch.cpp @ 411] 
04 (Inline Function) --------`-------- coreclr!CLREventBase::WaitEx+0x12 [e:\a\_work\31\s\src\vm\synch.cpp @ 483] 
05 (Inline Function) --------`-------- coreclr!CLREventBase::Wait+0x12 [e:\a\_work\31\s\src\vm\synch.cpp @ 426] 
06 00000075`fcdfd530 00007ff9`946547c0 coreclr!Thread::WaitSuspendEventsHelper+0xa9 [e:\a\_work\31\s\src\vm\threadsuspend.cpp @ 5954] 
07 (Inline Function) --------`-------- coreclr!Thread::WaitSuspendEvents+0x8 [e:\a\_work\31\s\src\vm\threadsuspend.cpp @ 5991] 
08 00000075`fcdfd5f0 00007ff9`944e1e81 coreclr!Thread::RareEnablePreemptiveGC+0x172bd0 [e:\a\_work\31\s\src\vm\threadsuspend.cpp @ 3514] 
09 (Inline Function) --------`-------- coreclr!Thread::EnablePreemptiveGC+0x126 [e:\a\_work\31\s\src\vm\threads.h @ 2163] 
0a 00000075`fcdfd630 00007ff9`94519191 coreclr!Thread::RareDisablePreemptiveGC+0x215 [e:\a\_work\31\s\src\vm\threadsuspend.cpp @ 3036] 
0b (Inline Function) --------`-------- coreclr!Thread::DisablePreemptiveGC+0x5b [e:\a\_work\31\s\src\vm\threads.h @ 2107] 
0c (Inline Function) --------`-------- coreclr!GCHolderBase::PopInternal+0x6c [e:\a\_work\31\s\src\vm\threads.h @ 5949] 
0d (Inline Function) --------`-------- coreclr!GCPreemp::{dtor}+0x6c [e:\a\_work\31\s\src\vm\threads.h @ 6307] 
0e 00000075`fcdfd680 00007ff9`94517e12 coreclr!invokeCompileMethod+0x18d [e:\a\_work\31\s\src\vm\jitinterface.cpp @ 12263] 
0f 00000075`fcdfd710 00007ff9`944ed178 coreclr!CallCompileMethodWithSEHWrapper+0x52 [e:\a\_work\31\s\src\vm\jitinterface.cpp @ 12306] 
10 00000075`fcdfd7a0 00007ff9`94596272 coreclr!UnsafeJitFunction+0x4e8 [e:\a\_work\31\s\src\vm\jitinterface.cpp @ 12803] 
11 00000075`fcdfdd70 00007ff9`946ae8fd coreclr!MethodDesc::JitCompileCodeLocked+0x1fe [e:\a\_work\31\s\src\vm\prestub.cpp @ 841] 
12 00000075`fcdfdf10 00007ff9`945966ee coreclr!MethodDesc::JitCompileCodeLockedEventWrapper+0x118b39 [e:\a\_work\31\s\src\vm\prestub.cpp @ 716] 
13 00000075`fcdfe030 00007ff9`945956e8 coreclr!MethodDesc::JitCompileCode+0x36e [e:\a\_work\31\s\src\vm\prestub.cpp @ 636] 
14 (Inline Function) --------`-------- coreclr!MethodDesc::PrepareILBasedCode+0x13a [e:\a\_work\31\s\src\vm\prestub.cpp @ 310] 
15 (Inline Function) --------`-------- coreclr!MethodDesc::PrepareCode+0x13a [e:\a\_work\31\s\src\vm\prestub.cpp @ 292] 
16 (Inline Function) --------`-------- coreclr!MethodDesc::PrepareInitialCode+0x163 [e:\a\_work\31\s\src\vm\prestub.cpp @ 248] 
17 00000075`fcdfe130 00007ff9`9450ba1a coreclr!MethodDesc::DoPrestub+0x5b8 [e:\a\_work\31\s\src\vm\prestub.cpp @ 1812] 
18 00000075`fcdfe280 00007ff9`9461e955 coreclr!PreStubWorker+0x37a [e:\a\_work\31\s\src\vm\prestub.cpp @ 1548] 
19 00000075`fcdfe510 00007ff9`34b70e7a coreclr!ThePreStub+0x55 [E:\A\_work\31\s\src\vm\amd64\ThePreStubAMD64.asm @ 22] 
1a 00000075`fcdfe5c0 00007ff9`8bfbcb39 StreamJsonRpc!StreamJsonRpc.HeaderDelimitedMessageHandler+&lt;ReadCoreAsync&gt;d__20.MoveNext()+0x33a*** WARNING: Unable to verify checksum for StreamJsonRpc.dll
 [D:\git\streamjsonrpc\src\StreamJsonRpc\HeaderDelimitedMessageHandler.cs @ 111] 
1b 00000075`fcdfe880 00007ff9`8c236340 System_Private_CoreLib!System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext System.Threading.ContextCallback System.Object)+0x89
1c 00000075`fcdfe900 00007ff9`8c0d7c80 System_Private_CoreLib!System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.__Canon System.Private.CoreLib][System.__Canon System.Private.CoreLib]].MoveNext()+0xa0
1d 00000075`fcdfe970 00007ff9`8c0a4579 System_Private_CoreLib!System.Runtime.CompilerServices.TaskAwaiter+&lt;&gt;c.&lt;OutputWaitEtwEvents&gt;b__12_0(System.Action System.Threading.Tasks.Task)+0x140
1e 00000075`fcdfea00 00007ff9`8c0707a4 System_Private_CoreLib!System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(System.Action Boolean)+0x79
1f 00000075`fcdfea60 00007ff9`8c0d5d0d System_Private_CoreLib!System.Threading.Tasks.Task.RunContinuations(System.Object)+0x184
20 00000075`fcdfeb30 00007ff9`8c0b2df9 System_Private_CoreLib!System.Threading.Tasks.Task`1[[System.__Canon System.Private.CoreLib]].TrySetResult(System.__Canon)+0x2c5fd
21 00000075`fcdfeb70 00007ff9`8c18fc23 System_Private_CoreLib!System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.Int32 System.Private.CoreLib]].SetExistingTaskResult(Int32)+0xffffffff`fffda7a9
22 00000075`fcdfebb0 00007ff9`34b7235b System_Private_CoreLib!System.Runtime.CompilerServices.AsyncTaskMethodBuilder.SetResult()+0x43
23 00000075`fcdfebf0 00007ff9`8bfbcb39 StreamJsonRpc!StreamJsonRpc.ReadBufferingStream+&lt;FillBufferAsync&gt;d__27.MoveNext()+0x3ab [D:\git\streamjsonrpc\src\StreamJsonRpc\Reflection\MethodSignature.cs @ 39] 
24 00000075`fcdfece0 00007ff9`8c239200 System_Private_CoreLib!System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext System.Threading.ContextCallback System.Object)+0x89
25 00000075`fcdfed60 00007ff9`8c0d7c80 System_Private_CoreLib!System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.__Canon System.Private.CoreLib][System.__Canon System.Private.CoreLib]].MoveNext()+0x2f60
26 00000075`fcdfedd0 00007ff9`8c0a4579 System_Private_CoreLib!System.Runtime.CompilerServices.TaskAwaiter+&lt;&gt;c.&lt;OutputWaitEtwEvents&gt;b__12_0(System.Action System.Threading.Tasks.Task)+0x140
27 00000075`fcdfee60 00007ff9`8c0707a4 System_Private_CoreLib!System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(System.Action Boolean)+0x79
28 00000075`fcdfeec0 00007ff9`8c076c44 System_Private_CoreLib!System.Threading.Tasks.Task.RunContinuations(System.Object)+0x184
29 00000075`fcdfef90 00007ff9`8c0d7d14 System_Private_CoreLib!System.Threading.Tasks.Task`1[[System.__Canon System.Private.CoreLib]].TrySetResult(System.__Canon)+0xffffffff`fffcd534
2a 00000075`fcdfefd0 00007ff9`8c0d7e92 System_Private_CoreLib!System.Threading.Tasks.TaskFactory`1+FromAsyncTrimPromise`1[[System.Threading.Tasks.VoidTaskResult System.Private.CoreLib][System.__Canon System.Private.CoreLib]].Complete(System.__Canon System.Func`3&lt;System.__CanonSystem.IAsyncResultSystem.Threading.Tasks.VoidTaskResult&gt; System.IAsyncResult Boolean)+0xffffffff`ffe99854
2b 00000075`fcdff010 00007ff9`8bfbcb39 System_Private_CoreLib!System.Threading.Tasks.TaskFactory`1+FromAsyncTrimPromise`1[[System.Threading.Tasks.VoidTaskResult System.Private.CoreLib][System.__Canon System.Private.CoreLib]].CompleteFromAsyncResult(System.IAsyncResult)+0xffffffff`ffe998a2
2c 00000075`fcdff070 00007ff9`8c0707ff System_Private_CoreLib!System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext System.Threading.ContextCallback System.Object)+0x89
2d 00000075`fcdff0f0 00007ff9`8c06f52e System_Private_CoreLib!System.Threading.Tasks.Task.RunContinuations(System.Object)+0x1df
2e 00000075`fcdff1c0 00007ff9`8c0a66ac System_Private_CoreLib!System.Threading.Tasks.Task.ExecuteWithThreadLocal(System.Threading.Tasks.Task ByRef)+0x1be
2f 00000075`fcdff260 00007ff9`9461f3b3 System_Private_CoreLib!System.Threading.ThreadPoolWorkQueue.Dispatch()+0x19c
30 00000075`fcdff300 00007ff9`94589e41 coreclr!CallDescrWorkerInternal+0x83 [E:\A\_work\31\s\src\vm\amd64\CallDescrWorkerAMD64.asm @ 101] 
31 (Inline Function) --------`-------- coreclr!CallDescrWorkerWithHandler+0x53 [e:\a\_work\31\s\src\vm\callhelpers.cpp @ 78] 
32 00000075`fcdff340 00007ff9`9458933f coreclr!MethodDescCallSite::CallTargetWorker+0x2b5 [e:\a\_work\31\s\src\vm\callhelpers.cpp @ 628] 
33 (Inline Function) --------`-------- coreclr!MethodDescCallSite::Call_RetBool+0x15 [e:\a\_work\31\s\src\vm\callhelpers.h @ 433] 
34 00000075`fcdff490 00007ff9`945a37f6 coreclr!QueueUserWorkItemManagedCallback+0x7f [e:\a\_work\31\s\src\vm\comthreadpool.cpp @ 451] 
35 00000075`fcdff580 00007ff9`945a3652 coreclr!ManagedThreadBase_DispatchInner+0x5a [e:\a\_work\31\s\src\vm\threads.cpp @ 8852] 
36 00000075`fcdff5c0 00007ff9`945a3551 coreclr!ManagedThreadBase_DispatchMiddle+0x76 [e:\a\_work\31\s\src\vm\threads.cpp @ 8901] 
37 00000075`fcdff6c0 00007ff9`945a2e10 coreclr!ManagedThreadBase_DispatchOuter+0x91 [e:\a\_work\31\s\src\vm\threads.cpp @ 9140] 
38 (Inline Function) --------`-------- coreclr!ManagedThreadBase_FullTransitionWithAD+0x56 [e:\a\_work\31\s\src\vm\threads.cpp @ 9199] 
39 (Inline Function) --------`-------- coreclr!ManagedThreadBase::ThreadPool+0x56 [e:\a\_work\31\s\src\vm\threads.cpp @ 9241] 
3a 00000075`fcdff730 00007ff9`945a2695 coreclr!ManagedPerAppDomainTPCount::DispatchWorkItem+0xe0 [e:\a\_work\31\s\src\vm\threadpoolrequest.cpp @ 757] 
3b (Inline Function) --------`-------- coreclr!ThreadpoolMgr::ExecuteWorkRequest+0x47 [e:\a\_work\31\s\src\vm\win32threadpool.cpp @ 1560] 
3c 00000075`fcdff890 00007ff9`944d3678 coreclr!ThreadpoolMgr::WorkerThreadStart+0x1d5 [e:\a\_work\31\s\src\vm\win32threadpool.cpp @ 2024] 
3d 00000075`fcdffa90 00007ffa`197a3034 coreclr!Thread::intermediateThreadProc+0x88 [e:\a\_work\31\s\src\vm\threads.cpp @ 2255] 
3e 00000075`fcdffc50 00007ffa`19e01431 kernel32!BaseThreadInitThunk+0x14
3f 00000075`fcdffc80 00000000`00000000 ntdll!RtlUserThreadStart+0x21

   9  Id: 3fb4.b958 Suspend: 0 Teb: 00000075`fbb6c000 Unfrozen
 # Child-SP          RetAddr           Call Site
00 00000075`fcf7b8f8 00007ffa`19dadc63 ntdll!NtWaitForAlertByThreadId+0x14
01 00000075`fcf7b900 00007ffa`19dada64 ntdll!RtlpWaitOnAddressWithTimeout+0x43
02 00000075`fcf7b930 00007ffa`19da83e7 ntdll!RtlpWaitOnCriticalSection+0x164
03 00000075`fcf7b9e0 00007ffa`19da8300 ntdll!RtlpEnterCriticalSectionContended+0xd7
04 00000075`fcf7ba10 00007ff9`944e19b3 ntdll!RtlEnterCriticalSection+0x40
05 (Inline Function) --------`-------- coreclr!UnsafeEnterCriticalSection+0x9 [e:\a\_work\31\s\src\inc\unsafe.h @ 19] 
06 00000075`fcf7ba40 00007ff9`94518fad coreclr!CrstBase::Enter+0x67 [e:\a\_work\31\s\src\vm\crst.cpp @ 319] 
07 00000075`fcf7ba80 00007ff9`948eb919 coreclr!Debugger::DoNotCallDirectlyPrivateLock+0x39 [e:\a\_work\31\s\src\debug\ee\debugger.cpp @ 365] 
08 (Inline Function) --------`-------- coreclr!Debugger::AcquireDebuggerLock+0x5 [e:\a\_work\31\s\src\debug\ee\debugger.h @ 2313] 
09 (Inline Function) --------`-------- coreclr!FunctionBase&lt;Debugger *&amp;Debugger::AcquireDebuggerLock&amp;Debugger::ReleaseDebuggerLock2&gt;::DoAcquire+0x5 [e:\a\_work\31\s\src\inc\holder.h @ 750] 
0a (Inline Function) --------`-------- coreclr!BaseHolder&lt;Debugger *FunctionBase&lt;Debugger *&amp;Debugger::AcquireDebuggerLock&amp;Debugger::ReleaseDebuggerLock2&gt;0&amp;CompareDefault&lt;Debugger *&gt;2&gt;::Acquire+0xd [e:\a\_work\31\s\src\inc\holder.h @ 296] 
0b 00000075`fcf7bab0 00007ff9`948ea26b coreclr!Debugger::LockForEventSending+0x25 [e:\a\_work\31\s\src\debug\ee\debugger.cpp @ 6467] 
0c 00000075`fcf7bae0 00007ff9`947b09cb coreclr!Debugger::LoadClass+0x7b [e:\a\_work\31\s\src\debug\ee\debugger.cpp @ 10210] 
0d 00000075`fcf7bb50 00007ff9`9466df7b coreclr!TypeHandle::NotifyDebuggerLoad+0x127 [e:\a\_work\31\s\src\vm\class.cpp @ 1539] 
0e 00000075`fcf7bb90 00007ff9`94508622 coreclr!ClassLoader::LoadTypeHandleForTypeKey_Body+0x16876b [e:\a\_work\31\s\src\vm\clsload.cpp @ 4325] 
0f 00000075`fcf7c7e0 00007ff9`9458ae5b coreclr!ClassLoader::LoadTypeHandleForTypeKey+0x9e [e:\a\_work\31\s\src\vm\clsload.cpp @ 4044] 
10 00000075`fcf7c870 00007ff9`9458d912 coreclr!ClassLoader::LoadTypeDefThrowing+0x24b [e:\a\_work\31\s\src\vm\clsload.cpp @ 2887] 
11 00000075`fcf7ca40 00007ff9`9458c6ae coreclr!ClassLoader::LoadTypeDefOrRefThrowing+0x442 [e:\a\_work\31\s\src\vm\clsload.cpp @ 3065] 
12 00000075`fcf7cb90 00007ff9`9452470c coreclr!SigPointer::GetTypeHandleThrowing+0x79e [e:\a\_work\31\s\src\vm\siginfo.cpp @ 1507] 
13 00000075`fcf7cf00 00007ff9`bfb18a5c coreclr!CEEInfo::getArgClass+0x1bc [e:\a\_work\31\s\src\vm\jitinterface.cpp @ 9688] 
14 00000075`fcf7d0d0 00007ff9`bfb1a2d0 clrjit!Compiler::lvaInitTypeRef+0x3ac [e:\a\_work\31\s\src\jit\lclvars.cpp @ 262] 
15 00000075`fcf7d170 00007ff9`bfb1a703 clrjit!Compiler::compCompileHelper+0x1d0 [e:\a\_work\31\s\src\jit\compiler.cpp @ 6116] 
16 00000075`fcf7d220 00007ff9`bfb09347 clrjit!Compiler::compCompile+0x253 [e:\a\_work\31\s\src\jit\compiler.cpp @ 5599] 
17 00000075`fcf7d2e0 00007ff9`bfb09d62 clrjit!jitNativeCode+0x267 [e:\a\_work\31\s\src\jit\compiler.cpp @ 6908] 
18 00000075`fcf7d4a0 00007ff9`945190e9 clrjit!CILJit::compileMethod+0xa2 [e:\a\_work\31\s\src\jit\ee_il_dll.cpp @ 303] 
19 (Inline Function) --------`-------- coreclr!invokeCompileMethodHelper+0x6b [e:\a\_work\31\s\src\vm\jitinterface.cpp @ 12187] 
1a 00000075`fcf7d510 00007ff9`94517e12 coreclr!invokeCompileMethod+0xe5 [e:\a\_work\31\s\src\vm\jitinterface.cpp @ 12254] 
1b 00000075`fcf7d5a0 00007ff9`944ed178 coreclr!CallCompileMethodWithSEHWrapper+0x52 [e:\a\_work\31\s\src\vm\jitinterface.cpp @ 12306] 
1c 00000075`fcf7d630 00007ff9`94596272 coreclr!UnsafeJitFunction+0x4e8 [e:\a\_work\31\s\src\vm\jitinterface.cpp @ 12803] 
1d 00000075`fcf7dc00 00007ff9`946ae8fd coreclr!MethodDesc::JitCompileCodeLocked+0x1fe [e:\a\_work\31\s\src\vm\prestub.cpp @ 841] 
1e 00000075`fcf7dda0 00007ff9`945966ee coreclr!MethodDesc::JitCompileCodeLockedEventWrapper+0x118b39 [e:\a\_work\31\s\src\vm\prestub.cpp @ 716] 
1f 00000075`fcf7dec0 00007ff9`945956e8 coreclr!MethodDesc::JitCompileCode+0x36e [e:\a\_work\31\s\src\vm\prestub.cpp @ 636] 
20 (Inline Function) --------`-------- coreclr!MethodDesc::PrepareILBasedCode+0x13a [e:\a\_work\31\s\src\vm\prestub.cpp @ 310] 
21 (Inline Function) --------`-------- coreclr!MethodDesc::PrepareCode+0x13a [e:\a\_work\31\s\src\vm\prestub.cpp @ 292] 
22 (Inline Function) --------`-------- coreclr!MethodDesc::PrepareInitialCode+0x163 [e:\a\_work\31\s\src\vm\prestub.cpp @ 248] 
23 00000075`fcf7dfc0 00007ff9`9450ba1a coreclr!MethodDesc::DoPrestub+0x5b8 [e:\a\_work\31\s\src\vm\prestub.cpp @ 1812] 
24 00000075`fcf7e110 00007ff9`9461e955 coreclr!PreStubWorker+0x37a [e:\a\_work\31\s\src\vm\prestub.cpp @ 1548] 
25 00000075`fcf7e3a0 00007ff9`8c0c1d25 coreclr!ThePreStub+0x55 [E:\A\_work\31\s\src\vm\amd64\ThePreStubAMD64.asm @ 22] 
26 00000075`fcf7e450 00007ff9`8c0958e0 System_Private_CoreLib!System.Threading.CancellationTokenSource.InternalRegister(System.Action`1&lt;System.Object&gt; System.Object System.Threading.SynchronizationContext System.Threading.ExecutionContext)+0x2c5
27 00000075`fcf7e4e0 00007ff9`8c095813 System_Private_CoreLib!System.Threading.CancellationToken.Register(System.Action`1&lt;System.Object&gt; System.Object Boolean Boolean)+0x90
28 00000075`fcf7e550 00007ff9`34b75ae1 System_Private_CoreLib!System.Threading.CancellationToken.Register(System.Action`1&lt;System.Object&gt; System.Object Boolean)+0x23
29 00000075`fcf7e590 00007ff9`8bfbcb39 StreamJsonRpc!StreamJsonRpc.JsonRpc+&lt;InvokeCoreAsync&gt;d__89`1[[System.__Canon System.Private.CoreLib]].MoveNext()+0xdd1 [D:\git\streamjsonrpc\src\StreamJsonRpc\JsonRpc.cs @ 948] 
2a 00000075`fcf7e950 00007ff9`8c236340 System_Private_CoreLib!System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext System.Threading.ContextCallback System.Object)+0x89
2b 00000075`fcf7e9d0 00007ff9`8c0d7c80 System_Private_CoreLib!System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.__Canon System.Private.CoreLib][System.__Canon System.Private.CoreLib]].MoveNext()+0xa0
2c 00000075`fcf7ea40 00007ff9`8c0a4579 System_Private_CoreLib!System.Runtime.CompilerServices.TaskAwaiter+&lt;&gt;c.&lt;OutputWaitEtwEvents&gt;b__12_0(System.Action System.Threading.Tasks.Task)+0x140
2d 00000075`fcf7ead0 00007ff9`8c0707a4 System_Private_CoreLib!System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(System.Action Boolean)+0x79
2e 00000075`fcf7eb30 00007ff9`8c0d5d0d System_Private_CoreLib!System.Threading.Tasks.Task.RunContinuations(System.Object)+0x184
2f 00000075`fcf7ec00 00007ff9`8c0b2df9 System_Private_CoreLib!System.Threading.Tasks.Task`1[[System.__Canon System.Private.CoreLib]].TrySetResult(System.__Canon)+0x2c5fd
30 00000075`fcf7ec40 00007ff9`8c18fc23 System_Private_CoreLib!System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.Int32 System.Private.CoreLib]].SetExistingTaskResult(Int32)+0xffffffff`fffda7a9
31 00000075`fcf7ec80 00007ff9`34ba7792 System_Private_CoreLib!System.Runtime.CompilerServices.AsyncTaskMethodBuilder.SetResult()+0x43
32 00000075`fcf7ecc0 00007ff9`8bfbcb39 StreamJsonRpc!StreamJsonRpc.DelimitedMessageHandler+&lt;WriteAsync&gt;d__23.MoveNext()+0x742 [D:\git\streamjsonrpc\src\StreamJsonRpc\HeaderDelimitedMessageHandler.cs @ 93] 
33 00000075`fcf7eea0 00007ff9`8c239200 System_Private_CoreLib!System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext System.Threading.ContextCallback System.Object)+0x89
34 00000075`fcf7ef20 00007ff9`8c0d7c80 System_Private_CoreLib!System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.__Canon System.Private.CoreLib][System.__Canon System.Private.CoreLib]].MoveNext()+0x2f60
35 00000075`fcf7ef90 00007ff9`8c0a4579 System_Private_CoreLib!System.Runtime.CompilerServices.TaskAwaiter+&lt;&gt;c.&lt;OutputWaitEtwEvents&gt;b__12_0(System.Action System.Threading.Tasks.Task)+0x140
36 00000075`fcf7f020 00007ff9`8c0707a4 System_Private_CoreLib!System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(System.Action Boolean)+0x79
37 00000075`fcf7f080 00007ff9`8c06f52e System_Private_CoreLib!System.Threading.Tasks.Task.RunContinuations(System.Object)+0x184
38 00000075`fcf7f150 00007ff9`8c0a66ac System_Private_CoreLib!System.Threading.Tasks.Task.ExecuteWithThreadLocal(System.Threading.Tasks.Task ByRef)+0x1be
39 00000075`fcf7f1f0 00007ff9`9461f3b3 System_Private_CoreLib!System.Threading.ThreadPoolWorkQueue.Dispatch()+0x19c
3a 00000075`fcf7f290 00007ff9`94589e41 coreclr!CallDescrWorkerInternal+0x83 [E:\A\_work\31\s\src\vm\amd64\CallDescrWorkerAMD64.asm @ 101] 
3b (Inline Function) --------`-------- coreclr!CallDescrWorkerWithHandler+0x53 [e:\a\_work\31\s\src\vm\callhelpers.cpp @ 78] 
3c 00000075`fcf7f2d0 00007ff9`9458933f coreclr!MethodDescCallSite::CallTargetWorker+0x2b5 [e:\a\_work\31\s\src\vm\callhelpers.cpp @ 628] 
3d (Inline Function) --------`-------- coreclr!MethodDescCallSite::Call_RetBool+0x15 [e:\a\_work\31\s\src\vm\callhelpers.h @ 433] 
3e 00000075`fcf7f420 00007ff9`945a37f6 coreclr!QueueUserWorkItemManagedCallback+0x7f [e:\a\_work\31\s\src\vm\comthreadpool.cpp @ 451] 
3f 00000075`fcf7f510 00007ff9`945a3652 coreclr!ManagedThreadBase_DispatchInner+0x5a [e:\a\_work\31\s\src\vm\threads.cpp @ 8852] 
40 00000075`fcf7f550 00007ff9`945a3551 coreclr!ManagedThreadBase_DispatchMiddle+0x76 [e:\a\_work\31\s\src\vm\threads.cpp @ 8901] 
41 00000075`fcf7f650 00007ff9`945a2e10 coreclr!ManagedThreadBase_DispatchOuter+0x91 [e:\a\_work\31\s\src\vm\threads.cpp @ 9140] 
42 (Inline Function) --------`-------- coreclr!ManagedThreadBase_FullTransitionWithAD+0x56 [e:\a\_work\31\s\src\vm\threads.cpp @ 9199] 
43 (Inline Function) --------`-------- coreclr!ManagedThreadBase::ThreadPool+0x56 [e:\a\_work\31\s\src\vm\threads.cpp @ 9241] 
44 00000075`fcf7f6c0 00007ff9`945a2695 coreclr!ManagedPerAppDomainTPCount::DispatchWorkItem+0xe0 [e:\a\_work\31\s\src\vm\threadpoolrequest.cpp @ 757] 
45 (Inline Function) --------`-------- coreclr!ThreadpoolMgr::ExecuteWorkRequest+0x47 [e:\a\_work\31\s\src\vm\win32threadpool.cpp @ 1560] 
46 00000075`fcf7f820 00007ff9`944d3678 coreclr!ThreadpoolMgr::WorkerThreadStart+0x1d5 [e:\a\_work\31\s\src\vm\win32threadpool.cpp @ 2024] 
47 00000075`fcf7fa20 00007ffa`197a3034 coreclr!Thread::intermediateThreadProc+0x88 [e:\a\_work\31\s\src\vm\threads.cpp @ 2255] 
48 00000075`fcf7fc60 00007ffa`19e01431 kernel32!BaseThreadInitThunk+0x14
49 00000075`fcf7fc90 00000000`00000000 ntdll!RtlUserThreadStart+0x21
```</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>AArnott</Assignee>
    <CreatedAt>27/06/2018 11:42:50 PM +00:00</CreatedAt>
    <ClosedAt>25/02/2019 7:03:21 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18679</IssueLabelID>
    <Title>JIT: look at cost impact of assertion dup detection</Title>
    <Description>More follow on from #18327.

When we generate new assertions we check to see if they're duplicates. If so we don't need to record them. Data from PMI shows that about 75% of generated assertions are duplicates.

The check does a linear scan against the existing assertion table which is potentially costly and this cost would grow if we start recording all or more assertions as proposed in #18678.

Profiling (crossgen x64 of Microsoft.CodeAnalysis.VisualBasic.dll) suggests `optAddAssertion` gets inlined and it currently represents perhaps ~1% of the time spent in the jit. (Assertion prop as whole is about 5%).

category:throughput
theme:assertion-prop
skill-level:intermediate
cost:medium</Description>
    <Title_Description>JIT: look at cost impact of assertion dup detection More follow on from #18327.

When we generate new assertions we check to see if they're duplicates. If so we don't need to record them. Data from PMI shows that about 75% of generated assertions are duplicates.

The check does a linear scan against the existing assertion table which is potentially costly and this cost would grow if we start recording all or more assertions as proposed in #18678.

Profiling (crossgen x64 of Microsoft.CodeAnalysis.VisualBasic.dll) suggests `optAddAssertion` gets inlined and it currently represents perhaps ~1% of the time spent in the jit. (Assertion prop as whole is about 5%).

category:throughput
theme:assertion-prop
skill-level:intermediate
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
    <CreatedAt>27/06/2018 10:55:34 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18678</IssueLabelID>
    <Title>JIT: possibly revisit how we set assertion prop table size</Title>
    <Description>Some data on how often we drop assertions (from investigations into #18327 via pmi over fx):

Table Size | Num Methods | Avg Assertion Count | Methods with Dropped Assertions 
----- | -------: | --------: | ----:
64 | 159493 | 4.6 | 222
128 | 1801 | 42.3 | 28
256 | 237 | 81.2 | 4

Overall this doesn't seem too bad -- only about 0.16% of methods lost assertions from table size limits. I unfortunately didn't track how many of the size 64 cases were ones where we deliberately limited the size for throughput reasons.

Table size is determined by looking at `compILCodeSize` which will not take additions from inlining into account (among other things). So it seems like we perhaps could find a better size predictor.

Or perhaps just allow the table to grow? 

Here's a breakdown of how many methods would fit into our existing size bins:

Assertion Count | Methods 
--- | ----:
0 - 64  |  161835 
65 - 128 | 585 
129 - 256 | 104 
 more than 256 | 21

Max number of assertions seen was 615 (in a method that used a size 64 table) in `Microsoft.CodeAnalysis.VisualBasic.VisualBasicCommandLineParser:Parse(refrefrefref):ref:this`. So 551 of these were dropped.

There is obviously some consideration of the overall cost of the subsequent dataflow analysis too which is roughly proportional to max assertion size * number of blocks. So if we allow max assertion size to scale up with blocks we potentially see some quadratic behavior. But this seems perhaps solvable too -- we generate all (or more) assertions initially and then only limit the ones we use if we see bad scaling.

This might let us also try and prioritize which assertions should survive though I don't have any particular idea yet how to formulate that (something like the value number equivalent of weighted ref count usage ...?).

Note today we actually generate all assertions. Assertion gen doesn't early out once the table is full (though perhaps it should). It just stops recording assertions once the table fills up. So we are already paying the cost of finding all these assertions. And the table size itself is not a burden

So a rough proposal would be to find and record all assertions -- allowing the table to grow larger (with perhaps some size limit) and have a budget based on blocks * assertions and if over budget start trimming assertions somehow to get under budget.



category:implementation
theme:assertion-prop
skill-level:intermediate
cost:medium</Description>
    <Title_Description>JIT: possibly revisit how we set assertion prop table size Some data on how often we drop assertions (from investigations into #18327 via pmi over fx):

Table Size | Num Methods | Avg Assertion Count | Methods with Dropped Assertions 
----- | -------: | --------: | ----:
64 | 159493 | 4.6 | 222
128 | 1801 | 42.3 | 28
256 | 237 | 81.2 | 4

Overall this doesn't seem too bad -- only about 0.16% of methods lost assertions from table size limits. I unfortunately didn't track how many of the size 64 cases were ones where we deliberately limited the size for throughput reasons.

Table size is determined by looking at `compILCodeSize` which will not take additions from inlining into account (among other things). So it seems like we perhaps could find a better size predictor.

Or perhaps just allow the table to grow? 

Here's a breakdown of how many methods would fit into our existing size bins:

Assertion Count | Methods 
--- | ----:
0 - 64  |  161835 
65 - 128 | 585 
129 - 256 | 104 
 more than 256 | 21

Max number of assertions seen was 615 (in a method that used a size 64 table) in `Microsoft.CodeAnalysis.VisualBasic.VisualBasicCommandLineParser:Parse(refrefrefref):ref:this`. So 551 of these were dropped.

There is obviously some consideration of the overall cost of the subsequent dataflow analysis too which is roughly proportional to max assertion size * number of blocks. So if we allow max assertion size to scale up with blocks we potentially see some quadratic behavior. But this seems perhaps solvable too -- we generate all (or more) assertions initially and then only limit the ones we use if we see bad scaling.

This might let us also try and prioritize which assertions should survive though I don't have any particular idea yet how to formulate that (something like the value number equivalent of weighted ref count usage ...?).

Note today we actually generate all assertions. Assertion gen doesn't early out once the table is full (though perhaps it should). It just stops recording assertions once the table fills up. So we are already paying the cost of finding all these assertions. And the table size itself is not a burden

So a rough proposal would be to find and record all assertions -- allowing the table to grow larger (with perhaps some size limit) and have a budget based on blocks * assertions and if over budget start trimming assertions somehow to get under budget.



category:implementation
theme:assertion-prop
skill-level:intermediate
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
    <CreatedAt>27/06/2018 10:28:42 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18677</IssueLabelID>
    <Title>Re-enable Test Logs and build only test host in CoreFX CI jobs</Title>
    <Description>#18365 has been merged so logging can be reenabled. Additionally this builds only the components required to build CoreFX tests.</Description>
    <Title_Description>Re-enable Test Logs and build only test host in CoreFX CI jobs #18365 has been merged so logging can be reenabled. Additionally this builds only the components required to build CoreFX tests.</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>A-And</Assignee>
    <CreatedAt>27/06/2018 9:43:45 PM +00:00</CreatedAt>
    <ClosedAt>27/06/2018 11:23:38 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18676</IssueLabelID>
    <Title>[NO MERGE] Add crossgen_equivalence scenario to netci.groovy</Title>
    <Description>**NO MERGE**</Description>
    <Title_Description>[NO MERGE] Add crossgen_equivalence scenario to netci.groovy **NO MERGE**</Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>echesakovMSFT</Assignee>
    <CreatedAt>27/06/2018 9:42:55 PM +00:00</CreatedAt>
    <ClosedAt>11/07/2018 6:04:43 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18675</IssueLabelID>
    <Title>Add additional PInvoke tests to coreclr</Title>
    <Description>The PInvoke scenario surface area is large and the coreclr repo doesn't have coverage that would be considered adequate. Missing areas (not exhaustive):

- Arrays
- SafeHandles
- CriticalHandles
- DllImport searching with UNICODE characters

</Description>
    <Title_Description>Add additional PInvoke tests to coreclr The PInvoke scenario surface area is large and the coreclr repo doesn't have coverage that would be considered adequate. Missing areas (not exhaustive):

- Arrays
- SafeHandles
- CriticalHandles
- DllImport searching with UNICODE characters

</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jkoritzinsky</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18674</IssueLabelID>
    <Title>.NET COM server tests</Title>
    <Description>Testing for scenarios when a coreclr application is a COM server should exist</Description>
    <Title_Description>.NET COM server tests Testing for scenarios when a coreclr application is a COM server should exist</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>27/06/2018 8:50:42 PM +00:00</CreatedAt>
    <ClosedAt>11/09/2018 12:25:40 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18673</IssueLabelID>
    <Title>.NET COM client tests</Title>
    <Description>Testing for scenarios when a coreclr application is a COM client should exist</Description>
    <Title_Description>.NET COM client tests Testing for scenarios when a coreclr application is a COM client should exist</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>27/06/2018 8:48:48 PM +00:00</CreatedAt>
    <ClosedAt>19/07/2018 12:53:42 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18672</IssueLabelID>
    <Title>Wrong constant propagation on Linux in release</Title>
    <Description>On Linux in release the following program outputs `1` in debug but `0` in release:
```csharp
using System.Runtime.CompilerServices;

struct S1
{
}

struct S3
{
    public int F1;
    public ulong F2;
    public S1 F6;
    public S3(int f1 S1 f6): this()
    {
        F1 = f1;
        F6 = f6;
    }
}

struct S5
{
    public S3 F0;
    public S5(S3 f0): this()
    {
        F0 = f0;
    }
}

public class Program
{
    public static void Main()
    {
        S5 vr13 = new S5(new S3(1 new S1()));
        int vr14 = vr13.F0.F1;
        M();
        System.Console.WriteLine(vr14); // 1 in debug 0 in release
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    private static void M(){}
}
```

I'm not 100% sure that this isn't the same as #18259 however this only reproduces on Linux so there is definitely something different here.</Description>
    <Title_Description>Wrong constant propagation on Linux in release On Linux in release the following program outputs `1` in debug but `0` in release:
```csharp
using System.Runtime.CompilerServices;

struct S1
{
}

struct S3
{
    public int F1;
    public ulong F2;
    public S1 F6;
    public S3(int f1 S1 f6): this()
    {
        F1 = f1;
        F6 = f6;
    }
}

struct S5
{
    public S3 F0;
    public S5(S3 f0): this()
    {
        F0 = f0;
    }
}

public class Program
{
    public static void Main()
    {
        S5 vr13 = new S5(new S3(1 new S1()));
        int vr14 = vr13.F0.F1;
        M();
        System.Console.WriteLine(vr14); // 1 in debug 0 in release
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    private static void M(){}
}
```

I'm not 100% sure that this isn't the same as #18259 however this only reproduces on Linux so there is definitely something different here.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>briansull</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18671</IssueLabelID>
    <Title>Add Public implementation RemoveEventHandler in EventRegistrationTokenTable</Title>
    <Description>Add a public implementation API GetEventHandlerFromEventRegistrationToken for System.runtime.WindowsRuntime to consume instead of using FriendAccessAllowed/InternalVisiable

Corefx PR:https://github.com/dotnet/corefx/pull/30699
</Description>
    <Title_Description>Add Public implementation RemoveEventHandler in EventRegistrationTokenTable Add a public implementation API GetEventHandlerFromEventRegistrationToken for System.runtime.WindowsRuntime to consume instead of using FriendAccessAllowed/InternalVisiable

Corefx PR:https://github.com/dotnet/corefx/pull/30699
</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>luqunl</Assignee>
    <CreatedAt>27/06/2018 5:54:14 PM +00:00</CreatedAt>
    <ClosedAt>27/06/2018 11:13:11 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18661</IssueLabelID>
    <Title>Remove Conditional Compilation of Generated DotNETRuntimeEventSource.cs</Title>
    <Description>Build scripts and/or project files need to be fixed so that the conditional compilation of DotNETRuntimeEventSource.cs can be replaced with an unconditional compilation.  Otherwise we risk ending up with a build System.Private.CoreLib.dll that doesn't contain the contents of DotNETRuntimeEventSource.cs.

The line of interest is here: https://github.com/dotnet/coreclr/blob/master/src/System.Private.CoreLib/System.Private.CoreLib.csproj#L446.</Description>
    <Title_Description>Remove Conditional Compilation of Generated DotNETRuntimeEventSource.cs Build scripts and/or project files need to be fixed so that the conditional compilation of DotNETRuntimeEventSource.cs can be replaced with an unconditional compilation.  Otherwise we risk ending up with a build System.Private.CoreLib.dll that doesn't contain the contents of DotNETRuntimeEventSource.cs.

The line of interest is here: https://github.com/dotnet/coreclr/blob/master/src/System.Private.CoreLib/System.Private.CoreLib.csproj#L446.</Title_Description>
    <Label>area-Tracing</Label>
    <Assignee>brianrob</Assignee>
    <CreatedAt>26/06/2018 11:01:27 PM +00:00</CreatedAt>
    <ClosedAt>27/06/2018 6:19:39 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18659</IssueLabelID>
    <Title>Provide a Mechanism to Stream Events Out-of-Process from EventPipe</Title>
    <Description>Provide a mechanism to consume events in real time from EventPipe out-of-process.</Description>
    <Title_Description>Provide a Mechanism to Stream Events Out-of-Process from EventPipe Provide a mechanism to consume events in real time from EventPipe out-of-process.</Title_Description>
    <Label>EventPipe</Label>
    <Assignee>jorive</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18658</IssueLabelID>
    <Title>Provide an Out-of-Process Control Mechanism for EventPipe</Title>
    <Description>Right now EventPipe is only controllable via environment variables and private reflection.  We should add an out-of-process control mechanism to significantly improve usability.</Description>
    <Title_Description>Provide an Out-of-Process Control Mechanism for EventPipe Right now EventPipe is only controllable via environment variables and private reflection.  We should add an out-of-process control mechanism to significantly improve usability.</Title_Description>
    <Label>EventPipe</Label>
    <Assignee>jorive</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18656</IssueLabelID>
    <Title>Use IBC to Drive Partial NGEN and Tiered Compilation Behavior</Title>
    <Description>Now that we have tiered compilation in .NET Core we should look for ways to use it to get fast start-up great throughput at steady state and improvements to size-on-disk.

Consider this a tracking item that should be used to drive a plan here.</Description>
    <Title_Description>Use IBC to Drive Partial NGEN and Tiered Compilation Behavior Now that we have tiered compilation in .NET Core we should look for ways to use it to get fast start-up great throughput at steady state and improvements to size-on-disk.

Consider this a tracking item that should be used to drive a plan here.</Title_Description>
    <Label>area-ReadyToRun</Label>
    <Assignee>brianrob</Assignee>
    <CreatedAt>26/06/2018 10:11:31 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18655</IssueLabelID>
    <Title>Enable IBC Optimization on System.Private.CoreLib</Title>
    <Description>
    </Description>
    <Title_Description>Enable IBC Optimization on System.Private.CoreLib </Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>brianrob</Assignee>
    <CreatedAt>26/06/2018 10:05:14 PM +00:00</CreatedAt>
    <ClosedAt>30/04/2019 7:56:15 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18654</IssueLabelID>
    <Title>Enable PGO Optimization for More Platforms / Architectures</Title>
    <Description>The following platforms currently don't get PGO optimized.

 - Windows arm32
 - Windows arm64
 - Linux arm32
 - Linux arm64
 - OSX x64</Description>
    <Title_Description>Enable PGO Optimization for More Platforms / Architectures The following platforms currently don't get PGO optimized.

 - Windows arm32
 - Windows arm64
 - Linux arm32
 - Linux arm64
 - OSX x64</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>brianrob</Assignee>
    <CreatedAt>26/06/2018 10:04:14 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18652</IssueLabelID>
    <Title>Add LastIndexOf compareoptions overload</Title>
    <Description>Relates to https://github.com/dotnet/corefx/issues/30649

I mostly copied the existing implementations and changed to FIND_FROMEND. Please let me know if something is missing here.</Description>
    <Title_Description>Add LastIndexOf compareoptions overload Relates to https://github.com/dotnet/corefx/issues/30649

I mostly copied the existing implementations and changed to FIND_FROMEND. Please let me know if something is missing here.</Title_Description>
    <Label>area-System.Memory</Label>
    <Assignee>ViktorHofer</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18650</IssueLabelID>
    <Title>[NO MERGE] Dummy PR for testing</Title>
    <Description>**NO MERGE**</Description>
    <Title_Description>[NO MERGE] Dummy PR for testing **NO MERGE**</Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>echesakovMSFT</Assignee>
    <CreatedAt>26/06/2018 5:30:20 PM +00:00</CreatedAt>
    <ClosedAt>17/07/2018 3:49:08 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18648</IssueLabelID>
    <Title>Misuse of optPrepareTreeForReplacement leads to incorrect exception thrown in release</Title>
    <Description>This example incorrectly throws an exception in release:
```csharp
// Generated by Fuzzlyn on 2018-06-26 16:32:41
// Seed: 3807292053929899503
// Reduced from 119.1 KiB to 0.2 KiB
// Debug: Runs successfully
// Release: Throws 'System.NullReferenceException'
public class Program
{
    static ushort[ ] s_1 = new ushort[ ]{{0}};
    public static void Main()
    {
        bool vr5 = 0 == ((0 % ((0 &amp; s_1[0 0]) | 1)) * s_1[0 0]);
    }
}
```

@mikedn has analyzed the cause [here](https://github.com/dotnet/coreclr/pull/18257#issuecomment-400360920):
&gt; Uh oh it's a different issue but in the same area. This PR basically fixes `optPrepareTreeForReplacement` (by fixing `gtExtractSideEffList`) but then it turns out that there are cases where `optPrepareTreeForReplacement` is misused.
&gt; 
&gt; It's really baffling optVNConstantPropOnTree calls optPrepareTreeForReplacement(tree tree) and then changes tree to a constant. In this case
&gt; 
&gt; * `tree` is `MOD` so itself ends up as a side effect
&gt; * `tree` is changed to a constant so the entire side effect subtree simply vanishes
&gt; * `newTree` is a COMMA where both op1 and op2 point to the same constant node
&gt; 
&gt; I'm surprised that this doesn't blow up more often and more spectacularly!</Description>
    <Title_Description>Misuse of optPrepareTreeForReplacement leads to incorrect exception thrown in release This example incorrectly throws an exception in release:
```csharp
// Generated by Fuzzlyn on 2018-06-26 16:32:41
// Seed: 3807292053929899503
// Reduced from 119.1 KiB to 0.2 KiB
// Debug: Runs successfully
// Release: Throws 'System.NullReferenceException'
public class Program
{
    static ushort[ ] s_1 = new ushort[ ]{{0}};
    public static void Main()
    {
        bool vr5 = 0 == ((0 % ((0 &amp; s_1[0 0]) | 1)) * s_1[0 0]);
    }
}
```

@mikedn has analyzed the cause [here](https://github.com/dotnet/coreclr/pull/18257#issuecomment-400360920):
&gt; Uh oh it's a different issue but in the same area. This PR basically fixes `optPrepareTreeForReplacement` (by fixing `gtExtractSideEffList`) but then it turns out that there are cases where `optPrepareTreeForReplacement` is misused.
&gt; 
&gt; It's really baffling optVNConstantPropOnTree calls optPrepareTreeForReplacement(tree tree) and then changes tree to a constant. In this case
&gt; 
&gt; * `tree` is `MOD` so itself ends up as a side effect
&gt; * `tree` is changed to a constant so the entire side effect subtree simply vanishes
&gt; * `newTree` is a COMMA where both op1 and op2 point to the same constant node
&gt; 
&gt; I'm surprised that this doesn't blow up more often and more spectacularly!</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>mikedn</Assignee>
    <CreatedAt>26/06/2018 4:29:32 PM +00:00</CreatedAt>
    <ClosedAt>26/06/2018 9:38:14 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18643</IssueLabelID>
    <Title>Community Slack engagement story needs work</Title>
    <Description>*[I'm writing this in story form as I believe it's important you look at this through the proper lens]*

# Story time
So put on your new user hat. 🤠 

You want to engage with the CoreCLR community and figure out why you can't debug CoreCLR. You hit the engagement documentation (https://github.com/dotnet/coreclr/blob/master/Documentation/workflow/IssuesFeedbackEngagement.md).

The CoreCLR repository documentation reels you in with a "chat with the community" heading and a badge that shows there's 6517 registered users on Slack. Wow! Sounds great! You click this badge.

Now you're whisked away to some random blog (tattoocoder) where it indicates 7091 users. Hm okay whatever. I'm daring I'll type my email into this random blog widget.

You continue through Slack's awful user flow where it notifies you that you're joining the .NET Slack. Great! But hosted at... aspnetcore.slack.com. You don't care about aspnet. But you continue anyway.

You join the slack and get plopped into the #general channel with no further guidance. You go through the Slack tutorial for the 100th time and remember there are channels. You join the CoreCLR channel and there's only 286 people. You begin to question if everything you did was for nothing ... 

And end scene. 🦑 

# Suggestions

* Make it clear the Slack is or isn't official (it's not clear)
* Set some expectations -- do core maintainers hang out in here? should I use Slack over Gitter for certain scenarios?
* Rename the Slack name/URLs to make sense (https://get.slack.help/hc/en-us/articles/201663443-Change-your-workspace-or-org-name-and-URL)
* Welcome users with a map ([perhaps with custom code](https://api.slack.com/best-practices/blueprints/new-user-notification) or a [simple bot](https://greetbot.io/))

# Dog Tax

![image](https://user-images.githubusercontent.com/475132/41888633-5501900a-78bb-11e8-803a-b66bd988117d.png)

cc: @spboyer 
</Description>
    <Title_Description>Community Slack engagement story needs work *[I'm writing this in story form as I believe it's important you look at this through the proper lens]*

# Story time
So put on your new user hat. 🤠 

You want to engage with the CoreCLR community and figure out why you can't debug CoreCLR. You hit the engagement documentation (https://github.com/dotnet/coreclr/blob/master/Documentation/workflow/IssuesFeedbackEngagement.md).

The CoreCLR repository documentation reels you in with a "chat with the community" heading and a badge that shows there's 6517 registered users on Slack. Wow! Sounds great! You click this badge.

Now you're whisked away to some random blog (tattoocoder) where it indicates 7091 users. Hm okay whatever. I'm daring I'll type my email into this random blog widget.

You continue through Slack's awful user flow where it notifies you that you're joining the .NET Slack. Great! But hosted at... aspnetcore.slack.com. You don't care about aspnet. But you continue anyway.

You join the slack and get plopped into the #general channel with no further guidance. You go through the Slack tutorial for the 100th time and remember there are channels. You join the CoreCLR channel and there's only 286 people. You begin to question if everything you did was for nothing ... 

And end scene. 🦑 

# Suggestions

* Make it clear the Slack is or isn't official (it's not clear)
* Set some expectations -- do core maintainers hang out in here? should I use Slack over Gitter for certain scenarios?
* Rename the Slack name/URLs to make sense (https://get.slack.help/hc/en-us/articles/201663443-Change-your-workspace-or-org-name-and-URL)
* Welcome users with a map ([perhaps with custom code](https://api.slack.com/best-practices/blueprints/new-user-notification) or a [simple bot](https://greetbot.io/))

# Dog Tax

![image](https://user-images.githubusercontent.com/475132/41888633-5501900a-78bb-11e8-803a-b66bd988117d.png)

cc: @spboyer 
</Title_Description>
    <Label>documentation</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>26/06/2018 4:04:37 AM +00:00</CreatedAt>
    <ClosedAt>26/06/2018 1:52:49 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18642</IssueLabelID>
    <Title>ARM: change reserved register (REG_OPT_RSVD) to LR</Title>
    <Description>Currently `REG_OPT_RSVD` is defined as R10. This is a preserved register which means if we need to reserve it we also need to save/restore it in the prolog/epilog.

Can we change this to scratch register LR instead to avoid this?

(We can't obviously use the other scratch register R12 because it is used in some special cases such as VSD dispatch.)
</Description>
    <Title_Description>ARM: change reserved register (REG_OPT_RSVD) to LR Currently `REG_OPT_RSVD` is defined as R10. This is a preserved register which means if we need to reserve it we also need to save/restore it in the prolog/epilog.

Can we change this to scratch register LR instead to avoid this?

(We can't obviously use the other scratch register R12 because it is used in some special cases such as VSD dispatch.)
</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>BruceForstall</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18641</IssueLabelID>
    <Title>Allow setting COR_PRF_ENABLE_REJIT after runtime startup</Title>
    <Description>It would useful to allow ReJIT on attach instead of it being restricted to scenarios where the profiler is loaded at startup.

This can be solved either such that only methods jitted after ReJIT is turned on are rejittable or make all jit compiled methods rejittable from the beginning of process startup. The former can be confusing but is probably easier to implement in the existing runtime with some error checking to fail on methods that are not rejittable.

If we go with the latter implementation calling SetEventMask with `COR_PRF_ENABLE_REJIT` will probably be a no-op and return success so that profilers don't have to change.</Description>
    <Title_Description>Allow setting COR_PRF_ENABLE_REJIT after runtime startup It would useful to allow ReJIT on attach instead of it being restricted to scenarios where the profiler is loaded at startup.

This can be solved either such that only methods jitted after ReJIT is turned on are rejittable or make all jit compiled methods rejittable from the beginning of process startup. The former can be confusing but is probably easier to implement in the existing runtime with some error checking to fail on methods that are not rejittable.

If we go with the latter implementation calling SetEventMask with `COR_PRF_ENABLE_REJIT` will probably be a no-op and return success so that profilers don't have to change.</Title_Description>
    <Label>area-TieredCompilation</Label>
    <Assignee>davmason</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18640</IssueLabelID>
    <Title>Cross-Platform COM Interop</Title>
    <Description>**Goal: enable interop with native libraries with COM ABI and a reasonable subset of COM features on all supported platforms.**

*Related issue with generic discussion: https://github.com/dotnet/coreclr/issues/11279*
This issue is to list specific work areas required to achieve the functionality:

* RCW (Runtime Callable Wrappers).
	* Managed proxy for a native VTable.
	* AddRef on native IUnknown until managed proxy is finalized (or Marshal Release/FinalRelease).
	* Turn managed casts into QI calls to native IUnknown.
	* Turn reflection/dynamic into IDispatch(Ex) calls to native object.

* CCW (COM Callable Wrappers).
	* Generate VTable expose native pointer to it.
	* Keep GC root until final release from native side.
	* Turn IDispatch calls into reflection/dynamic calls on the managed object.

* Marshalling.
	* Mostly the same as in PInvoke.
	* Non-preserve-sig handling:
		* HRESULT into Exception for RCW; Exception into HRESULT for CCW.
		* Out parameter vs. return value transform.
		* Pointer&lt;-&gt;RCW and object&lt;-&gt;CCW transform.
		
Supposedly most of the implementation should already be available from the .NET Framework code. WinAPI implementations should be substituted with crude fallbacks for trivial cases (no activation scenarios no cross-apartment call marshalling no proxy/stubs).
	
Activation: manual from a DLL file or possibly side-by-side scenarios. At first activation is out of scope suppose we create the first COM object with external means (e.g. Pinvoke + GetObjectForIUnknown).

Here are example scenarios for possible application of this functionality.
* CLR Debugger interfaces (ICorDebug et al). We have a success story of running the cross-platform implementation of debugger with native COM interop from C# with Mono on Linux and Mac. Mono has huge problems with correctness of the implementation yet if you're using only core features and trivial marshalling it's working enough to have a functioning debugger. The problems do not look fundamental just of the quality sort. Obviously we would now like to run the same code on CoreCLR.
* Visual Studio COM interfaces have proven a working example of a large-scale native-managed interop with native and managed parts mixed together with no clear separation. That's not exactly about porting but that's a good example of a multi-technology app with native/managed interop API.
* A few of our own helper libraries on Windows are exposing COM interfaces for object-oriented interaction with the app. This experience is nice to have on any platform.
</Description>
    <Title_Description>Cross-Platform COM Interop **Goal: enable interop with native libraries with COM ABI and a reasonable subset of COM features on all supported platforms.**

*Related issue with generic discussion: https://github.com/dotnet/coreclr/issues/11279*
This issue is to list specific work areas required to achieve the functionality:

* RCW (Runtime Callable Wrappers).
	* Managed proxy for a native VTable.
	* AddRef on native IUnknown until managed proxy is finalized (or Marshal Release/FinalRelease).
	* Turn managed casts into QI calls to native IUnknown.
	* Turn reflection/dynamic into IDispatch(Ex) calls to native object.

* CCW (COM Callable Wrappers).
	* Generate VTable expose native pointer to it.
	* Keep GC root until final release from native side.
	* Turn IDispatch calls into reflection/dynamic calls on the managed object.

* Marshalling.
	* Mostly the same as in PInvoke.
	* Non-preserve-sig handling:
		* HRESULT into Exception for RCW; Exception into HRESULT for CCW.
		* Out parameter vs. return value transform.
		* Pointer&lt;-&gt;RCW and object&lt;-&gt;CCW transform.
		
Supposedly most of the implementation should already be available from the .NET Framework code. WinAPI implementations should be substituted with crude fallbacks for trivial cases (no activation scenarios no cross-apartment call marshalling no proxy/stubs).
	
Activation: manual from a DLL file or possibly side-by-side scenarios. At first activation is out of scope suppose we create the first COM object with external means (e.g. Pinvoke + GetObjectForIUnknown).

Here are example scenarios for possible application of this functionality.
* CLR Debugger interfaces (ICorDebug et al). We have a success story of running the cross-platform implementation of debugger with native COM interop from C# with Mono on Linux and Mac. Mono has huge problems with correctness of the implementation yet if you're using only core features and trivial marshalling it's working enough to have a functioning debugger. The problems do not look fundamental just of the quality sort. Obviously we would now like to run the same code on CoreCLR.
* Visual Studio COM interfaces have proven a working example of a large-scale native-managed interop with native and managed parts mixed together with no clear separation. That's not exactly about porting but that's a good example of a multi-technology app with native/managed interop API.
* A few of our own helper libraries on Windows are exposing COM interfaces for object-oriented interaction with the app. This experience is nice to have on any platform.
</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>25/06/2018 7:57:30 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18634</IssueLabelID>
    <Title>CoreCLR fails to run when mlock is unavailable</Title>
    <Description>CoreCLR uses `mlock` during startup and fails if `mlock` fails with `EPERM`. Generally that's not a  problem.

However many Linux distributions are starting to use `systemd-nspawn` for building code. This creates a chroot where programs have restricted capabilities. Specifically they do not have `CAP_IPC_LOCK` which means they can't use `mlock`.

Wwhen `mlock` doesn't work coreclr fails to start. This shows up in an `strace` as something like:

    mmap(NULL 4096 PROT_READ|PROT_WRITE MAP_PRIVATE|MAP_ANONYMOUS -1 0) = 0x7fbd542bb000
    mlock(0x7fbd542bb000 4096)       = -1 EPERM (Operation not permitted)
    write(2 "Failed to initialize CoreCLR HR"... 49) = 49

As a result this makes it basically impossible to build coreclr in some Linux distribution build systems.</Description>
    <Title_Description>CoreCLR fails to run when mlock is unavailable CoreCLR uses `mlock` during startup and fails if `mlock` fails with `EPERM`. Generally that's not a  problem.

However many Linux distributions are starting to use `systemd-nspawn` for building code. This creates a chroot where programs have restricted capabilities. Specifically they do not have `CAP_IPC_LOCK` which means they can't use `mlock`.

Wwhen `mlock` doesn't work coreclr fails to start. This shows up in an `strace` as something like:

    mmap(NULL 4096 PROT_READ|PROT_WRITE MAP_PRIVATE|MAP_ANONYMOUS -1 0) = 0x7fbd542bb000
    mlock(0x7fbd542bb000 4096)       = -1 EPERM (Operation not permitted)
    write(2 "Failed to initialize CoreCLR HR"... 49) = 49

As a result this makes it basically impossible to build coreclr in some Linux distribution build systems.</Title_Description>
    <Label>area-PAL</Label>
    <Assignee>tmds</Assignee>
    <CreatedAt>25/06/2018 3:56:37 PM +00:00</CreatedAt>
    <ClosedAt>20/11/2018 6:52:47 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18632</IssueLabelID>
    <Title>Enable FEATURE_GDBJIT on default builds</Title>
    <Description>On Linux/OSX it would be very nice if the default distributing has FEATURE_GDBJIT enabled so the debugging experience doesn't require manual building of SOS to have *some* debugging experience (presuming one sets the envvar needed for this)</Description>
    <Title_Description>Enable FEATURE_GDBJIT on default builds On Linux/OSX it would be very nice if the default distributing has FEATURE_GDBJIT enabled so the debugging experience doesn't require manual building of SOS to have *some* debugging experience (presuming one sets the envvar needed for this)</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>mikem8361</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18630</IssueLabelID>
    <Title>comcallablewrapper has very misleading commentary</Title>
    <Description>As part of the gutting of FEATURE_CORECLR ifdefs (https://github.com/dotnet/coreclr/commit/54891e0650e69f08832f75a40dc102efc6115d38#diff-ade4b3276f9a170febb781e66ab30039) appx-specific functionality got removed but this comment (https://github.com/dotnet/coreclr/blob/master/src/vm/comcallablewrapper.cpp#L1927-L1937) wasn't updated sending me on a wild goose chase for a few hours.

Was going to submit a PR but guidelines indicate bar wouldn't be met. I disagree hence this issue. Hope we can all agree this comment should be edited.

cc: @danmosemsft </Description>
    <Title_Description>comcallablewrapper has very misleading commentary As part of the gutting of FEATURE_CORECLR ifdefs (https://github.com/dotnet/coreclr/commit/54891e0650e69f08832f75a40dc102efc6115d38#diff-ade4b3276f9a170febb781e66ab30039) appx-specific functionality got removed but this comment (https://github.com/dotnet/coreclr/blob/master/src/vm/comcallablewrapper.cpp#L1927-L1937) wasn't updated sending me on a wild goose chase for a few hours.

Was going to submit a PR but guidelines indicate bar wouldn't be met. I disagree hence this issue. Hope we can all agree this comment should be edited.

cc: @danmosemsft </Title_Description>
    <Label>area-Interop</Label>
    <Assignee>danmosemsft</Assignee>
    <CreatedAt>25/06/2018 8:00:50 AM +00:00</CreatedAt>
    <ClosedAt>25/06/2018 8:13:50 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18619</IssueLabelID>
    <Title>Add a memory budget to the GC</Title>
    <Description>As I understand it GC time is *very roughly* proportional to the number of object references alive. The total time an application spends in GC is also proportional to the number of (full) collections happening. It seems that on servers with a lot of memory there is an optimization opportunity: Collect less often. Simply allow huge amounts of garbage to build up. Allow 10 GBs of garbage to build up and blast it all away in a single G2 collection.

The .NET GC is very autotuning which is a great thing. For that reason by default the GC does not allow too much garbage to build up. This is a good thing because we don't want to impact other apps running on the server. Also this might not improve performance in all cases.

But the GC does not know what a developer is able to know. Developers can measure different GC settings and pick the best one. Developers also know their optimization goal (memory usage vs. CPU usage).

I therefore propose to add a simple tuning knob to the GC to tell it to use more memory than normal. I'm not sure what the best way to specify this would be. Maybe a setting `float MemoryFactor = 1.0f`. Setting it to `3` would allow the GC to use 3x the memory that it normally would use. Or maybe this would need to be set in bytes e.g. `long AllowedAdditionalMemoryUsage = 0`. The developer can calculate an appropriate value at app startup based on the machine hardware. Or he can dynamically adjust this value based on free memory and based on the workload.

Use cases:

1. Server apps on servers with a lot of memory. My ASP.NET apps tend to use a few hundred MBs of memory on servers with many GBs of memory. A lot of memory ends up unused.
2. Console apps running GC heavy batch workloads.
3. Cloud apps where possibly total cost can be reduced by switching to a memory heavy instance. Pay more for memory and save on GC CPU cycles.
4. Games which want to experience less GC pauses on machines with ample memory.
</Description>
    <Title_Description>Add a memory budget to the GC As I understand it GC time is *very roughly* proportional to the number of object references alive. The total time an application spends in GC is also proportional to the number of (full) collections happening. It seems that on servers with a lot of memory there is an optimization opportunity: Collect less often. Simply allow huge amounts of garbage to build up. Allow 10 GBs of garbage to build up and blast it all away in a single G2 collection.

The .NET GC is very autotuning which is a great thing. For that reason by default the GC does not allow too much garbage to build up. This is a good thing because we don't want to impact other apps running on the server. Also this might not improve performance in all cases.

But the GC does not know what a developer is able to know. Developers can measure different GC settings and pick the best one. Developers also know their optimization goal (memory usage vs. CPU usage).

I therefore propose to add a simple tuning knob to the GC to tell it to use more memory than normal. I'm not sure what the best way to specify this would be. Maybe a setting `float MemoryFactor = 1.0f`. Setting it to `3` would allow the GC to use 3x the memory that it normally would use. Or maybe this would need to be set in bytes e.g. `long AllowedAdditionalMemoryUsage = 0`. The developer can calculate an appropriate value at app startup based on the machine hardware. Or he can dynamically adjust this value based on free memory and based on the workload.

Use cases:

1. Server apps on servers with a lot of memory. My ASP.NET apps tend to use a few hundred MBs of memory on servers with many GBs of memory. A lot of memory ends up unused.
2. Console apps running GC heavy batch workloads.
3. Cloud apps where possibly total cost can be reduced by switching to a memory heavy instance. Pay more for memory and save on GC CPU cycles.
4. Games which want to experience less GC pauses on machines with ample memory.
</Title_Description>
    <Label>area-GC</Label>
    <Assignee>luhenry</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18617</IssueLabelID>
    <Title>macOS Mojave: Support for Hardened Runtime</Title>
    <Description>From https://github.com/xamarin/xamarin-macios/issues/4288 / https://github.com/mono/mono/issues/9210 :

In macOS Mojave Apple has introduced support for Hardened Runtime. (This is fully explained somewhere in the WWDC 2018 slides but I cannot right now find exactly where.) One of the hardening mechanisms is a limitation on JIT techniques. It is still fully possible and supported but the MAP_JIT flag must be passed to mmap() calls and a specific entitlement must also be present in the code signature. 

https://developer.apple.com/videos/play/wwdc2018/702/ 20 minute mark has details.</Description>
    <Title_Description>macOS Mojave: Support for Hardened Runtime From https://github.com/xamarin/xamarin-macios/issues/4288 / https://github.com/mono/mono/issues/9210 :

In macOS Mojave Apple has introduced support for Hardened Runtime. (This is fully explained somewhere in the WWDC 2018 slides but I cannot right now find exactly where.) One of the hardening mechanisms is a limitation on JIT techniques. It is still fully possible and supported but the MAP_JIT flag must be passed to mmap() calls and a specific entitlement must also be present in the code signature. 

https://developer.apple.com/videos/play/wwdc2018/702/ 20 minute mark has details.</Title_Description>
    <Label>area-VM</Label>
    <Assignee>janvorli</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18611</IssueLabelID>
    <Title>[WIP] Test with tiering</Title>
    <Description>For https://github.com/dotnet/coreclr/pull/18610</Description>
    <Title_Description>[WIP] Test with tiering For https://github.com/dotnet/coreclr/pull/18610</Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18610</IssueLabelID>
    <Title>Apply tiering's call counting delay more broadly</Title>
    <Description>Issues
- When some time passes between process startup and first significant use of the app startup perf with tiering can be slower because the call counting delay is no longer in effect
- This is especially true when the process is affinitized to one cpu

Fixes
- Initiate and prolong the call counting delay upon tier 0 activity (jitting or r2r code lookup for a new method)
- Stop call counting for a called method when the delay is in effect
- Stop (and don't start) tier 1 jitting when the delay is in effect
- After the delay resume call counting and tier 1 jitting
- If the process is affinitized to one cpu at process startup multiply the delay by 10

No change in benchmarks.</Description>
    <Title_Description>Apply tiering's call counting delay more broadly Issues
- When some time passes between process startup and first significant use of the app startup perf with tiering can be slower because the call counting delay is no longer in effect
- This is especially true when the process is affinitized to one cpu

Fixes
- Initiate and prolong the call counting delay upon tier 0 activity (jitting or r2r code lookup for a new method)
- Stop call counting for a called method when the delay is in effect
- Stop (and don't start) tier 1 jitting when the delay is in effect
- After the delay resume call counting and tier 1 jitting
- If the process is affinitized to one cpu at process startup multiply the delay by 10

No change in benchmarks.</Title_Description>
    <Label>area-VM</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18609</IssueLabelID>
    <Title>Mirror changes from dotnet/corert</Title>
    <Description>This PR contains mirrored changes from dotnet/corert


**Please REBASE this PR when merging**</Description>
    <Title_Description>Mirror changes from dotnet/corert This PR contains mirrored changes from dotnet/corert


**Please REBASE this PR when merging**</Title_Description>
    <Label>
    </Label>
    <Assignee>Anipik</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18607</IssueLabelID>
    <Title>What is the proper way of doing incremental builds on Windows?</Title>
    <Description>I am trying to make changes to native components (eg. `compiler.cpp`) only.

After running `./build.cmd` and opening the generated solution file `&lt;root&gt;\bin\obj\Windows_NT.x64.Debug\CoreCLR.sln` the `INSTALL` project is not copying binaries into the `&lt;root&gt;\bin\Product\Windows_NT.x64.Debug` folder when I make incremental changes. Instead it seems they are being copied directly to the root of my drive. After building `INSTALL` I get `C:\corerun.exe` `C:\coreclr.dll` etc. `build.cmd` works fine but takes several minutes even for tiny changes to a single file.

In `cmake_install.cmake` (which is being invoked when building `INSTALL`) I see
```cmake
if(NOT DEFINED CMAKE_INSTALL_PREFIX)
  set(CMAKE_INSTALL_PREFIX "$ENV{__CMakeBinDir}")
endif()
```
at the top -- am I supposed to run Visual Studio in an environment with `CMAKE_INSTALL_PREFIX`/`__CMakeBinDir` set correctly or is `build.cmd` supposed to be used every time?
By the way I think I have been running into the same issue on Linux -- `make install` is installing files to `/usr/local` after configuring.</Description>
    <Title_Description>What is the proper way of doing incremental builds on Windows? I am trying to make changes to native components (eg. `compiler.cpp`) only.

After running `./build.cmd` and opening the generated solution file `&lt;root&gt;\bin\obj\Windows_NT.x64.Debug\CoreCLR.sln` the `INSTALL` project is not copying binaries into the `&lt;root&gt;\bin\Product\Windows_NT.x64.Debug` folder when I make incremental changes. Instead it seems they are being copied directly to the root of my drive. After building `INSTALL` I get `C:\corerun.exe` `C:\coreclr.dll` etc. `build.cmd` works fine but takes several minutes even for tiny changes to a single file.

In `cmake_install.cmake` (which is being invoked when building `INSTALL`) I see
```cmake
if(NOT DEFINED CMAKE_INSTALL_PREFIX)
  set(CMAKE_INSTALL_PREFIX "$ENV{__CMakeBinDir}")
endif()
```
at the top -- am I supposed to run Visual Studio in an environment with `CMAKE_INSTALL_PREFIX`/`__CMakeBinDir` set correctly or is `build.cmd` supposed to be used every time?
By the way I think I have been running into the same issue on Linux -- `make install` is installing files to `/usr/local` after configuring.</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>22/06/2018 2:01:56 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18603</IssueLabelID>
    <Title>RyuJIT and SIMD - suboptimal codegen when performing bitmask comparisons</Title>
    <Description>```cs
    private static bool TestMask(ref Vector&lt;byte&gt; a ref Vector&lt;byte&gt; b)
    {
        return (a &amp; b) == Vector&lt;byte&gt;.Zero;
    }
```

This generates the codegen (x64):

```asm
00007FF82F4D1524  vmovupd     ymm0ymmword ptr [rsi]  
00007FF82F4D1529  vmovupd     ymm1ymmword ptr [rdi]  
00007FF82F4D152E  vpand       ymm0ymm0ymm1  
00007FF82F4D1533  vptest      ymm0ymm0  
00007FF82F4D1538  sete        al 
```

The `vpand` instruction is unnecessary as the comparison line could read simply `vptest ymm0ymm1` which sets both _ZF_ and _CF_ (see http://www.felixcloutier.com/x86/PTEST.html).

category:cq
theme:vector-codegen
skill-level:expert
cost:medium</Description>
    <Title_Description>RyuJIT and SIMD - suboptimal codegen when performing bitmask comparisons ```cs
    private static bool TestMask(ref Vector&lt;byte&gt; a ref Vector&lt;byte&gt; b)
    {
        return (a &amp; b) == Vector&lt;byte&gt;.Zero;
    }
```

This generates the codegen (x64):

```asm
00007FF82F4D1524  vmovupd     ymm0ymmword ptr [rsi]  
00007FF82F4D1529  vmovupd     ymm1ymmword ptr [rdi]  
00007FF82F4D152E  vpand       ymm0ymm0ymm1  
00007FF82F4D1533  vptest      ymm0ymm0  
00007FF82F4D1538  sete        al 
```

The `vpand` instruction is unnecessary as the comparison line could read simply `vptest ymm0ymm1` which sets both _ZF_ and _CF_ (see http://www.felixcloutier.com/x86/PTEST.html).

category:cq
theme:vector-codegen
skill-level:expert
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>22/06/2018 5:29:49 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18602</IssueLabelID>
    <Title>"Go to disassembly" in VS aborts debugging session</Title>
    <Description>Repro:

- Attach VS to CoreCLR process
- Find frame in System.Private.Corelib
- Select "Go to disassembly"

Result: 

msvsmon.exe crashes
</Description>
    <Title_Description>"Go to disassembly" in VS aborts debugging session Repro:

- Attach VS to CoreCLR process
- Find frame in System.Private.Corelib
- Select "Go to disassembly"

Result: 

msvsmon.exe crashes
</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>noahfalk</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18599</IssueLabelID>
    <Title>Dllimport does not find libraries outside of system default (Linux)</Title>
    <Description>@furoraest commented on [Sun May 20 2018](https://github.com/dotnet/core/issues/1575)

when doing PInvoke call like
[DllImport("mylib")]
        private static extern int some_external_func();
the dotnet does not find library unless in its some system default (like /usr/lib)
If to explicitly state the actual library name like "libmylib.so.0.0.0" it will find it 
ldconfig is finding the libraries correctly using ld.so.conf and stating custom library folder.
Temporary solution was to add LD_LIBRARY_PATH to the running environment  pointing to the library folder which should not be necessary if the ldconfig lists those libraries already.
If already linked library tries to use other library (outside the system default) when the dotnet program will get error:
dotnet: symbol lookup error: /usr/local/lib/libmylib.so: undefined symbol: _ZN2gr6some9awesome4functionEmmPcibi
Used platform: Ubuntu 18.04 and SDK 2.1 RC1
My current solution is to handload the all required libraries using this code:
[DllImport("dl")]
        private static extern IntPtr dlopen (string file int mode);
and then in the function somewhere before first call of the PInvoked function call out the libraries
dlopen("libmyawesomelib-x.y.z.0.so.0.0.0" RTLD_LAZY|RTLD_GLOBAL);
dlopen("libmyawesomelib2-x.y.z.0.so.0.0.0" RTLD_LAZY|RTLD_GLOBAL);


</Description>
    <Title_Description>Dllimport does not find libraries outside of system default (Linux) @furoraest commented on [Sun May 20 2018](https://github.com/dotnet/core/issues/1575)

when doing PInvoke call like
[DllImport("mylib")]
        private static extern int some_external_func();
the dotnet does not find library unless in its some system default (like /usr/lib)
If to explicitly state the actual library name like "libmylib.so.0.0.0" it will find it 
ldconfig is finding the libraries correctly using ld.so.conf and stating custom library folder.
Temporary solution was to add LD_LIBRARY_PATH to the running environment  pointing to the library folder which should not be necessary if the ldconfig lists those libraries already.
If already linked library tries to use other library (outside the system default) when the dotnet program will get error:
dotnet: symbol lookup error: /usr/local/lib/libmylib.so: undefined symbol: _ZN2gr6some9awesome4functionEmmPcibi
Used platform: Ubuntu 18.04 and SDK 2.1 RC1
My current solution is to handload the all required libraries using this code:
[DllImport("dl")]
        private static extern IntPtr dlopen (string file int mode);
and then in the function somewhere before first call of the PInvoked function call out the libraries
dlopen("libmyawesomelib-x.y.z.0.so.0.0.0" RTLD_LAZY|RTLD_GLOBAL);
dlopen("libmyawesomelib2-x.y.z.0.so.0.0.0" RTLD_LAZY|RTLD_GLOBAL);


</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18594</IssueLabelID>
    <Title>Consolidate testing guidelines</Title>
    <Description>There are multiple documents under https://github.com/dotnet/coreclr/tree/master/Documentation/building that describe how testing can be accomplished. These docs include building and running tests. However since we are using platform agnostic tools the instructions should also be largely agnostic of platform. Minor command line differences but that are basically limited to use the `.sh` vs `.cmd` file. There is a Workflow section under Documentation that has a placeholder file for this type of information - `RunningTests.md`.</Description>
    <Title_Description>Consolidate testing guidelines There are multiple documents under https://github.com/dotnet/coreclr/tree/master/Documentation/building that describe how testing can be accomplished. These docs include building and running tests. However since we are using platform agnostic tools the instructions should also be largely agnostic of platform. Minor command line differences but that are basically limited to use the `.sh` vs `.cmd` file. There is a Workflow section under Documentation that has a placeholder file for this type of information - `RunningTests.md`.</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
    <CreatedAt>21/06/2018 4:57:34 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18586</IssueLabelID>
    <Title>Mirror changes from dotnet/corert</Title>
    <Description>This PR contains mirrored changes from dotnet/corert


**Please REBASE this PR when merging**</Description>
    <Title_Description>Mirror changes from dotnet/corert This PR contains mirrored changes from dotnet/corert


**Please REBASE this PR when merging**</Title_Description>
    <Label>
    </Label>
    <Assignee>jkotas</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18582</IssueLabelID>
    <Title>optimize fgMorphTree for GenTreeArgList</Title>
    <Description>We can't usually have deep trees because importer restricts trees depth:
https://github.com/dotnet/coreclr/blob/da40cb1ca8779566ca53ed6bd2fa67a926b29b38/src/jit/importer.cpp#L10173-L10178

However it doesn't restrict depth of `GT_LIST` trees so we can hit a stack overflow if there is a method with huge number of arguments.

This PR adds non-recursive morph for `GenTreeArgList`.

Fixes DevDiv_635180.


No asm diffs no measurable instruction retired diff for System.Private.CoreLib.
</Description>
    <Title_Description>optimize fgMorphTree for GenTreeArgList We can't usually have deep trees because importer restricts trees depth:
https://github.com/dotnet/coreclr/blob/da40cb1ca8779566ca53ed6bd2fa67a926b29b38/src/jit/importer.cpp#L10173-L10178

However it doesn't restrict depth of `GT_LIST` trees so we can hit a stack overflow if there is a method with huge number of arguments.

This PR adds non-recursive morph for `GenTreeArgList`.

Fixes DevDiv_635180.


No asm diffs no measurable instruction retired diff for System.Private.CoreLib.
</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>20/06/2018 11:45:45 PM +00:00</CreatedAt>
    <ClosedAt>29/06/2018 8:38:45 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18580</IssueLabelID>
    <Title>Deadlock occuring after calling GetTypes() in visual studio</Title>
    <Description>First of all I'm new to this I'm not even sure I'm posting this at the right place. That being said here is my problem.

I have a C# application that lazy load a dll. In the constructor of a static class in that dll I have a call to GetTypes(). The problem seems to occur with a specific timming and only happens when running the application from visual studio. I'm running the .NET Framework 4.7.1.

To be clear:
MyExecutable.exe:
`void main() { SomeStaticClass.DoStuff();}`

AnotherProject.dll:
`static class SomeStaticClass
{
    static SomeStaticClass()
    {
        Assembly.GetExecutingAssembly().GetTypes();
    }
    static public void DoStuff()
    {
        // Do stuff
    }
}`

I've identified 2 threads causing the dead lock.

Thread #1:
This is my application main thread that will eventually call GetTypes() trough one of its dlls.

Thread #2:
It seems to be a thread launched by visual studio:

mscorlib.dll!System.AppDomain.OnAssemblyLoadEvent(System.Reflection.RuntimeAssembly LoadedAssembly) Line 3113    C#
    [Native to Managed Transition]    
    [Managed to Native Transition]    
    mscorlib.dll!System.Reflection.RuntimeAssembly.GetExportedTypes() Line 1482    C#     Microsoft.VisualStudio.DesignTools.WpfTap.dll!Microsoft.VisualStudio.DesignTools.WpfTap.WpfVisualTreeService.VisualTreeService.GetEnumTypes()    Unknown
    Microsoft.VisualStudio.DesignTools.WpfTap.dll!Microsoft.VisualStudio.DesignTools.WpfTap.WpfVisualTreeService.VisualTreeService.HandleEnumsRequest(Microsoft.VisualStudio.DesignTools.WpfTap.TapOM.EmptyRequestInfo request)    Unknown
     Microsoft.VisualStudio.DesignTools.WpfTap.dll!Microsoft.VisualStudio.DesignTools.WpfTap.Networking.ProtocolHandler.HandleMessage&lt;Microsoft.VisualStudio.DesignTools.WpfTap.TapOM.EmptyRequestInfo Microsoft.VisualStudio.DesignTools.WpfTap.TapOM.EnumsResponse&gt;(System.Func&lt;Microsoft.VisualStudio.DesignTools.WpfTap.TapOM.EmptyRequestInfo Microsoft.VisualStudio.DesignTools.WpfTap.TapOM.EnumsResponse&gt; callback Microsoft.VisualStudio.DesignTools.WpfTap.Networking.Message requestMessage)    Unknown
     Microsoft.VisualStudio.DesignTools.WpfTap.dll!Microsoft.VisualStudio.DesignTools.WpfTap.Networking.ProtocolHandler.RegisterMessageObserver.AnonymousMethod__0(Microsoft.VisualStudio.DesignTools.WpfTap.Networking.Message message)    Unknown
     Microsoft.VisualStudio.DesignTools.WpfTap.dll!Microsoft.VisualStudio.DesignTools.WpfTap.Networking.ProtocolHandler.OnMessageReceived(byte[] buffer)    Unknown
     Microsoft.VisualStudio.DesignTools.WpfTap.dll!Microsoft.VisualStudio.DesignTools.WpfTap.Networking.ProtocolHandler.ReadThread()    Unknown
     mscorlib.dll!System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext executionContext System.Threading.ContextCallback callback object state bool preserveSyncCtx) Line 954    C#
     mscorlib.dll!System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext executionContext System.Threading.ContextCallback callback object state bool preserveSyncCtx) Line 902    C#
     mscorlib.dll!System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext executionContext System.Threading.ContextCallback callback object state) Line 891    C#
     mscorlib.dll!System.Threading.ThreadHelper.ThreadStart() Line 111    C#


I went a step further and ran WinDbg and got this:

Thread #1:

ntdll!NtWaitForAlertByThreadId+0x14
ntdll!RtlpWaitOnAddressWithTimeout+0x43
ntdll!RtlpWaitOnAddress+0xb2
ntdll!RtlpWaitOnCriticalSection+0xdb
ntdll!RtlpEnterCriticalSectionContended+0xcc
ntdll!RtlEnterCriticalSection+0x40
clr!CrstBase::SpinEnter+0xac
clr!CrstBase::Enter+0x10d
clr!CrstBase::CrstHolder::CrstHolder+0x14
clr!ClassLoader::LoadTypeHandleForTypeKey_Body+0x819
clr!ClassLoader::LoadTypeHandleForTypeKey+0xee
clr!ClassLoader::LoadTypeDefThrowing+0x227
clr!ClassLoader::LoadTypeDefOrRefThrowing+0x279
clr!GetTypesInner+0x216
clr!COMModule::GetTypes+0xba
mscorlib_ni!System.Reflection.Assembly.GetTypes()$##600421C+0x70
0x00007ffc`5d0a3204
clr!CallDescrWorkerInternal+0x83
clr!CallDescrWorkerWithHandler+0x4e
clr!DispatchCallDebuggerWrapper+0x1f


Thread #2:

ntdll!NtWaitForAlertByThreadId+0x14
ntdll!RtlpWaitOnAddressWithTimeout+0x43
ntdll!RtlpWaitOnAddress+0xb2
ntdll!RtlpWaitOnCriticalSection+0xdb
ntdll!RtlpEnterCriticalSectionContended+0xcc
ntdll!RtlEnterCriticalSection+0x40
clr!CrstBase::SpinEnter+0xac
clr!CrstBase::Enter+0x10d
clr!ListLockEntry::LockHolder::DeadlockAwareAcquire+0x4b
clr!MethodTable::DoRunClassInitThrowing+0x1be
clr!MethodTable::CheckRunClassInitThrowing+0xa3
clr!MethodDesc::DoPrestub+0xdd8
clr!PreStubWorker+0x3cc
clr!ThePreStub+0x55
mscorlib_ni!System.AppDomain.OnAssemblyLoadEvent(System.Reflection.RuntimeAssembly)$##6000815+0x3f
clr!CallDescrWorkerInternal+0x83
clr!CallDescrWorkerWithHandler+0x4e
clr!MethodDescCallSite::CallTargetWorker+0xf8
clr!AppDomain::RaiseLoadingAssemblyEvent+0xffffffff`fffe1534
clr!DomainAssembly::DeliverAsyncEvents+0x40

I have a work around for now I simply construct my static class very soon the the application but I'm wondering if it's a known issue or if I'm doing something wrong.

Again the application works fine when not running it with visual studio.

Visual Studio Professional 2017
Version 15.6.1

.Net Framework
Version 4.7.02558</Description>
    <Title_Description>Deadlock occuring after calling GetTypes() in visual studio First of all I'm new to this I'm not even sure I'm posting this at the right place. That being said here is my problem.

I have a C# application that lazy load a dll. In the constructor of a static class in that dll I have a call to GetTypes(). The problem seems to occur with a specific timming and only happens when running the application from visual studio. I'm running the .NET Framework 4.7.1.

To be clear:
MyExecutable.exe:
`void main() { SomeStaticClass.DoStuff();}`

AnotherProject.dll:
`static class SomeStaticClass
{
    static SomeStaticClass()
    {
        Assembly.GetExecutingAssembly().GetTypes();
    }
    static public void DoStuff()
    {
        // Do stuff
    }
}`

I've identified 2 threads causing the dead lock.

Thread #1:
This is my application main thread that will eventually call GetTypes() trough one of its dlls.

Thread #2:
It seems to be a thread launched by visual studio:

mscorlib.dll!System.AppDomain.OnAssemblyLoadEvent(System.Reflection.RuntimeAssembly LoadedAssembly) Line 3113    C#
    [Native to Managed Transition]    
    [Managed to Native Transition]    
    mscorlib.dll!System.Reflection.RuntimeAssembly.GetExportedTypes() Line 1482    C#     Microsoft.VisualStudio.DesignTools.WpfTap.dll!Microsoft.VisualStudio.DesignTools.WpfTap.WpfVisualTreeService.VisualTreeService.GetEnumTypes()    Unknown
    Microsoft.VisualStudio.DesignTools.WpfTap.dll!Microsoft.VisualStudio.DesignTools.WpfTap.WpfVisualTreeService.VisualTreeService.HandleEnumsRequest(Microsoft.VisualStudio.DesignTools.WpfTap.TapOM.EmptyRequestInfo request)    Unknown
     Microsoft.VisualStudio.DesignTools.WpfTap.dll!Microsoft.VisualStudio.DesignTools.WpfTap.Networking.ProtocolHandler.HandleMessage&lt;Microsoft.VisualStudio.DesignTools.WpfTap.TapOM.EmptyRequestInfo Microsoft.VisualStudio.DesignTools.WpfTap.TapOM.EnumsResponse&gt;(System.Func&lt;Microsoft.VisualStudio.DesignTools.WpfTap.TapOM.EmptyRequestInfo Microsoft.VisualStudio.DesignTools.WpfTap.TapOM.EnumsResponse&gt; callback Microsoft.VisualStudio.DesignTools.WpfTap.Networking.Message requestMessage)    Unknown
     Microsoft.VisualStudio.DesignTools.WpfTap.dll!Microsoft.VisualStudio.DesignTools.WpfTap.Networking.ProtocolHandler.RegisterMessageObserver.AnonymousMethod__0(Microsoft.VisualStudio.DesignTools.WpfTap.Networking.Message message)    Unknown
     Microsoft.VisualStudio.DesignTools.WpfTap.dll!Microsoft.VisualStudio.DesignTools.WpfTap.Networking.ProtocolHandler.OnMessageReceived(byte[] buffer)    Unknown
     Microsoft.VisualStudio.DesignTools.WpfTap.dll!Microsoft.VisualStudio.DesignTools.WpfTap.Networking.ProtocolHandler.ReadThread()    Unknown
     mscorlib.dll!System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext executionContext System.Threading.ContextCallback callback object state bool preserveSyncCtx) Line 954    C#
     mscorlib.dll!System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext executionContext System.Threading.ContextCallback callback object state bool preserveSyncCtx) Line 902    C#
     mscorlib.dll!System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext executionContext System.Threading.ContextCallback callback object state) Line 891    C#
     mscorlib.dll!System.Threading.ThreadHelper.ThreadStart() Line 111    C#


I went a step further and ran WinDbg and got this:

Thread #1:

ntdll!NtWaitForAlertByThreadId+0x14
ntdll!RtlpWaitOnAddressWithTimeout+0x43
ntdll!RtlpWaitOnAddress+0xb2
ntdll!RtlpWaitOnCriticalSection+0xdb
ntdll!RtlpEnterCriticalSectionContended+0xcc
ntdll!RtlEnterCriticalSection+0x40
clr!CrstBase::SpinEnter+0xac
clr!CrstBase::Enter+0x10d
clr!CrstBase::CrstHolder::CrstHolder+0x14
clr!ClassLoader::LoadTypeHandleForTypeKey_Body+0x819
clr!ClassLoader::LoadTypeHandleForTypeKey+0xee
clr!ClassLoader::LoadTypeDefThrowing+0x227
clr!ClassLoader::LoadTypeDefOrRefThrowing+0x279
clr!GetTypesInner+0x216
clr!COMModule::GetTypes+0xba
mscorlib_ni!System.Reflection.Assembly.GetTypes()$##600421C+0x70
0x00007ffc`5d0a3204
clr!CallDescrWorkerInternal+0x83
clr!CallDescrWorkerWithHandler+0x4e
clr!DispatchCallDebuggerWrapper+0x1f


Thread #2:

ntdll!NtWaitForAlertByThreadId+0x14
ntdll!RtlpWaitOnAddressWithTimeout+0x43
ntdll!RtlpWaitOnAddress+0xb2
ntdll!RtlpWaitOnCriticalSection+0xdb
ntdll!RtlpEnterCriticalSectionContended+0xcc
ntdll!RtlEnterCriticalSection+0x40
clr!CrstBase::SpinEnter+0xac
clr!CrstBase::Enter+0x10d
clr!ListLockEntry::LockHolder::DeadlockAwareAcquire+0x4b
clr!MethodTable::DoRunClassInitThrowing+0x1be
clr!MethodTable::CheckRunClassInitThrowing+0xa3
clr!MethodDesc::DoPrestub+0xdd8
clr!PreStubWorker+0x3cc
clr!ThePreStub+0x55
mscorlib_ni!System.AppDomain.OnAssemblyLoadEvent(System.Reflection.RuntimeAssembly)$##6000815+0x3f
clr!CallDescrWorkerInternal+0x83
clr!CallDescrWorkerWithHandler+0x4e
clr!MethodDescCallSite::CallTargetWorker+0xf8
clr!AppDomain::RaiseLoadingAssemblyEvent+0xffffffff`fffe1534
clr!DomainAssembly::DeliverAsyncEvents+0x40

I have a work around for now I simply construct my static class very soon the the application but I'm wondering if it's a known issue or if I'm doing something wrong.

Again the application works fine when not running it with visual studio.

Visual Studio Professional 2017
Version 15.6.1

.Net Framework
Version 4.7.02558</Title_Description>
    <Label>area-AssemblyLoader</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>20/06/2018 10:28:54 PM +00:00</CreatedAt>
    <ClosedAt>22/06/2018 5:37:49 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18579</IssueLabelID>
    <Title>DateTime.ToString("d") formats differently on Mac OS and Windows</Title>
    <Description>When I have a DateTime that I call `ToString("d" CultureInfo.CreateSpecificCulture("en-US"))` I would expect that the formatted string would be the same on different platforms but for a date "9/25/2017" it produces 9/25/17 on MacOS and 9/25/2017 on windows.</Description>
    <Title_Description>DateTime.ToString("d") formats differently on Mac OS and Windows When I have a DateTime that I call `ToString("d" CultureInfo.CreateSpecificCulture("en-US"))` I would expect that the formatted string would be the same on different platforms but for a date "9/25/2017" it produces 9/25/17 on MacOS and 9/25/2017 on windows.</Title_Description>
    <Label>area-System.Globalization</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>20/06/2018 8:10:53 PM +00:00</CreatedAt>
    <ClosedAt>21/06/2018 1:45:27 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18577</IssueLabelID>
    <Title>ASP.NET core web API - OOM on Ubuntu after upgrade to 2.1.</Title>
    <Description>We have a .net core web API running on AWS Ubuntu 16.04 VM.
The API is using EF to query a relatively small DB and makes a lot of external requests due to integrations with other systems. After we upgraded to 2.1. we started to have serious OOM problems on production.  During the upgrade we haven't changed much in our execution logic aside from the changes needed to support the changes in the APIs. I made sure we are reusing HttpClients and that the DBContext objects are scoped honestly I don't think it is a memory leak from changes in our code. Moreover the app was running on the same environment with the same user load for roughly a year without problems. We make deployments regularly but let's say it could be running continuously for two weeks.

After the upgrade it consumes 6GB of ram for several hours and then crashes with OOM (actually the whole server crashes). The strange thing is that the memory used by the app goes up and barely goes down even in idle times. It's like barely anything gets released.

Looking at memory snapshots I can see a lot of memory cache collections growing big many of them used by entity framework and the Json.Net lib.

I'm sure that all that memory caching improves performance but my assumption is that the app should trade off performance for memory use based on the params of the system. Also it seems like the GC doesn't release memory but I'm not very familiar with how its implemented. I wonder why it used to work fine with 1.1. We are using supervisor to start and motor the service not sure if it matters but this is also not new.

Is there some important configuration I could be missing to tell the system how much in-memory caching it could do?

Checked a few issues which might be related but none seemed to offer a solution so far and I was not sure which is the 'most' related so I created this one. 

Possibly related:
https://github.com/dotnet/coreclr/issues/18044
https://github.com/dotnet/coreclr/issues/5551
https://github.com/aspnet/Home/issues/1976 (similar to what danports describes here and we are also considering downgrading after days of struggle) 

I noticed that most people reporting the problem are reporting it with web api projects. We have another dot net MVC app running on that machine which doesn't seem to have the problem but it has a significantly lower load the API is just faster to exhaust the memory.
</Description>
    <Title_Description>ASP.NET core web API - OOM on Ubuntu after upgrade to 2.1. We have a .net core web API running on AWS Ubuntu 16.04 VM.
The API is using EF to query a relatively small DB and makes a lot of external requests due to integrations with other systems. After we upgraded to 2.1. we started to have serious OOM problems on production.  During the upgrade we haven't changed much in our execution logic aside from the changes needed to support the changes in the APIs. I made sure we are reusing HttpClients and that the DBContext objects are scoped honestly I don't think it is a memory leak from changes in our code. Moreover the app was running on the same environment with the same user load for roughly a year without problems. We make deployments regularly but let's say it could be running continuously for two weeks.

After the upgrade it consumes 6GB of ram for several hours and then crashes with OOM (actually the whole server crashes). The strange thing is that the memory used by the app goes up and barely goes down even in idle times. It's like barely anything gets released.

Looking at memory snapshots I can see a lot of memory cache collections growing big many of them used by entity framework and the Json.Net lib.

I'm sure that all that memory caching improves performance but my assumption is that the app should trade off performance for memory use based on the params of the system. Also it seems like the GC doesn't release memory but I'm not very familiar with how its implemented. I wonder why it used to work fine with 1.1. We are using supervisor to start and motor the service not sure if it matters but this is also not new.

Is there some important configuration I could be missing to tell the system how much in-memory caching it could do?

Checked a few issues which might be related but none seemed to offer a solution so far and I was not sure which is the 'most' related so I created this one. 

Possibly related:
https://github.com/dotnet/coreclr/issues/18044
https://github.com/dotnet/coreclr/issues/5551
https://github.com/aspnet/Home/issues/1976 (similar to what danports describes here and we are also considering downgrading after days of struggle) 

I noticed that most people reporting the problem are reporting it with web api projects. We have another dot net MVC app running on that machine which doesn't seem to have the problem but it has a significantly lower load the API is just faster to exhaust the memory.
</Title_Description>
    <Label>area-GC</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>20/06/2018 7:24:18 PM +00:00</CreatedAt>
    <ClosedAt>18/04/2019 12:33:17 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18576</IssueLabelID>
    <Title>Mirror changes from Anipik/ corefx</Title>
    <Description>This PR contains mirrored changes from Anipik/ corefx


**Please REBASE this PR when merging**</Description>
    <Title_Description>Mirror changes from Anipik/ corefx This PR contains mirrored changes from Anipik/ corefx


**Please REBASE this PR when merging**</Title_Description>
    <Label>
    </Label>
    <Assignee>Anipik</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18572</IssueLabelID>
    <Title>Port Fix handling of generating relative path to parent (#18460)</Title>
    <Description>Port of #18460

Fixes #30263</Description>
    <Title_Description>Port Fix handling of generating relative path to parent (#18460) Port of #18460

Fixes #30263</Title_Description>
    <Label>area-System.IO</Label>
    <Assignee>JeremyKuhne</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18565</IssueLabelID>
    <Title>Timeout build failures in 'prodcon/coreclr/release/2.1/' - '20180620.01'</Title>
    <Description>There were a set of failures during this build. Here is a summary of these:
* https://devdiv.visualstudio.com/DefaultCollection/DevDiv/_build?_a=summary&amp;buildId=1790648
  - **Agent:** DDVSOLINUXAGE003
  - **Error log:** The job running on agent DDVSOLINUXAGE003 has exceeded the maximum execution time of 90....

* https://devdiv.visualstudio.com/DefaultCollection/DevDiv/_build?_a=summary&amp;buildId=1790650
  - **Agent:** DDVSOLINUXAGE005
  - **Error log:** The job running on agent DDVSOLINUXAGE005 has exceeded the maximum execution time of 90....

@mmitche @RussKeldorph
</Description>
    <Title_Description>Timeout build failures in 'prodcon/coreclr/release/2.1/' - '20180620.01' There were a set of failures during this build. Here is a summary of these:
* https://devdiv.visualstudio.com/DefaultCollection/DevDiv/_build?_a=summary&amp;buildId=1790648
  - **Agent:** DDVSOLINUXAGE003
  - **Error log:** The job running on agent DDVSOLINUXAGE003 has exceeded the maximum execution time of 90....

* https://devdiv.visualstudio.com/DefaultCollection/DevDiv/_build?_a=summary&amp;buildId=1790650
  - **Agent:** DDVSOLINUXAGE005
  - **Error log:** The job running on agent DDVSOLINUXAGE005 has exceeded the maximum execution time of 90....

@mmitche @RussKeldorph
</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>mmitche</Assignee>
    <CreatedAt>20/06/2018 8:05:03 AM +00:00</CreatedAt>
    <ClosedAt>5/07/2018 8:50:48 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18564</IssueLabelID>
    <Title>Segmentation fault in WKS::gc_heap::mark_object_simple on Linux</Title>
    <Description>On a linux machine running CentOS  7.5.1804 and Dotnet 2.1.300 I get the following segfault:

```
$ gdb --args dotnet bin/Release/netcoreapp2.0/publish/...
GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-110.el7
Copyright (C) 2013 Free Software Foundation Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-redhat-linux-gnu".
For bug reporting instructions please see:
&lt;http://www.gnu.org/software/gdb/bugs/&gt;...
Reading symbols from /usr/share/dotnet/dotnet...(no debugging symbols found)...done.
Missing separate debuginfos use: debuginfo-install dotnet-host-2.1.0-1.x86_64
(gdb) handle SIG34 noprint nostop
Signal        Stop      Print   Pass to program Description
SIG34         No        No      Yes             Real-time event 34
(gdb) r
The program being debugged has been started already.
Start it from the beginning? (y or n) y

Starting program: /usr/bin/dotnet bin/Release/netcoreapp2.0/publish/...
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib64/libthread_db.so.1".
[New Thread 0x7ffff5e2c700 (LWP 26930)]
[New Thread 0x7ffff562b700 (LWP 26931)]
[New Thread 0x7ffff4e2a700 (LWP 26932)]
[New Thread 0x7ffff42b0700 (LWP 26933)]
[New Thread 0x7ffff1452700 (LWP 26936)]
[New Thread 0x7ffff1357700 (LWP 26937)]
[New Thread 0x7ffff0b56700 (LWP 26938)]
[New Thread 0x7ffff0b15700 (LWP 26939)]
[New Thread 0x7ffff0101700 (LWP 26940)]
[New Thread 0x7fff57d9b700 (LWP 26941)]
[New Thread 0x7fff5759a700 (LWP 26943)]
[Thread 0x7ffff0b56700 (LWP 26938) exited]
[New Thread 0x7ffff0b56700 (LWP 26946)]
[New Thread 0x7fff56a0e700 (LWP 26947)]
[New Thread 0x7fff5620d700 (LWP 26948)]
[New Thread 0x7fff55a0c700 (LWP 26949)]
[New Thread 0x7fff5520b700 (LWP 26950)]
[New Thread 0x7fff54a0a700 (LWP 26951)]
[New Thread 0x7fff1ffff700 (LWP 26952)]
[New Thread 0x7fff1f7fe700 (LWP 26953)]
[New Thread 0x7fff1effd700 (LWP 26954)]
[New Thread 0x7fff1e7fc700 (LWP 26955)]
[New Thread 0x7fff1dffb700 (LWP 26956)]
[New Thread 0x7fff1d7fa700 (LWP 26957)]
[New Thread 0x7fff1cff9700 (LWP 26958)]
[New Thread 0x7ffefffff700 (LWP 26959)]
[New Thread 0x7ffeff7fe700 (LWP 26960)]
[New Thread 0x7ffefeffd700 (LWP 26961)]
[New Thread 0x7ffefe7fc700 (LWP 26962)]
[New Thread 0x7ffefdffb700 (LWP 26963)]
[New Thread 0x7ffefd7fa700 (LWP 26964)]
[New Thread 0x7ffefcff9700 (LWP 26965)]
[New Thread 0x7ffedffff700 (LWP 26966)]
[New Thread 0x7ffedf7fe700 (LWP 26967)]
[New Thread 0x7ffedeffd700 (LWP 26968)]
[New Thread 0x7ffede7fc700 (LWP 26969)]
[New Thread 0x7ffeddffb700 (LWP 26970)]
[New Thread 0x7ffedd7fa700 (LWP 26971)]
[New Thread 0x7ffedcff9700 (LWP 26972)]
[New Thread 0x7ffebffff700 (LWP 26973)]
[New Thread 0x7ffebf7fe700 (LWP 26974)]
[New Thread 0x7ffebeffd700 (LWP 26975)]
[New Thread 0x7ffebe7fc700 (LWP 26976)]
[New Thread 0x7ffebdffb700 (LWP 26980)]
[New Thread 0x7ffebd7fa700 (LWP 26984)]
[New Thread 0x7ffebcff9700 (LWP 26999)]
[New Thread 0x7ffe9ffff700 (LWP 27003)]
[New Thread 0x7ffe9f7fe700 (LWP 27007)]

Program received signal SIGSEGV Segmentation fault.
[Switching to Thread 0x7ffeff7fe700 (LWP 26960)]
0x00007ffff63e9ce4 in WKS::gc_heap::mark_object_simple(unsigned char**) ()
   from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.0/libcoreclr.so
(gdb) bt
#0  0x00007ffff63e9ce4 in WKS::gc_heap::mark_object_simple(unsigned char**) ()
   from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.0/libcoreclr.so
#1  0x00007ffff63edb1a in WKS::gc_heap::mark_through_cards_for_segments(void (*)(unsigned char**) int) ()
   from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.0/libcoreclr.so
#2  0x00007ffff63e013d in WKS::gc_heap::mark_phase(int int) () from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.0/libcoreclr.so
#3  0x00007ffff63dd977 in WKS::gc_heap::gc1() () from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.0/libcoreclr.so
#4  0x00007ffff63e7120 in WKS::gc_heap::garbage_collect(int) () from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.0/libcoreclr.so
#5  0x00007ffff63daa71 in WKS::GCHeap::GarbageCollectGeneration(unsigned int gc_reason) ()
   from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.0/libcoreclr.so
#6  0x00007ffff63dc0c9 in WKS::gc_heap::try_allocate_more_space(alloc_context* unsigned long int) ()
   from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.0/libcoreclr.so
#7  0x00007ffff63ffd7d in WKS::GCHeap::Alloc(gc_alloc_context* unsigned long unsigned int) ()
   from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.0/libcoreclr.so
#8  0x00007ffff6215750 in AllocateObject(MethodTable*) () from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.0/libcoreclr.so
#9  0x00007ffff6226246 in JIT_New(CORINFO_CLASS_STRUCT_*) () from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.0/libcoreclr.so
#10 0x00007fff7fcb3265 in ?? ()
#11 0x00007fff639de1f0 in ?? ()
#12 0x00007fff63aa7418 in ?? ()
#13 0x00007fff63e0f6d8 in ?? ()
#14 0x00007fff59f4ea20 in ?? ()
#15 0x00007ffeff7fd280 in ?? ()
#16 0x00007fff7fcb3200 in ?? ()
#17 0x0000000000000000 in ?? ()
```

The program runs without problems in Windows. The only native library used is System.Data.SqlClient otherwise its all no-unsafe C# code. Unfortunately I have not been successful in reproducing the bug in a smaller program and I cannot share the original program.

It's possibly (likely?) a memory corruption bug and not a GC bug as I have also experienced some weird C# exceptions (stuff that should be logically impossible).</Description>
    <Title_Description>Segmentation fault in WKS::gc_heap::mark_object_simple on Linux On a linux machine running CentOS  7.5.1804 and Dotnet 2.1.300 I get the following segfault:

```
$ gdb --args dotnet bin/Release/netcoreapp2.0/publish/...
GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-110.el7
Copyright (C) 2013 Free Software Foundation Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-redhat-linux-gnu".
For bug reporting instructions please see:
&lt;http://www.gnu.org/software/gdb/bugs/&gt;...
Reading symbols from /usr/share/dotnet/dotnet...(no debugging symbols found)...done.
Missing separate debuginfos use: debuginfo-install dotnet-host-2.1.0-1.x86_64
(gdb) handle SIG34 noprint nostop
Signal        Stop      Print   Pass to program Description
SIG34         No        No      Yes             Real-time event 34
(gdb) r
The program being debugged has been started already.
Start it from the beginning? (y or n) y

Starting program: /usr/bin/dotnet bin/Release/netcoreapp2.0/publish/...
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib64/libthread_db.so.1".
[New Thread 0x7ffff5e2c700 (LWP 26930)]
[New Thread 0x7ffff562b700 (LWP 26931)]
[New Thread 0x7ffff4e2a700 (LWP 26932)]
[New Thread 0x7ffff42b0700 (LWP 26933)]
[New Thread 0x7ffff1452700 (LWP 26936)]
[New Thread 0x7ffff1357700 (LWP 26937)]
[New Thread 0x7ffff0b56700 (LWP 26938)]
[New Thread 0x7ffff0b15700 (LWP 26939)]
[New Thread 0x7ffff0101700 (LWP 26940)]
[New Thread 0x7fff57d9b700 (LWP 26941)]
[New Thread 0x7fff5759a700 (LWP 26943)]
[Thread 0x7ffff0b56700 (LWP 26938) exited]
[New Thread 0x7ffff0b56700 (LWP 26946)]
[New Thread 0x7fff56a0e700 (LWP 26947)]
[New Thread 0x7fff5620d700 (LWP 26948)]
[New Thread 0x7fff55a0c700 (LWP 26949)]
[New Thread 0x7fff5520b700 (LWP 26950)]
[New Thread 0x7fff54a0a700 (LWP 26951)]
[New Thread 0x7fff1ffff700 (LWP 26952)]
[New Thread 0x7fff1f7fe700 (LWP 26953)]
[New Thread 0x7fff1effd700 (LWP 26954)]
[New Thread 0x7fff1e7fc700 (LWP 26955)]
[New Thread 0x7fff1dffb700 (LWP 26956)]
[New Thread 0x7fff1d7fa700 (LWP 26957)]
[New Thread 0x7fff1cff9700 (LWP 26958)]
[New Thread 0x7ffefffff700 (LWP 26959)]
[New Thread 0x7ffeff7fe700 (LWP 26960)]
[New Thread 0x7ffefeffd700 (LWP 26961)]
[New Thread 0x7ffefe7fc700 (LWP 26962)]
[New Thread 0x7ffefdffb700 (LWP 26963)]
[New Thread 0x7ffefd7fa700 (LWP 26964)]
[New Thread 0x7ffefcff9700 (LWP 26965)]
[New Thread 0x7ffedffff700 (LWP 26966)]
[New Thread 0x7ffedf7fe700 (LWP 26967)]
[New Thread 0x7ffedeffd700 (LWP 26968)]
[New Thread 0x7ffede7fc700 (LWP 26969)]
[New Thread 0x7ffeddffb700 (LWP 26970)]
[New Thread 0x7ffedd7fa700 (LWP 26971)]
[New Thread 0x7ffedcff9700 (LWP 26972)]
[New Thread 0x7ffebffff700 (LWP 26973)]
[New Thread 0x7ffebf7fe700 (LWP 26974)]
[New Thread 0x7ffebeffd700 (LWP 26975)]
[New Thread 0x7ffebe7fc700 (LWP 26976)]
[New Thread 0x7ffebdffb700 (LWP 26980)]
[New Thread 0x7ffebd7fa700 (LWP 26984)]
[New Thread 0x7ffebcff9700 (LWP 26999)]
[New Thread 0x7ffe9ffff700 (LWP 27003)]
[New Thread 0x7ffe9f7fe700 (LWP 27007)]

Program received signal SIGSEGV Segmentation fault.
[Switching to Thread 0x7ffeff7fe700 (LWP 26960)]
0x00007ffff63e9ce4 in WKS::gc_heap::mark_object_simple(unsigned char**) ()
   from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.0/libcoreclr.so
(gdb) bt
#0  0x00007ffff63e9ce4 in WKS::gc_heap::mark_object_simple(unsigned char**) ()
   from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.0/libcoreclr.so
#1  0x00007ffff63edb1a in WKS::gc_heap::mark_through_cards_for_segments(void (*)(unsigned char**) int) ()
   from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.0/libcoreclr.so
#2  0x00007ffff63e013d in WKS::gc_heap::mark_phase(int int) () from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.0/libcoreclr.so
#3  0x00007ffff63dd977 in WKS::gc_heap::gc1() () from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.0/libcoreclr.so
#4  0x00007ffff63e7120 in WKS::gc_heap::garbage_collect(int) () from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.0/libcoreclr.so
#5  0x00007ffff63daa71 in WKS::GCHeap::GarbageCollectGeneration(unsigned int gc_reason) ()
   from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.0/libcoreclr.so
#6  0x00007ffff63dc0c9 in WKS::gc_heap::try_allocate_more_space(alloc_context* unsigned long int) ()
   from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.0/libcoreclr.so
#7  0x00007ffff63ffd7d in WKS::GCHeap::Alloc(gc_alloc_context* unsigned long unsigned int) ()
   from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.0/libcoreclr.so
#8  0x00007ffff6215750 in AllocateObject(MethodTable*) () from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.0/libcoreclr.so
#9  0x00007ffff6226246 in JIT_New(CORINFO_CLASS_STRUCT_*) () from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.0/libcoreclr.so
#10 0x00007fff7fcb3265 in ?? ()
#11 0x00007fff639de1f0 in ?? ()
#12 0x00007fff63aa7418 in ?? ()
#13 0x00007fff63e0f6d8 in ?? ()
#14 0x00007fff59f4ea20 in ?? ()
#15 0x00007ffeff7fd280 in ?? ()
#16 0x00007fff7fcb3200 in ?? ()
#17 0x0000000000000000 in ?? ()
```

The program runs without problems in Windows. The only native library used is System.Data.SqlClient otherwise its all no-unsafe C# code. Unfortunately I have not been successful in reproducing the bug in a smaller program and I cannot share the original program.

It's possibly (likely?) a memory corruption bug and not a GC bug as I have also experienced some weird C# exceptions (stuff that should be logically impossible).</Title_Description>
    <Label>question</Label>
    <Assignee>Maoni0</Assignee>
    <CreatedAt>20/06/2018 7:06:59 AM +00:00</CreatedAt>
    <ClosedAt>11/01/2019 9:42:07 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18562</IssueLabelID>
    <Title>R2R Dumper treats READYTORUN_SECTION_RUNTIME_FUNCTIONS as required</Title>
    <Description>Currently the dumper requires READYTORUN_SECTION_RUNTIME_FUNCTIONS section to be present. It is actually optional - see https://github.com/dotnet/coreclr/blob/master/src/vm/readytoruninfo.cpp#L551

We should handle the case where it's missing gracefully in r2rdump.</Description>
    <Title_Description>R2R Dumper treats READYTORUN_SECTION_RUNTIME_FUNCTIONS as required Currently the dumper requires READYTORUN_SECTION_RUNTIME_FUNCTIONS section to be present. It is actually optional - see https://github.com/dotnet/coreclr/blob/master/src/vm/readytoruninfo.cpp#L551

We should handle the case where it's missing gracefully in r2rdump.</Title_Description>
    <Label>area-ReadyToRun</Label>
    <Assignee>acmyu</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18560</IssueLabelID>
    <Title>GC.GetAllocatedBytesForCurrentThread always returns 0 when processor affinity is set to single proc</Title>
    <Description>When the processor affinity is set in explicit way `GC.GetAllocatedBytesForCurrentThread` always  returns 0. Even is something was allocated.

```cs
using System;

namespace gcstats
{
    class Program
    {
        static void Main(string[] args)
        {
            var before = System.GC.GetAllocatedBytesForCurrentThread();
            Console.WriteLine("Hello World!");
            var after = System.GC.GetAllocatedBytesForCurrentThread();
            Console.WriteLine($"after - before = {after - before}");
            Console.ReadLine();
        }
    }
}
```

```log
start /affinity 1 dotnet.exe run
Hello World!
after - before = 0

start dotnet.exe run
Hello World!
after - before = 7552

dotnet --info
.NET Core SDK (reflecting any global.json):
 Version:   2.1.300-rc1-008673
 Commit:    f5e3ddbe73

Runtime Environment:
 OS Name:     Windows
 OS Version:  10.0.16299
 OS Platform: Windows
 RID:         win10-x64
 Base Path:   C:\Program Files\dotnet\sdk\2.1.300-rc1-008673\

Host (useful for support):
  Version: 2.1.0-rc1
  Commit:  eb9bc92051
```

@jkotas @Maoni0 is this expected behavior? am I doing something wrong? 

I am porting CoreCLR benchmarks from xunit-performance to BenchmarkDotNet and I have faced this issue today when I was comparing the results of some unstable benchmarks with affinity set and without.

/cc @jorive 
</Description>
    <Title_Description>GC.GetAllocatedBytesForCurrentThread always returns 0 when processor affinity is set to single proc When the processor affinity is set in explicit way `GC.GetAllocatedBytesForCurrentThread` always  returns 0. Even is something was allocated.

```cs
using System;

namespace gcstats
{
    class Program
    {
        static void Main(string[] args)
        {
            var before = System.GC.GetAllocatedBytesForCurrentThread();
            Console.WriteLine("Hello World!");
            var after = System.GC.GetAllocatedBytesForCurrentThread();
            Console.WriteLine($"after - before = {after - before}");
            Console.ReadLine();
        }
    }
}
```

```log
start /affinity 1 dotnet.exe run
Hello World!
after - before = 0

start dotnet.exe run
Hello World!
after - before = 7552

dotnet --info
.NET Core SDK (reflecting any global.json):
 Version:   2.1.300-rc1-008673
 Commit:    f5e3ddbe73

Runtime Environment:
 OS Name:     Windows
 OS Version:  10.0.16299
 OS Platform: Windows
 RID:         win10-x64
 Base Path:   C:\Program Files\dotnet\sdk\2.1.300-rc1-008673\

Host (useful for support):
  Version: 2.1.0-rc1
  Commit:  eb9bc92051
```

@jkotas @Maoni0 is this expected behavior? am I doing something wrong? 

I am porting CoreCLR benchmarks from xunit-performance to BenchmarkDotNet and I have faced this issue today when I was comparing the results of some unstable benchmarks with affinity set and without.

/cc @jorive 
</Title_Description>
    <Label>area-GC</Label>
    <Assignee>VSadov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18559</IssueLabelID>
    <Title>Mirror changes from Anipik/ corefx</Title>
    <Description>This PR contains mirrored changes from Anipik/ corefx


**Please REBASE this PR when merging**</Description>
    <Title_Description>Mirror changes from Anipik/ corefx This PR contains mirrored changes from Anipik/ corefx


**Please REBASE this PR when merging**</Title_Description>
    <Label>
    </Label>
    <Assignee>Anipik</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18558</IssueLabelID>
    <Title>Mirror changes from Anipik/ corefx</Title>
    <Description>This PR contains mirrored changes from Anipik/ corefx


**Please REBASE this PR when merging**</Description>
    <Title_Description>Mirror changes from Anipik/ corefx This PR contains mirrored changes from Anipik/ corefx


**Please REBASE this PR when merging**</Title_Description>
    <Label>
    </Label>
    <Assignee>Anipik</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18557</IssueLabelID>
    <Title>Mirror changes from dotnet/corefx</Title>
    <Description>This PR contains mirrored changes from dotnet/corefx


**Please REBASE this PR when merging**</Description>
    <Title_Description>Mirror changes from dotnet/corefx This PR contains mirrored changes from dotnet/corefx


**Please REBASE this PR when merging**</Title_Description>
    <Label>
    </Label>
    <Assignee>ViktorHofer</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18554</IssueLabelID>
    <Title>Mirror changes from Anipik/ corefx</Title>
    <Description>This PR contains mirrored changes from Anipik/ corefx


**Please REBASE this PR when merging**</Description>
    <Title_Description>Mirror changes from Anipik/ corefx This PR contains mirrored changes from Anipik/ corefx


**Please REBASE this PR when merging**</Title_Description>
    <Label>
    </Label>
    <Assignee>Anipik</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18553</IssueLabelID>
    <Title>SSE2 Insert (pinsrw) has incorrect encoding on containment form</Title>
    <Description>SSE2 `Insert` (instruction `pinsrw`) has incorrect encoding on containment form:
```asm
;;; Vector128&lt;short&gt; v = Sse2.Insert(baseVector array[4] 7);
;;; compiled to

C46179C6620E07   vpinsrw  xmm12 xmm0 xmmword ptr [rdx+14] 7 ;;; VEX encoding
66440FC6620E07   pinsrw   xmm12 xmmword ptr [rdx+14] 7       ;;; non-VEX encoding
```
However the correct encoding should be
```asm
C46179C4620E07  vpinsrw  xmm12 xmm0 xmmword ptr [rdx+14] 7 ;;; VEX encoding
66440FC4620E07  pinsrw   xmm12 xmmword ptr [rdx+14] 7       ;;; non-VEX encoding
```

Note: the JIT dump is incorrect the above `xmmword ptr` should read `word ptr `.

SSE4.1 Insert works fine and this bug seems introduced from the recent containment change.

I will look into this issue. cc @CarolEidt @tannergooding </Description>
    <Title_Description>SSE2 Insert (pinsrw) has incorrect encoding on containment form SSE2 `Insert` (instruction `pinsrw`) has incorrect encoding on containment form:
```asm
;;; Vector128&lt;short&gt; v = Sse2.Insert(baseVector array[4] 7);
;;; compiled to

C46179C6620E07   vpinsrw  xmm12 xmm0 xmmword ptr [rdx+14] 7 ;;; VEX encoding
66440FC6620E07   pinsrw   xmm12 xmmword ptr [rdx+14] 7       ;;; non-VEX encoding
```
However the correct encoding should be
```asm
C46179C4620E07  vpinsrw  xmm12 xmm0 xmmword ptr [rdx+14] 7 ;;; VEX encoding
66440FC4620E07  pinsrw   xmm12 xmmword ptr [rdx+14] 7       ;;; non-VEX encoding
```

Note: the JIT dump is incorrect the above `xmmword ptr` should read `word ptr `.

SSE4.1 Insert works fine and this bug seems introduced from the recent containment change.

I will look into this issue. cc @CarolEidt @tannergooding </Title_Description>
    <Label>arch-x64</Label>
    <Assignee>fiigii</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18551</IssueLabelID>
    <Title>Avoid extra allocation in IDNA</Title>
    <Description>Fixes #18545</Description>
    <Title_Description>Avoid extra allocation in IDNA Fixes #18545</Title_Description>
    <Label>area-System.Globalization</Label>
    <Assignee>stephentoub</Assignee>
    <CreatedAt>19/06/2018 6:30:02 PM +00:00</CreatedAt>
    <ClosedAt>20/06/2018 1:50:39 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18549</IssueLabelID>
    <Title>Remove sbyte overloads of Intel AES intrinsics</Title>
    <Description>Currently each `Aes` intrinsic has `byte` and `sbyte` overloads but the unsigned `byte` is probably sufficient for data encryption/decryption operations.
```csharp
    public static class Aes 
    {
        public static bool IsSupported { get =&gt; IsSupported; }
        public static Vector128&lt;sbyte&gt; Decrypt(Vector128&lt;sbyte&gt; value Vector128&lt;sbyte&gt; roundKey) =&gt; Decrypt(value roundKey);
        public static Vector128&lt;byte&gt; Decrypt(Vector128&lt;byte&gt; value Vector128&lt;byte&gt; roundKey) =&gt; Decrypt(value roundKey);
        public static Vector128&lt;sbyte&gt; DecryptLast(Vector128&lt;sbyte&gt; value Vector128&lt;sbyte&gt; roundKey) =&gt; DecryptLast(value roundKey);
        public static Vector128&lt;byte&gt; DecryptLast(Vector128&lt;byte&gt; value Vector128&lt;byte&gt; roundKey) =&gt; DecryptLast(value roundKey);
        public static Vector128&lt;sbyte&gt; Encrypt(Vector128&lt;sbyte&gt; value Vector128&lt;sbyte&gt; roundKey) =&gt; Encrypt(value roundKey);
        public static Vector128&lt;byte&gt; Encrypt(Vector128&lt;byte&gt; value Vector128&lt;byte&gt; roundKey) =&gt; Encrypt(value roundKey);
        public static Vector128&lt;sbyte&gt; EncryptLast(Vector128&lt;sbyte&gt; value Vector128&lt;sbyte&gt; roundKey) =&gt; EncryptLast(value roundKey);
        public static Vector128&lt;byte&gt; EncryptLast(Vector128&lt;byte&gt; value Vector128&lt;byte&gt; roundKey) =&gt; EncryptLast(value roundKey);
        public static Vector128&lt;sbyte&gt; InvisibleMixColumn(Vector128&lt;sbyte&gt; value) =&gt; InvisibleMixColumn(value);
        public static Vector128&lt;byte&gt; InvisibleMixColumn(Vector128&lt;byte&gt; value) =&gt; InvisibleMixColumn(value);
        public static Vector128&lt;sbyte&gt; KeygenAssist(Vector128&lt;sbyte&gt; value byte control) =&gt; KeygenAssist(value control);
        public static Vector128&lt;byte&gt; KeygenAssist(Vector128&lt;byte&gt; value byte control) =&gt; KeygenAssist(value control);
    }
```</Description>
    <Title_Description>Remove sbyte overloads of Intel AES intrinsics Currently each `Aes` intrinsic has `byte` and `sbyte` overloads but the unsigned `byte` is probably sufficient for data encryption/decryption operations.
```csharp
    public static class Aes 
    {
        public static bool IsSupported { get =&gt; IsSupported; }
        public static Vector128&lt;sbyte&gt; Decrypt(Vector128&lt;sbyte&gt; value Vector128&lt;sbyte&gt; roundKey) =&gt; Decrypt(value roundKey);
        public static Vector128&lt;byte&gt; Decrypt(Vector128&lt;byte&gt; value Vector128&lt;byte&gt; roundKey) =&gt; Decrypt(value roundKey);
        public static Vector128&lt;sbyte&gt; DecryptLast(Vector128&lt;sbyte&gt; value Vector128&lt;sbyte&gt; roundKey) =&gt; DecryptLast(value roundKey);
        public static Vector128&lt;byte&gt; DecryptLast(Vector128&lt;byte&gt; value Vector128&lt;byte&gt; roundKey) =&gt; DecryptLast(value roundKey);
        public static Vector128&lt;sbyte&gt; Encrypt(Vector128&lt;sbyte&gt; value Vector128&lt;sbyte&gt; roundKey) =&gt; Encrypt(value roundKey);
        public static Vector128&lt;byte&gt; Encrypt(Vector128&lt;byte&gt; value Vector128&lt;byte&gt; roundKey) =&gt; Encrypt(value roundKey);
        public static Vector128&lt;sbyte&gt; EncryptLast(Vector128&lt;sbyte&gt; value Vector128&lt;sbyte&gt; roundKey) =&gt; EncryptLast(value roundKey);
        public static Vector128&lt;byte&gt; EncryptLast(Vector128&lt;byte&gt; value Vector128&lt;byte&gt; roundKey) =&gt; EncryptLast(value roundKey);
        public static Vector128&lt;sbyte&gt; InvisibleMixColumn(Vector128&lt;sbyte&gt; value) =&gt; InvisibleMixColumn(value);
        public static Vector128&lt;byte&gt; InvisibleMixColumn(Vector128&lt;byte&gt; value) =&gt; InvisibleMixColumn(value);
        public static Vector128&lt;sbyte&gt; KeygenAssist(Vector128&lt;sbyte&gt; value byte control) =&gt; KeygenAssist(value control);
        public static Vector128&lt;byte&gt; KeygenAssist(Vector128&lt;byte&gt; value byte control) =&gt; KeygenAssist(value control);
    }
```</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>fiigii</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18546</IssueLabelID>
    <Title>Avoid two unnecessary string.Substring calls in PunycodeDecode</Title>
    <Description>cc: @tarekgh @krwq </Description>
    <Title_Description>Avoid two unnecessary string.Substring calls in PunycodeDecode cc: @tarekgh @krwq </Title_Description>
    <Label>area-System.Globalization</Label>
    <Assignee>tarekgh</Assignee>
    <CreatedAt>19/06/2018 4:24:11 PM +00:00</CreatedAt>
    <ClosedAt>19/06/2018 9:28:33 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18545</IssueLabelID>
    <Title>GlobalizationMode.Invariant's PunycodeDecode repeatedly calling StringBuilder.ToString</Title>
    <Description>See all of these calls to `output.ToString()` including two in a loop and `output` isn't changing in this region:
https://github.com/dotnet/coreclr/blob/473d9b09c7e000480f41021c94fbffeae27cb179/src/System.Private.CoreLib/shared/System/Globalization/IdnMapping.cs#L776-L806

Seems like this should either a) create the string once rather than repeatedly creating it or b) retrieve the char from the StringBuilder to test it rather than using a string and an index.  In other words worst case we should be allocating one string here best case zero.  Given the potential expense of indexing into a StringBuilder I'm not sure which ends up being faster.

cc: @tarekgh @krwq </Description>
    <Title_Description>GlobalizationMode.Invariant's PunycodeDecode repeatedly calling StringBuilder.ToString See all of these calls to `output.ToString()` including two in a loop and `output` isn't changing in this region:
https://github.com/dotnet/coreclr/blob/473d9b09c7e000480f41021c94fbffeae27cb179/src/System.Private.CoreLib/shared/System/Globalization/IdnMapping.cs#L776-L806

Seems like this should either a) create the string once rather than repeatedly creating it or b) retrieve the char from the StringBuilder to test it rather than using a string and an index.  In other words worst case we should be allocating one string here best case zero.  Given the potential expense of indexing into a StringBuilder I'm not sure which ends up being faster.

cc: @tarekgh @krwq </Title_Description>
    <Label>area-System.Globalization</Label>
    <Assignee>tarekgh</Assignee>
    <CreatedAt>19/06/2018 4:16:42 PM +00:00</CreatedAt>
    <ClosedAt>20/06/2018 1:50:39 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18544</IssueLabelID>
    <Title>[Linux/arm64]  GitHub_18497 fails with assert</Title>
    <Description>```
corerun GitHub_18497.exe

Assert failure(PID 38848 [0x000097c0] Thread: 38848 [0x97c0]): 
Assertion failed 'varDsc-&gt;lvFieldCnt == 1' in 'GitHub_18497:Sum(struct):struct' (IL size 18)

    File: src/jit/lclvars.cpp Line: 2020
```

@Caroleidt To track new failure introduced in #18499</Description>
    <Title_Description>[Linux/arm64]  GitHub_18497 fails with assert ```
corerun GitHub_18497.exe

Assert failure(PID 38848 [0x000097c0] Thread: 38848 [0x97c0]): 
Assertion failed 'varDsc-&gt;lvFieldCnt == 1' in 'GitHub_18497:Sum(struct):struct' (IL size 18)

    File: src/jit/lclvars.cpp Line: 2020
```

@Caroleidt To track new failure introduced in #18499</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18543</IssueLabelID>
    <Title>Internal Error in the .NET Runtime</Title>
    <Description>Hi All
I'm not sure the right place to ask this but I could use some help.
It looks as though after an upgrade to .NET 4.7 we're having our apps randomly crash.
We're seeing errors like this:
Faulting module name: clr.dll version: 4.7.3110.0 time stamp: 0x5ae8c35b
Exception code: 0x800703e9
Fault offset: 0x002b15da
Faulting process id: 0x3110
Faulting application start time: 0x01d407cfc700c079
The process was terminated due to an internal error in the .NET Runtime at IP 72F215DA (72C70000) with exit code 800703e9.

What is the right process for getting this resolved?
</Description>
    <Title_Description>Internal Error in the .NET Runtime Hi All
I'm not sure the right place to ask this but I could use some help.
It looks as though after an upgrade to .NET 4.7 we're having our apps randomly crash.
We're seeing errors like this:
Faulting module name: clr.dll version: 4.7.3110.0 time stamp: 0x5ae8c35b
Exception code: 0x800703e9
Fault offset: 0x002b15da
Faulting process id: 0x3110
Faulting application start time: 0x01d407cfc700c079
The process was terminated due to an internal error in the .NET Runtime at IP 72F215DA (72C70000) with exit code 800703e9.

What is the right process for getting this resolved?
</Title_Description>
    <Label>question</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>19/06/2018 2:16:50 PM +00:00</CreatedAt>
    <ClosedAt>11/01/2019 9:39:35 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18542</IssueLabelID>
    <Title>Inlined Struct wrapper .ctors are non-zero cost</Title>
    <Description>(Some now fixed by https://github.com/dotnet/coreclr/pull/19429)

This is problematic for example when adding formatting and/or buffering capabilities over `Span&lt;T&gt;`

As seen in "Add support for `BufferWriter&lt;T&gt;` to the JsonWriter" https://github.com/dotnet/corefxlab/pull/2366

When a struct wraps a struct (but has no additional fields) it becomes a non-zero cost abstraction for its constructor (but not method calls) e.g. [sharplab.io](https://sharplab.io/#v2:EYLgHgbALANALiAhgZwLYB8ACAGABJgRgG4BYAKB3wIDoAlAVwDs4BLVAU2oGEB7VABxYAbdgCcAymIBuLAMbtkpMuUwBmKhHwAmKgHZyAb1y5yx/OsKbMUXADUWiLkJTIAFAEpTxg17PGpiKK4srgAvLiM7ADuuFweSn5mstQAsvG+AL6mvmoa+Db2iOJwovSycAQevj5kif6BuMgEYRHRuOKVkTFx7u4JdU2p6bXGWSNmORYEVgUOxaXlWlXjNXW4AUHIOuFd7Uu7Ha67Pb39iVtDfZnZ47mW+XZzJWVwqstmq3Ubjeo7beJvA77f6dNonU6+PzIVSXM5jSZ5ayPIrPcpQd7eSFmb7IGx/GLidEHQH/YEE0HdDy9CHjKFQWHXWoI+5IwrzF4AVgxuE+iRxHJaBy5ByJ/xJBLJ7QpsSp1KutLMyA5DPGY0SzOmD0KThcri4wU8KyxxmSaXlZjV6tuUxmyPZ5TeHUaBENH2NzpVFshGttbNRr1c4h0W1dmIVxguZrhxp9WqeCwDAJ+oZ57uhntGWNjrPjL3RhMaUBTvLpGdwlom1sRsxRCa54gFSuLaeVUcZ8IoFh0+sMkIA2il2HAABY8AAmAEkBEJXIOR+Op/whAB5fisHiMZDUAByPAnjCELEYR4A5u4ALqQu42M2QktjDu5ZD+qW92n8UQsAJwdixXAAfVkfor3UQ59VkdwwgAPgAkJwiAvwQIeM1oNglVH3UZ8Ez2N8/A/L9EB/KUAMULwkKDQNmmQSDQhg/9kBaRRENpa9cBQ2iSPQ8gVEwl8AVwsx8O/X8gxIpRyMdYMaLohjwiYys/FY9iZK45RO0aPioAE4whMIkT1Ho8SWNA/NMOkkjGKIZjFIsG8PFQ+jVJ4jTsIbbTcF0oiC0M7jjPaesbGohzZMaKyFLMJT7I4xy2zIDIgA)

Given
```csharp
using System.Runtime.CompilerServices;

public static class Program
{  
   public static void ViaClass()
   {
       var c = new C();
       c.M();
   }
 
   public static void ViaStruct1()
   {
       var s1 = new S1(new C());
       s1.M();
   }
     
   public static void ViaStruct2()
   {
       var s2 = new S2(new S1(new C()));
       s2.M();
   }
 
   public static void ViaStruct3()
   {
       var s3 = new S3(new S2(new S1(new C())));
       s3.M();
   }

   public static void ViaStruct4()
   {
       var s4 = new S4(new S3(new S2(new S1(new C()))));
       s4.M();
   }
 
   public static void ViaStruct5()
   {
       var s5 = new S5(new S4(new S3(new S2(new S1(new C())))));
       s5.M();
   }
}

public class C 
{
    [MethodImpl(MethodImplOptions.NoInlining)]
    public void M()
    {
    }
}

public struct S1
{
    private C _c;
  
    public S1(C c) =&gt; _c = c;    
    public void M() =&gt; _c.M();
}

public struct S2
{
    private S1 _s;
  
    public S2(S1 s) =&gt; _s = s;    
    public void M() =&gt; _s.M();
}

public struct S3
{
    private S2 _s;

    public S3(S2 s) =&gt; _s = s;    
    public void M() =&gt; _s.M();
}

public struct S4
{
    private S3 _s;

    public S4(S3 s) =&gt; _s = s;    
    public void M() =&gt; _s.M();
}

public struct S5
{
    private S4 _s;

    public S5(S4 s) =&gt; _s = s;    
    public void M() =&gt; _s.M();
}
```
Each additional wrapper introduces redundant work in the asm e.g.
```asm
Program.ViaClass()
    L0000: sub rsp 0x28
    L0004: mov rcx 0x7ffa88b77008
    L000e: call 0x7ffadf232520
    L0013: mov rcx rax
    L0016: call C.M()
    L001b: nop
    L001c: add rsp 0x28
    L0020: ret

Program.ViaStruct1()
    L0000: sub rsp 0x28
    L0004: mov rcx 0x7ffa88b77008
    L000e: call 0x7ffadf232520
    L0013: mov rcx rax
    L0016: call C.M()
    L001b: nop
    L001c: add rsp 0x28
    L0020: ret

Program.ViaStruct2()
    L0000: sub rsp 0x28
    L0004: mov rcx 0x7ffa88b77008
    L000e: call 0x7ffadf232520
    L0013: mov rcx rax
    L0016: mov rax rcx
    L0019: mov rcx rax
    L001c: mov [rsp+0x20] rcx
    L0021: mov rcx [rsp+0x20]
    L0026: cmp [rcx] ecx
    L0028: call C.M()
    L002d: nop
    L002e: add rsp 0x28
    L0032: ret

Program.ViaStruct3()
    L0000: sub rsp 0x28
    L0004: xor eax eax
    L0006: mov [rsp+0x20] rax
    L000b: mov rcx 0x7ffa88b77008
    L0015: call 0x7ffadf232520
    L001a: mov rcx rax
    L001d: mov rax rcx
    L0020: mov rcx rax
    L0023: mov rax rcx
    L0026: mov rcx rax
    L0029: lea rax [rsp+0x20]
    L002e: mov [rax] rcx
    L0031: mov rcx [rsp+0x20]
    L0036: cmp [rcx] ecx
    L0038: call C.M()
    L003d: nop
    L003e: add rsp 0x28
    L0042: ret

Program.ViaStruct4()
    L0000: push rdi
    L0001: sub rsp 0x40
    L0005: lea rdi [rsp+0x28]
    L000a: mov ecx 0x6
    L000f: xor eax eax
    L0011: rep stosd
    L0013: mov rcx 0x7ffa88b77008
    L001d: call 0x7ffadf232520
    L0022: mov rcx rax
    L0025: mov rax rcx
    L0028: mov rcx rax
    L002b: mov rax rcx
    L002e: xor ecx ecx
    L0030: mov [rsp+0x30] rcx
    L0035: mov rcx rax
    L0038: lea rax [rsp+0x30]
    L003d: mov [rax] rcx
    L0040: mov rcx [rsp+0x30]
    L0045: mov [rsp+0x28] rcx
    L004a: mov rcx [rsp+0x28]
    L004f: lea rax [rsp+0x38]
    L0054: mov [rax] rcx
    L0057: mov rcx [rsp+0x38]
    L005c: cmp [rcx] ecx
    L005e: call C.M()
    L0063: nop
    L0064: add rsp 0x40
    L0068: pop rdi
    L0069: ret

Program.ViaStruct5()
    L0000: push rdi
    L0001: sub rsp 0x50
    L0005: lea rdi [rsp+0x28]
    L000a: mov ecx 0xa
    L000f: xor eax eax
    L0011: rep stosd
    L0013: mov rcx 0x7ffa88b77008
    L001d: call 0x7ffadf232520
    L0022: mov rcx rax
    L0025: mov rax rcx
    L0028: mov rcx rax
    L002b: mov rax rcx
    L002e: xor ecx ecx
    L0030: mov [rsp+0x40] rcx
    L0035: mov rcx rax
    L0038: lea rax [rsp+0x40]
    L003d: mov [rax] rcx
    L0040: xor ecx ecx
    L0042: mov [rsp+0x38] rcx
    L0047: mov rcx [rsp+0x40]
    L004c: mov [rsp+0x30] rcx
    L0051: mov rcx [rsp+0x30]
    L0056: lea rax [rsp+0x38]
    L005b: mov [rax] rcx
    L005e: mov rcx [rsp+0x38]
    L0063: mov [rsp+0x28] rcx
    L0068: mov rcx [rsp+0x28]
    L006d: lea rax [rsp+0x48]
    L0072: mov [rax] rcx
    L0075: mov rcx [rsp+0x48]
    L007a: cmp [rcx] ecx
    L007c: call C.M()
    L0081: nop
    L0082: add rsp 0x50
    L0086: pop rdi
    L0087: ret
```

category:cq
theme:structs
skill-level:expert
cost:medium</Description>
    <Title_Description>Inlined Struct wrapper .ctors are non-zero cost (Some now fixed by https://github.com/dotnet/coreclr/pull/19429)

This is problematic for example when adding formatting and/or buffering capabilities over `Span&lt;T&gt;`

As seen in "Add support for `BufferWriter&lt;T&gt;` to the JsonWriter" https://github.com/dotnet/corefxlab/pull/2366

When a struct wraps a struct (but has no additional fields) it becomes a non-zero cost abstraction for its constructor (but not method calls) e.g. [sharplab.io](https://sharplab.io/#v2:EYLgHgbALANALiAhgZwLYB8ACAGABJgRgG4BYAKB3wIDoAlAVwDs4BLVAU2oGEB7VABxYAbdgCcAymIBuLAMbtkpMuUwBmKhHwAmKgHZyAb1y5yx/OsKbMUXADUWiLkJTIAFAEpTxg17PGpiKK4srgAvLiM7ADuuFweSn5mstQAsvG+AL6mvmoa+Db2iOJwovSycAQevj5kif6BuMgEYRHRuOKVkTFx7u4JdU2p6bXGWSNmORYEVgUOxaXlWlXjNXW4AUHIOuFd7Uu7Ha67Pb39iVtDfZnZ47mW+XZzJWVwqstmq3Ubjeo7beJvA77f6dNonU6+PzIVSXM5jSZ5ayPIrPcpQd7eSFmb7IGx/GLidEHQH/YEE0HdDy9CHjKFQWHXWoI+5IwrzF4AVgxuE+iRxHJaBy5ByJ/xJBLJ7QpsSp1KutLMyA5DPGY0SzOmD0KThcri4wU8KyxxmSaXlZjV6tuUxmyPZ5TeHUaBENH2NzpVFshGttbNRr1c4h0W1dmIVxguZrhxp9WqeCwDAJ+oZ57uhntGWNjrPjL3RhMaUBTvLpGdwlom1sRsxRCa54gFSuLaeVUcZ8IoFh0+sMkIA2il2HAABY8AAmAEkBEJXIOR+Op/whAB5fisHiMZDUAByPAnjCELEYR4A5u4ALqQu42M2QktjDu5ZD+qW92n8UQsAJwdixXAAfVkfor3UQ59VkdwwgAPgAkJwiAvwQIeM1oNglVH3UZ8Ez2N8/A/L9EB/KUAMULwkKDQNmmQSDQhg/9kBaRRENpa9cBQ2iSPQ8gVEwl8AVwsx8O/X8gxIpRyMdYMaLohjwiYys/FY9iZK45RO0aPioAE4whMIkT1Ho8SWNA/NMOkkjGKIZjFIsG8PFQ+jVJ4jTsIbbTcF0oiC0M7jjPaesbGohzZMaKyFLMJT7I4xy2zIDIgA)

Given
```csharp
using System.Runtime.CompilerServices;

public static class Program
{  
   public static void ViaClass()
   {
       var c = new C();
       c.M();
   }
 
   public static void ViaStruct1()
   {
       var s1 = new S1(new C());
       s1.M();
   }
     
   public static void ViaStruct2()
   {
       var s2 = new S2(new S1(new C()));
       s2.M();
   }
 
   public static void ViaStruct3()
   {
       var s3 = new S3(new S2(new S1(new C())));
       s3.M();
   }

   public static void ViaStruct4()
   {
       var s4 = new S4(new S3(new S2(new S1(new C()))));
       s4.M();
   }
 
   public static void ViaStruct5()
   {
       var s5 = new S5(new S4(new S3(new S2(new S1(new C())))));
       s5.M();
   }
}

public class C 
{
    [MethodImpl(MethodImplOptions.NoInlining)]
    public void M()
    {
    }
}

public struct S1
{
    private C _c;
  
    public S1(C c) =&gt; _c = c;    
    public void M() =&gt; _c.M();
}

public struct S2
{
    private S1 _s;
  
    public S2(S1 s) =&gt; _s = s;    
    public void M() =&gt; _s.M();
}

public struct S3
{
    private S2 _s;

    public S3(S2 s) =&gt; _s = s;    
    public void M() =&gt; _s.M();
}

public struct S4
{
    private S3 _s;

    public S4(S3 s) =&gt; _s = s;    
    public void M() =&gt; _s.M();
}

public struct S5
{
    private S4 _s;

    public S5(S4 s) =&gt; _s = s;    
    public void M() =&gt; _s.M();
}
```
Each additional wrapper introduces redundant work in the asm e.g.
```asm
Program.ViaClass()
    L0000: sub rsp 0x28
    L0004: mov rcx 0x7ffa88b77008
    L000e: call 0x7ffadf232520
    L0013: mov rcx rax
    L0016: call C.M()
    L001b: nop
    L001c: add rsp 0x28
    L0020: ret

Program.ViaStruct1()
    L0000: sub rsp 0x28
    L0004: mov rcx 0x7ffa88b77008
    L000e: call 0x7ffadf232520
    L0013: mov rcx rax
    L0016: call C.M()
    L001b: nop
    L001c: add rsp 0x28
    L0020: ret

Program.ViaStruct2()
    L0000: sub rsp 0x28
    L0004: mov rcx 0x7ffa88b77008
    L000e: call 0x7ffadf232520
    L0013: mov rcx rax
    L0016: mov rax rcx
    L0019: mov rcx rax
    L001c: mov [rsp+0x20] rcx
    L0021: mov rcx [rsp+0x20]
    L0026: cmp [rcx] ecx
    L0028: call C.M()
    L002d: nop
    L002e: add rsp 0x28
    L0032: ret

Program.ViaStruct3()
    L0000: sub rsp 0x28
    L0004: xor eax eax
    L0006: mov [rsp+0x20] rax
    L000b: mov rcx 0x7ffa88b77008
    L0015: call 0x7ffadf232520
    L001a: mov rcx rax
    L001d: mov rax rcx
    L0020: mov rcx rax
    L0023: mov rax rcx
    L0026: mov rcx rax
    L0029: lea rax [rsp+0x20]
    L002e: mov [rax] rcx
    L0031: mov rcx [rsp+0x20]
    L0036: cmp [rcx] ecx
    L0038: call C.M()
    L003d: nop
    L003e: add rsp 0x28
    L0042: ret

Program.ViaStruct4()
    L0000: push rdi
    L0001: sub rsp 0x40
    L0005: lea rdi [rsp+0x28]
    L000a: mov ecx 0x6
    L000f: xor eax eax
    L0011: rep stosd
    L0013: mov rcx 0x7ffa88b77008
    L001d: call 0x7ffadf232520
    L0022: mov rcx rax
    L0025: mov rax rcx
    L0028: mov rcx rax
    L002b: mov rax rcx
    L002e: xor ecx ecx
    L0030: mov [rsp+0x30] rcx
    L0035: mov rcx rax
    L0038: lea rax [rsp+0x30]
    L003d: mov [rax] rcx
    L0040: mov rcx [rsp+0x30]
    L0045: mov [rsp+0x28] rcx
    L004a: mov rcx [rsp+0x28]
    L004f: lea rax [rsp+0x38]
    L0054: mov [rax] rcx
    L0057: mov rcx [rsp+0x38]
    L005c: cmp [rcx] ecx
    L005e: call C.M()
    L0063: nop
    L0064: add rsp 0x40
    L0068: pop rdi
    L0069: ret

Program.ViaStruct5()
    L0000: push rdi
    L0001: sub rsp 0x50
    L0005: lea rdi [rsp+0x28]
    L000a: mov ecx 0xa
    L000f: xor eax eax
    L0011: rep stosd
    L0013: mov rcx 0x7ffa88b77008
    L001d: call 0x7ffadf232520
    L0022: mov rcx rax
    L0025: mov rax rcx
    L0028: mov rcx rax
    L002b: mov rax rcx
    L002e: xor ecx ecx
    L0030: mov [rsp+0x40] rcx
    L0035: mov rcx rax
    L0038: lea rax [rsp+0x40]
    L003d: mov [rax] rcx
    L0040: xor ecx ecx
    L0042: mov [rsp+0x38] rcx
    L0047: mov rcx [rsp+0x40]
    L004c: mov [rsp+0x30] rcx
    L0051: mov rcx [rsp+0x30]
    L0056: lea rax [rsp+0x38]
    L005b: mov [rax] rcx
    L005e: mov rcx [rsp+0x38]
    L0063: mov [rsp+0x28] rcx
    L0068: mov rcx [rsp+0x28]
    L006d: lea rax [rsp+0x48]
    L0072: mov [rax] rcx
    L0075: mov rcx [rsp+0x48]
    L007a: cmp [rcx] ecx
    L007c: call C.M()
    L0081: nop
    L0082: add rsp 0x50
    L0086: pop rdi
    L0087: ret
```

category:cq
theme:structs
skill-level:expert
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>mikedn</Assignee>
    <CreatedAt>19/06/2018 12:57:19 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18541</IssueLabelID>
    <Title>0xc0000005(Access violation) when StackOverflow happen in async path?</Title>
    <Description>Test with win10x64 netcoreapp2.1 vscode1.25(Insider)

Debug in vscode/vs. You can see app exited with `0x800703e9`(`COR_E_STACKOVERFLOW`) when run SOF  in sync with 1 args and exited with `0xc0000005`(`Access violation`) when run SOF in async without args. And the stacktrace can't be catch in async mode as it does in sync.

&lt;details&gt;
&lt;summary&gt;code&lt;/summary&gt;

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Threading.Tasks;

namespace ConsoleApp2
{
    internal class Program
    {
        private static void Main(string[] args)
        {
            if (args.Length &gt; 0)
            {
                Console.WriteLine("SOF in sync");
                SOF();
            }
            else
            {
                Console.WriteLine("SOF in async");
                SOFAsync().Wait();
            }
        }

        private static async Task SOFAsync()
        {
            await Task.Delay(100);
            SOF();
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        private static void SOF()
        {
            SOF();
        }
    }
}
```

&lt;/details&gt;</Description>
    <Title_Description>0xc0000005(Access violation) when StackOverflow happen in async path? Test with win10x64 netcoreapp2.1 vscode1.25(Insider)

Debug in vscode/vs. You can see app exited with `0x800703e9`(`COR_E_STACKOVERFLOW`) when run SOF  in sync with 1 args and exited with `0xc0000005`(`Access violation`) when run SOF in async without args. And the stacktrace can't be catch in async mode as it does in sync.

&lt;details&gt;
&lt;summary&gt;code&lt;/summary&gt;

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Threading.Tasks;

namespace ConsoleApp2
{
    internal class Program
    {
        private static void Main(string[] args)
        {
            if (args.Length &gt; 0)
            {
                Console.WriteLine("SOF in sync");
                SOF();
            }
            else
            {
                Console.WriteLine("SOF in async");
                SOFAsync().Wait();
            }
        }

        private static async Task SOFAsync()
        {
            await Task.Delay(100);
            SOF();
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        private static void SOF()
        {
            SOF();
        }
    }
}
```

&lt;/details&gt;</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>19/06/2018 12:47:01 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18539</IssueLabelID>
    <Title>Call native methods of the CLR itself from managed code</Title>
    <Description>Hi 
is it possible to call a c++ method of the program that hosts the CoreCLR from inside the loaded managed assembly?

I need to integrate a C# programm into my C++ simulation project. So I successfully set up my C++ Project to hosted the CoreCLR and I'm able to call functions from the C# Code.
Now the C# itself needs to call into the C++ Code.

I tried native calls using [DllImport] with some test library successfully. But the external method symbols should be looked up in the main programm instead of another lib like you can do with dlopen(NULL) on linux.

I have done that whole integration in mono a few month ago but as the C# code was origianaly build for .NET Core I want to go with it now.

In Mono you can use the __Internal keyword with the DllImport attribute to encounter this topic. Is there any possibility to do the same with .NETCore? 

Regards
Jens

PS: I cannot use LoadLibrary() since I'm on linux and hence cannot use the kernel32.dll</Description>
    <Title_Description>Call native methods of the CLR itself from managed code Hi 
is it possible to call a c++ method of the program that hosts the CoreCLR from inside the loaded managed assembly?

I need to integrate a C# programm into my C++ simulation project. So I successfully set up my C++ Project to hosted the CoreCLR and I'm able to call functions from the C# Code.
Now the C# itself needs to call into the C++ Code.

I tried native calls using [DllImport] with some test library successfully. But the external method symbols should be looked up in the main programm instead of another lib like you can do with dlopen(NULL) on linux.

I have done that whole integration in mono a few month ago but as the C# code was origianaly build for .NET Core I want to go with it now.

In Mono you can use the __Internal keyword with the DllImport attribute to encounter this topic. Is there any possibility to do the same with .NETCore? 

Regards
Jens

PS: I cannot use LoadLibrary() since I'm on linux and hence cannot use the kernel32.dll</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>19/06/2018 11:23:11 AM +00:00</CreatedAt>
    <ClosedAt>4/01/2019 2:28:24 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18537</IssueLabelID>
    <Title>Test failure: JIT_Regression._JitBlue_GitHub_18497_GitHub_18497_GitHub_18497_/_JitBlue_GitHub_18497_GitHub_18497_GitHub_18497_cmd</Title>
    <Description>Opened on behalf of @Sunny-pu

The test `JIT_Regression._JitBlue_GitHub_18497_GitHub_18497_GitHub_18497_/_JitBlue_GitHub_18497_GitHub_18497_GitHub_18497_cmd` has failed.


    
    Return code:      1
    Raw output file:      /home/helixbot/dotnetbuild/work/4ad925d1-68a5-4fb6-a02b-ec0e293a9d7b/Work/5adc0e71-0040-44e0-8eb2-8cc4d5380b66/Unzip/Reports\JIT.Regression\JitBlue\GitHub_18497\GitHub_18497\GitHub_18497.output.txt
    Raw output:
    BEGIN EXECUTION
    /home/helixbot/dotnetbuild/work/4ad925d1-68a5-4fb6-a02b-ec0e293a9d7b/Payload/corerun GitHub_18497.exe
    Failed: v = &lt;1 1 236.1857 1 1 1 1 1&gt;
    Expected: 100
    Actual: 255
    END EXECUTION - FAILED
    Test Harness Exitcode is : 1
    
    To run the test:
    &gt; set CORE_ROOT=/home/helixbot/dotnetbuild/work/4ad925d1-68a5-4fb6-a02b-ec0e293a9d7b/Payload
    &gt; /home/helixbot/dotnetbuild/work/4ad925d1-68a5-4fb6-a02b-ec0e293a9d7b/Work/5adc0e71-0040-44e0-8eb2-8cc4d5380b66/Unzip/JitBlue/GitHub_18497/GitHub_18497/GitHub_18497.sh
    
    Expected: True
    Actual:   False

        Stack Trace:

Details: 
https://mc.dot.net/#/product/netcore/master/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fcli~2F/build/20180619.01/workItem/JIT.Regression.XUnitWrapper/analysis/xunit/JIT_Regression._JitBlue_GitHub_18497_GitHub_18497_GitHub_18497_~2F_JitBlue_GitHub_18497_GitHub_18497_GitHub_18497_cmd
        
Build : Master - 20180619.01 (Core Tests)
Failing configurations:
- redhat.69.amd64-x64
  - 
- ubuntu.1804.amd64-x64
  - 
- osx.1013.amd64-x64
  - 
- redhat.73.amd64-x64
  - 
- debian.82.amd64-x64
  -</Description>
    <Title_Description>Test failure: JIT_Regression._JitBlue_GitHub_18497_GitHub_18497_GitHub_18497_/_JitBlue_GitHub_18497_GitHub_18497_GitHub_18497_cmd Opened on behalf of @Sunny-pu

The test `JIT_Regression._JitBlue_GitHub_18497_GitHub_18497_GitHub_18497_/_JitBlue_GitHub_18497_GitHub_18497_GitHub_18497_cmd` has failed.


    
    Return code:      1
    Raw output file:      /home/helixbot/dotnetbuild/work/4ad925d1-68a5-4fb6-a02b-ec0e293a9d7b/Work/5adc0e71-0040-44e0-8eb2-8cc4d5380b66/Unzip/Reports\JIT.Regression\JitBlue\GitHub_18497\GitHub_18497\GitHub_18497.output.txt
    Raw output:
    BEGIN EXECUTION
    /home/helixbot/dotnetbuild/work/4ad925d1-68a5-4fb6-a02b-ec0e293a9d7b/Payload/corerun GitHub_18497.exe
    Failed: v = &lt;1 1 236.1857 1 1 1 1 1&gt;
    Expected: 100
    Actual: 255
    END EXECUTION - FAILED
    Test Harness Exitcode is : 1
    
    To run the test:
    &gt; set CORE_ROOT=/home/helixbot/dotnetbuild/work/4ad925d1-68a5-4fb6-a02b-ec0e293a9d7b/Payload
    &gt; /home/helixbot/dotnetbuild/work/4ad925d1-68a5-4fb6-a02b-ec0e293a9d7b/Work/5adc0e71-0040-44e0-8eb2-8cc4d5380b66/Unzip/JitBlue/GitHub_18497/GitHub_18497/GitHub_18497.sh
    
    Expected: True
    Actual:   False

        Stack Trace:

Details: 
https://mc.dot.net/#/product/netcore/master/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fcli~2F/build/20180619.01/workItem/JIT.Regression.XUnitWrapper/analysis/xunit/JIT_Regression._JitBlue_GitHub_18497_GitHub_18497_GitHub_18497_~2F_JitBlue_GitHub_18497_GitHub_18497_GitHub_18497_cmd
        
Build : Master - 20180619.01 (Core Tests)
Failing configurations:
- redhat.69.amd64-x64
  - 
- ubuntu.1804.amd64-x64
  - 
- osx.1013.amd64-x64
  - 
- redhat.73.amd64-x64
  - 
- debian.82.amd64-x64
  -</Title_Description>
    <Label>test-run-core</Label>
    <Assignee>RussKeldorph</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18536</IssueLabelID>
    <Title>Adding types to R2R images using profiler metadata emit at ModuleLoadFinished triggers AV</Title>
    <Description>After the ModuleLoadFinished callback returns the runtime attempts to update a type loader cache called the 'AvailableClassHash'. Historically this cache was always created eagerly prior to ModuleLoadFinished being called but ReadyToRun changed the behavior to be lazy. Unfortunately the code path the profiler used to update that cache wasn't changed to account for the lazy creation so it attempts to insert into the non-existent cache and triggers an AV. I stumbled upon the issue accidentally while trying to test something else. My repro was adding a type forwarder to System.Runtime.dll but based on code review I think the issue also applies to adding new TypeDefs.
Currently 'Ready To Run' compilation is used for all framework images except System.Private.CoreLib.dll.

Callstack with the AV:

 	coreclr.dll!ClassLoader::AddExportedTypeHaveLock(Module * pManifestModule unsigned int cl AllocMemTracker * pamTracker) Line 4771	C++
 	[Inline Frame] coreclr.dll!ClassLoader::AddExportedTypeDontHaveLock(Module *) Line 4679	C++
	coreclr.dll!Assembly::AddExportedType(unsigned int cl) Line 2176	C++
 	coreclr.dll!Module::NotifyProfilerLoadFinished(HRESULT hr) Line 248	C++
 	coreclr.dll!DomainFile::PostLoadLibrary() Line 1035	C++
 	coreclr.dll!DomainFile::DoIncrementalLoad(FileLoadLevel level) Line 582	C++
 	coreclr.dll!AppDomain::TryIncrementalLoad(DomainFile * pFile FileLoadLevel workLevel Wrapper&lt;FileLoadLock *&amp;DoNothing&lt;FileLoadLock *&gt;&amp;FileLoadLock::HolderLeave0&amp;CompareDefault&lt;FileLoadLock *&gt;21&gt; &amp; lockHolder) Line 5841	C++
 	coreclr.dll!AppDomain::LoadDomainFile(FileLoadLock * pLock FileLoadLevel targetLevel) Line 5773	C++
 	coreclr.dll!AppDomain::LoadDomainAssemblyInternal(AssemblySpec * pIdentity PEAssembly * pFile FileLoadLevel targetLevel) Line 5603	C++
 	coreclr.dll!AppDomain::LoadDomainAssembly(AssemblySpec * pSpec PEAssembly * pFile FileLoadLevel targetLevel) Line 5490	C++
 	coreclr.dll!Module::LoadAssembly(AppDomain * pDomain unsigned int kAssemblyRef const char * szWinRtTypeNamespace const char * szWinRtTypeClassName) Line 5613	C++
 	coreclr.dll!Assembly::FindModuleByTypeRef(Module * pModule unsigned int tkType Loader::LoadFlag loadFlag int * pfNoResolutionScope) Line 1274	C++
 	coreclr.dll!ClassLoader::LoadTypeDefOrRefThrowing(Module * pModule unsigned int typeDefOrRef ClassLoader::NotFoundAction fNotFoundAction ClassLoader::PermitUninstantiatedFlag fUninstantiated unsigned int tokenNotToLoad ClassLoadLevel level) Line 3003	C++
 	coreclr.dll!ClassLoader::LoadApproxTypeThrowing(Module * pModule unsigned int tok SigPointer * pSigInst const SigTypeContext * pClassTypeContext) Line 3416	C++
 	[Inline Frame] coreclr.dll!ClassLoader::LoadApproxParentThrowing(Module *) Line 3462	C++
 	coreclr.dll!ClassLoader::CreateTypeHandleForTypeDefThrowing(Module * pModule unsigned int cl Instantiation inst AllocMemTracker * pamTracker) Line 11906	C++
 	coreclr.dll!ClassLoader::CreateTypeHandleForTypeKey(TypeKey * pKey AllocMemTracker * pamTracker) Line 3589	C++
 	coreclr.dll!ClassLoader::LoadTypeHandleForTypeKey_Body(TypeKey * pTypeKey TypeHandle typeHnd ClassLoadLevel targetLevel) Line 4325	C++
 	coreclr.dll!ClassLoader::LoadTypeHandleForTypeKey(TypeKey * pTypeKey TypeHandle typeHnd ClassLoadLevel targetLevel const InstantiationContext * pInstContext) Line 4044	C++
 	coreclr.dll!ClassLoader::LoadTypeDefThrowing(Module * pModule unsigned int typeDef ClassLoader::NotFoundAction fNotFoundAction ClassLoader::PermitUninstantiatedFlag fUninstantiated unsigned int tokenNotToLoad ClassLoadLevel level Instantiation * pTargetInstantiation) Line 2887	C++
 	coreclr.dll!ClassLoader::LoadTypeDefOrRefThrowing(Module * pModule unsigned int typeDefOrRef ClassLoader::NotFoundAction fNotFoundAction ClassLoader::PermitUninstantiatedFlag fUninstantiated unsigned int tokenNotToLoad ClassLoadLevel level) Line 3065	C++
 	coreclr.dll!Assembly::GetEntryPoint() Line 1918	C++
 	coreclr.dll!Assembly::ExecuteMainMethod(PtrArray * * stringArgs int) Line 1792	C++
 	coreclr.dll!CorHost2::ExecuteAssembly(unsigned long dwAppDomainId const wchar_t * pwzAssemblyPath int argc const wchar_t * * argv unsigned long * pReturnValue) Line 491	C++
 	coreclr.dll!coreclr_execute_assembly(void * hostHandle unsigned int domainId int argc const char * * argv const char * managedAssemblyPath unsigned int * exitCode) Line 407	C++
</Description>
    <Title_Description>Adding types to R2R images using profiler metadata emit at ModuleLoadFinished triggers AV After the ModuleLoadFinished callback returns the runtime attempts to update a type loader cache called the 'AvailableClassHash'. Historically this cache was always created eagerly prior to ModuleLoadFinished being called but ReadyToRun changed the behavior to be lazy. Unfortunately the code path the profiler used to update that cache wasn't changed to account for the lazy creation so it attempts to insert into the non-existent cache and triggers an AV. I stumbled upon the issue accidentally while trying to test something else. My repro was adding a type forwarder to System.Runtime.dll but based on code review I think the issue also applies to adding new TypeDefs.
Currently 'Ready To Run' compilation is used for all framework images except System.Private.CoreLib.dll.

Callstack with the AV:

 	coreclr.dll!ClassLoader::AddExportedTypeHaveLock(Module * pManifestModule unsigned int cl AllocMemTracker * pamTracker) Line 4771	C++
 	[Inline Frame] coreclr.dll!ClassLoader::AddExportedTypeDontHaveLock(Module *) Line 4679	C++
	coreclr.dll!Assembly::AddExportedType(unsigned int cl) Line 2176	C++
 	coreclr.dll!Module::NotifyProfilerLoadFinished(HRESULT hr) Line 248	C++
 	coreclr.dll!DomainFile::PostLoadLibrary() Line 1035	C++
 	coreclr.dll!DomainFile::DoIncrementalLoad(FileLoadLevel level) Line 582	C++
 	coreclr.dll!AppDomain::TryIncrementalLoad(DomainFile * pFile FileLoadLevel workLevel Wrapper&lt;FileLoadLock *&amp;DoNothing&lt;FileLoadLock *&gt;&amp;FileLoadLock::HolderLeave0&amp;CompareDefault&lt;FileLoadLock *&gt;21&gt; &amp; lockHolder) Line 5841	C++
 	coreclr.dll!AppDomain::LoadDomainFile(FileLoadLock * pLock FileLoadLevel targetLevel) Line 5773	C++
 	coreclr.dll!AppDomain::LoadDomainAssemblyInternal(AssemblySpec * pIdentity PEAssembly * pFile FileLoadLevel targetLevel) Line 5603	C++
 	coreclr.dll!AppDomain::LoadDomainAssembly(AssemblySpec * pSpec PEAssembly * pFile FileLoadLevel targetLevel) Line 5490	C++
 	coreclr.dll!Module::LoadAssembly(AppDomain * pDomain unsigned int kAssemblyRef const char * szWinRtTypeNamespace const char * szWinRtTypeClassName) Line 5613	C++
 	coreclr.dll!Assembly::FindModuleByTypeRef(Module * pModule unsigned int tkType Loader::LoadFlag loadFlag int * pfNoResolutionScope) Line 1274	C++
 	coreclr.dll!ClassLoader::LoadTypeDefOrRefThrowing(Module * pModule unsigned int typeDefOrRef ClassLoader::NotFoundAction fNotFoundAction ClassLoader::PermitUninstantiatedFlag fUninstantiated unsigned int tokenNotToLoad ClassLoadLevel level) Line 3003	C++
 	coreclr.dll!ClassLoader::LoadApproxTypeThrowing(Module * pModule unsigned int tok SigPointer * pSigInst const SigTypeContext * pClassTypeContext) Line 3416	C++
 	[Inline Frame] coreclr.dll!ClassLoader::LoadApproxParentThrowing(Module *) Line 3462	C++
 	coreclr.dll!ClassLoader::CreateTypeHandleForTypeDefThrowing(Module * pModule unsigned int cl Instantiation inst AllocMemTracker * pamTracker) Line 11906	C++
 	coreclr.dll!ClassLoader::CreateTypeHandleForTypeKey(TypeKey * pKey AllocMemTracker * pamTracker) Line 3589	C++
 	coreclr.dll!ClassLoader::LoadTypeHandleForTypeKey_Body(TypeKey * pTypeKey TypeHandle typeHnd ClassLoadLevel targetLevel) Line 4325	C++
 	coreclr.dll!ClassLoader::LoadTypeHandleForTypeKey(TypeKey * pTypeKey TypeHandle typeHnd ClassLoadLevel targetLevel const InstantiationContext * pInstContext) Line 4044	C++
 	coreclr.dll!ClassLoader::LoadTypeDefThrowing(Module * pModule unsigned int typeDef ClassLoader::NotFoundAction fNotFoundAction ClassLoader::PermitUninstantiatedFlag fUninstantiated unsigned int tokenNotToLoad ClassLoadLevel level Instantiation * pTargetInstantiation) Line 2887	C++
 	coreclr.dll!ClassLoader::LoadTypeDefOrRefThrowing(Module * pModule unsigned int typeDefOrRef ClassLoader::NotFoundAction fNotFoundAction ClassLoader::PermitUninstantiatedFlag fUninstantiated unsigned int tokenNotToLoad ClassLoadLevel level) Line 3065	C++
 	coreclr.dll!Assembly::GetEntryPoint() Line 1918	C++
 	coreclr.dll!Assembly::ExecuteMainMethod(PtrArray * * stringArgs int) Line 1792	C++
 	coreclr.dll!CorHost2::ExecuteAssembly(unsigned long dwAppDomainId const wchar_t * pwzAssemblyPath int argc const wchar_t * * argv unsigned long * pReturnValue) Line 491	C++
 	coreclr.dll!coreclr_execute_assembly(void * hostHandle unsigned int domainId int argc const char * * argv const char * managedAssemblyPath unsigned int * exitCode) Line 407	C++
</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>sywhang</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18533</IssueLabelID>
    <Title>EventSource ActivityIds not present in Release UWP (.NET Native) traces</Title>
    <Description>The attached UWP app ([ActivityIdUwp.zip](https://github.com/dotnet/coreclr/files/2113339/ActivityIdUwp.zip)) has a simple self-describing EventSource.

```
public sealed class TestEventSource : EventSource
{​
public static TestEventSource Log = new TestEventSource();​
​
private TestEventSource()​
 : base("TestEventSource")​
{​
}​
​
private const string Test = "Test";​
public void TestStart() =&gt; Write(Test new EventSourceOptions { Opcode = EventOpcode.Start });​
public void TestStop() =&gt; Write(Test new EventSourceOptions { Opcode = EventOpcode.Stop });​
}
```

When you take a trace of a **debug** build of the app you will that ActivityIds are automatically computed for the stop and start events.

Event Name | Time MSec | Process Name | Rest
-- | -- | -- | --
TestEventSource/Test/Start | 13081.954 | ActivityIdUwp (10460) | ThreadID="31964" ProcessorNumber="1" ActivityID="/#10460/1/1/"
TestEventSource/Test/Stop | 13237.359 | ActivityIdUwp (10460) | ThreadID="31964" ProcessorNumber="1" DURATION_MSEC="155.405" ActivityID="/#10460/1/1/"

But when you take a trace of a **release** build of the app the activities are **not present**.

Event Name | Time MSec | Process Name | Rest
-- | -- | -- | --
TestEventSource/Test/Start | 9952.188 | ActivityIdUwp (25548) | ThreadID="30972" ProcessorNumber="0"
TestEventSource/Test/Stop | 9958.760 | ActivityIdUwp (25548) | ThreadID="30972" ProcessorNumber="0" DURATION_MSEC="6.573"

@brianrob since this could be related to issue [#18319 Classic EventSources don't work in Release builds using .NET Native (UWP)](https://github.com/dotnet/coreclr/issues/18319).

</Description>
    <Title_Description>EventSource ActivityIds not present in Release UWP (.NET Native) traces The attached UWP app ([ActivityIdUwp.zip](https://github.com/dotnet/coreclr/files/2113339/ActivityIdUwp.zip)) has a simple self-describing EventSource.

```
public sealed class TestEventSource : EventSource
{​
public static TestEventSource Log = new TestEventSource();​
​
private TestEventSource()​
 : base("TestEventSource")​
{​
}​
​
private const string Test = "Test";​
public void TestStart() =&gt; Write(Test new EventSourceOptions { Opcode = EventOpcode.Start });​
public void TestStop() =&gt; Write(Test new EventSourceOptions { Opcode = EventOpcode.Stop });​
}
```

When you take a trace of a **debug** build of the app you will that ActivityIds are automatically computed for the stop and start events.

Event Name | Time MSec | Process Name | Rest
-- | -- | -- | --
TestEventSource/Test/Start | 13081.954 | ActivityIdUwp (10460) | ThreadID="31964" ProcessorNumber="1" ActivityID="/#10460/1/1/"
TestEventSource/Test/Stop | 13237.359 | ActivityIdUwp (10460) | ThreadID="31964" ProcessorNumber="1" DURATION_MSEC="155.405" ActivityID="/#10460/1/1/"

But when you take a trace of a **release** build of the app the activities are **not present**.

Event Name | Time MSec | Process Name | Rest
-- | -- | -- | --
TestEventSource/Test/Start | 9952.188 | ActivityIdUwp (25548) | ThreadID="30972" ProcessorNumber="0"
TestEventSource/Test/Stop | 9958.760 | ActivityIdUwp (25548) | ThreadID="30972" ProcessorNumber="0" DURATION_MSEC="6.573"

@brianrob since this could be related to issue [#18319 Classic EventSources don't work in Release builds using .NET Native (UWP)](https://github.com/dotnet/coreclr/issues/18319).

</Title_Description>
    <Label>area-Tracing</Label>
    <Assignee>brianrob</Assignee>
    <CreatedAt>19/06/2018 12:12:23 AM +00:00</CreatedAt>
    <ClosedAt>23/05/2019 9:40:24 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18532</IssueLabelID>
    <Title>spmi doesn't report 'BAD_CODE`</Title>
    <Description>When spmi hits an assert it shows something like: 
```
ISSUE: &lt;ASSERT&gt; src\jit\lsrabuild.cpp (2449) - assertion failed 'killmask == getkillsetfornode(tree)' in 'methodName' (il size 426)
192.50:         ERROR: Exception thrown: DebugBreak or AV Exception 123
192.50:         ERROR: main method 77174 of size 96 failed to load and compile correctly.
```

but when `BADCODE` happens it shows only `ERROR` message without any details:
```
ERROR: main method 2 of size 381 failed to load and compile correctly.
```
</Description>
    <Title_Description>spmi doesn't report 'BAD_CODE` When spmi hits an assert it shows something like: 
```
ISSUE: &lt;ASSERT&gt; src\jit\lsrabuild.cpp (2449) - assertion failed 'killmask == getkillsetfornode(tree)' in 'methodName' (il size 426)
192.50:         ERROR: Exception thrown: DebugBreak or AV Exception 123
192.50:         ERROR: main method 77174 of size 96 failed to load and compile correctly.
```

but when `BADCODE` happens it shows only `ERROR` message without any details:
```
ERROR: main method 2 of size 381 failed to load and compile correctly.
```
</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>18/06/2018 8:03:45 PM +00:00</CreatedAt>
    <ClosedAt>22/08/2018 11:25:02 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18531</IssueLabelID>
    <Title>Mirror changes from dotnet/corert</Title>
    <Description>This PR contains mirrored changes from dotnet/corert


**Please REBASE this PR when merging**</Description>
    <Title_Description>Mirror changes from dotnet/corert This PR contains mirrored changes from dotnet/corert


**Please REBASE this PR when merging**</Title_Description>
    <Label>
    </Label>
    <Assignee>jkotas</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18528</IssueLabelID>
    <Title>Mirror changes from dotnet/corefx</Title>
    <Description>This PR contains mirrored changes from dotnet/corefx


**Please REBASE this PR when merging**</Description>
    <Title_Description>Mirror changes from dotnet/corefx This PR contains mirrored changes from dotnet/corefx


**Please REBASE this PR when merging**</Title_Description>
    <Label>
    </Label>
    <Assignee>jaredpar</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18527</IssueLabelID>
    <Title>Mirror changes from Anipik/ corefx</Title>
    <Description>This PR contains mirrored changes from Anipik/ corefx


**Please REBASE this PR when merging**</Description>
    <Title_Description>Mirror changes from Anipik/ corefx This PR contains mirrored changes from Anipik/ corefx


**Please REBASE this PR when merging**</Title_Description>
    <Label>
    </Label>
    <Assignee>Anipik</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18525</IssueLabelID>
    <Title>Possible JIT \ cross-gen bug in xplat in 2.2.0-preview1-26614-02 of shared runtime</Title>
    <Description>We started seeing errors during runtime Razor view compilation once we upgraded to build `2.2.0-preview1-26614-02` of Microsoft.NETCore.App. Downgrading to `2.2.0-preview1-26612-04` resolves this error. We're targeting the RTM (2.8.0) version of Roslyn that hasn't changed for a while now.

Builds with failures:: 
https://ci3.dot.net/job/aspnet_Mvc/job/dev/job/osx-Configuration_Release_prtest/319/console
https://ci3.dot.net/job/aspnet_Mvc/job/dev/job/linux-Configuration_Release_prtest/323/console

The error stack trace:

```
08:59:23    System.IndexOutOfRangeException : Index was outside the bounds of the array.
08:59:23   Stack Trace:
08:59:23      at Microsoft.CodeAnalysis.CodeGen.SwitchIntegralJumpTableEmitter.SwitchBucket.MergeIsAdvantageous(SwitchBucket bucket1 SwitchBucket bucket2) in /_/src/Compilers/Core/Portable/CodeGen/SwitchIntegralJumpTableEmitter.SwitchBucket.cs:line 282
08:59:23      at Microsoft.CodeAnalysis.CodeGen.SwitchIntegralJumpTableEmitter.GenerateSwitchBuckets(Int32 startLabelIndex Int32 endLabelIndex) in /_/src/Compilers/Core/Portable/CodeGen/SwitchIntegralJumpTableEmitter.cs:line 200
08:59:23      at Microsoft.CodeAnalysis.CodeGen.SwitchIntegralJumpTableEmitter.EmitJumpTable() in /_/src/Compilers/Core/Portable/CodeGen/SwitchIntegralJumpTableEmitter.cs:line 125
08:59:23      at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitSwitchHeader(BoundSwitchStatement switchStatement BoundExpression expression KeyValuePair`2[] switchCaseLabels LabelSymbol fallThroughLabel) in /_/src/Compilers/CSharp/Portable/CodeGen/EmitStatement.cs:line 1174
08:59:23      at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitSwitchStatement(BoundSwitchStatement switchStatement) in /_/src/Compilers/CSharp/Portable/CodeGen/EmitStatement.cs:line 1113
08:59:23      at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitStatement(BoundStatement statement) in /_/src/Compilers/CSharp/Portable/CodeGen/EmitStatement.cs:line 73
```

We've usually seen these sort of errors on account due to bugs in cross-gen \ JIT.</Description>
    <Title_Description>Possible JIT \ cross-gen bug in xplat in 2.2.0-preview1-26614-02 of shared runtime We started seeing errors during runtime Razor view compilation once we upgraded to build `2.2.0-preview1-26614-02` of Microsoft.NETCore.App. Downgrading to `2.2.0-preview1-26612-04` resolves this error. We're targeting the RTM (2.8.0) version of Roslyn that hasn't changed for a while now.

Builds with failures:: 
https://ci3.dot.net/job/aspnet_Mvc/job/dev/job/osx-Configuration_Release_prtest/319/console
https://ci3.dot.net/job/aspnet_Mvc/job/dev/job/linux-Configuration_Release_prtest/323/console

The error stack trace:

```
08:59:23    System.IndexOutOfRangeException : Index was outside the bounds of the array.
08:59:23   Stack Trace:
08:59:23      at Microsoft.CodeAnalysis.CodeGen.SwitchIntegralJumpTableEmitter.SwitchBucket.MergeIsAdvantageous(SwitchBucket bucket1 SwitchBucket bucket2) in /_/src/Compilers/Core/Portable/CodeGen/SwitchIntegralJumpTableEmitter.SwitchBucket.cs:line 282
08:59:23      at Microsoft.CodeAnalysis.CodeGen.SwitchIntegralJumpTableEmitter.GenerateSwitchBuckets(Int32 startLabelIndex Int32 endLabelIndex) in /_/src/Compilers/Core/Portable/CodeGen/SwitchIntegralJumpTableEmitter.cs:line 200
08:59:23      at Microsoft.CodeAnalysis.CodeGen.SwitchIntegralJumpTableEmitter.EmitJumpTable() in /_/src/Compilers/Core/Portable/CodeGen/SwitchIntegralJumpTableEmitter.cs:line 125
08:59:23      at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitSwitchHeader(BoundSwitchStatement switchStatement BoundExpression expression KeyValuePair`2[] switchCaseLabels LabelSymbol fallThroughLabel) in /_/src/Compilers/CSharp/Portable/CodeGen/EmitStatement.cs:line 1174
08:59:23      at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitSwitchStatement(BoundSwitchStatement switchStatement) in /_/src/Compilers/CSharp/Portable/CodeGen/EmitStatement.cs:line 1113
08:59:23      at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitStatement(BoundStatement statement) in /_/src/Compilers/CSharp/Portable/CodeGen/EmitStatement.cs:line 73
```

We've usually seen these sort of errors on account due to bugs in cross-gen \ JIT.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>18/06/2018 5:04:33 PM +00:00</CreatedAt>
    <ClosedAt>19/06/2018 2:25:24 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18522</IssueLabelID>
    <Title>Deterministic program outputs indeterministic results on Linux in release</Title>
    <Description>On Ubuntu 14.04 using current HEAD (71f4199) the following program outputs 0 in debug but seemingly random values in release. On Windows both debug and release output 0.
```csharp
struct S0
{
    public ushort F0;
}

struct S1
{
    public S0 F0;
    public ushort F1;
}

public class Program
{
    static S1 s_36;
    public static void Main()
    {
        s_36.F0 = M113();
        System.Console.WriteLine(s_36.F1);
    }

    static S0 M113()
    {
        return new S0();
    }
}
```</Description>
    <Title_Description>Deterministic program outputs indeterministic results on Linux in release On Ubuntu 14.04 using current HEAD (71f4199) the following program outputs 0 in debug but seemingly random values in release. On Windows both debug and release output 0.
```csharp
struct S0
{
    public ushort F0;
}

struct S1
{
    public S0 F0;
    public ushort F1;
}

public class Program
{
    static S1 s_36;
    public static void Main()
    {
        s_36.F0 = M113();
        System.Console.WriteLine(s_36.F1);
    }

    static S0 M113()
    {
        return new S0();
    }
}
```</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18521</IssueLabelID>
    <Title>Marshal.StructureToPtr() only marshals first element of an fixed-size buffer when structure is contained within a managed/non-blittable structure</Title>
    <Description>_From @kpreisser on June 17 2018 15:40_

Hi sorry if this isn't the right place to report this but I couldn't find other reports/explanations of this behavior.

I found that when using `Marshal.StructureToPtr()` with a managed/non-blittable structure that contains a blittable structure with a fixed-size buffer only the first byte of that fixed-size buffer is actually marshalled; the remaining bytes are `0`.

I could reproduce this issue/behavior on .NET Core 2.1 (Windows) .NET Core 2.0 (Linux) and .NET Framework 4.7.2.

Please see the following code:
```c#
using System;
using System.Runtime.InteropServices;
using System.Text;

namespace MarshalTest
{
    [StructLayout(LayoutKind.Sequential)]
    unsafe struct MyBufferStruct
    {
        public short number;
        public fixed byte number2[2];
        //public byte number2_1;
        //public byte number2_2;
        public short number3;
    }

    [StructLayout(LayoutKind.Sequential CharSet = CharSet.Unicode)]
    struct MyParentStruct
    {
        public MyBufferStruct myBufferStruct;
        public string string1; // commenting this makes it work
        public IntPtr intptr1;
    }

    class MarshalExample
    {
        static unsafe void Main()
        {
            var str = default(MyParentStruct);

            // Assign values to the bytes.
            byte* ptr = (byte*)&amp;str.myBufferStruct;
            for (int i = 0; i &lt; sizeof(MyBufferStruct); i++)
                ptr[i] = (byte)(0x11 * (i + 1));

            var stringBuilder = new StringBuilder();
            for (int i = 0; i &lt; sizeof(MyBufferStruct); i++)
                stringBuilder.Append(ptr[i].ToString("X2"));

            Console.WriteLine(stringBuilder.ToString());

            // Marshal the buffer struct directly.
            var bufferStructIntPtr = Marshal.AllocHGlobal(Marshal.SizeOf&lt;MyBufferStruct&gt;());
            Marshal.StructureToPtr(str.myBufferStruct bufferStructIntPtr false);
            try
            {
                byte* bufferStructPtr = (byte*)bufferStructIntPtr.ToPointer();
                stringBuilder = new StringBuilder();
                for (int i = 0; i &lt; sizeof(MyBufferStruct); i++)
                    stringBuilder.Append(bufferStructPtr[i].ToString("X2"));

                Console.WriteLine(stringBuilder.ToString());
            }
            finally
            {
                Marshal.DestroyStructure&lt;MyBufferStruct&gt;(bufferStructIntPtr);
                Marshal.FreeHGlobal(bufferStructIntPtr);
            }

            // Marshal the parent struct.
            var parentStructIntPtr = Marshal.AllocHGlobal(Marshal.SizeOf&lt;MyParentStruct&gt;());
            Marshal.StructureToPtr(str parentStructIntPtr false);
            try
            {
                byte* parentStructPtr = (byte*)parentStructIntPtr.ToPointer();
                stringBuilder = new StringBuilder();
                for (int i = 0; i &lt; sizeof(MyBufferStruct); i++)
                    stringBuilder.Append(parentStructPtr[i].ToString("X2"));

                Console.WriteLine(stringBuilder.ToString());
            }
            finally
            {
                Marshal.DestroyStructure&lt;MyParentStruct&gt;(parentStructIntPtr);
                Marshal.FreeHGlobal(parentStructIntPtr);
            }

            Console.ReadKey();
        }
    }
}
```

This example declares a struct `MyBufferStruct` that contains a fixed-size buffer. As it contains only primitive types I can get a pointer to it and set its values (6 bytes)
Then I first marshal the struct `MyBufferStruct` directly and after that I marshal the structure `MyParentStruct` which contains `MyBufferStruct` and additionally a non-blittable type (`string`).

Excepted output:
```
112233445566
112233445566
112233445566
```

Actual output:
```
112233445566
112233445566
112233005566
```

This means when marshalling only the struct itself everything works but when marshalling the parent structure only the first byte of the fixed-size buffer (`number2`) is marshalled instead of all bytes.

However if you comment-out the `public string string1` field in `MyParentStruct` everything is marshalled correctly. Also if you comment-out the fixed-size buffer field `public fixed byte number2[2];` in `MyBufferStruct` and instead uncomment the two short fields (`number2_1` and `number2_2`) marshalling works correctly.

Thank you!

_Copied from original issue: dotnet/corefx#30473_</Description>
    <Title_Description>Marshal.StructureToPtr() only marshals first element of an fixed-size buffer when structure is contained within a managed/non-blittable structure _From @kpreisser on June 17 2018 15:40_

Hi sorry if this isn't the right place to report this but I couldn't find other reports/explanations of this behavior.

I found that when using `Marshal.StructureToPtr()` with a managed/non-blittable structure that contains a blittable structure with a fixed-size buffer only the first byte of that fixed-size buffer is actually marshalled; the remaining bytes are `0`.

I could reproduce this issue/behavior on .NET Core 2.1 (Windows) .NET Core 2.0 (Linux) and .NET Framework 4.7.2.

Please see the following code:
```c#
using System;
using System.Runtime.InteropServices;
using System.Text;

namespace MarshalTest
{
    [StructLayout(LayoutKind.Sequential)]
    unsafe struct MyBufferStruct
    {
        public short number;
        public fixed byte number2[2];
        //public byte number2_1;
        //public byte number2_2;
        public short number3;
    }

    [StructLayout(LayoutKind.Sequential CharSet = CharSet.Unicode)]
    struct MyParentStruct
    {
        public MyBufferStruct myBufferStruct;
        public string string1; // commenting this makes it work
        public IntPtr intptr1;
    }

    class MarshalExample
    {
        static unsafe void Main()
        {
            var str = default(MyParentStruct);

            // Assign values to the bytes.
            byte* ptr = (byte*)&amp;str.myBufferStruct;
            for (int i = 0; i &lt; sizeof(MyBufferStruct); i++)
                ptr[i] = (byte)(0x11 * (i + 1));

            var stringBuilder = new StringBuilder();
            for (int i = 0; i &lt; sizeof(MyBufferStruct); i++)
                stringBuilder.Append(ptr[i].ToString("X2"));

            Console.WriteLine(stringBuilder.ToString());

            // Marshal the buffer struct directly.
            var bufferStructIntPtr = Marshal.AllocHGlobal(Marshal.SizeOf&lt;MyBufferStruct&gt;());
            Marshal.StructureToPtr(str.myBufferStruct bufferStructIntPtr false);
            try
            {
                byte* bufferStructPtr = (byte*)bufferStructIntPtr.ToPointer();
                stringBuilder = new StringBuilder();
                for (int i = 0; i &lt; sizeof(MyBufferStruct); i++)
                    stringBuilder.Append(bufferStructPtr[i].ToString("X2"));

                Console.WriteLine(stringBuilder.ToString());
            }
            finally
            {
                Marshal.DestroyStructure&lt;MyBufferStruct&gt;(bufferStructIntPtr);
                Marshal.FreeHGlobal(bufferStructIntPtr);
            }

            // Marshal the parent struct.
            var parentStructIntPtr = Marshal.AllocHGlobal(Marshal.SizeOf&lt;MyParentStruct&gt;());
            Marshal.StructureToPtr(str parentStructIntPtr false);
            try
            {
                byte* parentStructPtr = (byte*)parentStructIntPtr.ToPointer();
                stringBuilder = new StringBuilder();
                for (int i = 0; i &lt; sizeof(MyBufferStruct); i++)
                    stringBuilder.Append(parentStructPtr[i].ToString("X2"));

                Console.WriteLine(stringBuilder.ToString());
            }
            finally
            {
                Marshal.DestroyStructure&lt;MyParentStruct&gt;(parentStructIntPtr);
                Marshal.FreeHGlobal(parentStructIntPtr);
            }

            Console.ReadKey();
        }
    }
}
```

This example declares a struct `MyBufferStruct` that contains a fixed-size buffer. As it contains only primitive types I can get a pointer to it and set its values (6 bytes)
Then I first marshal the struct `MyBufferStruct` directly and after that I marshal the structure `MyParentStruct` which contains `MyBufferStruct` and additionally a non-blittable type (`string`).

Excepted output:
```
112233445566
112233445566
112233445566
```

Actual output:
```
112233445566
112233445566
112233005566
```

This means when marshalling only the struct itself everything works but when marshalling the parent structure only the first byte of the fixed-size buffer (`number2`) is marshalled instead of all bytes.

However if you comment-out the `public string string1` field in `MyParentStruct` everything is marshalled correctly. Also if you comment-out the fixed-size buffer field `public fixed byte number2[2];` in `MyBufferStruct` and instead uncomment the two short fields (`number2_1` and `number2_2`) marshalling works correctly.

Thank you!

_Copied from original issue: dotnet/corefx#30473_</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>17/06/2018 5:56:51 PM +00:00</CreatedAt>
    <ClosedAt>3/10/2018 4:32:35 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18517</IssueLabelID>
    <Title>Mirror changes from Anipik/ corefx</Title>
    <Description>This PR contains mirrored changes from Anipik/ corefx


**Please REBASE this PR when merging**</Description>
    <Title_Description>Mirror changes from Anipik/ corefx This PR contains mirrored changes from Anipik/ corefx


**Please REBASE this PR when merging**</Title_Description>
    <Label>
    </Label>
    <Assignee>Anipik</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18514</IssueLabelID>
    <Title>Mirror changes from Anipik/ corefx</Title>
    <Description>This PR contains mirrored changes from Anipik/ corefx


**Please REBASE this PR when merging**</Description>
    <Title_Description>Mirror changes from Anipik/ corefx This PR contains mirrored changes from Anipik/ corefx


**Please REBASE this PR when merging**</Title_Description>
    <Label>
    </Label>
    <Assignee>Anipik</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18513</IssueLabelID>
    <Title>Mirror changes from Anipik/ corefx</Title>
    <Description>This PR contains mirrored changes from Anipik/ corefx


**Please REBASE this PR when merging**</Description>
    <Title_Description>Mirror changes from Anipik/ corefx This PR contains mirrored changes from Anipik/ corefx


**Please REBASE this PR when merging**</Title_Description>
    <Label>
    </Label>
    <Assignee>Anipik</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18501</IssueLabelID>
    <Title>Add an aggressively-clear GC mode</Title>
    <Description>There are workstreams which have higher than average requirements about being defensive against in-memory sniffing and heapdumps.  For those customers the clear-on-use behavior of the garbage collector may be a reason that they cannot use .NET or may cause them a lot of regulatory/compliance paperwork to use .NET.

While the primary responsibility of clearing sensitive data would fall on the application there's a fair amount of platform code which makes temporaries and leaves them to the GC.  Additionally immutable types (such as `string`) have no "good" mechanism for clearing their data.

Rather than making the majority of applications have a performance penalty of a lot of small memory clears this behavior would be behind an opt-in.

When in the aggressively clearing mode the GC would clear the memory assigned to an object when that object has been declared to be "garbage" and calling applications would be able to get a moderate cleanup of potentially sensitive data by manually invoking `GC.Collect()`.</Description>
    <Title_Description>Add an aggressively-clear GC mode There are workstreams which have higher than average requirements about being defensive against in-memory sniffing and heapdumps.  For those customers the clear-on-use behavior of the garbage collector may be a reason that they cannot use .NET or may cause them a lot of regulatory/compliance paperwork to use .NET.

While the primary responsibility of clearing sensitive data would fall on the application there's a fair amount of platform code which makes temporaries and leaves them to the GC.  Additionally immutable types (such as `string`) have no "good" mechanism for clearing their data.

Rather than making the majority of applications have a performance penalty of a lot of small memory clears this behavior would be behind an opt-in.

When in the aggressively clearing mode the GC would clear the memory assigned to an object when that object has been declared to be "garbage" and calling applications would be able to get a moderate cleanup of potentially sensitive data by manually invoking `GC.Collect()`.</Title_Description>
    <Label>area-GC</Label>
    <Assignee>bartonjs</Assignee>
    <CreatedAt>16/06/2018 1:20:15 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18498</IssueLabelID>
    <Title>x64 Ubuntu corefx jobs are broken</Title>
    <Description>Looks like there's a netci.groovy configuration problem where we have a flow job for the Linux corefx tests but don't need them. We have both of these jobs:

```
x64_checked_ubuntu_corefx_baseline_prtest
x64_checked_ubuntu_corefx_baseline_flow_prtest
```

And both of them have the same trigger phrase:
```
(?i).*test\W+Ubuntu\W+x64\W+Checked\W+corefx_baseline.*
```

So they both get triggered e.g.:

https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/x64_checked_ubuntu_corefx_baseline_flow_prtest/31/
https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/x64_checked_ubuntu_corefx_baseline_prtest/342/

but the flow job fails.

Remove the flow/tst job for this case.
</Description>
    <Title_Description>x64 Ubuntu corefx jobs are broken Looks like there's a netci.groovy configuration problem where we have a flow job for the Linux corefx tests but don't need them. We have both of these jobs:

```
x64_checked_ubuntu_corefx_baseline_prtest
x64_checked_ubuntu_corefx_baseline_flow_prtest
```

And both of them have the same trigger phrase:
```
(?i).*test\W+Ubuntu\W+x64\W+Checked\W+corefx_baseline.*
```

So they both get triggered e.g.:

https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/x64_checked_ubuntu_corefx_baseline_flow_prtest/31/
https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/x64_checked_ubuntu_corefx_baseline_prtest/342/

but the flow job fails.

Remove the flow/tst job for this case.
</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>BruceForstall</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18497</IssueLabelID>
    <Title>[PMI] Assertion failed 'tree-&gt;gtHasReg()' in System.Private.CoreLib.dll</Title>
    <Description>
    </Description>
    <Title_Description>[PMI] Assertion failed 'tree-&gt;gtHasReg()' in System.Private.CoreLib.dll </Title_Description>
    <Label>arch-x64</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18491</IssueLabelID>
    <Title>Logging errors on Linux similar to Windows Event Log</Title>
    <Description>Logging unhandled exceptions to Windows Event Log was enabled with https://github.com/dotnet/coreclr/pull/16875 but currently we don't do anything on Linux. To match the diagnostics experience on Linux for .NET Core developers we should try to log exceptions to something like ```/var/log/netcore.log```</Description>
    <Title_Description>Logging errors on Linux similar to Windows Event Log Logging unhandled exceptions to Windows Event Log was enabled with https://github.com/dotnet/coreclr/pull/16875 but currently we don't do anything on Linux. To match the diagnostics experience on Linux for .NET Core developers we should try to log exceptions to something like ```/var/log/netcore.log```</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>sywhang</Assignee>
    <CreatedAt>15/06/2018 8:56:27 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18490</IssueLabelID>
    <Title>RegistrationServices support?</Title>
    <Description>Following the announcement that Windows Forms and WPF will be ported to .NET Core 3.0 I have a question about some complex (but necessary) COM interop that is currently not possible on .NET Core.

Suppose the following:

* I have an application developed in .NET Core 3 that will be distributed through the Windows Store.
* This application will include shell extensions (such as a preview handler) that are exposed through AppX Packaged COM.
* Due to restrictions inherent to Packaged COM these COM-visible types must be vended as an out-of-proc server rather than an in-proc handler.

On .NET Framework I can do this using [the `RegistrationServices` class](https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.registrationservices?view=netframework-4.7.2). However this class is not available in .NET Core. Furthermore the docs for the `RegisterTypeForComClients()` method states I should _not_ P/Invoke into `CoRegisterClassObject` and that doing so is unsupported. However this seems to be the only way to do out-of-proc COM registration under .NET Core. The wording implies that bad things will happen in the CLR if I try this so I am leery of using this technique in my .NET Core-based app.

The only workaround I can think of is to use an ATL-based COM server EXE written in C++ that vends COM interfaces that forward their calls to another COM interface implemented in C#. However due to the lack of a fully-featured Mono-style hosting API for Core I cannot do so because I have no way of calling C# code other than a static `Main()` method from C++. Therefore there seems to be no way to implement shell extensions in .NET Core that meet the restrictions mentioned above. Would it be possible for `RegistrationServices` to be (re)introduced to CoreCLR or alternatively to document another technique for accomplishing this? Thanks!</Description>
    <Title_Description>RegistrationServices support? Following the announcement that Windows Forms and WPF will be ported to .NET Core 3.0 I have a question about some complex (but necessary) COM interop that is currently not possible on .NET Core.

Suppose the following:

* I have an application developed in .NET Core 3 that will be distributed through the Windows Store.
* This application will include shell extensions (such as a preview handler) that are exposed through AppX Packaged COM.
* Due to restrictions inherent to Packaged COM these COM-visible types must be vended as an out-of-proc server rather than an in-proc handler.

On .NET Framework I can do this using [the `RegistrationServices` class](https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.registrationservices?view=netframework-4.7.2). However this class is not available in .NET Core. Furthermore the docs for the `RegisterTypeForComClients()` method states I should _not_ P/Invoke into `CoRegisterClassObject` and that doing so is unsupported. However this seems to be the only way to do out-of-proc COM registration under .NET Core. The wording implies that bad things will happen in the CLR if I try this so I am leery of using this technique in my .NET Core-based app.

The only workaround I can think of is to use an ATL-based COM server EXE written in C++ that vends COM interfaces that forward their calls to another COM interface implemented in C#. However due to the lack of a fully-featured Mono-style hosting API for Core I cannot do so because I have no way of calling C# code other than a static `Main()` method from C++. Therefore there seems to be no way to implement shell extensions in .NET Core that meet the restrictions mentioned above. Would it be possible for `RegistrationServices` to be (re)introduced to CoreCLR or alternatively to document another technique for accomplishing this? Thanks!</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18488</IssueLabelID>
    <Title>Profiler flag to ignore NGEN doesn't seem to be working</Title>
    <Description>/cc @noahfalk 

These [comments](https://github.com/dotnet/coreclr/pull/11040#issuecomment-298004449) indicate that the flag `COR_PRF_DISABLE_ALL_NGEN_IMAGES` can be used to force jitting of precompiled methods. However this is not working for `System.Private.CoreLib.dll` in CoreFx with OpenCover which does specify the flag and works when the IL version of S.P.C.dll is used instead.

If this is something that can be changed on the short run I may be able to drop some work to restore CI coverage for S.P.C.dll (Windows only).</Description>
    <Title_Description>Profiler flag to ignore NGEN doesn't seem to be working /cc @noahfalk 

These [comments](https://github.com/dotnet/coreclr/pull/11040#issuecomment-298004449) indicate that the flag `COR_PRF_DISABLE_ALL_NGEN_IMAGES` can be used to force jitting of precompiled methods. However this is not working for `System.Private.CoreLib.dll` in CoreFx with OpenCover which does specify the flag and works when the IL version of S.P.C.dll is used instead.

If this is something that can be changed on the short run I may be able to drop some work to restore CI coverage for S.P.C.dll (Windows only).</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>noahfalk</Assignee>
    <CreatedAt>15/06/2018 7:53:58 PM +00:00</CreatedAt>
    <ClosedAt>16/06/2018 1:49:21 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18486</IssueLabelID>
    <Title>Double free or corruption on Raspbian</Title>
    <Description>After the move from .NETCore 2.0 to 2.1 this started happening very frequently.
PowerShell running on Raspberry Pi 3 Model B ("Raspbian GNU/Linux 9 (stretch)")
crashes with:
`*** Error in "pwsh": double free or corruption (fasttop): 0x6e800fe0 ***`

stack from gdb:
```
Thread 6076 "pwsh" received signal SIGABRT Aborted.
[Switching to Thread 0x63647450 (LWP 32303)]
__GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:51
51	../sysdeps/unix/sysv/linux/raise.c: No such file or directory.
(gdb) bt
#0  __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:51
#1  0x76bc2824 in __GI_abort () at abort.c:89
#2  0x76bfbf78 in __libc_message (do_abort=do_abort@entry=2 fmt=&lt;optimized out&gt;) at ../sysdeps/posix/libc_fatal.c:175
#3  0x76c02ad4 in malloc_printerr (action=&lt;optimized out&gt; str=0x76cb5120 "double free or corruption (fasttop)" ptr=&lt;optimized out&gt; ar_ptr=&lt;optimized out&gt;) at malloc.c:5049
#4  0x76c03514 in _int_free (av=0x6e800010 p=0x6e800fd8 have_lock=&lt;optimized out&gt;) at malloc.c:3905
#5  0x768381e0 in HeapFree () from /home/pi/PSP3_2/libcoreclr.so
#6  0x765fd0aa in EEHeapFreeInProcessHeap(unsigned int void*) () from /home/pi/PSP3_2/libcoreclr.so
#7  0x76532c70 in operator delete(void*) () from /home/pi/PSP3_2/libcoreclr.so
#8  0x765adff0 in Thread::intermediateThreadProc(void*) () from /home/pi/PSP3_2/libcoreclr.so
#9  0x76851966 in CorUnix::CPalThread::ThreadEntry(void*) () from /home/pi/PSP3_2/libcoreclr.so
#10 0x76ecefc4 in start_thread (arg=0x63647450) at pthread_create.c:335
#11 0x76c66c68 in ?? () at ../sysdeps/unix/sysv/linux/arm/clone.S:76 from /lib/arm-linux-gnueabihf/libc.so.6
```

Can share the core file with above stack.</Description>
    <Title_Description>Double free or corruption on Raspbian After the move from .NETCore 2.0 to 2.1 this started happening very frequently.
PowerShell running on Raspberry Pi 3 Model B ("Raspbian GNU/Linux 9 (stretch)")
crashes with:
`*** Error in "pwsh": double free or corruption (fasttop): 0x6e800fe0 ***`

stack from gdb:
```
Thread 6076 "pwsh" received signal SIGABRT Aborted.
[Switching to Thread 0x63647450 (LWP 32303)]
__GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:51
51	../sysdeps/unix/sysv/linux/raise.c: No such file or directory.
(gdb) bt
#0  __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:51
#1  0x76bc2824 in __GI_abort () at abort.c:89
#2  0x76bfbf78 in __libc_message (do_abort=do_abort@entry=2 fmt=&lt;optimized out&gt;) at ../sysdeps/posix/libc_fatal.c:175
#3  0x76c02ad4 in malloc_printerr (action=&lt;optimized out&gt; str=0x76cb5120 "double free or corruption (fasttop)" ptr=&lt;optimized out&gt; ar_ptr=&lt;optimized out&gt;) at malloc.c:5049
#4  0x76c03514 in _int_free (av=0x6e800010 p=0x6e800fd8 have_lock=&lt;optimized out&gt;) at malloc.c:3905
#5  0x768381e0 in HeapFree () from /home/pi/PSP3_2/libcoreclr.so
#6  0x765fd0aa in EEHeapFreeInProcessHeap(unsigned int void*) () from /home/pi/PSP3_2/libcoreclr.so
#7  0x76532c70 in operator delete(void*) () from /home/pi/PSP3_2/libcoreclr.so
#8  0x765adff0 in Thread::intermediateThreadProc(void*) () from /home/pi/PSP3_2/libcoreclr.so
#9  0x76851966 in CorUnix::CPalThread::ThreadEntry(void*) () from /home/pi/PSP3_2/libcoreclr.so
#10 0x76ecefc4 in start_thread (arg=0x63647450) at pthread_create.c:335
#11 0x76c66c68 in ?? () at ../sysdeps/unix/sysv/linux/arm/clone.S:76 from /lib/arm-linux-gnueabihf/libc.so.6
```

Can share the core file with above stack.</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>janvorli</Assignee>
    <CreatedAt>15/06/2018 6:14:57 PM +00:00</CreatedAt>
    <ClosedAt>28/08/2018 8:29:32 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18485</IssueLabelID>
    <Title>Fix and re-enable StructABI test</Title>
    <Description>This was disabled as part of #1928 but no issue was filed to track fixing and re-enabling it.</Description>
    <Title_Description>Fix and re-enable StructABI test This was disabled as part of #1928 but no issue was filed to track fixing and re-enabling it.</Title_Description>
    <Label>arch-x64</Label>
    <Assignee>jashook</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18482</IssueLabelID>
    <Title>Sequential structs with padding not passed correctly on Linux x64</Title>
    <Description>Repro:

```csharp
using System;
using System.Runtime.CompilerServices;

public struct SequentialStruct
{
    public short f0;
    public int f1;
    public float f2;
    public IntPtr f3;
}

class Test
{
    [MethodImpl(MethodImplOptions.NoInlining)]
    static void foo(SequentialStruct s)
    {
        Console.WriteLine(s.f1);
        Console.WriteLine(s.f2);
    }

    static void Main()
    {
            SequentialStruct ss = new SequentialStruct();
            ss.f0 = 100;
            ss.f1 = 1;
            ss.f2 = 10.0f;
            ss.f3 = new IntPtr(42);
            foo(ss);
    }
}
```

Actual result:

0
3.880453E-39

Expected result:

1
10</Description>
    <Title_Description>Sequential structs with padding not passed correctly on Linux x64 Repro:

```csharp
using System;
using System.Runtime.CompilerServices;

public struct SequentialStruct
{
    public short f0;
    public int f1;
    public float f2;
    public IntPtr f3;
}

class Test
{
    [MethodImpl(MethodImplOptions.NoInlining)]
    static void foo(SequentialStruct s)
    {
        Console.WriteLine(s.f1);
        Console.WriteLine(s.f2);
    }

    static void Main()
    {
            SequentialStruct ss = new SequentialStruct();
            ss.f0 = 100;
            ss.f1 = 1;
            ss.f2 = 10.0f;
            ss.f3 = new IntPtr(42);
            foo(ss);
    }
}
```

Actual result:

0
3.880453E-39

Expected result:

1
10</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18481</IssueLabelID>
    <Title>Investigate named mutexes on FreeBSD</Title>
    <Description>#18480 forced usage of flock() based implementation of named mutexes on FreeBSD. 
According to the detection phtread should work but following test was failing:

&gt; threading/NamedMutex/test1/paltest_namedmutex_test1 test:
&gt; 
&gt; Child process: 'paltest_namedmutex_test1' failed at line 357. Expression: childRunningEvent.Release()
&gt;  

this should be further investigated and understood. 
Note that there is libthr and libpthread on FreeBSD.

related to #18067
</Description>
    <Title_Description>Investigate named mutexes on FreeBSD #18480 forced usage of flock() based implementation of named mutexes on FreeBSD. 
According to the detection phtread should work but following test was failing:

&gt; threading/NamedMutex/test1/paltest_namedmutex_test1 test:
&gt; 
&gt; Child process: 'paltest_namedmutex_test1' failed at line 357. Expression: childRunningEvent.Release()
&gt;  

this should be further investigated and understood. 
Note that there is libthr and libpthread on FreeBSD.

related to #18067
</Title_Description>
    <Label>area-PAL</Label>
    <Assignee>wfurt</Assignee>
    <CreatedAt>15/06/2018 7:29:42 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18480</IssueLabelID>
    <Title>temporarily disable pthread based named mutexes on FreeBSD</Title>
    <Description>This should be further investigated.
With this change all PAL tests do pass now on FreeBSD.

related to #18067


</Description>
    <Title_Description>temporarily disable pthread based named mutexes on FreeBSD This should be further investigated.
With this change all PAL tests do pass now on FreeBSD.

related to #18067


</Title_Description>
    <Label>os-freebsd</Label>
    <Assignee>wfurt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18479</IssueLabelID>
    <Title>fixes for  sos on FreeBSD</Title>
    <Description>add missing arch specific of libunwind so sos plugin can load.
Fix code for OS thread id so it does match with what lldb see. 

With this clrstack works on FreeBSD

```
(lldb) clrstack
GetTaskByOSThreadID:3452: 101422 th=000000080788E8C0
PrintThread:12070: hr=0 osID=101422  pStackWalk=0x83c27a000
OS Thread Id: 0x18c2e (16)
        Child SP               IP Call Site
00007FFFDF1AF8A8 00000008012a098a [Frame: 00007fffdf1af8a8] Interop+Sys.WaitForSocketEvents(IntPtr SocketEvent* Int32*)
00007FFFDF1AF8A8 0000000804d2ecc8 [InlinedCallFrame: 00007fffdf1af8a8] Interop+Sys.WaitForSocketEvents(IntPtr SocketEvent* Int32*)
00007FFFDF1AF8A0 0000000804D2ECC8 DomainBoundILStubClass.IL_STUB_PInvoke(IntPtr SocketEvent* Int32*)
00007FFFDF1AF920 0000000804D2EAE1 System.Net.Sockets.SocketAsyncEngine.EventLoop()
00007FFFDF1AF960 0000000804D2E469 System.Threading.Tasks.Task.ExecuteWithThreadLocal(System.Threading.Tasks.Task ByRef)
00007FFFDF1AFCE0 000000080248897f [GCFrame: 00007fffdf1afce0]
00007FFFDF1AFDB0 000000080248897f [DebuggerU2MCatchHandlerFrame: 00007fffdf1afdb0]
```
</Description>
    <Title_Description>fixes for  sos on FreeBSD add missing arch specific of libunwind so sos plugin can load.
Fix code for OS thread id so it does match with what lldb see. 

With this clrstack works on FreeBSD

```
(lldb) clrstack
GetTaskByOSThreadID:3452: 101422 th=000000080788E8C0
PrintThread:12070: hr=0 osID=101422  pStackWalk=0x83c27a000
OS Thread Id: 0x18c2e (16)
        Child SP               IP Call Site
00007FFFDF1AF8A8 00000008012a098a [Frame: 00007fffdf1af8a8] Interop+Sys.WaitForSocketEvents(IntPtr SocketEvent* Int32*)
00007FFFDF1AF8A8 0000000804d2ecc8 [InlinedCallFrame: 00007fffdf1af8a8] Interop+Sys.WaitForSocketEvents(IntPtr SocketEvent* Int32*)
00007FFFDF1AF8A0 0000000804D2ECC8 DomainBoundILStubClass.IL_STUB_PInvoke(IntPtr SocketEvent* Int32*)
00007FFFDF1AF920 0000000804D2EAE1 System.Net.Sockets.SocketAsyncEngine.EventLoop()
00007FFFDF1AF960 0000000804D2E469 System.Threading.Tasks.Task.ExecuteWithThreadLocal(System.Threading.Tasks.Task ByRef)
00007FFFDF1AFCE0 000000080248897f [GCFrame: 00007fffdf1afce0]
00007FFFDF1AFDB0 000000080248897f [DebuggerU2MCatchHandlerFrame: 00007fffdf1afdb0]
```
</Title_Description>
    <Label>os-freebsd</Label>
    <Assignee>wfurt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18478</IssueLabelID>
    <Title>Question: Does profiling API support Linux?</Title>
    <Description>This was originally posted by @dotnetjt . To avoid pinging the subscribers to our announcement issue (#15136) with a potentially ongoing discussion I moved it here:

&gt; Hi @noahfalk - just wondering if the profiling API support for Linux went out in 2.1. I've been coding off and on still working against a 2.1 preview.
&gt; I fired up a new Ubuntu server and installed the 2.1 runtime and set up environment to point to my (portable) profiler library and it doesn't even attempt to load. I'm pretty sure it's not me as ldd shows that I'm not missing any libraries so all of my static linking is fine.
&gt; Only other thing I can think of is that 2.1 doesn't support it yet.

Glad you reached out and sorry its causing you trouble! Linux is fully supported ([profiler status page](https://github.com/dotnet/coreclr/blob/master/Documentation/project-docs/profiling-api-status.md)) so this should work.

If you have a repro I could help diagnose the problem or if you are set up to [debug the runtime](https://github.com/dotnet/coreclr/blob/master/Documentation/building/debugging-instructions.md) (you don't need SOS regular C++ debugging is fine) you could set a breakpoint at https://github.com/dotnet/coreclr/blob/master/src/vm/profilinghelper.cpp#L690 and then see what fails.
</Description>
    <Title_Description>Question: Does profiling API support Linux? This was originally posted by @dotnetjt . To avoid pinging the subscribers to our announcement issue (#15136) with a potentially ongoing discussion I moved it here:

&gt; Hi @noahfalk - just wondering if the profiling API support for Linux went out in 2.1. I've been coding off and on still working against a 2.1 preview.
&gt; I fired up a new Ubuntu server and installed the 2.1 runtime and set up environment to point to my (portable) profiler library and it doesn't even attempt to load. I'm pretty sure it's not me as ldd shows that I'm not missing any libraries so all of my static linking is fine.
&gt; Only other thing I can think of is that 2.1 doesn't support it yet.

Glad you reached out and sorry its causing you trouble! Linux is fully supported ([profiler status page](https://github.com/dotnet/coreclr/blob/master/Documentation/project-docs/profiling-api-status.md)) so this should work.

If you have a repro I could help diagnose the problem or if you are set up to [debug the runtime](https://github.com/dotnet/coreclr/blob/master/Documentation/building/debugging-instructions.md) (you don't need SOS regular C++ debugging is fine) you could set a breakpoint at https://github.com/dotnet/coreclr/blob/master/src/vm/profilinghelper.cpp#L690 and then see what fails.
</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>noahfalk</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18477</IssueLabelID>
    <Title>Ensure AdjustmentRule.DaylightDelta is within [-1212]</Title>
    <Description>Fixes: https://github.com/dotnet/corefx/issues/29914

Unfortunately this is not ideal way to fix this - Linux currently lacks a good way to get BaseUtcOffset and getting it is purely heuristic. This PR ensures it is at least in the [-1212] range

cc: @jskeet</Description>
    <Title_Description>Ensure AdjustmentRule.DaylightDelta is within [-12,12] Fixes: https://github.com/dotnet/corefx/issues/29914

Unfortunately this is not ideal way to fix this - Linux currently lacks a good way to get BaseUtcOffset and getting it is purely heuristic. This PR ensures it is at least in the [-1212] range

cc: @jskeet</Title_Description>
    <Label>area-System.Runtime</Label>
    <Assignee>krwq</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18476</IssueLabelID>
    <Title>Enable unloading of AssemblyLoadContext</Title>
    <Description>This change is basically the work of @xoofx done some time ago rebased
to the current master and with added fixes. 

My contributions to it were:
* Extensive testing - running all 11753 coreclr Pri1 tests loaded into
AssemblyLoadContext including their dependencies and ensuring 
that they work (except the ones that use features not yet supported 
for unloading like thread local members COM interop).
That uncovered issues listed below.
* Fix few memory leaks
* Enable unloading of assemblies with PInvokes
* Fix virtual stub manager initialization
* Fix issue with unwind info regions reporting for stub linker
* Fix misplaced assert related to statics in collectible assemblies
* Fix issue with SOS domain enumeration.
* Fixed tests that were allocating but not freeing GCHandle that
was preventing the tests from unloading.

I recommend viewing the commits separately.

There is still a lot of work to do to enable e.g. unloading of assemblies
with classes having thread local members and other stuff. But it seems
worth merging these changes in.</Description>
    <Title_Description>Enable unloading of AssemblyLoadContext This change is basically the work of @xoofx done some time ago rebased
to the current master and with added fixes. 

My contributions to it were:
* Extensive testing - running all 11753 coreclr Pri1 tests loaded into
AssemblyLoadContext including their dependencies and ensuring 
that they work (except the ones that use features not yet supported 
for unloading like thread local members COM interop).
That uncovered issues listed below.
* Fix few memory leaks
* Enable unloading of assemblies with PInvokes
* Fix virtual stub manager initialization
* Fix issue with unwind info regions reporting for stub linker
* Fix misplaced assert related to statics in collectible assemblies
* Fix issue with SOS domain enumeration.
* Fixed tests that were allocating but not freeing GCHandle that
was preventing the tests from unloading.

I recommend viewing the commits separately.

There is still a lot of work to do to enable e.g. unloading of assemblies
with classes having thread local members and other stuff. But it seems
worth merging these changes in.</Title_Description>
    <Label>area-VM</Label>
    <Assignee>janvorli</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18475</IssueLabelID>
    <Title>fix the desktop build break</Title>
    <Description>Introduced by #18346.

`BuildPutArgSplit` returns `The number of sources consumed by this node.` so looks like it should go into `srcCount`.

The warning was: `lsraarm64.cpp(811): warning C4701: potentially uninitialized local variable 'srcCount' used`.
After I merge PR #18318 I will try to sync the list of warnings enabled on desktop with CoreCLR to prevent such breaks.

PTAL @dotnet/jit-contrib </Description>
    <Title_Description>fix the desktop build break Introduced by #18346.

`BuildPutArgSplit` returns `The number of sources consumed by this node.` so looks like it should go into `srcCount`.

The warning was: `lsraarm64.cpp(811): warning C4701: potentially uninitialized local variable 'srcCount' used`.
After I merge PR #18318 I will try to sync the list of warnings enabled on desktop with CoreCLR to prevent such breaks.

PTAL @dotnet/jit-contrib </Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>14/06/2018 11:04:25 PM +00:00</CreatedAt>
    <ClosedAt>15/06/2018 12:44:56 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18467</IssueLabelID>
    <Title>Intermittent failures in Fma test</Title>
    <Description>I have seen a couple of failures in this test that I can't repro even with various combinations of the `COMPlus_Enable` flags for the various ISAs. Not sure what's going on but there's no way that changing an ARM-only #define should cause this to fail. See https://ci.dot.net/job/dotnet_coreclr/job/master/job/x86_release_windows_nt_innerloop_prtest/4371/ and also https://ci.dot.net/job/dotnet_coreclr/job/master/job/x86_release_windows_nt_innerloop_prtest/4376/

The impacted test is Windows_NT.x86.Release\JIT\HardwareIntrinsics\X86\Fma_Vector256\Fma_ro\Fma_ro.cmd

It seems to pass on retry.</Description>
    <Title_Description>Intermittent failures in Fma test I have seen a couple of failures in this test that I can't repro even with various combinations of the `COMPlus_Enable` flags for the various ISAs. Not sure what's going on but there's no way that changing an ARM-only #define should cause this to fail. See https://ci.dot.net/job/dotnet_coreclr/job/master/job/x86_release_windows_nt_innerloop_prtest/4371/ and also https://ci.dot.net/job/dotnet_coreclr/job/master/job/x86_release_windows_nt_innerloop_prtest/4376/

The impacted test is Windows_NT.x86.Release\JIT\HardwareIntrinsics\X86\Fma_Vector256\Fma_ro\Fma_ro.cmd

It seems to pass on retry.</Title_Description>
    <Label>arch-x86</Label>
    <Assignee>echesakovMSFT</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18465</IssueLabelID>
    <Title>Linux performance problem</Title>
    <Description>Hello.

I've spotted a performance drop on "Linux s4-srv 4.9.0-6-amd64 #1 SMP Debian 4.9.88-1+deb9u1 (2018-05-07) x86_64 GNU/Linux" compared to Windows/MacOS.

Flame graphs:
![image](https://user-images.githubusercontent.com/3522038/41411837-de9a3232-6fe6-11e8-84f5-d340475951d4.png)

Debian PerfView view:
[deb.perfView.xml.zip](https://github.com/dotnet/coreclr/files/2102298/deb.perfView.xml.zip)


It looks like locale/encoding problem but changing system locale settings (as suggested in https://github.com/dotnet/coreclr/issues/5612) helps not.

Tried on .NET Core runtimes 2.0.7 and 2.1.0.
</Description>
    <Title_Description>Linux performance problem Hello.

I've spotted a performance drop on "Linux s4-srv 4.9.0-6-amd64 #1 SMP Debian 4.9.88-1+deb9u1 (2018-05-07) x86_64 GNU/Linux" compared to Windows/MacOS.

Flame graphs:
![image](https://user-images.githubusercontent.com/3522038/41411837-de9a3232-6fe6-11e8-84f5-d340475951d4.png)

Debian PerfView view:
[deb.perfView.xml.zip](https://github.com/dotnet/coreclr/files/2102298/deb.perfView.xml.zip)


It looks like locale/encoding problem but changing system locale settings (as suggested in https://github.com/dotnet/coreclr/issues/5612) helps not.

Tried on .NET Core runtimes 2.0.7 and 2.1.0.
</Title_Description>
    <Label>area-System.Runtime</Label>
    <Assignee>mikem8361</Assignee>
    <CreatedAt>14/06/2018 12:28:56 PM +00:00</CreatedAt>
    <ClosedAt>31/01/2019 8:15:45 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18464</IssueLabelID>
    <Title>AssemblyBinding with codeBase and href : Support in CoreClr ?</Title>
    <Description>I wanted to solve problem of `How to load an assembly at runtime that is located in a folder that is not the bin folder of the application`. I found this [.Net Framework reference](https://support.microsoft.com/en-us/help/837908/how-to-load-an-assembly-at-runtime-that-is-located-in-a-folder-that-is)

Is `Method 2: Use an application configuration (.config) file with the &lt;codeBase&gt; tags` in above link supported in CoreClr ?

I am not able to get it work on CoreClr.

Here is my `app.config` which generates `&lt;app&gt;.dll.config` :
```
&lt;configuration&gt;
   &lt;runtime&gt;
      &lt;assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1"&gt;
         &lt;dependentAssembly&gt;
            &lt;assemblyIdentity name="sft"  culture="neutral" publicKeyToken="8be7d6a1e90327c2"/&gt;
            &lt;codeBase version="1.0.0.0" href="FILE://E:/work/dotnet_projs/sf_sft/sf/bin_appconfig/Debug/netcoreapp2.0/NS/sft.dll"/&gt;
         &lt;/dependentAssembly&gt;
      &lt;/assemblyBinding&gt;
   &lt;/runtime&gt;
&lt;/configuration&gt;
```

Here is sample project :

1. sf folder is console app that depends on sft library.
2. sft is strong signed.
3. sf has App.config referring to full location of sft library. Please update it to your local path.
4. hand craft sf.deps.json to remove references of sft.dll and move sft.dll to folder referred in (3).

[assemblybinding_codebase.zip](https://github.com/dotnet/coreclr/files/2101044/assemblybinding_codebase.zip)

</Description>
    <Title_Description>AssemblyBinding with codeBase and href : Support in CoreClr ? I wanted to solve problem of `How to load an assembly at runtime that is located in a folder that is not the bin folder of the application`. I found this [.Net Framework reference](https://support.microsoft.com/en-us/help/837908/how-to-load-an-assembly-at-runtime-that-is-located-in-a-folder-that-is)

Is `Method 2: Use an application configuration (.config) file with the &lt;codeBase&gt; tags` in above link supported in CoreClr ?

I am not able to get it work on CoreClr.

Here is my `app.config` which generates `&lt;app&gt;.dll.config` :
```
&lt;configuration&gt;
   &lt;runtime&gt;
      &lt;assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1"&gt;
         &lt;dependentAssembly&gt;
            &lt;assemblyIdentity name="sft"  culture="neutral" publicKeyToken="8be7d6a1e90327c2"/&gt;
            &lt;codeBase version="1.0.0.0" href="FILE://E:/work/dotnet_projs/sf_sft/sf/bin_appconfig/Debug/netcoreapp2.0/NS/sft.dll"/&gt;
         &lt;/dependentAssembly&gt;
      &lt;/assemblyBinding&gt;
   &lt;/runtime&gt;
&lt;/configuration&gt;
```

Here is sample project :

1. sf folder is console app that depends on sft library.
2. sft is strong signed.
3. sf has App.config referring to full location of sft library. Please update it to your local path.
4. hand craft sf.deps.json to remove references of sft.dll and move sft.dll to folder referred in (3).

[assemblybinding_codebase.zip](https://github.com/dotnet/coreclr/files/2101044/assemblybinding_codebase.zip)

</Title_Description>
    <Label>area-AssemblyLoader</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>14/06/2018 6:24:55 AM +00:00</CreatedAt>
    <ClosedAt>1/11/2018 5:11:28 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18463</IssueLabelID>
    <Title>Profiler rejit can break invariants in jit interface</Title>
    <Description>In CEEInfo::ScanToken we exit early if pModule is System.Private.CoreLib as a perf optimization since we expect that System.Private.CoreLib won't have any external references.

However profiler rejit can rewrite any IL including adding external references to IL in System.Private.CoreLib. In our profiler tests I observed the following chain of events.

1.  Profiler rejits System.Private.CoreLib code with calls to an external library that is not yet loaded
2.  When the code is rejitted the external library is not activated because CEEInfoScanToken exits early
3.  On the first call to the rejitted code the method from the external library is jitted and an assert fires because the module is not activated https://github.com/dotnet/coreclr/blob/6bf04a47badd74646e21e70f4e9267c71b7bfd08/src/vm/prestub.cpp#L1522

The test passes on retail but I'm afraid there may be some pathological case lurking here that can cause corruption or a crash.

Code for CEEInfo::ScanToken for reference
 https://github.com/dotnet/coreclr/blob/79b8f94cc52b6b79945074b748508a0b3cbb8be6/src/vm/jitinterface.cpp#L2801-L2884</Description>
    <Title_Description>Profiler rejit can break invariants in jit interface In CEEInfo::ScanToken we exit early if pModule is System.Private.CoreLib as a perf optimization since we expect that System.Private.CoreLib won't have any external references.

However profiler rejit can rewrite any IL including adding external references to IL in System.Private.CoreLib. In our profiler tests I observed the following chain of events.

1.  Profiler rejits System.Private.CoreLib code with calls to an external library that is not yet loaded
2.  When the code is rejitted the external library is not activated because CEEInfoScanToken exits early
3.  On the first call to the rejitted code the method from the external library is jitted and an assert fires because the module is not activated https://github.com/dotnet/coreclr/blob/6bf04a47badd74646e21e70f4e9267c71b7bfd08/src/vm/prestub.cpp#L1522

The test passes on retail but I'm afraid there may be some pathological case lurking here that can cause corruption or a crash.

Code for CEEInfo::ScanToken for reference
 https://github.com/dotnet/coreclr/blob/79b8f94cc52b6b79945074b748508a0b3cbb8be6/src/vm/jitinterface.cpp#L2801-L2884</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>davmason</Assignee>
    <CreatedAt>14/06/2018 5:32:29 AM +00:00</CreatedAt>
    <ClosedAt>15/06/2018 10:16:59 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18460</IssueLabelID>
    <Title>Fix handling of generating relative path to parent</Title>
    <Description>Addresses https://github.com/dotnet/corefx/issues/30263

Test change in CoreFX will be linked in as soon as I post the PR.</Description>
    <Title_Description>Fix handling of generating relative path to parent Addresses https://github.com/dotnet/corefx/issues/30263

Test change in CoreFX will be linked in as soon as I post the PR.</Title_Description>
    <Label>area-System.IO</Label>
    <Assignee>JeremyKuhne</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18459</IssueLabelID>
    <Title>Intrinsic for the rdpmc instruction</Title>
    <Description>`rdpmc` is used to read hardware counter data. It is supported by most modern cpus from Intel and AMD.

MSVC++ has a [__readpmc intrinsic](https://docs.microsoft.com/en-us/cpp/intrinsics/readpmc) and other compilers where such an intrinsic doesn't exist use inline assembly.

The signature of such an intrinsic looks like `unsigned __int64 __readpmc(uint counterIndex);`

where the `counterIndex` is the configured to the counter of interest.

To use this functionality from any privilege level (i.e. outside ring0) a kernel driver (or loaded module) needs to set the `PCE` bit on the `CR4` register of each core where this functionality is desired. Once that is accomplished the MSRs for counters need to be configured to count the events of interest.

Obviously the preceding paragraph is outside the scope of CoreCLR and must be enabled or managed somehow by the user.

The proposal is to teach the `rdpmc` intrinsic to the JIT so that it can be accessed in an efficient way. To access this functionality today the cheapest way would be to have a native function that wraps the intrinsic and pinvoke into that which for certain measurements perturbs what is being measured. But more annoyingly a new native dependency is required to achieve this.

This feature would be very valuable in getting crisp performance data from managed code directly.

category:design
theme:intrinsics
skill-level:intermediate
cost:large</Description>
    <Title_Description>Intrinsic for the rdpmc instruction `rdpmc` is used to read hardware counter data. It is supported by most modern cpus from Intel and AMD.

MSVC++ has a [__readpmc intrinsic](https://docs.microsoft.com/en-us/cpp/intrinsics/readpmc) and other compilers where such an intrinsic doesn't exist use inline assembly.

The signature of such an intrinsic looks like `unsigned __int64 __readpmc(uint counterIndex);`

where the `counterIndex` is the configured to the counter of interest.

To use this functionality from any privilege level (i.e. outside ring0) a kernel driver (or loaded module) needs to set the `PCE` bit on the `CR4` register of each core where this functionality is desired. Once that is accomplished the MSRs for counters need to be configured to count the events of interest.

Obviously the preceding paragraph is outside the scope of CoreCLR and must be enabled or managed somehow by the user.

The proposal is to teach the `rdpmc` intrinsic to the JIT so that it can be accessed in an efficient way. To access this functionality today the cheapest way would be to have a native function that wraps the intrinsic and pinvoke into that which for certain measurements perturbs what is being measured. But more annoyingly a new native dependency is required to achieve this.

This feature would be very valuable in getting crisp performance data from managed code directly.

category:design
theme:intrinsics
skill-level:intermediate
cost:large</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>mjsabby</Assignee>
    <CreatedAt>13/06/2018 9:20:34 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18458</IssueLabelID>
    <Title>Add Path.Join string overloads</Title>
    <Description>coreclr part of https://github.com/dotnet/corefx/issues/30049
corefx PR are ready to go https://github.com/dotnet/corefx/compare/master...MarcoRossignoli:joinoverloads

/cc @JeremyKuhne </Description>
    <Title_Description>Add Path.Join string overloads coreclr part of https://github.com/dotnet/corefx/issues/30049
corefx PR are ready to go https://github.com/dotnet/corefx/compare/master...MarcoRossignoli:joinoverloads

/cc @JeremyKuhne </Title_Description>
    <Label>area-System.IO</Label>
    <Assignee>JeremyKuhne</Assignee>
    <CreatedAt>13/06/2018 8:32:26 PM +00:00</CreatedAt>
    <ClosedAt>14/06/2018 5:30:57 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18457</IssueLabelID>
    <Title>Fix allocation methods at few places in PAL</Title>
    <Description>In the utf8.cpp and process.cpp PAL was incorectly using the
global new operator. This results in calling this operator's
definition in coreclr runtime which is wrong. In the case
of the utf8 stuff a customer has reported a crash happening
due to that when the path from which the PAL was initialized
contained chinese characters.

The fix is to use InternalNew / InternalDelete functions instead.

I have also found that we were missing deletions of the DecoderFallbackBuffer
and EncoderFallbackBuffer so I have added them.</Description>
    <Title_Description>Fix allocation methods at few places in PAL In the utf8.cpp and process.cpp PAL was incorectly using the
global new operator. This results in calling this operator's
definition in coreclr runtime which is wrong. In the case
of the utf8 stuff a customer has reported a crash happening
due to that when the path from which the PAL was initialized
contained chinese characters.

The fix is to use InternalNew / InternalDelete functions instead.

I have also found that we were missing deletions of the DecoderFallbackBuffer
and EncoderFallbackBuffer so I have added them.</Title_Description>
    <Label>area-PAL</Label>
    <Assignee>janvorli</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18456</IssueLabelID>
    <Title>Added ISOWeek to System.Globalization</Title>
    <Description>Part of https://github.com/dotnet/corefx/issues/28933

// @tarekgh</Description>
    <Title_Description>Added ISOWeek to System.Globalization Part of https://github.com/dotnet/corefx/issues/28933

// @tarekgh</Title_Description>
    <Label>Hackathon</Label>
    <Assignee>khellang</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18455</IssueLabelID>
    <Title>Adds original error info to NotSupportedException during FileStream initialization</Title>
    <Description>Fixes #18454 

A couple of notes:
- I originally thought of throwing a Win32Exception but Win32Exception is not part of System.Private.Corelib;
- As I understand throwing a new exception type is a breaking change so instead I'm adding the error info to the current exception's InnerException
</Description>
    <Title_Description>Adds original error info to NotSupportedException during FileStream initialization Fixes #18454 

A couple of notes:
- I originally thought of throwing a Win32Exception but Win32Exception is not part of System.Private.Corelib;
- As I understand throwing a new exception type is a breaking change so instead I'm adding the error info to the current exception's InnerException
</Title_Description>
    <Label>area-System.IO</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>13/06/2018 11:10:11 AM +00:00</CreatedAt>
    <ClosedAt>14/06/2018 3:09:21 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18454</IssueLabelID>
    <Title>File.ReadAllBytes throws exception with a misleading message</Title>
    <Description># TL;DR;
The application calls `File.ReadAllBytes` passing a valid file name. For instance:

``` csharp
File.ReadAllBytes("93710.jpg");
```

Under some circumstances the application it ends up throwing a misleading exception.

&gt; FileStream was asked to open a device that was not a file. For support for devices like 'com1:' or 'lpt1:' call CreateFile then use the FileStream constructors that take an OS handle as an IntPtr.

# More Info
This is something I have found on the .NET Framework that I'm bringing here since there are talks about porting this application to .NET Core and the offending code is mostly the same.

Here's how the exception was logged on Windows:
```
Event code: 3005 
Event message: An unhandled exception has occurred. 
Event time: 6/6/2018 12:31:20 PM 
Event time (UTC): 6/6/2018 3:31:20 PM 
Event ID: 4c1127f18da24439abf85c192bb0ceeb 
Event sequence: 322 
Event occurrence: 1 
Event detail code: 0 
 
Application information: 
    Application domain: /LM/W3SVC/1/ROOT/Handlers-2-131727724516929646 
    Trust level: Full 
    Application Virtual Path: /Handlers 
    Application Path: F:\API\Handlers\ 
    Machine name: APISERVER-02 
 
Process information: 
    Process ID: 47224 
    Process name: w3wp.exe 
    Account name: domain\user 
 
Exception information: 
    Exception type: NotSupportedException 
    Exception message: FileStream was asked to open a device that was not a file. For support for devices like 'com1:' or 'lpt1:' call CreateFile then use the FileStream constructors that take an OS handle as an IntPtr.
   at Microsoft.Win32.Win32Native.SafeCreateFile(String lpFileName Int32 dwDesiredAccess FileShare dwShareMode SECURITY_ATTRIBUTES securityAttrs FileMode dwCreationDisposition Int32 dwFlagsAndAttributes IntPtr hTemplateFile)
   at System.IO.FileStream.Init(String path FileMode mode FileAccess access Int32 rights Boolean useRights FileShare share Int32 bufferSize FileOptions options SECURITY_ATTRIBUTES secAttrs String msgPath Boolean bFromProxy Boolean useLongPath Boolean checkHost)
   at System.IO.FileStream..ctor(String path FileMode mode FileAccess access FileShare share Int32 bufferSize FileOptions options String msgPath Boolean bFromProxy Boolean useLongPath Boolean checkHost)
   at System.IO.File.InternalReadAllBytes(String path Boolean checkHost)
   at Service.Handler.Web.Handlers.Image.&lt;ProcessRequestAsync&gt;d__3.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Web.TaskAsyncHelper.EndTask(IAsyncResult ar)
   at System.Web.HttpApplication.CallHandlerExecutionStep.System.Web.HttpApplication.IExecutionStep.Execute()
   at System.Web.HttpApplication.ExecuteStepImpl(IExecutionStep step)
   at System.Web.HttpApplication.ExecuteStep(IExecutionStep step Boolean&amp; completedSynchronously)

 
 
Request information: 
    Request URL: https://api.example.com:443/Handlers/Handler/Image.ashx?src=93710&amp;length=563&amp;fix=width 
    Request path: /Handlers/Handler/Image.ashx 
    User host address: 10.33.192.114 
    User:  
    Is authenticated: False 
    Authentication Type:  
    Thread account name: domain\user 
 
Thread information: 
    Thread ID: 145 
    Thread account name: domain\user 
    Is impersonating: False 
    Stack trace:    at Microsoft.Win32.Win32Native.SafeCreateFile(String lpFileName Int32 dwDesiredAccess FileShare dwShareMode SECURITY_ATTRIBUTES securityAttrs FileMode dwCreationDisposition Int32 dwFlagsAndAttributes IntPtr hTemplateFile)
   at System.IO.FileStream.Init(String path FileMode mode FileAccess access Int32 rights Boolean useRights FileShare share Int32 bufferSize FileOptions options SECURITY_ATTRIBUTES secAttrs String msgPath Boolean bFromProxy Boolean useLongPath Boolean checkHost)
   at System.IO.FileStream..ctor(String path FileMode mode FileAccess access FileShare share Int32 bufferSize FileOptions options String msgPath Boolean bFromProxy Boolean useLongPath Boolean checkHost)
   at System.IO.File.InternalReadAllBytes(String path Boolean checkHost)
   at Service.Handler.Web.Handlers.Image.&lt;ProcessRequestAsync&gt;d__3.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Web.TaskAsyncHelper.EndTask(IAsyncResult ar)
   at System.Web.HttpApplication.CallHandlerExecutionStep.System.Web.HttpApplication.IExecutionStep.Execute()
   at System.Web.HttpApplication.ExecuteStepImpl(IExecutionStep step)
   at System.Web.HttpApplication.ExecuteStep(IExecutionStep step Boolean&amp; completedSynchronously)
 
 ```

Here's the offending code on the .NET Framework (https://referencesource.microsoft.com/#mscorlib/microsoft/win32/win32native.cs):
``` csharp
// https://referencesource.microsoft.com/#mscorlib/microsoft/win32/win32native.cs980

int fileType = Win32Native.GetFileType(handle);
if (fileType != Win32Native.FILE_TYPE_DISK) {
   handle.Dispose();
   throw new NotSupportedException(Environment.GetResourceString("NotSupported_FileStreamOnNonFiles"));
}

.
.
.

// https://referencesource.microsoft.com/#mscorlib/microsoft/win32/win32native.cs1035

[DllImport(KERNEL32)]
[ResourceExposure(ResourceScope.None)]
internal static extern int GetFileType(SafeFileHandle handle);
```

And here's the equivalent code on .NET Core: 
https://github.com/dotnet/coreclr/blob/f4e09d1898a8eb172e5c286102ef9d1269b38666/src/System.Private.CoreLib/shared/System/IO/FileStream.Windows.cs#L57-L66

The thing is any error returned from [GetFileType](https://msdn.microsoft.com/en-us/library/windows/desktop/aa364960.aspx) is ignored. In it's place a NotSupportedException with a fixed (and possibly misleading) message is thrown making it harder to troubleshoot real cause of the exception.
</Description>
    <Title_Description>File.ReadAllBytes throws exception with a misleading message # TL;DR;
The application calls `File.ReadAllBytes` passing a valid file name. For instance:

``` csharp
File.ReadAllBytes("93710.jpg");
```

Under some circumstances the application it ends up throwing a misleading exception.

&gt; FileStream was asked to open a device that was not a file. For support for devices like 'com1:' or 'lpt1:' call CreateFile then use the FileStream constructors that take an OS handle as an IntPtr.

# More Info
This is something I have found on the .NET Framework that I'm bringing here since there are talks about porting this application to .NET Core and the offending code is mostly the same.

Here's how the exception was logged on Windows:
```
Event code: 3005 
Event message: An unhandled exception has occurred. 
Event time: 6/6/2018 12:31:20 PM 
Event time (UTC): 6/6/2018 3:31:20 PM 
Event ID: 4c1127f18da24439abf85c192bb0ceeb 
Event sequence: 322 
Event occurrence: 1 
Event detail code: 0 
 
Application information: 
    Application domain: /LM/W3SVC/1/ROOT/Handlers-2-131727724516929646 
    Trust level: Full 
    Application Virtual Path: /Handlers 
    Application Path: F:\API\Handlers\ 
    Machine name: APISERVER-02 
 
Process information: 
    Process ID: 47224 
    Process name: w3wp.exe 
    Account name: domain\user 
 
Exception information: 
    Exception type: NotSupportedException 
    Exception message: FileStream was asked to open a device that was not a file. For support for devices like 'com1:' or 'lpt1:' call CreateFile then use the FileStream constructors that take an OS handle as an IntPtr.
   at Microsoft.Win32.Win32Native.SafeCreateFile(String lpFileName Int32 dwDesiredAccess FileShare dwShareMode SECURITY_ATTRIBUTES securityAttrs FileMode dwCreationDisposition Int32 dwFlagsAndAttributes IntPtr hTemplateFile)
   at System.IO.FileStream.Init(String path FileMode mode FileAccess access Int32 rights Boolean useRights FileShare share Int32 bufferSize FileOptions options SECURITY_ATTRIBUTES secAttrs String msgPath Boolean bFromProxy Boolean useLongPath Boolean checkHost)
   at System.IO.FileStream..ctor(String path FileMode mode FileAccess access FileShare share Int32 bufferSize FileOptions options String msgPath Boolean bFromProxy Boolean useLongPath Boolean checkHost)
   at System.IO.File.InternalReadAllBytes(String path Boolean checkHost)
   at Service.Handler.Web.Handlers.Image.&lt;ProcessRequestAsync&gt;d__3.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Web.TaskAsyncHelper.EndTask(IAsyncResult ar)
   at System.Web.HttpApplication.CallHandlerExecutionStep.System.Web.HttpApplication.IExecutionStep.Execute()
   at System.Web.HttpApplication.ExecuteStepImpl(IExecutionStep step)
   at System.Web.HttpApplication.ExecuteStep(IExecutionStep step Boolean&amp; completedSynchronously)

 
 
Request information: 
    Request URL: https://api.example.com:443/Handlers/Handler/Image.ashx?src=93710&amp;length=563&amp;fix=width 
    Request path: /Handlers/Handler/Image.ashx 
    User host address: 10.33.192.114 
    User:  
    Is authenticated: False 
    Authentication Type:  
    Thread account name: domain\user 
 
Thread information: 
    Thread ID: 145 
    Thread account name: domain\user 
    Is impersonating: False 
    Stack trace:    at Microsoft.Win32.Win32Native.SafeCreateFile(String lpFileName Int32 dwDesiredAccess FileShare dwShareMode SECURITY_ATTRIBUTES securityAttrs FileMode dwCreationDisposition Int32 dwFlagsAndAttributes IntPtr hTemplateFile)
   at System.IO.FileStream.Init(String path FileMode mode FileAccess access Int32 rights Boolean useRights FileShare share Int32 bufferSize FileOptions options SECURITY_ATTRIBUTES secAttrs String msgPath Boolean bFromProxy Boolean useLongPath Boolean checkHost)
   at System.IO.FileStream..ctor(String path FileMode mode FileAccess access FileShare share Int32 bufferSize FileOptions options String msgPath Boolean bFromProxy Boolean useLongPath Boolean checkHost)
   at System.IO.File.InternalReadAllBytes(String path Boolean checkHost)
   at Service.Handler.Web.Handlers.Image.&lt;ProcessRequestAsync&gt;d__3.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Web.TaskAsyncHelper.EndTask(IAsyncResult ar)
   at System.Web.HttpApplication.CallHandlerExecutionStep.System.Web.HttpApplication.IExecutionStep.Execute()
   at System.Web.HttpApplication.ExecuteStepImpl(IExecutionStep step)
   at System.Web.HttpApplication.ExecuteStep(IExecutionStep step Boolean&amp; completedSynchronously)
 
 ```

Here's the offending code on the .NET Framework (https://referencesource.microsoft.com/#mscorlib/microsoft/win32/win32native.cs):
``` csharp
// https://referencesource.microsoft.com/#mscorlib/microsoft/win32/win32native.cs980

int fileType = Win32Native.GetFileType(handle);
if (fileType != Win32Native.FILE_TYPE_DISK) {
   handle.Dispose();
   throw new NotSupportedException(Environment.GetResourceString("NotSupported_FileStreamOnNonFiles"));
}

.
.
.

// https://referencesource.microsoft.com/#mscorlib/microsoft/win32/win32native.cs1035

[DllImport(KERNEL32)]
[ResourceExposure(ResourceScope.None)]
internal static extern int GetFileType(SafeFileHandle handle);
```

And here's the equivalent code on .NET Core: 
https://github.com/dotnet/coreclr/blob/f4e09d1898a8eb172e5c286102ef9d1269b38666/src/System.Private.CoreLib/shared/System/IO/FileStream.Windows.cs#L57-L66

The thing is any error returned from [GetFileType](https://msdn.microsoft.com/en-us/library/windows/desktop/aa364960.aspx) is ignored. In it's place a NotSupportedException with a fixed (and possibly misleading) message is thrown making it harder to troubleshoot real cause of the exception.
</Title_Description>
    <Label>area-System.IO</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>13/06/2018 10:57:23 AM +00:00</CreatedAt>
    <ClosedAt>14/06/2018 3:09:21 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18453</IssueLabelID>
    <Title>JIT: don't track arg and local and temp ref classes in minopts or debug mode</Title>
    <Description>If the jit is not optimizing it doesn't need to ask the runtime for the declared types for ref class arguments and locals. Just knowing they are of `TYP_REF` is sufficient. Removing this call back into the runtime may improve minopts/debug throughput by around 1% or so (hard to be sure because it may just shift the runtime cost from one place to another).

Currently ref class information is read in before the jit makes a determination as to whether or not it is in minopts mode (as minopts determination depends in part on the count of args and locals) -- so to conditionally read this info will require a bit of reworking.

Also `lvaSetClass` and `lvaUpdateClass` can become no-ops in minopts and debug modes.

category:throughput
theme:minopts
skill-level:expert
cost:large</Description>
    <Title_Description>JIT: don't track arg and local and temp ref classes in minopts or debug mode If the jit is not optimizing it doesn't need to ask the runtime for the declared types for ref class arguments and locals. Just knowing they are of `TYP_REF` is sufficient. Removing this call back into the runtime may improve minopts/debug throughput by around 1% or so (hard to be sure because it may just shift the runtime cost from one place to another).

Currently ref class information is read in before the jit makes a determination as to whether or not it is in minopts mode (as minopts determination depends in part on the count of args and locals) -- so to conditionally read this info will require a bit of reworking.

Also `lvaSetClass` and `lvaUpdateClass` can become no-ops in minopts and debug modes.

category:throughput
theme:minopts
skill-level:expert
cost:large</Title_Description>
    <Label>JitThroughput</Label>
    <Assignee>AndyAyersMS</Assignee>
    <CreatedAt>13/06/2018 8:26:59 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18452</IssueLabelID>
    <Title>Perfcollect issue while executing perf script (kubernetes engine)</Title>
    <Description>Hi

First of all my workload is on Kubernetes engine. We run our pods on `container optimized os` from google. With this **OS** it's almost impossible to collect tracing events. So I created a node with ubuntu.
I can run perfcollect with no problem until the execution of the `perf script` statement which tries to output with cpu field. An error is thrown with the following description : 
`'cpu-clock' event do not have CPU attribute set`. 

- I run perfcollect as follow:  `./perfcollect collect test -pid myPID` 

Does anyone has faced this issue ?

Thank you.</Description>
    <Title_Description>Perfcollect issue while executing perf script (kubernetes engine) Hi

First of all my workload is on Kubernetes engine. We run our pods on `container optimized os` from google. With this **OS** it's almost impossible to collect tracing events. So I created a node with ubuntu.
I can run perfcollect with no problem until the execution of the `perf script` statement which tries to output with cpu field. An error is thrown with the following description : 
`'cpu-clock' event do not have CPU attribute set`. 

- I run perfcollect as follow:  `./perfcollect collect test -pid myPID` 

Does anyone has faced this issue ?

Thank you.</Title_Description>
    <Label>area-Tracing</Label>
    <Assignee>brianrob</Assignee>
    <CreatedAt>13/06/2018 6:05:29 AM +00:00</CreatedAt>
    <ClosedAt>4/04/2019 11:05:27 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18451</IssueLabelID>
    <Title>moving ARM HW Intrinsics files to shared partition</Title>
    <Description>As requested in https://github.com/dotnet/coreclr/pull/18427#discussion_r194609717 moving arm64 HWIntrinsics to shared partition.

Related to: #15922

cc: @eerhardt @tannergooding @sdmaclea @CarolEidt</Description>
    <Title_Description>moving ARM HW Intrinsics files to shared partition As requested in https://github.com/dotnet/coreclr/pull/18427#discussion_r194609717 moving arm64 HWIntrinsics to shared partition.

Related to: #15922

cc: @eerhardt @tannergooding @sdmaclea @CarolEidt</Title_Description>
    <Label>
    </Label>
    <Assignee>maryamariyan</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18450</IssueLabelID>
    <Title>Binding duplicated handle to ThreadPool fails?</Title>
    <Description>When I run the following code I get a System.ArgumentException: ''handle' has already been bound to the thread pool or was not opened for asynchronous I/O.'

This seems weird since it is a copy of the handle bound and it is definitely opened for async I/O. From a glance it looks like the error ultimately comes from CreateIoCompletionPort but that is weird because the documentation implies that you can use DuplicateHandle to share a handle registered to an IO completion port:

&gt; It is best not to share a file handle associated with an I/O completion port by using either handle inheritance or a call to the DuplicateHandle function. Operations performed with such duplicate handles generate completion notifications. Careful consideration is advised.

Is the framework doing something funky here or is the reality more complicated than the documentation for CreateIoCompletionPort would lead you to think?

```CSharp
using Microsoft.Win32.SafeHandles;
using System;
using System.ComponentModel;
using System.Diagnostics;
using System.IO.Pipes;
using System.Runtime.InteropServices;
using System.Security.Principal;

namespace NamedPipeDuplicateHandleTestCore
{
  class Program
  {
    [DllImport("kernel32.dll" EntryPoint = "DuplicateHandle" SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    private static extern bool _DuplicateHandleSU(IntPtr hSourceProcessHandle
       SafeHandle hSourceHandle IntPtr hTargetProcessHandle out IntPtr lpTargetHandle
       uint dwDesiredAccess [MarshalAs(UnmanagedType.Bool)] bool bInheritHandle uint dwOptions);

    public static IntPtr DuplicateHandle(SafeHandle hSourceHandle IntPtr hTargetProcessHandle)
    {
      const int DUPLICATE_SAME_ACCESS = 0x00000002;
      IntPtr targetHandle;
      if (!_DuplicateHandleSU(Process.GetCurrentProcess().Handle hSourceHandle hTargetProcessHandle out targetHandle
        0 false DUPLICATE_SAME_ACCESS))
      {
        throw new Win32Exception(Marshal.GetLastWin32Error());
      }
      return targetHandle;
    }

    static void Main(string[] args)
    {
      string pipename = "foopipe" + Guid.NewGuid().ToString("N");
      var pipeServer = new NamedPipeServerStream(pipename PipeDirection.InOut 1 PipeTransmissionMode.Byte PipeOptions.Asynchronous
        4096 4096);
      pipeServer.BeginWaitForConnection(ar =&gt; { pipeServer.EndWaitForConnection(ar); } null);

      IntPtr handle2;
      using (var clientStream1 = new NamedPipeClientStream("." pipename PipeDirection.InOut PipeOptions.Asynchronous TokenImpersonationLevel.None
        System.IO.HandleInheritability.None))
      {
        clientStream1.Connect();
        handle2 = DuplicateHandle(clientStream1.SafePipeHandle Process.GetCurrentProcess().Handle);
      }
      var clientStream2 = new NamedPipeClientStream(PipeDirection.InOut true true new SafePipeHandle(handle2 true));
      pipeServer.WriteAsync(new byte[] { 42 } 0 1);
      Console.WriteLine(clientStream2.ReadByte());
    }
  }
}
```

This is tested on dotnet core 2.1.30 and Windows 10.0.17686.1003.</Description>
    <Title_Description>Binding duplicated handle to ThreadPool fails? When I run the following code I get a System.ArgumentException: ''handle' has already been bound to the thread pool or was not opened for asynchronous I/O.'

This seems weird since it is a copy of the handle bound and it is definitely opened for async I/O. From a glance it looks like the error ultimately comes from CreateIoCompletionPort but that is weird because the documentation implies that you can use DuplicateHandle to share a handle registered to an IO completion port:

&gt; It is best not to share a file handle associated with an I/O completion port by using either handle inheritance or a call to the DuplicateHandle function. Operations performed with such duplicate handles generate completion notifications. Careful consideration is advised.

Is the framework doing something funky here or is the reality more complicated than the documentation for CreateIoCompletionPort would lead you to think?

```CSharp
using Microsoft.Win32.SafeHandles;
using System;
using System.ComponentModel;
using System.Diagnostics;
using System.IO.Pipes;
using System.Runtime.InteropServices;
using System.Security.Principal;

namespace NamedPipeDuplicateHandleTestCore
{
  class Program
  {
    [DllImport("kernel32.dll" EntryPoint = "DuplicateHandle" SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    private static extern bool _DuplicateHandleSU(IntPtr hSourceProcessHandle
       SafeHandle hSourceHandle IntPtr hTargetProcessHandle out IntPtr lpTargetHandle
       uint dwDesiredAccess [MarshalAs(UnmanagedType.Bool)] bool bInheritHandle uint dwOptions);

    public static IntPtr DuplicateHandle(SafeHandle hSourceHandle IntPtr hTargetProcessHandle)
    {
      const int DUPLICATE_SAME_ACCESS = 0x00000002;
      IntPtr targetHandle;
      if (!_DuplicateHandleSU(Process.GetCurrentProcess().Handle hSourceHandle hTargetProcessHandle out targetHandle
        0 false DUPLICATE_SAME_ACCESS))
      {
        throw new Win32Exception(Marshal.GetLastWin32Error());
      }
      return targetHandle;
    }

    static void Main(string[] args)
    {
      string pipename = "foopipe" + Guid.NewGuid().ToString("N");
      var pipeServer = new NamedPipeServerStream(pipename PipeDirection.InOut 1 PipeTransmissionMode.Byte PipeOptions.Asynchronous
        4096 4096);
      pipeServer.BeginWaitForConnection(ar =&gt; { pipeServer.EndWaitForConnection(ar); } null);

      IntPtr handle2;
      using (var clientStream1 = new NamedPipeClientStream("." pipename PipeDirection.InOut PipeOptions.Asynchronous TokenImpersonationLevel.None
        System.IO.HandleInheritability.None))
      {
        clientStream1.Connect();
        handle2 = DuplicateHandle(clientStream1.SafePipeHandle Process.GetCurrentProcess().Handle);
      }
      var clientStream2 = new NamedPipeClientStream(PipeDirection.InOut true true new SafePipeHandle(handle2 true));
      pipeServer.WriteAsync(new byte[] { 42 } 0 1);
      Console.WriteLine(clientStream2.ReadByte());
    }
  }
}
```

This is tested on dotnet core 2.1.30 and Windows 10.0.17686.1003.</Title_Description>
    <Label>area-System.IO</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>13/06/2018 4:06:53 AM +00:00</CreatedAt>
    <ClosedAt>31/01/2019 4:51:51 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18448</IssueLabelID>
    <Title>System.BadImageFormatException: 'Bad IL format.'</Title>
    <Description>@atpyk commented on [Wed May 30 2018](https://github.com/dotnet/core/issues/1622)


I've upgraded dotnetcore2.0 to 2.1 and upgraded all packages too.
When I startup my web application the exception prompts.

StackTrace:
   at Microsoft.AspNetCore.Hosting.WebHostBuilder.BuildCommonServices(AggregateException&amp; hostingStartupErrors)
   at Microsoft.AspNetCore.Hosting.WebHostBuilder.Build()
   at GrapeLEAF.AdminService.Program.BuildWebHost(String[] args) in E:\workspace\dotnet\XXX\XXX.AdminService\XXX.AdminService\Program.cs:line 16
   at GrapeLEAF.AdminService.Program.Main(String[] args) in E:\workspace\dotnet\XXX\XXX.AdminService\XXX.AdminService\Program.cs:line 12


---

@atpyk commented on [Thu May 31 2018](https://github.com/dotnet/core/issues/1622#issuecomment-393436939)

I uninstall original .net core sdk and runtime; and reinstall VS2017 and 2.1 sdk. 
I create a new webapi application by scaffold it doesn't work.


---

@VladislavAntonyuk commented on [Thu May 31 2018](https://github.com/dotnet/core/issues/1622#issuecomment-393459163)

https://blogs.msdn.microsoft.com/webdev/2018/05/07/asp-net-core-2-1-0-rc1-now-available/

---

@atpyk commented on [Thu May 31 2018](https://github.com/dotnet/core/issues/1622#issuecomment-393465743)

So sad it doesn't work too.

---

@VladislavAntonyuk commented on [Thu May 31 2018](https://github.com/dotnet/core/issues/1622#issuecomment-393482909)

Make sure you have installed the latest VS and try to reinstall .net core.
Roolback your changes to .net core 2.0 and follow the instruction I have sent you

---

@atpyk commented on [Thu May 31 2018](https://github.com/dotnet/core/issues/1622#issuecomment-393746933)

I debug into Microsoft.AspNetCore.Hosting and find out the error line:
 var hostingServices = BuildCommonServices(out var hostingStartupErrors);

It will throw the exception: 'Bad IL format.'

But if I rename this method to BuildCommonServices111 or other It works.
So weird~
It seems like the namespace "Microsoft.AspNetCore.Hosting"  conflicts with others the .net runtime involves dlls of different version at same time.

---

@VladislavAntonyuk commented on [Fri Jun 01 2018](https://github.com/dotnet/core/issues/1622#issuecomment-393803561)

make sure you have installed version 2.1.300 and try to uninstall all previous versions. Also doublecheck you have finished all steps in the instruction I've sent you 

---

@atpyk commented on [Fri Jun 01 2018](https://github.com/dotnet/core/issues/1622#issuecomment-393810220)

I have reinstall my OS it works.
Thanks.

---

@mangod3 commented on [Sat Jun 02 2018](https://github.com/dotnet/core/issues/1622#issuecomment-394127431)

Did you have NewRelic monitoring your .net app by any chance when you ran into the issue?

---

@Merurino commented on [Sun Jun 03 2018](https://github.com/dotnet/core/issues/1622#issuecomment-394201129)

@mangod3 I was about to comment here. My issue seemed to be Newrelic. Was returning the IL issue. I was building it and running it on docker.



---

@mangod3 commented on [Sun Jun 03 2018](https://github.com/dotnet/core/issues/1622#issuecomment-394224256)

@Merurino Thanks for responding. After debugging the issue it looks like the 2.1 changes related to code versioning (https://github.com/dotnet/coreclr/blob/master/Documentation/design-docs/code-versioning-profiler-breaking-changes.md) are causing issues with profiling APIs. @noahfalk who should we follow up with to get this investigated looks like the ILHeader is not getting initialized correctly after updating a method IL using SetILFunctionBody

---

@noahfalk commented on [Mon Jun 04 2018](https://github.com/dotnet/core/issues/1622#issuecomment-394493650)

 Sorry you are running into trouble! Feel free to start with me as the investigator and I can pull in others as needed. To help get us started:
1) Could you post steps I can follow to try reproducing the problem?
2) Can you let me know what you observed while debugging that lead you to your conclusions?

---

@mangod3 commented on [Mon Jun 04 2018](https://github.com/dotnet/core/issues/1622#issuecomment-394511301)

Thanks for your response @noahfalk. Will package up a repro and send over email. 

---

@joseclament commented on [Wed Jun 06 2018](https://github.com/dotnet/core/issues/1622#issuecomment-395119603)

I have a web job built on netcoreapp2.1 console application targeting the win10-x64 and getting the  "Unhandled Exception: System.BadImageFormatException: Could not load file or assembly exception". 
I haven't had any issue with locally. Deployed using the visual studio directly to the app service. Any thoughts?

---

@noahfalk commented on [Wed Jun 06 2018](https://github.com/dotnet/core/issues/1622#issuecomment-395221204)

@joseclament - Are you aware of any .NET profiler or monitoring agent being used in your deployment environment? If not we should probably a open a new issue because there would be a decent chance that the root cause for you will be unrelated to the root cause here.

---

@joseclament commented on [Thu Jun 07 2018](https://github.com/dotnet/core/issues/1622#issuecomment-395337310)

@noahfalk  I am using AppInsight to push the logs other than no profiling or tooling.
Let me know if I need to open a new issue.


---

@nil4 commented on [Thu Jun 07 2018](https://github.com/dotnet/core/issues/1622#issuecomment-395442460)

@noahfalk I am seeing a similar issue using the [AppDynamics .NET Core profiler agent](https://docs.appdynamics.com/display/PRO44/Install+the+.NET+Core+Microservices+Agent+for+Windows) on a netcoreapp2.1 application and .NET Core SDK 2.1.300. 

When the application starts the following exception is thrown:

```
System.BadImageFormatException
  HResult=0x8007000B
  Message=Bad IL format.
  Source=System.Private.CoreLib
  StackTrace:
   at System.AppDomainManager..ctor()
   at System.Reflection.Assembly.GetEntryAssembly()
   at Microsoft.AspNetCore.Hosting.WebHostBuilder.BuildCommonServices(AggregateException&amp; hostingStartupErrors)
   at Microsoft.AspNetCore.Hosting.WebHostBuilder.Build()
   at MyApp.Web.Startup.Main(String[] args) 
```


---

@joseclament commented on [Thu Jun 07 2018](https://github.com/dotnet/core/issues/1622#issuecomment-395448692)

@noahfalk  and @nil4  I got the bottom of the problem. It took couple of days to get the bottom of the issue and made me bit nut. I was able to dig and find this link: https://tutel.me/c/programming/questions/42726350/how+to+change+azure+app+service+to+64bit

Your core should be built on x86 version even if the deploying server(Azure) is based on 64 bit architecture. Because the 64 bit .NET core processes using the .NET core runtime (as opposed to the .NET Framework runtime) are not yet supported on Azure but is planned to be coming in the future. You can verify this by go to the kudu and type  dotnet --info. You can see something like this below:

.NET Core SDK (reflecting any global.json):
 Version:   2.1.300
 Commit:    32f29b6eb9

Runtime Environment:
 OS Name:     Windows
 OS Version:  10.0.14393
 OS Platform: Windows
 RID:         win10-x86
 _Base Path:   D:\Program Files (x86)\dotnet\sdk\2.1.300\_ [**You  can see only the x86 version here**]

Host (useful for support):
  Version: 2.1.0
  Commit:  caa7b7e2ba

.NET Core SDKs installed:
  1.1.8 [D:\Program Files (x86)\dotnet\sdk]
  2.1.101 [D:\Program Files (x86)\dotnet\sdk]
  2.1.300 [D:\Program Files (x86)\dotnet\sdk]

You may be able to debug this locally "Any CPU" option as you might have x86 and x64 based libraries installed on your machine. I could not find any documentation on MSDN about this. I was assumed it would have been automatically support x64 version. Also make sure that the application setting is enabled for the "32" bit.



---

@nil4 commented on [Thu Jun 07 2018](https://github.com/dotnet/core/issues/1622#issuecomment-395465136)

I am not using Azure. The error occurs on my local PC when launching the application with IIS Express under the VS debugger regardless of whether IIS Express 64-bit or 32-bit is selected.

The application starts up correctly if I remove the AppDynamics.Agent.Windows NuGet package or set `CORECLR_ENABLE_PROFILING` environment variable to `0` in my Web.config (disabling the profiler).

---

@mangod3 commented on [Thu Jun 07 2018](https://github.com/dotnet/core/issues/1622#issuecomment-395478892)

is it possible for you to capture a full native stack of the exception? That might help with identifying if you are hitting the same issue or something different. 

---

@nil4 commented on [Thu Jun 07 2018](https://github.com/dotnet/core/issues/1622#issuecomment-395487431)

@noahfalk  Here are the steps to reproduce the issue I see. In a command prompt run:

```cmd
mkdir Repro1622 &amp;&amp; pushd Repro1622
dotnet new web
dotnet add package AppDynamics.Agent.Windows --version 4.4.3
```
Open the project in Visual Studio and build it once. 

A number of files brought by the AppDynamics package show up under the project including `Repro1622.AppDynamicsConfig.json`. Edit this file and replace its content with:

```json
{
  "controller": {
    "host": "localhost"
    "port": 443
    "account": "customer1"
    "password": "c025be84-d72d-4f6e-b5b4-b33ce264992b"
    "ssl": true
    "enable_tls12": true
  }
  "application": {
    "name": "irrelevant"
    "tier": "irrelevant"
    "node": "irrelevant"
  }
}
```

These values are not important they just need to be different than the default placeholders for the profiler to activate.

Add a `Web.config` file to the project with the following content:

```xml
&lt;configuration&gt;
  &lt;system.webServer&gt;
    &lt;handlers&gt;
      &lt;add name="aspNetCore" path="*" verb="*" modules="AspNetCoreModule" resourceType="Unspecified" /&gt;
    &lt;/handlers&gt;
    &lt;aspNetCore processPath="%LAUNCHER_PATH%" arguments="%LAUNCHER_ARGS%"&gt;
      &lt;environmentVariables&gt;
        &lt;environmentVariable name="CORECLR_ENABLE_PROFILING" value="1" /&gt;
        &lt;environmentVariable name="CORECLR_PROFILER" value="{39AEABC1-56A5-405F-B8E7-C3668490DB4A}" /&gt;

        &lt;environmentVariable name="CORECLR_PROFILER_PATH_32" value="D:\Repro1622\bin\Debug\netcoreapp2.1\AppDynamics.Profiler_x86.dll"/&gt;
        &lt;environmentVariable name="CORECLR_PROFILER_PATH_64" value="D:\Repro1622\bin\Debug\netcoreapp2.1\AppDynamics.Profiler_x64.dll"/&gt;
      &lt;/environmentVariables&gt;
    &lt;/aspNetCore&gt;
  &lt;/system.webServer&gt;
&lt;/configuration&gt;
```

⚠️ Per the [AppDynamics docs](https://docs.appdynamics.com/display/PRO44/Install+the+.NET+Core+Microservices+Agent+for+Windows) the two `CORECLR_PROFILER_PATH_*` variables must be full paths; **adjust as required**.

Start debugging (F5) with IIS Express and note `BadImageFormatException` is thrown at `System.AppDomainManager..ctor()` when the application starts.

Find the newest `.log` file under *%ProgramData%\AppDynamics\DotNetAgent\Logs\Profiler* which should be similar to:
```
2018-06-07 18:22:31.086553&lt;info&gt;:Use CoreCLR profiler
2018-06-07 18:22:31.089553&lt;info&gt;:Should instrument standalone profiler process (config found at D:\Repro1622\bin\Debug\netcoreapp2.1\Repro1622.AppDynamicsConfig.json): dotnet as app Repro1622.dll
2018-06-07 18:22:31.092555&lt;info&gt;:Agent Configuration: {"controller":{"account":"customer1""enableTls12":true"ssl":true"host":"localhost""password":"***""port":443}"application":{"tier":"irrelevant""node":"irrelevant""name":"irrelevant"}}
2018-06-07 18:22:31.092555&lt;info&gt;:Enabled rejit normally disabled all NGEN images.
2018-06-07 18:22:31.163553&lt;error&gt;:InjectMEE failed.
2018-06-07 18:22:31.935346&lt;info&gt;:Transforming 57540:clrhost:System.Void System.AppDomainManager..ctor() with [[][]]
```

---

@noahfalk commented on [Thu Jun 07 2018](https://github.com/dotnet/core/issues/1622#issuecomment-395550918)

@joseclament - Glad you were able to get the bottom of it and very appreciated that you came back to post your findings in case others hit the same issue in the future! Indeed it looks like your issue had a similar symptom but different root cause than the other ones here. I created #1670 to track any further work there.

@nil4 - Thanks for the repro! Let me try repro your issue so we can figure out if this is the same root cause or something else. 

---

@noahfalk commented on [Thu Jun 07 2018](https://github.com/dotnet/core/issues/1622#issuecomment-395614005)

@nil4 - Thanks I was able to reproduce the problem easily using your excellent instructions! Although the AppDynamics issue is slighly different than the NewRelic one (AppDynamics does not call ICorProfilerInfo::SetILFunctionBody or ICorProfilerFunctionControl::SetILFunctionBody)  the fix I submitted earlier today (#18322) does solve both issues at the same time.

I wasn't sure if you were an employee with AppDynamics or a customer of AppDynamics? For potential short term resolutions to the issue you could either continue to use .Net Core 2.0 or use a daily build of .Net Core that has this fix as soon as the installers are ready for download (I'll write back again when they are). A little further in the future I'm attempting to get this fix into the official servicing releases for 2.1. I can also try to reach out to AppDynamics to see if there are any additional solutions available for the issue.

Let me know if you've got any other questions or concerns?

---

@nil4 commented on [Fri Jun 08 2018](https://github.com/dotnet/core/issues/1622#issuecomment-395689332)

@noahfalk glad I could help and thank you for the update much appreciated! I am a customer and have opened an AppDynamics support ticket about this; will update it shortly with a link to this issue.

</Description>
    <Title_Description>System.BadImageFormatException: 'Bad IL format.' @atpyk commented on [Wed May 30 2018](https://github.com/dotnet/core/issues/1622)


I've upgraded dotnetcore2.0 to 2.1 and upgraded all packages too.
When I startup my web application the exception prompts.

StackTrace:
   at Microsoft.AspNetCore.Hosting.WebHostBuilder.BuildCommonServices(AggregateException&amp; hostingStartupErrors)
   at Microsoft.AspNetCore.Hosting.WebHostBuilder.Build()
   at GrapeLEAF.AdminService.Program.BuildWebHost(String[] args) in E:\workspace\dotnet\XXX\XXX.AdminService\XXX.AdminService\Program.cs:line 16
   at GrapeLEAF.AdminService.Program.Main(String[] args) in E:\workspace\dotnet\XXX\XXX.AdminService\XXX.AdminService\Program.cs:line 12


---

@atpyk commented on [Thu May 31 2018](https://github.com/dotnet/core/issues/1622#issuecomment-393436939)

I uninstall original .net core sdk and runtime; and reinstall VS2017 and 2.1 sdk. 
I create a new webapi application by scaffold it doesn't work.


---

@VladislavAntonyuk commented on [Thu May 31 2018](https://github.com/dotnet/core/issues/1622#issuecomment-393459163)

https://blogs.msdn.microsoft.com/webdev/2018/05/07/asp-net-core-2-1-0-rc1-now-available/

---

@atpyk commented on [Thu May 31 2018](https://github.com/dotnet/core/issues/1622#issuecomment-393465743)

So sad it doesn't work too.

---

@VladislavAntonyuk commented on [Thu May 31 2018](https://github.com/dotnet/core/issues/1622#issuecomment-393482909)

Make sure you have installed the latest VS and try to reinstall .net core.
Roolback your changes to .net core 2.0 and follow the instruction I have sent you

---

@atpyk commented on [Thu May 31 2018](https://github.com/dotnet/core/issues/1622#issuecomment-393746933)

I debug into Microsoft.AspNetCore.Hosting and find out the error line:
 var hostingServices = BuildCommonServices(out var hostingStartupErrors);

It will throw the exception: 'Bad IL format.'

But if I rename this method to BuildCommonServices111 or other It works.
So weird~
It seems like the namespace "Microsoft.AspNetCore.Hosting"  conflicts with others the .net runtime involves dlls of different version at same time.

---

@VladislavAntonyuk commented on [Fri Jun 01 2018](https://github.com/dotnet/core/issues/1622#issuecomment-393803561)

make sure you have installed version 2.1.300 and try to uninstall all previous versions. Also doublecheck you have finished all steps in the instruction I've sent you 

---

@atpyk commented on [Fri Jun 01 2018](https://github.com/dotnet/core/issues/1622#issuecomment-393810220)

I have reinstall my OS it works.
Thanks.

---

@mangod3 commented on [Sat Jun 02 2018](https://github.com/dotnet/core/issues/1622#issuecomment-394127431)

Did you have NewRelic monitoring your .net app by any chance when you ran into the issue?

---

@Merurino commented on [Sun Jun 03 2018](https://github.com/dotnet/core/issues/1622#issuecomment-394201129)

@mangod3 I was about to comment here. My issue seemed to be Newrelic. Was returning the IL issue. I was building it and running it on docker.



---

@mangod3 commented on [Sun Jun 03 2018](https://github.com/dotnet/core/issues/1622#issuecomment-394224256)

@Merurino Thanks for responding. After debugging the issue it looks like the 2.1 changes related to code versioning (https://github.com/dotnet/coreclr/blob/master/Documentation/design-docs/code-versioning-profiler-breaking-changes.md) are causing issues with profiling APIs. @noahfalk who should we follow up with to get this investigated looks like the ILHeader is not getting initialized correctly after updating a method IL using SetILFunctionBody

---

@noahfalk commented on [Mon Jun 04 2018](https://github.com/dotnet/core/issues/1622#issuecomment-394493650)

 Sorry you are running into trouble! Feel free to start with me as the investigator and I can pull in others as needed. To help get us started:
1) Could you post steps I can follow to try reproducing the problem?
2) Can you let me know what you observed while debugging that lead you to your conclusions?

---

@mangod3 commented on [Mon Jun 04 2018](https://github.com/dotnet/core/issues/1622#issuecomment-394511301)

Thanks for your response @noahfalk. Will package up a repro and send over email. 

---

@joseclament commented on [Wed Jun 06 2018](https://github.com/dotnet/core/issues/1622#issuecomment-395119603)

I have a web job built on netcoreapp2.1 console application targeting the win10-x64 and getting the  "Unhandled Exception: System.BadImageFormatException: Could not load file or assembly exception". 
I haven't had any issue with locally. Deployed using the visual studio directly to the app service. Any thoughts?

---

@noahfalk commented on [Wed Jun 06 2018](https://github.com/dotnet/core/issues/1622#issuecomment-395221204)

@joseclament - Are you aware of any .NET profiler or monitoring agent being used in your deployment environment? If not we should probably a open a new issue because there would be a decent chance that the root cause for you will be unrelated to the root cause here.

---

@joseclament commented on [Thu Jun 07 2018](https://github.com/dotnet/core/issues/1622#issuecomment-395337310)

@noahfalk  I am using AppInsight to push the logs other than no profiling or tooling.
Let me know if I need to open a new issue.


---

@nil4 commented on [Thu Jun 07 2018](https://github.com/dotnet/core/issues/1622#issuecomment-395442460)

@noahfalk I am seeing a similar issue using the [AppDynamics .NET Core profiler agent](https://docs.appdynamics.com/display/PRO44/Install+the+.NET+Core+Microservices+Agent+for+Windows) on a netcoreapp2.1 application and .NET Core SDK 2.1.300. 

When the application starts the following exception is thrown:

```
System.BadImageFormatException
  HResult=0x8007000B
  Message=Bad IL format.
  Source=System.Private.CoreLib
  StackTrace:
   at System.AppDomainManager..ctor()
   at System.Reflection.Assembly.GetEntryAssembly()
   at Microsoft.AspNetCore.Hosting.WebHostBuilder.BuildCommonServices(AggregateException&amp; hostingStartupErrors)
   at Microsoft.AspNetCore.Hosting.WebHostBuilder.Build()
   at MyApp.Web.Startup.Main(String[] args) 
```


---

@joseclament commented on [Thu Jun 07 2018](https://github.com/dotnet/core/issues/1622#issuecomment-395448692)

@noahfalk  and @nil4  I got the bottom of the problem. It took couple of days to get the bottom of the issue and made me bit nut. I was able to dig and find this link: https://tutel.me/c/programming/questions/42726350/how+to+change+azure+app+service+to+64bit

Your core should be built on x86 version even if the deploying server(Azure) is based on 64 bit architecture. Because the 64 bit .NET core processes using the .NET core runtime (as opposed to the .NET Framework runtime) are not yet supported on Azure but is planned to be coming in the future. You can verify this by go to the kudu and type  dotnet --info. You can see something like this below:

.NET Core SDK (reflecting any global.json):
 Version:   2.1.300
 Commit:    32f29b6eb9

Runtime Environment:
 OS Name:     Windows
 OS Version:  10.0.14393
 OS Platform: Windows
 RID:         win10-x86
 _Base Path:   D:\Program Files (x86)\dotnet\sdk\2.1.300\_ [**You  can see only the x86 version here**]

Host (useful for support):
  Version: 2.1.0
  Commit:  caa7b7e2ba

.NET Core SDKs installed:
  1.1.8 [D:\Program Files (x86)\dotnet\sdk]
  2.1.101 [D:\Program Files (x86)\dotnet\sdk]
  2.1.300 [D:\Program Files (x86)\dotnet\sdk]

You may be able to debug this locally "Any CPU" option as you might have x86 and x64 based libraries installed on your machine. I could not find any documentation on MSDN about this. I was assumed it would have been automatically support x64 version. Also make sure that the application setting is enabled for the "32" bit.



---

@nil4 commented on [Thu Jun 07 2018](https://github.com/dotnet/core/issues/1622#issuecomment-395465136)

I am not using Azure. The error occurs on my local PC when launching the application with IIS Express under the VS debugger regardless of whether IIS Express 64-bit or 32-bit is selected.

The application starts up correctly if I remove the AppDynamics.Agent.Windows NuGet package or set `CORECLR_ENABLE_PROFILING` environment variable to `0` in my Web.config (disabling the profiler).

---

@mangod3 commented on [Thu Jun 07 2018](https://github.com/dotnet/core/issues/1622#issuecomment-395478892)

is it possible for you to capture a full native stack of the exception? That might help with identifying if you are hitting the same issue or something different. 

---

@nil4 commented on [Thu Jun 07 2018](https://github.com/dotnet/core/issues/1622#issuecomment-395487431)

@noahfalk  Here are the steps to reproduce the issue I see. In a command prompt run:

```cmd
mkdir Repro1622 &amp;&amp; pushd Repro1622
dotnet new web
dotnet add package AppDynamics.Agent.Windows --version 4.4.3
```
Open the project in Visual Studio and build it once. 

A number of files brought by the AppDynamics package show up under the project including `Repro1622.AppDynamicsConfig.json`. Edit this file and replace its content with:

```json
{
  "controller": {
    "host": "localhost"
    "port": 443
    "account": "customer1"
    "password": "c025be84-d72d-4f6e-b5b4-b33ce264992b"
    "ssl": true
    "enable_tls12": true
  }
  "application": {
    "name": "irrelevant"
    "tier": "irrelevant"
    "node": "irrelevant"
  }
}
```

These values are not important they just need to be different than the default placeholders for the profiler to activate.

Add a `Web.config` file to the project with the following content:

```xml
&lt;configuration&gt;
  &lt;system.webServer&gt;
    &lt;handlers&gt;
      &lt;add name="aspNetCore" path="*" verb="*" modules="AspNetCoreModule" resourceType="Unspecified" /&gt;
    &lt;/handlers&gt;
    &lt;aspNetCore processPath="%LAUNCHER_PATH%" arguments="%LAUNCHER_ARGS%"&gt;
      &lt;environmentVariables&gt;
        &lt;environmentVariable name="CORECLR_ENABLE_PROFILING" value="1" /&gt;
        &lt;environmentVariable name="CORECLR_PROFILER" value="{39AEABC1-56A5-405F-B8E7-C3668490DB4A}" /&gt;

        &lt;environmentVariable name="CORECLR_PROFILER_PATH_32" value="D:\Repro1622\bin\Debug\netcoreapp2.1\AppDynamics.Profiler_x86.dll"/&gt;
        &lt;environmentVariable name="CORECLR_PROFILER_PATH_64" value="D:\Repro1622\bin\Debug\netcoreapp2.1\AppDynamics.Profiler_x64.dll"/&gt;
      &lt;/environmentVariables&gt;
    &lt;/aspNetCore&gt;
  &lt;/system.webServer&gt;
&lt;/configuration&gt;
```

⚠️ Per the [AppDynamics docs](https://docs.appdynamics.com/display/PRO44/Install+the+.NET+Core+Microservices+Agent+for+Windows) the two `CORECLR_PROFILER_PATH_*` variables must be full paths; **adjust as required**.

Start debugging (F5) with IIS Express and note `BadImageFormatException` is thrown at `System.AppDomainManager..ctor()` when the application starts.

Find the newest `.log` file under *%ProgramData%\AppDynamics\DotNetAgent\Logs\Profiler* which should be similar to:
```
2018-06-07 18:22:31.086553&lt;info&gt;:Use CoreCLR profiler
2018-06-07 18:22:31.089553&lt;info&gt;:Should instrument standalone profiler process (config found at D:\Repro1622\bin\Debug\netcoreapp2.1\Repro1622.AppDynamicsConfig.json): dotnet as app Repro1622.dll
2018-06-07 18:22:31.092555&lt;info&gt;:Agent Configuration: {"controller":{"account":"customer1""enableTls12":true"ssl":true"host":"localhost""password":"***""port":443}"application":{"tier":"irrelevant""node":"irrelevant""name":"irrelevant"}}
2018-06-07 18:22:31.092555&lt;info&gt;:Enabled rejit normally disabled all NGEN images.
2018-06-07 18:22:31.163553&lt;error&gt;:InjectMEE failed.
2018-06-07 18:22:31.935346&lt;info&gt;:Transforming 57540:clrhost:System.Void System.AppDomainManager..ctor() with [[][]]
```

---

@noahfalk commented on [Thu Jun 07 2018](https://github.com/dotnet/core/issues/1622#issuecomment-395550918)

@joseclament - Glad you were able to get the bottom of it and very appreciated that you came back to post your findings in case others hit the same issue in the future! Indeed it looks like your issue had a similar symptom but different root cause than the other ones here. I created #1670 to track any further work there.

@nil4 - Thanks for the repro! Let me try repro your issue so we can figure out if this is the same root cause or something else. 

---

@noahfalk commented on [Thu Jun 07 2018](https://github.com/dotnet/core/issues/1622#issuecomment-395614005)

@nil4 - Thanks I was able to reproduce the problem easily using your excellent instructions! Although the AppDynamics issue is slighly different than the NewRelic one (AppDynamics does not call ICorProfilerInfo::SetILFunctionBody or ICorProfilerFunctionControl::SetILFunctionBody)  the fix I submitted earlier today (#18322) does solve both issues at the same time.

I wasn't sure if you were an employee with AppDynamics or a customer of AppDynamics? For potential short term resolutions to the issue you could either continue to use .Net Core 2.0 or use a daily build of .Net Core that has this fix as soon as the installers are ready for download (I'll write back again when they are). A little further in the future I'm attempting to get this fix into the official servicing releases for 2.1. I can also try to reach out to AppDynamics to see if there are any additional solutions available for the issue.

Let me know if you've got any other questions or concerns?

---

@nil4 commented on [Fri Jun 08 2018](https://github.com/dotnet/core/issues/1622#issuecomment-395689332)

@noahfalk glad I could help and thank you for the update much appreciated! I am a customer and have opened an AppDynamics support ticket about this; will update it shortly with a link to this issue.

</Title_Description>
    <Label>area-TieredCompilation</Label>
    <Assignee>noahfalk</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18447</IssueLabelID>
    <Title>.Net Core and Native dll's always throw BadImageFormat</Title>
    <Description>@SharperC commented on [Sun Jun 10 2018](https://github.com/dotnet/core/issues/1678)

# BadImageFormatException everytime...

After a LOT of times trying to load native code or rather call a native method using `DllImport` I'm reporting this as a issue because it seems like there is no solution.

## So what did I try?

First of all I tried the way it works with .Net Framework what of course didn't work.
I searched in the Internet for solutions but i only found the same problems with "could work" solutions. For example compiling the .Net Core application and the native libary in 64 bit (what i did).
I also tried a non .Net c++ compiler (MinGW) and the default Visual Studio c++ compiler.
Both give the same `BadImageFormat` Exception.

## The code i used

### The c# part
```cs
[DllImport(@"testlib.dll" EntryPoint = "test")]
static extern int Test();

static void Main(string[] args)
{
    Console.WriteLine(Test());
    Console.ReadLine();
}
```

### The c++ part
```cpp
#define EXTERN extern "C" __declspec(dllexport)

EXTERN int test()
{
    return 1234;
}
```

I also tried it on Linux using the g++ compiler for some reason it worked on Linux.

Thanks for taking the time to read.

---

@markusschaber commented on [Mon Jun 11 2018](https://github.com/dotnet/core/issues/1678#issuecomment-396199666)

In my experience the main reason for this exception is when you try to load a 32-bit DLL into a 64 Bit process or the other way round.

Mismatch between x86/ARM is also possible in theory. :-)

Note that sometimes .NET core on Windows runs in an unexpected CPU architecture as some tools (e. G. Visual Studio xUnit etc.) tend to ignore the target CPU architecture defined in the project and just run the code in the first installation they find in PATH so if both 32 and 64 bit runtimes or SDKs are installed it's random which one you get.

We had to change the order of entries in PATH environment variable to run our code with x86 as the native DLL we depend on is not (yet) 64 bit.

---

@dasMulli commented on [Mon Jun 11 2018](https://github.com/dotnet/core/issues/1678#issuecomment-396203170)

for `dotnet` it will use the version of `dotnet.exe` that's in the path - either the 32bit or 64bit `dotnet.exe` host.
There will be some changes that will allow patching the csproj to allow `dotnet run` to switch architectures (when launching a sub-process) but until then it's a bit of a pain - https://github.com/dotnet/sdk/issues/1905

---

@SharperC commented on [Mon Jun 11 2018](https://github.com/dotnet/core/issues/1678#issuecomment-396254074)

@markusschaber I know that you mean but i tried both using a 32bit and a 64bit for c++ and dotnet and yes a already noticed that dotnet tends to totaly ignore if you set the assembly in vs to 32 bit

</Description>
    <Title_Description>.Net Core and Native dll's always throw BadImageFormat @SharperC commented on [Sun Jun 10 2018](https://github.com/dotnet/core/issues/1678)

# BadImageFormatException everytime...

After a LOT of times trying to load native code or rather call a native method using `DllImport` I'm reporting this as a issue because it seems like there is no solution.

## So what did I try?

First of all I tried the way it works with .Net Framework what of course didn't work.
I searched in the Internet for solutions but i only found the same problems with "could work" solutions. For example compiling the .Net Core application and the native libary in 64 bit (what i did).
I also tried a non .Net c++ compiler (MinGW) and the default Visual Studio c++ compiler.
Both give the same `BadImageFormat` Exception.

## The code i used

### The c# part
```cs
[DllImport(@"testlib.dll" EntryPoint = "test")]
static extern int Test();

static void Main(string[] args)
{
    Console.WriteLine(Test());
    Console.ReadLine();
}
```

### The c++ part
```cpp
#define EXTERN extern "C" __declspec(dllexport)

EXTERN int test()
{
    return 1234;
}
```

I also tried it on Linux using the g++ compiler for some reason it worked on Linux.

Thanks for taking the time to read.

---

@markusschaber commented on [Mon Jun 11 2018](https://github.com/dotnet/core/issues/1678#issuecomment-396199666)

In my experience the main reason for this exception is when you try to load a 32-bit DLL into a 64 Bit process or the other way round.

Mismatch between x86/ARM is also possible in theory. :-)

Note that sometimes .NET core on Windows runs in an unexpected CPU architecture as some tools (e. G. Visual Studio xUnit etc.) tend to ignore the target CPU architecture defined in the project and just run the code in the first installation they find in PATH so if both 32 and 64 bit runtimes or SDKs are installed it's random which one you get.

We had to change the order of entries in PATH environment variable to run our code with x86 as the native DLL we depend on is not (yet) 64 bit.

---

@dasMulli commented on [Mon Jun 11 2018](https://github.com/dotnet/core/issues/1678#issuecomment-396203170)

for `dotnet` it will use the version of `dotnet.exe` that's in the path - either the 32bit or 64bit `dotnet.exe` host.
There will be some changes that will allow patching the csproj to allow `dotnet run` to switch architectures (when launching a sub-process) but until then it's a bit of a pain - https://github.com/dotnet/sdk/issues/1905

---

@SharperC commented on [Mon Jun 11 2018](https://github.com/dotnet/core/issues/1678#issuecomment-396254074)

@markusschaber I know that you mean but i tried both using a 32bit and a 64bit for c++ and dotnet and yes a already noticed that dotnet tends to totaly ignore if you set the assembly in vs to 32 bit

</Title_Description>
    <Label>area-AssemblyLoader</Label>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18446</IssueLabelID>
    <Title>SUSE dotnet 2.0.3 Description: Infinite recursion during resource lookup within System.Private.CoreLib.</Title>
    <Description>@iga1976 commented on [Tue Jun 12 2018](https://github.com/dotnet/core/issues/1687)

SUSE dotnet 2.0.3 Description: Infinite recursion during resource lookup within System.Private.CoreLib. This may be a bug in System.Private.CoreLib or potentially in certain extensibility points such as assembly resolve events or CultureInfo names. Resource name: ArgumentNull_Generic 
https://github.com/dotnet/corefx/issues/30208



</Description>
    <Title_Description>SUSE dotnet 2.0.3 Description: Infinite recursion during resource lookup within System.Private.CoreLib. @iga1976 commented on [Tue Jun 12 2018](https://github.com/dotnet/core/issues/1687)

SUSE dotnet 2.0.3 Description: Infinite recursion during resource lookup within System.Private.CoreLib. This may be a bug in System.Private.CoreLib or potentially in certain extensibility points such as assembly resolve events or CultureInfo names. Resource name: ArgumentNull_Generic 
https://github.com/dotnet/corefx/issues/30208



</Title_Description>
    <Label>area-AssemblyLoader</Label>
    <Assignee>kouvel</Assignee>
    <CreatedAt>13/06/2018 3:12:40 AM +00:00</CreatedAt>
    <ClosedAt>26/10/2018 7:56:22 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18445</IssueLabelID>
    <Title>EEJitManager::SetCpuInfo is not exactly matching the ISA hierarchy described by the architecture manuals</Title>
    <Description>SSE/SSE2 support requires:
* Check for CPUID support
* Check the SSE and/or SSE2 flag

SSE3 support requires:
* Check for SSE/SSE2 support
* Check the SSE3 flag

SSSE3 support requires:
* Check for SSE/SSE2 support
* Check the SSSE3 flag

SSE4.1 support requires:
* Check for SSE/SSE2 Support
* Check for SSE3 Support
* Check for SSSE3 Support
* Check the SSE4.1 flag

SSE4.2 support requires:
* Check for SSE/SSE2 Support
* Check for SSSE3 Support
* Check for SSE4.1 Support
* Check the SSE4.2 flag

etc...</Description>
    <Title_Description>EEJitManager::SetCpuInfo is not exactly matching the ISA hierarchy described by the architecture manuals SSE/SSE2 support requires:
* Check for CPUID support
* Check the SSE and/or SSE2 flag

SSE3 support requires:
* Check for SSE/SSE2 support
* Check the SSE3 flag

SSSE3 support requires:
* Check for SSE/SSE2 support
* Check the SSSE3 flag

SSE4.1 support requires:
* Check for SSE/SSE2 Support
* Check for SSE3 Support
* Check for SSSE3 Support
* Check the SSE4.1 flag

SSE4.2 support requires:
* Check for SSE/SSE2 Support
* Check for SSSE3 Support
* Check for SSE4.1 Support
* Check the SSE4.2 flag

etc...</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>tannergooding</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18444</IssueLabelID>
    <Title>Mirror changes from dotnet/corefx</Title>
    <Description>This PR contains mirrored changes from dotnet/corefx


**Please REBASE this PR when merging**</Description>
    <Title_Description>Mirror changes from dotnet/corefx This PR contains mirrored changes from dotnet/corefx


**Please REBASE this PR when merging**</Title_Description>
    <Label>
    </Label>
    <Assignee>Anipik</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18443</IssueLabelID>
    <Title>[arm/Ubuntu] JIT/Methodical/ELEMENT_TYPE_IU/_il_relu_fld/_il_relu_fld.sh failed in gcstress</Title>
    <Description>https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_gcstress0xc_zapdisable_heapverify1_tst/12/consoleFull#-8536224876a086b3e-df04-41d2-bc4d-43e8f9406d07

```
12:08:40 FAILED   - JIT/Methodical/ELEMENT_TYPE_IU/_il_relu_fld/_il_relu_fld.sh
12:08:40                BEGIN EXECUTION
12:08:40                /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_gcstress0xc_zapdisable_heapverify1_tst/bin/tests/Linux.arm.Checked/Tests/Core_Root/corerun _il_relu_fld.exe
12:08:40                -858993344
12:08:40                failed
12:08:40                Expected: 100
12:08:40                Actual: 1
12:08:40                END EXECUTION - FAILED
```

`COMPlus_GCStress=0xc` `COMPlus_ZapDisable=1` `COMPlus_HeapVerify=1`

I could not reproduce this failure.</Description>
    <Title_Description>[arm/Ubuntu] JIT/Methodical/ELEMENT_TYPE_IU/_il_relu_fld/_il_relu_fld.sh failed in gcstress https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_gcstress0xc_zapdisable_heapverify1_tst/12/consoleFull#-8536224876a086b3e-df04-41d2-bc4d-43e8f9406d07

```
12:08:40 FAILED   - JIT/Methodical/ELEMENT_TYPE_IU/_il_relu_fld/_il_relu_fld.sh
12:08:40                BEGIN EXECUTION
12:08:40                /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_gcstress0xc_zapdisable_heapverify1_tst/bin/tests/Linux.arm.Checked/Tests/Core_Root/corerun _il_relu_fld.exe
12:08:40                -858993344
12:08:40                failed
12:08:40                Expected: 100
12:08:40                Actual: 1
12:08:40                END EXECUTION - FAILED
```

`COMPlus_GCStress=0xc` `COMPlus_ZapDisable=1` `COMPlus_HeapVerify=1`

I could not reproduce this failure.</Title_Description>
    <Label>GCStress</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>12/06/2018 10:55:06 PM +00:00</CreatedAt>
    <ClosedAt>12/06/2018 10:55:22 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18441</IssueLabelID>
    <Title>[arm/Ubuntu] crash under GCStress in test b65423.exe</Title>
    <Description>E.g. https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_gcstress0xc_zapdisable_tst/12/consoleFull#-5931779914b7730ef-150b-4be7-a00f-82ba6c50792b

```
09:41:06                BEGIN EXECUTION
09:41:06                /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_gcstress0xc_zapdisable_tst/bin/tests/Linux.arm.Checked/Tests/Core_Root/corerun b65423.exe
09:41:06                Caught TypeLoadException exception: 100
09:41:06 
               ./b65423.sh: line 244:  3713 Segmentation fault      $_DebuggerFullPath "$CORE_ROOT/corerun" $ExePath $CLRTestExecutionArguments
09:41:06                Expected: 100
09:41:06                Actual: 139
09:41:06                END EXECUTION - FAILED
```

I can repro this about 1/2 the time with just `COMPlus_GCStress=C`. I've never seen it take more than 4 runs in a row to reproduce. I can't reproduce the crash under GDB.
</Description>
    <Title_Description>[arm/Ubuntu] crash under GCStress in test b65423.exe E.g. https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_gcstress0xc_zapdisable_tst/12/consoleFull#-5931779914b7730ef-150b-4be7-a00f-82ba6c50792b

```
09:41:06                BEGIN EXECUTION
09:41:06                /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_gcstress0xc_zapdisable_tst/bin/tests/Linux.arm.Checked/Tests/Core_Root/corerun b65423.exe
09:41:06                Caught TypeLoadException exception: 100
09:41:06 
               ./b65423.sh: line 244:  3713 Segmentation fault      $_DebuggerFullPath "$CORE_ROOT/corerun" $ExePath $CLRTestExecutionArguments
09:41:06                Expected: 100
09:41:06                Actual: 139
09:41:06                END EXECUTION - FAILED
```

I can repro this about 1/2 the time with just `COMPlus_GCStress=C`. I've never seen it take more than 4 runs in a row to reproduce. I can't reproduce the crash under GDB.
</Title_Description>
    <Label>GCStress</Label>
    <Assignee>BruceForstall</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18439</IssueLabelID>
    <Title>Crash in coreclr when muxer/apphost path contains valid UTF-8 sequence</Title>
    <Description>## Steps to reproduce

On macOS 10.13 (with brew installed `wget`):

```
$ wget https://download.microsoft.com/download/8/8/5/88544F33-836A-49A5-8B67-451C24709A8F/dotnet-sdk-2.1.300-osx-x64.tar.gz
$ mkdir 我能吞下玻璃而不傷身體
$ cd 我能吞下玻璃而不傷身體
$ tar xvzf ../dotnet-sdk-2.1.300-osx-x64.tar.gz
$ ./dotnet --help
```

## Expected  behavior

`dotnet` should print out the SDK help.

## Actual behavior

`dotnet` segfaults:

```
$ ./dotnet --help
[1]    70062 segmentation fault  ./dotnet --help
```

Backtrace:
```
(lldb) bt
* thread #1 queue = 'com.apple.main-thread' stop reason = EXC_BAD_ACCESS (code=1 address=0x0)
  * frame #0: 0x0000000000000000
    frame #1: 0x000000010204b51e libcoreclr.dylib`ClrAllocInProcessHeapBootstrap(unsigned int unsigned long) + 30
    frame #2: 0x000000010204b872 libcoreclr.dylib`operator new(unsigned long) + 18
    frame #3: 0x000000010201b144 libcoreclr.dylib`DecoderReplacementFallback::CreateFallbackBuffer() + 20
    frame #4: 0x000000010201b80e libcoreclr.dylib`UTF8Encoding::GetCharCount(unsigned char* int) + 1102
    frame #5: 0x000000010201b2f3 libcoreclr.dylib`UTF8ToUnicode + 179
    frame #6: 0x0000000102018231 libcoreclr.dylib`Initialize(int char const* const* unsigned int) + 737
    frame #7: 0x0000000102018872 libcoreclr.dylib`PAL_InitializeCoreCLR + 34
    frame #8: 0x000000010204ad35 libcoreclr.dylib`coreclr_initialize + 37
    frame #9: 0x0000000100476cfc libhostpolicy.dylib`___lldb_unnamed_symbol946$$libhostpolicy.dylib + 172
    frame #10: 0x000000010045f48c libhostpolicy.dylib`___lldb_unnamed_symbol750$$libhostpolicy.dylib + 32428
    frame #11: 0x0000000100466af9 libhostpolicy.dylib`___lldb_unnamed_symbol773$$libhostpolicy.dylib + 297
    frame #12: 0x000000010038b3a3 libhostfxr.dylib`___lldb_unnamed_symbol931$$libhostfxr.dylib + 451
    frame #13: 0x00000001003af16e libhostfxr.dylib`___lldb_unnamed_symbol1000$$libhostfxr.dylib + 18606
    frame #14: 0x00000001003b1d42 libhostfxr.dylib`___lldb_unnamed_symbol1009$$libhostfxr.dylib + 1602
    frame #15: 0x00000001003b1ed5 libhostfxr.dylib`___lldb_unnamed_symbol1011$$libhostfxr.dylib + 309
    frame #16: 0x00000001003b157b libhostfxr.dylib`___lldb_unnamed_symbol1008$$libhostfxr.dylib + 4891
    frame #17: 0x00000001003b0151 libhostfxr.dylib`___lldb_unnamed_symbol1007$$libhostfxr.dylib + 1809
    frame #18: 0x000000010038c419 libhostfxr.dylib`___lldb_unnamed_symbol934$$libhostfxr.dylib + 297
    frame #19: 0x000000010000d052 dotnet`___lldb_unnamed_symbol58$$dotnet + 7842
    frame #20: 0x000000010000d645 dotnet`___lldb_unnamed_symbol60$$dotnet + 165
    frame #21: 0x00007fff75d4f015 libdyld.dylib`start + 1
    frame #22: 0x00007fff75d4f015 libdyld.dylib`start + 1
```

## Additional information

I've verified the argument to `UTF8ToUnicode` is valid UTF-8:

```
(lldb) mem read -c 69 0x0000000100231170
0x100231170: 2f 55 73 65 72 73 2f 70 65 74 65 72 68 75 65 6e  /Users/peterhuen
0x100231180: 65 2f 44 6f 77 6e 6c 6f 61 64 73 2f e6 88 91 e8  e/Downloads/�..�
0x100231190: 83 bd e5 90 9e e4 b8 8b e7 8e bb e7 92 83 e8 80  .��..�.�.��..�.
0x1002311a0: 8c e4 b8 8d e5 82 b7 e8 ba ab e9 ab 94 2f 64 6f  .�.�.�身�./do
0x1002311b0: 74 6e 65 74 00                                   tnet.
```

which is the expected `argv[0]` of:

```
/Users/peterhuene/Downloads/我能吞下玻璃而不傷身體/dotnet
```

It appears that it is treating part of the sequence as invalid UTF-8 and attempting to count or add a fallback character but the fallback buffer can't be allocated yet (initialization issue I assume?).

## Environment data
```
$ dotnet --info
.NET Core SDK (reflecting any global.json):
 Version:   2.1.300
 Commit:    adab45bf0c

Runtime Environment:
 OS Name:     Mac OS X
 OS Version:  10.13
 OS Platform: Darwin
 RID:         osx.10.13-x64
 Base Path:   /usr/local/share/dotnet/sdk/2.1.300/

Host (useful for support):
  Version: 2.1.0
  Commit:  caa7b7e2ba

.NET Core SDKs installed:
  2.1.300 [/usr/local/share/dotnet/sdk]

.NET Core runtimes installed:
  Microsoft.AspNetCore.All 2.1.0 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.All]
  Microsoft.AspNetCore.App 2.1.0 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]
  Microsoft.NETCore.App 2.1.0 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App]

To install additional .NET Core runtimes or SDKs:
  https://aka.ms/dotnet-download
```

</Description>
    <Title_Description>Crash in coreclr when muxer/apphost path contains valid UTF-8 sequence ## Steps to reproduce

On macOS 10.13 (with brew installed `wget`):

```
$ wget https://download.microsoft.com/download/8/8/5/88544F33-836A-49A5-8B67-451C24709A8F/dotnet-sdk-2.1.300-osx-x64.tar.gz
$ mkdir 我能吞下玻璃而不傷身體
$ cd 我能吞下玻璃而不傷身體
$ tar xvzf ../dotnet-sdk-2.1.300-osx-x64.tar.gz
$ ./dotnet --help
```

## Expected  behavior

`dotnet` should print out the SDK help.

## Actual behavior

`dotnet` segfaults:

```
$ ./dotnet --help
[1]    70062 segmentation fault  ./dotnet --help
```

Backtrace:
```
(lldb) bt
* thread #1 queue = 'com.apple.main-thread' stop reason = EXC_BAD_ACCESS (code=1 address=0x0)
  * frame #0: 0x0000000000000000
    frame #1: 0x000000010204b51e libcoreclr.dylib`ClrAllocInProcessHeapBootstrap(unsigned int unsigned long) + 30
    frame #2: 0x000000010204b872 libcoreclr.dylib`operator new(unsigned long) + 18
    frame #3: 0x000000010201b144 libcoreclr.dylib`DecoderReplacementFallback::CreateFallbackBuffer() + 20
    frame #4: 0x000000010201b80e libcoreclr.dylib`UTF8Encoding::GetCharCount(unsigned char* int) + 1102
    frame #5: 0x000000010201b2f3 libcoreclr.dylib`UTF8ToUnicode + 179
    frame #6: 0x0000000102018231 libcoreclr.dylib`Initialize(int char const* const* unsigned int) + 737
    frame #7: 0x0000000102018872 libcoreclr.dylib`PAL_InitializeCoreCLR + 34
    frame #8: 0x000000010204ad35 libcoreclr.dylib`coreclr_initialize + 37
    frame #9: 0x0000000100476cfc libhostpolicy.dylib`___lldb_unnamed_symbol946$$libhostpolicy.dylib + 172
    frame #10: 0x000000010045f48c libhostpolicy.dylib`___lldb_unnamed_symbol750$$libhostpolicy.dylib + 32428
    frame #11: 0x0000000100466af9 libhostpolicy.dylib`___lldb_unnamed_symbol773$$libhostpolicy.dylib + 297
    frame #12: 0x000000010038b3a3 libhostfxr.dylib`___lldb_unnamed_symbol931$$libhostfxr.dylib + 451
    frame #13: 0x00000001003af16e libhostfxr.dylib`___lldb_unnamed_symbol1000$$libhostfxr.dylib + 18606
    frame #14: 0x00000001003b1d42 libhostfxr.dylib`___lldb_unnamed_symbol1009$$libhostfxr.dylib + 1602
    frame #15: 0x00000001003b1ed5 libhostfxr.dylib`___lldb_unnamed_symbol1011$$libhostfxr.dylib + 309
    frame #16: 0x00000001003b157b libhostfxr.dylib`___lldb_unnamed_symbol1008$$libhostfxr.dylib + 4891
    frame #17: 0x00000001003b0151 libhostfxr.dylib`___lldb_unnamed_symbol1007$$libhostfxr.dylib + 1809
    frame #18: 0x000000010038c419 libhostfxr.dylib`___lldb_unnamed_symbol934$$libhostfxr.dylib + 297
    frame #19: 0x000000010000d052 dotnet`___lldb_unnamed_symbol58$$dotnet + 7842
    frame #20: 0x000000010000d645 dotnet`___lldb_unnamed_symbol60$$dotnet + 165
    frame #21: 0x00007fff75d4f015 libdyld.dylib`start + 1
    frame #22: 0x00007fff75d4f015 libdyld.dylib`start + 1
```

## Additional information

I've verified the argument to `UTF8ToUnicode` is valid UTF-8:

```
(lldb) mem read -c 69 0x0000000100231170
0x100231170: 2f 55 73 65 72 73 2f 70 65 74 65 72 68 75 65 6e  /Users/peterhuen
0x100231180: 65 2f 44 6f 77 6e 6c 6f 61 64 73 2f e6 88 91 e8  e/Downloads/�..�
0x100231190: 83 bd e5 90 9e e4 b8 8b e7 8e bb e7 92 83 e8 80  .��..�.�.��..�.
0x1002311a0: 8c e4 b8 8d e5 82 b7 e8 ba ab e9 ab 94 2f 64 6f  .�.�.�身�./do
0x1002311b0: 74 6e 65 74 00                                   tnet.
```

which is the expected `argv[0]` of:

```
/Users/peterhuene/Downloads/我能吞下玻璃而不傷身體/dotnet
```

It appears that it is treating part of the sequence as invalid UTF-8 and attempting to count or add a fallback character but the fallback buffer can't be allocated yet (initialization issue I assume?).

## Environment data
```
$ dotnet --info
.NET Core SDK (reflecting any global.json):
 Version:   2.1.300
 Commit:    adab45bf0c

Runtime Environment:
 OS Name:     Mac OS X
 OS Version:  10.13
 OS Platform: Darwin
 RID:         osx.10.13-x64
 Base Path:   /usr/local/share/dotnet/sdk/2.1.300/

Host (useful for support):
  Version: 2.1.0
  Commit:  caa7b7e2ba

.NET Core SDKs installed:
  2.1.300 [/usr/local/share/dotnet/sdk]

.NET Core runtimes installed:
  Microsoft.AspNetCore.All 2.1.0 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.All]
  Microsoft.AspNetCore.App 2.1.0 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]
  Microsoft.NETCore.App 2.1.0 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App]

To install additional .NET Core runtimes or SDKs:
  https://aka.ms/dotnet-download
```

</Title_Description>
    <Label>area-PAL</Label>
    <Assignee>janvorli</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18437</IssueLabelID>
    <Title>GC KeepAlive test incorrectly assumes GC activity</Title>
    <Description>tests\src\GC\API\GC\keepalive.cs is testing `GC.KeepAlive()` but has incorrect logic that causes the test to fail in some GCStress + JitStress combinations (e.g. [here](https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_gcstress0xc_jitstress2_tst/11/consoleFull#-8536224876a086b3e-df04-41d2-bc4d-43e8f9406d07)).

Basically the `Test:RunTest()` function calls `GC.KeepAlive(obj)` to keep a `Dummy` class object alive. It then returns to Main which checks that the `Dummy` class finalizer has not run. However under GCStress a GC could have run between the `GC.KeepAlive()` and the `bool` check.

In the referenced test failure with `COMPlus_GCStress=0xc` and `COMPlus_JitStress=2` one salient different compared to a non-`COMPlus_JitStress` run is that the `Test:RunTest()` function is made fully interruptible which allows for more GCStress-caused GC events.
</Description>
    <Title_Description>GC KeepAlive test incorrectly assumes GC activity tests\src\GC\API\GC\keepalive.cs is testing `GC.KeepAlive()` but has incorrect logic that causes the test to fail in some GCStress + JitStress combinations (e.g. [here](https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_gcstress0xc_jitstress2_tst/11/consoleFull#-8536224876a086b3e-df04-41d2-bc4d-43e8f9406d07)).

Basically the `Test:RunTest()` function calls `GC.KeepAlive(obj)` to keep a `Dummy` class object alive. It then returns to Main which checks that the `Dummy` class finalizer has not run. However under GCStress a GC could have run between the `GC.KeepAlive()` and the `bool` check.

In the referenced test failure with `COMPlus_GCStress=0xc` and `COMPlus_JitStress=2` one salient different compared to a non-`COMPlus_JitStress` run is that the `Test:RunTest()` function is made fully interruptible which allows for more GCStress-caused GC events.
</Title_Description>
    <Label>GCStress</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>12/06/2018 6:53:04 PM +00:00</CreatedAt>
    <ClosedAt>13/06/2018 10:04:24 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18436</IssueLabelID>
    <Title>Move SSE/SSE2 Set[All]Vector128 helpers to JIT implementation</Title>
    <Description>The current managed implementation of SSE/SSE2 `Set[All]Vector128` helpers have some inefficient codegn (e.g. unnecessary zeroing semantics from `SetScalarVector128`). I will look into moving them to JIT-inside implementation.

cc @CarolEidt @tannergooding </Description>
    <Title_Description>Move SSE/SSE2 Set[All]Vector128 helpers to JIT implementation The current managed implementation of SSE/SSE2 `Set[All]Vector128` helpers have some inefficient codegn (e.g. unnecessary zeroing semantics from `SetScalarVector128`). I will look into moving them to JIT-inside implementation.

cc @CarolEidt @tannergooding </Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>fiigii</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18434</IssueLabelID>
    <Title>Make Line numbers work for crossgened DLLs when profiling with EventPipe </Title>
    <Description>Useing the 2.1 version of .NET Core you profile a simple app .NET Core App o (e.g. a spin loop like)
```
            var start = DateTime.Now;
            while ((DateTime.Now - start).TotalSeconds &lt; 5)
                {}
```
Using EventPipe (e.g. set COMPlus_EnableEventPipe=1 and run the app) and then open the resulting *.netperf file you will find that PerfView's 'Goto Source' feature works in the main program attributing the cost to the correct source line.  

However if you open up frames that are inside the framework (e.g. System.TimeZoneInfo.GetLocalTimeZoneFromTzFile) you will find that while PerfView can open the source code (it can correctly find the PDBS for System.Private.Corelib.pdb and the source files on Github) but it will attribute all the cost the the first line in the method.

This is because PerfView lacks the Native-&gt;IL mapping needed to map to a particular IL instruction (which in turn can be mapped to a particular line).     These normally given to perfView by the ILToNativeMap events in the runtime.  (Normally PerfView hides these events when you look at a trace but if you pass PerfView the /keepAllEvents when the trace is converted you can see them).  

What you will find is that the mappings exist for all JIT compiled methods (at the time of JIT as well as during rundown) but there are no ILToNativeMap rundown events for DLLs that have been precompiled with Crossgen (which is most of the framework). 

We do force the rundown of all methods (DCStopVerbose) that are precompiled (that is how we know the method) but we do currently do this for the ILToNativeMap.   

Thus the most straightforward solution is to simply log the ILToNativeMap during this rundown as well.  

This will be alot of data and it may not be needed for simple investigations but I think it is best to do the simple thing (always include it) and we can talk about having options for turning it off for advanced scenarios that care about file size.   

@brianrob 


</Description>
    <Title_Description>Make Line numbers work for crossgened DLLs when profiling with EventPipe  Useing the 2.1 version of .NET Core you profile a simple app .NET Core App o (e.g. a spin loop like)
```
            var start = DateTime.Now;
            while ((DateTime.Now - start).TotalSeconds &lt; 5)
                {}
```
Using EventPipe (e.g. set COMPlus_EnableEventPipe=1 and run the app) and then open the resulting *.netperf file you will find that PerfView's 'Goto Source' feature works in the main program attributing the cost to the correct source line.  

However if you open up frames that are inside the framework (e.g. System.TimeZoneInfo.GetLocalTimeZoneFromTzFile) you will find that while PerfView can open the source code (it can correctly find the PDBS for System.Private.Corelib.pdb and the source files on Github) but it will attribute all the cost the the first line in the method.

This is because PerfView lacks the Native-&gt;IL mapping needed to map to a particular IL instruction (which in turn can be mapped to a particular line).     These normally given to perfView by the ILToNativeMap events in the runtime.  (Normally PerfView hides these events when you look at a trace but if you pass PerfView the /keepAllEvents when the trace is converted you can see them).  

What you will find is that the mappings exist for all JIT compiled methods (at the time of JIT as well as during rundown) but there are no ILToNativeMap rundown events for DLLs that have been precompiled with Crossgen (which is most of the framework). 

We do force the rundown of all methods (DCStopVerbose) that are precompiled (that is how we know the method) but we do currently do this for the ILToNativeMap.   

Thus the most straightforward solution is to simply log the ILToNativeMap during this rundown as well.  

This will be alot of data and it may not be needed for simple investigations but I think it is best to do the simple thing (always include it) and we can talk about having options for turning it off for advanced scenarios that care about file size.   

@brianrob 


</Title_Description>
    <Label>EventPipe</Label>
    <Assignee>brianrob</Assignee>
    <CreatedAt>12/06/2018 6:34:55 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18432</IssueLabelID>
    <Title>Mirror changes from dotnet/corert</Title>
    <Description>This PR contains mirrored changes from dotnet/corert


**Please REBASE this PR when merging**</Description>
    <Title_Description>Mirror changes from dotnet/corert This PR contains mirrored changes from dotnet/corert


**Please REBASE this PR when merging**</Title_Description>
    <Label>
    </Label>
    <Assignee>MichalStrehovsky</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18430</IssueLabelID>
    <Title>ArgumentException.Message and ParamName</Title>
    <Description>When an execption of type System.ArgumentException (or any inheritors) is thrown with paramName set it appends the text "Parameter Name: &lt;paramName&gt;" to the ArgumentException.Message (Ref [this](https://github.com/dotnet/coreclr/blob/1b32b2b795d52bd4bc00fd37efd528ef56b9d7af/src/System.Private.CoreLib/shared/System/ArgumentException.cs#L84)).

My opinion is that this "Parameter Name" addition has nothing to do in the Message property that one should only contain what's . If people want this it is possible to retrieve this using the ParamName property. Stripping it away when reading the exception is not an option since this text is localizable (e.g. "Parameternavn" in Norwegian) and thus impossible to extract in all translation variants.

So it should be removed from ArgumentException.Message however. It should be added to .ToString() override since the intention of this is to display the whole argument exception information including all parameters.

If someone really requires parameter name as a part of the ArgumentExeption.Message they should append this themselves when creating the exception.

I know that this is legacy from before .NET Core and exists in .NET Framework but I can't see why it couldn't be fixed. I suspect that this code is more copy/pasted from the .NET Framework source.
</Description>
    <Title_Description>ArgumentException.Message and ParamName When an execption of type System.ArgumentException (or any inheritors) is thrown with paramName set it appends the text "Parameter Name: &lt;paramName&gt;" to the ArgumentException.Message (Ref [this](https://github.com/dotnet/coreclr/blob/1b32b2b795d52bd4bc00fd37efd528ef56b9d7af/src/System.Private.CoreLib/shared/System/ArgumentException.cs#L84)).

My opinion is that this "Parameter Name" addition has nothing to do in the Message property that one should only contain what's . If people want this it is possible to retrieve this using the ParamName property. Stripping it away when reading the exception is not an option since this text is localizable (e.g. "Parameternavn" in Norwegian) and thus impossible to extract in all translation variants.

So it should be removed from ArgumentException.Message however. It should be added to .ToString() override since the intention of this is to display the whole argument exception information including all parameters.

If someone really requires parameter name as a part of the ArgumentExeption.Message they should append this themselves when creating the exception.

I know that this is legacy from before .NET Core and exists in .NET Framework but I can't see why it couldn't be fixed. I suspect that this code is more copy/pasted from the .NET Framework source.
</Title_Description>
    <Label>area-System.Runtime</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>12/06/2018 12:53:14 PM +00:00</CreatedAt>
    <ClosedAt>31/01/2019 8:14:41 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18429</IssueLabelID>
    <Title>Enable Tiered Compilation by default</Title>
    <Description>1) Changes the default state of the tiered compilation feature check to be ON BY DEFAULT
2) Removed comments about the source about this being a work in progress. Although it will surely continue to evolve and improve remaining issues would be better tracked in our issue tracking system with the same default presumption as other runtime features - assume it works unless noted otherwise.
3) Adjusts a number of tests and automated scripts that made assumptions that the default setting of this feature is off.
4) Stop accepting the deprecated env var COMPLUS_EXPERIMENTAL_TieredCompilation. I'm not aware it has any remaining usage but if so we're going to find out.


@kouvel @adiaaida @adamsitnik @jorive - This isn't going to work just yet (if nothing else I think a bunch of jit tests will be improperly disabled) but I hope its in the ballpark.

I've marked this NO_MERGE to ensure nobody submits it prematurely but I do plan to remove the marking and merge once the PR is green I've given broader heads up to the team that this change is incoming and everyone is ready for it.
</Description>
    <Title_Description>Enable Tiered Compilation by default 1) Changes the default state of the tiered compilation feature check to be ON BY DEFAULT
2) Removed comments about the source about this being a work in progress. Although it will surely continue to evolve and improve remaining issues would be better tracked in our issue tracking system with the same default presumption as other runtime features - assume it works unless noted otherwise.
3) Adjusts a number of tests and automated scripts that made assumptions that the default setting of this feature is off.
4) Stop accepting the deprecated env var COMPLUS_EXPERIMENTAL_TieredCompilation. I'm not aware it has any remaining usage but if so we're going to find out.


@kouvel @adiaaida @adamsitnik @jorive - This isn't going to work just yet (if nothing else I think a bunch of jit tests will be improperly disabled) but I hope its in the ballpark.

I've marked this NO_MERGE to ensure nobody submits it prematurely but I do plan to remove the marking and merge once the PR is green I've given broader heads up to the team that this change is incoming and everyone is ready for it.
</Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>kouvel</Assignee>
    <CreatedAt>12/06/2018 9:03:14 AM +00:00</CreatedAt>
    <ClosedAt>25/07/2018 2:44:04 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18428</IssueLabelID>
    <Title>Add profiling events to describe stub code generated by the runtime</Title>
    <Description>One example of the issue came up when doing some investigation on tiered jitting here: https://github.com/dotnet/coreclr/issues/18361#issuecomment-396495131
In that case we were analyzing sampled instructions and trying to attribute them to code. Several of the instructions were within Precodes and there is no ETW information that correlates this.

At a broader scope as far as I know there aren't profiling events that describe any of our generated code that doesn't come from the JIT. 

This is potentially overlapped with #12070 but that one appears to focus on missing unwind information that would be emitted for the OS to use. This issue covers names and other descriptive information that would be useful for diagnostics tools to show in the UI or to do analysis with.</Description>
    <Title_Description>Add profiling events to describe stub code generated by the runtime One example of the issue came up when doing some investigation on tiered jitting here: https://github.com/dotnet/coreclr/issues/18361#issuecomment-396495131
In that case we were analyzing sampled instructions and trying to attribute them to code. Several of the instructions were within Precodes and there is no ETW information that correlates this.

At a broader scope as far as I know there aren't profiling events that describe any of our generated code that doesn't come from the JIT. 

This is potentially overlapped with #12070 but that one appears to focus on missing unwind information that would be emitted for the OS to use. This issue covers names and other descriptive information that would be useful for diagnostics tools to show in the UI or to do analysis with.</Title_Description>
    <Label>area-TieredCompilation</Label>
    <Assignee>noahfalk</Assignee>
    <CreatedAt>12/06/2018 7:54:51 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18427</IssueLabelID>
    <Title> Move x86 HW intrinsics files to shared</Title>
    <Description>Fixes: #15922
</Description>
    <Title_Description> Move x86 HW intrinsics files to shared Fixes: #15922
</Title_Description>
    <Label>
    </Label>
    <Assignee>maryamariyan</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18426</IssueLabelID>
    <Title>[WIP][test pr] find cases when the cold part does not adjust the hot part.</Title>
    <Description>
    </Description>
    <Title_Description>[WIP][test pr] find cases when the cold part does not adjust the hot part. </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>12/06/2018 1:16:54 AM +00:00</CreatedAt>
    <ClosedAt>12/06/2018 5:35:12 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18423</IssueLabelID>
    <Title>Add public implementation FrameworkEventSourceSupport</Title>
    <Description>Add class FrameworkEventSourceSupport for S.P.WindowsRuntime to use.

corefx PR:https://github.com/dotnet/corefx/pull/30297</Description>
    <Title_Description>Add public implementation FrameworkEventSourceSupport Add class FrameworkEventSourceSupport for S.P.WindowsRuntime to use.

corefx PR:https://github.com/dotnet/corefx/pull/30297</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>luqunl</Assignee>
    <CreatedAt>11/06/2018 9:56:42 PM +00:00</CreatedAt>
    <ClosedAt>28/06/2018 2:55:47 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18422</IssueLabelID>
    <Title>Revert "Temporarily disable package signing in 2.0.0"</Title>
    <Description>Reverts dotnet/coreclr#18421

Don't merge until the 2.0.0 Publish job has signing permissions

CC @weshaggard </Description>
    <Title_Description>Revert "Temporarily disable package signing in 2.0.0" Reverts dotnet/coreclr#18421

Don't merge until the 2.0.0 Publish job has signing permissions

CC @weshaggard </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>wtgodbe</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18420</IssueLabelID>
    <Title>Make a pass to remove dead strings from mscorrc.rc</Title>
    <Description>Some strings in [mscorrc.rc](https://github.com/dotnet/coreclr/blob/master/src/dlls/mscorrc/mscorrc.rc) seem to be dead. eg
`IDS_SERIALIZATION_NONFREEZABLE_TYPE` `IDS_EE_IJWLOAD_CROSSVERSION_DISALLOWED` `IDS_EE_TORNSTATE` `IDS_CLASSLOAD_SH_SUBCLASS_FINALIZER`

It should not be too hard to write a script that removes any strings whose identifiers only appear in mscorrc\mscorrc.rc and mscorrc\resource.h.

Separately src\inc\corerror.xml which generates mscorurt.rc and coreerror.h may also be worth looking at. eg : `CLR_OPTSVC_E_CONTROLLER_INTERRUPT` `NGEN_E_EXE_MACHINE_TYPE_MISMATCH`</Description>
    <Title_Description>Make a pass to remove dead strings from mscorrc.rc Some strings in [mscorrc.rc](https://github.com/dotnet/coreclr/blob/master/src/dlls/mscorrc/mscorrc.rc) seem to be dead. eg
`IDS_SERIALIZATION_NONFREEZABLE_TYPE` `IDS_EE_IJWLOAD_CROSSVERSION_DISALLOWED` `IDS_EE_TORNSTATE` `IDS_CLASSLOAD_SH_SUBCLASS_FINALIZER`

It should not be too hard to write a script that removes any strings whose identifiers only appear in mscorrc\mscorrc.rc and mscorrc\resource.h.

Separately src\inc\corerror.xml which generates mscorurt.rc and coreerror.h may also be worth looking at. eg : `CLR_OPTSVC_E_CONTROLLER_INTERRUPT` `NGEN_E_EXE_MACHINE_TYPE_MISMATCH`</Title_Description>
    <Label>easy</Label>
    <Assignee>danmosemsft</Assignee>
    <CreatedAt>11/06/2018 9:40:51 PM +00:00</CreatedAt>
    <ClosedAt>27/06/2018 3:41:34 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18415</IssueLabelID>
    <Title>skip empty regMask in verifyRegistersUsed</Title>
    <Description>Fixes #18367.

To repro this issue we need to call `verifyRegistersUsed` with `RBM_NONE` it happens only when `genEmitHelperCall` returns empty `callKillSet` for the helper and this situation is possible only for `CORINFO_HELP_PROF_FCN_LEAVE` in `genProfilingLeaveCallback`. It means that we need an attached profiler to hit this issue.

Because the cost of the repro is higher that its expected value I have decided to push only the fix.</Description>
    <Title_Description>skip empty regMask in verifyRegistersUsed Fixes #18367.

To repro this issue we need to call `verifyRegistersUsed` with `RBM_NONE` it happens only when `genEmitHelperCall` returns empty `callKillSet` for the helper and this situation is possible only for `CORINFO_HELP_PROF_FCN_LEAVE` in `genProfilingLeaveCallback`. It means that we need an attached profiler to hit this issue.

Because the cost of the repro is higher that its expected value I have decided to push only the fix.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>11/06/2018 7:25:57 PM +00:00</CreatedAt>
    <ClosedAt>11/06/2018 9:29:18 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18410</IssueLabelID>
    <Title>FileNotFoundException being thrown for assemblies that are in fact present or even when loaded into AppDomain</Title>
    <Description>I have a small .NET Core app I am writing which reads all types from an assembly and the XML comments from the corresponding XML comments file. I am facing a problem with loads of **FileNotFoundException**s being thrown when a method constructor or whatever is using a type that comes from another assembly (example: `SelectList` from `Microsoft.AspNetCore.Mvc.ViewFeatures`). So when trying to get info from say a `RuntimeMethodInfo` it will throw an exception like: **Could not load file or assembly 'Microsoft.AspNetCore.Mvc.ViewFeatures Version=2.1.0.0 Culture=neutral PublicKeyToken=adb9793829ddae60'. The system cannot find the file specified.**.

I have tried 2 different possible solutions both of which are not working (hence my asking here for help):

1. Firstly I ensured all required assemblies were present by using `&lt;CopyLocalLockFileAssemblies&gt;true&lt;/CopyLocalLockFileAssemblies&gt;` so I know that all required assemblies are present in one location. This still results in the same thing: lots of **FileNotFoundException**s being thrown even though those assemblies are in fact present in the same location as the assemblies I am reading.

2. I then thought that perhaps there is some limitation in .NET Core requiring those assemblies to be loaded into the running app... so I iterated through all the assemblies and loaded them with `AppDomain.CurrentDomain.Load` and additionally I inspected the results from `AppDomain.CurrentDomain.GetAssemblies()` and confirmed that those assemblies were now in fact loaded into the running app... but unfortunately that also did not work... and exact the same errors were thrown.

So what do I do here?

I have extracted the important parts of the app I am writing and put them info a small demo project here: [LoadAssembliesProblem](https://github.com/gordon-matt/LoadAssembliesProblem)
&gt; **NOTE:** There are some comments in the **Program.cs** file as well.

Is this some kind of a bug or am I doing something wrong here?</Description>
    <Title_Description>FileNotFoundException being thrown for assemblies that are in fact present or even when loaded into AppDomain I have a small .NET Core app I am writing which reads all types from an assembly and the XML comments from the corresponding XML comments file. I am facing a problem with loads of **FileNotFoundException**s being thrown when a method constructor or whatever is using a type that comes from another assembly (example: `SelectList` from `Microsoft.AspNetCore.Mvc.ViewFeatures`). So when trying to get info from say a `RuntimeMethodInfo` it will throw an exception like: **Could not load file or assembly 'Microsoft.AspNetCore.Mvc.ViewFeatures Version=2.1.0.0 Culture=neutral PublicKeyToken=adb9793829ddae60'. The system cannot find the file specified.**.

I have tried 2 different possible solutions both of which are not working (hence my asking here for help):

1. Firstly I ensured all required assemblies were present by using `&lt;CopyLocalLockFileAssemblies&gt;true&lt;/CopyLocalLockFileAssemblies&gt;` so I know that all required assemblies are present in one location. This still results in the same thing: lots of **FileNotFoundException**s being thrown even though those assemblies are in fact present in the same location as the assemblies I am reading.

2. I then thought that perhaps there is some limitation in .NET Core requiring those assemblies to be loaded into the running app... so I iterated through all the assemblies and loaded them with `AppDomain.CurrentDomain.Load` and additionally I inspected the results from `AppDomain.CurrentDomain.GetAssemblies()` and confirmed that those assemblies were now in fact loaded into the running app... but unfortunately that also did not work... and exact the same errors were thrown.

So what do I do here?

I have extracted the important parts of the app I am writing and put them info a small demo project here: [LoadAssembliesProblem](https://github.com/gordon-matt/LoadAssembliesProblem)
&gt; **NOTE:** There are some comments in the **Program.cs** file as well.

Is this some kind of a bug or am I doing something wrong here?</Title_Description>
    <Label>area-AssemblyLoader</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>11/06/2018 12:56:45 PM +00:00</CreatedAt>
    <ClosedAt>12/06/2018 3:19:44 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18408</IssueLabelID>
    <Title>Bad codegen + Assertion failed 'varDsc-&gt;lvIsParam'</Title>
    <Description>Repro:

Compile with `/o+`:

```csharp
using System;
using System.Reflection;
using System.Threading;
using System.Runtime.CompilerServices;

class MetadataReader
{
    [MethodImpl(MethodImplOptions.NoInlining)]
    public Method GetMethod(MethodHandle handle)
    {
        throw null;
    }

}

struct Handle
{
    int _value;

    public MethodHandle ToMethodHandle(MetadataReader reader)
    {
        return new MethodHandle(this);
    }
}

static class MetadataReaderExtensions
{
    public static unsafe Handle AsHandle(this int token)
    {
        return *(Handle*)&amp;token;
    }
}

struct MethodHandle
{
    internal int _value;

    [MethodImpl(MethodImplOptions.NoInlining)]
    internal MethodHandle(Handle value)
    {
        throw null;
    }

    public Method GetMethod(MetadataReader reader)
    {
        return reader.GetMethod(this);
    }
}

struct Method
{
    internal MetadataReader _reader;
    internal MethodHandle _handle;
    internal MethodAttributes _flags;

    public MethodAttributes Flags =&gt; _flags;
}

struct QMethodDefinition
{
    private QMethodDefinition(MetadataReader reader int token)
    {
        _reader = reader;
        _handle = token;
    }

    public static QMethodDefinition FromObjectAndInt(MetadataReader reader int token)
    {
        return new QMethodDefinition(reader token);
    }

    public MetadataReader Reader { get { return _reader; } }
    public int Token { get { return _handle; } }

    public bool IsValid { get { return _reader == null; } }

    private readonly MetadataReader _reader;
    private readonly int _handle;

    public MetadataReader NativeFormatReader { get { return _reader; } }
    public MethodHandle NativeFormatHandle { get { return _handle.AsHandle().ToMethodHandle(NativeFormatReader); } }
}

class Test
{

    [MethodImpl(MethodImplOptions.NoInlining)]
    static object foo(QMethodDefinition methodHandle)
    {
        Method method = methodHandle.NativeFormatHandle.GetMethod(methodHandle.NativeFormatReader);

        return (method.Flags != (MethodAttributes)0) ? new object() : null;
    }

    static void Main()
    {
        foo(default(QMethodDefinition));
    }
}
```

Result:

On debug/checked Windows x64 build this fails with:

```

Assert failure(PID 26504 [0x00006788] Thread: 8952 [0x22f8]): Assertion failed 'varDsc-&gt;lvIsParam' in 'QMethodDefinition:get_NativeFormatHandle():struct:this' (IL size 26)

    File: c:\coreclr\src\jit\compiler.hpp Line: 2321
```</Description>
    <Title_Description>Bad codegen + Assertion failed 'varDsc-&gt;lvIsParam' Repro:

Compile with `/o+`:

```csharp
using System;
using System.Reflection;
using System.Threading;
using System.Runtime.CompilerServices;

class MetadataReader
{
    [MethodImpl(MethodImplOptions.NoInlining)]
    public Method GetMethod(MethodHandle handle)
    {
        throw null;
    }

}

struct Handle
{
    int _value;

    public MethodHandle ToMethodHandle(MetadataReader reader)
    {
        return new MethodHandle(this);
    }
}

static class MetadataReaderExtensions
{
    public static unsafe Handle AsHandle(this int token)
    {
        return *(Handle*)&amp;token;
    }
}

struct MethodHandle
{
    internal int _value;

    [MethodImpl(MethodImplOptions.NoInlining)]
    internal MethodHandle(Handle value)
    {
        throw null;
    }

    public Method GetMethod(MetadataReader reader)
    {
        return reader.GetMethod(this);
    }
}

struct Method
{
    internal MetadataReader _reader;
    internal MethodHandle _handle;
    internal MethodAttributes _flags;

    public MethodAttributes Flags =&gt; _flags;
}

struct QMethodDefinition
{
    private QMethodDefinition(MetadataReader reader int token)
    {
        _reader = reader;
        _handle = token;
    }

    public static QMethodDefinition FromObjectAndInt(MetadataReader reader int token)
    {
        return new QMethodDefinition(reader token);
    }

    public MetadataReader Reader { get { return _reader; } }
    public int Token { get { return _handle; } }

    public bool IsValid { get { return _reader == null; } }

    private readonly MetadataReader _reader;
    private readonly int _handle;

    public MetadataReader NativeFormatReader { get { return _reader; } }
    public MethodHandle NativeFormatHandle { get { return _handle.AsHandle().ToMethodHandle(NativeFormatReader); } }
}

class Test
{

    [MethodImpl(MethodImplOptions.NoInlining)]
    static object foo(QMethodDefinition methodHandle)
    {
        Method method = methodHandle.NativeFormatHandle.GetMethod(methodHandle.NativeFormatReader);

        return (method.Flags != (MethodAttributes)0) ? new object() : null;
    }

    static void Main()
    {
        foo(default(QMethodDefinition));
    }
}
```

Result:

On debug/checked Windows x64 build this fails with:

```

Assert failure(PID 26504 [0x00006788] Thread: 8952 [0x22f8]): Assertion failed 'varDsc-&gt;lvIsParam' in 'QMethodDefinition:get_NativeFormatHandle():struct:this' (IL size 26)

    File: c:\coreclr\src\jit\compiler.hpp Line: 2321
```</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18407</IssueLabelID>
    <Title>Move the HWIntrinsic Load/Store operations to use GenTreeIndir nodes</Title>
    <Description>Currently the x86 Hardware Intrinsics handle the load/store operations directly. This was done both for quick bring up and in order to easily represent the various new memory operation types.

However it would be ideal if we could merge this functionality back in with the normal Indir handling that already exists.

category:implementation
theme:vector-codegen
skill-level:expert
cost:extra-large</Description>
    <Title_Description>Move the HWIntrinsic Load/Store operations to use GenTreeIndir nodes Currently the x86 Hardware Intrinsics handle the load/store operations directly. This was done both for quick bring up and in order to easily represent the various new memory operation types.

However it would be ideal if we could merge this functionality back in with the normal Indir handling that already exists.

category:implementation
theme:vector-codegen
skill-level:expert
cost:extra-large</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>tannergooding</Assignee>
    <CreatedAt>11/06/2018 1:01:44 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18406</IssueLabelID>
    <Title>Inlining and explicit tail calls</Title>
    <Description>We should re-examine the logic the jit uses for inlining in the presence of explicit tail calls (calls with a `tail` prefix). Currently the jit won't inline any method that is explicitly tail called

https://github.com/dotnet/coreclr/blob/7e215941c8d6a68fa52f98bb8fd2a419d8a1ef5d/src/jit/importer.cpp#L18943-L18949

or any method that makes an explicit tail call:

https://github.com/dotnet/coreclr/blob/7e215941c8d6a68fa52f98bb8fd2a419d8a1ef5d/src/jit/flowgraph.cpp#L5434-L5442

Both of these should be allowed provided with reasonable checks (former: callee frame is not overly huge; latter: call site is in tail position).

category:cq
theme:tail-call
skill-level:intermediate
cost:medium</Description>
    <Title_Description>Inlining and explicit tail calls We should re-examine the logic the jit uses for inlining in the presence of explicit tail calls (calls with a `tail` prefix). Currently the jit won't inline any method that is explicitly tail called

https://github.com/dotnet/coreclr/blob/7e215941c8d6a68fa52f98bb8fd2a419d8a1ef5d/src/jit/importer.cpp#L18943-L18949

or any method that makes an explicit tail call:

https://github.com/dotnet/coreclr/blob/7e215941c8d6a68fa52f98bb8fd2a419d8a1ef5d/src/jit/flowgraph.cpp#L5434-L5442

Both of these should be allowed provided with reasonable checks (former: callee frame is not overly huge; latter: call site is in tail position).

category:cq
theme:tail-call
skill-level:intermediate
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
    <CreatedAt>10/06/2018 4:03:12 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18405</IssueLabelID>
    <Title>Transition from .Net Framework to Coreclr : Moving from GACed Dlls</Title>
    <Description>We are porting our SDK from .NET Framework to Coreclr.

As a platform we have SDK and runtime c# dlls. Most of them are nicely segregated. However the bridge library between SDK and Runtime: A.dll is GACed in .Net Framework. Apps from SDK version X can run on cluster version Y where Y &gt;=X. So we get latest (Y) version of Dlls A always on cluster’s platform.

Problem:
There are classes in sdk dlls like SDK_A.dll which inherit from types in A.dll. So before even Main method is called A.dll is searched and found in GAC in .Net Framework. Since there is no GAC in coreclr we get FileNotFoundException for A.dll in coreclr. 

What we have tried:
1. We have tried adding AssemblyResolver to load these A.dll from Runtime folder. That does not help as exception is thrown before any code (Program’s Main) is executed.
2. We have looked at `dotnet strore` but it looks more complicated than GAC and it seems it was not designed as cross platform GAC. For e.g. we can't ask users to run `dotnet publish` with specific `manifest.xml`. It breaks development and packaging workflow for many developers.

What are the guidelines for library and platform writers to move there Dlls from GAC when transitioning form .Net Framework to CoreClr?
</Description>
    <Title_Description>Transition from .Net Framework to Coreclr : Moving from GACed Dlls We are porting our SDK from .NET Framework to Coreclr.

As a platform we have SDK and runtime c# dlls. Most of them are nicely segregated. However the bridge library between SDK and Runtime: A.dll is GACed in .Net Framework. Apps from SDK version X can run on cluster version Y where Y &gt;=X. So we get latest (Y) version of Dlls A always on cluster’s platform.

Problem:
There are classes in sdk dlls like SDK_A.dll which inherit from types in A.dll. So before even Main method is called A.dll is searched and found in GAC in .Net Framework. Since there is no GAC in coreclr we get FileNotFoundException for A.dll in coreclr. 

What we have tried:
1. We have tried adding AssemblyResolver to load these A.dll from Runtime folder. That does not help as exception is thrown before any code (Program’s Main) is executed.
2. We have looked at `dotnet strore` but it looks more complicated than GAC and it seems it was not designed as cross platform GAC. For e.g. we can't ask users to run `dotnet publish` with specific `manifest.xml`. It breaks development and packaging workflow for many developers.

What are the guidelines for library and platform writers to move there Dlls from GAC when transitioning form .Net Framework to CoreClr?
</Title_Description>
    <Label>area-AssemblyLoader</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>10/06/2018 2:18:59 PM +00:00</CreatedAt>
    <ClosedAt>9/05/2019 2:55:30 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18404</IssueLabelID>
    <Title>Added CallerArgumentExpressionAttribute (corefx issue 21809)</Title>
    <Description>Adding System.Runtime.CompilerServices.CallerArgumentExpressionAttribute to System.Private.CoreLib for [CoreFX issue 21809](https://github.com/dotnet/corefx/issues/21809).

After this addition is reflected to the System.Private.CoreLib.dll then I will expose it from System.Runtime.dll in corefx. I believe this is the proper place to add this as all other CompilerServices attributes live here but if that is not the case then please let me know.

@karelz @danmosemsft</Description>
    <Title_Description>Added CallerArgumentExpressionAttribute (corefx issue 21809) Adding System.Runtime.CompilerServices.CallerArgumentExpressionAttribute to System.Private.CoreLib for [CoreFX issue 21809](https://github.com/dotnet/corefx/issues/21809).

After this addition is reflected to the System.Private.CoreLib.dll then I will expose it from System.Runtime.dll in corefx. I believe this is the proper place to add this as all other CompilerServices attributes live here but if that is not the case then please let me know.

@karelz @danmosemsft</Title_Description>
    <Label>Hackathon</Label>
    <Assignee>jswolf19</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18403</IssueLabelID>
    <Title>Associating threadpool queues with CPU cores.</Title>
    <Description>New implementation of ThreadPool work queues as lock-free queues softly associated with CPU cores.

The implementation avoids 1:1 strict mapping between work queues and working threads which is often a far greater number than the number of cores.

This implementation improves handling of cases where the number of workers needs to exceeds the number of cores. It avoids precipitous performance drops because:
- the cost of snooping/stealing does not grow with the number of workers.
- the local queues tend to be deeper (since there are fewer of them) and thus stealing is less frequent and less contentious with enqueuing/popping.
- blocking or preempting a worker does not result in its entire work queue be only accessible through stealing.
- reduced likelihood that the workitem will have to execute on a core different from where it was scheduled.

Fixes:#19088

Also may alleviate issues as described in http://labs.criteo.com/2018/10/net-threadpool-starvation-and-how-queuing-makes-it-worse/</Description>
    <Title_Description>Associating threadpool queues with CPU cores. New implementation of ThreadPool work queues as lock-free queues softly associated with CPU cores.

The implementation avoids 1:1 strict mapping between work queues and working threads which is often a far greater number than the number of cores.

This implementation improves handling of cases where the number of workers needs to exceeds the number of cores. It avoids precipitous performance drops because:
- the cost of snooping/stealing does not grow with the number of workers.
- the local queues tend to be deeper (since there are fewer of them) and thus stealing is less frequent and less contentious with enqueuing/popping.
- blocking or preempting a worker does not result in its entire work queue be only accessible through stealing.
- reduced likelihood that the workitem will have to execute on a core different from where it was scheduled.

Fixes:#19088

Also may alleviate issues as described in http://labs.criteo.com/2018/10/net-threadpool-starvation-and-how-queuing-makes-it-worse/</Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>VSadov</Assignee>
    <CreatedAt>10/06/2018 4:02:43 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18402</IssueLabelID>
    <Title>Removed length restrictions on named synchronization primitives lengths on Windows</Title>
    <Description>Fixes https://github.com/dotnet/coreclr/issues/18370
Tests PR :- https://github.com/dotnet/corefx/pull/30243

we're letting the API kick back names that are too long rather than pre-validating them.</Description>
    <Title_Description>Removed length restrictions on named synchronization primitives lengths on Windows Fixes https://github.com/dotnet/coreclr/issues/18370
Tests PR :- https://github.com/dotnet/corefx/pull/30243

we're letting the API kick back names that are too long rather than pre-validating them.</Title_Description>
    <Label>area-System.Threading</Label>
    <Assignee>Anipik</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18401</IssueLabelID>
    <Title>C# `in` parameter modifier: Should I be able to create a delegate for a method with non-matching signature?</Title>
    <Description>While working on Moq (https://github.com/moq/moq4/pull/625) I've run into something strange: It appears that the runtime does not match signatures properly when creating delegates through e.g. `MethodInfo.CreateDelegate`. It appears that custom modifiers aren't taken into account at all:

```csharp
using System;

public delegate void WithIn(in AttributeTargets arg);
//                          ^^
// C# compiler emits a required custom modifier (among other things; see IL below)

public interface IWithoutIn
{
    void Invoke(ref AttributeTargets arg);
    //          ^^^
    // no custom modifier here
}

public class WithoutIn : IWithoutIn
{
    public void Invoke(ref AttributeTargets arg)
    {
        Console.WriteLine($"Called with {arg}.");
    }
}

class Program
{
    static void Main()
    {
        var interfaceMethod = typeof(IWithoutIn).GetMethod("Invoke");
        var interfaceMethodViaDelegate = (WithIn)interfaceMethod.CreateDelegate(typeof(WithIn) new WithoutIn());
        interfaceMethodViaDelegate.Invoke(AttributeTargets.All);
    }
}
```

I can create a delegate with signature `void(in AttributeTargets)` for a method with signature `void(ref AttributeTargets)`. This doesn't seem right since the signatures differ by a required custom modifier. From ECMA-335 section 13.6 Delegates:

&gt; _"The `Invoke` method shall be virtual and have the same signature (return type parameter types calling convention **and modifiers** [...]) as the target method. When actually called the arguments passed shall match the types specified in this signature."_ (emphasis added by me)

Is this imprecise signature matching for delegates intentional or a bug?

&lt;details&gt;
&lt;summary&gt;(Expand to see the IL for `WithIn` and `IWithoutIn`)&lt;/summary&gt;

```
.class public auto ansi sealed WithIn extends [System.Runtime]System.MulticastDelegate
{
  // (ctor omitted)

  .method public hidebysig newslot virtual instance void Invoke(
    [in] valuetype [System.Runtime]System.AttributeTargets&amp; modreq([System.Runtime.InteropServices]System.Runtime.InteropServices.InAttribute) arg) runtime managed
  {
    .param [1]
    .custom instance void [System.Runtime]System.Runtime.CompilerServices.IsReadOnlyAttribute::.ctor() = ( 01 00 00 00 ) 
  }

  // (BeginInvoke and EndInvoke omitted)
}

.class interface public abstract auto ansi IWithoutIn
{
  .method public hidebysig newslot abstract virtual instance void Invoke(
    valuetype [System.Runtime]System.AttributeTargets&amp; arg) cil managed
  {
  }
}
```
&lt;/details&gt;
&lt;br&gt;

/cc @zvirja</Description>
    <Title_Description>C# `in` parameter modifier: Should I be able to create a delegate for a method with non-matching signature? While working on Moq (https://github.com/moq/moq4/pull/625) I've run into something strange: It appears that the runtime does not match signatures properly when creating delegates through e.g. `MethodInfo.CreateDelegate`. It appears that custom modifiers aren't taken into account at all:

```csharp
using System;

public delegate void WithIn(in AttributeTargets arg);
//                          ^^
// C# compiler emits a required custom modifier (among other things; see IL below)

public interface IWithoutIn
{
    void Invoke(ref AttributeTargets arg);
    //          ^^^
    // no custom modifier here
}

public class WithoutIn : IWithoutIn
{
    public void Invoke(ref AttributeTargets arg)
    {
        Console.WriteLine($"Called with {arg}.");
    }
}

class Program
{
    static void Main()
    {
        var interfaceMethod = typeof(IWithoutIn).GetMethod("Invoke");
        var interfaceMethodViaDelegate = (WithIn)interfaceMethod.CreateDelegate(typeof(WithIn) new WithoutIn());
        interfaceMethodViaDelegate.Invoke(AttributeTargets.All);
    }
}
```

I can create a delegate with signature `void(in AttributeTargets)` for a method with signature `void(ref AttributeTargets)`. This doesn't seem right since the signatures differ by a required custom modifier. From ECMA-335 section 13.6 Delegates:

&gt; _"The `Invoke` method shall be virtual and have the same signature (return type parameter types calling convention **and modifiers** [...]) as the target method. When actually called the arguments passed shall match the types specified in this signature."_ (emphasis added by me)

Is this imprecise signature matching for delegates intentional or a bug?

&lt;details&gt;
&lt;summary&gt;(Expand to see the IL for `WithIn` and `IWithoutIn`)&lt;/summary&gt;

```
.class public auto ansi sealed WithIn extends [System.Runtime]System.MulticastDelegate
{
  // (ctor omitted)

  .method public hidebysig newslot virtual instance void Invoke(
    [in] valuetype [System.Runtime]System.AttributeTargets&amp; modreq([System.Runtime.InteropServices]System.Runtime.InteropServices.InAttribute) arg) runtime managed
  {
    .param [1]
    .custom instance void [System.Runtime]System.Runtime.CompilerServices.IsReadOnlyAttribute::.ctor() = ( 01 00 00 00 ) 
  }

  // (BeginInvoke and EndInvoke omitted)
}

.class interface public abstract auto ansi IWithoutIn
{
  .method public hidebysig newslot abstract virtual instance void Invoke(
    valuetype [System.Runtime]System.AttributeTargets&amp; arg) cil managed
  {
  }
}
```
&lt;/details&gt;
&lt;br&gt;

/cc @zvirja</Title_Description>
    <Label>area-System.Reflection</Label>
    <Assignee>stakx</Assignee>
    <CreatedAt>9/06/2018 6:33:28 PM +00:00</CreatedAt>
    <ClosedAt>11/06/2018 10:38:07 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18400</IssueLabelID>
    <Title>Optimize placement of VZEROUPPER</Title>
    <Description>Which rules CLR JIT uses to place VZEROUPPER and how do I opt-out ?

The live example is - one flavor of distribution sorting algorithm uses insertion sort subroutine for basic case sorting of small buckets and it gets called quite often esp. for of 2- and 3-record cases.  The insertion sort subroutine itself is highly optimized - it uses SIMD registers (XMMs in my case) HW intrinsics and just basic RSP-based stack frame for couple values. Still VZEROUPPER is generated at the beginning and at the end of subroutine which adds some perfmormance hit. There is natural desire to avoid such penalty knowing that caller will always be other CLR JITted code and all nested method invocations are inlined (checked this manually).

category:cq
theme:vector-codegen
skill-level:expert
cost:medium</Description>
    <Title_Description>Optimize placement of VZEROUPPER Which rules CLR JIT uses to place VZEROUPPER and how do I opt-out ?

The live example is - one flavor of distribution sorting algorithm uses insertion sort subroutine for basic case sorting of small buckets and it gets called quite often esp. for of 2- and 3-record cases.  The insertion sort subroutine itself is highly optimized - it uses SIMD registers (XMMs in my case) HW intrinsics and just basic RSP-based stack frame for couple values. Still VZEROUPPER is generated at the beginning and at the end of subroutine which adds some perfmormance hit. There is natural desire to avoid such penalty knowing that caller will always be other CLR JITted code and all nested method invocations are inlined (checked this manually).

category:cq
theme:vector-codegen
skill-level:expert
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>9/06/2018 11:15:27 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18399</IssueLabelID>
    <Title>StringBuidler  support Offset(int length)</Title>
    <Description>New API:
```C#
//
public void Offset(int length){
   if(length&lt;0)
   {
       // throw........   
   }
   if(length&gt;count){
       // alloc more space
   }else{ 
      // reset the offset
       m_ChunkLength=length;
   }
}
```

Use:
```C#
StringBuilder builder = new StringBuilder();
for(int i=0;i&lt;10;i+=1)
{
    builder.Append(array[i]);
    builder.Append('');
}
builder.Offset(builder.length-1);
builder.Append(others);

```</Description>
    <Title_Description>StringBuidler  support Offset(int length) New API:
```C#
//
public void Offset(int length){
   if(length&lt;0)
   {
       // throw........   
   }
   if(length&gt;count){
       // alloc more space
   }else{ 
      // reset the offset
       m_ChunkLength=length;
   }
}
```

Use:
```C#
StringBuilder builder = new StringBuilder();
for(int i=0;i&lt;10;i+=1)
{
    builder.Append(array[i]);
    builder.Append('');
}
builder.Offset(builder.length-1);
builder.Append(others);

```</Title_Description>
    <Label>question</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>9/06/2018 8:20:03 AM +00:00</CreatedAt>
    <ClosedAt>10/06/2018 3:57:13 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18396</IssueLabelID>
    <Title>Build fails when using enable sanitizers script</Title>
    <Description>Disclaimer:  The reason I am trying to do this is so I can run an ASAN enabled native library that I heavily use with P/Invoke.  However it seems if I don't compile coreclr with the same ASAN enabled the arguments from C# get turned into garbage on their way into C++.  If this should not the case then please inform me.

Building against the v2.1.0 tag

I'm running following the instructions I found [here](https://github.com/dotnet/coreclr/blob/master/Documentation/building/linux-instructions.md) verbatim in an ubuntu:14.04 docker container.  The build succeeds using `build.sh debug skiptests clang3.9` but then when I run `. enablesanitizers.sh asan clang3.9` the same build invocation fails with the following:

```
/usr/bin/ld: /usr/lib/llvm-3.9/bin/../lib/clang/3.9.1/lib/linux/libclang_rt.asan-x86_64.a(asan_allocator.cc.o): unrecognized relocation (0x2a) in section `.text'
/usr/bin/ld: final link failed: Bad value
clang: error: linker command failed with exit code 1 (use -v to see invocation)
make[2]: *** [src/coreclr/hosts/unixcorerun/corerun] Error 1
make[1]: *** [src/coreclr/hosts/unixcorerun/CMakeFiles/corerun.dir/all] Error 2
```

(Similar error for coreconsole)</Description>
    <Title_Description>Build fails when using enable sanitizers script Disclaimer:  The reason I am trying to do this is so I can run an ASAN enabled native library that I heavily use with P/Invoke.  However it seems if I don't compile coreclr with the same ASAN enabled the arguments from C# get turned into garbage on their way into C++.  If this should not the case then please inform me.

Building against the v2.1.0 tag

I'm running following the instructions I found [here](https://github.com/dotnet/coreclr/blob/master/Documentation/building/linux-instructions.md) verbatim in an ubuntu:14.04 docker container.  The build succeeds using `build.sh debug skiptests clang3.9` but then when I run `. enablesanitizers.sh asan clang3.9` the same build invocation fails with the following:

```
/usr/bin/ld: /usr/lib/llvm-3.9/bin/../lib/clang/3.9.1/lib/linux/libclang_rt.asan-x86_64.a(asan_allocator.cc.o): unrecognized relocation (0x2a) in section `.text'
/usr/bin/ld: final link failed: Bad value
clang: error: linker command failed with exit code 1 (use -v to see invocation)
make[2]: *** [src/coreclr/hosts/unixcorerun/corerun] Error 1
make[1]: *** [src/coreclr/hosts/unixcorerun/CMakeFiles/corerun.dir/all] Error 2
```

(Similar error for coreconsole)</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>9/06/2018 5:44:12 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18389</IssueLabelID>
    <Title>Fix fragility in setup-stress-dependencies infra</Title>
    <Description>E.g. https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_checked_ubuntu_innerloop_tst_prtest/3663/consoleText

```
Downloading CoreDisTools package
+ /mnt/j/workspace/dotnet_coreclr/master/x64_checked_ubuntu_innerloop_tst_prtest/tests/../Tools/dotnetcli/dotnet restore /mnt/j/workspace/dotnet_coreclr/master/x64_checked_ubuntu_innerloop_tst_prtest/tests/src/Common/stress_dependencies/stress_dependencies.csproj --source https://dotnet.myget.org/F/dotnet-core/ --packages /mnt/j/workspace/dotnet_coreclr/master/x64_checked_ubuntu_innerloop_tst_prtest/tests/../packages
  Restoring packages for /mnt/j/workspace/dotnet_coreclr/master/x64_checked_ubuntu_innerloop_tst_prtest/tests/src/Common/stress_dependencies/stress_dependencies.csproj...
  Installing Microsoft.NETCore.CoreDisTools 1.0.1-prerelease-00003.
  Generating MSBuild file /mnt/j/workspace/dotnet_coreclr/master/x64_checked_ubuntu_innerloop_tst_prtest/tests/src/Common/stress_dependencies/obj/stress_dependencies.csproj.nuget.g.props.
  Generating MSBuild file /mnt/j/workspace/dotnet_coreclr/master/x64_checked_ubuntu_innerloop_tst_prtest/tests/src/Common/stress_dependencies/obj/stress_dependencies.csproj.nuget.g.targets.
  Restore completed in 1.84 sec for /mnt/j/workspace/dotnet_coreclr/master/x64_checked_ubuntu_innerloop_tst_prtest/tests/src/Common/stress_dependencies/stress_dependencies.csproj.
Copy library: --&gt; /mnt/j/workspace/dotnet_coreclr/master/x64_checked_ubuntu_innerloop_tst_prtest/bin/tests/Linux.x64.Checked/Tests/Core_Root/
cp: missing destination file operand after ‘/mnt/j/workspace/dotnet_coreclr/master/x64_checked_ubuntu_innerloop_tst_prtest/bin/tests/Linux.x64.Checked/Tests/Core_Root’
Try 'cp --help' for more information.
Failed to copy the library
```
</Description>
    <Title_Description>Fix fragility in setup-stress-dependencies infra E.g. https://ci.dot.net/job/dotnet_coreclr/job/master/job/x64_checked_ubuntu_innerloop_tst_prtest/3663/consoleText

```
Downloading CoreDisTools package
+ /mnt/j/workspace/dotnet_coreclr/master/x64_checked_ubuntu_innerloop_tst_prtest/tests/../Tools/dotnetcli/dotnet restore /mnt/j/workspace/dotnet_coreclr/master/x64_checked_ubuntu_innerloop_tst_prtest/tests/src/Common/stress_dependencies/stress_dependencies.csproj --source https://dotnet.myget.org/F/dotnet-core/ --packages /mnt/j/workspace/dotnet_coreclr/master/x64_checked_ubuntu_innerloop_tst_prtest/tests/../packages
  Restoring packages for /mnt/j/workspace/dotnet_coreclr/master/x64_checked_ubuntu_innerloop_tst_prtest/tests/src/Common/stress_dependencies/stress_dependencies.csproj...
  Installing Microsoft.NETCore.CoreDisTools 1.0.1-prerelease-00003.
  Generating MSBuild file /mnt/j/workspace/dotnet_coreclr/master/x64_checked_ubuntu_innerloop_tst_prtest/tests/src/Common/stress_dependencies/obj/stress_dependencies.csproj.nuget.g.props.
  Generating MSBuild file /mnt/j/workspace/dotnet_coreclr/master/x64_checked_ubuntu_innerloop_tst_prtest/tests/src/Common/stress_dependencies/obj/stress_dependencies.csproj.nuget.g.targets.
  Restore completed in 1.84 sec for /mnt/j/workspace/dotnet_coreclr/master/x64_checked_ubuntu_innerloop_tst_prtest/tests/src/Common/stress_dependencies/stress_dependencies.csproj.
Copy library: --&gt; /mnt/j/workspace/dotnet_coreclr/master/x64_checked_ubuntu_innerloop_tst_prtest/bin/tests/Linux.x64.Checked/Tests/Core_Root/
cp: missing destination file operand after ‘/mnt/j/workspace/dotnet_coreclr/master/x64_checked_ubuntu_innerloop_tst_prtest/bin/tests/Linux.x64.Checked/Tests/Core_Root’
Try 'cp --help' for more information.
Failed to copy the library
```
</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>9/06/2018 12:24:14 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18387</IssueLabelID>
    <Title>Fix UTF8 encoding fallback index</Title>
    <Description>When falling back in UTF8 decoding we’ll call the DecoderFallbackBuffer.InternalFallback method which takes a pointer to the source bytes pointer which points to where we have progressed inside the source bytes. The problem is before calling DecoderFallbackBuffer.InternalFallback we call GetBytesUnknown which can adjust the source byte pointer and DecoderFallbackBuffer.InternalFallback needs to be called with the pointer before the adjustment. The fix is simply storing the original pointer value of the source byte pointer before calling GetBytesUnknown and then pass the stored original pointer to DecoderFallbackBuffer.InternalFallback instead of the adjusted source byte pointer

Fixes https://github.com/dotnet/corefx/issues/29898</Description>
    <Title_Description>Fix UTF8 encoding fallback index When falling back in UTF8 decoding we’ll call the DecoderFallbackBuffer.InternalFallback method which takes a pointer to the source bytes pointer which points to where we have progressed inside the source bytes. The problem is before calling DecoderFallbackBuffer.InternalFallback we call GetBytesUnknown which can adjust the source byte pointer and DecoderFallbackBuffer.InternalFallback needs to be called with the pointer before the adjustment. The fix is simply storing the original pointer value of the source byte pointer before calling GetBytesUnknown and then pass the stored original pointer to DecoderFallbackBuffer.InternalFallback instead of the adjusted source byte pointer

Fixes https://github.com/dotnet/corefx/issues/29898</Title_Description>
    <Label>
    </Label>
    <Assignee>tarekgh</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18386</IssueLabelID>
    <Title>GC Heap Compaction should clear the source data</Title>
    <Description>During GC heap compaction a copy of data is made.  In cases where there was no practical way to pin data (e.g. a returned `byte[]`) it isn't possible to ensure that the data has been adequately cleared because of the extra copy created compaction.

Having the GC clear the memory on compaction improve the security of applications for which heap dumps and in-memory probes are within their scope of threat given some guidelines:
* A secret allocated to a caller is the caller's responsibility to clear (e.g. RSA.Decrypt).
  * Current: Returned objects can't be pinned in a practical manner API would have to also emit a GCHandle.
* A secret held by an IDisposable object should be cleared on Dispose and it is the owner's responsibility to call Dispose (e.g. KeyedHashAlgorithm)
  * Current: existing classes which have `byte[]` fields would need to use GCHandle and add a finalizer to ensure that the handle got cleared.
* A temporary copy of a secret must be cleared by the creator/owner (e.g. addition/removal of symmetric encryption padding)

If the GC can guarantee that pinning is no longer required to ensure that Span.Clear() removes the data from the heap then a good amount of defensive pinning can be eliminated from current BCL security code (theoretically reducing heap fragmentation?).</Description>
    <Title_Description>GC Heap Compaction should clear the source data During GC heap compaction a copy of data is made.  In cases where there was no practical way to pin data (e.g. a returned `byte[]`) it isn't possible to ensure that the data has been adequately cleared because of the extra copy created compaction.

Having the GC clear the memory on compaction improve the security of applications for which heap dumps and in-memory probes are within their scope of threat given some guidelines:
* A secret allocated to a caller is the caller's responsibility to clear (e.g. RSA.Decrypt).
  * Current: Returned objects can't be pinned in a practical manner API would have to also emit a GCHandle.
* A secret held by an IDisposable object should be cleared on Dispose and it is the owner's responsibility to call Dispose (e.g. KeyedHashAlgorithm)
  * Current: existing classes which have `byte[]` fields would need to use GCHandle and add a finalizer to ensure that the handle got cleared.
* A temporary copy of a secret must be cleared by the creator/owner (e.g. addition/removal of symmetric encryption padding)

If the GC can guarantee that pinning is no longer required to ensure that Span.Clear() removes the data from the heap then a good amount of defensive pinning can be eliminated from current BCL security code (theoretically reducing heap fragmentation?).</Title_Description>
    <Label>area-GC</Label>
    <Assignee>Maoni0</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18384</IssueLabelID>
    <Title>[release/2.1] JIT: Fix bug in finally cloning caused by unsound callfinally reordering</Title>
    <Description>Port of #18348 to release 2.1.

Related issue #18332. Not a regression. This optimization was introduced
in 2.0 and the bug has been there from the beginning.

We need to make sure that if we reorder a callfinally during finally cloning
that the callfinally is actually the one being targeted by the last block in
the try range.

Linked issue has some more detailed notes.</Description>
    <Title_Description>[release/2.1] JIT: Fix bug in finally cloning caused by unsound callfinally reordering Port of #18348 to release 2.1.

Related issue #18332. Not a regression. This optimization was introduced
in 2.0 and the bug has been there from the beginning.

We need to make sure that if we reorder a callfinally during finally cloning
that the callfinally is actually the one being targeted by the last block in
the try range.

Linked issue has some more detailed notes.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18381</IssueLabelID>
    <Title>One CoreCLR 2.1 unit test is failing due to missing ThreadStartBool.sh file</Title>
    <Description>Hi

CoreCLR 2.1 unit tests are failing due to missing ThreadStartBool.sh file

&gt; How to reproduce:
&gt; 
&gt; Build the repos and the tests (release/2.1 branch)
&gt; - ./build.sh x64 release msbuildonunsupportedplatform
&gt; - ./build-test.sh release
&gt; 
&gt; Running the tests:
&gt; - tests/runtest.sh --testRootDir=/build/coreclr/bin/tests/Linux.x64.Release --testNativeBinDir=/build/coreclr/bin/obj/Linux.x64.Release/tests --coreClrBinDir=/build/coreclr/bin/Product/Linux.x64.Release --mscorlibDir=/build/coreclr/bin/Product/Linux.x64.Release --coreFxBinDir=/build/corefx/bin/runtime/netcoreapp-Linux-Release-x64

```
21:56:33 # Tests Discovered : 2428
21:56:33 # Passed : 2373
21:56:33 # Failed : 1
21:56:33 # Skipped : 54

21:55:27 FAILED - baseservices/threading/paramthreadstart/ThreadStartBool_1/ThreadStartBool_1.sh
21:55:27 BEGIN EXECUTION
21:55:27 export CDPATH=.
21:55:27 /bin/sh -c /build/coreclr/tests/bin/tests/Linux.x64.Release/baseservices/threading/paramthreadstart/ThreadStartBool/ThreadStartBool.sh
21:55:27/bin/sh: /build/coreclr/tests/bin/tests/Linux.x64.Release/baseservices/threading/paramthreadstart/ThreadStartBool/ThreadStartBool.sh: No such file or directory
21:55:27 Expected: 0
21:55:27 Actual: 127
21:55:27 END EXECUTION - FAILED
```


Current fix I am using:

```
cp -r --parents ./bin/tests/Linux.x64.Release/baseservices/threading/paramthreadstart/ThreadStartBool tests
chmod 755 ./tests/bin/tests/Linux.x64.Release/baseservices/threading/paramthreadstart/ThreadStartBool/ThreadStartBool.sh
```

Hamza.</Description>
    <Title_Description>One CoreCLR 2.1 unit test is failing due to missing ThreadStartBool.sh file Hi

CoreCLR 2.1 unit tests are failing due to missing ThreadStartBool.sh file

&gt; How to reproduce:
&gt; 
&gt; Build the repos and the tests (release/2.1 branch)
&gt; - ./build.sh x64 release msbuildonunsupportedplatform
&gt; - ./build-test.sh release
&gt; 
&gt; Running the tests:
&gt; - tests/runtest.sh --testRootDir=/build/coreclr/bin/tests/Linux.x64.Release --testNativeBinDir=/build/coreclr/bin/obj/Linux.x64.Release/tests --coreClrBinDir=/build/coreclr/bin/Product/Linux.x64.Release --mscorlibDir=/build/coreclr/bin/Product/Linux.x64.Release --coreFxBinDir=/build/corefx/bin/runtime/netcoreapp-Linux-Release-x64

```
21:56:33 # Tests Discovered : 2428
21:56:33 # Passed : 2373
21:56:33 # Failed : 1
21:56:33 # Skipped : 54

21:55:27 FAILED - baseservices/threading/paramthreadstart/ThreadStartBool_1/ThreadStartBool_1.sh
21:55:27 BEGIN EXECUTION
21:55:27 export CDPATH=.
21:55:27 /bin/sh -c /build/coreclr/tests/bin/tests/Linux.x64.Release/baseservices/threading/paramthreadstart/ThreadStartBool/ThreadStartBool.sh
21:55:27/bin/sh: /build/coreclr/tests/bin/tests/Linux.x64.Release/baseservices/threading/paramthreadstart/ThreadStartBool/ThreadStartBool.sh: No such file or directory
21:55:27 Expected: 0
21:55:27 Actual: 127
21:55:27 END EXECUTION - FAILED
```


Current fix I am using:

```
cp -r --parents ./bin/tests/Linux.x64.Release/baseservices/threading/paramthreadstart/ThreadStartBool tests
chmod 755 ./tests/bin/tests/Linux.x64.Release/baseservices/threading/paramthreadstart/ThreadStartBool/ThreadStartBool.sh
```

Hamza.</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>RussKeldorph</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18377</IssueLabelID>
    <Title>Initial thoughts on Native Vararg support on Unix platforms for RyuJit</Title>
    <Description>PR #18373 will re-enable __arglist (native vararg support) for coreclr; however currently only Windows platforms support the ABI. This "issue" is more of a brain dump to help any future work to allow native varargs on other currently unsupported/untested platforms. It is platform and arch specific if there are gaps in my familiarity with other platform's/arch's ABIs please let me know I will update the issue.

#
#### Unix Amd64
x64 Unix should only require using RAX to pass the number of floating point arguments passed in registers for setting up the caller function. Change the prolog to spill all the General purpose registers and FP registers. ArgIterator would need to get the next arg based on type from the stack offset.

#
#### Unix Arm64
Currently there are a fair amount of example of where we mangle the vararg type for all arm arches. See https://github.com/dotnet/coreclr/blob/master/src/jit/compiler.hpp#L2607. This and other instances of forcing the argument types away from floating point types such as https://github.com/dotnet/coreclr/blob/master/src/jit/morph.cpp#L3322 need to also be restricted to windows. In addition the prolog ([here](https://github.com/dotnet/coreclr/blob/master/src/jit/codegencommon.cpp#L3302) also assumes all arguments are passing in the general purpose registers. 

#
#### Unix arm32
Everything for Unix arm64 applies. The only difference I can see is that non-fixed args (args in the ... varargs) that are TYP_FLOAT will need to be retyped and used as if they were TYP_DOUBLE. This will require annotating the arguments with new additional information isFixedArg.

#
#### Windows arm32
This is the same ABI as arm64 varargs. Investigation needs to be done to determine if back-filling is supported.

category:reach
theme:varargs
skill-level:expert
cost:medium</Description>
    <Title_Description>Initial thoughts on Native Vararg support on Unix platforms for RyuJit PR #18373 will re-enable __arglist (native vararg support) for coreclr; however currently only Windows platforms support the ABI. This "issue" is more of a brain dump to help any future work to allow native varargs on other currently unsupported/untested platforms. It is platform and arch specific if there are gaps in my familiarity with other platform's/arch's ABIs please let me know I will update the issue.

#
#### Unix Amd64
x64 Unix should only require using RAX to pass the number of floating point arguments passed in registers for setting up the caller function. Change the prolog to spill all the General purpose registers and FP registers. ArgIterator would need to get the next arg based on type from the stack offset.

#
#### Unix Arm64
Currently there are a fair amount of example of where we mangle the vararg type for all arm arches. See https://github.com/dotnet/coreclr/blob/master/src/jit/compiler.hpp#L2607. This and other instances of forcing the argument types away from floating point types such as https://github.com/dotnet/coreclr/blob/master/src/jit/morph.cpp#L3322 need to also be restricted to windows. In addition the prolog ([here](https://github.com/dotnet/coreclr/blob/master/src/jit/codegencommon.cpp#L3302) also assumes all arguments are passing in the general purpose registers. 

#
#### Unix arm32
Everything for Unix arm64 applies. The only difference I can see is that non-fixed args (args in the ... varargs) that are TYP_FLOAT will need to be retyped and used as if they were TYP_DOUBLE. This will require annotating the arguments with new additional information isFixedArg.

#
#### Windows arm32
This is the same ABI as arm64 varargs. Investigation needs to be done to determine if back-filling is supported.

category:reach
theme:varargs
skill-level:expert
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>jashook</Assignee>
    <CreatedAt>8/06/2018 6:33:21 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18375</IssueLabelID>
    <Title>Enable versioning bubbles that span multiple assemblies</Title>
    <Description>The concept of versioning bubbles is described in https://github.com/dotnet/coreclr/blob/master/Documentation/botr/readytorun-overview.md#version-bubbles

The current implementation is hardcoded to each assembly being its own versioning bubble. This issue is about adding an option for larger versioning bubbles:

- [ ] Add command line option to crossgen to allow specifying versioning bubbles
- [ ] Update `IsInSameVersionBubble` to respect this
- [ ] Record MVIDs of assemblies participating in the version bubble in R2R image
- [ ] Add enforcement to assembly loader to detect version bubble mismatches using MVIDs stored in the R2R images. This is important for a good diagnostic of mistakes when the assembly within version bubble is accidentally replaced by a different one.
- [ ] Use def tokens and module references within the version bubble (look for `ZapImportTable::TryEncodeModule). This is required to allow cross-module inlining of non-leaf methods within the version bubble.</Description>
    <Title_Description>Enable versioning bubbles that span multiple assemblies The concept of versioning bubbles is described in https://github.com/dotnet/coreclr/blob/master/Documentation/botr/readytorun-overview.md#version-bubbles

The current implementation is hardcoded to each assembly being its own versioning bubble. This issue is about adding an option for larger versioning bubbles:

- [ ] Add command line option to crossgen to allow specifying versioning bubbles
- [ ] Update `IsInSameVersionBubble` to respect this
- [ ] Record MVIDs of assemblies participating in the version bubble in R2R image
- [ ] Add enforcement to assembly loader to detect version bubble mismatches using MVIDs stored in the R2R images. This is important for a good diagnostic of mistakes when the assembly within version bubble is accidentally replaced by a different one.
- [ ] Use def tokens and module references within the version bubble (look for `ZapImportTable::TryEncodeModule). This is required to allow cross-module inlining of non-leaf methods within the version bubble.</Title_Description>
    <Label>area-ReadyToRun</Label>
    <Assignee>janvorli</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18374</IssueLabelID>
    <Title>Fix coredistools download script now that Packages layout has changed</Title>
    <Description>Fixes #18321</Description>
    <Title_Description>Fix coredistools download script now that Packages layout has changed Fixes #18321</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>dotnet-bot</Assignee>
    <CreatedAt>8/06/2018 6:01:03 PM +00:00</CreatedAt>
    <ClosedAt>8/06/2018 10:27:20 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18371</IssueLabelID>
    <Title>Large Page Support in memory allocated by the GC</Title>
    <Description>Large Pages (a.k.a Huge Pages on Linux) is a feature where the operating system is able to establish memory regions larger than the native page size (often 4K) to improve performance of the application requesting these large pages.

When a virtual-to-physical address translation occurs a cache called the `
Translation lookaside buffer` (TLB) is first consulted (often in parallel) to check if a physical translation for the virtual address being accessed is available to avoid doing a page-table walk which can be expensive.

A 4GB virtual address space is made up of 1048576 4K virtual pages. It could also be thought of to be represented as 2048 2MB virtual pages. Most modern os and cpus can operate on 4K or larger page sizes (2MB/4MB/1GB in x86_64).

On Windows `VirtualAlloc` must be called with `MEM_RESERVE | MEM_COMMIT | MEM_LARGE_PAGES` for the `flAllocationType` parameter. It is also required that process acquire the `SeLockMemoryPrivilege` privelege. Large Pages can also significantly increase the chance of a memory allocation failure because now the OS has to find physically contiguous memory.

What this means for coreclr and the GC is that when the GC does a VirtualReserve at the beginning of the program it must now commit this memory as well.</Description>
    <Title_Description>Large Page Support in memory allocated by the GC Large Pages (a.k.a Huge Pages on Linux) is a feature where the operating system is able to establish memory regions larger than the native page size (often 4K) to improve performance of the application requesting these large pages.

When a virtual-to-physical address translation occurs a cache called the `
Translation lookaside buffer` (TLB) is first consulted (often in parallel) to check if a physical translation for the virtual address being accessed is available to avoid doing a page-table walk which can be expensive.

A 4GB virtual address space is made up of 1048576 4K virtual pages. It could also be thought of to be represented as 2048 2MB virtual pages. Most modern os and cpus can operate on 4K or larger page sizes (2MB/4MB/1GB in x86_64).

On Windows `VirtualAlloc` must be called with `MEM_RESERVE | MEM_COMMIT | MEM_LARGE_PAGES` for the `flAllocationType` parameter. It is also required that process acquire the `SeLockMemoryPrivilege` privelege. Large Pages can also significantly increase the chance of a memory allocation failure because now the OS has to find physically contiguous memory.

What this means for coreclr and the GC is that when the GC does a VirtualReserve at the beginning of the program it must now commit this memory as well.</Title_Description>
    <Label>area-GC</Label>
    <Assignee>Maoni0</Assignee>
    <CreatedAt>8/06/2018 4:31:57 PM +00:00</CreatedAt>
    <ClosedAt>8/04/2019 8:48:21 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18370</IssueLabelID>
    <Title>Remove length restrictions on named synchronization primitives lengths on Windows</Title>
    <Description>From https://github.com/dotnet/coreclr/pull/18320#issuecomment-395603647

If the OS allows creating mutex with the long name we should allow it too. We are just getting into way by blocking the longer names for no good reason.</Description>
    <Title_Description>Remove length restrictions on named synchronization primitives lengths on Windows From https://github.com/dotnet/coreclr/pull/18320#issuecomment-395603647

If the OS allows creating mutex with the long name we should allow it too. We are just getting into way by blocking the longer names for no good reason.</Title_Description>
    <Label>area-System.Threading</Label>
    <Assignee>Anipik</Assignee>
    <CreatedAt>8/06/2018 3:45:41 PM +00:00</CreatedAt>
    <ClosedAt>11/06/2018 2:29:59 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18367</IssueLabelID>
    <Title>[Regression] Assertion failed 'mask != RBM_NONE'</Title>
    <Description>`jit\regset.cpp (120) - Assertion failed 'mask != RBM_NONE'`
The regression was introduced by #18230.

cc @dotnet/jit-contrib </Description>
    <Title_Description>[Regression] Assertion failed 'mask != RBM_NONE' `jit\regset.cpp (120) - Assertion failed 'mask != RBM_NONE'`
The regression was introduced by #18230.

cc @dotnet/jit-contrib </Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>sandreenko</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18362</IssueLabelID>
    <Title>[Windows/arm][JitStress] Assertion failed 'defList.IsEmpty()' in System.Numerics.Tests.ComplexTests:Conjugate</Title>
    <Description>Hit this is in PR #18347 during [Windows_NT arm Cross Checked corefx_jitstress1 Build and Test](https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_windows_nt_corefx_jitstress1_tst_prtest/3/consoleText) and [Windows_NT arm Cross Checked corefx_jitstress2 Build and Test](https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_windows_nt_corefx_jitstress2_tst_prtest/3/consoleText)

```
===========================================================================================================

C:\Users\robox\j\workspace\arm_cross_che---953a3c02\_\fx\bin\tests\System.Runtime.Numerics.Tests\netcoreapp-Windows_NT-Release-arm&gt;set COMPlus_JitStress=1 

C:\Users\robox\j\workspace\arm_cross_che---953a3c02\_\fx\bin\tests\System.Runtime.Numerics.Tests\netcoreapp-Windows_NT-Release-arm&gt;call C:\Users\robox\j\workspace\arm_cross_che---953a3c02\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm\dotnet.exe xunit.console.netcore.exe System.Runtime.Numerics.Tests.dll  -xml testResults.xml -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonwindowstests  -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing 
xUnit.net console test runner (32-bit .NET Core)
Copyright (C) 2014 Outercurve Foundation.

Discovering: System.Runtime.Numerics.Tests
Discovered:  System.Runtime.Numerics.Tests
Starting:    System.Runtime.Numerics.Tests

Assert failure(PID 3720 [0x00000e88] Thread: 9524 [0x2534]): Assertion failed 'defList.IsEmpty()' in 'System.Numerics.Tests.ComplexTests:Conjugate(doubledouble)' (IL size 57)

    File: d:\j\workspace\arm_cross_che---23cdb046\src\jit\lsrabuild.cpp Line: 2094
    Image: C:\Users\robox\j\workspace\arm_cross_che---953a3c02\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm\dotnet.exe

----- end 12:25:03.32 ----- exit code 123456789 ----------------------------------------------------------
COREFX TEST FAILED
Running: C:\Users\robox\j\workspace\arm_cross_che---953a3c02\_\fx\bin\tests\System.Runtime.Performance.Tests\netcoreapp-Windows_NT-Release-arm\RunTests.cmd C:\Users\robox\j\workspace\arm_cross_che---953a3c02\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm
Using C:\Users\robox\j\workspace\arm_cross_che---953a3c02\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm as the test runtime folder.
Executing in C:\Users\robox\j\workspace\arm_cross_che---953a3c02\_\fx\bin\tests\System.Runtime.Performance.Tests\netcoreapp-Windows_NT-Release-arm\ 
----- start 12:25:03.43 ===============  To repro directly: ===================================================== 
```

```
===========================================================================================================

C:\Users\robox\j\workspace\arm_cross_che---0fb8fec2\_\fx\bin\tests\System.Runtime.Numerics.Tests\netcoreapp-Windows_NT-Release-arm&gt;set COMPlus_JitStress=2 

C:\Users\robox\j\workspace\arm_cross_che---0fb8fec2\_\fx\bin\tests\System.Runtime.Numerics.Tests\netcoreapp-Windows_NT-Release-arm&gt;call C:\Users\robox\j\workspace\arm_cross_che---0fb8fec2\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm\dotnet.exe xunit.console.netcore.exe System.Runtime.Numerics.Tests.dll  -xml testResults.xml -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonwindowstests  -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing 
xUnit.net console test runner (32-bit .NET Core)
Copyright (C) 2014 Outercurve Foundation.

Discovering: System.Runtime.Numerics.Tests
Discovered:  System.Runtime.Numerics.Tests
Starting:    System.Runtime.Numerics.Tests

Assert failure(PID 10868 [0x00002a74] Thread: 972 [0x03cc]): Assertion failed 'defList.IsEmpty()' in 'System.Numerics.Tests.ComplexTests:Conjugate(doubledouble)' (IL size 57)

    File: d:\j\workspace\arm_cross_che---f3754642\src\jit\lsrabuild.cpp Line: 2094
    Image: C:\Users\robox\j\workspace\arm_cross_che---0fb8fec2\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm\dotnet.exe

----- end 12:30:43.88 ----- exit code 123456789 ----------------------------------------------------------
COREFX TEST FAILED
Running: C:\Users\robox\j\workspace\arm_cross_che---0fb8fec2\_\fx\bin\tests\System.Runtime.Performance.Tests\netcoreapp-Windows_NT-Release-arm\RunTests.cmd C:\Users\robox\j\workspace\arm_cross_che---0fb8fec2\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm
Using C:\Users\robox\j\workspace\arm_cross_che---0fb8fec2\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm as the test runtime folder.
Executing in C:\Users\robox\j\workspace\arm_cross_che---0fb8fec2\_\fx\bin\tests\System.Runtime.Performance.Tests\netcoreapp-Windows_NT-Release-arm\ 
----- start 12:30:44.01 ===============  To repro directly: ===================================================== 
```
The issue was introduces sometime between now and May 8 2018
I am going to disable System.Runtime.Numerics.Tests in #18347 
When the issue is resolved please remove corresponding line in tests/arm/corefx_test_exclusions.txt </Description>
    <Title_Description>[Windows/arm][JitStress] Assertion failed 'defList.IsEmpty()' in System.Numerics.Tests.ComplexTests:Conjugate Hit this is in PR #18347 during [Windows_NT arm Cross Checked corefx_jitstress1 Build and Test](https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_windows_nt_corefx_jitstress1_tst_prtest/3/consoleText) and [Windows_NT arm Cross Checked corefx_jitstress2 Build and Test](https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_windows_nt_corefx_jitstress2_tst_prtest/3/consoleText)

```
===========================================================================================================

C:\Users\robox\j\workspace\arm_cross_che---953a3c02\_\fx\bin\tests\System.Runtime.Numerics.Tests\netcoreapp-Windows_NT-Release-arm&gt;set COMPlus_JitStress=1 

C:\Users\robox\j\workspace\arm_cross_che---953a3c02\_\fx\bin\tests\System.Runtime.Numerics.Tests\netcoreapp-Windows_NT-Release-arm&gt;call C:\Users\robox\j\workspace\arm_cross_che---953a3c02\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm\dotnet.exe xunit.console.netcore.exe System.Runtime.Numerics.Tests.dll  -xml testResults.xml -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonwindowstests  -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing 
xUnit.net console test runner (32-bit .NET Core)
Copyright (C) 2014 Outercurve Foundation.

Discovering: System.Runtime.Numerics.Tests
Discovered:  System.Runtime.Numerics.Tests
Starting:    System.Runtime.Numerics.Tests

Assert failure(PID 3720 [0x00000e88] Thread: 9524 [0x2534]): Assertion failed 'defList.IsEmpty()' in 'System.Numerics.Tests.ComplexTests:Conjugate(doubledouble)' (IL size 57)

    File: d:\j\workspace\arm_cross_che---23cdb046\src\jit\lsrabuild.cpp Line: 2094
    Image: C:\Users\robox\j\workspace\arm_cross_che---953a3c02\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm\dotnet.exe

----- end 12:25:03.32 ----- exit code 123456789 ----------------------------------------------------------
COREFX TEST FAILED
Running: C:\Users\robox\j\workspace\arm_cross_che---953a3c02\_\fx\bin\tests\System.Runtime.Performance.Tests\netcoreapp-Windows_NT-Release-arm\RunTests.cmd C:\Users\robox\j\workspace\arm_cross_che---953a3c02\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm
Using C:\Users\robox\j\workspace\arm_cross_che---953a3c02\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm as the test runtime folder.
Executing in C:\Users\robox\j\workspace\arm_cross_che---953a3c02\_\fx\bin\tests\System.Runtime.Performance.Tests\netcoreapp-Windows_NT-Release-arm\ 
----- start 12:25:03.43 ===============  To repro directly: ===================================================== 
```

```
===========================================================================================================

C:\Users\robox\j\workspace\arm_cross_che---0fb8fec2\_\fx\bin\tests\System.Runtime.Numerics.Tests\netcoreapp-Windows_NT-Release-arm&gt;set COMPlus_JitStress=2 

C:\Users\robox\j\workspace\arm_cross_che---0fb8fec2\_\fx\bin\tests\System.Runtime.Numerics.Tests\netcoreapp-Windows_NT-Release-arm&gt;call C:\Users\robox\j\workspace\arm_cross_che---0fb8fec2\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm\dotnet.exe xunit.console.netcore.exe System.Runtime.Numerics.Tests.dll  -xml testResults.xml -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonwindowstests  -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing 
xUnit.net console test runner (32-bit .NET Core)
Copyright (C) 2014 Outercurve Foundation.

Discovering: System.Runtime.Numerics.Tests
Discovered:  System.Runtime.Numerics.Tests
Starting:    System.Runtime.Numerics.Tests

Assert failure(PID 10868 [0x00002a74] Thread: 972 [0x03cc]): Assertion failed 'defList.IsEmpty()' in 'System.Numerics.Tests.ComplexTests:Conjugate(doubledouble)' (IL size 57)

    File: d:\j\workspace\arm_cross_che---f3754642\src\jit\lsrabuild.cpp Line: 2094
    Image: C:\Users\robox\j\workspace\arm_cross_che---0fb8fec2\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm\dotnet.exe

----- end 12:30:43.88 ----- exit code 123456789 ----------------------------------------------------------
COREFX TEST FAILED
Running: C:\Users\robox\j\workspace\arm_cross_che---0fb8fec2\_\fx\bin\tests\System.Runtime.Performance.Tests\netcoreapp-Windows_NT-Release-arm\RunTests.cmd C:\Users\robox\j\workspace\arm_cross_che---0fb8fec2\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm
Using C:\Users\robox\j\workspace\arm_cross_che---0fb8fec2\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm as the test runtime folder.
Executing in C:\Users\robox\j\workspace\arm_cross_che---0fb8fec2\_\fx\bin\tests\System.Runtime.Performance.Tests\netcoreapp-Windows_NT-Release-arm\ 
----- start 12:30:44.01 ===============  To repro directly: ===================================================== 
```
The issue was introduces sometime between now and May 8 2018
I am going to disable System.Runtime.Numerics.Tests in #18347 
When the issue is resolved please remove corresponding line in tests/arm/corefx_test_exclusions.txt </Title_Description>
    <Label>JitStress</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18361</IssueLabelID>
    <Title>Performance degradation dotnet core 2.1.300 TieredCompilation</Title>
    <Description>I am very excited about Tiered Compilation in dotnet core so I decided to take it for a spin. Unfortunately in my case I found a performance degradation from 370 ms to 540 ms

## My dotnet version:

```
&gt; dotnet --version
2.1.300
```

##  My use-case

I am tinkering with a push stream in F#.  Push streams are faster than Pull streams (like LINQ). One area where .NET JIT loses against JVM JIT is that .NET JIT is less keen on inlining. With Tiered Compilation I was hoping to see improved inlining improving performance.


Essentially the degradation seems to boil down to that there is an extra jmp in the call chain (as far as I understood this is due to the new jitter introducing an level stub to track stats). I was expected this jmp being eliminated after warmup phase. As the stub don't do any stats tracking it seems to be the final optimized stub to me.

## Finally time for some assembly code:

```
; Top level loop this identical regardless of COMPlus_TieredCompilation
00007ffc`d5d88ece 3bdf            cmp     ebxedi
00007ffc`d5d88ed0 7f13            jg      00007ffc`d5d88ee5
00007ffc`d5d88ed2 488bce          mov     rcxrsi
00007ffc`d5d88ed5 8bd3            mov     edxebx
00007ffc`d5d88ed7 488b06          mov     raxqword ptr [rsi]
00007ffc`d5d88eda 488b4040        mov     raxqword ptr [rax+40h]
; Virtual call to next step in the push stream
00007ffc`d5d88ede ff5020          call    qword ptr [rax+20h]
00007ffc`d5d88ee1 ffc3            inc     ebx
00007ffc`d5d88ee3 ebe9            jmp     00007ffc`d5d88ece

; The virtual call ends up here which seems left overs from the stats tracking stub.
; This is not present when COMPlus_TieredCompilation=0
00007ffc`d5d88200 e9bb080000      jmp     00007ffc`d5d88ac0

; The next step in the push stream
00007ffc`d5d88ac0 488b4908        mov     rcxqword ptr [rcx+8] ds:0000023a`000124c0=0000023a000124a0
00007ffc`d5d88ac4 4863d2          movsxd  rdxedx
00007ffc`d5d88ac7 488b01          mov     raxqword ptr [rcx]
00007ffc`d5d88aca 488b4040        mov     raxqword ptr [rax+40h]
00007ffc`d5d88ace 488b4020        mov     raxqword ptr [rax+20h]
00007ffc`d5d88ad2 48ffe0          jmp     rax
```

So with Tiered compilation I was hoping for the virtual call to be eliminated (as is the case in JVM JIT) instead I got a performance degradation from 370 ms to 540 ms.

Perhaps I should wait for some more detailed posts on Tiered Compilation as promised here: https://blogs.msdn.microsoft.com/dotnet/2018/05/30/announcing-net-core-2-1/

However I am quite excited about Tiered Compilation so I wanted to get an early start. Hopefully you tell me I made a mistake.

## My F# code:

```
module TrivialStream =
  // The trivial stream is a very simplistic push stream that doesn't support
  //  early exits (useful for first)
  //  The trivial stream is useful as basic stream to measure performance against

  type Receiver&lt;'T&gt; = 'T            -&gt; unit
  type Stream&lt;'T&gt;   = Receiver&lt;'T&gt;  -&gt; unit

  module Details =
    module Loop =
      // This way to iterate seems to be faster in F#4 than a while loop
      let rec range s e r i = if i &lt;= e then r i; range s e r (i + s)

  open Details

  // Sources

  let inline range b s e : Stream&lt;int&gt; =
    fun r -&gt; Loop.range s e r b

  // Pipes

  let inline filter (f : 'T -&gt; bool) (s : Stream&lt;'T&gt;) : Stream&lt;'T&gt; =
    fun r -&gt; s (fun v -&gt; if f v then r v)

  let inline map (m : 'T -&gt; 'U) (s : Stream&lt;'T&gt;) : Stream&lt;'U&gt; =
    fun r -&gt; s (fun v -&gt; r (m v))

  // Sinks

  let inline sum (s : Stream&lt;'T&gt;) : 'T =
    let mutable ss = LanguagePrimitives.GenericZero
    s (fun v -&gt; ss &lt;- ss + v)
    ss

module PerformanceTests =
  open System
  open System.Diagnostics
  open System.IO

  let now =
    let sw = Stopwatch ()
    sw.Start ()
    fun () -&gt; sw.ElapsedMilliseconds

  let time n a =
    let inline cc i       = GC.CollectionCount i

    let v                 = a ()

    GC.Collect (2 GCCollectionMode.Forced true)

    let bcc0 bcc1 bcc2  = cc 0 cc 1 cc 2
    let b                 = now ()

    for i in 1..n do
      a () |&gt; ignore

    let e = now ()
    let ecc0 ecc1 ecc2  = cc 0 cc 1 cc 2

    v (e - b) ecc0 - bcc0 ecc1 - bcc1 ecc2 - bcc2

  let trivialTest n =
    TrivialStream.range       0 1 n
    |&gt; TrivialStream.map      int64
    |&gt; TrivialStream.filter   (fun v -&gt; v &amp;&amp;&amp; 1L = 0L)
    |&gt; TrivialStream.map      ((+) 1L)
    |&gt; TrivialStream.sum

  let imperativeTest n =
    let rec loop s i =
      if i &gt;= 0L then
        if i &amp;&amp;&amp; 1L = 0L then
          loop (s + i + 1L) (i - 1L)
        else
          loop s (i - 1L)
      else
        s
    loop 0L (int64 n)

  let test (path : string) =
    printfn "Running performance tests..."

    let testCases =
      [|
//        "imperative"   imperativeTest
        "trivialpush"  trivialTest
      |]

    do
      let warmups = 100
      printfn "Warming up..."
      for name a in testCases do
        time warmups (fun () -&gt; a warmups) |&gt; ignore

    use out                   = new StreamWriter (path)
    let write (msg : string)  = out.WriteLine msg
    let writef fmt            = FSharp.Core.Printf.kprintf write fmt

    write "Name\tTotal\tOuter\tInner\tElapsed\tCC\tCC0\tCC1\tCC2\tResult"

    let total   = 100000000
    let outers =
      [|
        10
        1000
        1000000
      |]
    for outer in outers do
      let inner = total / outer
      for name a in testCases do
        printfn "Running %s with total=%d outer=%d inner=%d ..." name total outer inner
        let v ms cc0 cc1 cc2 = time outer (fun () -&gt; a inner)
        let cc = cc0 + cc1 + cc2
        printfn "  ... %d ms cc=%d cc0=%d cc1=%d cc2=%d result=%A" ms cc cc0 cc1 cc2 v
        writef "%s\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d" name total outer inner ms cc cc0 cc1 cc2 v

    printfn "Performance tests completed"

[&lt;EntryPoint&gt;]
let main argv =
//  printfn "Attach debugger and hit a key"
//  System.Console.ReadKey () |&gt; ignore
  PerformanceTests.test "perf.tsv"
  0
```
</Description>
    <Title_Description>Performance degradation dotnet core 2.1.300 TieredCompilation I am very excited about Tiered Compilation in dotnet core so I decided to take it for a spin. Unfortunately in my case I found a performance degradation from 370 ms to 540 ms

## My dotnet version:

```
&gt; dotnet --version
2.1.300
```

##  My use-case

I am tinkering with a push stream in F#.  Push streams are faster than Pull streams (like LINQ). One area where .NET JIT loses against JVM JIT is that .NET JIT is less keen on inlining. With Tiered Compilation I was hoping to see improved inlining improving performance.


Essentially the degradation seems to boil down to that there is an extra jmp in the call chain (as far as I understood this is due to the new jitter introducing an level stub to track stats). I was expected this jmp being eliminated after warmup phase. As the stub don't do any stats tracking it seems to be the final optimized stub to me.

## Finally time for some assembly code:

```
; Top level loop this identical regardless of COMPlus_TieredCompilation
00007ffc`d5d88ece 3bdf            cmp     ebxedi
00007ffc`d5d88ed0 7f13            jg      00007ffc`d5d88ee5
00007ffc`d5d88ed2 488bce          mov     rcxrsi
00007ffc`d5d88ed5 8bd3            mov     edxebx
00007ffc`d5d88ed7 488b06          mov     raxqword ptr [rsi]
00007ffc`d5d88eda 488b4040        mov     raxqword ptr [rax+40h]
; Virtual call to next step in the push stream
00007ffc`d5d88ede ff5020          call    qword ptr [rax+20h]
00007ffc`d5d88ee1 ffc3            inc     ebx
00007ffc`d5d88ee3 ebe9            jmp     00007ffc`d5d88ece

; The virtual call ends up here which seems left overs from the stats tracking stub.
; This is not present when COMPlus_TieredCompilation=0
00007ffc`d5d88200 e9bb080000      jmp     00007ffc`d5d88ac0

; The next step in the push stream
00007ffc`d5d88ac0 488b4908        mov     rcxqword ptr [rcx+8] ds:0000023a`000124c0=0000023a000124a0
00007ffc`d5d88ac4 4863d2          movsxd  rdxedx
00007ffc`d5d88ac7 488b01          mov     raxqword ptr [rcx]
00007ffc`d5d88aca 488b4040        mov     raxqword ptr [rax+40h]
00007ffc`d5d88ace 488b4020        mov     raxqword ptr [rax+20h]
00007ffc`d5d88ad2 48ffe0          jmp     rax
```

So with Tiered compilation I was hoping for the virtual call to be eliminated (as is the case in JVM JIT) instead I got a performance degradation from 370 ms to 540 ms.

Perhaps I should wait for some more detailed posts on Tiered Compilation as promised here: https://blogs.msdn.microsoft.com/dotnet/2018/05/30/announcing-net-core-2-1/

However I am quite excited about Tiered Compilation so I wanted to get an early start. Hopefully you tell me I made a mistake.

## My F# code:

```
module TrivialStream =
  // The trivial stream is a very simplistic push stream that doesn't support
  //  early exits (useful for first)
  //  The trivial stream is useful as basic stream to measure performance against

  type Receiver&lt;'T&gt; = 'T            -&gt; unit
  type Stream&lt;'T&gt;   = Receiver&lt;'T&gt;  -&gt; unit

  module Details =
    module Loop =
      // This way to iterate seems to be faster in F#4 than a while loop
      let rec range s e r i = if i &lt;= e then r i; range s e r (i + s)

  open Details

  // Sources

  let inline range b s e : Stream&lt;int&gt; =
    fun r -&gt; Loop.range s e r b

  // Pipes

  let inline filter (f : 'T -&gt; bool) (s : Stream&lt;'T&gt;) : Stream&lt;'T&gt; =
    fun r -&gt; s (fun v -&gt; if f v then r v)

  let inline map (m : 'T -&gt; 'U) (s : Stream&lt;'T&gt;) : Stream&lt;'U&gt; =
    fun r -&gt; s (fun v -&gt; r (m v))

  // Sinks

  let inline sum (s : Stream&lt;'T&gt;) : 'T =
    let mutable ss = LanguagePrimitives.GenericZero
    s (fun v -&gt; ss &lt;- ss + v)
    ss

module PerformanceTests =
  open System
  open System.Diagnostics
  open System.IO

  let now =
    let sw = Stopwatch ()
    sw.Start ()
    fun () -&gt; sw.ElapsedMilliseconds

  let time n a =
    let inline cc i       = GC.CollectionCount i

    let v                 = a ()

    GC.Collect (2 GCCollectionMode.Forced true)

    let bcc0 bcc1 bcc2  = cc 0 cc 1 cc 2
    let b                 = now ()

    for i in 1..n do
      a () |&gt; ignore

    let e = now ()
    let ecc0 ecc1 ecc2  = cc 0 cc 1 cc 2

    v (e - b) ecc0 - bcc0 ecc1 - bcc1 ecc2 - bcc2

  let trivialTest n =
    TrivialStream.range       0 1 n
    |&gt; TrivialStream.map      int64
    |&gt; TrivialStream.filter   (fun v -&gt; v &amp;&amp;&amp; 1L = 0L)
    |&gt; TrivialStream.map      ((+) 1L)
    |&gt; TrivialStream.sum

  let imperativeTest n =
    let rec loop s i =
      if i &gt;= 0L then
        if i &amp;&amp;&amp; 1L = 0L then
          loop (s + i + 1L) (i - 1L)
        else
          loop s (i - 1L)
      else
        s
    loop 0L (int64 n)

  let test (path : string) =
    printfn "Running performance tests..."

    let testCases =
      [|
//        "imperative"   imperativeTest
        "trivialpush"  trivialTest
      |]

    do
      let warmups = 100
      printfn "Warming up..."
      for name a in testCases do
        time warmups (fun () -&gt; a warmups) |&gt; ignore

    use out                   = new StreamWriter (path)
    let write (msg : string)  = out.WriteLine msg
    let writef fmt            = FSharp.Core.Printf.kprintf write fmt

    write "Name\tTotal\tOuter\tInner\tElapsed\tCC\tCC0\tCC1\tCC2\tResult"

    let total   = 100000000
    let outers =
      [|
        10
        1000
        1000000
      |]
    for outer in outers do
      let inner = total / outer
      for name a in testCases do
        printfn "Running %s with total=%d outer=%d inner=%d ..." name total outer inner
        let v ms cc0 cc1 cc2 = time outer (fun () -&gt; a inner)
        let cc = cc0 + cc1 + cc2
        printfn "  ... %d ms cc=%d cc0=%d cc1=%d cc2=%d result=%A" ms cc cc0 cc1 cc2 v
        writef "%s\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d" name total outer inner ms cc cc0 cc1 cc2 v

    printfn "Performance tests completed"

[&lt;EntryPoint&gt;]
let main argv =
//  printfn "Attach debugger and hit a key"
//  System.Console.ReadKey () |&gt; ignore
  PerformanceTests.test "perf.tsv"
  0
```
</Title_Description>
    <Label>area-TieredCompilation</Label>
    <Assignee>noahfalk</Assignee>
    <CreatedAt>7/06/2018 10:49:58 PM +00:00</CreatedAt>
    <ClosedAt>18/12/2018 12:29:35 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18359</IssueLabelID>
    <Title>Mirror changes from dotnet/corefx</Title>
    <Description>This PR contains mirrored changes from dotnet/corefx


**Please REBASE this PR when merging**</Description>
    <Title_Description>Mirror changes from dotnet/corefx This PR contains mirrored changes from dotnet/corefx


**Please REBASE this PR when merging**</Title_Description>
    <Label>
    </Label>
    <Assignee>brianrob</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18353</IssueLabelID>
    <Title>JIT: make sure finally cloning isn't cloning along EH only paths</Title>
    <Description>Need to re-examine the selection of which finally clause to clone as I suspect in #18332 that the jit makes a poor choice and clones a finally that can only be reached when an exception is thrown.

Current algorithm is to walk the try region from back to front and picks the finally associated with the "last" exit point in the try hoping that this is the normal try region exit. Perhaps more checks are warranted here -- for instance I think we may also want to screen out blocks that are within some nested handler region.

This is a potential perf enhancement not a correctness issue.</Description>
    <Title_Description>JIT: make sure finally cloning isn't cloning along EH only paths Need to re-examine the selection of which finally clause to clone as I suspect in #18332 that the jit makes a poor choice and clones a finally that can only be reached when an exception is thrown.

Current algorithm is to walk the try region from back to front and picks the finally associated with the "last" exit point in the try hoping that this is the normal try region exit. Perhaps more checks are warranted here -- for instance I think we may also want to screen out blocks that are within some nested handler region.

This is a potential perf enhancement not a correctness issue.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
    <CreatedAt>7/06/2018 7:53:05 PM +00:00</CreatedAt>
    <ClosedAt>12/06/2018 4:49:38 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18347</IssueLabelID>
    <Title>Disable CoreFx tests on Windows/arm and Linux/arm</Title>
    <Description>Disable `System.Dynamic.Runtime.Tests` failing on Windows/arm and Linux/arm due to #18295 

**Update:** Disable `System.Linq.Expressions.Tests` failing on Windows/arm due to #18295; Disable `System.Runtime.Numerics.Tests` failing on Windows/arm due to #18362</Description>
    <Title_Description>Disable CoreFx tests on Windows/arm and Linux/arm Disable `System.Dynamic.Runtime.Tests` failing on Windows/arm and Linux/arm due to #18295 

**Update:** Disable `System.Linq.Expressions.Tests` failing on Windows/arm due to #18295; Disable `System.Runtime.Numerics.Tests` failing on Windows/arm due to #18362</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>dotnet-bot</Assignee>
    <CreatedAt>7/06/2018 4:14:29 PM +00:00</CreatedAt>
    <ClosedAt>8/06/2018 4:32:33 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18342</IssueLabelID>
    <Title>Debugging : The libcoreclr.so module is not loaded yet in the target process : when different build id of dotnet</Title>
    <Description>I have a crash dump from command `dotnet a.dll` on production Linux servers.

We only install `dotnet-runtime` on the machine. The crash dump shows build id : `e3943c3b216e09052a31405f70505efd06bf4fc2` of `dotnet`


```
asnegi@asnegi-vm $ eu-unstrip -n --core dotnet.46929 | grep -i dotnet
0x400000+0x21a000 e3943c3b216e09052a31405f70505efd06bf4fc2@0x400284 . - /usr/share/dotnet/dotnet
0x7faf4db4b000+0x212730 5e0ccae0ec928ec24414fa56ee23869a5b16962d@0x7faf6a11e210 /usr/share/dotnet/shared/Microsoft.NETCore.App/2.0.7/libcoreclr.so - libcoreclr.so
0x7faf6a837000+0x2c9788 4dee45d09c9e5de03fa5becc65fbb466cec81b58@0x7faf6a8371d8 /usr/share/dotnet/shared/Microsoft.NETCore.App/2.0.7/libhostpolicy.so - libhostpolicy.so
0x7faf6ab01000+0x2ac698 abffae5e46e06d6830ecebd717df9b741f804ff4@0x7faf6ab011d8 /usr/share/dotnet/host/fxr/2.0.7/libhostfxr.so - libhostfxr.so
asnegi@asnegi-vm $
```

When I install only `dotnet-runtime-2.0.7` locally it's build id is different : `1e0d2e7281fa99d9dd23dda4388d34274b901b34`

```
$ dotnet --info

Microsoft .NET Core Shared Framework Host

  Version  : 2.0.7
  Build    : 2d61d0b043915bc948ebf98836fefe9ba942be11

$ readelf -n /usr/share/dotnet/dotnet

Displaying notes found at file offset 0x00000254 with length 0x00000020:
  Owner                 Data size       Description
  GNU                  0x00000010       NT_GNU_ABI_TAG (ABI version tag)
    OS: Linux ABI: 2.6.32

Displaying notes found at file offset 0x00000274 with length 0x00000024:
  Owner                 Data size       Description
  GNU                  0x00000014       NT_GNU_BUILD_ID (unique build ID bitstring)
    Build ID: 1e0d2e7281fa99d9dd23dda4388d34274b901b34
```

The problem is that when I use `lldb-3.9` to look at dump the symbols don't load and I don't see any stack trace with `sos ClrStack` command even though `libcoreclr.so` symbols are present.

```
$ eu-unstrip -n --core dotnet.46929.core | grep -i coreclr
0x7faf69416000+0x29eea8 6ef619cfdb93245e64cfa85a216bc193bbdc2c41@0x7faf694161d8 /usr/share/dotnet/shared/Microsoft.NETCore.App/2.0.7/libcoreclrtraceptprovider.so - libcoreclrtraceptprovider.so
0x7faf6a11e000+0x718db0 5e0ccae0ec928ec24414fa56ee23869a5b16962d@0x7faf6a11e210 /usr/share/dotnet/shared/Microsoft.NETCore.App/2.0.7/libcoreclr.so - libcoreclr.so
```

`5e0ccae0ec928ec24414fa56ee23869a5b16962d` matches with locally present `.so` file.

```
$ readelf -n libcoreclr.so

Displaying notes found at file offset 0x00000200 with length 0x00000024:
  Owner                 Data size       Description
  GNU                  0x00000014       NT_GNU_BUILD_ID (unique build ID bitstring)
    Build ID: 5e0ccae0ec928ec24414fa56ee23869a5b16962d

Displaying notes found at file offset 0x006e76cc with length 0x0000001c:
  Owner                 Data size       Description
  GNU                  0x00000009       NT_GNU_GOLD_VERSION (gold version)
    Version: gold 1.11
$
```
And then I get `The libcoreclr.so module is not loaded yet in the target process` in lldb.

```
$ lldb-3.9 -O "plugin load libsosplugin.so" -O "sos ClrStack" -c dotnet.46929.core /usr/share/dotnet/dotnet
(lldb) plugin load libsosplugin.so
(lldb) target create "/usr/share/dotnet/dotnet" --core "dotnet.46929.core"
Core file '/mnt/hdd/coredumps/dotnet.46929/dotnet.46929.core' (x86_64) was loaded.
(lldb) sos ClrStack
The libcoreclr.so module is not loaded yet in the target process
(lldb) bt
* thread #1: tid = 76765 0x00007faf6ade3428 name = 'dotnet' stop reason = signal SIGABRT
  * frame #0: 0x00007faf6ade3428
    frame #1: 0x00007faf6a5fff5b
    frame #2: 0x00007faf6a2a50d3
    frame #3: 0x00007faf6a2a66f1
    frame #4: 0x00007faf6a582a06
    frame #5: 0x00007faf6a58319e
    frame #6: 0x00007faef1c71a99
    frame #7: 0x00007faef1c717ee
    frame #8: 0x00007faef1c4dc4b
    frame #9: 0x00007faef1c4d7fa
    frame #10: 0x00007faef1c4d667
    frame #11: 0x00007faef1c4d611
    frame #12: 0x00007faef246aa68
    frame #13: 0x00007faef285bb8c
    frame #14: 0x00007faef0bc3481
    frame #15: 0x00007faef0c3e8c2
    frame #16: 0x00007faef0bfde1e
    frame #17: 0x00007faef0c436e6
    frame #18: 0x00007faef0d35887
    frame #19: 0x00007faef1c82385
    frame #20: 0x00007faef1c81f05
    frame #21: 0x00007faef1c8359b
    frame #22: 0x00007faf6a37624e
(lldb) target modules list
[  0] 1E0D2E72-81FA-99D9-DD23-DDA4388D3427-4B901B34                    /usr/share/dotnet/dotnet
(lldb)
(lldb) quit
Quitting LLDB will kill one or more processes. Do you really want to proceed: [Y/n] y
```

I have `libcoreclr.so` and `libcoreclr.so.dbg` on same folder as dump.

Luckily on my other machine where I had installed dotnet earlier the build id of dotnet matches :

```
asnegi@asnegi-vm ~/ryu/2.0.7/dump $ readelf -n /usr/share/dotnet/dotnet

Displaying notes found at file offset 0x00000254 with length 0x00000020:
  Owner                 Data size       Description
  GNU                  0x00000010       NT_GNU_ABI_TAG (ABI version tag)
    OS: Linux ABI: 2.6.32

Displaying notes found at file offset 0x00000274 with length 0x00000024:
  Owner                 Data size       Description
  GNU                  0x00000014       NT_GNU_BUILD_ID (unique build ID bitstring)
    Build ID: e3943c3b216e09052a31405f70505efd06bf4fc2
asnegi@asnegi-vm ~/ryu/2.0.7/dump $
```
and dotnet symbols load fine

```
asnegi@asnegi-vm ~/ryu/2.0.7/dump $ lldb-3.9 -O "plugin load ~/ryu/libsosplugin/libsosplugin.so" -c dotnet.46929 /usr/share/dotnet/dotnet
(lldb) plugin load ~/ryu/libsosplugin/libsosplugin.so
(lldb) target create "/usr/share/dotnet/dotnet" --core "dotnet.46929"
Core file '/home/asnegi/ryu/2.0.7/dump/dotnet.46929' (x86_64) was loaded.
(lldb) sos ClrStack
OS Thread Id: 0x12bdd (1)
        Child SP               IP Call Site
00007FAE19FF9BB0 00007faf6ade3428 [GCFrame: 00007fae19ff9bb0]
00007FAE19FF9C78 00007faf6ade3428 [HelperMethodFrame_2OBJ: 00007fae19ff9c78] System.Environment.FailFast(System.String System.Exception)
00007FAE19FF9DB0 00007FAEF1C71A99 System.Runtime.InteropServices.TypeHandleExtensions.HasDynamicAdapterClass(System.RuntimeTypeHandle)
00007FAE19FF9E20 00007FAEF1C717EE System.__ComObject.InsertIntoCache(System.RuntimeTypeHandle System.Runtime.InteropServices.ContextCookie IntPtr ByRef Boolean)
00007FAE19FF9E80 00007FAEF1C4DC4B System.Runtime.InteropServices.McgComHelpers.ComInterfaceToComObjectInternal(IntPtr IntPtr System.RuntimeTypeHandle System.RuntimeTypeHandle System.Runtime
...
(lldb) target modules list
[  0] E3943C3B-216E-0905-2A31-405F70505EFD-06BF4FC2                    /usr/share/dotnet/dotnet
[  1] 49D9D8C0-0D86-62C5-F1C8-D1B20B4D1FC9-26240650 0x00007ffc965ec000 [vdso] (0x00007ffc965ec000)
[  2] 8CC8D0D1-19B1-42D8-3980-0BFF71FB71E7-3AEA7BD4                    /lib/x86_64-linux-gnu/libdl.so.2
      /usr/lib/debug/lib/x86_64-linux-gnu/libdl-2.23.so
[  3] CE17E023-5422-65FC-11D9-BC8F534BB4F0-70493D30                    /lib/x86_64-linux-gnu/libpthread.so.0
[  4] CB93C881-929B-523C-01AC-EF171B52D526-1F026029                    /usr/lib/x86_64-linux-gnu/libstdc++.so.6
[  5] DFB85DE4-2DAF-FD09-640C-8FE377D572DE-3E168920                    /lib/x86_64-linux-gnu/libm.so.6
      /usr/lib/debug/lib/x86_64-linux-gnu/libm-2.23.so
[  6] 68220AE2-C65D-65C1-B6AA-A12FA6765A6E-C2F5F434                    /lib/x86_64-linux-gnu/libgcc_s.so.1
[  7] B5381A45-7906-D279-0738-22A5CEB24C4B-FEF94DDB                    /lib/x86_64-linux-gnu/libc.so.6
      /usr/lib/debug/lib/x86_64-linux-gnu/libc-2.23.so
[  8] 5D7B6259-5522-75A3-C17B-D4C3FD05F5A6-BF40CAA5                    /lib64/ld-linux-x86-64.so.2
[  9] ....
```

Q1. Is there a way to `force load symbols` even if `buildid` of dotnet does not match but other `bulidid`s like that of `libcoreclr.so` match ?
Q2. Where can I find symbols for a particular buildid : `e3943c3b216e09052a31405f70505efd06bf4fc2` ?
    and what commands to run to get the bits for `dotnet-runtime` for same buildid always consistently across platforms.
Q3. Why has the `build id` of dotnet changed ? Is this our problem ? Or problem in process of dotnet publishing to apt-repos.

</Description>
    <Title_Description>Debugging : The libcoreclr.so module is not loaded yet in the target process : when different build id of dotnet I have a crash dump from command `dotnet a.dll` on production Linux servers.

We only install `dotnet-runtime` on the machine. The crash dump shows build id : `e3943c3b216e09052a31405f70505efd06bf4fc2` of `dotnet`


```
asnegi@asnegi-vm $ eu-unstrip -n --core dotnet.46929 | grep -i dotnet
0x400000+0x21a000 e3943c3b216e09052a31405f70505efd06bf4fc2@0x400284 . - /usr/share/dotnet/dotnet
0x7faf4db4b000+0x212730 5e0ccae0ec928ec24414fa56ee23869a5b16962d@0x7faf6a11e210 /usr/share/dotnet/shared/Microsoft.NETCore.App/2.0.7/libcoreclr.so - libcoreclr.so
0x7faf6a837000+0x2c9788 4dee45d09c9e5de03fa5becc65fbb466cec81b58@0x7faf6a8371d8 /usr/share/dotnet/shared/Microsoft.NETCore.App/2.0.7/libhostpolicy.so - libhostpolicy.so
0x7faf6ab01000+0x2ac698 abffae5e46e06d6830ecebd717df9b741f804ff4@0x7faf6ab011d8 /usr/share/dotnet/host/fxr/2.0.7/libhostfxr.so - libhostfxr.so
asnegi@asnegi-vm $
```

When I install only `dotnet-runtime-2.0.7` locally it's build id is different : `1e0d2e7281fa99d9dd23dda4388d34274b901b34`

```
$ dotnet --info

Microsoft .NET Core Shared Framework Host

  Version  : 2.0.7
  Build    : 2d61d0b043915bc948ebf98836fefe9ba942be11

$ readelf -n /usr/share/dotnet/dotnet

Displaying notes found at file offset 0x00000254 with length 0x00000020:
  Owner                 Data size       Description
  GNU                  0x00000010       NT_GNU_ABI_TAG (ABI version tag)
    OS: Linux ABI: 2.6.32

Displaying notes found at file offset 0x00000274 with length 0x00000024:
  Owner                 Data size       Description
  GNU                  0x00000014       NT_GNU_BUILD_ID (unique build ID bitstring)
    Build ID: 1e0d2e7281fa99d9dd23dda4388d34274b901b34
```

The problem is that when I use `lldb-3.9` to look at dump the symbols don't load and I don't see any stack trace with `sos ClrStack` command even though `libcoreclr.so` symbols are present.

```
$ eu-unstrip -n --core dotnet.46929.core | grep -i coreclr
0x7faf69416000+0x29eea8 6ef619cfdb93245e64cfa85a216bc193bbdc2c41@0x7faf694161d8 /usr/share/dotnet/shared/Microsoft.NETCore.App/2.0.7/libcoreclrtraceptprovider.so - libcoreclrtraceptprovider.so
0x7faf6a11e000+0x718db0 5e0ccae0ec928ec24414fa56ee23869a5b16962d@0x7faf6a11e210 /usr/share/dotnet/shared/Microsoft.NETCore.App/2.0.7/libcoreclr.so - libcoreclr.so
```

`5e0ccae0ec928ec24414fa56ee23869a5b16962d` matches with locally present `.so` file.

```
$ readelf -n libcoreclr.so

Displaying notes found at file offset 0x00000200 with length 0x00000024:
  Owner                 Data size       Description
  GNU                  0x00000014       NT_GNU_BUILD_ID (unique build ID bitstring)
    Build ID: 5e0ccae0ec928ec24414fa56ee23869a5b16962d

Displaying notes found at file offset 0x006e76cc with length 0x0000001c:
  Owner                 Data size       Description
  GNU                  0x00000009       NT_GNU_GOLD_VERSION (gold version)
    Version: gold 1.11
$
```
And then I get `The libcoreclr.so module is not loaded yet in the target process` in lldb.

```
$ lldb-3.9 -O "plugin load libsosplugin.so" -O "sos ClrStack" -c dotnet.46929.core /usr/share/dotnet/dotnet
(lldb) plugin load libsosplugin.so
(lldb) target create "/usr/share/dotnet/dotnet" --core "dotnet.46929.core"
Core file '/mnt/hdd/coredumps/dotnet.46929/dotnet.46929.core' (x86_64) was loaded.
(lldb) sos ClrStack
The libcoreclr.so module is not loaded yet in the target process
(lldb) bt
* thread #1: tid = 76765 0x00007faf6ade3428 name = 'dotnet' stop reason = signal SIGABRT
  * frame #0: 0x00007faf6ade3428
    frame #1: 0x00007faf6a5fff5b
    frame #2: 0x00007faf6a2a50d3
    frame #3: 0x00007faf6a2a66f1
    frame #4: 0x00007faf6a582a06
    frame #5: 0x00007faf6a58319e
    frame #6: 0x00007faef1c71a99
    frame #7: 0x00007faef1c717ee
    frame #8: 0x00007faef1c4dc4b
    frame #9: 0x00007faef1c4d7fa
    frame #10: 0x00007faef1c4d667
    frame #11: 0x00007faef1c4d611
    frame #12: 0x00007faef246aa68
    frame #13: 0x00007faef285bb8c
    frame #14: 0x00007faef0bc3481
    frame #15: 0x00007faef0c3e8c2
    frame #16: 0x00007faef0bfde1e
    frame #17: 0x00007faef0c436e6
    frame #18: 0x00007faef0d35887
    frame #19: 0x00007faef1c82385
    frame #20: 0x00007faef1c81f05
    frame #21: 0x00007faef1c8359b
    frame #22: 0x00007faf6a37624e
(lldb) target modules list
[  0] 1E0D2E72-81FA-99D9-DD23-DDA4388D3427-4B901B34                    /usr/share/dotnet/dotnet
(lldb)
(lldb) quit
Quitting LLDB will kill one or more processes. Do you really want to proceed: [Y/n] y
```

I have `libcoreclr.so` and `libcoreclr.so.dbg` on same folder as dump.

Luckily on my other machine where I had installed dotnet earlier the build id of dotnet matches :

```
asnegi@asnegi-vm ~/ryu/2.0.7/dump $ readelf -n /usr/share/dotnet/dotnet

Displaying notes found at file offset 0x00000254 with length 0x00000020:
  Owner                 Data size       Description
  GNU                  0x00000010       NT_GNU_ABI_TAG (ABI version tag)
    OS: Linux ABI: 2.6.32

Displaying notes found at file offset 0x00000274 with length 0x00000024:
  Owner                 Data size       Description
  GNU                  0x00000014       NT_GNU_BUILD_ID (unique build ID bitstring)
    Build ID: e3943c3b216e09052a31405f70505efd06bf4fc2
asnegi@asnegi-vm ~/ryu/2.0.7/dump $
```
and dotnet symbols load fine

```
asnegi@asnegi-vm ~/ryu/2.0.7/dump $ lldb-3.9 -O "plugin load ~/ryu/libsosplugin/libsosplugin.so" -c dotnet.46929 /usr/share/dotnet/dotnet
(lldb) plugin load ~/ryu/libsosplugin/libsosplugin.so
(lldb) target create "/usr/share/dotnet/dotnet" --core "dotnet.46929"
Core file '/home/asnegi/ryu/2.0.7/dump/dotnet.46929' (x86_64) was loaded.
(lldb) sos ClrStack
OS Thread Id: 0x12bdd (1)
        Child SP               IP Call Site
00007FAE19FF9BB0 00007faf6ade3428 [GCFrame: 00007fae19ff9bb0]
00007FAE19FF9C78 00007faf6ade3428 [HelperMethodFrame_2OBJ: 00007fae19ff9c78] System.Environment.FailFast(System.String System.Exception)
00007FAE19FF9DB0 00007FAEF1C71A99 System.Runtime.InteropServices.TypeHandleExtensions.HasDynamicAdapterClass(System.RuntimeTypeHandle)
00007FAE19FF9E20 00007FAEF1C717EE System.__ComObject.InsertIntoCache(System.RuntimeTypeHandle System.Runtime.InteropServices.ContextCookie IntPtr ByRef Boolean)
00007FAE19FF9E80 00007FAEF1C4DC4B System.Runtime.InteropServices.McgComHelpers.ComInterfaceToComObjectInternal(IntPtr IntPtr System.RuntimeTypeHandle System.RuntimeTypeHandle System.Runtime
...
(lldb) target modules list
[  0] E3943C3B-216E-0905-2A31-405F70505EFD-06BF4FC2                    /usr/share/dotnet/dotnet
[  1] 49D9D8C0-0D86-62C5-F1C8-D1B20B4D1FC9-26240650 0x00007ffc965ec000 [vdso] (0x00007ffc965ec000)
[  2] 8CC8D0D1-19B1-42D8-3980-0BFF71FB71E7-3AEA7BD4                    /lib/x86_64-linux-gnu/libdl.so.2
      /usr/lib/debug/lib/x86_64-linux-gnu/libdl-2.23.so
[  3] CE17E023-5422-65FC-11D9-BC8F534BB4F0-70493D30                    /lib/x86_64-linux-gnu/libpthread.so.0
[  4] CB93C881-929B-523C-01AC-EF171B52D526-1F026029                    /usr/lib/x86_64-linux-gnu/libstdc++.so.6
[  5] DFB85DE4-2DAF-FD09-640C-8FE377D572DE-3E168920                    /lib/x86_64-linux-gnu/libm.so.6
      /usr/lib/debug/lib/x86_64-linux-gnu/libm-2.23.so
[  6] 68220AE2-C65D-65C1-B6AA-A12FA6765A6E-C2F5F434                    /lib/x86_64-linux-gnu/libgcc_s.so.1
[  7] B5381A45-7906-D279-0738-22A5CEB24C4B-FEF94DDB                    /lib/x86_64-linux-gnu/libc.so.6
      /usr/lib/debug/lib/x86_64-linux-gnu/libc-2.23.so
[  8] 5D7B6259-5522-75A3-C17B-D4C3FD05F5A6-BF40CAA5                    /lib64/ld-linux-x86-64.so.2
[  9] ....
```

Q1. Is there a way to `force load symbols` even if `buildid` of dotnet does not match but other `bulidid`s like that of `libcoreclr.so` match ?
Q2. Where can I find symbols for a particular buildid : `e3943c3b216e09052a31405f70505efd06bf4fc2` ?
    and what commands to run to get the bits for `dotnet-runtime` for same buildid always consistently across platforms.
Q3. Why has the `build id` of dotnet changed ? Is this our problem ? Or problem in process of dotnet publishing to apt-repos.

</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>mikem8361</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18341</IssueLabelID>
    <Title>JIT: disasm assert on OSX</Title>
    <Description>Build checked coreclr on OSX. Set `COMPlus_JitDisasm=*` and try to run any program. It will assert trying to show the listing for a `vextractf128` instruction in one of the span methods jitted at startup:

```
Assert failure(PID 20420 [0x00004fc4] Thread: 672964 [0xa44c4]): 
Assertion failed '(val &gt;= 0xFFFFFFFF80000000LL) &amp;&amp; (val &lt;= 0x000000007FFFFFFFLL)' 
in 'System.SpanHelpers:IndexOf(byrefushortint):int' (IL size 339)

    File: /Users/andy/repos/coreclr/src/jit/emitxarch.cpp Line: 8744
    Image: /Users/andy/repos/coreclr/bin/tests/OSX.x64.Checked/Tests/Core_Root/corerun

       C4E37D19C101         vextractf128 ymm1 ymm0
```</Description>
    <Title_Description>JIT: disasm assert on OSX Build checked coreclr on OSX. Set `COMPlus_JitDisasm=*` and try to run any program. It will assert trying to show the listing for a `vextractf128` instruction in one of the span methods jitted at startup:

```
Assert failure(PID 20420 [0x00004fc4] Thread: 672964 [0xa44c4]): 
Assertion failed '(val &gt;= 0xFFFFFFFF80000000LL) &amp;&amp; (val &lt;= 0x000000007FFFFFFFLL)' 
in 'System.SpanHelpers:IndexOf(byrefushortint):int' (IL size 339)

    File: /Users/andy/repos/coreclr/src/jit/emitxarch.cpp Line: 8744
    Image: /Users/andy/repos/coreclr/bin/tests/OSX.x64.Checked/Tests/Core_Root/corerun

       C4E37D19C101         vextractf128 ymm1 ymm0
```</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>BruceForstall</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18339</IssueLabelID>
    <Title>JIT Performance regression between 1.1 and 2.0 and between 2.0 and 2.1</Title>
    <Description>I've been trying to come up with a simple repro for a perf regression I've been fighting and I think I have it trimmed down as much as possible while still showing the real-world impact.  What I have [here](https://github.com/saucecontrol/Blake2Fast/tree/master/tests/JitRegression) is a stripped-down version of my [Blake2b](http://blake2.net/) hashing algorithm implementation.  The main work is driven through a single CPU-intensive mixing function and I've set up benchmarks with 3 variants of that function to show the problem.

1) is a [no-op version](https://github.com/saucecontrol/Blake2Fast/blob/master/tests/JitRegression/Blake2bMixNoop.cs) that simply runs all the outer loop code as a baseline for determining time spent in the inner loop.
2) is the version I'd like to use with the mixing math in a [separate method](https://github.com/saucecontrol/Blake2Fast/blob/master/tests/JitRegression/Blake2bMixPreferred.cs) marked with `[MethodImpl(MethodImplOptions.AggressiveInlining)]`
3) is the version I ended up using in my real implementation which is [fully-inlined](https://github.com/saucecontrol/Blake2Fast/blob/master/tests/JitRegression/Blake2bMixManualInline.cs) manually because this one gives the most consistent results with the older runtimes.

The function is huge when inlined (JitDump was 67MB) but it really takes running all the calculations to show the full perf effect.  It looks like it's probably a register allocation issue (the algorithm uses 16 local accumulator variables) but I haven't been able to tell exactly where it's going wrong.

I'm seeing a consistent perf regression between .NET Core 1.1 and 2.0 and then some additional regression between 2.0 and 2.1 (x86 particularly) with this function.  I've run the benchmarks against all three runtimes x86 and x64 on two machines to show what I mean.

First up is a Skylake i7 Desktop
```
BenchmarkDotNet=v0.10.14 OS=Windows 10.0.16299.431 (1709/FallCreatorsUpdate/Redstone3)
Intel Core i7-6700K CPU 4.00GHz (Skylake) 1 CPU 8 logical and 4 physical cores
Frequency=3914064 Hz Resolution=255.4889 ns Timer=TSC
.NET Core SDK=2.1.300
  [Host]        : .NET Core 2.1.0 (CoreCLR 4.6.26515.07 CoreFX 4.6.26515.06) 64bit RyuJIT
  netcoreapp1.1 : .NET Core 1.1.8 (CoreCLR 4.6.26328.01 CoreFX 4.6.24705.01) 64bit RyuJIT
  netcoreapp2.0 : .NET Core 2.0.7 (CoreCLR 4.6.26328.01 CoreFX 4.6.26403.03) 64bit RyuJIT
  netcoreapp2.1 : .NET Core 2.1.0 (CoreCLR 4.6.26515.07 CoreFX 4.6.26515.06) 64bit RyuJIT
```

Method |           Job | Platform | IsBaseline |         Mean |       Error |     StdDev | Scaled |
---------------- |-------------- |--------- |----------- |-------------:|------------:|-----------:|-------:|
MixNoop | netcoreapp1.1 |      X64 |       True |     541.1 us |   1.2367 us |  1.1568 us |   1.00 |
MixNoop | netcoreapp2.0 |      X64 |    Default |     536.7 us |   0.4613 us |  0.3852 us |   0.99 |
MixNoop | netcoreapp2.1 |      X64 |    Default |     578.8 us |   0.4531 us |  0.3783 us |   1.07 |
|               |          |            |              |             |            |        |
MixNoop | netcoreapp1.1 |      X86 |       True |   1119.9 us |   9.6466 us |  9.0234 us |   1.00 |
MixNoop | netcoreapp2.0 |      X86 |    Default |   1192.8 us |   2.6294 us |  2.0529 us |   1.07 |
MixNoop | netcoreapp2.1 |      X86 |    Default |   1191.3 us |   0.6622 us |  0.5170 us |   1.06 |
|               |          |            |              |             |            |        |
MixPreferred | netcoreapp1.1 |      X64 |       True |  12459.8 us | 101.8205 us | 90.2612 us |   1.00 |
MixPreferred | netcoreapp2.0 |      X64 |    Default |  12678.6 us |   5.6177 us |  4.6910 us |   1.02 |
MixPreferred | netcoreapp2.1 |      X64 |    Default |  12746.3 us |   6.1352 us |  4.7900 us |   1.02 |
|               |          |            |              |             |            |        |
MixPreferred | netcoreapp1.1 |      X86 |       True | 175779.4 us |  74.0106 us | 61.8022 us |   1.00 |
MixPreferred | netcoreapp2.0 |      X86 |    Default | 106492.8 us |  35.6985 us | 27.8710 us |   0.61 |
MixPreferred | netcoreapp2.1 |      X86 |    Default | 136210.1 us |  59.2411 us | 55.4141 us |   0.77 |
|               |          |            |              |             |            |        |
MixManualInline | netcoreapp1.1 |      X64 |       True |  12349.0 us |  24.9308 us | 20.8184 us |   1.00 |
MixManualInline | netcoreapp2.0 |      X64 |    Default |  12792.0 us |  80.9773 us | 75.7462 us |   1.04 |
MixManualInline | netcoreapp2.1 |      X64 |    Default |  12741.5 us |   6.3150 us |  5.2733 us |   1.03 |
|               |          |            |              |             |            |        |
MixManualInline | netcoreapp1.1 |      X86 |       True |  81966.3 us |  27.9119 us | 21.7917 us |   1.00 |
MixManualInline | netcoreapp2.0 |      X86 |    Default | 106330.1 us |  33.9632 us | 31.7692 us |   1.30 |
MixManualInline | netcoreapp2.1 |      X86 |    Default | 135755.2 us |  67.5010 us | 63.1405 us |   1.66 |

The `MixManualInline` numbers show the regression quite clearly.  There's a 3-4% slowdown between 1.1 and 2.0 on x64 that holds up in 2.1  On x86 it gets significatntly worse with each newer version.  The `MixPreferred` job with the `AgressiveInlining` version of the mixing function does very poorly on 1.1 x86 but then shows basically the same results as the manually-inlined version everywhere else.

And here's the same benchmark run on an older Sandy Bridge Xeon server

```
BenchmarkDotNet=v0.10.14 OS=Windows 8.1 (6.3.9600.0)
Intel Xeon CPU E31230 3.20GHz 1 CPU 8 logical and 4 physical cores
Frequency=3117919 Hz Resolution=320.7267 ns Timer=TSC
.NET Core SDK=2.1.300
  [Host]        : .NET Core 2.1.0 (CoreCLR 4.6.26515.07 CoreFX 4.6.26515.06) 32bit RyuJIT
  netcoreapp1.1 : .NET Core 1.1.8 (CoreCLR 4.6.26328.01 CoreFX 4.6.24705.01) 64bit RyuJIT
  netcoreapp2.0 : .NET Core 2.0.7 (CoreCLR 4.6.26328.01 CoreFX 4.6.26403.03) 64bit RyuJIT
  netcoreapp2.1 : .NET Core 2.1.0 (CoreCLR 4.6.26515.07 CoreFX 4.6.26515.06) 64bit RyuJIT
```

Method |           Job | Platform | IsBaseline |       Mean |      Error |     StdDev |     Median | Scaled | ScaledSD |
---------------- |-------------- |--------- |----------- |-----------:|-----------:|-----------:|-----------:|-------:|---------:|
MixNoop | netcoreapp1.1 |      X64 |       True |   1.326 ms |  0.1071 ms |  0.3158 ms |   1.331 ms |   1.00 |     0.00 |
MixNoop | netcoreapp2.0 |      X64 |    Default |   1.288 ms |  0.1003 ms |  0.2957 ms |   1.285 ms |   1.03 |     0.36 |
MixNoop | netcoreapp2.1 |      X64 |    Default |   1.352 ms |  0.0928 ms |  0.2735 ms |   1.358 ms |   1.08 |     0.36 |
|               |          |            |            |            |            |            |        |          |
MixNoop | netcoreapp1.1 |      X86 |       True |   2.738 ms |  0.2200 ms |  0.6486 ms |   2.701 ms |   1.00 |     0.00 |
MixNoop | netcoreapp2.0 |      X86 |    Default |   2.673 ms |  0.2034 ms |  0.5998 ms |   2.826 ms |   1.04 |     0.36 |
MixNoop | netcoreapp2.1 |      X86 |    Default |   2.776 ms |  0.2096 ms |  0.6181 ms |   2.740 ms |   1.08 |     0.37 |
|               |          |            |            |            |            |            |        |          |
MixPreferred | netcoreapp1.1 |      X64 |       True |  31.926 ms |  2.2443 ms |  6.6172 ms |  32.740 ms |   1.00 |     0.00 |
MixPreferred | netcoreapp2.0 |      X64 |    Default |  31.898 ms |  2.1440 ms |  6.3216 ms |  31.735 ms |   1.05 |     0.33 |
MixPreferred | netcoreapp2.1 |      X64 |    Default |  27.419 ms |  2.4213 ms |  7.1393 ms |  25.538 ms |   0.90 |     0.32 |
|               |          |            |            |            |            |            |        |          |
MixPreferred | netcoreapp1.1 |      X86 |       True | 341.759 ms | 13.1190 ms | 38.4759 ms | 331.234 ms |   1.00 |     0.00 |
MixPreferred | netcoreapp2.0 |      X86 |    Default | 251.373 ms | 13.1463 ms | 38.3484 ms | 239.499 ms |   0.74 |     0.14 |
MixPreferred | netcoreapp2.1 |      X86 |    Default | 291.564 ms | 10.3316 ms | 29.6434 ms | 285.206 ms |   0.86 |     0.13 |
|               |          |            |            |            |            |            |        |          |
MixManualInline | netcoreapp1.1 |      X64 |       True |  33.165 ms |  2.2903 ms |  6.7529 ms |  33.426 ms |   1.00 |     0.00 |
MixManualInline | netcoreapp2.0 |      X64 |    Default |  33.819 ms |  2.4410 ms |  7.1973 ms |  34.340 ms |   1.07 |     0.34 |
MixManualInline | netcoreapp2.1 |      X64 |    Default |  20.601 ms |  0.1490 ms |  0.1394 ms |  20.606 ms |   0.65 |     0.15 |
|               |          |            |            |            |            |            |        |          |
MixManualInline | netcoreapp1.1 |      X86 |       True | 163.629 ms |  7.6584 ms | 22.3398 ms | 160.224 ms |   1.00 |     0.00 |
MixManualInline | netcoreapp2.0 |      X86 |    Default | 249.708 ms | 11.3452 ms | 32.7336 ms | 240.169 ms |   1.55 |     0.28 |
MixManualInline | netcoreapp2.1 |      X86 |    Default | 285.367 ms |  9.0883 ms | 25.6337 ms | 278.039 ms |   1.77 |     0.27 |

Here there are a few more outliers but it's the same general story.

Full code for the benchmarks is [here](https://github.com/saucecontrol/Blake2Fast/tree/master/tests/JitRegression) if anyone wants to try on different hardware.

category:cq
theme:optimization
skill-level:expert
cost:large</Description>
    <Title_Description>JIT Performance regression between 1.1 and 2.0 and between 2.0 and 2.1 I've been trying to come up with a simple repro for a perf regression I've been fighting and I think I have it trimmed down as much as possible while still showing the real-world impact.  What I have [here](https://github.com/saucecontrol/Blake2Fast/tree/master/tests/JitRegression) is a stripped-down version of my [Blake2b](http://blake2.net/) hashing algorithm implementation.  The main work is driven through a single CPU-intensive mixing function and I've set up benchmarks with 3 variants of that function to show the problem.

1) is a [no-op version](https://github.com/saucecontrol/Blake2Fast/blob/master/tests/JitRegression/Blake2bMixNoop.cs) that simply runs all the outer loop code as a baseline for determining time spent in the inner loop.
2) is the version I'd like to use with the mixing math in a [separate method](https://github.com/saucecontrol/Blake2Fast/blob/master/tests/JitRegression/Blake2bMixPreferred.cs) marked with `[MethodImpl(MethodImplOptions.AggressiveInlining)]`
3) is the version I ended up using in my real implementation which is [fully-inlined](https://github.com/saucecontrol/Blake2Fast/blob/master/tests/JitRegression/Blake2bMixManualInline.cs) manually because this one gives the most consistent results with the older runtimes.

The function is huge when inlined (JitDump was 67MB) but it really takes running all the calculations to show the full perf effect.  It looks like it's probably a register allocation issue (the algorithm uses 16 local accumulator variables) but I haven't been able to tell exactly where it's going wrong.

I'm seeing a consistent perf regression between .NET Core 1.1 and 2.0 and then some additional regression between 2.0 and 2.1 (x86 particularly) with this function.  I've run the benchmarks against all three runtimes x86 and x64 on two machines to show what I mean.

First up is a Skylake i7 Desktop
```
BenchmarkDotNet=v0.10.14 OS=Windows 10.0.16299.431 (1709/FallCreatorsUpdate/Redstone3)
Intel Core i7-6700K CPU 4.00GHz (Skylake) 1 CPU 8 logical and 4 physical cores
Frequency=3914064 Hz Resolution=255.4889 ns Timer=TSC
.NET Core SDK=2.1.300
  [Host]        : .NET Core 2.1.0 (CoreCLR 4.6.26515.07 CoreFX 4.6.26515.06) 64bit RyuJIT
  netcoreapp1.1 : .NET Core 1.1.8 (CoreCLR 4.6.26328.01 CoreFX 4.6.24705.01) 64bit RyuJIT
  netcoreapp2.0 : .NET Core 2.0.7 (CoreCLR 4.6.26328.01 CoreFX 4.6.26403.03) 64bit RyuJIT
  netcoreapp2.1 : .NET Core 2.1.0 (CoreCLR 4.6.26515.07 CoreFX 4.6.26515.06) 64bit RyuJIT
```

Method |           Job | Platform | IsBaseline |         Mean |       Error |     StdDev | Scaled |
---------------- |-------------- |--------- |----------- |-------------:|------------:|-----------:|-------:|
MixNoop | netcoreapp1.1 |      X64 |       True |     541.1 us |   1.2367 us |  1.1568 us |   1.00 |
MixNoop | netcoreapp2.0 |      X64 |    Default |     536.7 us |   0.4613 us |  0.3852 us |   0.99 |
MixNoop | netcoreapp2.1 |      X64 |    Default |     578.8 us |   0.4531 us |  0.3783 us |   1.07 |
|               |          |            |              |             |            |        |
MixNoop | netcoreapp1.1 |      X86 |       True |   1119.9 us |   9.6466 us |  9.0234 us |   1.00 |
MixNoop | netcoreapp2.0 |      X86 |    Default |   1192.8 us |   2.6294 us |  2.0529 us |   1.07 |
MixNoop | netcoreapp2.1 |      X86 |    Default |   1191.3 us |   0.6622 us |  0.5170 us |   1.06 |
|               |          |            |              |             |            |        |
MixPreferred | netcoreapp1.1 |      X64 |       True |  12459.8 us | 101.8205 us | 90.2612 us |   1.00 |
MixPreferred | netcoreapp2.0 |      X64 |    Default |  12678.6 us |   5.6177 us |  4.6910 us |   1.02 |
MixPreferred | netcoreapp2.1 |      X64 |    Default |  12746.3 us |   6.1352 us |  4.7900 us |   1.02 |
|               |          |            |              |             |            |        |
MixPreferred | netcoreapp1.1 |      X86 |       True | 175779.4 us |  74.0106 us | 61.8022 us |   1.00 |
MixPreferred | netcoreapp2.0 |      X86 |    Default | 106492.8 us |  35.6985 us | 27.8710 us |   0.61 |
MixPreferred | netcoreapp2.1 |      X86 |    Default | 136210.1 us |  59.2411 us | 55.4141 us |   0.77 |
|               |          |            |              |             |            |        |
MixManualInline | netcoreapp1.1 |      X64 |       True |  12349.0 us |  24.9308 us | 20.8184 us |   1.00 |
MixManualInline | netcoreapp2.0 |      X64 |    Default |  12792.0 us |  80.9773 us | 75.7462 us |   1.04 |
MixManualInline | netcoreapp2.1 |      X64 |    Default |  12741.5 us |   6.3150 us |  5.2733 us |   1.03 |
|               |          |            |              |             |            |        |
MixManualInline | netcoreapp1.1 |      X86 |       True |  81966.3 us |  27.9119 us | 21.7917 us |   1.00 |
MixManualInline | netcoreapp2.0 |      X86 |    Default | 106330.1 us |  33.9632 us | 31.7692 us |   1.30 |
MixManualInline | netcoreapp2.1 |      X86 |    Default | 135755.2 us |  67.5010 us | 63.1405 us |   1.66 |

The `MixManualInline` numbers show the regression quite clearly.  There's a 3-4% slowdown between 1.1 and 2.0 on x64 that holds up in 2.1  On x86 it gets significatntly worse with each newer version.  The `MixPreferred` job with the `AgressiveInlining` version of the mixing function does very poorly on 1.1 x86 but then shows basically the same results as the manually-inlined version everywhere else.

And here's the same benchmark run on an older Sandy Bridge Xeon server

```
BenchmarkDotNet=v0.10.14 OS=Windows 8.1 (6.3.9600.0)
Intel Xeon CPU E31230 3.20GHz 1 CPU 8 logical and 4 physical cores
Frequency=3117919 Hz Resolution=320.7267 ns Timer=TSC
.NET Core SDK=2.1.300
  [Host]        : .NET Core 2.1.0 (CoreCLR 4.6.26515.07 CoreFX 4.6.26515.06) 32bit RyuJIT
  netcoreapp1.1 : .NET Core 1.1.8 (CoreCLR 4.6.26328.01 CoreFX 4.6.24705.01) 64bit RyuJIT
  netcoreapp2.0 : .NET Core 2.0.7 (CoreCLR 4.6.26328.01 CoreFX 4.6.26403.03) 64bit RyuJIT
  netcoreapp2.1 : .NET Core 2.1.0 (CoreCLR 4.6.26515.07 CoreFX 4.6.26515.06) 64bit RyuJIT
```

Method |           Job | Platform | IsBaseline |       Mean |      Error |     StdDev |     Median | Scaled | ScaledSD |
---------------- |-------------- |--------- |----------- |-----------:|-----------:|-----------:|-----------:|-------:|---------:|
MixNoop | netcoreapp1.1 |      X64 |       True |   1.326 ms |  0.1071 ms |  0.3158 ms |   1.331 ms |   1.00 |     0.00 |
MixNoop | netcoreapp2.0 |      X64 |    Default |   1.288 ms |  0.1003 ms |  0.2957 ms |   1.285 ms |   1.03 |     0.36 |
MixNoop | netcoreapp2.1 |      X64 |    Default |   1.352 ms |  0.0928 ms |  0.2735 ms |   1.358 ms |   1.08 |     0.36 |
|               |          |            |            |            |            |            |        |          |
MixNoop | netcoreapp1.1 |      X86 |       True |   2.738 ms |  0.2200 ms |  0.6486 ms |   2.701 ms |   1.00 |     0.00 |
MixNoop | netcoreapp2.0 |      X86 |    Default |   2.673 ms |  0.2034 ms |  0.5998 ms |   2.826 ms |   1.04 |     0.36 |
MixNoop | netcoreapp2.1 |      X86 |    Default |   2.776 ms |  0.2096 ms |  0.6181 ms |   2.740 ms |   1.08 |     0.37 |
|               |          |            |            |            |            |            |        |          |
MixPreferred | netcoreapp1.1 |      X64 |       True |  31.926 ms |  2.2443 ms |  6.6172 ms |  32.740 ms |   1.00 |     0.00 |
MixPreferred | netcoreapp2.0 |      X64 |    Default |  31.898 ms |  2.1440 ms |  6.3216 ms |  31.735 ms |   1.05 |     0.33 |
MixPreferred | netcoreapp2.1 |      X64 |    Default |  27.419 ms |  2.4213 ms |  7.1393 ms |  25.538 ms |   0.90 |     0.32 |
|               |          |            |            |            |            |            |        |          |
MixPreferred | netcoreapp1.1 |      X86 |       True | 341.759 ms | 13.1190 ms | 38.4759 ms | 331.234 ms |   1.00 |     0.00 |
MixPreferred | netcoreapp2.0 |      X86 |    Default | 251.373 ms | 13.1463 ms | 38.3484 ms | 239.499 ms |   0.74 |     0.14 |
MixPreferred | netcoreapp2.1 |      X86 |    Default | 291.564 ms | 10.3316 ms | 29.6434 ms | 285.206 ms |   0.86 |     0.13 |
|               |          |            |            |            |            |            |        |          |
MixManualInline | netcoreapp1.1 |      X64 |       True |  33.165 ms |  2.2903 ms |  6.7529 ms |  33.426 ms |   1.00 |     0.00 |
MixManualInline | netcoreapp2.0 |      X64 |    Default |  33.819 ms |  2.4410 ms |  7.1973 ms |  34.340 ms |   1.07 |     0.34 |
MixManualInline | netcoreapp2.1 |      X64 |    Default |  20.601 ms |  0.1490 ms |  0.1394 ms |  20.606 ms |   0.65 |     0.15 |
|               |          |            |            |            |            |            |        |          |
MixManualInline | netcoreapp1.1 |      X86 |       True | 163.629 ms |  7.6584 ms | 22.3398 ms | 160.224 ms |   1.00 |     0.00 |
MixManualInline | netcoreapp2.0 |      X86 |    Default | 249.708 ms | 11.3452 ms | 32.7336 ms | 240.169 ms |   1.55 |     0.28 |
MixManualInline | netcoreapp2.1 |      X86 |    Default | 285.367 ms |  9.0883 ms | 25.6337 ms | 278.039 ms |   1.77 |     0.27 |

Here there are a few more outliers but it's the same general story.

Full code for the benchmarks is [here](https://github.com/saucecontrol/Blake2Fast/tree/master/tests/JitRegression) if anyone wants to try on different hardware.

category:cq
theme:optimization
skill-level:expert
cost:large</Title_Description>
    <Label>arch-x86</Label>
    <Assignee>pgavlin</Assignee>
    <CreatedAt>7/06/2018 3:58:38 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18338</IssueLabelID>
    <Title>CoreCLR failed when build with msvc on windows</Title>
    <Description>CoreCLR failed with warning C4644  when build with msvc on Windows I use latest source on master branch. The source code is ill-formed could you please help take a look at this?
Noted that this issue only found when compiles with unreleased vctoolset that next release of MSVC will have this behavior.

The probably fix: the project either needs to build with /wd4644 pragma push/pop the warning or do as the warning says and use the STL’s offsetof

You can repro this issue as the steps below:
1.git clone https://github.com/dotnet/coreclr D:\CoreCLR\src
2.Open a clean x86 prompt (C:\windows\syswow64\cmd.exe) and browse to D:\CoreCLR\src
3.build x86 release -Rebuild -- /clp:ShowCommandLine

Failures:
d:\coreclr\src\src\vm\i386\profiler.cpp(17210): warning C4644:  usage of the macro-based offsetof pattern in constant expressions is non-standard; use offsetof defined in the C++ standard library instead [D:\CoreCLR\src\bin\obj\Windows_NT.x86.Release\src\vm\wks\cee_wks.vcxproj]
d:\coreclr\src\src\vm\i386\profiler.cpp(17210): warning C4644:     case offsetof(ArgumentRegisters ECX): [D:\CoreCLR\src\bin\obj\Windows_NT.x86.Release\src\vm\wks\cee_wks.vcxproj]
d:\coreclr\src\src\vm\i386\profiler.cpp(17210): warning C4644:          ^ [D:\CoreCLR\src\bin\obj\Windows_NT.x86.Release\src\vm\wks\cee_wks.vcxproj]
d:\coreclr\src\src\vm\i386\profiler.cpp(17410): warning C4644:  usage of the macro-based offsetof pattern in constant expressions is non-standard; use offsetof defined in the C++ standard library instead [D:\CoreCLR\src\bin\obj\Windows_NT.x86.Release\src\vm\wks\cee_wks.vcxproj]
d:\coreclr\src\src\vm\i386\profiler.cpp(17410): warning C4644:     case offsetof(ArgumentRegisters EDX): [D:\CoreCLR\src\bin\obj\Windows_NT.x86.Release\src\vm\wks\cee_wks.vcxproj]
d:\coreclr\src\src\vm\i386\profiler.cpp(17410): warning C4644:          ^ [D:\CoreCLR\src\bin\obj\Windows_NT.x86.Release\src\vm\wks\cee_wks.vcxproj]
&lt;snip&gt;
[D:\CoreCLR\src\bin\obj\Windows_NT.x86.Release\src\vm\wks\cee_wks.vcxproj]
d:\coreclr\src\src\vm\i386\profiler.cpp(17210): error C2220:  warning treated as error - no 'object' file generated [D:\CoreCLR\src\bin\obj\Windows_NT.x86.Release\src\vm\wks\cee_wks.vcxproj]
d:\coreclr\src\src\vm\i386\profiler.cpp(17210): error C2220:     case offsetof(ArgumentRegisters ECX): [D:\CoreCLR\src\bin\obj\Windows_NT.x86.Release\src\vm\wks\cee_wks.vcxproj]
d:\coreclr\src\src\vm\i386\profiler.cpp(17210): error C2220:          ^ [D:\CoreCLR\src\bin\obj\Windows_NT.x86.Release\src\vm\wks\cee_wks.vcxproj]
</Description>
    <Title_Description>CoreCLR failed when build with msvc on windows CoreCLR failed with warning C4644  when build with msvc on Windows I use latest source on master branch. The source code is ill-formed could you please help take a look at this?
Noted that this issue only found when compiles with unreleased vctoolset that next release of MSVC will have this behavior.

The probably fix: the project either needs to build with /wd4644 pragma push/pop the warning or do as the warning says and use the STL’s offsetof

You can repro this issue as the steps below:
1.git clone https://github.com/dotnet/coreclr D:\CoreCLR\src
2.Open a clean x86 prompt (C:\windows\syswow64\cmd.exe) and browse to D:\CoreCLR\src
3.build x86 release -Rebuild -- /clp:ShowCommandLine

Failures:
d:\coreclr\src\src\vm\i386\profiler.cpp(17210): warning C4644:  usage of the macro-based offsetof pattern in constant expressions is non-standard; use offsetof defined in the C++ standard library instead [D:\CoreCLR\src\bin\obj\Windows_NT.x86.Release\src\vm\wks\cee_wks.vcxproj]
d:\coreclr\src\src\vm\i386\profiler.cpp(17210): warning C4644:     case offsetof(ArgumentRegisters ECX): [D:\CoreCLR\src\bin\obj\Windows_NT.x86.Release\src\vm\wks\cee_wks.vcxproj]
d:\coreclr\src\src\vm\i386\profiler.cpp(17210): warning C4644:          ^ [D:\CoreCLR\src\bin\obj\Windows_NT.x86.Release\src\vm\wks\cee_wks.vcxproj]
d:\coreclr\src\src\vm\i386\profiler.cpp(17410): warning C4644:  usage of the macro-based offsetof pattern in constant expressions is non-standard; use offsetof defined in the C++ standard library instead [D:\CoreCLR\src\bin\obj\Windows_NT.x86.Release\src\vm\wks\cee_wks.vcxproj]
d:\coreclr\src\src\vm\i386\profiler.cpp(17410): warning C4644:     case offsetof(ArgumentRegisters EDX): [D:\CoreCLR\src\bin\obj\Windows_NT.x86.Release\src\vm\wks\cee_wks.vcxproj]
d:\coreclr\src\src\vm\i386\profiler.cpp(17410): warning C4644:          ^ [D:\CoreCLR\src\bin\obj\Windows_NT.x86.Release\src\vm\wks\cee_wks.vcxproj]
&lt;snip&gt;
[D:\CoreCLR\src\bin\obj\Windows_NT.x86.Release\src\vm\wks\cee_wks.vcxproj]
d:\coreclr\src\src\vm\i386\profiler.cpp(17210): error C2220:  warning treated as error - no 'object' file generated [D:\CoreCLR\src\bin\obj\Windows_NT.x86.Release\src\vm\wks\cee_wks.vcxproj]
d:\coreclr\src\src\vm\i386\profiler.cpp(17210): error C2220:     case offsetof(ArgumentRegisters ECX): [D:\CoreCLR\src\bin\obj\Windows_NT.x86.Release\src\vm\wks\cee_wks.vcxproj]
d:\coreclr\src\src\vm\i386\profiler.cpp(17210): error C2220:          ^ [D:\CoreCLR\src\bin\obj\Windows_NT.x86.Release\src\vm\wks\cee_wks.vcxproj]
</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>RussKeldorph</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18337</IssueLabelID>
    <Title>Moves CurrentSystemTimeZone ICastable RegistryView and RegistryValueKind to shared</Title>
    <Description>1) As recommended in the comment [here](https://github.com/dotnet/coreclr/issues/17904#issuecomment-391056322) now that Hashtable is available in CoreLib we can undo the split on `CurrentSystemTimeZone` and move it completely to shared.

2) Moving `ICastable` was a pretty simple change.

3) `RegistryValueKind` and `RegistryView` changes were done by moving some Win32Native enums to Interop.Kernel32

Related to https://github.com/dotnet/corert/pull/5906

cc: @jkotas </Description>
    <Title_Description>Moves CurrentSystemTimeZone, ICastable, RegistryView and RegistryValueKind to shared 1) As recommended in the comment [here](https://github.com/dotnet/coreclr/issues/17904#issuecomment-391056322) now that Hashtable is available in CoreLib we can undo the split on `CurrentSystemTimeZone` and move it completely to shared.

2) Moving `ICastable` was a pretty simple change.

3) `RegistryValueKind` and `RegistryView` changes were done by moving some Win32Native enums to Interop.Kernel32

Related to https://github.com/dotnet/corert/pull/5906

cc: @jkotas </Title_Description>
    <Label>
    </Label>
    <Assignee>maryamariyan</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18332</IssueLabelID>
    <Title>Function erroneously returns null when compiled in release mode</Title>
    <Description>@leecow commented on [Wed Jun 06 2018](https://github.com/dotnet/corefx/issues/30173)

@jlwSL commented on [Wed Jun 06 2018](https://github.com/dotnet/core/issues/1663)

I've discovered a bug that causes a function to return null even if every possible return value is non-null. The issue does not happen if the project is compiled in debug mode. Please see the code attached that reproduces this issue.

```csharp
using System;
using System.Collections.Generic;

namespace DotNetBug
{
    internal class Foo : IDisposable
    {
        public void Dispose()
        {
        }
    }

    class Program
    {
        public static string Aargh()
        {
            using (var foo = new Foo())
            {
                foreach (var i in new List&lt;int&gt;())
                {
                    try
                    {
                        Console.WriteLine("here"); // This doesn't get printed
                    }
                    catch (Exception)
                    {
                        return "wibble";
                    }
                }
                foreach (var i in new List&lt;int&gt;())
                {
                }
            }
        
            return "wobble";
        }

        static void Main(string[] args)
        {
            Console.WriteLine(Aargh() == null);
        }
    }
}
```
The code above prints True.

For your information my system details are below:

```bash
$ dotnet --info
.NET Core SDK (reflecting any global.json):
 Version:   2.1.300
 Commit:    adab45bf0c

Runtime Environment:
 OS Name:     centos
 OS Version:  7
 OS Platform: Linux
 RID:         centos.7-x64
 Base Path:   /usr/share/dotnet/sdk/2.1.300/

Host (useful for support):
  Version: 2.1.0
  Commit:  caa7b7e2ba

.NET Core SDKs installed:
  2.1.300 [/usr/share/dotnet/sdk]

.NET Core runtimes installed:
  Microsoft.AspNetCore.All 2.1.0 [/usr/share/dotnet/shared/Microsoft.AspNetCore.All]
  Microsoft.AspNetCore.App 2.1.0 [/usr/share/dotnet/shared/Microsoft.AspNetCore.App]
  Microsoft.NETCore.App 2.1.0 [/usr/share/dotnet/shared/Microsoft.NETCore.App]

To install additional .NET Core runtimes or SDKs:
  https://aka.ms/dotnet-download
```

I can also reproduce the issue on Windows with a slightly older SDK and Host version:
```bash
$ dotnet --info
.NET Command Line Tools (2.1.201)

Product Information:
 Version:            2.1.201
 Commit SHA-1 hash:  7932dc6179

Runtime Environment:
 OS Name:     Windows
 OS Version:  10.0.17134
 OS Platform: Windows
 RID:         win10-x64
 Base Path:   C:\Program Files\dotnet\sdk\2.1.201\

Microsoft .NET Core Shared Framework Host

  Version  : 2.0.7
  Build    : 2d61d0b043915bc948ebf98836fefe9ba942be11
```

I tried to reproduce the issue targeting .NET Framework 4.5 and 4.6.1 and it worked correctly in both of those cases.


---

@leecow commented on [Wed Jun 06 2018](https://github.com/dotnet/core/issues/1663#issuecomment-395163136)

I ran your code on Mac Fedora 28 and a clean CentOS 7 image and all return `false`. Going to move this to the CoreFX to start. 



---

@0xd4d commented on [Wed Jun 06 2018](https://github.com/dotnet/corefx/issues/30173#issuecomment-395183992)

Looks like a jitter bug so coreclr is a better repo.

&gt; I ran your code on Mac Fedora 28 and a clean CentOS 7 image and all return false

Did you try Release builds?

</Description>
    <Title_Description>Function erroneously returns null when compiled in release mode @leecow commented on [Wed Jun 06 2018](https://github.com/dotnet/corefx/issues/30173)

@jlwSL commented on [Wed Jun 06 2018](https://github.com/dotnet/core/issues/1663)

I've discovered a bug that causes a function to return null even if every possible return value is non-null. The issue does not happen if the project is compiled in debug mode. Please see the code attached that reproduces this issue.

```csharp
using System;
using System.Collections.Generic;

namespace DotNetBug
{
    internal class Foo : IDisposable
    {
        public void Dispose()
        {
        }
    }

    class Program
    {
        public static string Aargh()
        {
            using (var foo = new Foo())
            {
                foreach (var i in new List&lt;int&gt;())
                {
                    try
                    {
                        Console.WriteLine("here"); // This doesn't get printed
                    }
                    catch (Exception)
                    {
                        return "wibble";
                    }
                }
                foreach (var i in new List&lt;int&gt;())
                {
                }
            }
        
            return "wobble";
        }

        static void Main(string[] args)
        {
            Console.WriteLine(Aargh() == null);
        }
    }
}
```
The code above prints True.

For your information my system details are below:

```bash
$ dotnet --info
.NET Core SDK (reflecting any global.json):
 Version:   2.1.300
 Commit:    adab45bf0c

Runtime Environment:
 OS Name:     centos
 OS Version:  7
 OS Platform: Linux
 RID:         centos.7-x64
 Base Path:   /usr/share/dotnet/sdk/2.1.300/

Host (useful for support):
  Version: 2.1.0
  Commit:  caa7b7e2ba

.NET Core SDKs installed:
  2.1.300 [/usr/share/dotnet/sdk]

.NET Core runtimes installed:
  Microsoft.AspNetCore.All 2.1.0 [/usr/share/dotnet/shared/Microsoft.AspNetCore.All]
  Microsoft.AspNetCore.App 2.1.0 [/usr/share/dotnet/shared/Microsoft.AspNetCore.App]
  Microsoft.NETCore.App 2.1.0 [/usr/share/dotnet/shared/Microsoft.NETCore.App]

To install additional .NET Core runtimes or SDKs:
  https://aka.ms/dotnet-download
```

I can also reproduce the issue on Windows with a slightly older SDK and Host version:
```bash
$ dotnet --info
.NET Command Line Tools (2.1.201)

Product Information:
 Version:            2.1.201
 Commit SHA-1 hash:  7932dc6179

Runtime Environment:
 OS Name:     Windows
 OS Version:  10.0.17134
 OS Platform: Windows
 RID:         win10-x64
 Base Path:   C:\Program Files\dotnet\sdk\2.1.201\

Microsoft .NET Core Shared Framework Host

  Version  : 2.0.7
  Build    : 2d61d0b043915bc948ebf98836fefe9ba942be11
```

I tried to reproduce the issue targeting .NET Framework 4.5 and 4.6.1 and it worked correctly in both of those cases.


---

@leecow commented on [Wed Jun 06 2018](https://github.com/dotnet/core/issues/1663#issuecomment-395163136)

I ran your code on Mac Fedora 28 and a clean CentOS 7 image and all return `false`. Going to move this to the CoreFX to start. 



---

@0xd4d commented on [Wed Jun 06 2018](https://github.com/dotnet/corefx/issues/30173#issuecomment-395183992)

Looks like a jitter bug so coreclr is a better repo.

&gt; I ran your code on Mac Fedora 28 and a clean CentOS 7 image and all return false

Did you try Release builds?

</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18330</IssueLabelID>
    <Title>Metrics "framework" for JIT</Title>
    <Description>While hacking the JIT quite often I end up with a simple question - "how many time does X happen?":
* How many JCC instructions are generated?
* How many side effects trees are extracted?
* How many range checks are encountered/removed?

So I end up adding variables `printf`s and what not. And it's always a quick improvisation done to be used once and then thrown away.

I think it would be useful to have some basic metrics framework in the JIT that would let people to simply add a line like:
```C++
metrics.Increment("ExtractedSideEffect");
```
pretty much anywhere in the JIT code and have such counters dumped to the console like mem stats are. Or included in disassembly comments so that they show up in diffs and maybe be used by jit-analyze.

Counters should be collected per method and if possible per phase as well. And of course some basic aggregations should be included as well.

The API should be as easy to use as possible - the above example shows the use of a string as a counter identifier (so I guess the implementation would be using these strings as a hashtable key). This would avoid the need to add a new enum member - such an enum typically resides in a header that when changed triggers the compilation of all JIT files.  Of course an enum based overload could also provided that would be useful for counters that are useful long term.

@dotnet/jit-contrib Thoughts?

category:implementation
theme:jit-coding-style
skill-level:beginner
cost:medium</Description>
    <Title_Description>Metrics "framework" for JIT While hacking the JIT quite often I end up with a simple question - "how many time does X happen?":
* How many JCC instructions are generated?
* How many side effects trees are extracted?
* How many range checks are encountered/removed?

So I end up adding variables `printf`s and what not. And it's always a quick improvisation done to be used once and then thrown away.

I think it would be useful to have some basic metrics framework in the JIT that would let people to simply add a line like:
```C++
metrics.Increment("ExtractedSideEffect");
```
pretty much anywhere in the JIT code and have such counters dumped to the console like mem stats are. Or included in disassembly comments so that they show up in diffs and maybe be used by jit-analyze.

Counters should be collected per method and if possible per phase as well. And of course some basic aggregations should be included as well.

The API should be as easy to use as possible - the above example shows the use of a string as a counter identifier (so I guess the implementation would be using these strings as a hashtable key). This would avoid the need to add a new enum member - such an enum typically resides in a header that when changed triggers the compilation of all JIT files.  Of course an enum based overload could also provided that would be useful for counters that are useful long term.

@dotnet/jit-contrib Thoughts?

category:implementation
theme:jit-coding-style
skill-level:beginner
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>pgavlin</Assignee>
    <CreatedAt>6/06/2018 7:48:51 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18328</IssueLabelID>
    <Title>Fix issue in Compiler::impImportStaticFieldAccess</Title>
    <Description>When CORINFO_FIELD_STATIC_SHARED_STATIC_HELPER accessor is being processed for
structs the method creates a GT_IND node instead of GT_OBJ node. For structs
that can be normalized to a specific type (like TYP_SIMD8) it causes an assert
in Compiler::impNormStructVal in the switch case for GT_IND.

This change modifies the node creation to work the same way as in the default
case for accessors creating GT_OBJ for structs and GT_IND otherwise.</Description>
    <Title_Description>Fix issue in Compiler::impImportStaticFieldAccess When CORINFO_FIELD_STATIC_SHARED_STATIC_HELPER accessor is being processed for
structs the method creates a GT_IND node instead of GT_OBJ node. For structs
that can be normalized to a specific type (like TYP_SIMD8) it causes an assert
in Compiler::impNormStructVal in the switch case for GT_IND.

This change modifies the node creation to work the same way as in the default
case for accessors creating GT_OBJ for structs and GT_IND otherwise.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>janvorli</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18327</IssueLabelID>
    <Title>Excessive/strange null reference checks after method inlining</Title>
    <Description>Consider the following repro example (this is actually from the live system just narrowed down significantly):

```
        interface ISortKeyOps&lt;TComparableKeyPart&gt;
        {
            TComparableKeyPart EmptyComparableKeyPart { get; }
            byte GetComparableKeyPartsLCPInfo(TComparableKeyPart left ref TComparableKeyPart right);
        }

        struct SortKeyOps_UInt64 : ISortKeyOps&lt;ulong&gt;
        {
            public ulong EmptyComparableKeyPart { get { return 0; } }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public byte GetComparableKeyPartsLCPInfo(ulong left ref ulong right) =&gt; 0x42;
        }

        struct SortKeysClassifier&lt;TKeyOps TComparableKeyPart&gt;
            where TKeyOps : ISortKeyOps&lt;TComparableKeyPart&gt;
            where TComparableKeyPart : struct
        {
            TKeyOps KeyOps;
            ulong CurrentKeyPartOfst;
            TComparableKeyPart[] SplittersTree;

            public SortKeysClassifier(TKeyOps keyOps)
            {
                KeyOps = keyOps;
                CurrentKeyPartOfst = 5;
                SplittersTree = new TComparableKeyPart[0];
            }

            unsafe public byte Build()
            {
                var emptyKey = KeyOps.EmptyComparableKeyPart;
                return KeyOps.GetComparableKeyPartsLCPInfo(KeyOps.EmptyComparableKeyPart ref emptyKey);
            }
        }

        unsafe static void Main(string[] args)
        {
            var keyOps = new SortKeyOps_UInt64();
            var c = new SortKeysClassifier&lt;SortKeyOps_UInt64 ulong&gt;(keyOps);
            var v = c.Build();
            Console.WriteLine(v);
        }
```

When the nested code within method `Build()` is inlined with .NET Core 2.1 (preview/RC/RTM) JIT the following machine code is observed:

```
--- ...\Program2.cs ---
                var emptyKey = KeyOps.EmptyComparableKeyPart;
000007FE69DF1850  cmp         dword ptr [rcx]ecx  
                return KeyOps.GetComparableKeyPartsLCPInfo(KeyOps.EmptyComparableKeyPart ref emptyKey);
000007FE69DF1852  cmp         dword ptr [rcx]ecx  
000007FE69DF1854  cmp         dword ptr [rcx]ecx  
000007FE69DF1856  mov         eax42h  
000007FE69DF185B  ret  
--- No source file -------------------------------------------------------------
```

Although the code works (disregarding penalty for unneeded operations) there are certain unclarities about this:

1. It is unclear why checking for null reference more than once (if at all) if `this` stored in `ECX` never changes. To add to this - I've seen up to 8-10 such null reference checks stacked when complex expression is involved in full production code.
2. [The strangest one] *ALL* null checks disappear if I remove field `SplittersTree` and all references to it from structure.

category:cq
theme:value-numbering
skill-level:expert
cost:medium</Description>
    <Title_Description>Excessive/strange null reference checks after method inlining Consider the following repro example (this is actually from the live system just narrowed down significantly):

```
        interface ISortKeyOps&lt;TComparableKeyPart&gt;
        {
            TComparableKeyPart EmptyComparableKeyPart { get; }
            byte GetComparableKeyPartsLCPInfo(TComparableKeyPart left ref TComparableKeyPart right);
        }

        struct SortKeyOps_UInt64 : ISortKeyOps&lt;ulong&gt;
        {
            public ulong EmptyComparableKeyPart { get { return 0; } }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public byte GetComparableKeyPartsLCPInfo(ulong left ref ulong right) =&gt; 0x42;
        }

        struct SortKeysClassifier&lt;TKeyOps TComparableKeyPart&gt;
            where TKeyOps : ISortKeyOps&lt;TComparableKeyPart&gt;
            where TComparableKeyPart : struct
        {
            TKeyOps KeyOps;
            ulong CurrentKeyPartOfst;
            TComparableKeyPart[] SplittersTree;

            public SortKeysClassifier(TKeyOps keyOps)
            {
                KeyOps = keyOps;
                CurrentKeyPartOfst = 5;
                SplittersTree = new TComparableKeyPart[0];
            }

            unsafe public byte Build()
            {
                var emptyKey = KeyOps.EmptyComparableKeyPart;
                return KeyOps.GetComparableKeyPartsLCPInfo(KeyOps.EmptyComparableKeyPart ref emptyKey);
            }
        }

        unsafe static void Main(string[] args)
        {
            var keyOps = new SortKeyOps_UInt64();
            var c = new SortKeysClassifier&lt;SortKeyOps_UInt64 ulong&gt;(keyOps);
            var v = c.Build();
            Console.WriteLine(v);
        }
```

When the nested code within method `Build()` is inlined with .NET Core 2.1 (preview/RC/RTM) JIT the following machine code is observed:

```
--- ...\Program2.cs ---
                var emptyKey = KeyOps.EmptyComparableKeyPart;
000007FE69DF1850  cmp         dword ptr [rcx]ecx  
                return KeyOps.GetComparableKeyPartsLCPInfo(KeyOps.EmptyComparableKeyPart ref emptyKey);
000007FE69DF1852  cmp         dword ptr [rcx]ecx  
000007FE69DF1854  cmp         dword ptr [rcx]ecx  
000007FE69DF1856  mov         eax42h  
000007FE69DF185B  ret  
--- No source file -------------------------------------------------------------
```

Although the code works (disregarding penalty for unneeded operations) there are certain unclarities about this:

1. It is unclear why checking for null reference more than once (if at all) if `this` stored in `ECX` never changes. To add to this - I've seen up to 8-10 such null reference checks stacked when complex expression is involved in full production code.
2. [The strangest one] *ALL* null checks disappear if I remove field `SplittersTree` and all references to it from structure.

category:cq
theme:value-numbering
skill-level:expert
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>6/06/2018 6:27:55 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18324</IssueLabelID>
    <Title>JIT has run out of instruction bits in instrDesc</Title>
    <Description>We have 9 bits for the instruction field and `INS_count` is now 515. It's not clear how come we didn't hit any asserts yet it might be because the last instructions are long jumps and `INS_align`. Long jumps do not appear to be used and `INS_align` is probably only used with the "align loops" option.
</Description>
    <Title_Description>JIT has run out of instruction bits in instrDesc We have 9 bits for the instruction field and `INS_count` is now 515. It's not clear how come we didn't hit any asserts yet it might be because the last instructions are long jumps and `INS_align`. Long jumps do not appear to be used and `INS_align` is probably only used with the "align loops" option.
</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>pgavlin</Assignee>
    <CreatedAt>6/06/2018 3:06:50 PM +00:00</CreatedAt>
    <ClosedAt>7/06/2018 11:58:04 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18323</IssueLabelID>
    <Title>Unreproducible InvalidProgramExceptions at random places</Title>
    <Description>Our .NET Core Web Apps running on Azure App Service occasionally start throwing InvalidProgramExceptions at seemly random places in code. For example see the following stack traces:

On .NET Core 2.0:

* https://gist.github.com/chrarnoldus/bc4362ff1b4df11b34d2407f0131a607
* https://gist.github.com/chrarnoldus/f7ceab63117c33a3be8c6128815b7cdb (see inner exception)
* https://gist.github.com/chrarnoldus/101c99d0b14f5ad7e572670ffe913f74

On .NET Core 2.1 so the issue doesn't seem toe be fixed:

* https://gist.github.com/chrarnoldus/d4da9436c575f453e46043aa9b062353 (see inner exception)

Due to the unpredictable nature of these exceptions I suspect the problem is in the runtime and not in the ASP.NET Core libraries used. In all of the cases the exception continued to be thrown every time the affected code was executed. The problem disappears after restarting the process so I don't have steps to reproduce it. I do have memory dumps that were captured by the Application Insights Snapshot Collector. If a Microsoft employee is interested in analysing those in the understanding that they probably contain sensitive data please contact me using the email in my profile.
</Description>
    <Title_Description>Unreproducible InvalidProgramExceptions at random places Our .NET Core Web Apps running on Azure App Service occasionally start throwing InvalidProgramExceptions at seemly random places in code. For example see the following stack traces:

On .NET Core 2.0:

* https://gist.github.com/chrarnoldus/bc4362ff1b4df11b34d2407f0131a607
* https://gist.github.com/chrarnoldus/f7ceab63117c33a3be8c6128815b7cdb (see inner exception)
* https://gist.github.com/chrarnoldus/101c99d0b14f5ad7e572670ffe913f74

On .NET Core 2.1 so the issue doesn't seem toe be fixed:

* https://gist.github.com/chrarnoldus/d4da9436c575f453e46043aa9b062353 (see inner exception)

Due to the unpredictable nature of these exceptions I suspect the problem is in the runtime and not in the ASP.NET Core libraries used. In all of the cases the exception continued to be thrown every time the affected code was executed. The problem disappears after restarting the process so I don't have steps to reproduce it. I do have memory dumps that were captured by the Application Insights Snapshot Collector. If a Microsoft employee is interested in analysing those in the understanding that they probably contain sensitive data please contact me using the email in my profile.
</Title_Description>
    <Label>
    </Label>
    <Assignee>leculver</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18321</IssueLabelID>
    <Title>setup-stress-dependencies.cmd failing</Title>
    <Description>This is causing x86 GCStress testing to fail.

https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/x86_checked_windows_nt_gcstress0xc/

e.g.

https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/x86_checked_windows_nt_gcstress0xc/83/consoleText
```
Downloading CoreDisTools package
"D:\j\workspace\x86_checked_w---e5963ece\tests\..\Tools\dotnetcli\dotnet.exe " restore "D:\j\workspace\x86_checked_w---e5963ece\tests\\src\Common\stress_dependencies\stress_dependencies.csproj" --source https://dotnet.myget.org/F/dotnet-core/ --packages "D:\j\workspace\x86_checked_w---e5963ece\tests\..\Packages"
  Restoring packages for D:\j\workspace\x86_checked_w---e5963ece\tests\src\Common\stress_dependencies\stress_dependencies.csproj...
  Installing Microsoft.NETCore.CoreDisTools 1.0.1-prerelease-00003.
  Generating MSBuild file D:\j\workspace\x86_checked_w---e5963ece\tests\src\Common\stress_dependencies\obj\stress_dependencies.csproj.nuget.g.props.
  Generating MSBuild file D:\j\workspace\x86_checked_w---e5963ece\tests\src\Common\stress_dependencies\obj\stress_dependencies.csproj.nuget.g.targets.
  Restore completed in 1.38 sec for D:\j\workspace\x86_checked_w---e5963ece\tests\src\Common\stress_dependencies\stress_dependencies.csproj.
Locating coredistools.dll
CoreDisTools library path: 
Failed to locate the downloaded library: 
```
</Description>
    <Title_Description>setup-stress-dependencies.cmd failing This is causing x86 GCStress testing to fail.

https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/x86_checked_windows_nt_gcstress0xc/

e.g.

https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/x86_checked_windows_nt_gcstress0xc/83/consoleText
```
Downloading CoreDisTools package
"D:\j\workspace\x86_checked_w---e5963ece\tests\..\Tools\dotnetcli\dotnet.exe " restore "D:\j\workspace\x86_checked_w---e5963ece\tests\\src\Common\stress_dependencies\stress_dependencies.csproj" --source https://dotnet.myget.org/F/dotnet-core/ --packages "D:\j\workspace\x86_checked_w---e5963ece\tests\..\Packages"
  Restoring packages for D:\j\workspace\x86_checked_w---e5963ece\tests\src\Common\stress_dependencies\stress_dependencies.csproj...
  Installing Microsoft.NETCore.CoreDisTools 1.0.1-prerelease-00003.
  Generating MSBuild file D:\j\workspace\x86_checked_w---e5963ece\tests\src\Common\stress_dependencies\obj\stress_dependencies.csproj.nuget.g.props.
  Generating MSBuild file D:\j\workspace\x86_checked_w---e5963ece\tests\src\Common\stress_dependencies\obj\stress_dependencies.csproj.nuget.g.targets.
  Restore completed in 1.38 sec for D:\j\workspace\x86_checked_w---e5963ece\tests\src\Common\stress_dependencies\stress_dependencies.csproj.
Locating coredistools.dll
CoreDisTools library path: 
Failed to locate the downloaded library: 
```
</Title_Description>
    <Label>arch-x86</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>6/06/2018 12:59:28 AM +00:00</CreatedAt>
    <ClosedAt>8/06/2018 10:27:20 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18319</IssueLabelID>
    <Title>Classic EventSources don't work in Release builds using .NET Native (UWP)</Title>
    <Description>Michael Taron  reported this on 6/5/2018 via E-mail to @vancem and @brianrob 

To repro using VS create the 'Blank UWP app' and add the following EventSource
```
[EventSource(Name = "Microsoft-StickyNotes")]
public class NoteEventSource : EventSource
{
      public static readonly NoteEventSource Log = new NoteEventSource();
      private NoteEventSource()
      {
      }
      public void AppConstructed() { WriteEvent(1); }
      public void AppSuspended() { WriteEvent(2); }
      public void BootStart() { WriteEvent(3); }
      public void BootStop() { WriteEvent(4); }
}
```
Then add NoteEventSource.Log.AppConstructed() or the other methods to the OnLaunched method.
Use 

PerfView /Providers=*Microsoft-StickyNotes collect

to collect a trace.  You will find that the manifest information is not generated IF YOU USE THE RELEASE BUILD (works OK on debug build).  
```
Event Name | Time MSec | Process Name | Rest
Provider(b8642b6a-9359-532e-c9dc-fccbe92b98b0)/EventID(1) | 2945.520 | TestUWPApp (34364) | ThreadID="42024" ProcessorNumber="6"
Provider(b8642b6a-9359-532e-c9dc-fccbe92b98b0)/EventID(3) | 2945.757 | TestUWPApp (34364) | ThreadID="42024" ProcessorNumber="6"
Provider(b8642b6a-9359-532e-c9dc-fccbe92b98b0)/EventID(4) | 2949.862 | TestUWPApp (34364) | ThreadID="42024" ProcessorNumber="4"   DURATION_MSEC="4.105"
```

Note that I tried using 
```
        public NoteEventSource() : base(EventSourceSettings.EtwSelfDescribingEventFormat) { }
```
To make the EventSource use self-describing events but that causes a Exception to be thrown (**this seems like an independent but that is also worth fixing**).  

This bug is meant to track this issue (Note it is a .NET Native issue not a .NET Core issue
@brianrob 

</Description>
    <Title_Description>Classic EventSources don't work in Release builds using .NET Native (UWP) Michael Taron  reported this on 6/5/2018 via E-mail to @vancem and @brianrob 

To repro using VS create the 'Blank UWP app' and add the following EventSource
```
[EventSource(Name = "Microsoft-StickyNotes")]
public class NoteEventSource : EventSource
{
      public static readonly NoteEventSource Log = new NoteEventSource();
      private NoteEventSource()
      {
      }
      public void AppConstructed() { WriteEvent(1); }
      public void AppSuspended() { WriteEvent(2); }
      public void BootStart() { WriteEvent(3); }
      public void BootStop() { WriteEvent(4); }
}
```
Then add NoteEventSource.Log.AppConstructed() or the other methods to the OnLaunched method.
Use 

PerfView /Providers=*Microsoft-StickyNotes collect

to collect a trace.  You will find that the manifest information is not generated IF YOU USE THE RELEASE BUILD (works OK on debug build).  
```
Event Name | Time MSec | Process Name | Rest
Provider(b8642b6a-9359-532e-c9dc-fccbe92b98b0)/EventID(1) | 2945.520 | TestUWPApp (34364) | ThreadID="42024" ProcessorNumber="6"
Provider(b8642b6a-9359-532e-c9dc-fccbe92b98b0)/EventID(3) | 2945.757 | TestUWPApp (34364) | ThreadID="42024" ProcessorNumber="6"
Provider(b8642b6a-9359-532e-c9dc-fccbe92b98b0)/EventID(4) | 2949.862 | TestUWPApp (34364) | ThreadID="42024" ProcessorNumber="4"   DURATION_MSEC="4.105"
```

Note that I tried using 
```
        public NoteEventSource() : base(EventSourceSettings.EtwSelfDescribingEventFormat) { }
```
To make the EventSource use self-describing events but that causes a Exception to be thrown (**this seems like an independent but that is also worth fixing**).  

This bug is meant to track this issue (Note it is a .NET Native issue not a .NET Core issue
@brianrob 

</Title_Description>
    <Label>area-Tracing</Label>
    <Assignee>vancem</Assignee>
    <CreatedAt>6/06/2018 12:07:58 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18316</IssueLabelID>
    <Title>Force short date pattern to use yyyy on Linux</Title>
    <Description>The default pattern we get is using yy which causes the years to be displayed as 2 digits. This is not acceptable for many users. The fix here is to force 4-digit year as a default and still keep the original pattern which has 2-digit year in the optional list</Description>
    <Title_Description>Force short date pattern to use yyyy on Linux The default pattern we get is using yy which causes the years to be displayed as 2 digits. This is not acceptable for many users. The fix here is to force 4-digit year as a default and still keep the original pattern which has 2-digit year in the optional list</Title_Description>
    <Label>
    </Label>
    <Assignee>tarekgh</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18315</IssueLabelID>
    <Title>Assertion failed 'killMask == getKillSetForNode(tree)' lsrabuild.cpp</Title>
    <Description>Was caused by #16517.
</Description>
    <Title_Description>Assertion failed 'killMask == getKillSetForNode(tree)' lsrabuild.cpp Was caused by #16517.
</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18312</IssueLabelID>
    <Title>Increase timeout and log the result for some WaitAny tests that expect AbandonedMutexException</Title>
    <Description>Follow-up to https://github.com/dotnet/coreclr/pull/13298 missed a few cases.</Description>
    <Title_Description>Increase timeout and log the result for some WaitAny tests that expect AbandonedMutexException Follow-up to https://github.com/dotnet/coreclr/pull/13298 missed a few cases.</Title_Description>
    <Label>area-System.Threading</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18309</IssueLabelID>
    <Title>[release/2.1] Use WChar instead of char</Title>
    <Description>Use WCHAR to avoid truncate -- pTarget is WCHAR*.

This PR is for 2.1 servicing.

Fix: #18269</Description>
    <Title_Description>[release/2.1] Use WChar instead of char Use WCHAR to avoid truncate -- pTarget is WCHAR*.

This PR is for 2.1 servicing.

Fix: #18269</Title_Description>
    <Label>
    </Label>
    <Assignee>luqunl</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18307</IssueLabelID>
    <Title>Alpine Linux coreclr dac dbi not honoring PAL symbol versions</Title>
    <Description>The loader on Alpine links the libmscordbi.so PAL references to libvsbaseservices.so (which contains VS's debug engine PAL) instead of the the PAL in libmscordaccore.so.

On Alpine Linux the export PAL APIs from the DAC need to have a module specific prefix added so the loader links to the right module/PAL.</Description>
    <Title_Description>Alpine Linux coreclr, dac, dbi not honoring PAL symbol versions The loader on Alpine links the libmscordbi.so PAL references to libvsbaseservices.so (which contains VS's debug engine PAL) instead of the the PAL in libmscordaccore.so.

On Alpine Linux the export PAL APIs from the DAC need to have a module specific prefix added so the loader links to the right module/PAL.</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>mikem8361</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18305</IssueLabelID>
    <Title>Skip old time zones adjustments with offsets higher than 14h</Title>
    <Description>Fixes: https://github.com/dotnet/corefx/issues/29820
Tested locally with original repro.

Some old time zones (i.e. Asia/Manilla - see comment in the code for more examples) had adjustment higher than our max expected value 14h. Because of compatibility with SQL server concerns we cannot change the max value (i.e. Windows does not have that data at all). Last known adjustment with offset larger than 14h is in year 1900.</Description>
    <Title_Description>Skip old time zones adjustments with offsets higher than 14h Fixes: https://github.com/dotnet/corefx/issues/29820
Tested locally with original repro.

Some old time zones (i.e. Asia/Manilla - see comment in the code for more examples) had adjustment higher than our max expected value 14h. Because of compatibility with SQL server concerns we cannot change the max value (i.e. Windows does not have that data at all). Last known adjustment with offset larger than 14h is in year 1900.</Title_Description>
    <Label>
    </Label>
    <Assignee>tarekgh</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18300</IssueLabelID>
    <Title>Sse2.Set[All]Vector128([u]long [u]long) crashes with PNSE when run in 32-bit process</Title>
    <Description>My guess is - these method have managed implementation behind them involving `ConvertScalarToVector128[U]Int64()` (`MOVQ xmm r64`) unavailable in 32-bit mode.
Since these are all just helper methods not necessarily mapped to some specific HW intrinsic directly my understanding is that the implementation should behave considering current process bitness - eg. use set of 32-bit HW intrinsics to setup the result when in 32-bit mode.</Description>
    <Title_Description>Sse2.Set[All]Vector128([u]long, [u]long) crashes with PNSE when run in 32-bit process My guess is - these method have managed implementation behind them involving `ConvertScalarToVector128[U]Int64()` (`MOVQ xmm r64`) unavailable in 32-bit mode.
Since these are all just helper methods not necessarily mapped to some specific HW intrinsic directly my understanding is that the implementation should behave considering current process bitness - eg. use set of 32-bit HW intrinsics to setup the result when in 32-bit mode.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
    <CreatedAt>5/06/2018 3:34:28 PM +00:00</CreatedAt>
    <ClosedAt>6/12/2018 7:50:41 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18299</IssueLabelID>
    <Title>Methods with operations on pointers to unmanaged type (T* where T: unmanaged) not getting inlined</Title>
    <Description>VS 15.7.3 .NET Framework 4.7.2

```csharp
namespace ConsoleApp3
{
	class Program
	{
		static void Main(string[] args)
		{
			var summary = BenchmarkRunner.Run&lt;Test&gt;();
		}
	}

	[DisassemblyDiagnoser(printAsm: true printSource: true printPrologAndEpilog: false recursiveDepth: 2)]
	public class Test
	{
		[Benchmark]
		public unsafe ulong Run1()
		{
			var length = 1024;
			ulong res = 0;
			var data = stackalloc byte[length];
			var pdata = new Ptr1&lt;byte&gt;(data);
			for (int i = 0; i &lt; 10000; i++)
			{
				res += (ulong)Method1(ref pdata length);
			}
			return res;
		}

		[Benchmark]
		public unsafe ulong Run2()
		{
			var length = 1024;
			ulong res = 0;
			var data = stackalloc byte[length];
			var pdata = new Ptr2&lt;byte&gt;(data);
			for (int i = 0; i &lt; 10000; i++)
			{
				res += (ulong)Method2(ref pdata length);
			}
			return res;
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		public int Method1(ref Ptr1&lt;byte&gt; data int length)
		{
			var i = 0;
			var res = 0;
			do
			{
				data.Ref = (byte)(data.Ref + data[i++]);
				res += data.Ref;
			} while (--length != 0);
			return res;
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		public int Method2(ref Ptr2&lt;byte&gt; data int length)
		{
			var i = 0;
			var res = 0;
			do
			{
				data.Ref = (byte)(data.Ref + data[i++]);
				res += data.Ref;
			} while (--length != 0);
			return res;
		}
	}

	public unsafe struct Ptr1&lt;T&gt; where T : unmanaged
	{
		private readonly T* _nptr;

		public Ptr1(void* nptr) =&gt; _nptr = (T*)nptr;

		public ref T Ref
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get { return ref *(_nptr); }
		}

		public ref T this[int offset]
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get { return ref *(_nptr + offset); }
		}
	}

	public unsafe struct Ptr2&lt;T&gt; where T : unmanaged
	{
		private static readonly int TSize = Unsafe.SizeOf&lt;T&gt;();
		private readonly byte* _nptr;

		public Ptr2(void* nptr) =&gt; _nptr = (byte*) nptr;
		
		public ref T Ref
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get {return ref Unsafe.AsRef&lt;T&gt;(_nptr); }
		}

		public ref T this[int offset] 
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get { return ref Unsafe.AsRef&lt;T&gt;(_nptr + offset * TSize); }
		}
	}
}
```

Disassembly output for `Run1` benchmark:

```asm
;ConsoleApp3.Test.Run1()  
 xor     ediedi 
 add     rsp20h 
 mov     edx40h 
M00_L00   
 push    0 
 push    0 
 dec     rdx 
 jne     M00_L00 
 sub     rsp20h 
 lea     rdx[rsp+20h] 
 mov     qword ptr [rbp+10h]rsp 
 mov     qword ptr [rbp+8]rdx 
 xor     ebxebx 
M00_L01   
 lea     rdx[rbp+8] 
 mov     rcxrsi 
 mov     r8d400h 
 call    ConsoleApp3.Test.Method1(ConsoleApp3.Ptr1`1 ByRef Int32) 
 movsxd  raxeax 
 add     rdirax 
 inc     ebx 
 cmp     ebx2710h 
 jl      M00_L01 
 mov     raxrdi 
  
;ConsoleApp3.Test.Method1(ConsoleApp3.Ptr1`1 ByRef Int32)  
 xor     ebxebx 
 xor     ebpebp 
M01_L00   
 mov     rcxrsi 
 call    ConsoleApp3.Ptr1`1[[System.Byte mscorlib]].get_Ref() 
 mov     r14rax 
 lea     ecx[rbx+1] 
 mov     r15decx 
 mov     rcxrsi 
 call    ConsoleApp3.Ptr1`1[[System.Byte mscorlib]].get_Ref() 
 movzx   r12dbyte ptr [rax] 
 mov     rcxrsi 
 mov     edxebx 
 call    ConsoleApp3.Ptr1`1[[System.Byte mscorlib]].get_Item(Int32) 
 movzx   ecxbyte ptr [rax] 
 add     ecxr12d 
 mov     byte ptr [r14]cl 
 mov     rcxrsi 
 call    ConsoleApp3.Ptr1`1[[System.Byte mscorlib]].get_Ref() 
 movzx   eaxbyte ptr [rax] 
 add     ebpeax 
 dec     edi 
 test    ediedi 
 mov     ebxr15d 
 jne     M01_L00 
 mov     eaxebp 
  
;ConsoleApp3.Ptr1`1[[System.Byte mscorlib]].get_Ref()  
 mov     raxqword ptr [rcx] 
  
;ConsoleApp3.Ptr1`1[[System.Byte mscorlib]].get_Item(Int32)  
 movsxd  raxedx 
 add     raxqword ptr [rcx] 
```

Disassembly output for `Run2` benchmark:

```asm
;ConsoleApp3.Test.Run2()  
 xor     ediedi 
 add     rsp20h 
 mov     edx40h 
M00_L00   
 push    0 
 push    0 
 dec     rdx 
 jne     M00_L00 
 sub     rsp20h 
 lea     rdx[rsp+20h] 
 mov     qword ptr [rbp+10h]rsp 
 mov     qword ptr [rbp+8]rdx 
 xor     ebxebx 
M00_L01   
 lea     rdx[rbp+8] 
 mov     rcxrsi 
 mov     r8d400h 
 call    ConsoleApp3.Test.Method2(ConsoleApp3.Ptr2`1 ByRef Int32) 
 movsxd  raxeax 
 add     rdirax 
 inc     ebx 
 cmp     ebx2710h 
 jl      M00_L01 
 mov     raxrdi 
  
;ConsoleApp3.Test.Method2(ConsoleApp3.Ptr2`1 ByRef Int32)  
 xor     eaxeax 
 xor     ecxecx 
M01_L00   
 mov     r9qword ptr [rdx] 
 mov     r10r9 
 mov     r11r9 
 lea     esi[rax+1] 
 movzx   r11dbyte ptr [r11] 
 movsxd  raxeax 
 add     raxr9 
 movzx   eaxbyte ptr [rax] 
 add     r11deax 
 mov     byte ptr [r10]r11b 
 mov     raxqword ptr [rdx] 
 movzx   eaxbyte ptr [rax] 
 add     ecxeax 
 dec     r8d 
 test    r8dr8d 
 mov     eaxesi 
 jne     M01_L00 
 mov     eaxecx 
```

Results:

```
| Method |     Mean |     Error |    StdDev |
|------- |---------:|----------:|----------:|
|   Run1 | 80.98 ms | 0.9829 ms | 0.8713 ms |
|   Run2 | 20.79 ms | 0.0431 ms | 0.0337 ms |
</Description>
    <Title_Description>Methods with operations on pointers to unmanaged type (T*, where T: unmanaged) not getting inlined VS 15.7.3 .NET Framework 4.7.2

```csharp
namespace ConsoleApp3
{
	class Program
	{
		static void Main(string[] args)
		{
			var summary = BenchmarkRunner.Run&lt;Test&gt;();
		}
	}

	[DisassemblyDiagnoser(printAsm: true printSource: true printPrologAndEpilog: false recursiveDepth: 2)]
	public class Test
	{
		[Benchmark]
		public unsafe ulong Run1()
		{
			var length = 1024;
			ulong res = 0;
			var data = stackalloc byte[length];
			var pdata = new Ptr1&lt;byte&gt;(data);
			for (int i = 0; i &lt; 10000; i++)
			{
				res += (ulong)Method1(ref pdata length);
			}
			return res;
		}

		[Benchmark]
		public unsafe ulong Run2()
		{
			var length = 1024;
			ulong res = 0;
			var data = stackalloc byte[length];
			var pdata = new Ptr2&lt;byte&gt;(data);
			for (int i = 0; i &lt; 10000; i++)
			{
				res += (ulong)Method2(ref pdata length);
			}
			return res;
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		public int Method1(ref Ptr1&lt;byte&gt; data int length)
		{
			var i = 0;
			var res = 0;
			do
			{
				data.Ref = (byte)(data.Ref + data[i++]);
				res += data.Ref;
			} while (--length != 0);
			return res;
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		public int Method2(ref Ptr2&lt;byte&gt; data int length)
		{
			var i = 0;
			var res = 0;
			do
			{
				data.Ref = (byte)(data.Ref + data[i++]);
				res += data.Ref;
			} while (--length != 0);
			return res;
		}
	}

	public unsafe struct Ptr1&lt;T&gt; where T : unmanaged
	{
		private readonly T* _nptr;

		public Ptr1(void* nptr) =&gt; _nptr = (T*)nptr;

		public ref T Ref
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get { return ref *(_nptr); }
		}

		public ref T this[int offset]
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get { return ref *(_nptr + offset); }
		}
	}

	public unsafe struct Ptr2&lt;T&gt; where T : unmanaged
	{
		private static readonly int TSize = Unsafe.SizeOf&lt;T&gt;();
		private readonly byte* _nptr;

		public Ptr2(void* nptr) =&gt; _nptr = (byte*) nptr;
		
		public ref T Ref
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get {return ref Unsafe.AsRef&lt;T&gt;(_nptr); }
		}

		public ref T this[int offset] 
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get { return ref Unsafe.AsRef&lt;T&gt;(_nptr + offset * TSize); }
		}
	}
}
```

Disassembly output for `Run1` benchmark:

```asm
;ConsoleApp3.Test.Run1()  
 xor     ediedi 
 add     rsp20h 
 mov     edx40h 
M00_L00   
 push    0 
 push    0 
 dec     rdx 
 jne     M00_L00 
 sub     rsp20h 
 lea     rdx[rsp+20h] 
 mov     qword ptr [rbp+10h]rsp 
 mov     qword ptr [rbp+8]rdx 
 xor     ebxebx 
M00_L01   
 lea     rdx[rbp+8] 
 mov     rcxrsi 
 mov     r8d400h 
 call    ConsoleApp3.Test.Method1(ConsoleApp3.Ptr1`1 ByRef Int32) 
 movsxd  raxeax 
 add     rdirax 
 inc     ebx 
 cmp     ebx2710h 
 jl      M00_L01 
 mov     raxrdi 
  
;ConsoleApp3.Test.Method1(ConsoleApp3.Ptr1`1 ByRef Int32)  
 xor     ebxebx 
 xor     ebpebp 
M01_L00   
 mov     rcxrsi 
 call    ConsoleApp3.Ptr1`1[[System.Byte mscorlib]].get_Ref() 
 mov     r14rax 
 lea     ecx[rbx+1] 
 mov     r15decx 
 mov     rcxrsi 
 call    ConsoleApp3.Ptr1`1[[System.Byte mscorlib]].get_Ref() 
 movzx   r12dbyte ptr [rax] 
 mov     rcxrsi 
 mov     edxebx 
 call    ConsoleApp3.Ptr1`1[[System.Byte mscorlib]].get_Item(Int32) 
 movzx   ecxbyte ptr [rax] 
 add     ecxr12d 
 mov     byte ptr [r14]cl 
 mov     rcxrsi 
 call    ConsoleApp3.Ptr1`1[[System.Byte mscorlib]].get_Ref() 
 movzx   eaxbyte ptr [rax] 
 add     ebpeax 
 dec     edi 
 test    ediedi 
 mov     ebxr15d 
 jne     M01_L00 
 mov     eaxebp 
  
;ConsoleApp3.Ptr1`1[[System.Byte mscorlib]].get_Ref()  
 mov     raxqword ptr [rcx] 
  
;ConsoleApp3.Ptr1`1[[System.Byte mscorlib]].get_Item(Int32)  
 movsxd  raxedx 
 add     raxqword ptr [rcx] 
```

Disassembly output for `Run2` benchmark:

```asm
;ConsoleApp3.Test.Run2()  
 xor     ediedi 
 add     rsp20h 
 mov     edx40h 
M00_L00   
 push    0 
 push    0 
 dec     rdx 
 jne     M00_L00 
 sub     rsp20h 
 lea     rdx[rsp+20h] 
 mov     qword ptr [rbp+10h]rsp 
 mov     qword ptr [rbp+8]rdx 
 xor     ebxebx 
M00_L01   
 lea     rdx[rbp+8] 
 mov     rcxrsi 
 mov     r8d400h 
 call    ConsoleApp3.Test.Method2(ConsoleApp3.Ptr2`1 ByRef Int32) 
 movsxd  raxeax 
 add     rdirax 
 inc     ebx 
 cmp     ebx2710h 
 jl      M00_L01 
 mov     raxrdi 
  
;ConsoleApp3.Test.Method2(ConsoleApp3.Ptr2`1 ByRef Int32)  
 xor     eaxeax 
 xor     ecxecx 
M01_L00   
 mov     r9qword ptr [rdx] 
 mov     r10r9 
 mov     r11r9 
 lea     esi[rax+1] 
 movzx   r11dbyte ptr [r11] 
 movsxd  raxeax 
 add     raxr9 
 movzx   eaxbyte ptr [rax] 
 add     r11deax 
 mov     byte ptr [r10]r11b 
 mov     raxqword ptr [rdx] 
 movzx   eaxbyte ptr [rax] 
 add     ecxeax 
 dec     r8d 
 test    r8dr8d 
 mov     eaxesi 
 jne     M01_L00 
 mov     eaxecx 
```

Results:

```
| Method |     Mean |     Error |    StdDev |
|------- |---------:|----------:|----------:|
|   Run1 | 80.98 ms | 0.9829 ms | 0.8713 ms |
|   Run2 | 20.79 ms | 0.0431 ms | 0.0337 ms |
</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
    <CreatedAt>5/06/2018 12:22:08 PM +00:00</CreatedAt>
    <ClosedAt>5/06/2018 4:18:53 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18296</IssueLabelID>
    <Title>Avoid marking the frame pointer is used in genFuncletProlog</Title>
    <Description>This pull request is a follow up of the pull request (#18230) I made earlier.

Initially I followed the advice to mark the frame pointer as modified in `LinearScan::setFrameType()` this results in an assert in the code below (ifdef eliminated for clarity)

`codegencommon.cpp`

    /* Count how many callee-saved registers will actually be saved (pushed) */

    // EBP cannot be (directly) modified for EBP frame and double-aligned frames
    noway_assert(!doubleAlignOrFramePointerUsed() || !regSet.rsRegsModified(RBM_FPBASE));

    // EBP cannot be (directly) modified
    noway_assert(!regSet.rsRegsModified(RBM_FPBASE));

    regMaskTP maskCalleeRegsPushed = regSet.rsGetModifiedRegsMask() &amp; RBM_CALLEE_SAVED;

    if (isFramePointerUsed())
    {
        // For a FP based frame we have to push/pop the FP register
        //
        maskCalleeRegsPushed |= RBM_FPBASE;

        // This assert check that we are not using REG_FP
        // as both the frame pointer and as a codegen register
        //
        assert(!regSet.rsRegsModified(RBM_FPBASE));
    }

    // we always push LR.  See genPushCalleeSavedRegisters
    //
    maskCalleeRegsPushed |= RBM_LR;

Reading the code it is apparent that if EBP is used as the frame pointer it is expected that it is not marked as modified in the regSet that is why I believe setting the frame pointer as modified in the `LinearScan::setFrameType()` is the wrong thing to do.

It remains to deal with the assert.

The code that I changed in this pull request is to bracket the particular instruction that modifies EBP in the prolog that asserts. The function `instGen_Set_Reg_To_Zero` is a generic function that zeros a register as a side effect it also asserts that the register is marked as modified. In general this is the right thing to do but only for this special case where we `modify` the frame pointer but not really ...

In some sense the original code did pretty much that same but it brackets a much larger region. This change narrowed down the region to just emitting one instruction in the large frame case.</Description>
    <Title_Description>Avoid marking the frame pointer is used in genFuncletProlog This pull request is a follow up of the pull request (#18230) I made earlier.

Initially I followed the advice to mark the frame pointer as modified in `LinearScan::setFrameType()` this results in an assert in the code below (ifdef eliminated for clarity)

`codegencommon.cpp`

    /* Count how many callee-saved registers will actually be saved (pushed) */

    // EBP cannot be (directly) modified for EBP frame and double-aligned frames
    noway_assert(!doubleAlignOrFramePointerUsed() || !regSet.rsRegsModified(RBM_FPBASE));

    // EBP cannot be (directly) modified
    noway_assert(!regSet.rsRegsModified(RBM_FPBASE));

    regMaskTP maskCalleeRegsPushed = regSet.rsGetModifiedRegsMask() &amp; RBM_CALLEE_SAVED;

    if (isFramePointerUsed())
    {
        // For a FP based frame we have to push/pop the FP register
        //
        maskCalleeRegsPushed |= RBM_FPBASE;

        // This assert check that we are not using REG_FP
        // as both the frame pointer and as a codegen register
        //
        assert(!regSet.rsRegsModified(RBM_FPBASE));
    }

    // we always push LR.  See genPushCalleeSavedRegisters
    //
    maskCalleeRegsPushed |= RBM_LR;

Reading the code it is apparent that if EBP is used as the frame pointer it is expected that it is not marked as modified in the regSet that is why I believe setting the frame pointer as modified in the `LinearScan::setFrameType()` is the wrong thing to do.

It remains to deal with the assert.

The code that I changed in this pull request is to bracket the particular instruction that modifies EBP in the prolog that asserts. The function `instGen_Set_Reg_To_Zero` is a generic function that zeros a register as a side effect it also asserts that the register is marked as modified. In general this is the right thing to do but only for this special case where we `modify` the frame pointer but not really ...

In some sense the original code did pretty much that same but it brackets a much larger region. This change narrowed down the region to just emitting one instruction in the large frame case.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>cshung</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18295</IssueLabelID>
    <Title>[arm32] Assertion failed 'genIsValidIntReg(dstReg)'</Title>
    <Description>It seems that this has been broken for a while. I recently caught this during PR #18289 testing
But the regression was introduced earlier - sometime between  [Build #18 (May 17 2018 4:32:43 AM) ](https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_corefx_baseline_tst/18/) and [Build #19 (May 24 2018 4:27:51 AM)](https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_corefx_baseline_tst/19/)
```
----- start 23:20:10 =============== To repro directly: =====================================================
pushd .
#!/usr/bin/env bash
chmod +x /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_baseline_tst_prtest/_/fx/bin/testhost/netcoreapp-Linux-Release-arm/dotnet
/ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_baseline_tst_prtest/_/fx/bin/testhost/netcoreapp-Linux-Release-arm/dotnet xunit.console.netcore.exe System.Dynamic.Runtime.Tests.dll  -xml testResults.xml -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonlinuxtests  -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing
popd
===========================================================================================================
/ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_baseline_tst_prtest/_/fx/bin/tests/System.Dynamic.Runtime.Tests/netcoreapp-Linux-Release-arm /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_baseline_tst_prtest/_/fx/bin/tests/System.Dynamic.Runtime.Tests/netcoreapp-Linux-Release-arm
xUnit.net console test runner (32-bit .NET Core)
Copyright (C) 2014 Outercurve Foundation.

Discovering: System.Dynamic.Runtime.Tests
Discovered:  System.Dynamic.Runtime.Tests
Starting:    System.Dynamic.Runtime.Tests

Assert failure(PID 12372 [0x00003054] Thread: 12387 [0x3063]): Assertion failed 'genIsValidIntReg(dstReg)' in 'DynamicClass:CallSite.Target(refrefrefref):ref' (IL size 143)

    File: /mnt/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_baseline_prtest/src/jit/codegenarmarch.cpp Line: 3406
    Image: /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_baseline_tst_prtest/_/fx/bin/testhost/netcoreapp-Linux-Release-arm/dotnet


Assert failure(PID 12372 [0x00003054] Thread: 12387 [0x3063]): Assertion failed 'genIsValidIntReg(dstReg)' in 'DynamicClass:CallSite.Target(refrefrefref):ref' (IL size 143)

    File: /mnt/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_baseline_prtest/src/jit/codegenarmarch.cpp Line: 3406
    Image: /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_baseline_tst_prtest/_/fx/bin/testhost/netcoreapp-Linux-Release-arm/dotnet

./RunTests.sh: line 126: 12372 Aborted                 $RUNTIME_PATH/dotnet xunit.console.netcore.exe System.Dynamic.Runtime.Tests.dll -xml testResults.xml -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonlinuxtests -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing
/ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_baseline_tst_prtest/_/fx/bin/tests/System.Dynamic.Runtime.Tests/netcoreapp-Linux-Release-arm
----- end 23:22:29 ----- exit code 134 ----------------------------------------------------------
```
**Update:** The issue is also reproducible on Windows/ARM (e.g. https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_corefx_baseline_tst/21/consoleText)

When the issue is resolved enable back tests disabled in PR #18347</Description>
    <Title_Description>[arm32] Assertion failed 'genIsValidIntReg(dstReg)' It seems that this has been broken for a while. I recently caught this during PR #18289 testing
But the regression was introduced earlier - sometime between  [Build #18 (May 17 2018 4:32:43 AM) ](https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_corefx_baseline_tst/18/) and [Build #19 (May 24 2018 4:27:51 AM)](https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_corefx_baseline_tst/19/)
```
----- start 23:20:10 =============== To repro directly: =====================================================
pushd .
#!/usr/bin/env bash
chmod +x /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_baseline_tst_prtest/_/fx/bin/testhost/netcoreapp-Linux-Release-arm/dotnet
/ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_baseline_tst_prtest/_/fx/bin/testhost/netcoreapp-Linux-Release-arm/dotnet xunit.console.netcore.exe System.Dynamic.Runtime.Tests.dll  -xml testResults.xml -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonlinuxtests  -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing
popd
===========================================================================================================
/ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_baseline_tst_prtest/_/fx/bin/tests/System.Dynamic.Runtime.Tests/netcoreapp-Linux-Release-arm /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_baseline_tst_prtest/_/fx/bin/tests/System.Dynamic.Runtime.Tests/netcoreapp-Linux-Release-arm
xUnit.net console test runner (32-bit .NET Core)
Copyright (C) 2014 Outercurve Foundation.

Discovering: System.Dynamic.Runtime.Tests
Discovered:  System.Dynamic.Runtime.Tests
Starting:    System.Dynamic.Runtime.Tests

Assert failure(PID 12372 [0x00003054] Thread: 12387 [0x3063]): Assertion failed 'genIsValidIntReg(dstReg)' in 'DynamicClass:CallSite.Target(refrefrefref):ref' (IL size 143)

    File: /mnt/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_baseline_prtest/src/jit/codegenarmarch.cpp Line: 3406
    Image: /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_baseline_tst_prtest/_/fx/bin/testhost/netcoreapp-Linux-Release-arm/dotnet


Assert failure(PID 12372 [0x00003054] Thread: 12387 [0x3063]): Assertion failed 'genIsValidIntReg(dstReg)' in 'DynamicClass:CallSite.Target(refrefrefref):ref' (IL size 143)

    File: /mnt/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_baseline_prtest/src/jit/codegenarmarch.cpp Line: 3406
    Image: /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_baseline_tst_prtest/_/fx/bin/testhost/netcoreapp-Linux-Release-arm/dotnet

./RunTests.sh: line 126: 12372 Aborted                 $RUNTIME_PATH/dotnet xunit.console.netcore.exe System.Dynamic.Runtime.Tests.dll -xml testResults.xml -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonlinuxtests -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing
/ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_baseline_tst_prtest/_/fx/bin/tests/System.Dynamic.Runtime.Tests/netcoreapp-Linux-Release-arm
----- end 23:22:29 ----- exit code 134 ----------------------------------------------------------
```
**Update:** The issue is also reproducible on Windows/ARM (e.g. https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_corefx_baseline_tst/21/consoleText)

When the issue is resolved enable back tests disabled in PR #18347</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18294</IssueLabelID>
    <Title>Use WChar instead of char</Title>
    <Description>Use WCHAR to avoid truncate -- pTarget  is WCHAR*.

Fix: https://github.com/dotnet/coreclr/issues/18269</Description>
    <Title_Description>Use WChar instead of char Use WCHAR to avoid truncate -- pTarget  is WCHAR*.

Fix: https://github.com/dotnet/coreclr/issues/18269</Title_Description>
    <Label>
    </Label>
    <Assignee>luqunl</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18292</IssueLabelID>
    <Title>Workaround for  compiler.hpp (1848) - Assertion failed 'lvRefCnt'</Title>
    <Description>The description is in #18291.

The fix is to replace `JTRUE` `relop` before morph the list of its side effects. In this case when we have `fgRemoveRestOfBlock` and call `fgRemoveStmt` it removes updated `JTRUE` and this part works correct.

The problem that `optVNConstantPropCurStmt` could receive a statement that was already removed still exists.</Description>
    <Title_Description>Workaround for  compiler.hpp (1848) - Assertion failed 'lvRefCnt' The description is in #18291.

The fix is to replace `JTRUE` `relop` before morph the list of its side effects. In this case when we have `fgRemoveRestOfBlock` and call `fgRemoveStmt` it removes updated `JTRUE` and this part works correct.

The problem that `optVNConstantPropCurStmt` could receive a statement that was already removed still exists.</Title_Description>
    <Label>bug</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>4/06/2018 10:57:40 PM +00:00</CreatedAt>
    <ClosedAt>8/06/2018 5:30:44 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18291</IssueLabelID>
    <Title>optVNConstantPropOnJTrue with uncondition throw removes the tree twice</Title>
    <Description>An example:
```
N024 ( 51 48) [000035] --CXG-------              *  JTRUE     void
N022 (  1  1) [000033] ------------              |  /--*  CNS_INT   int    0 $40
N023 ( 49 46) [000034] J-CXG--N----              \--*  NE        int    $41
N021 ( 47 44) [000032] --CXG-------                 \--*  NOT       int    $43
N019 (  1  1) [000022] ------------                    |  /--*  CNS_INT   int    0 $40
N020 ( 46 43) [000031] --CXG-------                    \--*  COMMA     int    $40
N016 (  3  4) [000017] ------------                       |     /--*  LCL_VAR   double V04 loc1         u:2 (last use) $100
N017 ( 11 12) [000018] ------------                       |  /--*  MUL       double $100
N015 (  3  4) [000016] ------------                       |  |  \--*  LCL_VAR   double V04 loc1         u:2 $100
N018 ( 45 42) [000019] N-CXG----U--                       \--*  LT        int    $400
N014 ( 30 29) [000013] --CXG-------                          \--*  NEG       double $3c0
N013 ( 29 28) [000012] --CXG-------                             \--*  CKFINITE  double $380
N012 ( 28 27) [000011] --CXG-------                                \--*  NEG       double $341
N011 ( 27 26) [000009] --CXG-------                                   \--*  CAST      double &lt;- long $340
N009 (  3 10) [000004] ------------                                      |  /--*  CNS_INT   long   0x1917394023ae4269 $2c1
N010 ( 21 20) [000008] --CXG-------                                      \--*  ADD       long   $301
N008 ( 17  9) [000118] --CXG-------                                         \--*  NEG       long   $300
N006 (  1  1) [000111] ------------                                            |  /--*  CNS_INT   long   0 $2c0
N007 ( 16  8) [000115] --CXG-------                                            \--*  COMMA     long   $300
N005 ( 15  7) [000114] --CXG-------                                               \--*  CALL help void   HELPER.CORINFO_HELP_OVERFLOW $281
N003 (  1  1) [000112] ------------ arg0 in rcx                                      \--*  CNS_INT   int    0 $40
```

The real condition is:
```
N022 (  1  1) [000033] ------------              |  /--*  CNS_INT   int    0 $40
N023 ( 49 46) [000034] J-CXG--N----              \--*  NE        int    $41
N021 ( 47 44) [000032] --CXG-------                 \--*  NOT       int    $43
N019 (  1  1) [000022] ------------                    \--*  CNS_INT   int    0 $40
```
so it is `0 != !0` == `true`.

the list of side effects is:
```
N005 ( 15  7) [000114] --CXG-------                                               \--*  CALL help void   HELPER.CORINFO_HELP_OVERFLOW $281
N003 (  1  1) [000112] ------------ arg0 in rcx                                      \--*  CNS_INT   int    0 $40
```
and `optVNConstantPropOnJTrue` extracts it and place **before** the jump statement then it calls `fgMorphBlockStmt` on the extracted statement `fgMorphBlockStmt` see that:
```
We have a top-level fgIsThrow stmt
Removing the rest of block as unreachable
```
and removes the jump node and decrements LCL_VAR ref counters in the original tree for the second time that triggers assert `compiler.hpp (1848) - Assertion failed 'lvRefCnt'`.

Affects all targets affects 2.1 but it does not generate bad code in release however I think it is possible to cause it with this issue.

category:testing
theme:basic-cq
skill-level:expert
cost:small</Description>
    <Title_Description>optVNConstantPropOnJTrue with uncondition throw removes the tree twice An example:
```
N024 ( 51 48) [000035] --CXG-------              *  JTRUE     void
N022 (  1  1) [000033] ------------              |  /--*  CNS_INT   int    0 $40
N023 ( 49 46) [000034] J-CXG--N----              \--*  NE        int    $41
N021 ( 47 44) [000032] --CXG-------                 \--*  NOT       int    $43
N019 (  1  1) [000022] ------------                    |  /--*  CNS_INT   int    0 $40
N020 ( 46 43) [000031] --CXG-------                    \--*  COMMA     int    $40
N016 (  3  4) [000017] ------------                       |     /--*  LCL_VAR   double V04 loc1         u:2 (last use) $100
N017 ( 11 12) [000018] ------------                       |  /--*  MUL       double $100
N015 (  3  4) [000016] ------------                       |  |  \--*  LCL_VAR   double V04 loc1         u:2 $100
N018 ( 45 42) [000019] N-CXG----U--                       \--*  LT        int    $400
N014 ( 30 29) [000013] --CXG-------                          \--*  NEG       double $3c0
N013 ( 29 28) [000012] --CXG-------                             \--*  CKFINITE  double $380
N012 ( 28 27) [000011] --CXG-------                                \--*  NEG       double $341
N011 ( 27 26) [000009] --CXG-------                                   \--*  CAST      double &lt;- long $340
N009 (  3 10) [000004] ------------                                      |  /--*  CNS_INT   long   0x1917394023ae4269 $2c1
N010 ( 21 20) [000008] --CXG-------                                      \--*  ADD       long   $301
N008 ( 17  9) [000118] --CXG-------                                         \--*  NEG       long   $300
N006 (  1  1) [000111] ------------                                            |  /--*  CNS_INT   long   0 $2c0
N007 ( 16  8) [000115] --CXG-------                                            \--*  COMMA     long   $300
N005 ( 15  7) [000114] --CXG-------                                               \--*  CALL help void   HELPER.CORINFO_HELP_OVERFLOW $281
N003 (  1  1) [000112] ------------ arg0 in rcx                                      \--*  CNS_INT   int    0 $40
```

The real condition is:
```
N022 (  1  1) [000033] ------------              |  /--*  CNS_INT   int    0 $40
N023 ( 49 46) [000034] J-CXG--N----              \--*  NE        int    $41
N021 ( 47 44) [000032] --CXG-------                 \--*  NOT       int    $43
N019 (  1  1) [000022] ------------                    \--*  CNS_INT   int    0 $40
```
so it is `0 != !0` == `true`.

the list of side effects is:
```
N005 ( 15  7) [000114] --CXG-------                                               \--*  CALL help void   HELPER.CORINFO_HELP_OVERFLOW $281
N003 (  1  1) [000112] ------------ arg0 in rcx                                      \--*  CNS_INT   int    0 $40
```
and `optVNConstantPropOnJTrue` extracts it and place **before** the jump statement then it calls `fgMorphBlockStmt` on the extracted statement `fgMorphBlockStmt` see that:
```
We have a top-level fgIsThrow stmt
Removing the rest of block as unreachable
```
and removes the jump node and decrements LCL_VAR ref counters in the original tree for the second time that triggers assert `compiler.hpp (1848) - Assertion failed 'lvRefCnt'`.

Affects all targets affects 2.1 but it does not generate bad code in release however I think it is possible to cause it with this issue.

category:testing
theme:basic-cq
skill-level:expert
cost:small</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>sandreenko</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18286</IssueLabelID>
    <Title>[Arm64/Linux] gcStress=1/2/3 intermittent failures</Title>
    <Description>This issue is for tracking intermittent gcGtress failures which are not threading related..

While the occurrence rate of these failures is low it is worth tracking them here to help detect patterns.</Description>
    <Title_Description>[Arm64/Linux] gcStress=1/2/3 intermittent failures This issue is for tracking intermittent gcGtress failures which are not threading related..

While the occurrence rate of these failures is low it is worth tracking them here to help detect patterns.</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>Maoni0</Assignee>
    <CreatedAt>4/06/2018 5:29:43 PM +00:00</CreatedAt>
    <ClosedAt>10/04/2019 5:00:02 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18285</IssueLabelID>
    <Title>[Arm64/Linux] gcServer intermittent failures</Title>
    <Description>These have been a few intermittent failures in gcServer modes

Opening this issue to track these intermittent failures.

@Maoni0 </Description>
    <Title_Description>[Arm64/Linux] gcServer intermittent failures These have been a few intermittent failures in gcServer modes

Opening this issue to track these intermittent failures.

@Maoni0 </Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>VSadov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18284</IssueLabelID>
    <Title>Working folder when debugging a .NET Core app changing bizarrely</Title>
    <Description>_From @adamralph on June 1 2018 22:33_

_Continuing from [Twitter](https://twitter.com/davkean/status/1002675512399970304)._

Note that the breakpoint is _before_ the call to `Directory.SetCurrentDirectory()`!

![working-dir](https://user-images.githubusercontent.com/677704/40866148-6f48d7b0-65fc-11e8-9e9b-498bae7e57c2.gif)


_Copied from original issue: dotnet/project-system#3609_</Description>
    <Title_Description>Working folder when debugging a .NET Core app changing bizarrely _From @adamralph on June 1 2018 22:33_

_Continuing from [Twitter](https://twitter.com/davkean/status/1002675512399970304)._

Note that the breakpoint is _before_ the call to `Directory.SetCurrentDirectory()`!

![working-dir](https://user-images.githubusercontent.com/677704/40866148-6f48d7b0-65fc-11e8-9e9b-498bae7e57c2.gif)


_Copied from original issue: dotnet/project-system#3609_</Title_Description>
    <Label>area-Meta-corelib</Label>
    <Assignee>danmosemsft</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18283</IssueLabelID>
    <Title>Moves FastResourceComparer and TaskAwaiter to shared</Title>
    <Description>cc: @jkotas 

Related to corert PR: https://github.com/dotnet/corert/pull/5893</Description>
    <Title_Description>Moves FastResourceComparer and TaskAwaiter to shared cc: @jkotas 

Related to corert PR: https://github.com/dotnet/corert/pull/5893</Title_Description>
    <Label>
    </Label>
    <Assignee>maryamariyan</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18280</IssueLabelID>
    <Title>Interpretation of ByRefLikeAttribute in .NET Core 2.1 is a breaking change and a standard violation</Title>
    <Description>As a matter of facts it is possible in .NET Core 2.0 to use a ref struct as an argument of a generic parameter if you're generating MSIL but this same MSIL code no longer runs in .NET Core 2.1. We used this compilation pattern in PostSharp and did all the testing in .NET Core 2.0 just to see it's breaking in .NET Core 2.1.

I understand why you guys have taken this approach as this is a pragmatic way but I think it is my role as a third-party tool developer to respectfully complain.

Giving a runtime meaning to a custom attribute (ByRefLikeAttribute) is non-standard-compliant (ECMA-335) so the least I would expect is that you document an extension or violation of the standard. An orthodox approach would have been to define a new TypeAttribute and to cope with the problem that the compiler will need a specific version of the runtime. 

The concrete impact for this change and as far as PostSharp is concerned is minimal because support for C# 7.2 in PostSharp wasn't made RTW yet.

However as a policy breaking standards and relying on "tricks" (like ObsoleteAttribute) to minimize their impact is unhealthy and warrants this complain.

It seems there's a need for a well-thought solution to this problem. Like .NET Standard is the API-level answer to this issue should it be some CLR Standard? Maybe the compiler could emit a list of non-standard-compliant extensions marked as MUST UNDERSTAND or OPTIONAL that all members of the MSIL pipeline (therefore including the compiler PostSharp and the CLR) would respect.

```
[assembly: AssemblyRequiresClr( 2012 /* baseline CIL spec */ "!RefStruct" /* required extension */ )]
```


</Description>
    <Title_Description>Interpretation of ByRefLikeAttribute in .NET Core 2.1 is a breaking change and a standard violation As a matter of facts it is possible in .NET Core 2.0 to use a ref struct as an argument of a generic parameter if you're generating MSIL but this same MSIL code no longer runs in .NET Core 2.1. We used this compilation pattern in PostSharp and did all the testing in .NET Core 2.0 just to see it's breaking in .NET Core 2.1.

I understand why you guys have taken this approach as this is a pragmatic way but I think it is my role as a third-party tool developer to respectfully complain.

Giving a runtime meaning to a custom attribute (ByRefLikeAttribute) is non-standard-compliant (ECMA-335) so the least I would expect is that you document an extension or violation of the standard. An orthodox approach would have been to define a new TypeAttribute and to cope with the problem that the compiler will need a specific version of the runtime. 

The concrete impact for this change and as far as PostSharp is concerned is minimal because support for C# 7.2 in PostSharp wasn't made RTW yet.

However as a policy breaking standards and relying on "tricks" (like ObsoleteAttribute) to minimize their impact is unhealthy and warrants this complain.

It seems there's a need for a well-thought solution to this problem. Like .NET Standard is the API-level answer to this issue should it be some CLR Standard? Maybe the compiler could emit a list of non-standard-compliant extensions marked as MUST UNDERSTAND or OPTIONAL that all members of the MSIL pipeline (therefore including the compiler PostSharp and the CLR) would respect.

```
[assembly: AssemblyRequiresClr( 2012 /* baseline CIL spec */ "!RefStruct" /* required extension */ )]
```


</Title_Description>
    <Label>area-TypeSystem</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>4/06/2018 2:02:29 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18278</IssueLabelID>
    <Title>Build failure: src\vm\codeversion.cpp(2523): warning C4101: 'hr': unreferenced local variable</Title>
    <Description>Opened on behalf of @RussKeldorph

Warnings: 2
Status Message: failed

Build : Master - 20180604.03 (Product Build)
Failing configurations:
- Windows
  - PortableBuild-Checked-arm
  - PortableBuild-Checked-arm64
  - PortableBuild-Debug-arm
  - PortableBuild-Debug-arm64
  - PortableBuild-Release-arm
  - PortableBuild-Release-arm64
[Mission Control Build Info](https://mc.dot.net/#/product/netcore/master/source/official~2Fcoreclr~2Fmaster~2F/type/build~2Fproduct~2F/build/20180604.03/workItem/Orchestration/analysis/external/Link)
</Description>
    <Title_Description>Build failure: src\vm\codeversion.cpp(2523): warning C4101: 'hr': unreferenced local variable Opened on behalf of @RussKeldorph

Warnings: 2
Status Message: failed

Build : Master - 20180604.03 (Product Build)
Failing configurations:
- Windows
  - PortableBuild-Checked-arm
  - PortableBuild-Checked-arm64
  - PortableBuild-Debug-arm
  - PortableBuild-Debug-arm64
  - PortableBuild-Release-arm
  - PortableBuild-Release-arm64
[Mission Control Build Info](https://mc.dot.net/#/product/netcore/master/source/official~2Fcoreclr~2Fmaster~2F/type/build~2Fproduct~2F/build/20180604.03/workItem/Orchestration/analysis/external/Link)
</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>4/06/2018 1:04:33 PM +00:00</CreatedAt>
    <ClosedAt>4/06/2018 3:11:19 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18277</IssueLabelID>
    <Title>Consider using SIMD registers for "hot" local variables instead of placing them on stack when out of free GP registers</Title>
    <Description>The idea is intuitive though I'm not sure it was ever sounded in context of CLR JIT - why not use X/Y/ZMM registers for "hot" local variables to avoid stack memory accesses just like common GP registers are used to load/store the values? (I'm not talking here about operations other than load/store `MOVQ/MOVD` because it's much deeper topic which may include auto-vectorization and other funny stuff.)

There are always up to at least 6 volatile SIMD registers and the number of regs used may be increased up to the size of SIMD register file. With more complex techniques this may provide up to 8 regs for x86/SSE+ up to 16 regs for x64/SSE+ up to 32 regs for x64/AVX-512 (future). These numbers may be achievable in the context of CLR due to the fact that at the moment few code in system assemblies uses vectors and to my understanding SIMD ops are now only used for FP operations otherwise.

Even taking into account the store forwarding mechanisms implemented in modern CPUs when accessing memory the significant speed-up could be achieved. One extra point is that on HyperThreaded CPUs the register files are independent on each other whereas memory access circuitry is mostly shared by (sub-)cores.

category:design
theme:register-allocator
skill-level:expert
cost:large</Description>
    <Title_Description>Consider using SIMD registers for "hot" local variables instead of placing them on stack when out of free GP registers The idea is intuitive though I'm not sure it was ever sounded in context of CLR JIT - why not use X/Y/ZMM registers for "hot" local variables to avoid stack memory accesses just like common GP registers are used to load/store the values? (I'm not talking here about operations other than load/store `MOVQ/MOVD` because it's much deeper topic which may include auto-vectorization and other funny stuff.)

There are always up to at least 6 volatile SIMD registers and the number of regs used may be increased up to the size of SIMD register file. With more complex techniques this may provide up to 8 regs for x86/SSE+ up to 16 regs for x64/SSE+ up to 32 regs for x64/AVX-512 (future). These numbers may be achievable in the context of CLR due to the fact that at the moment few code in system assemblies uses vectors and to my understanding SIMD ops are now only used for FP operations otherwise.

Even taking into account the store forwarding mechanisms implemented in modern CPUs when accessing memory the significant speed-up could be achieved. One extra point is that on HyperThreaded CPUs the register files are independent on each other whereas memory access circuitry is mostly shared by (sub-)cores.

category:design
theme:register-allocator
skill-level:expert
cost:large</Title_Description>
    <Label>Design Discussion</Label>
    <Assignee>tannergooding</Assignee>
    <CreatedAt>4/06/2018 12:33:15 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18272</IssueLabelID>
    <Title>Fix error during compilation with /permissive-</Title>
    <Description>Closes #17944 </Description>
    <Title_Description>Fix error during compilation with /permissive- Closes #17944 </Title_Description>
    <Label>Hackathon</Label>
    <Assignee>kant2002</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18270</IssueLabelID>
    <Title>Unsafe.AsRef is not getting inlined in Span.GetPinnableReference</Title>
    <Description>Repro:

```csharp
static unsafe void Main() {
   Span&lt;byte&gt; span = new byte[1];
   // This gets compiled into a call to Span.GetPinnableReference in latest C#
   fixed (byte* p = span) { *p = 1; }
}
```

Result: `Unsafe.Ref(0)` is not inlined</Description>
    <Title_Description>Unsafe.AsRef is not getting inlined in Span.GetPinnableReference Repro:

```csharp
static unsafe void Main() {
   Span&lt;byte&gt; span = new byte[1];
   // This gets compiled into a call to Span.GetPinnableReference in latest C#
   fixed (byte* p = span) { *p = 1; }
}
```

Result: `Unsafe.Ref(0)` is not inlined</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
    <CreatedAt>4/06/2018 12:24:31 AM +00:00</CreatedAt>
    <ClosedAt>4/06/2018 11:02:02 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18269</IssueLabelID>
    <Title>Regression in 2.1.300: AssemblyName parsing with unicode/emoji crashes</Title>
    <Description>I found a regression in 2.1.300 when trying to upgrade [Xamarin Workbooks](https://github.com/Microsoft/workbooks) to `netcoreapp2.1`.

It seems that maybe (at least based on the date of the commit) [that flat layout for `GetAssemblyName`](https://github.com/dotnet/coreclr/commit/77d4c11fcd67414d2195a63287e9c8e0b6f32958#diff-8b5c082f27b55aa1d4b297f3b78309d0) cannot handle sequences of unicode/emoji characters that we are using in our Roslyn-generated script submission assemblies that represent workbook cells.

Our script submission assemblies end up with assembly names of the form&lt;sup&gt;1&lt;/sup&gt;

```
🐵🐻#2faeea4e-c41b-4d38-85ea-124b4197280d-0
```

The issue can be reproduced easily:

```csharp
new AssemblyName("🐵🐻#2faeea4e-c41b-4d38-85ea-124b4197280d-0");
```

Which now results in the exception:

```
Unhandled Exception: System.IO.FileLoadException: The given assembly name or codebase was
invalid. (Exception from HRESULT: 0x80131047)
  at System.Reflection.AssemblyName.nInit(RuntimeAssembly&amp; assembly Boolean raiseResolve
Event)
  at System.Reflection.AssemblyName..ctor(String assemblyName)
…
```

It may be important to note that each of the emoji here are four UTF-16 bytes (this is significant in our code for patching) and the exception only seems to occur when there are at least two emoji in a string that is more than &gt;= 20 UTF-16 bytes.

## Simple Test Case

Run the follow program against `netcoreapp2.0` (2.1.4 in `global.json`) and `netcoreapp2.1` (2.1.300 in `global.json`).

```csharp
using System;
using System.Reflection;
using System.Text;

class Program
{
    static void Main(string[] args)
    {
        string str = null;
        for (int i = 0; i &lt; 5; i++) {
            str += "🐻";
            Console.WriteLine ($"String:      {str} ({str.Length})");
            Console.WriteLine ($"UTF-16 Size: {Encoding.Unicode.GetByteCount(str)}");
            try {
                new AssemblyName (str);
                Console.WriteLine ("OK");
                Console.WriteLine ();
            } catch {
                Console.WriteLine ("FAIL");
                throw;
            }
        }
    }
}
```

### Output in 2.1.4 / `netcoreapp2.0`

```
String:      🐻 (2)
UTF-16 Size: 4
OK

String:      🐻🐻 (4)
UTF-16 Size: 8
OK

String:      🐻🐻🐻 (6)
UTF-16 Size: 12
OK

String:      🐻🐻🐻🐻 (8)
UTF-16 Size: 16
OK

String:      🐻🐻🐻🐻🐻 (10)
UTF-16 Size: 20
OK
```

### Output in 2.1.300 / `netcoreapp2.1`

```
String:      🐻 (2)
UTF-16 Size: 4
OK

String:      🐻🐻 (4)
UTF-16 Size: 8
OK

String:      🐻🐻🐻 (6)
UTF-16 Size: 12
OK

String:      🐻🐻🐻🐻 (8)
UTF-16 Size: 16
OK

String:      🐻🐻🐻🐻🐻 (10)
UTF-16 Size: 20
FAIL

Unhandled Exception: System.IO.FileLoadException: The given assembly name or codebase wasinvalid. (Exception from HRESULT: 0x80131047)
   at System.Reflection.AssemblyName.nInit(RuntimeAssembly&amp; assembly Boolean raiseResolveEvent)
   at System.Reflection.AssemblyName..ctor(String assemblyName)
   at Program.Main(String[] args) in /Users/aaron/Desktop/emoji/Program.cs:line 15
```

_1. If you're interested in _why_ we have assembly names with this particular sequence of emoji feel free to ask!_</Description>
    <Title_Description>Regression in 2.1.300: AssemblyName parsing with unicode/emoji crashes I found a regression in 2.1.300 when trying to upgrade [Xamarin Workbooks](https://github.com/Microsoft/workbooks) to `netcoreapp2.1`.

It seems that maybe (at least based on the date of the commit) [that flat layout for `GetAssemblyName`](https://github.com/dotnet/coreclr/commit/77d4c11fcd67414d2195a63287e9c8e0b6f32958#diff-8b5c082f27b55aa1d4b297f3b78309d0) cannot handle sequences of unicode/emoji characters that we are using in our Roslyn-generated script submission assemblies that represent workbook cells.

Our script submission assemblies end up with assembly names of the form&lt;sup&gt;1&lt;/sup&gt;

```
🐵🐻#2faeea4e-c41b-4d38-85ea-124b4197280d-0
```

The issue can be reproduced easily:

```csharp
new AssemblyName("🐵🐻#2faeea4e-c41b-4d38-85ea-124b4197280d-0");
```

Which now results in the exception:

```
Unhandled Exception: System.IO.FileLoadException: The given assembly name or codebase was
invalid. (Exception from HRESULT: 0x80131047)
  at System.Reflection.AssemblyName.nInit(RuntimeAssembly&amp; assembly Boolean raiseResolve
Event)
  at System.Reflection.AssemblyName..ctor(String assemblyName)
…
```

It may be important to note that each of the emoji here are four UTF-16 bytes (this is significant in our code for patching) and the exception only seems to occur when there are at least two emoji in a string that is more than &gt;= 20 UTF-16 bytes.

## Simple Test Case

Run the follow program against `netcoreapp2.0` (2.1.4 in `global.json`) and `netcoreapp2.1` (2.1.300 in `global.json`).

```csharp
using System;
using System.Reflection;
using System.Text;

class Program
{
    static void Main(string[] args)
    {
        string str = null;
        for (int i = 0; i &lt; 5; i++) {
            str += "🐻";
            Console.WriteLine ($"String:      {str} ({str.Length})");
            Console.WriteLine ($"UTF-16 Size: {Encoding.Unicode.GetByteCount(str)}");
            try {
                new AssemblyName (str);
                Console.WriteLine ("OK");
                Console.WriteLine ();
            } catch {
                Console.WriteLine ("FAIL");
                throw;
            }
        }
    }
}
```

### Output in 2.1.4 / `netcoreapp2.0`

```
String:      🐻 (2)
UTF-16 Size: 4
OK

String:      🐻🐻 (4)
UTF-16 Size: 8
OK

String:      🐻🐻🐻 (6)
UTF-16 Size: 12
OK

String:      🐻🐻🐻🐻 (8)
UTF-16 Size: 16
OK

String:      🐻🐻🐻🐻🐻 (10)
UTF-16 Size: 20
OK
```

### Output in 2.1.300 / `netcoreapp2.1`

```
String:      🐻 (2)
UTF-16 Size: 4
OK

String:      🐻🐻 (4)
UTF-16 Size: 8
OK

String:      🐻🐻🐻 (6)
UTF-16 Size: 12
OK

String:      🐻🐻🐻🐻 (8)
UTF-16 Size: 16
OK

String:      🐻🐻🐻🐻🐻 (10)
UTF-16 Size: 20
FAIL

Unhandled Exception: System.IO.FileLoadException: The given assembly name or codebase wasinvalid. (Exception from HRESULT: 0x80131047)
   at System.Reflection.AssemblyName.nInit(RuntimeAssembly&amp; assembly Boolean raiseResolveEvent)
   at System.Reflection.AssemblyName..ctor(String assemblyName)
   at Program.Main(String[] args) in /Users/aaron/Desktop/emoji/Program.cs:line 15
```

_1. If you're interested in _why_ we have assembly names with this particular sequence of emoji feel free to ask!_</Title_Description>
    <Label>area-AssemblyLoader</Label>
    <Assignee>luqunl</Assignee>
    <CreatedAt>3/06/2018 11:43:38 PM +00:00</CreatedAt>
    <ClosedAt>17/07/2018 4:23:09 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18264</IssueLabelID>
    <Title>Set GTF_RELOP_QMARK in gtNewQmarkNode</Title>
    <Description>Add/Set  GTF_RELOP_QMARK in gtNewQmarkNode

Fix https://github.com/dotnet/coreclr/issues/18192
</Description>
    <Title_Description>Set GTF_RELOP_QMARK in gtNewQmarkNode Add/Set  GTF_RELOP_QMARK in gtNewQmarkNode

Fix https://github.com/dotnet/coreclr/issues/18192
</Title_Description>
    <Label>Hackathon</Label>
    <Assignee>luqunl</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18260</IssueLabelID>
    <Title>Warnings cleanup</Title>
    <Description>- Reenables all warnings that do not trigger
- Fixes two of the easier warnings and reenables them too.

contributes to #18128 </Description>
    <Title_Description>Warnings cleanup - Reenables all warnings that do not trigger
- Fixes two of the easier warnings and reenables them too.

contributes to #18128 </Title_Description>
    <Label>Hackathon</Label>
    <Assignee>Suchiman</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18259</IssueLabelID>
    <Title>Wrong value passed to generic interface method in release</Title>
    <Description>On .NET core 2.1.0 and .NET framework 4.7.1 the following program prints `0` in debug but `1` in release:
```csharp
using System;

class C0
{
    public ulong F6;
    public C0(ulong f6)
    {
        F6 = f6;
    }
}

struct S0
{
    public C0 F2;
    public S0(C0 f2)
    {
        F2 = f2;
    }
}

struct S1
{
    public S0 F0;
    public S0 F2;
    public S1(S0 f2)
    {
        F0 = default(S0);
        F2 = f2;
    }
}

interface II0
{
    void WriteLine&lt;T&gt;(T b);
}

class C1 : II0
{
    public void WriteLine&lt;T&gt;(T b)
    {
        Console.WriteLine(b);
    }
}

public class Program
{
    private static II0 s_0;
    public static void Main()
    {
        s_0 = new C1();
        S1[] var0 = {new S1(new S0(new C0(0)))};
        var0[0].F2.F2.F6 = var0[0].F2.F2.F6;
        var0[0].F2.F2 = new C0(1); // The value specified here is printed in release
        var0[0].F2.F2.F6 = 0;
        s_0.WriteLine(var0[0].F2.F2.F6);
    }
}

```</Description>
    <Title_Description>Wrong value passed to generic interface method in release On .NET core 2.1.0 and .NET framework 4.7.1 the following program prints `0` in debug but `1` in release:
```csharp
using System;

class C0
{
    public ulong F6;
    public C0(ulong f6)
    {
        F6 = f6;
    }
}

struct S0
{
    public C0 F2;
    public S0(C0 f2)
    {
        F2 = f2;
    }
}

struct S1
{
    public S0 F0;
    public S0 F2;
    public S1(S0 f2)
    {
        F0 = default(S0);
        F2 = f2;
    }
}

interface II0
{
    void WriteLine&lt;T&gt;(T b);
}

class C1 : II0
{
    public void WriteLine&lt;T&gt;(T b)
    {
        Console.WriteLine(b);
    }
}

public class Program
{
    private static II0 s_0;
    public static void Main()
    {
        s_0 = new C1();
        S1[] var0 = {new S1(new S0(new C0(0)))};
        var0[0].F2.F2.F6 = var0[0].F2.F2.F6;
        var0[0].F2.F2 = new C0(1); // The value specified here is printed in release
        var0[0].F2.F2.F6 = 0;
        s_0.WriteLine(var0[0].F2.F2.F6);
    }
}

```</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>briansull</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18258</IssueLabelID>
    <Title>Cleanup and remove unused parameters from genCreateAddrMode</Title>
    <Description>fixes #18177</Description>
    <Title_Description>Cleanup and remove unused parameters from genCreateAddrMode fixes #18177</Title_Description>
    <Label>Hackathon</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18257</IssueLabelID>
    <Title>Change gtExtractSideEffList to use GenTreeVisitor</Title>
    <Description>This changes `gtExtractSideEffList` to use `GenTreeVisitor` instead of custom tree traversal logic. The existing code did not handle `GT_ARR_ELEM` and `GT_ARR_OFFSET` and did not always preserve side effect ordering.

Additionally this changes `optPrepareTreeForReplacement` to use `GTF_SIDE_EFFECT` instead of ` GTF_PERSISTENT_SIDE_EFFECTS_IN_CSE` to avoid dropping exception side effects and class constructor calls.

More details in commit message and discussion below.

Unfortunately the change to use `GenTreeVisitor` slows down things a bit - around 0.05% instructions retired. But I don't think such a small regression can justify keeping the custom/duplicate tree traversal logic especially if it can lead to bugs. Besides there are plenty of places in the JIT where one can recover 0.05% without compromising code reliability and clarity.

Fixes #18232</Description>
    <Title_Description>Change gtExtractSideEffList to use GenTreeVisitor This changes `gtExtractSideEffList` to use `GenTreeVisitor` instead of custom tree traversal logic. The existing code did not handle `GT_ARR_ELEM` and `GT_ARR_OFFSET` and did not always preserve side effect ordering.

Additionally this changes `optPrepareTreeForReplacement` to use `GTF_SIDE_EFFECT` instead of ` GTF_PERSISTENT_SIDE_EFFECTS_IN_CSE` to avoid dropping exception side effects and class constructor calls.

More details in commit message and discussion below.

Unfortunately the change to use `GenTreeVisitor` slows down things a bit - around 0.05% instructions retired. But I don't think such a small regression can justify keeping the custom/duplicate tree traversal logic especially if it can lead to bugs. Besides there are plenty of places in the JIT where one can recover 0.05% without compromising code reliability and clarity.

Fixes #18232</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>mikedn</Assignee>
    <CreatedAt>2/06/2018 7:38:04 PM +00:00</CreatedAt>
    <ClosedAt>23/07/2018 7:21:35 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18256</IssueLabelID>
    <Title>Share more of the HWIntrinsic base code between ARM and XArch if possible</Title>
    <Description>https://github.com/dotnet/coreclr/pull/18255 did a fairly big refactoring of the XArch HWIntrinsic code.

There are likely several functions which could be shared between Arm64 and XArch. This issue tracks the initial investigation and any work required.

category:design
theme:intrinsics
skill-level:expert
cost:medium</Description>
    <Title_Description>Share more of the HWIntrinsic base code between ARM and XArch, if possible https://github.com/dotnet/coreclr/pull/18255 did a fairly big refactoring of the XArch HWIntrinsic code.

There are likely several functions which could be shared between Arm64 and XArch. This issue tracks the initial investigation and any work required.

category:design
theme:intrinsics
skill-level:expert
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>tannergooding</Assignee>
    <CreatedAt>2/06/2018 7:25:04 PM +00:00</CreatedAt>
    <ClosedAt>16/10/2019 9:55:14 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18253</IssueLabelID>
    <Title>Implement corefx/#16619: Add FormattableString.CurrentCulture</Title>
    <Description>Implement https://github.com/dotnet/corefx/issues/16619: Add FormattableString.CurrentCulture</Description>
    <Title_Description>Implement corefx/#16619: Add FormattableString.CurrentCulture Implement https://github.com/dotnet/corefx/issues/16619: Add FormattableString.CurrentCulture</Title_Description>
    <Label>Hackathon</Label>
    <Assignee>mikhailshilkov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18252</IssueLabelID>
    <Title>Setting breakpoint in managed function using lldb</Title>
    <Description>I want to set breakpoint on my function `Foo` in below program.

```cs
// Program.cs

using System;
using System.Threading;

namespace lldblivedebug
{
    class Program
    {
        static void Main(string[] args)
        {
            int count = 1;
            while (count &gt; 0)
            {
                 Thread.Sleep(2000);
                 count = count + 1;
                 Foo();
            }
        }

        static void Foo()
        {
             Console.WriteLine("From foo");
        }
    }
}

```

I can see managed stack trace. But I am not able to set the breakpoints on function.
I tried command `bpmd`. I don't totally understand what should be next argument to `bpmd` on Linux.
`bpmd &lt;module_name&gt; &lt;Fully_qualified_funciton&gt;`.

If my executable name is X and code is in X.dll on linux Is `module_name` in above command `X.dll` or `X` ?

Here is a sample lldb session of what I tried.

```
dotnet build -r ubuntu.16.04-x64
cd ~/dotnet_test/lldblivedebug/bin/Debug/netcoreapp2.0/ubuntu.16.04-x64
```
```gdb
asnegi@asnegi-vm ~/dotnet_test/lldblivedebug/bin/Debug/netcoreapp2.0/ubuntu.16.04-x64 $ lldb-3.9 -O "plugin load ~/ryu/libsosplugin/libsosplugin.so" -O "target create lldblivedebug" -o "breakpoint set -n lldblivedebug.Program.Main"  lldblivedebug linux
(lldb) plugin load ~/ryu/libsosplugin/libsosplugin.so
(lldb) target create lldblivedebug
Current executable set to 'lldblivedebug' (x86_64).
(lldb) target create "lldblivedebug"
Current executable set to 'lldblivedebug' (x86_64).
(lldb) settings set -- target.run-args  "linux"
(lldb) breakpoint set -n lldblivedebug.Program.Main
Breakpoint 1: no locations (pending).
WARNING:  Unable to resolve breakpoint to any actual locations.
(lldb) r
Process 28055 launched: '/home/asnegi/dotnet_test/lldblivedebug/bin/Debug/netcoreapp2.0/ubuntu.16.04-x64/lldblivedebug' (x86_64)
From foo
Process 28055 stopped
* thread #1: tid = 28055 0x00007ffff79c3709 libpthread.so.0`__pthread_cond_timedwait + 297 name = 'lldblivedebug' stop reason = signal SIGSTOP
    frame #0: 0x00007ffff79c3709 libpthread.so.0`__pthread_cond_timedwait + 297
libpthread.so.0`__pthread_cond_timedwait:
-&gt;  0x7ffff79c3709 &lt;+297&gt;: movq   %rax %r14
    0x7ffff79c370c &lt;+300&gt;: movl   (%rsp) %edi
    0x7ffff79c370f &lt;+303&gt;: callq  0x7ffff79c61c0            ; __pthread_disable_asynccancel
    0x7ffff79c3714 &lt;+308&gt;: movq   0x8(%rsp) %rdi
```

Here `From foo` comes from `Foo` function.

```gdb
(lldb) sos ClrStack
OS Thread Id: 0x6d97 (1)
        Child SP               IP Call Site
00007FFFFFFFCE18 00007ffff79c3709 [HelperMethodFrame: 00007fffffffce18] System.Threading.Thread.SleepInternal(Int32)
00007FFFFFFFCF40 00007FFF7CB3661D System.Threading.Thread.Sleep(Int32)
00007FFFFFFFCF60 00007FFF7D1B592B System.Threading.Thread.Sleep(Int32)
00007FFFFFFFCF70 00007FFF7D1504C0 lldblivedebug.Program.Main(System.String[])
00007FFFFFFFD260 00007ffff6313f07 [GCFrame: 00007fffffffd260]
00007FFFFFFFD670 00007ffff6313f07 [GCFrame: 00007fffffffd670]
(lldb) target modules list
[  0] B1E8F043-DAAA-7034-9629-D6129728A989-1A19C89E                    /home/asnegi/dotnet_test/lldblivedebug/bin/Debug/netcoreapp2.0/ubuntu.16.04-x64/lldblivedebug
[  1] BD45E79E-8A08-DCE5-67A1-E9EFB2F970A9-B2DC77D8 0x00007ffff7ffa000 [vdso] (0x00007ffff7ffa000)
[  2] 8CC8D0D1-19B1-42D8-3980-0BFF71FB71E7-3AEA7BD4                    /lib/x86_64-linux-gnu/libdl.so.2
      /usr/lib/debug/lib/x86_64-linux-gnu/libdl-2.23.so
[  3] CE17E023-5422-65FC-11D9-BC8F534BB4F0-70493D30                    /lib/x86_64-linux-gnu/libpthread.so.0
[  4] CB93C881-929B-523C-01AC-EF171B52D526-1F026029                    /usr/lib/x86_64-linux-gnu/libstdc++.so.6
[  5] DFB85DE4-2DAF-FD09-640C-8FE377D572DE-3E168920                    /lib/x86_64-linux-gnu/libm.so.6
      /usr/lib/debug/lib/x86_64-linux-gnu/libm-2.23.so
[  6] 68220AE2-C65D-65C1-B6AA-A12FA6765A6E-C2F5F434                    /lib/x86_64-linux-gnu/libgcc_s.so.1
[  7] B5381A45-7906-D279-0738-22A5CEB24C4B-FEF94DDB                    /lib/x86_64-linux-gnu/libc.so.6
      /usr/lib/debug/lib/x86_64-linux-gnu/libc-2.23.so
[  8] 5D7B6259-5522-75A3-C17B-D4C3FD05F5A6-BF40CAA5                    /lib64/ld-linux-x86-64.so.2
[  9] FA3EC34F-FF22-C058-FE6C-120AD8466ACE-A05DCEBB                    /home/asnegi/dotnet_test/lldblivedebug/bin/Debug/netcoreapp2.0/ubuntu.16.04-x64/libhostfxr.so
[ 10] 82FA3DDE-91A5-5710-F6CD-42274FF2701E-5A2E9BE3                    /home/asnegi/dotnet_test/lldblivedebug/bin/Debug/netcoreapp2.0/ubuntu.16.04-x64/libhostpolicy.so
[ 11] FC9AA4F0-E049-E703-DA1B-0108018007F6-17295119                    /home/asnegi/.nuget/packages/runtime.linux-x64.microsoft.netcore.app/2.0.0/runtimes/linux-x64/native/libcoreclr.so
[ 12] 89C34D7A-1823-87D7-6D5C-DA1F7718F5D5-8824DFB3                    /lib/x86_64-linux-gnu/librt.so.1
      /usr/lib/debug/lib/x86_64-linux-gnu/librt-2.23.so
[ 13] 29F63E3B-24F9-5E95-5C76-E58354DB3294-944105A1                    /usr/lib/x86_64-linux-gnu/libunwind.so.8
[ 14] 13BF33CF-CE9A-8E60-360A-390912876AC2-75C8AD93                    /lib/x86_64-linux-gnu/libuuid.so.1
[ 15] 1E80512E-50EA-07A3-BEB3-6D91C30B3B33-283967AB                    /usr/lib/x86_64-linux-gnu/libunwind-x86_64.so.8
[ 16] 15AED485-5920-E5A0-FB87-91B683EB88C7-E1199260                    /lib/x86_64-linux-gnu/liblzma.so.5
[ 17] 6EF619CF-DB93-245E-64CF-A85A216BC193-BBDC2C41                    /home/asnegi/.nuget/packages/runtime.linux-x64.microsoft.netcore.app/2.0.0/runtimes/linux-x64/native/libcoreclrtraceptprovider.so
[ 18] 269756FB-4AD2-E616-3CA4-FD34A3237739-A3AA962C                    /usr/lib/x86_64-linux-gnu/liblttng-ust.so.0
[ 19] 499250C2-6B5E-9CDE-B4A1-BBD03E15A2F5-E0B9CE55                    /usr/lib/x86_64-linux-gnu/liblttng-ust-tracepoint.so.0
[ 20] C090387F-8C58-1779-4A75-0B3439405DAA-C1FA75EE                    /usr/lib/x86_64-linux-gnu/liburcu-bp.so.4
[ 21] 9A5A4438-D46B-C130-7719-71A903B29757-00C8BC25                    /usr/lib/x86_64-linux-gnu/liburcu-cds.so.4
[ 22] 92F4379E-B144-FCB9-47CD-A120F46B67A7-A38D39F9                    /home/asnegi/.nuget/packages/runtime.linux-x64.microsoft.netcore.app/2.0.0/runtimes/linux-x64/native/libclrjit.so
[ 23] F3FA2CBA-8B15-ABC5-E785-BE2B38B6F620-E4E617A4                    /home/asnegi/.nuget/packages/runtime.linux-x64.microsoft.netcore.app/2.0.0/runtimes/linux-x64/native/System.Globalization.Native.so
[ 24] 463D8B61-0702-D64A-E080-3C7DFCAA02CF-B4C6477B                    /usr/lib/x86_64-linux-gnu/libicuuc.so.55.1
[ 25] 2CC92B3E-C411-16DD-818F-3DAF7DA7CBB4-10183DD6                    /usr/lib/x86_64-linux-gnu/libicudata.so.55
[ 26] F5BE69B9-2B74-26F1-7A61-E1A1308115A9-FE73C51D                    /usr/lib/x86_64-linux-gnu/libicui18n.so.55.1
[ 27] 7B4BE8CE-1CC5-DCF8-629A-A008500A93F0-E77577A0                    /home/asnegi/.nuget/packages/runtime.linux-x64.microsoft.netcore.app/2.0.0/runtimes/linux-x64/native/System.Native.so
(lldb) bpmd lldblivedebug lldblivedebug.Program.Foo
Adding pending breakpoints...
(lldb) bpmd lldblivedebug Program.Foo
Adding pending breakpoints...
(lldb) bpmd lldblivedebug.Program.Foo
Adding pending breakpoints...
(lldb) bpmd -list
bpmd pending breakpoint list
 Breakpoint index - Location ModuleID Method Token
1 - lldblivedebug.Program.Foo!Program.Foo+0 0x0000000000000000 0x00000000
2 - lldblivedebug!Program.Foo+0 0x0000000000000000 0x00000000
3 - lldblivedebug!lldblivedebug.Program.Foo+0 0x0000000000000000 0x00000000
(lldb) c
Process 28055 resuming
From foo
From foo
Process 28055 stopped
* thread #1: tid = 28055 0x00007ffff79c3709 libpthread.so.0`__pthread_cond_timedwait + 297 name = 'lldblivedebug' stop reason = signal SIGSTOP
    frame #0: 0x00007ffff79c3709 libpthread.so.0`__pthread_cond_timedwait + 297
libpthread.so.0`__pthread_cond_timedwait:
-&gt;  0x7ffff79c3709 &lt;+297&gt;: movq   %rax %r14
    0x7ffff79c370c &lt;+300&gt;: movl   (%rsp) %edi
    0x7ffff79c370f &lt;+303&gt;: callq  0x7ffff79c61c0            ; __pthread_disable_asynccancel
    0x7ffff79c3714 &lt;+308&gt;: movq   0x8(%rsp) %rdi
```

Q1. Why does not `target modules list` does not have `lldblivedebug.dll` in its list ?
       Is `[vdso] (0x00007ffff7ffa000)` in above `target modules list` actually `lldblivedebug.dll` ?

Q2. I think I don't understand how to use `bpmd` command in lldb on Linux. Can you please explain how to pass right module name to `bpmd` ?

Other info :
```
asnegi@asnegi-vm ~/dotnet_test/lldblivedebug/bin/Debug/netcoreapp2.0/ubuntu.16.04-x64 $ dotnet --info
.NET Command Line Tools (2.0.3)

Product Information:
 Version:            2.0.3
 Commit SHA-1 hash:  eb1d5ee318

Runtime Environment:
 OS Name:     ubuntu
 OS Version:  16.04
 OS Platform: Linux
 RID:         ubuntu.16.04-x64
 Base Path:   /usr/share/dotnet/sdk/2.0.3/

Microsoft .NET Core Shared Framework Host

  Version  : 2.0.7
  Build    : 2d61d0b043915bc948ebf98836fefe9ba942be11
```
</Description>
    <Title_Description>Setting breakpoint in managed function using lldb I want to set breakpoint on my function `Foo` in below program.

```cs
// Program.cs

using System;
using System.Threading;

namespace lldblivedebug
{
    class Program
    {
        static void Main(string[] args)
        {
            int count = 1;
            while (count &gt; 0)
            {
                 Thread.Sleep(2000);
                 count = count + 1;
                 Foo();
            }
        }

        static void Foo()
        {
             Console.WriteLine("From foo");
        }
    }
}

```

I can see managed stack trace. But I am not able to set the breakpoints on function.
I tried command `bpmd`. I don't totally understand what should be next argument to `bpmd` on Linux.
`bpmd &lt;module_name&gt; &lt;Fully_qualified_funciton&gt;`.

If my executable name is X and code is in X.dll on linux Is `module_name` in above command `X.dll` or `X` ?

Here is a sample lldb session of what I tried.

```
dotnet build -r ubuntu.16.04-x64
cd ~/dotnet_test/lldblivedebug/bin/Debug/netcoreapp2.0/ubuntu.16.04-x64
```
```gdb
asnegi@asnegi-vm ~/dotnet_test/lldblivedebug/bin/Debug/netcoreapp2.0/ubuntu.16.04-x64 $ lldb-3.9 -O "plugin load ~/ryu/libsosplugin/libsosplugin.so" -O "target create lldblivedebug" -o "breakpoint set -n lldblivedebug.Program.Main"  lldblivedebug linux
(lldb) plugin load ~/ryu/libsosplugin/libsosplugin.so
(lldb) target create lldblivedebug
Current executable set to 'lldblivedebug' (x86_64).
(lldb) target create "lldblivedebug"
Current executable set to 'lldblivedebug' (x86_64).
(lldb) settings set -- target.run-args  "linux"
(lldb) breakpoint set -n lldblivedebug.Program.Main
Breakpoint 1: no locations (pending).
WARNING:  Unable to resolve breakpoint to any actual locations.
(lldb) r
Process 28055 launched: '/home/asnegi/dotnet_test/lldblivedebug/bin/Debug/netcoreapp2.0/ubuntu.16.04-x64/lldblivedebug' (x86_64)
From foo
Process 28055 stopped
* thread #1: tid = 28055 0x00007ffff79c3709 libpthread.so.0`__pthread_cond_timedwait + 297 name = 'lldblivedebug' stop reason = signal SIGSTOP
    frame #0: 0x00007ffff79c3709 libpthread.so.0`__pthread_cond_timedwait + 297
libpthread.so.0`__pthread_cond_timedwait:
-&gt;  0x7ffff79c3709 &lt;+297&gt;: movq   %rax %r14
    0x7ffff79c370c &lt;+300&gt;: movl   (%rsp) %edi
    0x7ffff79c370f &lt;+303&gt;: callq  0x7ffff79c61c0            ; __pthread_disable_asynccancel
    0x7ffff79c3714 &lt;+308&gt;: movq   0x8(%rsp) %rdi
```

Here `From foo` comes from `Foo` function.

```gdb
(lldb) sos ClrStack
OS Thread Id: 0x6d97 (1)
        Child SP               IP Call Site
00007FFFFFFFCE18 00007ffff79c3709 [HelperMethodFrame: 00007fffffffce18] System.Threading.Thread.SleepInternal(Int32)
00007FFFFFFFCF40 00007FFF7CB3661D System.Threading.Thread.Sleep(Int32)
00007FFFFFFFCF60 00007FFF7D1B592B System.Threading.Thread.Sleep(Int32)
00007FFFFFFFCF70 00007FFF7D1504C0 lldblivedebug.Program.Main(System.String[])
00007FFFFFFFD260 00007ffff6313f07 [GCFrame: 00007fffffffd260]
00007FFFFFFFD670 00007ffff6313f07 [GCFrame: 00007fffffffd670]
(lldb) target modules list
[  0] B1E8F043-DAAA-7034-9629-D6129728A989-1A19C89E                    /home/asnegi/dotnet_test/lldblivedebug/bin/Debug/netcoreapp2.0/ubuntu.16.04-x64/lldblivedebug
[  1] BD45E79E-8A08-DCE5-67A1-E9EFB2F970A9-B2DC77D8 0x00007ffff7ffa000 [vdso] (0x00007ffff7ffa000)
[  2] 8CC8D0D1-19B1-42D8-3980-0BFF71FB71E7-3AEA7BD4                    /lib/x86_64-linux-gnu/libdl.so.2
      /usr/lib/debug/lib/x86_64-linux-gnu/libdl-2.23.so
[  3] CE17E023-5422-65FC-11D9-BC8F534BB4F0-70493D30                    /lib/x86_64-linux-gnu/libpthread.so.0
[  4] CB93C881-929B-523C-01AC-EF171B52D526-1F026029                    /usr/lib/x86_64-linux-gnu/libstdc++.so.6
[  5] DFB85DE4-2DAF-FD09-640C-8FE377D572DE-3E168920                    /lib/x86_64-linux-gnu/libm.so.6
      /usr/lib/debug/lib/x86_64-linux-gnu/libm-2.23.so
[  6] 68220AE2-C65D-65C1-B6AA-A12FA6765A6E-C2F5F434                    /lib/x86_64-linux-gnu/libgcc_s.so.1
[  7] B5381A45-7906-D279-0738-22A5CEB24C4B-FEF94DDB                    /lib/x86_64-linux-gnu/libc.so.6
      /usr/lib/debug/lib/x86_64-linux-gnu/libc-2.23.so
[  8] 5D7B6259-5522-75A3-C17B-D4C3FD05F5A6-BF40CAA5                    /lib64/ld-linux-x86-64.so.2
[  9] FA3EC34F-FF22-C058-FE6C-120AD8466ACE-A05DCEBB                    /home/asnegi/dotnet_test/lldblivedebug/bin/Debug/netcoreapp2.0/ubuntu.16.04-x64/libhostfxr.so
[ 10] 82FA3DDE-91A5-5710-F6CD-42274FF2701E-5A2E9BE3                    /home/asnegi/dotnet_test/lldblivedebug/bin/Debug/netcoreapp2.0/ubuntu.16.04-x64/libhostpolicy.so
[ 11] FC9AA4F0-E049-E703-DA1B-0108018007F6-17295119                    /home/asnegi/.nuget/packages/runtime.linux-x64.microsoft.netcore.app/2.0.0/runtimes/linux-x64/native/libcoreclr.so
[ 12] 89C34D7A-1823-87D7-6D5C-DA1F7718F5D5-8824DFB3                    /lib/x86_64-linux-gnu/librt.so.1
      /usr/lib/debug/lib/x86_64-linux-gnu/librt-2.23.so
[ 13] 29F63E3B-24F9-5E95-5C76-E58354DB3294-944105A1                    /usr/lib/x86_64-linux-gnu/libunwind.so.8
[ 14] 13BF33CF-CE9A-8E60-360A-390912876AC2-75C8AD93                    /lib/x86_64-linux-gnu/libuuid.so.1
[ 15] 1E80512E-50EA-07A3-BEB3-6D91C30B3B33-283967AB                    /usr/lib/x86_64-linux-gnu/libunwind-x86_64.so.8
[ 16] 15AED485-5920-E5A0-FB87-91B683EB88C7-E1199260                    /lib/x86_64-linux-gnu/liblzma.so.5
[ 17] 6EF619CF-DB93-245E-64CF-A85A216BC193-BBDC2C41                    /home/asnegi/.nuget/packages/runtime.linux-x64.microsoft.netcore.app/2.0.0/runtimes/linux-x64/native/libcoreclrtraceptprovider.so
[ 18] 269756FB-4AD2-E616-3CA4-FD34A3237739-A3AA962C                    /usr/lib/x86_64-linux-gnu/liblttng-ust.so.0
[ 19] 499250C2-6B5E-9CDE-B4A1-BBD03E15A2F5-E0B9CE55                    /usr/lib/x86_64-linux-gnu/liblttng-ust-tracepoint.so.0
[ 20] C090387F-8C58-1779-4A75-0B3439405DAA-C1FA75EE                    /usr/lib/x86_64-linux-gnu/liburcu-bp.so.4
[ 21] 9A5A4438-D46B-C130-7719-71A903B29757-00C8BC25                    /usr/lib/x86_64-linux-gnu/liburcu-cds.so.4
[ 22] 92F4379E-B144-FCB9-47CD-A120F46B67A7-A38D39F9                    /home/asnegi/.nuget/packages/runtime.linux-x64.microsoft.netcore.app/2.0.0/runtimes/linux-x64/native/libclrjit.so
[ 23] F3FA2CBA-8B15-ABC5-E785-BE2B38B6F620-E4E617A4                    /home/asnegi/.nuget/packages/runtime.linux-x64.microsoft.netcore.app/2.0.0/runtimes/linux-x64/native/System.Globalization.Native.so
[ 24] 463D8B61-0702-D64A-E080-3C7DFCAA02CF-B4C6477B                    /usr/lib/x86_64-linux-gnu/libicuuc.so.55.1
[ 25] 2CC92B3E-C411-16DD-818F-3DAF7DA7CBB4-10183DD6                    /usr/lib/x86_64-linux-gnu/libicudata.so.55
[ 26] F5BE69B9-2B74-26F1-7A61-E1A1308115A9-FE73C51D                    /usr/lib/x86_64-linux-gnu/libicui18n.so.55.1
[ 27] 7B4BE8CE-1CC5-DCF8-629A-A008500A93F0-E77577A0                    /home/asnegi/.nuget/packages/runtime.linux-x64.microsoft.netcore.app/2.0.0/runtimes/linux-x64/native/System.Native.so
(lldb) bpmd lldblivedebug lldblivedebug.Program.Foo
Adding pending breakpoints...
(lldb) bpmd lldblivedebug Program.Foo
Adding pending breakpoints...
(lldb) bpmd lldblivedebug.Program.Foo
Adding pending breakpoints...
(lldb) bpmd -list
bpmd pending breakpoint list
 Breakpoint index - Location ModuleID Method Token
1 - lldblivedebug.Program.Foo!Program.Foo+0 0x0000000000000000 0x00000000
2 - lldblivedebug!Program.Foo+0 0x0000000000000000 0x00000000
3 - lldblivedebug!lldblivedebug.Program.Foo+0 0x0000000000000000 0x00000000
(lldb) c
Process 28055 resuming
From foo
From foo
Process 28055 stopped
* thread #1: tid = 28055 0x00007ffff79c3709 libpthread.so.0`__pthread_cond_timedwait + 297 name = 'lldblivedebug' stop reason = signal SIGSTOP
    frame #0: 0x00007ffff79c3709 libpthread.so.0`__pthread_cond_timedwait + 297
libpthread.so.0`__pthread_cond_timedwait:
-&gt;  0x7ffff79c3709 &lt;+297&gt;: movq   %rax %r14
    0x7ffff79c370c &lt;+300&gt;: movl   (%rsp) %edi
    0x7ffff79c370f &lt;+303&gt;: callq  0x7ffff79c61c0            ; __pthread_disable_asynccancel
    0x7ffff79c3714 &lt;+308&gt;: movq   0x8(%rsp) %rdi
```

Q1. Why does not `target modules list` does not have `lldblivedebug.dll` in its list ?
       Is `[vdso] (0x00007ffff7ffa000)` in above `target modules list` actually `lldblivedebug.dll` ?

Q2. I think I don't understand how to use `bpmd` command in lldb on Linux. Can you please explain how to pass right module name to `bpmd` ?

Other info :
```
asnegi@asnegi-vm ~/dotnet_test/lldblivedebug/bin/Debug/netcoreapp2.0/ubuntu.16.04-x64 $ dotnet --info
.NET Command Line Tools (2.0.3)

Product Information:
 Version:            2.0.3
 Commit SHA-1 hash:  eb1d5ee318

Runtime Environment:
 OS Name:     ubuntu
 OS Version:  16.04
 OS Platform: Linux
 RID:         ubuntu.16.04-x64
 Base Path:   /usr/share/dotnet/sdk/2.0.3/

Microsoft .NET Core Shared Framework Host

  Version  : 2.0.7
  Build    : 2d61d0b043915bc948ebf98836fefe9ba942be11
```
</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>2/06/2018 11:54:29 AM +00:00</CreatedAt>
    <ClosedAt>7/06/2018 11:13:35 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18249</IssueLabelID>
    <Title>Convert Decimal to all-managed implementation</Title>
    <Description>CoreCLR's is in
https://github.com/dotnet/coreclr/blob/master/src/System.Private.CoreLib/src/System/Decimal.cs
https://github.com/dotnet/coreclr/blob/master/src/classlibnative/bcltype/decimal.cpp

The place to start is by grabbing the code verbatim from CoreRT and measuring performance then optimizing to fix any regression:

https://github.com/dotnet/corert/blob/master/src/System.Private.CoreLib/src/System/Decimal.cs
https://github.com/dotnet/corert/blob/master/src/System.Private.CoreLib/src/System/Decimal.DecCalc.cs

Ensuring tests have good coverage of course.</Description>
    <Title_Description>Convert Decimal to all-managed implementation CoreCLR's is in
https://github.com/dotnet/coreclr/blob/master/src/System.Private.CoreLib/src/System/Decimal.cs
https://github.com/dotnet/coreclr/blob/master/src/classlibnative/bcltype/decimal.cpp

The place to start is by grabbing the code verbatim from CoreRT and measuring performance then optimizing to fix any regression:

https://github.com/dotnet/corert/blob/master/src/System.Private.CoreLib/src/System/Decimal.cs
https://github.com/dotnet/corert/blob/master/src/System.Private.CoreLib/src/System/Decimal.DecCalc.cs

Ensuring tests have good coverage of course.</Title_Description>
    <Label>Hackathon</Label>
    <Assignee>pentp</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18247</IssueLabelID>
    <Title>Fix PCODE not having thumb bit set when comparing two addresses</Title>
    <Description>
    </Description>
    <Title_Description>Fix PCODE not having thumb bit set when comparing two addresses </Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>chsienki</Assignee>
    <CreatedAt>1/06/2018 10:44:09 PM +00:00</CreatedAt>
    <ClosedAt>11/06/2018 6:12:45 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18246</IssueLabelID>
    <Title>Enable tailcall_v4\smallFrame\smallFrame</Title>
    <Description>PR #11316  removed the bad IL sequences from this test but left these tests disabled for arm/arm64.</Description>
    <Title_Description>Enable tailcall_v4\smallFrame\smallFrame PR #11316  removed the bad IL sequences from this test but left these tests disabled for arm/arm64.</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>1/06/2018 10:35:51 PM +00:00</CreatedAt>
    <ClosedAt>2/06/2018 10:40:14 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18245</IssueLabelID>
    <Title>Replace some sizeof-s with target specific constants</Title>
    <Description>The goal of this PR is to identify all places in VM using sizeof operator that should be made target-specific in order to support cross-bitness scenario #16513. &lt;s&gt;The proposal is to introduce CrossBitness_SizeOf operator to make such places *explicit*.

CrossBitness_SizeOf operator satisfies the following conditions:
1. CrossBitness_SizeOf(X) == sizeof(X) in non-crossbitness scenarios;
2. CrossBitness_SizeOf(X) == sizeof(Y) where Y is a "fake" structure created to describe layout of X on the target platform in crossbitness scenarios (i.e. x64_arm). Note that usually sizeof(X) != sizeof(Y).&lt;/s&gt;

It's been proven experimentally that this subset of changes is needed in order to get outputs of x64_arm and arm_arm crossgens to be binary identical for S.P.C.dll and CoreFx assemblies.&lt;/s&gt;

This PR also includes other related changes:
1. `LOG2_PTRSIZE` should depend on `_TARGET_64BIT_`;
2. more careful pointer arithmetic in `FakePromote` and `ReportPointersFromValueType`.

&lt;s&gt;This PR is to initiate design discussion (at alternatives discussion) and not a final work.&lt;/s&gt;

**Update:** the final solution is to replace identified `sizeof` expressions with target-specifics constants

@jkotas PTAL</Description>
    <Title_Description>Replace some sizeof-s with target specific constants The goal of this PR is to identify all places in VM using sizeof operator that should be made target-specific in order to support cross-bitness scenario #16513. &lt;s&gt;The proposal is to introduce CrossBitness_SizeOf operator to make such places *explicit*.

CrossBitness_SizeOf operator satisfies the following conditions:
1. CrossBitness_SizeOf(X) == sizeof(X) in non-crossbitness scenarios;
2. CrossBitness_SizeOf(X) == sizeof(Y) where Y is a "fake" structure created to describe layout of X on the target platform in crossbitness scenarios (i.e. x64_arm). Note that usually sizeof(X) != sizeof(Y).&lt;/s&gt;

It's been proven experimentally that this subset of changes is needed in order to get outputs of x64_arm and arm_arm crossgens to be binary identical for S.P.C.dll and CoreFx assemblies.&lt;/s&gt;

This PR also includes other related changes:
1. `LOG2_PTRSIZE` should depend on `_TARGET_64BIT_`;
2. more careful pointer arithmetic in `FakePromote` and `ReportPointersFromValueType`.

&lt;s&gt;This PR is to initiate design discussion (at alternatives discussion) and not a final work.&lt;/s&gt;

**Update:** the final solution is to replace identified `sizeof` expressions with target-specifics constants

@jkotas PTAL</Title_Description>
    <Label>area-VM</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>1/06/2018 10:34:34 PM +00:00</CreatedAt>
    <ClosedAt>4/06/2018 5:08:23 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18244</IssueLabelID>
    <Title>Exception when trying to GCHandle.Alloc(new ValueTuple&lt;ulong ulong&gt;[1] GCHandleType.Pinned)</Title>
    <Description>I'm getting exception when I try to pin array of `ValueTuple`s using this statement with .NET Core 2.1 release:

&gt; GCHandle.Alloc(new ValueTuple&lt;ulong ulong&gt;[1] GCHandleType.Pinned)

The exception tells:
&gt; System.ArgumentException
&gt;   HResult=0x80070057
&gt;   Message=Object contains non-primitive or non-blittable data.
&gt;   Source=System.Private.CoreLib
&gt;   StackTrace:
&gt;    at System.Runtime.InteropServices.GCHandle.InternalAlloc(Object value GCHandleType type)
&gt;    at System.Runtime.InteropServices.GCHandle.Alloc(Object value GCHandleType type) in E:\A\_work\31\s\src\mscorlib\src\System\Runtime\InteropServices\GcHandle.cs:line 94
</Description>
    <Title_Description>Exception when trying to GCHandle.Alloc(new ValueTuple&lt;ulong, ulong&gt;[1], GCHandleType.Pinned) I'm getting exception when I try to pin array of `ValueTuple`s using this statement with .NET Core 2.1 release:

&gt; GCHandle.Alloc(new ValueTuple&lt;ulong ulong&gt;[1] GCHandleType.Pinned)

The exception tells:
&gt; System.ArgumentException
&gt;   HResult=0x80070057
&gt;   Message=Object contains non-primitive or non-blittable data.
&gt;   Source=System.Private.CoreLib
&gt;   StackTrace:
&gt;    at System.Runtime.InteropServices.GCHandle.InternalAlloc(Object value GCHandleType type)
&gt;    at System.Runtime.InteropServices.GCHandle.Alloc(Object value GCHandleType type) in E:\A\_work\31\s\src\mscorlib\src\System\Runtime\InteropServices\GcHandle.cs:line 94
</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>1/06/2018 9:37:41 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18242</IssueLabelID>
    <Title>Mirror changes from dotnet/corert</Title>
    <Description>This PR contains mirrored changes from dotnet/corert


**Please REBASE this PR when merging**</Description>
    <Title_Description>Mirror changes from dotnet/corert This PR contains mirrored changes from dotnet/corert


**Please REBASE this PR when merging**</Title_Description>
    <Label>
    </Label>
    <Assignee>jkotas</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18238</IssueLabelID>
    <Title>Cast to ushort is dropped in release</Title>
    <Description>The following program gives different outputs for release and debug:
```csharp
public class Program
{
    static short s_2 = -1000;

    public static void Main()
    {
        ulong var1 = (ushort)(1U ^ s_2);
        Console.WriteLine(var1);
    }
}
```
In release the result is `4294966297`. In debug the result is `64537`.
@mikedn has analyzed the cause [here](https://github.com/dotnet/coreclr/issues/18235#issuecomment-393915294).

This issue repros on .NET framework as well with 64-bit JIT (it does not repro with 32-bit JIT).</Description>
    <Title_Description>Cast to ushort is dropped in release The following program gives different outputs for release and debug:
```csharp
public class Program
{
    static short s_2 = -1000;

    public static void Main()
    {
        ulong var1 = (ushort)(1U ^ s_2);
        Console.WriteLine(var1);
    }
}
```
In release the result is `4294966297`. In debug the result is `64537`.
@mikedn has analyzed the cause [here](https://github.com/dotnet/coreclr/issues/18235#issuecomment-393915294).

This issue repros on .NET framework as well with 64-bit JIT (it does not repro with 32-bit JIT).</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>erozenfeld</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18235</IssueLabelID>
    <Title>Wrong integer promotion in release</Title>
    <Description>For .NET core 2.1 the following program outputs 1023 in debug but 255 in release.
```csharp
using System;

class C0
{
    public sbyte F;
}

public class Program
{
    public static void Main()
    {
        C0 var0 = new C0 { F = -1 };
        ulong var1 = (ulong)(1000 | (byte)var0.F);
        Console.WriteLine(var1);
    }
}
```

This issue repros on .NET framework 4.6.1 as well with 64-bit JIT (it does not repro with 32-bit JIT). The compiler used is csc.exe 2.8.3.62923 (7aafab56).</Description>
    <Title_Description>Wrong integer promotion in release For .NET core 2.1 the following program outputs 1023 in debug but 255 in release.
```csharp
using System;

class C0
{
    public sbyte F;
}

public class Program
{
    public static void Main()
    {
        C0 var0 = new C0 { F = -1 };
        ulong var1 = (ulong)(1000 | (byte)var0.F);
        Console.WriteLine(var1);
    }
}
```

This issue repros on .NET framework 4.6.1 as well with 64-bit JIT (it does not repro with 32-bit JIT). The compiler used is csc.exe 2.8.3.62923 (7aafab56).</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>jakobbotsch</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18234</IssueLabelID>
    <Title>Enable Alpine cross build for arm and arm64</Title>
    <Description>This change enables cross build and rootfs creation for
Alpine Linux ARM / ARM64 targets.

Besides that I've cleaned up the toolchain.cmake and got rid
of the explicit specification of GCC version specific include
and lib folders for all targets except of Tizen. Clang is able
to figure that out on its own the same way as it does when doing
regular non-cross builds but it needed one more option for that.

I've also fixed a bug in the `add_compile_param` macro that caused
ignoring of parameters in cases where another parameter that was
a substring of the one being added was already present. So for example
if an option `-L${CMAKE_SYSROOT}/usr/lib/gcc` was already added 
attempt to add option `-L${CMAKE_SYSROOT}/usr/lib` would do nothing.
</Description>
    <Title_Description>Enable Alpine cross build for arm and arm64 This change enables cross build and rootfs creation for
Alpine Linux ARM / ARM64 targets.

Besides that I've cleaned up the toolchain.cmake and got rid
of the explicit specification of GCC version specific include
and lib folders for all targets except of Tizen. Clang is able
to figure that out on its own the same way as it does when doing
regular non-cross builds but it needed one more option for that.

I've also fixed a bug in the `add_compile_param` macro that caused
ignoring of parameters in cases where another parameter that was
a substring of the one being added was already present. So for example
if an option `-L${CMAKE_SYSROOT}/usr/lib/gcc` was already added 
attempt to add option `-L${CMAKE_SYSROOT}/usr/lib` would do nothing.
</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>janvorli</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18232</IssueLabelID>
    <Title>NullReferenceException thrown for multi-dimensional arrays in release</Title>
    <Description>The following program runs successfully in debug but throws a `NullReferenceException` when run in release under .NET core 2.1. This issue repros on .NET framework as well with 64-bit JIT (it does not repro with 32-bit JIT).
```csharp
class Program
{
    static int[] s_2 = new int[1 1];
    static void Main()
    {
        M(s_2[0 0] &amp; 0);
    }

    static void M(int arg0)
    {
        s_2[0 0] = arg0;
    }
}
```

The bug is not triggered if the array is changed to a single-dimensional array or if a different operator than `&amp;` is used.</Description>
    <Title_Description>NullReferenceException thrown for multi-dimensional arrays in release The following program runs successfully in debug but throws a `NullReferenceException` when run in release under .NET core 2.1. This issue repros on .NET framework as well with 64-bit JIT (it does not repro with 32-bit JIT).
```csharp
class Program
{
    static int[] s_2 = new int[1 1];
    static void Main()
    {
        M(s_2[0 0] &amp; 0);
    }

    static void M(int arg0)
    {
        s_2[0 0] = arg0;
    }
}
```

The bug is not triggered if the array is changed to a single-dimensional array or if a different operator than `&amp;` is used.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>mikedn</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18230</IssueLabelID>
    <Title>JIT: Eliminate RegTracker (#18179)</Title>
    <Description>https://github.com/dotnet/coreclr/issues/18179
@BruceForstall 
@CarolEidt </Description>
    <Title_Description>JIT: Eliminate RegTracker (#18179) https://github.com/dotnet/coreclr/issues/18179
@BruceForstall 
@CarolEidt </Title_Description>
    <Label>Hackathon</Label>
    <Assignee>cshung</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18229</IssueLabelID>
    <Title>x64 JIT crash 'Compiler::implResolveToken' for typeof(ValueType) containing array of self</Title>
    <Description>The following program crashes the **x64** JIT.

    using System;

    public struct StructTree
    {
        public Double P;
        public StructTree[] rg;
    };

    class Program
    {
        static void Main() =&gt; T = typeof(StructTree);      // &lt;-- EETypeLoadException

        static Type T; // (not important that 'T' be a non-local variable; only done here to
                       // prevent the above assignment from being fully optimized-out)
    }

The exception:

&gt;Exception thrown at 0x00007FFDFD13F218 in ConsoleApp23.exe: Microsoft C++ exception: EETypeLoadException at memory location 0x0000003F1433A450.

Stack trace:

	RaiseException()
	_CxxThrowException()
	Compiler::impResolveToken() Line 277          &lt;--- EETypeLoadException
	Compiler::impImportBlockCode() Line 14293
	Compiler::impImportBlock() Line 16079
	Compiler::impImport() Line 17163
	[Inline Frame] Compiler::fgImport() Line 6800
	Compiler::compCompile() Line 4386
	Compiler::compCompileHelper() Line 6025
	Compiler::compCompile() Line 5359
	jitNativeCode() Line 6666
	CILJit::compileMethod() Line 315
	_CorExeMain()
	_CorExeMain_Exported()
	BaseThreadInitThunk()
	RtlUserThreadStart()

Here's a link to the throwing source code form the [coreclr repo](https://github.com/dotnet/coreclr):

https://github.com/dotnet/coreclr/blob/86c438de4043359942f3e0f46c55fdaa98dc5b2f/src/jit/importer.cpp#L262-L277

As best as I can tell that would be here:

![asm](https://user-images.githubusercontent.com/5589855/40815819-f5e8d6c6-64fd-11e8-9901-98adcc270f9b.png)

The **IL** code for the problematic **C#** JIT target method (`Program.Main`) is essentially the same for *Debug* and *Release* builds and both exhibit the crash.

	L_0000: ldtoken StructTree
	L_0005: call class [mscorlib]Type [mscorlib]Type::GetTypeFromHandle(valuetype [mscorlib]RuntimeTypeHandle)
	L_000a: stsfld class [mscorlib]Type Program::T
	L_000f: ret 

To Reproduce
----

To reproduce this crash create a new **C#** project for .NET 4.7.2 in the latest VS2017. Enter the code shown at the top. Alternatively [here's a zip](https://github.com/dotnet/coreclr/files/2060673/jit-crash-resolve-token-recursive.zip) of the whole project.

Next on the *Project Properties* pane enable **Native Code Debugging**:

![app-properties](https://user-images.githubusercontent.com/5589855/40815912-a3573802-64fe-11e8-9d48-b0b8c86e142d.png)

On the *Exception Settings* pane enable exceptions as shown here:

![ex-settings](https://user-images.githubusercontent.com/5589855/40815934-cd6d1526-64fe-11e8-8929-2b773df0df56.png)

Here are the debugger settings I used. In the case of **Suppress JIT optimization on module load** it does not have any effect on the issue (the crash occurs in both modes).


![dbg-opts](https://user-images.githubusercontent.com/5589855/40816102-d3693878-64ff-11e8-82e0-16dfaa56e038.png)
</Description>
    <Title_Description>x64 JIT crash 'Compiler::implResolveToken' for typeof(ValueType) containing array of self The following program crashes the **x64** JIT.

    using System;

    public struct StructTree
    {
        public Double P;
        public StructTree[] rg;
    };

    class Program
    {
        static void Main() =&gt; T = typeof(StructTree);      // &lt;-- EETypeLoadException

        static Type T; // (not important that 'T' be a non-local variable; only done here to
                       // prevent the above assignment from being fully optimized-out)
    }

The exception:

&gt;Exception thrown at 0x00007FFDFD13F218 in ConsoleApp23.exe: Microsoft C++ exception: EETypeLoadException at memory location 0x0000003F1433A450.

Stack trace:

	RaiseException()
	_CxxThrowException()
	Compiler::impResolveToken() Line 277          &lt;--- EETypeLoadException
	Compiler::impImportBlockCode() Line 14293
	Compiler::impImportBlock() Line 16079
	Compiler::impImport() Line 17163
	[Inline Frame] Compiler::fgImport() Line 6800
	Compiler::compCompile() Line 4386
	Compiler::compCompileHelper() Line 6025
	Compiler::compCompile() Line 5359
	jitNativeCode() Line 6666
	CILJit::compileMethod() Line 315
	_CorExeMain()
	_CorExeMain_Exported()
	BaseThreadInitThunk()
	RtlUserThreadStart()

Here's a link to the throwing source code form the [coreclr repo](https://github.com/dotnet/coreclr):

https://github.com/dotnet/coreclr/blob/86c438de4043359942f3e0f46c55fdaa98dc5b2f/src/jit/importer.cpp#L262-L277

As best as I can tell that would be here:

![asm](https://user-images.githubusercontent.com/5589855/40815819-f5e8d6c6-64fd-11e8-9901-98adcc270f9b.png)

The **IL** code for the problematic **C#** JIT target method (`Program.Main`) is essentially the same for *Debug* and *Release* builds and both exhibit the crash.

	L_0000: ldtoken StructTree
	L_0005: call class [mscorlib]Type [mscorlib]Type::GetTypeFromHandle(valuetype [mscorlib]RuntimeTypeHandle)
	L_000a: stsfld class [mscorlib]Type Program::T
	L_000f: ret 

To Reproduce
----

To reproduce this crash create a new **C#** project for .NET 4.7.2 in the latest VS2017. Enter the code shown at the top. Alternatively [here's a zip](https://github.com/dotnet/coreclr/files/2060673/jit-crash-resolve-token-recursive.zip) of the whole project.

Next on the *Project Properties* pane enable **Native Code Debugging**:

![app-properties](https://user-images.githubusercontent.com/5589855/40815912-a3573802-64fe-11e8-9d48-b0b8c86e142d.png)

On the *Exception Settings* pane enable exceptions as shown here:

![ex-settings](https://user-images.githubusercontent.com/5589855/40815934-cd6d1526-64fe-11e8-8929-2b773df0df56.png)

Here are the debugger settings I used. In the case of **Suppress JIT optimization on module load** it does not have any effect on the issue (the crash occurs in both modes).


![dbg-opts](https://user-images.githubusercontent.com/5589855/40816102-d3693878-64ff-11e8-82e0-16dfaa56e038.png)
</Title_Description>
    <Label>area-TypeSystem</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>1/06/2018 1:45:43 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18228</IssueLabelID>
    <Title>[arm32][JitStressRegs=3] Assertion failed 'farthestRefPhysRegRecord != nullptr'</Title>
    <Description>https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_jitstressregs3_tst/9/consoleFull

```
21:09:37 FAILED   - JIT/Performance/CodeQuality/V8/Crypto/Crypto/Crypto.sh
21:09:37                BEGIN EXECUTION
21:09:37                /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_jitstressregs3_tst/bin/tests/Linux.arm.Checked/Tests/Core_Root/corerun Crypto.exe
21:09:37                
21:09:37 
               Assert failure(PID 17639 [0x000044e7] Thread: 17639 [0x44e7]): Assertion failed 'farthestRefPhysRegRecord != nullptr' in 'V8.Crypto.BigInteger:exp(intref):ref:this' (IL size 110)
21:09:37                
21:09:37                    File: /mnt/j/workspace/dotnet_coreclr/master/arm_cross_checked_ubuntu/src/jit/lsra.cpp Line: 3637
21:09:37                    Image: /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_jitstressregs3_tst/bin/tests/Linux.arm.Checked/Tests/Core_Root/corerun
21:09:37                
21:09:37                ./Crypto.sh: line 244: 17639 Aborted                 $_DebuggerFullPath "$CORE_ROOT/corerun" $ExePath $CLRTestExecutionArguments
21:09:37                Expected: 100
21:09:37                Actual: 134
21:09:37                END EXECUTION - FAILED
```

Possibly related: https://github.com/dotnet/coreclr/issues/18153
</Description>
    <Title_Description>[arm32][JitStressRegs=3] Assertion failed 'farthestRefPhysRegRecord != nullptr' https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_jitstressregs3_tst/9/consoleFull

```
21:09:37 FAILED   - JIT/Performance/CodeQuality/V8/Crypto/Crypto/Crypto.sh
21:09:37                BEGIN EXECUTION
21:09:37                /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_jitstressregs3_tst/bin/tests/Linux.arm.Checked/Tests/Core_Root/corerun Crypto.exe
21:09:37                
21:09:37 
               Assert failure(PID 17639 [0x000044e7] Thread: 17639 [0x44e7]): Assertion failed 'farthestRefPhysRegRecord != nullptr' in 'V8.Crypto.BigInteger:exp(intref):ref:this' (IL size 110)
21:09:37                
21:09:37                    File: /mnt/j/workspace/dotnet_coreclr/master/arm_cross_checked_ubuntu/src/jit/lsra.cpp Line: 3637
21:09:37                    Image: /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_jitstressregs3_tst/bin/tests/Linux.arm.Checked/Tests/Core_Root/corerun
21:09:37                
21:09:37                ./Crypto.sh: line 244: 17639 Aborted                 $_DebuggerFullPath "$CORE_ROOT/corerun" $ExePath $CLRTestExecutionArguments
21:09:37                Expected: 100
21:09:37                Actual: 134
21:09:37                END EXECUTION - FAILED
```

Possibly related: https://github.com/dotnet/coreclr/issues/18153
</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18210</IssueLabelID>
    <Title>Fix GitHub_16041 test.</Title>
    <Description>This was doing a cpblk of 28 bytes (size of StructY) from StructX but StructX was only 12 bytes big. Change StructY size to 12.

The discussion was in #16090.
cc @dotnet/jit-contrib.

I have checked that with the new size it still repro the original issue (but only on the old version now It doesn't create necessary `GT_COMMA` for some reasons).</Description>
    <Title_Description>Fix GitHub_16041 test. This was doing a cpblk of 28 bytes (size of StructY) from StructX but StructX was only 12 bytes big. Change StructY size to 12.

The discussion was in #16090.
cc @dotnet/jit-contrib.

I have checked that with the new size it still repro the original issue (but only on the old version now It doesn't create necessary `GT_COMMA` for some reasons).</Title_Description>
    <Label>test bug</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>30/05/2018 11:36:27 PM +00:00</CreatedAt>
    <ClosedAt>1/06/2018 6:08:34 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18209</IssueLabelID>
    <Title>Support new Japanese calendar eras</Title>
    <Description>Japan is going to introduce the new era next year 2019 this new era will be added to the Japanese calendar. This new era would affect anyone converting formatting or parsing dates using the Japanese calendar.
Users who formatted future dates before introducing the new era and then try to parse these dates after introducing the new era will fail and get parsing exception. The reason is the year number will not be valid in the old era anymore because the new era set a year limit to the old era.

Here is an example:

Format a date like "平成 32年2月1日" which saying year 32 in the era "平成". after we introduce the new era the old era "平成" will be limited up to and including year 31 so year 32 is exceeding the era end.

The fix is to allow the parser succeeds with such dates and have a config switch which can be used to for anyone want the old behavior.</Description>
    <Title_Description>Support new Japanese calendar eras Japan is going to introduce the new era next year 2019 this new era will be added to the Japanese calendar. This new era would affect anyone converting formatting or parsing dates using the Japanese calendar.
Users who formatted future dates before introducing the new era and then try to parse these dates after introducing the new era will fail and get parsing exception. The reason is the year number will not be valid in the old era anymore because the new era set a year limit to the old era.

Here is an example:

Format a date like "平成 32年2月1日" which saying year 32 in the era "平成". after we introduce the new era the old era "平成" will be limited up to and including year 31 so year 32 is exceeding the era end.

The fix is to allow the parser succeeds with such dates and have a config switch which can be used to for anyone want the old behavior.</Title_Description>
    <Label>area-System.Globalization</Label>
    <Assignee>tarekgh</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18208</IssueLabelID>
    <Title>Optimize Encoding.ASCII</Title>
    <Description>`Encoding.ASCII` has room for optimization such as vectorizing the `GetBytes` / `GetChars` methods simplifying `if` checks and so on.

(This is a nice-to-have. This isn't blocking anything as I know.)</Description>
    <Title_Description>Optimize Encoding.ASCII `Encoding.ASCII` has room for optimization such as vectorizing the `GetBytes` / `GetChars` methods simplifying `if` checks and so on.

(This is a nice-to-have. This isn't blocking anything as I know.)</Title_Description>
    <Label>area-System.Runtime</Label>
    <Assignee>GrabYourPitchforks</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18207</IssueLabelID>
    <Title>Moving MissingFieldException (fully) and MissingMethodException (partially) to shared</Title>
    <Description>- **[First 5 commits explained]**: Reduce diff of StackTrace with coreclr version by (1) moving StackFrameHelper class to its own file (2) renaming and (3) cleaning up documentation
- Reduces diff in MemoryFailPoint by renaming private field
- Reduces diff in TypeLoadException by changing String to string
- Reduces diff in ThrowHelper by sorting using
- **[Last 4 commits explained]**: Moving MissingFieldException and MissingMethodException partially to shared

CoreRT PR: https://github.com/dotnet/corert/pull/5868

cc: @jkotas </Description>
    <Title_Description>Moving MissingFieldException (fully) and MissingMethodException (partially) to shared - **[First 5 commits explained]**: Reduce diff of StackTrace with coreclr version by (1) moving StackFrameHelper class to its own file (2) renaming and (3) cleaning up documentation
- Reduces diff in MemoryFailPoint by renaming private field
- Reduces diff in TypeLoadException by changing String to string
- Reduces diff in ThrowHelper by sorting using
- **[Last 4 commits explained]**: Moving MissingFieldException and MissingMethodException partially to shared

CoreRT PR: https://github.com/dotnet/corert/pull/5868

cc: @jkotas </Title_Description>
    <Label>
    </Label>
    <Assignee>maryamariyan</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18206</IssueLabelID>
    <Title>[arm64] Disable `a % b = a &amp; (b - 1);` optimization.</Title>
    <Description>Morph can't relay on Lower optimization that it can't guarantee.

In this test case we have such tree:
```
               [000041] ------------                   /--*  CAST      long &lt;- int
               [000040] ------------                   |  \--*  CNS_INT   int    1
               [000042] ---X--------                /--*  UMOD      long  
			                                              / *** 
               [000024] ---X--------                |  \--*  MUL       long
			                                              \ ***

```
Moprh thinks that Lower will optimize it as `a % b = a &amp; (b - 1); ` but then `a` tree is found to be a constant:
```
N034 (  1  1) [000041] ------------                      /--*  CNS_INT   long   1 $182
N035 ( 36 24) [000042] -A-X--------                   /--*  UMOD      long   $287
N032 (  1  1) [000023] ------------                   |  /--*  CNS_INT   long   0 $180
N033 ( 34 22) [000024] -A-X--------                   \--*  COMMA     long
                                                          \ *** 
```
and Lower rejects optimizing `a % b` when both operands are const.

It cases assert during Lsra: `assert(!"Shouldn't see an integer typed GT_MOD node in ARM64");`

The fix is similar to #17338.

Fixes #17968.

PR #15690 can help to return this optimization back.</Description>
    <Title_Description>[arm64] Disable `a % b = a &amp; (b - 1);` optimization. Morph can't relay on Lower optimization that it can't guarantee.

In this test case we have such tree:
```
               [000041] ------------                   /--*  CAST      long &lt;- int
               [000040] ------------                   |  \--*  CNS_INT   int    1
               [000042] ---X--------                /--*  UMOD      long  
			                                              / *** 
               [000024] ---X--------                |  \--*  MUL       long
			                                              \ ***

```
Moprh thinks that Lower will optimize it as `a % b = a &amp; (b - 1); ` but then `a` tree is found to be a constant:
```
N034 (  1  1) [000041] ------------                      /--*  CNS_INT   long   1 $182
N035 ( 36 24) [000042] -A-X--------                   /--*  UMOD      long   $287
N032 (  1  1) [000023] ------------                   |  /--*  CNS_INT   long   0 $180
N033 ( 34 22) [000024] -A-X--------                   \--*  COMMA     long
                                                          \ *** 
```
and Lower rejects optimizing `a % b` when both operands are const.

It cases assert during Lsra: `assert(!"Shouldn't see an integer typed GT_MOD node in ARM64");`

The fix is similar to #17338.

Fixes #17968.

PR #15690 can help to return this optimization back.</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>30/05/2018 9:42:47 PM +00:00</CreatedAt>
    <ClosedAt>1/06/2018 11:19:19 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18205</IssueLabelID>
    <Title>Remove some GT_ASG_op leftovers</Title>
    <Description>
    </Description>
    <Title_Description>Remove some GT_ASG_op leftovers </Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>30/05/2018 7:31:08 PM +00:00</CreatedAt>
    <ClosedAt>25/08/2018 10:30:58 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18204</IssueLabelID>
    <Title>Expose SpinWait.SpinOnce(int sleep1Threshold) overload</Title>
    <Description>To allow customizing the spin count threshold for Sleep(1) usage and to allow disabling the use of Sleep(1).

API review: https://github.com/dotnet/corefx/issues/29623
Part of fix for https://github.com/dotnet/corefx/issues/29595</Description>
    <Title_Description>Expose SpinWait.SpinOnce(int sleep1Threshold) overload To allow customizing the spin count threshold for Sleep(1) usage and to allow disabling the use of Sleep(1).

API review: https://github.com/dotnet/corefx/issues/29623
Part of fix for https://github.com/dotnet/corefx/issues/29595</Title_Description>
    <Label>area-System.Threading</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18203</IssueLabelID>
    <Title>Expose Exception.set_HResult as Public</Title>
    <Description>This is to change Excetion.set_HResult from protected to public so that others can set HResult value for a given exception.

Approved API: https://github.com/dotnet/corefx/issues/29696
Related Corefx Change(ref assembly): https://github.com/dotnet/corefx/pull/29986</Description>
    <Title_Description>Expose Exception.set_HResult as Public This is to change Excetion.set_HResult from protected to public so that others can set HResult value for a given exception.

Approved API: https://github.com/dotnet/corefx/issues/29696
Related Corefx Change(ref assembly): https://github.com/dotnet/corefx/pull/29986</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>luqunl</Assignee>
    <CreatedAt>30/05/2018 6:54:14 PM +00:00</CreatedAt>
    <ClosedAt>31/05/2018 2:37:51 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18202</IssueLabelID>
    <Title>Is Multi-Core JIT ProfileOptimization possible with CoreCLR?</Title>
    <Description>Hey 

This is a question regarding the API `ProfileOptimization.SetProfileRoot` and `ProfileOptimization.StartProfile`. It doesn't seem to be available through .NET CoreCLR (and almost no issues apart #17124) there is a bit of multi-core JIT in [multicorejit.h](https://github.com/dotnet/coreclr/blob/master/src/vm/multicorejit.h) with actually the internal calls declared for both SetProfileRoot/StartProfile... but no C# version of it...

So just wondering if it could be available? If not what were the reason? (Not really used? Not compatible with CoreCLR?...etc.)

Thanks!</Description>
    <Title_Description>Is Multi-Core JIT, ProfileOptimization possible with CoreCLR? Hey 

This is a question regarding the API `ProfileOptimization.SetProfileRoot` and `ProfileOptimization.StartProfile`. It doesn't seem to be available through .NET CoreCLR (and almost no issues apart #17124) there is a bit of multi-core JIT in [multicorejit.h](https://github.com/dotnet/coreclr/blob/master/src/vm/multicorejit.h) with actually the internal calls declared for both SetProfileRoot/StartProfile... but no C# version of it...

So just wondering if it could be available? If not what were the reason? (Not really used? Not compatible with CoreCLR?...etc.)

Thanks!</Title_Description>
    <Label>area-VM</Label>
    <Assignee>brianrob</Assignee>
    <CreatedAt>30/05/2018 6:47:24 PM +00:00</CreatedAt>
    <ClosedAt>31/05/2018 2:51:51 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18201</IssueLabelID>
    <Title>Eliminate GenTreeRegVar and GT_REG_VAR</Title>
    <Description>These are no longer used with the removal of `LEGACY_BACKEND`.

category:design
theme:ir
skill-level:intermediate
cost:small</Description>
    <Title_Description>Eliminate GenTreeRegVar and GT_REG_VAR These are no longer used with the removal of `LEGACY_BACKEND`.

category:design
theme:ir
skill-level:intermediate
cost:small</Title_Description>
    <Label>Hackathon</Label>
    <Assignee>CarolEidt</Assignee>
    <CreatedAt>30/05/2018 6:22:45 PM +00:00</CreatedAt>
    <ClosedAt>4/01/2019 3:41:21 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18198</IssueLabelID>
    <Title>Clean up threading tests to make them deterministic and not rely on timing</Title>
    <Description>
    </Description>
    <Title_Description>Clean up threading tests to make them deterministic and not rely on timing </Title_Description>
    <Label>area-System.Threading</Label>
    <Assignee>kouvel</Assignee>
    <CreatedAt>30/05/2018 4:34:43 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18196</IssueLabelID>
    <Title>JIT: Implement or eliminate GTF_REG_BIRTH</Title>
    <Description>This flag is no longer used after the removal of `LEGACY_BACKEND`. The comment above it says that "We should consider using it more generally for VAR_BIRTH instead of GTF_VAR_DEF &amp;&amp; !GTF_VAR_USEASG". This is currently used by `TreeLifeUpdater` (in `UpdateLifeVar()`) and is used in its negation in `fgValueNumberTree()`.
We should either:
- Implement `GTF_VAR_BIRTH` in RyuJIT ensuring that liveness sets it appropriately OR
- Eliminate it.

In either case it would be useful to have properties or methods on `GenTree` that abstract the usage of the liveness flags. This would also entail deciding/agreeing on the terminology - e.g. I would prefer to have `IsPureDef` `IsLastUse` `IsDef` and `IsUseDef` over using "birth" and "death" terminology.

category:design
theme:liveness
skill-level:expert
cost:medium</Description>
    <Title_Description>JIT: Implement or eliminate GTF_REG_BIRTH This flag is no longer used after the removal of `LEGACY_BACKEND`. The comment above it says that "We should consider using it more generally for VAR_BIRTH instead of GTF_VAR_DEF &amp;&amp; !GTF_VAR_USEASG". This is currently used by `TreeLifeUpdater` (in `UpdateLifeVar()`) and is used in its negation in `fgValueNumberTree()`.
We should either:
- Implement `GTF_VAR_BIRTH` in RyuJIT ensuring that liveness sets it appropriately OR
- Eliminate it.

In either case it would be useful to have properties or methods on `GenTree` that abstract the usage of the liveness flags. This would also entail deciding/agreeing on the terminology - e.g. I would prefer to have `IsPureDef` `IsLastUse` `IsDef` and `IsUseDef` over using "birth" and "death" terminology.

category:design
theme:liveness
skill-level:expert
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
    <CreatedAt>30/05/2018 4:12:18 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18192</IssueLabelID>
    <Title>Set GTF_RELOP_QMARK in gtNewQmarkNode</Title>
    <Description>Each caller of `gtNewQmarkNode()` sets `GTF_RELOP_QMARK` on the condition node.
It would be cleaner and more reliable to do that in `gtNewQmarkNode()` rather than at each call site.</Description>
    <Title_Description>Set GTF_RELOP_QMARK in gtNewQmarkNode Each caller of `gtNewQmarkNode()` sets `GTF_RELOP_QMARK` on the condition node.
It would be cleaner and more reliable to do that in `gtNewQmarkNode()` rather than at each call site.</Title_Description>
    <Label>Hackathon</Label>
    <Assignee>luqunl</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18190</IssueLabelID>
    <Title>[arm64] Implement compRsvdRegCheck</Title>
    <Description>`Compiler::compRsvdRegCheck` always returns `true` for arm64 with this code:
```
#if defined(_TARGET_ARM64_)

    // TODO-ARM64-CQ: update this!
    JITDUMP(" Returning true (ARM64)\n\n");
    return true; // just always assume we'll need it for now

#else  // _TARGET_ARM_
```

So the `REG_OPT_SRVD` register is always reserved.

Either implement this function and recover a register sometimes or choose not to and remove the `TODO-ARM64-CQ`.

category:design
theme:basic-cq
skill-level:intermediate
cost:small
</Description>
    <Title_Description>[arm64] Implement compRsvdRegCheck `Compiler::compRsvdRegCheck` always returns `true` for arm64 with this code:
```
#if defined(_TARGET_ARM64_)

    // TODO-ARM64-CQ: update this!
    JITDUMP(" Returning true (ARM64)\n\n");
    return true; // just always assume we'll need it for now

#else  // _TARGET_ARM_
```

So the `REG_OPT_SRVD` register is always reserved.

Either implement this function and recover a register sometimes or choose not to and remove the `TODO-ARM64-CQ`.

category:design
theme:basic-cq
skill-level:intermediate
cost:small
</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>30/05/2018 12:13:36 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18187</IssueLabelID>
    <Title>[arm32arm64] Stop setting EMIT_TRACK_STACK_DEPTH to 1</Title>
    <Description>In target.h:
```
#define EMIT_TRACK_STACK_DEPTH   1       // This is something of a workaround.  For both ARM and AMD64 the frame size is fixed so we don't really
                                           // need to track stack depth but this is currently necessary to get GC information reported at call sites.
```
Is this a "workaround" that can be fixed?

category:design
theme:gc-info
skill-level:expert
cost:small</Description>
    <Title_Description>[arm32,arm64] Stop setting EMIT_TRACK_STACK_DEPTH to 1 In target.h:
```
#define EMIT_TRACK_STACK_DEPTH   1       // This is something of a workaround.  For both ARM and AMD64 the frame size is fixed so we don't really
                                           // need to track stack depth but this is currently necessary to get GC information reported at call sites.
```
Is this a "workaround" that can be fixed?

category:design
theme:gc-info
skill-level:expert
cost:small</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>29/05/2018 11:53:17 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18186</IssueLabelID>
    <Title>[WIP]Add DllImport Charset UTF8</Title>
    <Description>The purpose is to enable Charset.UTF8 support for DllImport which will help customer to write cross-platform PInvoke.

Partial Fix https://github.com/dotnet/coreclr/issues/1012

Remaining problems:
1. UTF8 Array isn't support yet. 
2. Update roslyn to support Charset UTF8
3. There are couple shift/reduce reduce/reduce conflict for ilasm yy file
4. More testing

Open problems:
1. What's the native type for default char marshalling with [DllImport(CharSet = CharSet.UTF8)]
Currently use U2 instead.
2. Whether UnmanagedType.LPTSTR should support UTF8? 
Currently LPTSTR only supports ANSI/Unicode
3. Whether UnmanagedType.AsAny should support UTF8?  
Currently AsAny doesn't support UTF8.
4. Ongoing support for UTF16(LE/BE) UTF32?


</Description>
    <Title_Description>[WIP]Add DllImport Charset UTF8 The purpose is to enable Charset.UTF8 support for DllImport which will help customer to write cross-platform PInvoke.

Partial Fix https://github.com/dotnet/coreclr/issues/1012

Remaining problems:
1. UTF8 Array isn't support yet. 
2. Update roslyn to support Charset UTF8
3. There are couple shift/reduce reduce/reduce conflict for ilasm yy file
4. More testing

Open problems:
1. What's the native type for default char marshalling with [DllImport(CharSet = CharSet.UTF8)]
Currently use U2 instead.
2. Whether UnmanagedType.LPTSTR should support UTF8? 
Currently LPTSTR only supports ANSI/Unicode
3. Whether UnmanagedType.AsAny should support UTF8?  
Currently AsAny doesn't support UTF8.
4. Ongoing support for UTF16(LE/BE) UTF32?


</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>luqunl</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18185</IssueLabelID>
    <Title>JIT: Eliminate RegTracker</Title>
    <Description>Now that `LEGACY_BACKEND` has been eliminated the `RegTracker` is not longer useful. It was used by the legacy backend to avoid reloading local variables or setting a register to a constant if it was already available in a register. Some constant reuse has been implemented in the register allocator and future work to support reuse of (memory-based) locals or constants would be done elsewhere (e.g. see issue #6131).

Currently the `RegTracker` methods only call `regSet-&gt;rsSetRegsModified()` however the register allocator should already be doing this for any registers it allocates as well as any registers killed by an instruction. Furthermore the code generator should already be doing this for any additional registers used for example in prolog or epilog code.

Calls to these methods should be replaced with methods on `RegSet` that simply verify that the register is in the modified set and assert otherwise (and would be a no-op in retail builds) e.g.:

- `RegSet::verifyRegUsed(regNumber reg)`
  - this would replace calls to `RegTracker::rsTrackRegTrash()` `RegTracker::rsTrackRegIntCns()` `RegTracker::rsTrackRegLclVar()` and `RegTracker::rsTrackRegCopy()`.

- `RegSet::verifyRegistersUsed(regMaskTP regMask)`
  - this would replace calls to `RegTracker::rsTrashRegSet()`</Description>
    <Title_Description>JIT: Eliminate RegTracker Now that `LEGACY_BACKEND` has been eliminated the `RegTracker` is not longer useful. It was used by the legacy backend to avoid reloading local variables or setting a register to a constant if it was already available in a register. Some constant reuse has been implemented in the register allocator and future work to support reuse of (memory-based) locals or constants would be done elsewhere (e.g. see issue #6131).

Currently the `RegTracker` methods only call `regSet-&gt;rsSetRegsModified()` however the register allocator should already be doing this for any registers it allocates as well as any registers killed by an instruction. Furthermore the code generator should already be doing this for any additional registers used for example in prolog or epilog code.

Calls to these methods should be replaced with methods on `RegSet` that simply verify that the register is in the modified set and assert otherwise (and would be a no-op in retail builds) e.g.:

- `RegSet::verifyRegUsed(regNumber reg)`
  - this would replace calls to `RegTracker::rsTrackRegTrash()` `RegTracker::rsTrackRegIntCns()` `RegTracker::rsTrackRegLclVar()` and `RegTracker::rsTrackRegCopy()`.

- `RegSet::verifyRegistersUsed(regMaskTP regMask)`
  - this would replace calls to `RegTracker::rsTrashRegSet()`</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
    <CreatedAt>29/05/2018 11:22:44 PM +00:00</CreatedAt>
    <ClosedAt>29/05/2018 11:36:28 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18182</IssueLabelID>
    <Title>[arm32 arm64] Build framework with IBC data and hot/cold splitting</Title>
    <Description>Apparently the official builds for arm32 and arm64 do not implement IBC data optimization. We should implement this to gain those benefits.

This issue should probably be in some other repo but putting it here for tracking for now.

Related: https://github.com/dotnet/coreclr/issues/18181
</Description>
    <Title_Description>[arm32, arm64] Build framework with IBC data and hot/cold splitting Apparently the official builds for arm32 and arm64 do not implement IBC data optimization. We should implement this to gain those benefits.

This issue should probably be in some other repo but putting it here for tracking for now.

Related: https://github.com/dotnet/coreclr/issues/18181
</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>29/05/2018 9:53:00 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18181</IssueLabelID>
    <Title>[arm64] Implement hot/cold splitting</Title>
    <Description>From `compInitOptions`:

```
#ifdef _TARGET_ARM64_
    // TODO-ARM64-NYI: enable hot/cold splitting
    opts.compProcedureSplitting = false;
#endif // _TARGET_ARM64_
```


category:cq
theme:optimization
skill-level:expert
cost:large</Description>
    <Title_Description>[arm64] Implement hot/cold splitting From `compInitOptions`:

```
#ifdef _TARGET_ARM64_
    // TODO-ARM64-NYI: enable hot/cold splitting
    opts.compProcedureSplitting = false;
#endif // _TARGET_ARM64_
```


category:cq
theme:optimization
skill-level:expert
cost:large</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>29/05/2018 9:40:05 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18179</IssueLabelID>
    <Title>JIT: Eliminate RegTracker</Title>
    <Description>Now that `LEGACY_BACKEND` is gone do we still need RegTracker?
</Description>
    <Title_Description>JIT: Eliminate RegTracker Now that `LEGACY_BACKEND` is gone do we still need RegTracker?
</Title_Description>
    <Label>Hackathon</Label>
    <Assignee>cshung</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18178</IssueLabelID>
    <Title>[arm64] Implement/remove NYI_ARM64</Title>
    <Description>The following are the remaining `NYI_ARM64`. They should either be removed if not needed or implemented or split into a separate issue for each related unimplemented feature.

| File | NYI |
| --- | --- |
| codegenarmarch.cpp | NYI_ARM64("CodeGen::genJmpMethod with multireg HFA arg") |
| ~~codegencommon.cpp~~ | ~~NYI_ARM64("Unsupported JMP indirection")~~ |
| ~~emit.cpp~~ | ~~NYI_ARM64("Need to handle fix-up to data from cold code.")~~ |
| ~~emitarm64.cpp~~ | ~~NYI_ARM64("Relocation Support for long address")~~ |
| ~~morph.cpp~~ | ~~NYI_ARM64("Tail calls via stub are unsupported on this platform.")~~ |
| ~~register_arg_convention.cpp~~ | ~~NYI_ARM64("alignReg")~~ |

category:correctness
theme:testing
skill-level:expert
cost:small</Description>
    <Title_Description>[arm64] Implement/remove NYI_ARM64 The following are the remaining `NYI_ARM64`. They should either be removed if not needed or implemented or split into a separate issue for each related unimplemented feature.

| File | NYI |
| --- | --- |
| codegenarmarch.cpp | NYI_ARM64("CodeGen::genJmpMethod with multireg HFA arg") |
| ~~codegencommon.cpp~~ | ~~NYI_ARM64("Unsupported JMP indirection")~~ |
| ~~emit.cpp~~ | ~~NYI_ARM64("Need to handle fix-up to data from cold code.")~~ |
| ~~emitarm64.cpp~~ | ~~NYI_ARM64("Relocation Support for long address")~~ |
| ~~morph.cpp~~ | ~~NYI_ARM64("Tail calls via stub are unsupported on this platform.")~~ |
| ~~register_arg_convention.cpp~~ | ~~NYI_ARM64("alignReg")~~ |

category:correctness
theme:testing
skill-level:expert
cost:small</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>BruceForstall</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18177</IssueLabelID>
    <Title>JIT: Remove unused parameters from genCreateAddrMode</Title>
    <Description>Now that the `LEGACY_BACKEND` has been disabled this method is always called with:
- `regMask == RBM_NONE`
- `nogen == true`

These parameters should be removed.

In addition the `scale` parameter is only defined under `SCALED_ADDR_MODES` however `Lowering` calls it with that parameter unconditionally. Currently all targets define that to be true but for now it's probably best to at least modify the call in lower.cpp to be consistent.

Finally the header comment talks about `LEA_AVAILABLE` when it should be `SCALED_ADDR_MODES` and it would be good to clean up this header to follow the format here: https://github.com/dotnet/coreclr/blob/master/Documentation/coding-guidelines/clr-jit-coding-conventions.md#94-function-header-comment</Description>
    <Title_Description>JIT: Remove unused parameters from genCreateAddrMode Now that the `LEGACY_BACKEND` has been disabled this method is always called with:
- `regMask == RBM_NONE`
- `nogen == true`

These parameters should be removed.

In addition the `scale` parameter is only defined under `SCALED_ADDR_MODES` however `Lowering` calls it with that parameter unconditionally. Currently all targets define that to be true but for now it's probably best to at least modify the call in lower.cpp to be consistent.

Finally the header comment talks about `LEA_AVAILABLE` when it should be `SCALED_ADDR_MODES` and it would be good to clean up this header to follow the format here: https://github.com/dotnet/coreclr/blob/master/Documentation/coding-guidelines/clr-jit-coding-conventions.md#94-function-header-comment</Title_Description>
    <Label>Hackathon</Label>
    <Assignee>Suchiman</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18176</IssueLabelID>
    <Title>JIT: x86 assertion failed 'header-&gt;gsCookieOffset != INVALID_GS_COOKIE_OFFSET'</Title>
    <Description>Regression caused by #17996.

If the jit sees a zero-sized stackalloc it will push a null unmanaged pointer. Unfortunately the jit may have already decided it needs a GS cookie and without a proper stackalloc it never sets a slot for the GS cookie hence the assert.

Recent CSCs fold away computations leading to zero-sized stackallocs and do this optimization directly in IL. But older CSCs will leave the computations around:

```
    ldc.i4.0
    conv.u
    ldc.i4.4
    mul.ovf.un
    localloc
```

#17996 effectively removed the `conv.u` and so the jit now folds the size computation to zero.</Description>
    <Title_Description>JIT: x86 assertion failed 'header-&gt;gsCookieOffset != INVALID_GS_COOKIE_OFFSET' Regression caused by #17996.

If the jit sees a zero-sized stackalloc it will push a null unmanaged pointer. Unfortunately the jit may have already decided it needs a GS cookie and without a proper stackalloc it never sets a slot for the GS cookie hence the assert.

Recent CSCs fold away computations leading to zero-sized stackallocs and do this optimization directly in IL. But older CSCs will leave the computations around:

```
    ldc.i4.0
    conv.u
    ldc.i4.4
    mul.ovf.un
    localloc
```

#17996 effectively removed the `conv.u` and so the jit now folds the size computation to zero.</Title_Description>
    <Label>arch-x86</Label>
    <Assignee>AndyAyersMS</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18175</IssueLabelID>
    <Title>[Arm64] Enable HW intrinsics for Windows</Title>
    <Description>It appears arm64 HW intrinsics capabilities are enabled for Linux via `PAL_GetJitCpuCapabilityFlags` and not via a cross-platform mechanism used by Windows.

Enable Windows/Linux parity by enabling (and testing) the HW intrinsics for Windows as well.
</Description>
    <Title_Description>[Arm64] Enable HW intrinsics for Windows It appears arm64 HW intrinsics capabilities are enabled for Linux via `PAL_GetJitCpuCapabilityFlags` and not via a cross-platform mechanism used by Windows.

Enable Windows/Linux parity by enabling (and testing) the HW intrinsics for Windows as well.
</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18174</IssueLabelID>
    <Title>[arm64/Linux] Enable 'jitnosimd' testing?</Title>
    <Description>Arm64/Linux is missing the netci.groovy 'jitnosimd' testing job (`COMPlus_FeatureSIMD=0`).

It doesn't make sense (or is duplicative) for arm32. But arm64 does support SIMD so should support this mode.
</Description>
    <Title_Description>[arm64/Linux] Enable 'jitnosimd' testing? Arm64/Linux is missing the netci.groovy 'jitnosimd' testing job (`COMPlus_FeatureSIMD=0`).

It doesn't make sense (or is duplicative) for arm32. But arm64 does support SIMD so should support this mode.
</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>BruceForstall</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18172</IssueLabelID>
    <Title>Fix CI views to only include top-level flow jobs</Title>
    <Description>Jobs that are only executed as part of flow jobs should not be included in the per-architecture Jenkins views.

E.g. https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm64/ should not include "_tst" jobs.
</Description>
    <Title_Description>Fix CI views to only include top-level flow jobs Jobs that are only executed as part of flow jobs should not be included in the per-architecture Jenkins views.

E.g. https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm64/ should not include "_tst" jobs.
</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>BruceForstall</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18170</IssueLabelID>
    <Title>[arm64/Windows] Add corefx testing to CI</Title>
    <Description>We have arm32 Windows and Ubuntu arm64 altjit and arm64 Ubuntu corefx testing in CI. Add arm64 Windows (hardware) corefx testing.
</Description>
    <Title_Description>[arm64/Windows] Add corefx testing to CI We have arm32 Windows and Ubuntu arm64 altjit and arm64 Ubuntu corefx testing in CI. Add arm64 Windows (hardware) corefx testing.
</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>BruceForstall</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18162</IssueLabelID>
    <Title>Remove unsafe code from number parsing</Title>
    <Description>There is heavy use of unsafe code in number.parsing.cs and calling code (eg at https://github.com/dotnet/corefx/blob/master/src/Common/src/CoreLib/System/Number.Parsing.cs#L399). This could be rewritten with `ReadOnlySpan&lt;char&gt;` to eliminate the `char *` resulting in safer code that is also easier to read.

Relates to https://github.com/dotnet/coreclr/pull/17808</Description>
    <Title_Description>Remove unsafe code from number parsing There is heavy use of unsafe code in number.parsing.cs and calling code (eg at https://github.com/dotnet/corefx/blob/master/src/Common/src/CoreLib/System/Number.Parsing.cs#L399). This could be rewritten with `ReadOnlySpan&lt;char&gt;` to eliminate the `char *` resulting in safer code that is also easier to read.

Relates to https://github.com/dotnet/coreclr/pull/17808</Title_Description>
    <Label>area-System.Runtime</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>29/05/2018 5:32:14 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18157</IssueLabelID>
    <Title> An assembly specified in the application dependencies manifest was not found</Title>
    <Description>I got the following error when I am trying to start asp.net core server not on my dev system:

	  An assembly specified in the application dependencies manifest (PublishError.deps.json) was not found:
		package: 'HtmlAgilityPack' version: '1.8.4'
		path: 'lib/netstandard2.0/HtmlAgilityPack.dll'

Now server is Win 10  but I got this error both on Windows and Linux. On Windows I got not only runtime but also an sdk - doesnt help .

Sample project can be [found here](https://drive.google.com/open?id=1H0ecF5kqkbSCkPM6_Bi9CGX6DlBf9ApS
).</Description>
    <Title_Description> An assembly specified in the application dependencies manifest was not found I got the following error when I am trying to start asp.net core server not on my dev system:

	  An assembly specified in the application dependencies manifest (PublishError.deps.json) was not found:
		package: 'HtmlAgilityPack' version: '1.8.4'
		path: 'lib/netstandard2.0/HtmlAgilityPack.dll'

Now server is Win 10  but I got this error both on Windows and Linux. On Windows I got not only runtime but also an sdk - doesnt help .

Sample project can be [found here](https://drive.google.com/open?id=1H0ecF5kqkbSCkPM6_Bi9CGX6DlBf9ApS
).</Title_Description>
    <Label>area-AssemblyLoader</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>29/05/2018 12:11:30 PM +00:00</CreatedAt>
    <ClosedAt>30/04/2019 7:59:38 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18156</IssueLabelID>
    <Title>Run CoreFX tests as default PR-triggered CI jobs </Title>
    <Description># CoreFX CI Testing Scenario for CoreCLR #

## Current State of CoreFX testing in CoreCLR
Currently the CoreCLR repos runs CoreFX tests by checking out the CoreFX repository at a specified commit (or HEAD by default) building the repo on top of the runtime to test building all tests and subsequently running them.  These jobs run post-check-in in multiple different stress configurations.
While this approach is flexible a few details make it less suited to be used in CI. Firstly breaking changes can creep in due to CoreFX version mismatches. Secondly this process is time-consuming and storage-heavy which is not ideal for quick PR runs. Thirdly in the current state the way to skip running tests is by annotating the test code itself with XUnit annotations requiring changes to be made in both repos and slowing down development 

## Current State of CoreFX testing in CoreRT (Proof of Concept)
When Helix runs CoreFX tests the produced project and test binaries are saved and kept for a limited time. A Test List is produced on every build with the URLs of the binaries. These built test assemblies can be reused for CI jobs allowing a quicker and less resource-intensive way to test changes made to the runtime.
In CoreRT a small subset of framework tests run for every PR. These tests are not built locally but instead an already built set of tests is saved in blob storage and downloaded on request. Each test project includes a XUnit test runner eliminating the need to build it independently.
A minimal test “harness” (in the form of a dummy `.csproj` file) is used to allow NuGet package dependencies to be resolved for the project. 
Our XUnit console wrapper produced and published from the build tools repo allows unstable and failing tests to be disabled via command line switches and/or `.rsp` files. Test runs are defined via JSON files in the repository which define both which tests to run (e.g. `System.Collections.Tests.dll`) as well as which tests should be excluded – defined either by fully-qualified name their class or namespace with a required reason for exclusion (validated on every test run). The feature will allow CI checks to pass even if a breaking change is propagating - the failing test(s) can be added to the exclusion list with a link to the associated issue or other reason for skipping during test runs avoiding the need to make any modifications to CoreFX-side test code. 

This gives a large degree of flexibility in defining test runs – each definition can be created as an easily extensible JSON file. Utilizing the enforced JSON schema additional tooling can be built around the framework – for example validity of exclusions can be tracked by an associated link to a GitHub issue. The validity of issues can be checked on each test run – using a library/tool similar to [Octokit.NET]( https://github.com/octokit/octokit.net ) .

## Proposal
The approach taken in CoreRT will be extended to cover CoreCLR. The CoreCLR components to be tested will be laid out such that they can be run with the dotnet cli mirroring the [binplacing approach](https://github.com/dotnet/corefx/blob/master/dir.props) in the CoreFX repo 

The established infrastructure pattern will be modified for better integration with the existing codebase – the test harness defining dependencies will be removed and instead the repo's XUnit version will be reused. The Core_Root folder built for current testing scenarios contains most components necessary to run tests and will therefore be reused. 

A test list will sit in the root of the blob storage instance with URL values of each test for supported configurations (e.g. Windows_NT x64). Once tests are run with a specified configuration the test list will be read and the test suites at the relevant URLs downloaded.

Each test flight’s included test assemblies and method/class/namespace exclusions will be defined via a JSON file. The test assemblies can be automatically updated and replaced in blob storage by running a full CoreFX build for each respective configuration. For the current work built CoreFX test assemblies will be copied into separate blob storage to be used by the CI setup. 

Outside of the scope of this proposal binary management can be automated by adding features to dotnet-maestro-bot updating the test assemblies on every update to the current CoreFX version.

</Description>
    <Title_Description>Run CoreFX tests as default PR-triggered CI jobs  # CoreFX CI Testing Scenario for CoreCLR #

## Current State of CoreFX testing in CoreCLR
Currently the CoreCLR repos runs CoreFX tests by checking out the CoreFX repository at a specified commit (or HEAD by default) building the repo on top of the runtime to test building all tests and subsequently running them.  These jobs run post-check-in in multiple different stress configurations.
While this approach is flexible a few details make it less suited to be used in CI. Firstly breaking changes can creep in due to CoreFX version mismatches. Secondly this process is time-consuming and storage-heavy which is not ideal for quick PR runs. Thirdly in the current state the way to skip running tests is by annotating the test code itself with XUnit annotations requiring changes to be made in both repos and slowing down development 

## Current State of CoreFX testing in CoreRT (Proof of Concept)
When Helix runs CoreFX tests the produced project and test binaries are saved and kept for a limited time. A Test List is produced on every build with the URLs of the binaries. These built test assemblies can be reused for CI jobs allowing a quicker and less resource-intensive way to test changes made to the runtime.
In CoreRT a small subset of framework tests run for every PR. These tests are not built locally but instead an already built set of tests is saved in blob storage and downloaded on request. Each test project includes a XUnit test runner eliminating the need to build it independently.
A minimal test “harness” (in the form of a dummy `.csproj` file) is used to allow NuGet package dependencies to be resolved for the project. 
Our XUnit console wrapper produced and published from the build tools repo allows unstable and failing tests to be disabled via command line switches and/or `.rsp` files. Test runs are defined via JSON files in the repository which define both which tests to run (e.g. `System.Collections.Tests.dll`) as well as which tests should be excluded – defined either by fully-qualified name their class or namespace with a required reason for exclusion (validated on every test run). The feature will allow CI checks to pass even if a breaking change is propagating - the failing test(s) can be added to the exclusion list with a link to the associated issue or other reason for skipping during test runs avoiding the need to make any modifications to CoreFX-side test code. 

This gives a large degree of flexibility in defining test runs – each definition can be created as an easily extensible JSON file. Utilizing the enforced JSON schema additional tooling can be built around the framework – for example validity of exclusions can be tracked by an associated link to a GitHub issue. The validity of issues can be checked on each test run – using a library/tool similar to [Octokit.NET]( https://github.com/octokit/octokit.net ) .

## Proposal
The approach taken in CoreRT will be extended to cover CoreCLR. The CoreCLR components to be tested will be laid out such that they can be run with the dotnet cli mirroring the [binplacing approach](https://github.com/dotnet/corefx/blob/master/dir.props) in the CoreFX repo 

The established infrastructure pattern will be modified for better integration with the existing codebase – the test harness defining dependencies will be removed and instead the repo's XUnit version will be reused. The Core_Root folder built for current testing scenarios contains most components necessary to run tests and will therefore be reused. 

A test list will sit in the root of the blob storage instance with URL values of each test for supported configurations (e.g. Windows_NT x64). Once tests are run with a specified configuration the test list will be read and the test suites at the relevant URLs downloaded.

Each test flight’s included test assemblies and method/class/namespace exclusions will be defined via a JSON file. The test assemblies can be automatically updated and replaced in blob storage by running a full CoreFX build for each respective configuration. For the current work built CoreFX test assemblies will be copied into separate blob storage to be used by the CI setup. 

Outside of the scope of this proposal binary management can be automated by adding features to dotnet-maestro-bot updating the test assemblies on every update to the current CoreFX version.

</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>A-And</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18155</IssueLabelID>
    <Title>Generate native image from IL the same way as produced by JIT</Title>
    <Description>Question:
Is there any way I could get a dump of native executable code that .NET Core JIT creates with some additional custom markup? It is not required to be runnable when transferred to different PC.

I'd like to try to run the tool called "Intel Architecture Code Analyzer" (https://software.intel.com/en-us/articles/intel-architecture-code-analyzer) to analyze the performance of my tool which is currently under development in context of different CPUs - this is what the IACA tool does but it normally accepts compiled native binary file with "magic" byte sequences inserted telling the region of code which is subject for the analysis.
Thanks.
category:design
theme:ngen
skill-level:expert
cost:large</Description>
    <Title_Description>Generate native image from IL the same way as produced by JIT Question:
Is there any way I could get a dump of native executable code that .NET Core JIT creates with some additional custom markup? It is not required to be runnable when transferred to different PC.

I'd like to try to run the tool called "Intel Architecture Code Analyzer" (https://software.intel.com/en-us/articles/intel-architecture-code-analyzer) to analyze the performance of my tool which is currently under development in context of different CPUs - this is what the IACA tool does but it normally accepts compiled native binary file with "magic" byte sequences inserted telling the region of code which is subject for the analysis.
Thanks.
category:design
theme:ngen
skill-level:expert
cost:large</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>28/05/2018 5:46:07 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18154</IssueLabelID>
    <Title>[WIP] Upload perf artifacts to Azure Blob Storage using AzCopy</Title>
    <Description>
    </Description>
    <Title_Description>[WIP] Upload perf artifacts to Azure Blob Storage using AzCopy </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>dotnet-bot</Assignee>
    <CreatedAt>28/05/2018 12:54:12 PM +00:00</CreatedAt>
    <ClosedAt>8/10/2018 3:43:11 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18153</IssueLabelID>
    <Title>Assertion failed 'farthestRefPhysRegRecord != nullptr' /dotnet/coreclr/src/jit/lsra.cpp:3637 </Title>
    <Description>I'm using the x86 version of the CoreCLR to run CoreRT and compile tests for ARM.

After the commit:
&gt; b39a5b2cfad4620ae23cda84186a36ffb463cd5a 

compilation fails (for all tests) with message

&gt; cd /overlay.arm.Debug &amp;&amp; ./corerun ilc.dll --codegenopt "AltJitNgen=*" @/overlay.arm.Debug/pow3/base.ilc.rsp
/dotnet/coreclr/src/jit/lsra.cpp:3637
Assertion failed 'farthestRefPhysRegRecord != nullptr' in 'Sys:DoubleToString(doubleintintint):int' (IL size 14)

The folder /overlay.arm.Debug/ contains necessary parts from CoreRT CoreCLR and CoreFX to 
cross-compile IL binary to native ARM code.  I've followed the following guide: [https://github.com/dotnet/corert/blob/master/Documentation/cross-building.md](url)
The `@/overlay.arm.Debug/pow3/base.ilc.rsp` is dependency file generated by the `msbuild`. 
The pow3 test is one of the CoreCRL's tests for CoreRT. The tests are downloaded by `/dotnet/corert/tests/runtest.sh`  script and could be run by the following command `./tests/runtest.sh -coreclr all`

I've checked with the following versions of the CoreCRL CoreRT and CoreFX:

CoreCLR: 6bf04a47badd74646e21e70f4e9267c71b7bfd08
CoreFX: ccdb5a48a49d3e932aa00d02749777464f4c8d5b
CoreRT: a028615abe80057e413d632a7c9257208b7c6865


</Description>
    <Title_Description>Assertion failed 'farthestRefPhysRegRecord != nullptr' /dotnet/coreclr/src/jit/lsra.cpp:3637  I'm using the x86 version of the CoreCLR to run CoreRT and compile tests for ARM.

After the commit:
&gt; b39a5b2cfad4620ae23cda84186a36ffb463cd5a 

compilation fails (for all tests) with message

&gt; cd /overlay.arm.Debug &amp;&amp; ./corerun ilc.dll --codegenopt "AltJitNgen=*" @/overlay.arm.Debug/pow3/base.ilc.rsp
/dotnet/coreclr/src/jit/lsra.cpp:3637
Assertion failed 'farthestRefPhysRegRecord != nullptr' in 'Sys:DoubleToString(doubleintintint):int' (IL size 14)

The folder /overlay.arm.Debug/ contains necessary parts from CoreRT CoreCLR and CoreFX to 
cross-compile IL binary to native ARM code.  I've followed the following guide: [https://github.com/dotnet/corert/blob/master/Documentation/cross-building.md](url)
The `@/overlay.arm.Debug/pow3/base.ilc.rsp` is dependency file generated by the `msbuild`. 
The pow3 test is one of the CoreCRL's tests for CoreRT. The tests are downloaded by `/dotnet/corert/tests/runtest.sh`  script and could be run by the following command `./tests/runtest.sh -coreclr all`

I've checked with the following versions of the CoreCRL CoreRT and CoreFX:

CoreCLR: 6bf04a47badd74646e21e70f4e9267c71b7bfd08
CoreFX: ccdb5a48a49d3e932aa00d02749777464f4c8d5b
CoreRT: a028615abe80057e413d632a7c9257208b7c6865


</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18151</IssueLabelID>
    <Title>Test failure: GC_Coverage._delete_next_card_table_delete_next_card_table_/_delete_next_card_table_delete_next_card_table_cmd</Title>
    <Description>Opened on behalf of @Sunny-pu

The test `GC_Coverage._delete_next_card_table_delete_next_card_table_/_delete_next_card_table_delete_next_card_table_cmd` has failed.

Test Infrastructure Failure: Could not load file or assembly 'System.Memory Version=4.1.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. The system cannot find the file specified.
    
    Expected: True
    Actual:   False

        Stack Trace:

        
Build : Master - 20180528.01 (Ready-To-Run Tests)
Failing configurations:
- ubuntu.1604.amd64
  - x64

Details: https://mc.dot.net/#/product/netcore/master/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fr2r~2Fcli~2F/build/20180528.01/workItem/GC.Coverage.XUnitWrapper/analysis/xunit/GC_Coverage._delete_next_card_table_delete_next_card_table_~2F_delete_next_card_table_delete_next_card_table_cmd</Description>
    <Title_Description>Test failure: GC_Coverage._delete_next_card_table_delete_next_card_table_/_delete_next_card_table_delete_next_card_table_cmd Opened on behalf of @Sunny-pu

The test `GC_Coverage._delete_next_card_table_delete_next_card_table_/_delete_next_card_table_delete_next_card_table_cmd` has failed.

Test Infrastructure Failure: Could not load file or assembly 'System.Memory Version=4.1.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. The system cannot find the file specified.
    
    Expected: True
    Actual:   False

        Stack Trace:

        
Build : Master - 20180528.01 (Ready-To-Run Tests)
Failing configurations:
- ubuntu.1604.amd64
  - x64

Details: https://mc.dot.net/#/product/netcore/master/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fr2r~2Fcli~2F/build/20180528.01/workItem/GC.Coverage.XUnitWrapper/analysis/xunit/GC_Coverage._delete_next_card_table_delete_next_card_table_~2F_delete_next_card_table_delete_next_card_table_cmd</Title_Description>
    <Label>test-run-uwp-coreclr</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>28/05/2018 7:27:44 AM +00:00</CreatedAt>
    <ClosedAt>30/05/2018 6:19:27 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18149</IssueLabelID>
    <Title>Multiple restart of runtime host within the same process</Title>
    <Description>We have requirement to restart the runtime host within the same process. We are using following sequence of calls with ICLRRuntimeHost4 interface as listed in https://docs.microsoft.com/en-us/dotnet/core/tutorials/netcore-hosting

1. Load coreclr library and get m_runtimehost (of type ICLRRuntimeHost4) by calling GetCLRRuntimeHost
2. m_runtimehost-&gt;Start()
3. m_runtimehost-&gt;CreateAppDomainwithManager() =&gt; using SINGLE_APP_DOMAIN
4. m_runtimehost-&gt;CreateDelegate()
5. Call delegates
6. m_runtimehost-&gt;UnloadAppDomain2()
7. m_runtimehost-&gt;Stop()
8. Unload the coreclr library

When we try to repeat the above sequence without restart of the process we get access violation exception at step 2 above with following call stack

        coreclr.dll!SystemDomain::LoadBaseSystemClasses() Line 2715	C++
 	coreclr.dll!SystemDomain::Init() Line 2460	C++
 	coreclr.dll!EEStartupHelper(tagCOINITEE) Line 1058	C++
 	coreclr.dll!EEStartup(tagCOINITEE) Line 1237	C++
 	coreclr.dll!EnsureEEStarted(tagCOINITEE) Line 375	C++
 	coreclr.dll!CorHost2::Start() Line 189	C++

1. Is this known issue? Is there any workaround to restart the runtime host multiple times without restarting the process? We see similar issue with Linux hosts throwing exception in coreclr_initialize method.
2. We are also seeing managed assemblies not being unloaded with UnloadAppDomain2 call mentioned in the step 6 above. Also we expect memory to be released when we call m_runtimehost-&gt;Stop() mentioned in the step 7 above.
</Description>
    <Title_Description>Multiple restart of runtime host within the same process We have requirement to restart the runtime host within the same process. We are using following sequence of calls with ICLRRuntimeHost4 interface as listed in https://docs.microsoft.com/en-us/dotnet/core/tutorials/netcore-hosting

1. Load coreclr library and get m_runtimehost (of type ICLRRuntimeHost4) by calling GetCLRRuntimeHost
2. m_runtimehost-&gt;Start()
3. m_runtimehost-&gt;CreateAppDomainwithManager() =&gt; using SINGLE_APP_DOMAIN
4. m_runtimehost-&gt;CreateDelegate()
5. Call delegates
6. m_runtimehost-&gt;UnloadAppDomain2()
7. m_runtimehost-&gt;Stop()
8. Unload the coreclr library

When we try to repeat the above sequence without restart of the process we get access violation exception at step 2 above with following call stack

        coreclr.dll!SystemDomain::LoadBaseSystemClasses() Line 2715	C++
 	coreclr.dll!SystemDomain::Init() Line 2460	C++
 	coreclr.dll!EEStartupHelper(tagCOINITEE) Line 1058	C++
 	coreclr.dll!EEStartup(tagCOINITEE) Line 1237	C++
 	coreclr.dll!EnsureEEStarted(tagCOINITEE) Line 375	C++
 	coreclr.dll!CorHost2::Start() Line 189	C++

1. Is this known issue? Is there any workaround to restart the runtime host multiple times without restarting the process? We see similar issue with Linux hosts throwing exception in coreclr_initialize method.
2. We are also seeing managed assemblies not being unloaded with UnloadAppDomain2 call mentioned in the step 6 above. Also we expect memory to be released when we call m_runtimehost-&gt;Stop() mentioned in the step 7 above.
</Title_Description>
    <Label>question</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>28/05/2018 4:00:28 AM +00:00</CreatedAt>
    <ClosedAt>31/05/2018 2:13:45 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18148</IssueLabelID>
    <Title>Question: How do I diagnose an IPE?</Title>
    <Description>I am running code on .NET Core that is ported over from mono. The same compiler was used in both instances. Mono runs the IL fine but .NET Core is complaining about invalid IL in a particular method. Is there a debug flag that will make .NET Core spit out the exact instruction that it finds invalid? As the author of said compiler I could fix the bug pointed out by the CLR if I had the instruction pointed out.</Description>
    <Title_Description>Question: How do I diagnose an IPE? I am running code on .NET Core that is ported over from mono. The same compiler was used in both instances. Mono runs the IL fine but .NET Core is complaining about invalid IL in a particular method. Is there a debug flag that will make .NET Core spit out the exact instruction that it finds invalid? As the author of said compiler I could fix the bug pointed out by the CLR if I had the instruction pointed out.</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>27/05/2018 8:05:16 PM +00:00</CreatedAt>
    <ClosedAt>22/02/2019 10:51:57 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18147</IssueLabelID>
    <Title>Report a better error message when assembly version conflict is encountered</Title>
    <Description>The simplest possible .NET Core 1.0 console application throws a `FileLoadException` with very little detail when I try to load the netstandard1.0 build of System.Collections.Immutable.dll:

&gt; Could not load file or assembly 'System.Collections.Immutable Version=1.2.2.0 Culture=neutral PublicKeyToken=b03f5f7f11d50a3a'

If I update to .NET Core 2.0 it works but it loads the assembly from a different path than the one I give it. And besides in the original project updating to .NET Core 2.0 creates other assembly load problems so I'd prefer to learn why this doesn't work on .NET Core 1.0 and fix that issue.

Simplest repro project is linked below but the C# code is simply this:

```csharp
AssemblyLoadContext.Default.LoadFromAssemblyPath(@"C:\Users\andarno\.nuget\packages\system.collections.immutable\1.4.0\lib\netstandard1.0\System.Collections.Immutable.dll");
```

[ConsoleApp20.zip](https://github.com/dotnet/coreclr/files/2042920/ConsoleApp20.zip)
</Description>
    <Title_Description>Report a better error message when assembly version conflict is encountered The simplest possible .NET Core 1.0 console application throws a `FileLoadException` with very little detail when I try to load the netstandard1.0 build of System.Collections.Immutable.dll:

&gt; Could not load file or assembly 'System.Collections.Immutable Version=1.2.2.0 Culture=neutral PublicKeyToken=b03f5f7f11d50a3a'

If I update to .NET Core 2.0 it works but it loads the assembly from a different path than the one I give it. And besides in the original project updating to .NET Core 2.0 creates other assembly load problems so I'd prefer to learn why this doesn't work on .NET Core 1.0 and fix that issue.

Simplest repro project is linked below but the C# code is simply this:

```csharp
AssemblyLoadContext.Default.LoadFromAssemblyPath(@"C:\Users\andarno\.nuget\packages\system.collections.immutable\1.4.0\lib\netstandard1.0\System.Collections.Immutable.dll");
```

[ConsoleApp20.zip](https://github.com/dotnet/coreclr/files/2042920/ConsoleApp20.zip)
</Title_Description>
    <Label>area-AssemblyLoader</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>27/05/2018 6:59:24 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18145</IssueLabelID>
    <Title>Some integer scalar and vectored methods/overloads are not exposed in HW intrinsics API</Title>
    <Description>1. Currently the intrinsics are exposed for signed int -&gt; signed int and for unsigned int -&gt; signed int upconversion when both src and dest are 128-bit vector. But no such API method is directly exposed for **unsigned int -&gt; unsigned int** so one has to either use `UnpackLow()` (which is different operation) or wrap existing signed upconversion with `StaticCast&lt;signed unsigned&gt;()` which may provide overhead (see #18069) .
The suggestion is to add following convenience methods:
- Sse41.ConvertToVector128UInt16(Vector128(byte)) for `[V]PMOVZXBW xmm xmm` (same insn as for existing ConvertToVector128Int16())
- Sse41.ConvertToVector128UInt32(Vector128(byte/ushort)) for `[V]PMOVZXBD/WD xmm xmm` (same insn as for existing ConvertToVector128Int32())
- Sse41.ConvertToVector128UInt64(Vector128(byte/ushort/uint)) for `[V]PMOVZXBQ/WQ/DQ xmm xmm` (same insn as for existing ConvertToVector128Int64())
----------------------------------------
2. Similarly no direct means are exposed in API for **unsigned int -&gt; signed int** upconversion when src is in 128-bit vector and the dest is in 256-bit vector.
The methods being suggested are:
- Avx2.ConvertToVector256Int16(Vector128(byte)) for `VPMOVZXBW ymm xmm` (same insn as for existing ConvertToVector256UInt16())
- Avx2.ConvertToVector256Int32(Vector128(byte/ushort)) for `VPMOVZXBD/WD ymm xmm` (same insn as for existing ConvertToVector256UInt32())
- Avx2.ConvertToVector256Int64(Vector128(byte/ushort/uint)) for `VPMOVZXBQ/WQ/DQ ymm xmm` (same insn as for existing ConvertToVector256UInt64())
----------------------------------------
3. I was not able to find not-too-verbose method to convert 32/64-bit scalar value to 256-bit vector in YMM reg. It is possible to set 128-bit vector with `Sse2.ConvertScalarToVector128UInt32/64()` which produces (`MOV r32/r64 imm` + `MOVD/MOVQ XMM r32/r64`) but then `MOVDQA XMMd XMMs` is automatically issued when one attempts to use helper method `Avx.ExtendToVector256()` to get 256-bit vector. To my understanding the helper method was intended to be used as type conversion and produce no-op in such cases since `MOVD/MOVQ X/YMM r32/r64` zeroes upper portion of dest reg. Below is an example of the issue I'm trying to explain:

```
var v = Avx.ExtendToVector256(Sse2.ConvertScalarToVector128UInt64(0x12345678UL));
00007FF989272625  mov         ecx12345678h  
00007FF98927262A  vmovq       xmm0rcx  
00007FF98927262F  vmovdqa     xmm6xmm0  &lt;======= this is not required
```

OTOH the following conversion in reverse direction produces code that looks fine/optimal:

```
var v1 = Sse2.ConvertToUInt64(Avx.GetLowerHalf(Avx.SetZeroVector256&lt;ulong&gt;()));
00007FF989282618  vpxor       ymm0ymm0ymm0  
00007FF98928261D  vmovq       rsixmm0
```
----------------------------------------
4. There exists just one overload for `Ssse3.AlignRight()` that works on `sbyte`. I believe it makes sense to add overloads for other integer types the same way as it was implemented for `Sse2.ShiftRightLogical128BitLane()` which is quite similar in operation. Otherwise developers will have to use type casting.
----------------------------------------
5. There exists just one overload for `Ssse3.Shuffle()`  that works on `sbyte`. I believe it makes sense to add overload that will also work on `byte`.
Adding something mentioned in https://github.com/dotnet/coreclr/issues/18300#issuecomment-394772776
----------------------------------------
I believe these versions deserve their own overloads since conceptually they can be used on SSExx-only hardware which does not provide anything closer to implement "gather" and "scatter" operations (actually "scatter" only appears in AVX512 and anyway granularity is 32 or 64 bits IIRC):

6. `PMOVZX/SX... xmm [m]` - these load from [m] and extend at once a nice fusion. Esp. note the 2x 8-bit version.
7. `PEXTRB/D/W + EXTRACTPS [m] xmm i` - spill single element from xmm to [m]
8. `PINSRB/D/W + INSERTPS xmm [m] i` - merge single element from [m] into xmm. There is special issue open on API for INSERTPS ( #18143 ).

category:testing
theme:intrinsics
skill-level:intermediate
cost:medium</Description>
    <Title_Description>Some integer scalar and vectored methods/overloads are not exposed in HW intrinsics API 1. Currently the intrinsics are exposed for signed int -&gt; signed int and for unsigned int -&gt; signed int upconversion when both src and dest are 128-bit vector. But no such API method is directly exposed for **unsigned int -&gt; unsigned int** so one has to either use `UnpackLow()` (which is different operation) or wrap existing signed upconversion with `StaticCast&lt;signed unsigned&gt;()` which may provide overhead (see #18069) .
The suggestion is to add following convenience methods:
- Sse41.ConvertToVector128UInt16(Vector128(byte)) for `[V]PMOVZXBW xmm xmm` (same insn as for existing ConvertToVector128Int16())
- Sse41.ConvertToVector128UInt32(Vector128(byte/ushort)) for `[V]PMOVZXBD/WD xmm xmm` (same insn as for existing ConvertToVector128Int32())
- Sse41.ConvertToVector128UInt64(Vector128(byte/ushort/uint)) for `[V]PMOVZXBQ/WQ/DQ xmm xmm` (same insn as for existing ConvertToVector128Int64())
----------------------------------------
2. Similarly no direct means are exposed in API for **unsigned int -&gt; signed int** upconversion when src is in 128-bit vector and the dest is in 256-bit vector.
The methods being suggested are:
- Avx2.ConvertToVector256Int16(Vector128(byte)) for `VPMOVZXBW ymm xmm` (same insn as for existing ConvertToVector256UInt16())
- Avx2.ConvertToVector256Int32(Vector128(byte/ushort)) for `VPMOVZXBD/WD ymm xmm` (same insn as for existing ConvertToVector256UInt32())
- Avx2.ConvertToVector256Int64(Vector128(byte/ushort/uint)) for `VPMOVZXBQ/WQ/DQ ymm xmm` (same insn as for existing ConvertToVector256UInt64())
----------------------------------------
3. I was not able to find not-too-verbose method to convert 32/64-bit scalar value to 256-bit vector in YMM reg. It is possible to set 128-bit vector with `Sse2.ConvertScalarToVector128UInt32/64()` which produces (`MOV r32/r64 imm` + `MOVD/MOVQ XMM r32/r64`) but then `MOVDQA XMMd XMMs` is automatically issued when one attempts to use helper method `Avx.ExtendToVector256()` to get 256-bit vector. To my understanding the helper method was intended to be used as type conversion and produce no-op in such cases since `MOVD/MOVQ X/YMM r32/r64` zeroes upper portion of dest reg. Below is an example of the issue I'm trying to explain:

```
var v = Avx.ExtendToVector256(Sse2.ConvertScalarToVector128UInt64(0x12345678UL));
00007FF989272625  mov         ecx12345678h  
00007FF98927262A  vmovq       xmm0rcx  
00007FF98927262F  vmovdqa     xmm6xmm0  &lt;======= this is not required
```

OTOH the following conversion in reverse direction produces code that looks fine/optimal:

```
var v1 = Sse2.ConvertToUInt64(Avx.GetLowerHalf(Avx.SetZeroVector256&lt;ulong&gt;()));
00007FF989282618  vpxor       ymm0ymm0ymm0  
00007FF98928261D  vmovq       rsixmm0
```
----------------------------------------
4. There exists just one overload for `Ssse3.AlignRight()` that works on `sbyte`. I believe it makes sense to add overloads for other integer types the same way as it was implemented for `Sse2.ShiftRightLogical128BitLane()` which is quite similar in operation. Otherwise developers will have to use type casting.
----------------------------------------
5. There exists just one overload for `Ssse3.Shuffle()`  that works on `sbyte`. I believe it makes sense to add overload that will also work on `byte`.
Adding something mentioned in https://github.com/dotnet/coreclr/issues/18300#issuecomment-394772776
----------------------------------------
I believe these versions deserve their own overloads since conceptually they can be used on SSExx-only hardware which does not provide anything closer to implement "gather" and "scatter" operations (actually "scatter" only appears in AVX512 and anyway granularity is 32 or 64 bits IIRC):

6. `PMOVZX/SX... xmm [m]` - these load from [m] and extend at once a nice fusion. Esp. note the 2x 8-bit version.
7. `PEXTRB/D/W + EXTRACTPS [m] xmm i` - spill single element from xmm to [m]
8. `PINSRB/D/W + INSERTPS xmm [m] i` - merge single element from [m] into xmm. There is special issue open on API for INSERTPS ( #18143 ).

category:testing
theme:intrinsics
skill-level:intermediate
cost:medium</Title_Description>
    <Label>Design Discussion</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>27/05/2018 4:27:50 PM +00:00</CreatedAt>
    <ClosedAt>21/03/2019 4:15:48 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18144</IssueLabelID>
    <Title>Sub-optimal performance when saving/restoring upper parts of YMM regs on AVX+ before/after invoking nested methods</Title>
    <Description>Currently `VEXTRACTF128` is emitted by JIT to save upper parts of YMM regs before invoking nested method(s) which is followed by `VINSERTF128` to restore value back.

There are 4 issues observed:

1. Although there exists encoding `VEXTRACTx128 xmmword ptr [m128] YMMy 1` that allows saving the upper half of YMM directly to [m128] when for some reason ;-)  JIT decides to spill that to stack location two insns are now emitted: `VEXTRACTx128 XMMx YMMy 1` + `VMOVUPD xmmword ptr [rsp+ZZZ]XMMx`. The similar issue appears when restoring values back - `VMOVUPD XMMx xmmword ptr [rsp+ZZZ]` + `VINSERTx128 YMMy YMMy XMMx 1` although there exists form `VINSERTx128 YMMy YMMy [m128] 1`

2. Overall multiple unneeded `VINSERTx128` + `VEXTRACTx128` (in this order) are issued inbetween the calls to nested methods even though it is obvious that the values initially saved are neither modified nor required during and inbetween the invocations. For the repro code below no restore/save roundtrip is required to my understanding inbetween calls to `DoThis()` and `DoThat()`. The good indication of performance hit is in the 2nd part of example when `object[]` is implicitly created and filled in which involves lots of (what I think is) boxing conversions to be later passed to `Console.WriteLine()`. It is even worse if string interpolation would be used. Overall ~1Kb of machine code was generated of which mere 1/4th-1/3rd does anything useful. [My speculation is - this thing may worsen further when it will come to restoring/saving larger vectors like the ones AVX-512 will provide when it will come into play.]

3. `VINSERTF128/VEXTRACTF128` FP domain insns are issued for integer domain vectors although `VINSERTI128/VEXTRACTI128` integer domain insns are available on AVX2 (JIT ran on Haswell). It's possible that even though both pairs of insns execute equally fast on current CPUs this may change in the future. [I cannot consistently confirm whether performance hit exists or not on current CPUs since I only have pre-AVX Nehalem and noisy Haswell VM at my disposal.]

4. I believe that the method-level attribute something like `[NoYMMSaveRestore]` would find it's place under the sun. This could also be new `MethodImplOption.NoRegistersSaveRestore` flag and/or parameter in `DllImportAttribute` for P/Invoke. The usage behind is - when you're calling the code [you written] in native DLL and you're absolutely sure it doesn't interfere with SIMD registers other than X/Y/ZMM0-5 if at all.

Below is the source code for repro:

```
        [MethodImpl(MethodImplOptions.NoInlining)]
        static void DoThis() { }

        [MethodImpl(MethodImplOptions.NoInlining)]
        static void DoThat() { }

        static void Main(string[] args)
        {
            var xA = Avx.SetZeroVector256&lt;byte&gt;();
            var xB = Avx.SetZeroVector256&lt;byte&gt;();
            var xC = Avx.SetZeroVector256&lt;byte&gt;();
            var xD = Avx.SetZeroVector256&lt;byte&gt;();
            var xE = Avx.SetZeroVector256&lt;byte&gt;();
            var xF = Avx.SetZeroVector256&lt;byte&gt;();
            var xG = Avx.SetZeroVector256&lt;byte&gt;();
            var xH = Avx.SetZeroVector256&lt;byte&gt;();

            DoThis();
            DoThat();

            Console.WriteLine("{0} {1} {2} {3} {4} {5} {6} {7}" xA xB xC xD xE xF xG xH);
        }
```
The asm code I've got on Haswell (i7-4790K with AVX2):

```
--- ...\Program.cs --------------------------------------
            var xA = Avx.SetZeroVector256&lt;byte&gt;();
00007FF989261BA0  push        rsi  
00007FF989261BA1  sub         rsp190h  
00007FF989261BA8  vzeroupper  
00007FF989261BAB  vmovaps     xmmword ptr [rsp+180h]xmm6  
00007FF989261BB5  vmovaps     xmmword ptr [rsp+170h]xmm7  
00007FF989261BBF  vmovaps     xmmword ptr [rsp+160h]xmm8  
00007FF989261BC9  vmovaps     xmmword ptr [rsp+150h]xmm9  
00007FF989261BD3  vmovaps     xmmword ptr [rsp+140h]xmm10  
00007FF989261BDD  vmovaps     xmmword ptr [rsp+130h]xmm11  
00007FF989261BE7  vmovaps     xmmword ptr [rsp+120h]xmm12  
00007FF989261BF1  vmovaps     xmmword ptr [rsp+110h]xmm13  
00007FF989261BFB  vmovaps     xmmword ptr [rsp+100h]xmm14  
00007FF989261C05  vmovaps     xmmword ptr [rsp+0F0h]xmm15  
00007FF989261C0F  vpxor       ymm6ymm6ymm6  
            var xB = Avx.SetZeroVector256&lt;byte&gt;();
00007FF989261C14  vpxor       ymm7ymm7ymm7  
            var xC = Avx.SetZeroVector256&lt;byte&gt;();
00007FF989261C19  vpxor       ymm8ymm8ymm8  
            var xD = Avx.SetZeroVector256&lt;byte&gt;();
00007FF989261C1E  vpxor       ymm9ymm9ymm9  
            var xE = Avx.SetZeroVector256&lt;byte&gt;();
00007FF989261C23  vpxor       ymm10ymm10ymm10  
            var xF = Avx.SetZeroVector256&lt;byte&gt;();
00007FF989261C28  vpxor       ymm11ymm11ymm11  
00007FF989261C2D  vmovupd     ymmword ptr [rsp+60h]ymm11  
            var xG = Avx.SetZeroVector256&lt;byte&gt;();
00007FF989261C34  vpxor       ymm12ymm12ymm12  
            var xG = Avx.SetZeroVector256&lt;byte&gt;();
00007FF989261C39  vmovupd     ymmword ptr [rsp+40h]ymm12  
            var xH = Avx.SetZeroVector256&lt;byte&gt;();
00007FF989261C40  vpxor       ymm13ymm13ymm13  
00007FF989261C45  vmovupd     ymmword ptr [rsp+20h]ymm13  

            DoThis();
00007FF989261C4C  vextractf128 xmm14ymm61  
00007FF989261C52  vextractf128 xmm15ymm71  
00007FF989261C58  vextractf128 xmm4ymm81  
00007FF989261C5E  vmovupd     xmmword ptr [rsp+0E0h]xmm4  
00007FF989261C68  vextractf128 xmm4ymm91  
00007FF989261C6E  vmovupd     xmmword ptr [rsp+0D0h]xmm4  
00007FF989261C78  vextractf128 xmm4ymm101  
00007FF989261C7E  vmovupd     xmmword ptr [rsp+0C0h]xmm4  
00007FF989261C88  call        00007FF989261108  
00007FF989261C8D  vmovupd     xmm4xmmword ptr [rsp+0C0h]  
00007FF989261C97  vinsertf128 ymm10ymm10xmm41  
00007FF989261C9D  vmovupd     xmm4xmmword ptr [rsp+0D0h]  
00007FF989261CA7  vinsertf128 ymm9ymm9xmm41  
00007FF989261CAD  vmovupd     xmm4xmmword ptr [rsp+0E0h]  
00007FF989261CB7  vinsertf128 ymm8ymm8xmm41  
00007FF989261CBD  vinsertf128 ymm7ymm7xmm151  
00007FF989261CC3  vinsertf128 ymm6ymm6xmm141  
            DoThat();
00007FF989261CC9  vextractf128 xmm11ymm61  
00007FF989261CCF  vextractf128 xmm12ymm71  
00007FF989261CD5  vextractf128 xmm13ymm81  
00007FF989261CDB  vextractf128 xmm14ymm91  
00007FF989261CE1  vextractf128 xmm15ymm101  
00007FF989261CE7  call        00007FF989261110  
00007FF989261CEC  vinsertf128 ymm10ymm10xmm151  
00007FF989261CF2  vinsertf128 ymm9ymm9xmm141  
00007FF989261CF8  vinsertf128 ymm8ymm8xmm131  
            DoThat();
00007FF989261CFE  vinsertf128 ymm7ymm7xmm121  
00007FF989261D04  vinsertf128 ymm6ymm6xmm111  

            Console.WriteLine("{0} {1} {2} {3} {4} {5} {6} {7}" xA xB xC xD xE xF xG xH);
00007FF989261D0A  mov         rcx7FF9E67932B0h  
00007FF989261D14  mov         edx8  
00007FF989261D19  vextractf128 xmm11ymm61  
00007FF989261D1F  vextractf128 xmm12ymm71  
00007FF989261D25  vextractf128 xmm13ymm81  
00007FF989261D2B  vextractf128 xmm14ymm91  
00007FF989261D31  vextractf128 xmm15ymm101  
00007FF989261D37  call        00007FF9E8D41AD0  
00007FF989261D3C  vinsertf128 ymm10ymm10xmm151  
00007FF989261D42  vinsertf128 ymm9ymm9xmm141  
00007FF989261D48  vinsertf128 ymm8ymm8xmm131  
00007FF989261D4E  vinsertf128 ymm7ymm7xmm121  
00007FF989261D54  vinsertf128 ymm6ymm6xmm111  
00007FF989261D5A  mov         rsirax  
00007FF989261D5D  mov         rcx7FF989256770h  
00007FF989261D67  vextractf128 xmm11ymm61  
00007FF989261D6D  vextractf128 xmm12ymm71  
00007FF989261D73  vextractf128 xmm13ymm81  
00007FF989261D79  vextractf128 xmm14ymm91  
00007FF989261D7F  vextractf128 xmm15ymm101  
00007FF989261D85  call        00007FF9E8D41940  
00007FF989261D8A  vinsertf128 ymm10ymm10xmm151  
00007FF989261D90  vinsertf128 ymm9ymm9xmm141  
00007FF989261D96  vinsertf128 ymm8ymm8xmm131  
00007FF989261D9C  vinsertf128 ymm7ymm7xmm121  
00007FF989261DA2  vinsertf128 ymm6ymm6xmm111  
00007FF989261DA8  mov         r8rax  
00007FF989261DAB  vmovupd     ymmword ptr [r8+8]ymm6  
00007FF989261DB1  mov         rcxrsi  
00007FF989261DB4  xor         edxedx  
00007FF989261DB6  vextractf128 xmm6ymm71  
00007FF989261DBC  vextractf128 xmm11ymm81  
00007FF989261DC2  vextractf128 xmm12ymm91  
00007FF989261DC8  vextractf128 xmm13ymm101  
00007FF989261DCE  call        00007FF9E8D405C0  
00007FF989261DD3  vinsertf128 ymm10ymm10xmm131  
00007FF989261DD9  vinsertf128 ymm9ymm9xmm121  
00007FF989261DDF  vinsertf128 ymm8ymm8xmm111  
00007FF989261DE5  vinsertf128 ymm7ymm7xmm61  
00007FF989261DEB  mov         rcx7FF989256770h  
00007FF989261DF5  vextractf128 xmm6ymm71  
00007FF989261DFB  vextractf128 xmm11ymm81  
00007FF989261E01  vextractf128 xmm12ymm91  
00007FF989261E07  vextractf128 xmm13ymm101  
00007FF989261E0D  call        00007FF9E8D41940  
00007FF989261E12  vinsertf128 ymm10ymm10xmm131  
00007FF989261E18  vinsertf128 ymm9ymm9xmm121  
00007FF989261E1E  vinsertf128 ymm8ymm8xmm111  
00007FF989261E24  vinsertf128 ymm7ymm7xmm61  
00007FF989261E2A  mov         r8rax  
00007FF989261E2D  vmovupd     ymmword ptr [r8+8]ymm7  
00007FF989261E33  mov         rcxrsi  
00007FF989261E36  mov         edx1  
00007FF989261E3B  vextractf128 xmm6ymm81  
00007FF989261E41  vextractf128 xmm7ymm91  
00007FF989261E47  vextractf128 xmm11ymm101  
00007FF989261E4D  call        00007FF9E8D405C0  
00007FF989261E52  vinsertf128 ymm10ymm10xmm111  
00007FF989261E58  vinsertf128 ymm9ymm9xmm71  
00007FF989261E5E  vinsertf128 ymm8ymm8xmm61  
00007FF989261E64  mov         rcx7FF989256770h  
00007FF989261E6E  vextractf128 xmm6ymm81  
00007FF989261E74  vextractf128 xmm7ymm91  
00007FF989261E7A  vextractf128 xmm11ymm101  
00007FF989261E80  call        00007FF9E8D41940  
00007FF989261E85  vinsertf128 ymm10ymm10xmm111  
00007FF989261E8B  vinsertf128 ymm9ymm9xmm71  
00007FF989261E91  vinsertf128 ymm8ymm8xmm61  
00007FF989261E97  mov         r8rax  
00007FF989261E9A  vmovupd     ymmword ptr [r8+8]ymm8  
00007FF989261EA0  mov         rcxrsi  
00007FF989261EA3  mov         edx2  
00007FF989261EA8  vextractf128 xmm6ymm91  
00007FF989261EAE  vextractf128 xmm7ymm101  
00007FF989261EB4  call        00007FF9E8D405C0  
00007FF989261EB9  vinsertf128 ymm10ymm10xmm71  
00007FF989261EBF  vinsertf128 ymm9ymm9xmm61  
00007FF989261EC5  mov         rcx7FF989256770h  
00007FF989261ECF  vextractf128 xmm6ymm91  
00007FF989261ED5  vextractf128 xmm7ymm101  
00007FF989261EDB  call        00007FF9E8D41940  
00007FF989261EE0  vinsertf128 ymm10ymm10xmm71  
00007FF989261EE6  vinsertf128 ymm9ymm9xmm61  
00007FF989261EEC  mov         r8rax  
00007FF989261EEF  vmovupd     ymmword ptr [r8+8]ymm9  
00007FF989261EF5  mov         rcxrsi  
00007FF989261EF8  mov         edx3  
00007FF989261EFD  vextractf128 xmm6ymm101  
00007FF989261F03  call        00007FF9E8D405C0  
00007FF989261F08  vinsertf128 ymm10ymm10xmm61  
00007FF989261F0E  mov         rcx7FF989256770h  
00007FF989261F18  vextractf128 xmm6ymm101  
00007FF989261F1E  call        00007FF9E8D41940  
00007FF989261F23  vinsertf128 ymm10ymm10xmm61  
00007FF989261F29  mov         r8rax  
00007FF989261F2C  vmovupd     ymmword ptr [r8+8]ymm10  
00007FF989261F32  mov         rcxrsi  
00007FF989261F35  mov         edx4  
00007FF989261F3A  call        00007FF9E8D405C0  
00007FF989261F3F  mov         rcx7FF989256770h  
00007FF989261F49  call        00007FF9E8D41940  
00007FF989261F4E  mov         r8rax  
00007FF989261F51  vmovupd     ymm11ymmword ptr [rsp+60h]  
00007FF989261F58  vmovupd     ymmword ptr [r8+8]ymm11  
00007FF989261F5E  mov         rcxrsi  
00007FF989261F61  mov         edx5  
00007FF989261F66  call        00007FF9E8D405C0  
00007FF989261F6B  mov         rcx7FF989256770h  
00007FF989261F75  call        00007FF9E8D41940  
00007FF989261F7A  mov         r8rax  
00007FF989261F7D  vmovupd     ymm12ymmword ptr [rsp+40h]  
00007FF989261F84  vmovupd     ymmword ptr [r8+8]ymm12  
00007FF989261F8A  mov         rcxrsi  
00007FF989261F8D  mov         edx6  
00007FF989261F92  call        00007FF9E8D405C0  
00007FF989261F97  mov         rcx7FF989256770h  
00007FF989261FA1  call        00007FF9E8D41940  
00007FF989261FA6  mov         r8rax  
00007FF989261FA9  vmovupd     ymm13ymmword ptr [rsp+20h]  
00007FF989261FB0  vmovupd     ymmword ptr [r8+8]ymm13  
00007FF989261FB6  mov         rcxrsi  
00007FF989261FB9  mov         edx7  
00007FF989261FBE  call        00007FF9E8D405C0  
00007FF989261FC3  mov         rcx20B9B723068h  
00007FF989261FCD  mov         rcxqword ptr [rcx]  
00007FF989261FD0  mov         rdxrsi  
00007FF989261FD3  call        00007FF9892613F0  
00007FF989261FD8  nop  
00007FF989261FD9  vmovaps     xmm6xmmword ptr [rsp+180h]  
00007FF989261FE3  vmovaps     xmm7xmmword ptr [rsp+170h]  
00007FF989261FED  vmovaps     xmm8xmmword ptr [rsp+160h]  
00007FF989261FF7  vmovaps     xmm9xmmword ptr [rsp+150h]  
00007FF989262001  vmovaps     xmm10xmmword ptr [rsp+140h]  
00007FF98926200B  vmovaps     xmm11xmmword ptr [rsp+130h]  
00007FF989262015  vmovaps     xmm12xmmword ptr [rsp+120h]  
00007FF98926201F  vmovaps     xmm13xmmword ptr [rsp+110h]  
00007FF989262029  vmovaps     xmm14xmmword ptr [rsp+100h]  
00007FF989262033  vmovaps     xmm15xmmword ptr [rsp+0F0h]  
00007FF98926203D  vzeroupper  
00007FF989262040  add         rsp190h  
00007FF989262047  pop         rsi  
00007FF989262048  ret 
```
category:cq
theme:register-allocator
skill-level:expert
cost:medium
</Description>
    <Title_Description>Sub-optimal performance when saving/restoring upper parts of YMM regs on AVX+ before/after invoking nested methods Currently `VEXTRACTF128` is emitted by JIT to save upper parts of YMM regs before invoking nested method(s) which is followed by `VINSERTF128` to restore value back.

There are 4 issues observed:

1. Although there exists encoding `VEXTRACTx128 xmmword ptr [m128] YMMy 1` that allows saving the upper half of YMM directly to [m128] when for some reason ;-)  JIT decides to spill that to stack location two insns are now emitted: `VEXTRACTx128 XMMx YMMy 1` + `VMOVUPD xmmword ptr [rsp+ZZZ]XMMx`. The similar issue appears when restoring values back - `VMOVUPD XMMx xmmword ptr [rsp+ZZZ]` + `VINSERTx128 YMMy YMMy XMMx 1` although there exists form `VINSERTx128 YMMy YMMy [m128] 1`

2. Overall multiple unneeded `VINSERTx128` + `VEXTRACTx128` (in this order) are issued inbetween the calls to nested methods even though it is obvious that the values initially saved are neither modified nor required during and inbetween the invocations. For the repro code below no restore/save roundtrip is required to my understanding inbetween calls to `DoThis()` and `DoThat()`. The good indication of performance hit is in the 2nd part of example when `object[]` is implicitly created and filled in which involves lots of (what I think is) boxing conversions to be later passed to `Console.WriteLine()`. It is even worse if string interpolation would be used. Overall ~1Kb of machine code was generated of which mere 1/4th-1/3rd does anything useful. [My speculation is - this thing may worsen further when it will come to restoring/saving larger vectors like the ones AVX-512 will provide when it will come into play.]

3. `VINSERTF128/VEXTRACTF128` FP domain insns are issued for integer domain vectors although `VINSERTI128/VEXTRACTI128` integer domain insns are available on AVX2 (JIT ran on Haswell). It's possible that even though both pairs of insns execute equally fast on current CPUs this may change in the future. [I cannot consistently confirm whether performance hit exists or not on current CPUs since I only have pre-AVX Nehalem and noisy Haswell VM at my disposal.]

4. I believe that the method-level attribute something like `[NoYMMSaveRestore]` would find it's place under the sun. This could also be new `MethodImplOption.NoRegistersSaveRestore` flag and/or parameter in `DllImportAttribute` for P/Invoke. The usage behind is - when you're calling the code [you written] in native DLL and you're absolutely sure it doesn't interfere with SIMD registers other than X/Y/ZMM0-5 if at all.

Below is the source code for repro:

```
        [MethodImpl(MethodImplOptions.NoInlining)]
        static void DoThis() { }

        [MethodImpl(MethodImplOptions.NoInlining)]
        static void DoThat() { }

        static void Main(string[] args)
        {
            var xA = Avx.SetZeroVector256&lt;byte&gt;();
            var xB = Avx.SetZeroVector256&lt;byte&gt;();
            var xC = Avx.SetZeroVector256&lt;byte&gt;();
            var xD = Avx.SetZeroVector256&lt;byte&gt;();
            var xE = Avx.SetZeroVector256&lt;byte&gt;();
            var xF = Avx.SetZeroVector256&lt;byte&gt;();
            var xG = Avx.SetZeroVector256&lt;byte&gt;();
            var xH = Avx.SetZeroVector256&lt;byte&gt;();

            DoThis();
            DoThat();

            Console.WriteLine("{0} {1} {2} {3} {4} {5} {6} {7}" xA xB xC xD xE xF xG xH);
        }
```
The asm code I've got on Haswell (i7-4790K with AVX2):

```
--- ...\Program.cs --------------------------------------
            var xA = Avx.SetZeroVector256&lt;byte&gt;();
00007FF989261BA0  push        rsi  
00007FF989261BA1  sub         rsp190h  
00007FF989261BA8  vzeroupper  
00007FF989261BAB  vmovaps     xmmword ptr [rsp+180h]xmm6  
00007FF989261BB5  vmovaps     xmmword ptr [rsp+170h]xmm7  
00007FF989261BBF  vmovaps     xmmword ptr [rsp+160h]xmm8  
00007FF989261BC9  vmovaps     xmmword ptr [rsp+150h]xmm9  
00007FF989261BD3  vmovaps     xmmword ptr [rsp+140h]xmm10  
00007FF989261BDD  vmovaps     xmmword ptr [rsp+130h]xmm11  
00007FF989261BE7  vmovaps     xmmword ptr [rsp+120h]xmm12  
00007FF989261BF1  vmovaps     xmmword ptr [rsp+110h]xmm13  
00007FF989261BFB  vmovaps     xmmword ptr [rsp+100h]xmm14  
00007FF989261C05  vmovaps     xmmword ptr [rsp+0F0h]xmm15  
00007FF989261C0F  vpxor       ymm6ymm6ymm6  
            var xB = Avx.SetZeroVector256&lt;byte&gt;();
00007FF989261C14  vpxor       ymm7ymm7ymm7  
            var xC = Avx.SetZeroVector256&lt;byte&gt;();
00007FF989261C19  vpxor       ymm8ymm8ymm8  
            var xD = Avx.SetZeroVector256&lt;byte&gt;();
00007FF989261C1E  vpxor       ymm9ymm9ymm9  
            var xE = Avx.SetZeroVector256&lt;byte&gt;();
00007FF989261C23  vpxor       ymm10ymm10ymm10  
            var xF = Avx.SetZeroVector256&lt;byte&gt;();
00007FF989261C28  vpxor       ymm11ymm11ymm11  
00007FF989261C2D  vmovupd     ymmword ptr [rsp+60h]ymm11  
            var xG = Avx.SetZeroVector256&lt;byte&gt;();
00007FF989261C34  vpxor       ymm12ymm12ymm12  
            var xG = Avx.SetZeroVector256&lt;byte&gt;();
00007FF989261C39  vmovupd     ymmword ptr [rsp+40h]ymm12  
            var xH = Avx.SetZeroVector256&lt;byte&gt;();
00007FF989261C40  vpxor       ymm13ymm13ymm13  
00007FF989261C45  vmovupd     ymmword ptr [rsp+20h]ymm13  

            DoThis();
00007FF989261C4C  vextractf128 xmm14ymm61  
00007FF989261C52  vextractf128 xmm15ymm71  
00007FF989261C58  vextractf128 xmm4ymm81  
00007FF989261C5E  vmovupd     xmmword ptr [rsp+0E0h]xmm4  
00007FF989261C68  vextractf128 xmm4ymm91  
00007FF989261C6E  vmovupd     xmmword ptr [rsp+0D0h]xmm4  
00007FF989261C78  vextractf128 xmm4ymm101  
00007FF989261C7E  vmovupd     xmmword ptr [rsp+0C0h]xmm4  
00007FF989261C88  call        00007FF989261108  
00007FF989261C8D  vmovupd     xmm4xmmword ptr [rsp+0C0h]  
00007FF989261C97  vinsertf128 ymm10ymm10xmm41  
00007FF989261C9D  vmovupd     xmm4xmmword ptr [rsp+0D0h]  
00007FF989261CA7  vinsertf128 ymm9ymm9xmm41  
00007FF989261CAD  vmovupd     xmm4xmmword ptr [rsp+0E0h]  
00007FF989261CB7  vinsertf128 ymm8ymm8xmm41  
00007FF989261CBD  vinsertf128 ymm7ymm7xmm151  
00007FF989261CC3  vinsertf128 ymm6ymm6xmm141  
            DoThat();
00007FF989261CC9  vextractf128 xmm11ymm61  
00007FF989261CCF  vextractf128 xmm12ymm71  
00007FF989261CD5  vextractf128 xmm13ymm81  
00007FF989261CDB  vextractf128 xmm14ymm91  
00007FF989261CE1  vextractf128 xmm15ymm101  
00007FF989261CE7  call        00007FF989261110  
00007FF989261CEC  vinsertf128 ymm10ymm10xmm151  
00007FF989261CF2  vinsertf128 ymm9ymm9xmm141  
00007FF989261CF8  vinsertf128 ymm8ymm8xmm131  
            DoThat();
00007FF989261CFE  vinsertf128 ymm7ymm7xmm121  
00007FF989261D04  vinsertf128 ymm6ymm6xmm111  

            Console.WriteLine("{0} {1} {2} {3} {4} {5} {6} {7}" xA xB xC xD xE xF xG xH);
00007FF989261D0A  mov         rcx7FF9E67932B0h  
00007FF989261D14  mov         edx8  
00007FF989261D19  vextractf128 xmm11ymm61  
00007FF989261D1F  vextractf128 xmm12ymm71  
00007FF989261D25  vextractf128 xmm13ymm81  
00007FF989261D2B  vextractf128 xmm14ymm91  
00007FF989261D31  vextractf128 xmm15ymm101  
00007FF989261D37  call        00007FF9E8D41AD0  
00007FF989261D3C  vinsertf128 ymm10ymm10xmm151  
00007FF989261D42  vinsertf128 ymm9ymm9xmm141  
00007FF989261D48  vinsertf128 ymm8ymm8xmm131  
00007FF989261D4E  vinsertf128 ymm7ymm7xmm121  
00007FF989261D54  vinsertf128 ymm6ymm6xmm111  
00007FF989261D5A  mov         rsirax  
00007FF989261D5D  mov         rcx7FF989256770h  
00007FF989261D67  vextractf128 xmm11ymm61  
00007FF989261D6D  vextractf128 xmm12ymm71  
00007FF989261D73  vextractf128 xmm13ymm81  
00007FF989261D79  vextractf128 xmm14ymm91  
00007FF989261D7F  vextractf128 xmm15ymm101  
00007FF989261D85  call        00007FF9E8D41940  
00007FF989261D8A  vinsertf128 ymm10ymm10xmm151  
00007FF989261D90  vinsertf128 ymm9ymm9xmm141  
00007FF989261D96  vinsertf128 ymm8ymm8xmm131  
00007FF989261D9C  vinsertf128 ymm7ymm7xmm121  
00007FF989261DA2  vinsertf128 ymm6ymm6xmm111  
00007FF989261DA8  mov         r8rax  
00007FF989261DAB  vmovupd     ymmword ptr [r8+8]ymm6  
00007FF989261DB1  mov         rcxrsi  
00007FF989261DB4  xor         edxedx  
00007FF989261DB6  vextractf128 xmm6ymm71  
00007FF989261DBC  vextractf128 xmm11ymm81  
00007FF989261DC2  vextractf128 xmm12ymm91  
00007FF989261DC8  vextractf128 xmm13ymm101  
00007FF989261DCE  call        00007FF9E8D405C0  
00007FF989261DD3  vinsertf128 ymm10ymm10xmm131  
00007FF989261DD9  vinsertf128 ymm9ymm9xmm121  
00007FF989261DDF  vinsertf128 ymm8ymm8xmm111  
00007FF989261DE5  vinsertf128 ymm7ymm7xmm61  
00007FF989261DEB  mov         rcx7FF989256770h  
00007FF989261DF5  vextractf128 xmm6ymm71  
00007FF989261DFB  vextractf128 xmm11ymm81  
00007FF989261E01  vextractf128 xmm12ymm91  
00007FF989261E07  vextractf128 xmm13ymm101  
00007FF989261E0D  call        00007FF9E8D41940  
00007FF989261E12  vinsertf128 ymm10ymm10xmm131  
00007FF989261E18  vinsertf128 ymm9ymm9xmm121  
00007FF989261E1E  vinsertf128 ymm8ymm8xmm111  
00007FF989261E24  vinsertf128 ymm7ymm7xmm61  
00007FF989261E2A  mov         r8rax  
00007FF989261E2D  vmovupd     ymmword ptr [r8+8]ymm7  
00007FF989261E33  mov         rcxrsi  
00007FF989261E36  mov         edx1  
00007FF989261E3B  vextractf128 xmm6ymm81  
00007FF989261E41  vextractf128 xmm7ymm91  
00007FF989261E47  vextractf128 xmm11ymm101  
00007FF989261E4D  call        00007FF9E8D405C0  
00007FF989261E52  vinsertf128 ymm10ymm10xmm111  
00007FF989261E58  vinsertf128 ymm9ymm9xmm71  
00007FF989261E5E  vinsertf128 ymm8ymm8xmm61  
00007FF989261E64  mov         rcx7FF989256770h  
00007FF989261E6E  vextractf128 xmm6ymm81  
00007FF989261E74  vextractf128 xmm7ymm91  
00007FF989261E7A  vextractf128 xmm11ymm101  
00007FF989261E80  call        00007FF9E8D41940  
00007FF989261E85  vinsertf128 ymm10ymm10xmm111  
00007FF989261E8B  vinsertf128 ymm9ymm9xmm71  
00007FF989261E91  vinsertf128 ymm8ymm8xmm61  
00007FF989261E97  mov         r8rax  
00007FF989261E9A  vmovupd     ymmword ptr [r8+8]ymm8  
00007FF989261EA0  mov         rcxrsi  
00007FF989261EA3  mov         edx2  
00007FF989261EA8  vextractf128 xmm6ymm91  
00007FF989261EAE  vextractf128 xmm7ymm101  
00007FF989261EB4  call        00007FF9E8D405C0  
00007FF989261EB9  vinsertf128 ymm10ymm10xmm71  
00007FF989261EBF  vinsertf128 ymm9ymm9xmm61  
00007FF989261EC5  mov         rcx7FF989256770h  
00007FF989261ECF  vextractf128 xmm6ymm91  
00007FF989261ED5  vextractf128 xmm7ymm101  
00007FF989261EDB  call        00007FF9E8D41940  
00007FF989261EE0  vinsertf128 ymm10ymm10xmm71  
00007FF989261EE6  vinsertf128 ymm9ymm9xmm61  
00007FF989261EEC  mov         r8rax  
00007FF989261EEF  vmovupd     ymmword ptr [r8+8]ymm9  
00007FF989261EF5  mov         rcxrsi  
00007FF989261EF8  mov         edx3  
00007FF989261EFD  vextractf128 xmm6ymm101  
00007FF989261F03  call        00007FF9E8D405C0  
00007FF989261F08  vinsertf128 ymm10ymm10xmm61  
00007FF989261F0E  mov         rcx7FF989256770h  
00007FF989261F18  vextractf128 xmm6ymm101  
00007FF989261F1E  call        00007FF9E8D41940  
00007FF989261F23  vinsertf128 ymm10ymm10xmm61  
00007FF989261F29  mov         r8rax  
00007FF989261F2C  vmovupd     ymmword ptr [r8+8]ymm10  
00007FF989261F32  mov         rcxrsi  
00007FF989261F35  mov         edx4  
00007FF989261F3A  call        00007FF9E8D405C0  
00007FF989261F3F  mov         rcx7FF989256770h  
00007FF989261F49  call        00007FF9E8D41940  
00007FF989261F4E  mov         r8rax  
00007FF989261F51  vmovupd     ymm11ymmword ptr [rsp+60h]  
00007FF989261F58  vmovupd     ymmword ptr [r8+8]ymm11  
00007FF989261F5E  mov         rcxrsi  
00007FF989261F61  mov         edx5  
00007FF989261F66  call        00007FF9E8D405C0  
00007FF989261F6B  mov         rcx7FF989256770h  
00007FF989261F75  call        00007FF9E8D41940  
00007FF989261F7A  mov         r8rax  
00007FF989261F7D  vmovupd     ymm12ymmword ptr [rsp+40h]  
00007FF989261F84  vmovupd     ymmword ptr [r8+8]ymm12  
00007FF989261F8A  mov         rcxrsi  
00007FF989261F8D  mov         edx6  
00007FF989261F92  call        00007FF9E8D405C0  
00007FF989261F97  mov         rcx7FF989256770h  
00007FF989261FA1  call        00007FF9E8D41940  
00007FF989261FA6  mov         r8rax  
00007FF989261FA9  vmovupd     ymm13ymmword ptr [rsp+20h]  
00007FF989261FB0  vmovupd     ymmword ptr [r8+8]ymm13  
00007FF989261FB6  mov         rcxrsi  
00007FF989261FB9  mov         edx7  
00007FF989261FBE  call        00007FF9E8D405C0  
00007FF989261FC3  mov         rcx20B9B723068h  
00007FF989261FCD  mov         rcxqword ptr [rcx]  
00007FF989261FD0  mov         rdxrsi  
00007FF989261FD3  call        00007FF9892613F0  
00007FF989261FD8  nop  
00007FF989261FD9  vmovaps     xmm6xmmword ptr [rsp+180h]  
00007FF989261FE3  vmovaps     xmm7xmmword ptr [rsp+170h]  
00007FF989261FED  vmovaps     xmm8xmmword ptr [rsp+160h]  
00007FF989261FF7  vmovaps     xmm9xmmword ptr [rsp+150h]  
00007FF989262001  vmovaps     xmm10xmmword ptr [rsp+140h]  
00007FF98926200B  vmovaps     xmm11xmmword ptr [rsp+130h]  
00007FF989262015  vmovaps     xmm12xmmword ptr [rsp+120h]  
00007FF98926201F  vmovaps     xmm13xmmword ptr [rsp+110h]  
00007FF989262029  vmovaps     xmm14xmmword ptr [rsp+100h]  
00007FF989262033  vmovaps     xmm15xmmword ptr [rsp+0F0h]  
00007FF98926203D  vzeroupper  
00007FF989262040  add         rsp190h  
00007FF989262047  pop         rsi  
00007FF989262048  ret 
```
category:cq
theme:register-allocator
skill-level:expert
cost:medium
</Title_Description>
    <Label>arch-x64</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18143</IssueLabelID>
    <Title>HW intrinsics API declaration is incorrect for Sse41.Insert() that operates on vector of 32-bit floats</Title>
    <Description>The `[V]INSERTPS` operation differs from similarly named operations that maps to `[V]PINSRW` (SSE2+) and `[V]PINSRB/D/Q` (SSE4.1+).

Here's how it is declared in API:

```
        /// &lt;summary&gt;
        /// __m128 _mm_insert_ps (__m128 a __m128 b const int imm8)
        ///   INSERTPS xmm xmm/m32 imm8
        /// &lt;/summary&gt;
        public static Vector128&lt;float&gt; Insert(Vector128&lt;float&gt; value float data byte index) =&gt; Insert(value data index);
```

In fact the operation either loads the value from [m32] and merges it with source XMM reg at specified position or merges value of selected 32-bit element from XMM reg (2nd operand) with source XMM reg (1st operand).
Additionally it can zero some or all elements of result.

Here's how it is implemented in CPU:

**INSERTPS (128-bit Legacy SSE version)**
```
IF (SRC = REG) THEN COUNT_S←imm8[7:6]
    ELSE COUNT_S←0
COUNT_D ←imm8[5:4]
ZMASK ←imm8[3:0]
CASE (COUNT_S) OF
    0: TMP←SRC[31:0]
    1: TMP←SRC[63:32]
    2: TMP←SRC[95:64]
    3: TMP←SRC[127:96]
ESAC;
CASE (COUNT_D) OF
    0: TMP2[31:0]←TMP
        TMP2[127:32] ←DEST[127:32]
    1: TMP2[63:32]←TMP
        TMP2[31:0] ←DEST[31:0]
        TMP2[127:64] ←DEST[127:64]
    2: TMP2[95:64]←TMP
        TMP2[63:0] ←DEST[63:0]
        TMP2[127:96] ←DEST[127:96]
    3: TMP2[127:96]←TMP
        TMP2[95:0] ←DEST[95:0]
ESAC;
IF (ZMASK[0] = 1) THEN DEST[31:0]←00000000H
    ELSE DEST[31:0]←TMP2[31:0]
IF (ZMASK[1] = 1) THEN DEST[63:32]←00000000H
    ELSE DEST[63:32]←TMP2[63:32]
IF (ZMASK[2] = 1) THEN DEST[95:64]←00000000H
    ELSE DEST[95:64]←TMP2[95:64]
IF (ZMASK[3] = 1) THEN DEST[127:96]←00000000H
    ELSE DEST[127:96]←TMP2[127:96]
DEST[MAXVL-1:128] (Unmodified)
```

**VINSERTPS (VEX.128 and EVEX encoded version)**
```
IF (SRC = REG) THEN COUNT_S←imm8[7:6]
    ELSE COUNT_S←0
COUNT_D ← imm8[5:4]
ZMASK ← imm8[3:0]
CASE (COUNT_S) OF
    0: TMP←SRC2[31:0]
    1: TMP←SRC2[63:32]
    2: TMP←SRC2[95:64]
    3: TMP←SRC2[127:96]
ESAC;
CASE (COUNT_D) OF
    0: TMP2[31:0]←TMP
        TMP2[127:32] ← SRC1[127:32]
    1: TMP2[63:32]←TMP
        TMP2[31:0] ← SRC1[31:0]
        TMP2[127:64] ← SRC1[127:64]
    2: TMP2[95:64]←TMP
        TMP2[63:0] ← SRC1[63:0]
        TMP2[127:96] ← SRC1[127:96]
    3: TMP2[127:96]←TMP
        TMP2[95:0] ← SRC1[95:0]
ESAC;
IF (ZMASK[0] = 1) THEN DEST[31:0]←00000000H
    ELSE DEST[31:0]←TMP2[31:0]
IF (ZMASK[1] = 1) THEN DEST[63:32]←00000000H
    ELSE DEST[63:32]←TMP2[63:32]
IF (ZMASK[2] = 1) THEN DEST[95:64]←00000000H
    ELSE DEST[95:64]←TMP2[95:64]
IF (ZMASK[3] = 1) THEN DEST[127:96]←00000000H
    ELSE DEST[127:96]←TMP2[127:96]
DEST[MAXVL-1:128] ← 0
```</Description>
    <Title_Description>HW intrinsics API declaration is incorrect for Sse41.Insert() that operates on vector of 32-bit floats The `[V]INSERTPS` operation differs from similarly named operations that maps to `[V]PINSRW` (SSE2+) and `[V]PINSRB/D/Q` (SSE4.1+).

Here's how it is declared in API:

```
        /// &lt;summary&gt;
        /// __m128 _mm_insert_ps (__m128 a __m128 b const int imm8)
        ///   INSERTPS xmm xmm/m32 imm8
        /// &lt;/summary&gt;
        public static Vector128&lt;float&gt; Insert(Vector128&lt;float&gt; value float data byte index) =&gt; Insert(value data index);
```

In fact the operation either loads the value from [m32] and merges it with source XMM reg at specified position or merges value of selected 32-bit element from XMM reg (2nd operand) with source XMM reg (1st operand).
Additionally it can zero some or all elements of result.

Here's how it is implemented in CPU:

**INSERTPS (128-bit Legacy SSE version)**
```
IF (SRC = REG) THEN COUNT_S←imm8[7:6]
    ELSE COUNT_S←0
COUNT_D ←imm8[5:4]
ZMASK ←imm8[3:0]
CASE (COUNT_S) OF
    0: TMP←SRC[31:0]
    1: TMP←SRC[63:32]
    2: TMP←SRC[95:64]
    3: TMP←SRC[127:96]
ESAC;
CASE (COUNT_D) OF
    0: TMP2[31:0]←TMP
        TMP2[127:32] ←DEST[127:32]
    1: TMP2[63:32]←TMP
        TMP2[31:0] ←DEST[31:0]
        TMP2[127:64] ←DEST[127:64]
    2: TMP2[95:64]←TMP
        TMP2[63:0] ←DEST[63:0]
        TMP2[127:96] ←DEST[127:96]
    3: TMP2[127:96]←TMP
        TMP2[95:0] ←DEST[95:0]
ESAC;
IF (ZMASK[0] = 1) THEN DEST[31:0]←00000000H
    ELSE DEST[31:0]←TMP2[31:0]
IF (ZMASK[1] = 1) THEN DEST[63:32]←00000000H
    ELSE DEST[63:32]←TMP2[63:32]
IF (ZMASK[2] = 1) THEN DEST[95:64]←00000000H
    ELSE DEST[95:64]←TMP2[95:64]
IF (ZMASK[3] = 1) THEN DEST[127:96]←00000000H
    ELSE DEST[127:96]←TMP2[127:96]
DEST[MAXVL-1:128] (Unmodified)
```

**VINSERTPS (VEX.128 and EVEX encoded version)**
```
IF (SRC = REG) THEN COUNT_S←imm8[7:6]
    ELSE COUNT_S←0
COUNT_D ← imm8[5:4]
ZMASK ← imm8[3:0]
CASE (COUNT_S) OF
    0: TMP←SRC2[31:0]
    1: TMP←SRC2[63:32]
    2: TMP←SRC2[95:64]
    3: TMP←SRC2[127:96]
ESAC;
CASE (COUNT_D) OF
    0: TMP2[31:0]←TMP
        TMP2[127:32] ← SRC1[127:32]
    1: TMP2[63:32]←TMP
        TMP2[31:0] ← SRC1[31:0]
        TMP2[127:64] ← SRC1[127:64]
    2: TMP2[95:64]←TMP
        TMP2[63:0] ← SRC1[63:0]
        TMP2[127:96] ← SRC1[127:96]
    3: TMP2[127:96]←TMP
        TMP2[95:0] ← SRC1[95:0]
ESAC;
IF (ZMASK[0] = 1) THEN DEST[31:0]←00000000H
    ELSE DEST[31:0]←TMP2[31:0]
IF (ZMASK[1] = 1) THEN DEST[63:32]←00000000H
    ELSE DEST[63:32]←TMP2[63:32]
IF (ZMASK[2] = 1) THEN DEST[95:64]←00000000H
    ELSE DEST[95:64]←TMP2[95:64]
IF (ZMASK[3] = 1) THEN DEST[127:96]←00000000H
    ELSE DEST[127:96]←TMP2[127:96]
DEST[MAXVL-1:128] ← 0
```</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
    <CreatedAt>27/05/2018 12:33:45 PM +00:00</CreatedAt>
    <ClosedAt>18/06/2018 8:17:42 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18137</IssueLabelID>
    <Title>Create a profiler API that appends to the TPA list</Title>
    <Description>This is a more distilled design proposal that solves issues raised in #3894. The idea is to add a new profiler API such as:

    ICorProfilerInfo10::AddAssemblyPath(AppDomainID appDomainId const WCHAR* pAssemblyPath)

which will add a path to list of assemblies that the runtime probes to resolve assembly references. This allows profilers to instrument managed code and include assembly references to a new assembly that was deployed by the profiler rather than being deployed as part of the application.


**Background info to assist implementors**

Probably the hardest part of the problem is creating a testable repro scenario (assuming you don't already have your own IL instrumenting profiler handy). There is an example instrumenting profiler here: https://github.com/Microsoft/clr-samples/tree/master/ProfilingAPI/ReJITEnterLeaveHooks that has most of what is necessary. However this example instruments using a CALLI instruction:
https://github.com/Microsoft/clr-samples/blob/master/ProfilingAPI/ReJITEnterLeaveHooks/ILRewriter.cpp#L746

To reproduce the problem here the profiler instead needs to:
1) Include with the profiler a new managed assembly that has the implementation of some simple callback within it. Lets call this ManagedInstrumentation.dll.

```
     public static class ManagedCallbackFunctions
     {
         public static void OnMethodEnter(int functionId)
         {
              Console.WriteLine("Function " + functionId + " was called");
         }
     }
```

2) Use IMetaDataAssemblyEmit::DefineAssemblyRef to create an AssemblyRef token that refers to the ManagedInstrumentation.dll assembly.
https://docs.microsoft.com/en-us/dotnet/framework/unmanaged-api/metadata/imetadataassemblyemit-defineassemblyref-method
3) Use IMetaDataEmit::DefineTypeRefByName and DefineMemberRef 
https://docs.microsoft.com/en-us/dotnet/framework/unmanaged-api/metadata/imetadataemit-definetyperefbyname-method
https://docs.microsoft.com/en-us/dotnet/framework/unmanaged-api/metadata/imetadataemit-definememberref-method
to create a MemberRef token that refers to ManagedCallbackFunctions.OnMethodEnter
4) Change the instrumentation to use an IL CALL opcode with the ManagedCallbackFunctions.OnMethodEnter token

Running an application with this profiler should fail because ManagedInstrumentation.dll can't be located.

5) To test the new API you will need to handle the AppDomainCreationFinished callback. In the handler QI for ICorProfilerInfo10 and then invoke AddTrustedAssemblyPath(domainId path_to_ManagedInstrumentation.dll). Initially the QI will fail but once the feature is implemented this call should succeed at modifying the assembly list. Later the compilation of instrumented methods should also succeed because the runtime will find ManagedInstrumentation.dll and load it.

To implement the feature:
1) Add the new API to https://github.com/dotnet/coreclr/blob/master/src/inc/corprof.idl
2) Add an implementation to 
https://github.com/dotnet/coreclr/blob/master/src/vm/proftoeeinterfaceimpl.h
https://github.com/dotnet/coreclr/blob/master/src/vm/proftoeeinterfaceimpl.cpp

The implementation of the method needs to change the TPA list which is stored here: 
https://github.com/dotnet/coreclr/blob/32f0f9721afb584b4a14d69135bea7ddc129f755/src/binder/inc/applicationcontext.inl#L74

Navigating to that datastructure should be something like:

    BaseDomain* pDomain = (BaseDomain *) appDomainId;
    pDomain-&gt;GetTPABinderContext()-&gt;GetAppContext()-&gt;GetTpaList();


More background docs about CLR and profiling:
https://github.com/dotnet/coreclr/tree/master/Documentation/botr
https://github.com/dotnet/coreclr/blob/master/Documentation/botr/profiling.md
https://github.com/dotnet/coreclr/blob/master/Documentation/botr/profilability.md

Where the TPA list normally gets set from without using a profiler:
https://github.com/dotnet/coreclr/blob/ef88a92215a8f90fe0bd8b0327c16bb889902105/src/vm/corhost.cpp#L820
Inside the pProfilerNames/Values there is a property named TRUSTED_PLATFORM_ASSEMBLIES with a list of assembly paths. The runtime host constructs this list however they want (dotnet.exe assembles it from some .json configuration files like app.deps.json) and then the runtime stores it.

</Description>
    <Title_Description>Create a profiler API that appends to the TPA list This is a more distilled design proposal that solves issues raised in #3894. The idea is to add a new profiler API such as:

    ICorProfilerInfo10::AddAssemblyPath(AppDomainID appDomainId const WCHAR* pAssemblyPath)

which will add a path to list of assemblies that the runtime probes to resolve assembly references. This allows profilers to instrument managed code and include assembly references to a new assembly that was deployed by the profiler rather than being deployed as part of the application.


**Background info to assist implementors**

Probably the hardest part of the problem is creating a testable repro scenario (assuming you don't already have your own IL instrumenting profiler handy). There is an example instrumenting profiler here: https://github.com/Microsoft/clr-samples/tree/master/ProfilingAPI/ReJITEnterLeaveHooks that has most of what is necessary. However this example instruments using a CALLI instruction:
https://github.com/Microsoft/clr-samples/blob/master/ProfilingAPI/ReJITEnterLeaveHooks/ILRewriter.cpp#L746

To reproduce the problem here the profiler instead needs to:
1) Include with the profiler a new managed assembly that has the implementation of some simple callback within it. Lets call this ManagedInstrumentation.dll.

```
     public static class ManagedCallbackFunctions
     {
         public static void OnMethodEnter(int functionId)
         {
              Console.WriteLine("Function " + functionId + " was called");
         }
     }
```

2) Use IMetaDataAssemblyEmit::DefineAssemblyRef to create an AssemblyRef token that refers to the ManagedInstrumentation.dll assembly.
https://docs.microsoft.com/en-us/dotnet/framework/unmanaged-api/metadata/imetadataassemblyemit-defineassemblyref-method
3) Use IMetaDataEmit::DefineTypeRefByName and DefineMemberRef 
https://docs.microsoft.com/en-us/dotnet/framework/unmanaged-api/metadata/imetadataemit-definetyperefbyname-method
https://docs.microsoft.com/en-us/dotnet/framework/unmanaged-api/metadata/imetadataemit-definememberref-method
to create a MemberRef token that refers to ManagedCallbackFunctions.OnMethodEnter
4) Change the instrumentation to use an IL CALL opcode with the ManagedCallbackFunctions.OnMethodEnter token

Running an application with this profiler should fail because ManagedInstrumentation.dll can't be located.

5) To test the new API you will need to handle the AppDomainCreationFinished callback. In the handler QI for ICorProfilerInfo10 and then invoke AddTrustedAssemblyPath(domainId path_to_ManagedInstrumentation.dll). Initially the QI will fail but once the feature is implemented this call should succeed at modifying the assembly list. Later the compilation of instrumented methods should also succeed because the runtime will find ManagedInstrumentation.dll and load it.

To implement the feature:
1) Add the new API to https://github.com/dotnet/coreclr/blob/master/src/inc/corprof.idl
2) Add an implementation to 
https://github.com/dotnet/coreclr/blob/master/src/vm/proftoeeinterfaceimpl.h
https://github.com/dotnet/coreclr/blob/master/src/vm/proftoeeinterfaceimpl.cpp

The implementation of the method needs to change the TPA list which is stored here: 
https://github.com/dotnet/coreclr/blob/32f0f9721afb584b4a14d69135bea7ddc129f755/src/binder/inc/applicationcontext.inl#L74

Navigating to that datastructure should be something like:

    BaseDomain* pDomain = (BaseDomain *) appDomainId;
    pDomain-&gt;GetTPABinderContext()-&gt;GetAppContext()-&gt;GetTpaList();


More background docs about CLR and profiling:
https://github.com/dotnet/coreclr/tree/master/Documentation/botr
https://github.com/dotnet/coreclr/blob/master/Documentation/botr/profiling.md
https://github.com/dotnet/coreclr/blob/master/Documentation/botr/profilability.md

Where the TPA list normally gets set from without using a profiler:
https://github.com/dotnet/coreclr/blob/ef88a92215a8f90fe0bd8b0327c16bb889902105/src/vm/corhost.cpp#L820
Inside the pProfilerNames/Values there is a property named TRUSTED_PLATFORM_ASSEMBLIES with a list of assembly paths. The runtime host constructs this list however they want (dotnet.exe assembles it from some .json configuration files like app.deps.json) and then the runtime stores it.

</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>noahfalk</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18133</IssueLabelID>
    <Title>Improve SOS to display current profiler state</Title>
    <Description>**Issue description**
Add a command to SOS to display the profiler's state in a process (whether it is attached and what configuration flags it was set up with). 

The task should be fairly straightforward as all the information that SOS needs to display is already stored in the g_profControlBlock struct. My estimation is roughly 3-4 hours for someone who's not already familiar with the codebase.

This issue is originally from: https://github.com/dotnet/coreclr/issues/12719 (partially)

**A little bit of background**
SOS (Son of Strike) is a debugging extension that allows us to debug managed applications running on top of CLR. You can find the source in the ```src/ToolBox/SOS``` directory.

To see how to use SOS to debug managed code you can follow the instructions here: 
https://github.com/dotnet/coreclr/blob/master/Documentation/building/debugging-instructions.md

**Little bit more push on the back to get started**
To add a SOS command to do this you will need to add a function to ```src/ToolBox/SOS/Strike/strike.cpp``` with a suitable SOS command name. (i.e. ```DumpProfilerState```).

You can follow the code path for other SOS commands that are already implemented (i.e. DumpHeap ClrStack) to see how they are implemented as a reference.

CC @mikem8361 @noahfalk </Description>
    <Title_Description>Improve SOS to display current profiler state **Issue description**
Add a command to SOS to display the profiler's state in a process (whether it is attached and what configuration flags it was set up with). 

The task should be fairly straightforward as all the information that SOS needs to display is already stored in the g_profControlBlock struct. My estimation is roughly 3-4 hours for someone who's not already familiar with the codebase.

This issue is originally from: https://github.com/dotnet/coreclr/issues/12719 (partially)

**A little bit of background**
SOS (Son of Strike) is a debugging extension that allows us to debug managed applications running on top of CLR. You can find the source in the ```src/ToolBox/SOS``` directory.

To see how to use SOS to debug managed code you can follow the instructions here: 
https://github.com/dotnet/coreclr/blob/master/Documentation/building/debugging-instructions.md

**Little bit more push on the back to get started**
To add a SOS command to do this you will need to add a function to ```src/ToolBox/SOS/Strike/strike.cpp``` with a suitable SOS command name. (i.e. ```DumpProfilerState```).

You can follow the code path for other SOS commands that are already implemented (i.e. DumpHeap ClrStack) to see how they are implemented as a reference.

CC @mikem8361 @noahfalk </Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>mikem8361</Assignee>
    <CreatedAt>25/05/2018 11:46:48 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18131</IssueLabelID>
    <Title>Enhance ABI and ISA support in altjits</Title>
    <Description>It would be desirable when an altjit is being used to have the full ABI information available plus a default setting for the ISA support (for hardware intrinsics). This might be easier to accomplish with a cleaner refactored `fgMorphArgs()`.
It would also be desirable to set the size of `Vector&lt;T&gt;` according to the minimum supported size between the main and altjits and avoid having to separately set `COMPlus_SIMD16ByteOnly`.

category:design
theme:calling-convention
skill-level:expert
cost:medium</Description>
    <Title_Description>Enhance ABI and ISA support in altjits It would be desirable when an altjit is being used to have the full ABI information available plus a default setting for the ISA support (for hardware intrinsics). This might be easier to accomplish with a cleaner refactored `fgMorphArgs()`.
It would also be desirable to set the size of `Vector&lt;T&gt;` according to the minimum supported size between the main and altjits and avoid having to separately set `COMPlus_SIMD16ByteOnly`.

category:design
theme:calling-convention
skill-level:expert
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
    <CreatedAt>25/05/2018 8:27:16 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18130</IssueLabelID>
    <Title>[Arm64] JIT generate LSE Atomics</Title>
    <Description>When ARMv8.1 LSE Atomics are available use them to implement
Interlocked operations.

@briansull @BruceForstall @CarolEidt @dotnet/jit-contrib </Description>
    <Title_Description>[Arm64] JIT generate LSE Atomics When ARMv8.1 LSE Atomics are available use them to implement
Interlocked operations.

@briansull @BruceForstall @CarolEidt @dotnet/jit-contrib </Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>briansull</Assignee>
    <CreatedAt>25/05/2018 7:51:36 PM +00:00</CreatedAt>
    <ClosedAt>27/06/2018 4:51:33 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18128</IssueLabelID>
    <Title>Clean the list of disabled warnings for CoreCLR</Title>
    <Description>[\src\inc\warningcontrol.h](https://github.com/dotnet/coreclr/blob/master/src/inc/warningcontrol.h) has list of disabled warning for all CoreCLR projects many of them came from the desktop and do not fire on CoreCLR (like 4053 4056 4100 etc) some of them need small fixed (4430) so the task is to:
1. delete all warnings that do not fire;
2. delete warning that needs simple small fixes (and fix them);</Description>
    <Title_Description>Clean the list of disabled warnings for CoreCLR [\src\inc\warningcontrol.h](https://github.com/dotnet/coreclr/blob/master/src/inc/warningcontrol.h) has list of disabled warning for all CoreCLR projects many of them came from the desktop and do not fire on CoreCLR (like 4053 4056 4100 etc) some of them need small fixed (4430) so the task is to:
1. delete all warnings that do not fire;
2. delete warning that needs simple small fixes (and fix them);</Title_Description>
    <Label>Hackathon</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>25/05/2018 6:07:39 PM +00:00</CreatedAt>
    <ClosedAt>4/03/2019 6:40:48 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18123</IssueLabelID>
    <Title>CoreCLR failed when build in conformance mode (/permissive-)  </Title>
    <Description>I build CoreCLR with Visual studio 15.7.1 in conformance mode (/permissive-) on Windows it failed with error C4596 The changes involved by
https://github.com/dotnet/coreclr/commit/b39a5b2cfad4620ae23cda84186a36ffb463cd5a#diff-7844842ffbae44d891b5170d2a229d4bR1590

Could you help remove the redundant "LinearScan::" on BuildRMWUses. The compiler complains about this in conformance mode (/permissive-)

Failures:
d:\coreclr\src\src\jit\lsra.h(1590): error C4596: 'BuildRMWUses': illegal qualified name in member declaration </Description>
    <Title_Description>CoreCLR failed when build in conformance mode (/permissive-)   I build CoreCLR with Visual studio 15.7.1 in conformance mode (/permissive-) on Windows it failed with error C4596 The changes involved by
https://github.com/dotnet/coreclr/commit/b39a5b2cfad4620ae23cda84186a36ffb463cd5a#diff-7844842ffbae44d891b5170d2a229d4bR1590

Could you help remove the redundant "LinearScan::" on BuildRMWUses. The compiler complains about this in conformance mode (/permissive-)

Failures:
d:\coreclr\src\src\jit\lsra.h(1590): error C4596: 'BuildRMWUses': illegal qualified name in member declaration </Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>25/05/2018 6:03:25 AM +00:00</CreatedAt>
    <ClosedAt>4/06/2018 5:10:31 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18121</IssueLabelID>
    <Title>delete unused variables from jit</Title>
    <Description>Delete unused variables after the `legacy_backend` death.</Description>
    <Title_Description>delete unused variables from jit Delete unused variables after the `legacy_backend` death.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>24/05/2018 11:07:47 PM +00:00</CreatedAt>
    <ClosedAt>25/05/2018 10:02:21 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18117</IssueLabelID>
    <Title>[JitStress] Crossgen JIT/Regression/JitBlue/GitHub_18056/Bool_And_Op_cs_do Jit Assert</Title>
    <Description>Hit this during crossgen in [ 
Ubuntu arm Cross Checked r2r_jitstress1 Build and Test](https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_ubuntu_r2r_jitstress1_tst_prtest/6/consoleText) when testing #18053
```
FAILED   - JIT/Regression/JitBlue/GitHub_18056/Bool_And_Op_cs_do/Bool_And_Op_cs_do.sh
               BEGIN EXECUTION
               in takeLock
               /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_r2r_jitstress1_tst_prtest/bin/tests/Linux.arm.Checked/Tests/Core_Root/crossgen /Platform_Assemblies_Paths /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_r2r_jitstress1_tst_prtest/bin/tests/Linux.arm.Checked/Tests/Core_Root:/ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_r2r_jitstress1_tst_prtest/bin/tests/Linux.arm.Checked/JIT/Regression/JitBlue/GitHub_18056/Bool_And_Op_cs_do/IL:/ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_r2r_jitstress1_tst_prtest/bin/tests/Linux.arm.Checked/JIT/Regression/JitBlue/GitHub_18056/Bool_And_Op_cs_do /in Bool_And_Op_cs_do.org /out Bool_And_Op_cs_do.exe
               
               Assert failure(PID 28502 [0x00006f56] Thread: 28502 [0x6f56]): Assertion failed 'blockPred-&gt;bbTraversalStamp == curTraversalStamp' in 'testout1:Sub_Funclet_411():int' (IL size 826)
               
                   File: /mnt/j/workspace/dotnet_coreclr/master/arm_cross_checked_ubuntu_prtest/src/jit/flowgraph.cpp Line: 20738
                   Image: /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_r2r_jitstress1_tst_prtest/bin/tests/Linux.arm.Checked/Tests/Core_Root/crossgen
               
               Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0
               Copyright (c) Microsoft Corporation.  All rights reserved.
               
               ./Bool_And_Op_cs_do.sh: line 156: 28502 Aborted                 $_DebuggerFullPath "$CORE_ROOT/crossgen" /Platform_Assemblies_Paths $CORE_ROOT:$PWD/IL:$PWD /in Bool_And_Op_cs_do.org /out Bool_And_Op_cs_do.exe
               Crossgen failed with exitcode: 134
               in ReleaseLock

```</Description>
    <Title_Description>[JitStress] Crossgen JIT/Regression/JitBlue/GitHub_18056/Bool_And_Op_cs_do Jit Assert Hit this during crossgen in [ 
Ubuntu arm Cross Checked r2r_jitstress1 Build and Test](https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_ubuntu_r2r_jitstress1_tst_prtest/6/consoleText) when testing #18053
```
FAILED   - JIT/Regression/JitBlue/GitHub_18056/Bool_And_Op_cs_do/Bool_And_Op_cs_do.sh
               BEGIN EXECUTION
               in takeLock
               /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_r2r_jitstress1_tst_prtest/bin/tests/Linux.arm.Checked/Tests/Core_Root/crossgen /Platform_Assemblies_Paths /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_r2r_jitstress1_tst_prtest/bin/tests/Linux.arm.Checked/Tests/Core_Root:/ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_r2r_jitstress1_tst_prtest/bin/tests/Linux.arm.Checked/JIT/Regression/JitBlue/GitHub_18056/Bool_And_Op_cs_do/IL:/ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_r2r_jitstress1_tst_prtest/bin/tests/Linux.arm.Checked/JIT/Regression/JitBlue/GitHub_18056/Bool_And_Op_cs_do /in Bool_And_Op_cs_do.org /out Bool_And_Op_cs_do.exe
               
               Assert failure(PID 28502 [0x00006f56] Thread: 28502 [0x6f56]): Assertion failed 'blockPred-&gt;bbTraversalStamp == curTraversalStamp' in 'testout1:Sub_Funclet_411():int' (IL size 826)
               
                   File: /mnt/j/workspace/dotnet_coreclr/master/arm_cross_checked_ubuntu_prtest/src/jit/flowgraph.cpp Line: 20738
                   Image: /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_r2r_jitstress1_tst_prtest/bin/tests/Linux.arm.Checked/Tests/Core_Root/crossgen
               
               Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0
               Copyright (c) Microsoft Corporation.  All rights reserved.
               
               ./Bool_And_Op_cs_do.sh: line 156: 28502 Aborted                 $_DebuggerFullPath "$CORE_ROOT/crossgen" /Platform_Assemblies_Paths $CORE_ROOT:$PWD/IL:$PWD /in Bool_And_Op_cs_do.org /out Bool_And_Op_cs_do.exe
               Crossgen failed with exitcode: 134
               in ReleaseLock

```</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>echesakovMSFT</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18114</IssueLabelID>
    <Title>Collecting StackTrace performance</Title>
    <Description>Why can't I collect stack information?
Currently in the slow tracking details or error details the stack information corresponding to the .NET Core code method cannot be consulted.

The root cause is the poor performance of collecting StackTrace on the .NET Core 2.0 platform. After evaluation each execution of StackTrace will result in millisecond CPU usage.

Technically speaking we can collect the stack but due to performance issues releasing this feature will result in serious impact on user application performance so at present we have not yet opened the stack.

To solve this problem you must expect the .NET Core kernel team to develop a more efficient StackTrace approach.</Description>
    <Title_Description>Collecting StackTrace performance Why can't I collect stack information?
Currently in the slow tracking details or error details the stack information corresponding to the .NET Core code method cannot be consulted.

The root cause is the poor performance of collecting StackTrace on the .NET Core 2.0 platform. After evaluation each execution of StackTrace will result in millisecond CPU usage.

Technically speaking we can collect the stack but due to performance issues releasing this feature will result in serious impact on user application performance so at present we have not yet opened the stack.

To solve this problem you must expect the .NET Core kernel team to develop a more efficient StackTrace approach.</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>24/05/2018 9:26:56 AM +00:00</CreatedAt>
    <ClosedAt>24/05/2018 5:52:14 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18113</IssueLabelID>
    <Title>dynamic keyword takes too much time.</Title>
    <Description>We found that ```dynamic``` keyword causes the significant delay at the first execution of a  method call. 
```
private static void Test2()
{
    dynamic dnClass = new Class1();
    for (int i = 0; i &lt;= 5; i++)
    {
        try
        {
            Stopwatch sw = new Stopwatch();
            sw.Start();

            dnClass.Foo();

            sw.Stop();
            Log.Info("Sample" "Class1.Foo - " + sw.ElapsedMilliseconds.ToString() + "ms");
        }
        catch (MissingMethodException ex)
        {
            Console.WriteLine("Can't find Foo() - " + ex.ToString());
        }
    }
}
```
at the device with armel architecture we got the following result

Test2(57) &gt; 1429ms
Test2(57) &gt; 8ms
Test2(57) &gt; 8ms
Test2(57) &gt; 10ms
Test2(57) &gt; 8ms
Test2(57) &gt; 8ms

I added the simplest variant of this program (see attach) and got the following results on Ubuntu 16.04 x64 cpu MHz: 3801.226 with the latest verions of coreclr and corefx

Debug version
with ```dynamic``` 
```
Sample 4124 ms
Sample 17 ms
Sample 17 ms
Sample 17 ms
Sample 17 ms
Sample 17 ms
```
without ```dynamic```
```
Sample 39 ms
Sample 17 ms
Sample 17 ms
Sample 17 ms
Sample 18 ms
Sample 17 ms
```

Release version
with ```dynamic```
```
Sample 337 ms
Sample 2 ms
Sample 3 ms
Sample 2 ms
Sample 2 ms
Sample 2 ms
```
without ```dynamic```
```
Sample 3 ms
Sample 2 ms
Sample 2 ms
Sample 3 ms
Sample 3 ms
Sample 2 ms
```

[Program.cs.zip](https://github.com/dotnet/coreclr/files/2034454/Program.cs.zip)

</Description>
    <Title_Description>dynamic keyword takes too much time. We found that ```dynamic``` keyword causes the significant delay at the first execution of a  method call. 
```
private static void Test2()
{
    dynamic dnClass = new Class1();
    for (int i = 0; i &lt;= 5; i++)
    {
        try
        {
            Stopwatch sw = new Stopwatch();
            sw.Start();

            dnClass.Foo();

            sw.Stop();
            Log.Info("Sample" "Class1.Foo - " + sw.ElapsedMilliseconds.ToString() + "ms");
        }
        catch (MissingMethodException ex)
        {
            Console.WriteLine("Can't find Foo() - " + ex.ToString());
        }
    }
}
```
at the device with armel architecture we got the following result

Test2(57) &gt; 1429ms
Test2(57) &gt; 8ms
Test2(57) &gt; 8ms
Test2(57) &gt; 10ms
Test2(57) &gt; 8ms
Test2(57) &gt; 8ms

I added the simplest variant of this program (see attach) and got the following results on Ubuntu 16.04 x64 cpu MHz: 3801.226 with the latest verions of coreclr and corefx

Debug version
with ```dynamic``` 
```
Sample 4124 ms
Sample 17 ms
Sample 17 ms
Sample 17 ms
Sample 17 ms
Sample 17 ms
```
without ```dynamic```
```
Sample 39 ms
Sample 17 ms
Sample 17 ms
Sample 17 ms
Sample 18 ms
Sample 17 ms
```

Release version
with ```dynamic```
```
Sample 337 ms
Sample 2 ms
Sample 3 ms
Sample 2 ms
Sample 2 ms
Sample 2 ms
```
without ```dynamic```
```
Sample 3 ms
Sample 2 ms
Sample 2 ms
Sample 3 ms
Sample 3 ms
Sample 2 ms
```

[Program.cs.zip](https://github.com/dotnet/coreclr/files/2034454/Program.cs.zip)

</Title_Description>
    <Label>tenet-performance</Label>
    <Assignee>janvorli</Assignee>
    <CreatedAt>24/05/2018 8:51:16 AM +00:00</CreatedAt>
    <ClosedAt>30/05/2018 5:17:32 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18112</IssueLabelID>
    <Title>Add additional preds checks to flowgraph.</Title>
    <Description>
    </Description>
    <Title_Description>Add additional preds checks to flowgraph. </Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>24/05/2018 7:38:27 AM +00:00</CreatedAt>
    <ClosedAt>1/06/2018 7:05:12 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18111</IssueLabelID>
    <Title>Add managed views of the EE datastructures like MethodTable </Title>
    <Description>CoreRT CoreLib does this already. Related https://github.com/dotnet/coreclr/issues/9474.

It can be used for performance optimizations like https://github.com/dotnet/coreclr/pull/18101#discussion_r190346937</Description>
    <Title_Description>Add managed views of the EE datastructures like MethodTable  CoreRT CoreLib does this already. Related https://github.com/dotnet/coreclr/issues/9474.

It can be used for performance optimizations like https://github.com/dotnet/coreclr/pull/18101#discussion_r190346937</Title_Description>
    <Label>area-Meta-corelib</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>24/05/2018 7:23:14 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18106</IssueLabelID>
    <Title>[Ignore] Testing some issue editing automation.</Title>
    <Description>Please ignore this issue. I'm using it to test some issue editing  automation. It will be deleted.

   category:somecategory1
 theme:sometheme1
     skill-level:beginner
  cost:medium</Description>
    <Title_Description>[Ignore] Testing some issue editing automation. Please ignore this issue. I'm using it to test some issue editing  automation. It will be deleted.

   category:somecategory1
 theme:sometheme1
     skill-level:beginner
  cost:medium</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>erozenfeld</Assignee>
    <CreatedAt>23/05/2018 11:52:41 PM +00:00</CreatedAt>
    <ClosedAt>11/08/2018 7:21:43 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18104</IssueLabelID>
    <Title>[Arm64] Crypto assertion failure</Title>
    <Description>Recent regression 
JIT/HardwareIntrinsics/Arm64/Crypto/Crypto.sh
```
corerun Crypto.exe
System.Runtime.Intrinsics.Arm.Arm64.Aes.IsSupported = True
System.Runtime.Intrinsics.Arm.Arm64.Sha1.IsSupported = True
System.Runtime.Intrinsics.Arm.Arm64.Sha2.IsSupported = True
Running tests
testCryptoOp&lt;Byte Vector128`1 &gt;Aes: Check Passed
testCryptoOp&lt;Byte Vector128`1 &gt;Aes: Check Passed
testCryptoOp&lt;Byte Vector128`1 &gt;Aes: Check Passed
testCryptoOp&lt;Byte Vector128`1 &gt;Aes: Check Passed

Assert failure(PID 12709 [0x000031a5] Thread: 12709 [0x31a5]): Assertion failed 'compiler-&gt;compFloatingPointUsed || ((mask &amp;amp; RBM_FLT_CALLEE_SAVED) == 0)' in 'Arm64intrisicsTest.Program:TestSha1()' (IL size 437)

    File: src/jit/lsrabuild.cpp Line: 572
```

Failing on 6185b9af8
Passing on fa3e66ea42

@dotnet/arm64-contrib @CarolEidt </Description>
    <Title_Description>[Arm64] Crypto assertion failure Recent regression 
JIT/HardwareIntrinsics/Arm64/Crypto/Crypto.sh
```
corerun Crypto.exe
System.Runtime.Intrinsics.Arm.Arm64.Aes.IsSupported = True
System.Runtime.Intrinsics.Arm.Arm64.Sha1.IsSupported = True
System.Runtime.Intrinsics.Arm.Arm64.Sha2.IsSupported = True
Running tests
testCryptoOp&lt;Byte Vector128`1 &gt;Aes: Check Passed
testCryptoOp&lt;Byte Vector128`1 &gt;Aes: Check Passed
testCryptoOp&lt;Byte Vector128`1 &gt;Aes: Check Passed
testCryptoOp&lt;Byte Vector128`1 &gt;Aes: Check Passed

Assert failure(PID 12709 [0x000031a5] Thread: 12709 [0x31a5]): Assertion failed 'compiler-&gt;compFloatingPointUsed || ((mask &amp;amp; RBM_FLT_CALLEE_SAVED) == 0)' in 'Arm64intrisicsTest.Program:TestSha1()' (IL size 437)

    File: src/jit/lsrabuild.cpp Line: 572
```

Failing on 6185b9af8
Passing on fa3e66ea42

@dotnet/arm64-contrib @CarolEidt </Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>CarolEidt</Assignee>
    <CreatedAt>23/05/2018 10:16:32 PM +00:00</CreatedAt>
    <ClosedAt>1/06/2018 9:06:20 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18102</IssueLabelID>
    <Title>sharing SerializationInfo for corert and coreclr</Title>
    <Description>I tested locally on corert and on corefx and ran tests to make sure there is nothing is breaking.

I did multiple commits so that it's easier to review. Overall there was not much implementation difference more so it was code styles or renamings in the diff than anything else.

I had to add CORECLR condition in two places only.

I added `_requireSameTokenInPartialTrust` as it was missing in one of the repos. But when you trace its usages in this class you see it doesn't really do much. So perhaps if agreed I can remove it instead.

There is a noticeable summary comment on top of `UpdateValue` method and seems like the api is only public for corefx access. Let me know if we would like to keep it public. It was public in both repos anyway. I did however end up merging the comment contents for this method.

cc: @jkotas @danmosemsft </Description>
    <Title_Description>sharing SerializationInfo for corert and coreclr I tested locally on corert and on corefx and ran tests to make sure there is nothing is breaking.

I did multiple commits so that it's easier to review. Overall there was not much implementation difference more so it was code styles or renamings in the diff than anything else.

I had to add CORECLR condition in two places only.

I added `_requireSameTokenInPartialTrust` as it was missing in one of the repos. But when you trace its usages in this class you see it doesn't really do much. So perhaps if agreed I can remove it instead.

There is a noticeable summary comment on top of `UpdateValue` method and seems like the api is only public for corefx access. Let me know if we would like to keep it public. It was public in both repos anyway. I did however end up merging the comment contents for this method.

cc: @jkotas @danmosemsft </Title_Description>
    <Label>area-System.Runtime</Label>
    <Assignee>maryamariyan</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18100</IssueLabelID>
    <Title>[JIT] Allow the developer to instruct the JIT to do not reorder goto based blocks.</Title>
    <Description>When manually rearranging blocks you end up in situations where you know best what the arrangement is. I hit one of those cases when optimizing memory diffing. Example: https://youtu.be/DD3w66Ff8Ms?t=20859

Give the JIT a hint could help. 

```csharp
Jit.DoNotReorder()
``` 
or
```csharp
[JitAttribute(JitMethod.DoNotReorder)]
```

Details on all the tricks can be found at: https://www.youtube.com/watch?time_continue=18053&amp;v=DD3w66Ff8Ms

cc @AndyAyersMS </Description>
    <Title_Description>[JIT] Allow the developer to instruct the JIT to do not reorder goto based blocks. When manually rearranging blocks you end up in situations where you know best what the arrangement is. I hit one of those cases when optimizing memory diffing. Example: https://youtu.be/DD3w66Ff8Ms?t=20859

Give the JIT a hint could help. 

```csharp
Jit.DoNotReorder()
``` 
or
```csharp
[JitAttribute(JitMethod.DoNotReorder)]
```

Details on all the tricks can be found at: https://www.youtube.com/watch?time_continue=18053&amp;v=DD3w66Ff8Ms

cc @AndyAyersMS </Title_Description>
    <Label>Design Discussion</Label>
    <Assignee>AndyAyersMS</Assignee>
    <CreatedAt>23/05/2018 4:25:35 PM +00:00</CreatedAt>
    <ClosedAt>24/05/2018 8:09:54 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18098</IssueLabelID>
    <Title>Cancel CTS immediately if delay is zero.</Title>
    <Description>The intended behaviour on specifying a delay of zero is that the CancellationTokenSource is cancelled immediately - before this change it would depend on the scheduling of the timer callback which could lead to seeing a non-cancelled token. Now it marks itself as cancelled immediately without invoking any callbacks (as this method is called only from within the constructor of the object before any callbacks could have been registered.

I can't find any tests for this code so I'm not in a position to update those apologies if I've missed them.</Description>
    <Title_Description>Cancel CTS immediately if delay is zero. The intended behaviour on specifying a delay of zero is that the CancellationTokenSource is cancelled immediately - before this change it would depend on the scheduling of the timer callback which could lead to seeing a non-cancelled token. Now it marks itself as cancelled immediately without invoking any callbacks (as this method is called only from within the constructor of the object before any callbacks could have been registered.

I can't find any tests for this code so I'm not in a position to update those apologies if I've missed them.</Title_Description>
    <Label>
    </Label>
    <Assignee>stephentoub</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18097</IssueLabelID>
    <Title>Which dependencies are runtime dependencies and which ones are build dependencies?</Title>
    <Description>I have a question about the dependencies listed in [the coreclr instructions](https://github.com/dotnet/coreclr/blob/release/2.1/Documentation/building/linux-instructions.md) and [the corefx instructions](https://github.com/dotnet/corefx/blob/master/Documentation/building/unix-instructions.md).
Which dependencies are for runtime and which ones are for build-time only?

Also if I install the SDK and run ldd on all the .so files included and all the dependencies resolve correctly does that mean I have everything I need for runtime installed on the box?
In other words are there any DllImports in the C# for shared libraries other than the ones included in the SDK?</Description>
    <Title_Description>Which dependencies are runtime dependencies and which ones are build dependencies? I have a question about the dependencies listed in [the coreclr instructions](https://github.com/dotnet/coreclr/blob/release/2.1/Documentation/building/linux-instructions.md) and [the corefx instructions](https://github.com/dotnet/corefx/blob/master/Documentation/building/unix-instructions.md).
Which dependencies are for runtime and which ones are for build-time only?

Also if I install the SDK and run ldd on all the .so files included and all the dependencies resolve correctly does that mean I have everything I need for runtime installed on the box?
In other words are there any DllImports in the C# for shared libraries other than the ones included in the SDK?</Title_Description>
    <Label>area-PAL</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>23/05/2018 2:38:14 PM +00:00</CreatedAt>
    <ClosedAt>23/05/2018 9:45:02 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18093</IssueLabelID>
    <Title>Fix parallel spmi return code.</Title>
    <Description>Sort and merge children return codes for the parallel spmi runs.
Found after #17997; our internal system reports exit code 0x3 (missing values) even if there are actual errors (0x1).

cc @dotnet/jit-contrib </Description>
    <Title_Description>Fix parallel spmi return code. Sort and merge children return codes for the parallel spmi runs.
Found after #17997; our internal system reports exit code 0x3 (missing values) even if there are actual errors (0x1).

cc @dotnet/jit-contrib </Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>23/05/2018 1:36:16 AM +00:00</CreatedAt>
    <ClosedAt>23/05/2018 5:23:19 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18091</IssueLabelID>
    <Title>Unexplained ref count sorting for ARM only</Title>
    <Description>The following code in Compiler::WtdRefCntCmp() (and also in the currently-unused Compiler::RefCntCmp) is only for non-ARM targets. This seems strange and unexplained. Should the `#ifndef` be removed to make it all platform? This causes exactly one diff in ARM altjit asm diffs over the frameworks a case with a huge function where a float variable ends up on the stack instead of in registers causing loads and stores where they didn't exist previously.

Or should the code be removed entirely because it is not applicable or desirable with the current system?

```
#ifndef _TARGET_ARM_
    // ARM-TODO: this was disabled for ARM under !FEATURE_FP_REGALLOC; it was probably a left-over from
    // legacy backend. It should be enabled and verified.

    /* Force integer candidates to sort above float candidates */

    bool isFloat1 = isFloatRegType(dsc1-&gt;lvType);
    bool isFloat2 = isFloatRegType(dsc2-&gt;lvType);

    if (isFloat1 != isFloat2)
    {
        if (weight2 &amp;&amp; isFloat1)
        {
            return +1;
        }
        if (weight1 &amp;&amp; isFloat2)
        {
            return -1;
        }
    }
```
category:cq
theme:basic-cq
skill-level:intermediate
cost:small</Description>
    <Title_Description>Unexplained ref count sorting for ARM only The following code in Compiler::WtdRefCntCmp() (and also in the currently-unused Compiler::RefCntCmp) is only for non-ARM targets. This seems strange and unexplained. Should the `#ifndef` be removed to make it all platform? This causes exactly one diff in ARM altjit asm diffs over the frameworks a case with a huge function where a float variable ends up on the stack instead of in registers causing loads and stores where they didn't exist previously.

Or should the code be removed entirely because it is not applicable or desirable with the current system?

```
#ifndef _TARGET_ARM_
    // ARM-TODO: this was disabled for ARM under !FEATURE_FP_REGALLOC; it was probably a left-over from
    // legacy backend. It should be enabled and verified.

    /* Force integer candidates to sort above float candidates */

    bool isFloat1 = isFloatRegType(dsc1-&gt;lvType);
    bool isFloat2 = isFloatRegType(dsc2-&gt;lvType);

    if (isFloat1 != isFloat2)
    {
        if (weight2 &amp;&amp; isFloat1)
        {
            return +1;
        }
        if (weight1 &amp;&amp; isFloat2)
        {
            return -1;
        }
    }
```
category:cq
theme:basic-cq
skill-level:intermediate
cost:small</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>22/05/2018 10:44:27 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18088</IssueLabelID>
    <Title>Add -Wthread-safety to CoreCLR build</Title>
    <Description>This found a real issue for us at least on BSD with Clang3.9 and may be more useful as headers are updated. It has no effect on the generated binaries so probably reasonable for us to enable for CoreCLR.

See https://github.com/dotnet/corefx/pull/29850
https://clang.llvm.org/docs/ThreadSafetyAnalysis.html

@janvorli </Description>
    <Title_Description>Add -Wthread-safety to CoreCLR build This found a real issue for us at least on BSD with Clang3.9 and may be more useful as headers are updated. It has no effect on the generated binaries so probably reasonable for us to enable for CoreCLR.

See https://github.com/dotnet/corefx/pull/29850
https://clang.llvm.org/docs/ThreadSafetyAnalysis.html

@janvorli </Title_Description>
    <Label>Hackathon</Label>
    <Assignee>janvorli</Assignee>
    <CreatedAt>22/05/2018 9:37:03 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18084</IssueLabelID>
    <Title>Basic block moved out of the loop flow after JIT optimization</Title>
    <Description>Sometimes JITter moves basic block away from the loop giving two extra `JMP` insns for no reason. Could provide significant performance hit in tight loops.
Is likely related to rearrangement of the basic blocks within the loop.
The issue does not appear when:
- the generic type argument is `ushort`;
- or the line with `while` is commented out in the source code below (effectively leaving no loop);
- or the line with `throw new NotSupportedException()` is commented out.

Source code for repro:

```
        [MethodImpl(MethodImplOptions.AggressiveInlining)] 
        static void Do&lt;TComparableKeyPart&gt;()
            where TComparableKeyPart : struct
        {
            /*const*/ ulong KeyPartsInVector = (ulong)(Unsafe.SizeOf&lt;Vector128&lt;TComparableKeyPart&gt;&gt;() / Unsafe.SizeOf&lt;TComparableKeyPart&gt;());

            ulong iterationsLeft = KeyPartsInVector;
            while (iterationsLeft &gt; 0)
            {
                switch (KeyPartsInVector)
                {
                    default: throw new NotSupportedException();
                    case 02: Console.WriteLine("2 x {0}" typeof(TComparableKeyPart)); break;
                    case 04: Console.WriteLine("4 x {0}" typeof(TComparableKeyPart)); break;
                    case 08: Console.WriteLine("8 x {0}" typeof(TComparableKeyPart)); break;
                }

                --iterationsLeft;
            }
        }

        static void Main(string[] args)
        {
            Do&lt;ulong&gt;();
        }
```

Asm code I've got with `AggressiveInlining` (the issue is still there with `NoInlining`):

```
--- ..\Program.cs -----
            Do&lt;ulong&gt;();
000007FE71D817C0  push        rdi  
000007FE71D817C1  push        rsi  
000007FE71D817C2  sub         rsp38h  
000007FE71D817C6  mov         esi2  
000007FE71D817CB  jmp         000007FE71D817DC       ==========&gt; go away to #1
000007FE71D817CD  dec         rsi                    &lt;========== continue from here
000007FE71D817D0  test        rsirsi  
000007FE71D817D3  jne         000007FE71D817DC  
000007FE71D817D5  add         rsp38h  
000007FE71D817D9  pop         rsi  
000007FE71D817DA  pop         rdi  
000007FE71D817DB  ret  
000007FE71D817DC  mov         rdiqword ptr [12363068h]  &lt;======== #1
000007FE71D817E4  mov         rcx7FEC8881960h  
000007FE71D817EE  call        000007FED1807F20  
000007FE71D817F3  mov         rdxrax  
000007FE71D817F6  mov         rcxrdi  
000007FE71D817F9  call        000007FE71D816F0  
000007FE71D817FE  jmp         000007FE71D817CD          =========&gt; go back and continue 
--- No source file -------------------------------------------------------------
```
category:cq
theme:basic-cq
skill-level:intermediate
cost:small</Description>
    <Title_Description>Basic block moved out of the loop flow after JIT optimization Sometimes JITter moves basic block away from the loop giving two extra `JMP` insns for no reason. Could provide significant performance hit in tight loops.
Is likely related to rearrangement of the basic blocks within the loop.
The issue does not appear when:
- the generic type argument is `ushort`;
- or the line with `while` is commented out in the source code below (effectively leaving no loop);
- or the line with `throw new NotSupportedException()` is commented out.

Source code for repro:

```
        [MethodImpl(MethodImplOptions.AggressiveInlining)] 
        static void Do&lt;TComparableKeyPart&gt;()
            where TComparableKeyPart : struct
        {
            /*const*/ ulong KeyPartsInVector = (ulong)(Unsafe.SizeOf&lt;Vector128&lt;TComparableKeyPart&gt;&gt;() / Unsafe.SizeOf&lt;TComparableKeyPart&gt;());

            ulong iterationsLeft = KeyPartsInVector;
            while (iterationsLeft &gt; 0)
            {
                switch (KeyPartsInVector)
                {
                    default: throw new NotSupportedException();
                    case 02: Console.WriteLine("2 x {0}" typeof(TComparableKeyPart)); break;
                    case 04: Console.WriteLine("4 x {0}" typeof(TComparableKeyPart)); break;
                    case 08: Console.WriteLine("8 x {0}" typeof(TComparableKeyPart)); break;
                }

                --iterationsLeft;
            }
        }

        static void Main(string[] args)
        {
            Do&lt;ulong&gt;();
        }
```

Asm code I've got with `AggressiveInlining` (the issue is still there with `NoInlining`):

```
--- ..\Program.cs -----
            Do&lt;ulong&gt;();
000007FE71D817C0  push        rdi  
000007FE71D817C1  push        rsi  
000007FE71D817C2  sub         rsp38h  
000007FE71D817C6  mov         esi2  
000007FE71D817CB  jmp         000007FE71D817DC       ==========&gt; go away to #1
000007FE71D817CD  dec         rsi                    &lt;========== continue from here
000007FE71D817D0  test        rsirsi  
000007FE71D817D3  jne         000007FE71D817DC  
000007FE71D817D5  add         rsp38h  
000007FE71D817D9  pop         rsi  
000007FE71D817DA  pop         rdi  
000007FE71D817DB  ret  
000007FE71D817DC  mov         rdiqword ptr [12363068h]  &lt;======== #1
000007FE71D817E4  mov         rcx7FEC8881960h  
000007FE71D817EE  call        000007FED1807F20  
000007FE71D817F3  mov         rdxrax  
000007FE71D817F6  mov         rcxrdi  
000007FE71D817F9  call        000007FE71D816F0  
000007FE71D817FE  jmp         000007FE71D817CD          =========&gt; go back and continue 
--- No source file -------------------------------------------------------------
```
category:cq
theme:basic-cq
skill-level:intermediate
cost:small</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>22/05/2018 11:59:24 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18082</IssueLabelID>
    <Title>Refactor fgDebugCheckBBlist</Title>
    <Description>No Spmi diffs.

This is a preparation PR before the fix for #18056 .</Description>
    <Title_Description>Refactor fgDebugCheckBBlist No Spmi diffs.

This is a preparation PR before the fix for #18056 .</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>22/05/2018 5:49:22 AM +00:00</CreatedAt>
    <ClosedAt>23/05/2018 8:52:16 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18081</IssueLabelID>
    <Title>Implement the HWIntrinsics for FMA</Title>
    <Description>
    </Description>
    <Title_Description>Implement the HWIntrinsics for FMA </Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>tannergooding</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18076</IssueLabelID>
    <Title>Build failure: Link</Title>
    <Description>Opened on behalf of @RussKeldorph

Warnings: 6
Status Message: failed

Build : Master - 20180518.01 (Product Build)
Failing configurations:
- Linux
  - PortableCrossBuild-Checked-arm
  - PortableCrossBuild-Debug-arm64
  - PortableCrossBuild-Release-arm64
  - PortableCrossBuild-Release-arm
  - PortableCrossBuild-Debug-arm
  - Debug-x64
  - Release-x64
  - Checked-x64
  - PortableCrossBuild-Checked-arm64
- Linux-musl
  - Release-x64
  - Checked-x64
  - Debug-x64
- RedHat6
  - Checked-x64
  - Release-x64
  - Debug-x64
- OSX
  - PortableBuild-Release-x64
  - PortableBuild-Debug-x64
  - PortableBuild-Checked-x64
[Mission Control Build Info](https://mc.dot.net/#/product/netcore/master/source/official~2Fcoreclr~2Fmaster~2F/type/build~2Fproduct~2F/build/20180518.01/workItem/Orchestration/analysis/external/Link)
</Description>
    <Title_Description>Build failure: Link Opened on behalf of @RussKeldorph

Warnings: 6
Status Message: failed

Build : Master - 20180518.01 (Product Build)
Failing configurations:
- Linux
  - PortableCrossBuild-Checked-arm
  - PortableCrossBuild-Debug-arm64
  - PortableCrossBuild-Release-arm64
  - PortableCrossBuild-Release-arm
  - PortableCrossBuild-Debug-arm
  - Debug-x64
  - Release-x64
  - Checked-x64
  - PortableCrossBuild-Checked-arm64
- Linux-musl
  - Release-x64
  - Checked-x64
  - Debug-x64
- RedHat6
  - Checked-x64
  - Release-x64
  - Debug-x64
- OSX
  - PortableBuild-Release-x64
  - PortableBuild-Debug-x64
  - PortableBuild-Checked-x64
[Mission Control Build Info](https://mc.dot.net/#/product/netcore/master/source/official~2Fcoreclr~2Fmaster~2F/type/build~2Fproduct~2F/build/20180518.01/workItem/Orchestration/analysis/external/Link)
</Title_Description>
    <Label>area-Tracing</Label>
    <Assignee>brianrob</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18071</IssueLabelID>
    <Title>coreclr.lib</Title>
    <Description>Copying from Dotnet: https://github.com/Microsoft/dotnet/issues/753


daoqiang commented 9 hours ago • edited  
I want to add coreclr to my project. I must introduce it in a static way. What should I do?
There can be no dynamic reference，thank you</Description>
    <Title_Description>coreclr.lib Copying from Dotnet: https://github.com/Microsoft/dotnet/issues/753


daoqiang commented 9 hours ago • edited  
I want to add coreclr to my project. I must introduce it in a static way. What should I do?
There can be no dynamic reference，thank you</Title_Description>
    <Label>area-AssemblyLoader</Label>
    <Assignee>jeffschwMSFT</Assignee>
    <CreatedAt>21/05/2018 5:45:54 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18069</IssueLabelID>
    <Title>Sub-optimal codegen when using Sse.StaticCast&lt;TFromTTo&gt;() with non-VEX encoded HW intrinsics</Title>
    <Description>Below is the source code (basically this is an example of partial vector update code trimmed down for repro):

            // Setup constants
            Vector128&lt;ushort&gt; valuesIncrement = Sse2.SetAllVector128((ushort)0x0001U); // &lt;== no. 1
            Vector128&lt;ushort&gt; opCookie = Sse.StaticCast&lt;ulong ushort&gt;( //&lt;== no. 2
                Sse2.SetVector128(
                    0x0001_0002_0003_0004UL
                    0x0005_0006_0007_0008UL));

            // Setup initial condition
            Vector128&lt;ushort&gt; values = Sse2.SetVector128(
                (ushort)0x1111U (ushort)0x2222U (ushort)0x3333U (ushort)0x4444U
                (ushort)0x5555U (ushort)0x6666U (ushort)0x7777U (ushort)0x8888U);

            // Simulate op
            Vector128&lt;ushort&gt; updateSelector = Sse2.SetAllVector128((ushort)0x0004U);
            Vector128&lt;ushort&gt; updateMask = Sse2.CompareEqual(updateSelector opCookie);
            Vector128&lt;ushort&gt; newValues = Sse2.AddSaturate(values valuesIncrement);

            // Generate codegen issue
            values =
                Sse.StaticCast&lt;byte ushort&gt;(
                    Sse41.BlendVariable(
                        Sse.StaticCast&lt;ushort byte&gt;(values)
                        Sse.StaticCast&lt;ushort byte&gt;(newValues)
                        Sse.StaticCast&lt;ushort byte&gt;(updateMask)));

            Console.WriteLine(values);

With  my i5-750 CPU (Nehalem uarch) which does not support VEX encoding I've got the following asm code with .NET Core 2.1 RC1 JITter (look for the `PBLENDVB` instruction down below):

```
&gt; 000007FE664F5D23  mov         ecx1  
&gt; 000007FE664F5D28  movd        xmm0ecx  
&gt; 000007FE664F5D2C  movaps      xmm1xmm0  
&gt; 000007FE664F5D2F  punpcklwd   xmm1xmm0  
&gt; 000007FE664F5D33  movaps      xmm0xmm1  
&gt; 000007FE664F5D36  pshufd      xmm0xmm00  
&gt;             Vector128&lt;ushort&gt; opCookie = Sse.StaticCast&lt;ulong ushort&gt;(
&gt;                 Sse2.SetVector128(
&gt;                     0x0001_0002_0003_0004UL
&gt;                     0x0005_0006_0007_0008UL));
&gt; 000007FE664F5D3B  mov         rcx1000200030004h  
&gt; 000007FE664F5D45  movq        xmm1rcx  
&gt; 000007FE664F5D4A  mov         rcx5000600070008h  
&gt; 000007FE664F5D54  movq        xmm2rcx  
&gt; 000007FE664F5D59  punpcklqdq  xmm2xmm1  
&gt; 000007FE664F5D5D  movaps      xmm1xmm2  
&gt; 
&gt;             // Setup initial condition
&gt;             Vector128&lt;ushort&gt; values = Sse2.SetVector128(
&gt;                 (ushort)0x1111U (ushort)0x2222U (ushort)0x3333U (ushort)0x4444U
&gt;                 (ushort)0x5555U (ushort)0x6666U (ushort)0x7777U (ushort)0x8888U);
&gt; 000007FE664F5D60  mov         ecx8888h  
&gt; 000007FE664F5D65  movd        xmm2ecx  
&gt; 000007FE664F5D69  mov         ecx7777h  
&gt; 000007FE664F5D6E  pinsrw      xmm2ecx1  
&gt; 000007FE664F5D73  mov         ecx6666h  
&gt; 000007FE664F5D78  pinsrw      xmm2ecx2  
&gt; 000007FE664F5D7D  mov         ecx5555h  
&gt; 000007FE664F5D82  pinsrw      xmm2ecx3  
&gt; 000007FE664F5D87  mov         ecx4444h  
&gt; 000007FE664F5D8C  pinsrw      xmm2ecx4  
&gt; 000007FE664F5D91  mov         ecx3333h  
&gt; 000007FE664F5D96  pinsrw      xmm2ecx5  
&gt; 000007FE664F5D9B  mov         ecx2222h  
&gt; 000007FE664F5DA0  pinsrw      xmm2ecx6  
&gt; 000007FE664F5DA5  mov         ecx1111h  
&gt; 000007FE664F5DAA  movaps      xmm6xmm2  
&gt; 000007FE664F5DAD  pinsrw      xmm6ecx7  
&gt; 
&gt;             // Simulate op
&gt;             Vector128&lt;ushort&gt; updateSelector = Sse2.SetAllVector128((ushort)0x0004U);
&gt; 000007FE664F5DB2  mov         ecx4  
&gt; 000007FE664F5DB7  movd        xmm2ecx  
&gt; 000007FE664F5DBB  movaps      xmm3xmm2  
&gt; 000007FE664F5DBE  punpcklwd   xmm3xmm2  
&gt; 000007FE664F5DC2  movaps      xmm2xmm3  
&gt; 000007FE664F5DC5  pshufd      xmm2xmm20  
&gt;             Vector128&lt;ushort&gt; updateMask = Sse2.CompareEqual(updateSelector opCookie);
&gt; 000007FE664F5DCA  pcmpeqw     xmm1xmm2  
&gt;             Vector128&lt;ushort&gt; newValues = Sse2.AddSaturate(values valuesIncrement);
&gt; 000007FE664F5DCE  paddusw     xmm0xmm6  
&gt; 
&gt;             // Generate codegen issue
&gt;             values =
&gt;                 Sse.StaticCast&lt;byte ushort&gt;(
&gt;                     Sse41.BlendVariable(
&gt;                         Sse.StaticCast&lt;ushort byte&gt;(values)
&gt;                         Sse.StaticCast&lt;ushort byte&gt;(newValues)
&gt;                         Sse.StaticCast&lt;ushort byte&gt;(updateMask)));
&gt; 000007FE664F5DD2  movups      xmmword ptr [rbp-4D0h]xmm0  
&gt; 000007FE664F5DD9  movaps      xmm0xmm1  
&gt; 000007FE664F5DDC  movups      xmm1xmmword ptr [rbp-4D0h]  
&gt; 000007FE664F5DE3  movaps      xmm2xmm6  
&gt; 000007FE664F5DE6  pblendvb    xmm2xmm1xmm0  &lt;===========================
&gt; 000007FE664F5DEB  movaps      xmm6xmm2  
&gt; 
&gt;             Console.WriteLine(values);
&gt; 000007FE664F5DEE  mov         rcx7FE664E6750h  
&gt; 000007FE664F5DF8  call        000007FEC5FB1940  
&gt; 000007FE664F5DFD  mov         rcxrax  
&gt; 000007FE664F5E00  movups      xmmword ptr [rcx+8]xmm6  
&gt; 000007FE664F5E04  call        000007FE664F3088

```
There are lots of `MOVxPS` before `PBLENDVB` for which I can't see any purpose some spilling the register's content on stack and then loading it back. `Sse41.BlendVariable()` is not the only HW intrinsic which displays the issue when input vectors are typecasted before being set as parameters but it gives the worst case seen by me so far esp. taking into account that the blend insn is not really fast and there is no good general case alternative (the only viable one is a sequence of And + AndNot + Or). 
I have feeling that `Sse.StaticCast&lt;TFromTTo&gt;()` contributes a lot to presence of `MOVxPS` whereas it is supposed to be just typecasting operation triggering something during compile time but not at runtime. The `MOVxPS` insns do not always appear looks like codegen optimizes some away but it's hard to predict - it is common case to see ~30 such insns within the span of 85-90 SSE insns when my code is JITted and it's obvious that at most half of them are really required. Although I know pre-VEX CPUs are old :-) to align to it's obvious that there is codegen issue.

Getting back to the issue it is interesting to note that if one would swap two first statements in the source code (marked as "line no. 1" and "line no. 2") then the codegen is much cleaner:

```
&gt;             Vector128&lt;ushort&gt; newValues = Sse2.AddSaturate(values valuesIncrement);
&gt; 000007FE64285DCE  paddusw     xmm1xmm6  
&gt; 
&gt;             // Generate codegen issue
&gt;             values =
&gt;                 Sse.StaticCast&lt;byte ushort&gt;(
&gt;                     Sse41.BlendVariable(
&gt;                         Sse.StaticCast&lt;ushort byte&gt;(values)
&gt;                         Sse.StaticCast&lt;ushort byte&gt;(newValues)
&gt;                         Sse.StaticCast&lt;ushort byte&gt;(updateMask)));
&gt; 000007FE64285DD2  movaps      xmm2xmm6  
&gt; 000007FE64285DD5  pblendvb    xmm2xmm1xmm0  
&gt; 000007FE64285DDA  movaps      xmm6xmm2  
&gt; 
&gt;             Console.WriteLine(values);
&gt; 000007FE64285DDD  mov         rcx7FE64276750h  
&gt; 000007FE64285DE7  call        000007FEC3D41940  
&gt; 000007FE64285DEC  mov         rcxrax  
&gt; 000007FE64285DEF  movups      xmmword ptr [rcx+8]xmm6  
&gt; 000007FE64285DF3  call        000007FE64283088  
```

(Just checked with Haswell CPU - no major issues appear when VEX-encoded)</Description>
    <Title_Description>Sub-optimal codegen when using Sse.StaticCast&lt;TFrom,TTo&gt;() with non-VEX encoded HW intrinsics Below is the source code (basically this is an example of partial vector update code trimmed down for repro):

            // Setup constants
            Vector128&lt;ushort&gt; valuesIncrement = Sse2.SetAllVector128((ushort)0x0001U); // &lt;== no. 1
            Vector128&lt;ushort&gt; opCookie = Sse.StaticCast&lt;ulong ushort&gt;( //&lt;== no. 2
                Sse2.SetVector128(
                    0x0001_0002_0003_0004UL
                    0x0005_0006_0007_0008UL));

            // Setup initial condition
            Vector128&lt;ushort&gt; values = Sse2.SetVector128(
                (ushort)0x1111U (ushort)0x2222U (ushort)0x3333U (ushort)0x4444U
                (ushort)0x5555U (ushort)0x6666U (ushort)0x7777U (ushort)0x8888U);

            // Simulate op
            Vector128&lt;ushort&gt; updateSelector = Sse2.SetAllVector128((ushort)0x0004U);
            Vector128&lt;ushort&gt; updateMask = Sse2.CompareEqual(updateSelector opCookie);
            Vector128&lt;ushort&gt; newValues = Sse2.AddSaturate(values valuesIncrement);

            // Generate codegen issue
            values =
                Sse.StaticCast&lt;byte ushort&gt;(
                    Sse41.BlendVariable(
                        Sse.StaticCast&lt;ushort byte&gt;(values)
                        Sse.StaticCast&lt;ushort byte&gt;(newValues)
                        Sse.StaticCast&lt;ushort byte&gt;(updateMask)));

            Console.WriteLine(values);

With  my i5-750 CPU (Nehalem uarch) which does not support VEX encoding I've got the following asm code with .NET Core 2.1 RC1 JITter (look for the `PBLENDVB` instruction down below):

```
&gt; 000007FE664F5D23  mov         ecx1  
&gt; 000007FE664F5D28  movd        xmm0ecx  
&gt; 000007FE664F5D2C  movaps      xmm1xmm0  
&gt; 000007FE664F5D2F  punpcklwd   xmm1xmm0  
&gt; 000007FE664F5D33  movaps      xmm0xmm1  
&gt; 000007FE664F5D36  pshufd      xmm0xmm00  
&gt;             Vector128&lt;ushort&gt; opCookie = Sse.StaticCast&lt;ulong ushort&gt;(
&gt;                 Sse2.SetVector128(
&gt;                     0x0001_0002_0003_0004UL
&gt;                     0x0005_0006_0007_0008UL));
&gt; 000007FE664F5D3B  mov         rcx1000200030004h  
&gt; 000007FE664F5D45  movq        xmm1rcx  
&gt; 000007FE664F5D4A  mov         rcx5000600070008h  
&gt; 000007FE664F5D54  movq        xmm2rcx  
&gt; 000007FE664F5D59  punpcklqdq  xmm2xmm1  
&gt; 000007FE664F5D5D  movaps      xmm1xmm2  
&gt; 
&gt;             // Setup initial condition
&gt;             Vector128&lt;ushort&gt; values = Sse2.SetVector128(
&gt;                 (ushort)0x1111U (ushort)0x2222U (ushort)0x3333U (ushort)0x4444U
&gt;                 (ushort)0x5555U (ushort)0x6666U (ushort)0x7777U (ushort)0x8888U);
&gt; 000007FE664F5D60  mov         ecx8888h  
&gt; 000007FE664F5D65  movd        xmm2ecx  
&gt; 000007FE664F5D69  mov         ecx7777h  
&gt; 000007FE664F5D6E  pinsrw      xmm2ecx1  
&gt; 000007FE664F5D73  mov         ecx6666h  
&gt; 000007FE664F5D78  pinsrw      xmm2ecx2  
&gt; 000007FE664F5D7D  mov         ecx5555h  
&gt; 000007FE664F5D82  pinsrw      xmm2ecx3  
&gt; 000007FE664F5D87  mov         ecx4444h  
&gt; 000007FE664F5D8C  pinsrw      xmm2ecx4  
&gt; 000007FE664F5D91  mov         ecx3333h  
&gt; 000007FE664F5D96  pinsrw      xmm2ecx5  
&gt; 000007FE664F5D9B  mov         ecx2222h  
&gt; 000007FE664F5DA0  pinsrw      xmm2ecx6  
&gt; 000007FE664F5DA5  mov         ecx1111h  
&gt; 000007FE664F5DAA  movaps      xmm6xmm2  
&gt; 000007FE664F5DAD  pinsrw      xmm6ecx7  
&gt; 
&gt;             // Simulate op
&gt;             Vector128&lt;ushort&gt; updateSelector = Sse2.SetAllVector128((ushort)0x0004U);
&gt; 000007FE664F5DB2  mov         ecx4  
&gt; 000007FE664F5DB7  movd        xmm2ecx  
&gt; 000007FE664F5DBB  movaps      xmm3xmm2  
&gt; 000007FE664F5DBE  punpcklwd   xmm3xmm2  
&gt; 000007FE664F5DC2  movaps      xmm2xmm3  
&gt; 000007FE664F5DC5  pshufd      xmm2xmm20  
&gt;             Vector128&lt;ushort&gt; updateMask = Sse2.CompareEqual(updateSelector opCookie);
&gt; 000007FE664F5DCA  pcmpeqw     xmm1xmm2  
&gt;             Vector128&lt;ushort&gt; newValues = Sse2.AddSaturate(values valuesIncrement);
&gt; 000007FE664F5DCE  paddusw     xmm0xmm6  
&gt; 
&gt;             // Generate codegen issue
&gt;             values =
&gt;                 Sse.StaticCast&lt;byte ushort&gt;(
&gt;                     Sse41.BlendVariable(
&gt;                         Sse.StaticCast&lt;ushort byte&gt;(values)
&gt;                         Sse.StaticCast&lt;ushort byte&gt;(newValues)
&gt;                         Sse.StaticCast&lt;ushort byte&gt;(updateMask)));
&gt; 000007FE664F5DD2  movups      xmmword ptr [rbp-4D0h]xmm0  
&gt; 000007FE664F5DD9  movaps      xmm0xmm1  
&gt; 000007FE664F5DDC  movups      xmm1xmmword ptr [rbp-4D0h]  
&gt; 000007FE664F5DE3  movaps      xmm2xmm6  
&gt; 000007FE664F5DE6  pblendvb    xmm2xmm1xmm0  &lt;===========================
&gt; 000007FE664F5DEB  movaps      xmm6xmm2  
&gt; 
&gt;             Console.WriteLine(values);
&gt; 000007FE664F5DEE  mov         rcx7FE664E6750h  
&gt; 000007FE664F5DF8  call        000007FEC5FB1940  
&gt; 000007FE664F5DFD  mov         rcxrax  
&gt; 000007FE664F5E00  movups      xmmword ptr [rcx+8]xmm6  
&gt; 000007FE664F5E04  call        000007FE664F3088

```
There are lots of `MOVxPS` before `PBLENDVB` for which I can't see any purpose some spilling the register's content on stack and then loading it back. `Sse41.BlendVariable()` is not the only HW intrinsic which displays the issue when input vectors are typecasted before being set as parameters but it gives the worst case seen by me so far esp. taking into account that the blend insn is not really fast and there is no good general case alternative (the only viable one is a sequence of And + AndNot + Or). 
I have feeling that `Sse.StaticCast&lt;TFromTTo&gt;()` contributes a lot to presence of `MOVxPS` whereas it is supposed to be just typecasting operation triggering something during compile time but not at runtime. The `MOVxPS` insns do not always appear looks like codegen optimizes some away but it's hard to predict - it is common case to see ~30 such insns within the span of 85-90 SSE insns when my code is JITted and it's obvious that at most half of them are really required. Although I know pre-VEX CPUs are old :-) to align to it's obvious that there is codegen issue.

Getting back to the issue it is interesting to note that if one would swap two first statements in the source code (marked as "line no. 1" and "line no. 2") then the codegen is much cleaner:

```
&gt;             Vector128&lt;ushort&gt; newValues = Sse2.AddSaturate(values valuesIncrement);
&gt; 000007FE64285DCE  paddusw     xmm1xmm6  
&gt; 
&gt;             // Generate codegen issue
&gt;             values =
&gt;                 Sse.StaticCast&lt;byte ushort&gt;(
&gt;                     Sse41.BlendVariable(
&gt;                         Sse.StaticCast&lt;ushort byte&gt;(values)
&gt;                         Sse.StaticCast&lt;ushort byte&gt;(newValues)
&gt;                         Sse.StaticCast&lt;ushort byte&gt;(updateMask)));
&gt; 000007FE64285DD2  movaps      xmm2xmm6  
&gt; 000007FE64285DD5  pblendvb    xmm2xmm1xmm0  
&gt; 000007FE64285DDA  movaps      xmm6xmm2  
&gt; 
&gt;             Console.WriteLine(values);
&gt; 000007FE64285DDD  mov         rcx7FE64276750h  
&gt; 000007FE64285DE7  call        000007FEC3D41940  
&gt; 000007FE64285DEC  mov         rcxrax  
&gt; 000007FE64285DEF  movups      xmmword ptr [rcx+8]xmm6  
&gt; 000007FE64285DF3  call        000007FE64283088  
```

(Just checked with Haswell CPU - no major issues appear when VEX-encoded)</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>mikedn</Assignee>
    <CreatedAt>21/05/2018 3:31:30 PM +00:00</CreatedAt>
    <ClosedAt>12/07/2018 3:36:44 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18068</IssueLabelID>
    <Title>Excess MOVAPS on some non-VEX encoded SSE HW intrinsics having the same 1st and 2nd operand</Title>
    <Description>Codegen for some HW intrinsics on pre-AVX CPU provides result which is obviously too verbose.
Here is sample code:

                Vector128&lt;ulong&gt; vU64 = Sse2.ConvertScalarToVector128UInt64(1UL);
                vU64 = Sse2.UnpackHigh(vU64 vU64);
                Console.WriteLine(vU64);

Here is asm code generated on my i5-750 (Nehalem uarch):

&gt; 000007FE650F5D20  mov         rsircx  
&gt; 000007FE650F5D23  mov         ecx1  
&gt; 000007FE650F5D28  movq        xmm6rcx  
&gt;                 vU64 = Sse2.UnpackHigh(vU64 vU64);
&gt; 000007FE650F5D2D  movaps      xmm0xmm6        ; &lt;==========
&gt; 000007FE650F5D30  punpckhqdq  xmm0xmm6     ; &lt;==========
&gt; 000007FE650F5D34  movaps      xmm6xmm0  
&gt;                 Console.WriteLine(vU64);
&gt; 000007FE650F5D37  mov         rcx7FE650E6750h  
&gt; 000007FE650F5D41  call        000007FEC4BB1940  
&gt; 000007FE650F5D46  mov         rcxrax  
&gt; 000007FE650F5D49  movups      xmmword ptr [rcx+8]xmm6  
&gt; 000007FE650F5D4D  call        000007FE650F2558

`vU64` is not used anywhere after the last line and to my opinion the instructions marked can be replaced with just one `punpckhqdq  xmm6xmm6`. The same excess `MOVAPS`s also happen to other HW intrinsics so `UnpackHigh()` is just an example.

VEX-encoded version is OK no extra `VMOVAPS` generated - tested with i7-4790K (Haswell uarch w/ AVX &amp; AVX2).

UPD: I'm using .NET Core 2.1 RC1

category:cq
theme:register-allocator
skill-level:intermediate
cost:small</Description>
    <Title_Description>Excess MOVAPS on some non-VEX encoded SSE HW intrinsics having the same 1st and 2nd operand Codegen for some HW intrinsics on pre-AVX CPU provides result which is obviously too verbose.
Here is sample code:

                Vector128&lt;ulong&gt; vU64 = Sse2.ConvertScalarToVector128UInt64(1UL);
                vU64 = Sse2.UnpackHigh(vU64 vU64);
                Console.WriteLine(vU64);

Here is asm code generated on my i5-750 (Nehalem uarch):

&gt; 000007FE650F5D20  mov         rsircx  
&gt; 000007FE650F5D23  mov         ecx1  
&gt; 000007FE650F5D28  movq        xmm6rcx  
&gt;                 vU64 = Sse2.UnpackHigh(vU64 vU64);
&gt; 000007FE650F5D2D  movaps      xmm0xmm6        ; &lt;==========
&gt; 000007FE650F5D30  punpckhqdq  xmm0xmm6     ; &lt;==========
&gt; 000007FE650F5D34  movaps      xmm6xmm0  
&gt;                 Console.WriteLine(vU64);
&gt; 000007FE650F5D37  mov         rcx7FE650E6750h  
&gt; 000007FE650F5D41  call        000007FEC4BB1940  
&gt; 000007FE650F5D46  mov         rcxrax  
&gt; 000007FE650F5D49  movups      xmmword ptr [rcx+8]xmm6  
&gt; 000007FE650F5D4D  call        000007FE650F2558

`vU64` is not used anywhere after the last line and to my opinion the instructions marked can be replaced with just one `punpckhqdq  xmm6xmm6`. The same excess `MOVAPS`s also happen to other HW intrinsics so `UnpackHigh()` is just an example.

VEX-encoded version is OK no extra `VMOVAPS` generated - tested with i7-4790K (Haswell uarch w/ AVX &amp; AVX2).

UPD: I'm using .NET Core 2.1 RC1

category:cq
theme:register-allocator
skill-level:intermediate
cost:small</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18067</IssueLabelID>
    <Title>On porting .NET Core to FreeBSD</Title>
    <Description>Hello

I'm working on a [project](https://wiki.freebsd.org/SummerOfCode2018Projects/PortingPowerShellPorting) with Google Summer of Code and FreeBSD to port the .NET Core runtime and SDK as well as PowerShell over to the FreeBSD platform. Right now I'm gathering information on how to build and put together the tooling and runtime since the components are pretty scattered around in different repositories.

I've started with CoreCLR and CoreFX to build a working runtime which I'm basing on the 2.1.0 RC1 release -- commit hash [`a226c35`](https://github.com/dotnet/coreclr/commit/a226c3507db5f001840501652be82856c1b72cad) for CoreCLR and [`8f968b9`](https://github.com/dotnet/corefx/commit/8f968b9e79c5721d78cc88e46fe57457fe9d490d) for CoreFX. What I did was building them on Ubuntu Linux (which is an officially supported platform) to understand what the build results are and how to put them together and then execute the same steps on FreeBSD to try to get the same result. During this process of building on Linux I've come upon a couple questions which I'd like to discuss:

- I've built the CoreFX managed components on Windows (targeting Linux with `build-managed.cmd -os=Linux -SkipTests`) which resulted in a bunch of DLLs (exptected) and a couple Linux executables and .so files (not expected). These executables and .so files also appear when building CoreCLR native on Linux which is expected. Why did they appear on the Windows build and which ones should I use the ones that appear on the Windows CoreFX managed build or the ones that appear on the CoreCLR native build? They have the same filenames but different sizes -- the ones on the CoreCLR native build are about 10x larger.

- After getting the runtime working on Linux by creating the folder structure with the dotnet executable on top the `libhostfxr.so` file inside the `host/fxr/2.1.0-rc1` folder and the DLLs along with `createdump` and the native components of CoreFX inside the `shared/Microsoft.NETCore.App/2.1.0-rc1` folder I tried executing a little HelloWorld.dll program I created and built elsewhere on my own built-from-source runtime and it complained about a missing Microsoft.NETCore.App.deps.json file. In what step should it get built and how do I build it?

cc @Petermarcu @jkotas 

I should mention this project is being mentored by @DragonSA (FreeBSD) and @davidchisnall (Microsoft Research and FreeBSD)</Description>
    <Title_Description>On porting .NET Core to FreeBSD Hello

I'm working on a [project](https://wiki.freebsd.org/SummerOfCode2018Projects/PortingPowerShellPorting) with Google Summer of Code and FreeBSD to port the .NET Core runtime and SDK as well as PowerShell over to the FreeBSD platform. Right now I'm gathering information on how to build and put together the tooling and runtime since the components are pretty scattered around in different repositories.

I've started with CoreCLR and CoreFX to build a working runtime which I'm basing on the 2.1.0 RC1 release -- commit hash [`a226c35`](https://github.com/dotnet/coreclr/commit/a226c3507db5f001840501652be82856c1b72cad) for CoreCLR and [`8f968b9`](https://github.com/dotnet/corefx/commit/8f968b9e79c5721d78cc88e46fe57457fe9d490d) for CoreFX. What I did was building them on Ubuntu Linux (which is an officially supported platform) to understand what the build results are and how to put them together and then execute the same steps on FreeBSD to try to get the same result. During this process of building on Linux I've come upon a couple questions which I'd like to discuss:

- I've built the CoreFX managed components on Windows (targeting Linux with `build-managed.cmd -os=Linux -SkipTests`) which resulted in a bunch of DLLs (exptected) and a couple Linux executables and .so files (not expected). These executables and .so files also appear when building CoreCLR native on Linux which is expected. Why did they appear on the Windows build and which ones should I use the ones that appear on the Windows CoreFX managed build or the ones that appear on the CoreCLR native build? They have the same filenames but different sizes -- the ones on the CoreCLR native build are about 10x larger.

- After getting the runtime working on Linux by creating the folder structure with the dotnet executable on top the `libhostfxr.so` file inside the `host/fxr/2.1.0-rc1` folder and the DLLs along with `createdump` and the native components of CoreFX inside the `shared/Microsoft.NETCore.App/2.1.0-rc1` folder I tried executing a little HelloWorld.dll program I created and built elsewhere on my own built-from-source runtime and it complained about a missing Microsoft.NETCore.App.deps.json file. In what step should it get built and how do I build it?

cc @Petermarcu @jkotas 

I should mention this project is being mentored by @DragonSA (FreeBSD) and @davidchisnall (Microsoft Research and FreeBSD)</Title_Description>
    <Label>area-PAL</Label>
    <Assignee>bartonjs</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18063</IssueLabelID>
    <Title>Fix ARM cast codegen</Title>
    <Description>ARM cast codegen is rather convoluted and sometimes does the wrong thing by applying `GTF_UNSIGNED` to the destination type even though this flag is only about the source type.

Fixes #18040</Description>
    <Title_Description>Fix ARM cast codegen ARM cast codegen is rather convoluted and sometimes does the wrong thing by applying `GTF_UNSIGNED` to the destination type even though this flag is only about the source type.

Fixes #18040</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>mikedn</Assignee>
    <CreatedAt>19/05/2018 2:38:47 PM +00:00</CreatedAt>
    <ClosedAt>7/06/2018 5:19:01 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18060</IssueLabelID>
    <Title>Don't close the JIT func info file on shutdown</Title>
    <Description>During shutdown there can be a race between closing/nulling `compJitFuncInfoFile` in `compShutdown` and a background thread trying to write to it after checking that it was not null. This was found with tiering enabled but it looks like it can happen normally with unlucky timing because background threads aren't torn down on the shutdown path after main exits.</Description>
    <Title_Description>Don't close the JIT func info file on shutdown During shutdown there can be a race between closing/nulling `compJitFuncInfoFile` in `compShutdown` and a background thread trying to write to it after checking that it was not null. This was found with tiering enabled but it looks like it can happen normally with unlucky timing because background threads aren't torn down on the shutdown path after main exits.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18057</IssueLabelID>
    <Title>add repro for #18056 </Title>
    <Description>Link #18056.

Note: if you change file names then it will change methods hashes and the bug stops to repro.</Description>
    <Title_Description>add repro for #18056  Link #18056.

Note: if you change file names then it will change methods hashes and the bug stops to repro.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>18/05/2018 11:43:43 PM +00:00</CreatedAt>
    <ClosedAt>22/05/2018 4:08:59 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18056</IssueLabelID>
    <Title>[RyuJit/STRESS_BB_PROFILE] flowgraph.cpp  noway_assert(blockPred-&gt;bbTraversalStamp == curTraversalStamp) fails</Title>
    <Description>1. `fgReplacePred` does not keep the sorted order (#13295);
2. if 1) then `fgAddRefPred` does not find the existing occurrence if the order is not sorted;
3. if 2) then `fgReplacePred` has several occurrences of the same block and when the block dies `fgReplacePred` updates only the first link;
4. if 3) The link to the dead block exposed `noway_assert` in `flowgraph`.

Repro: #18057 

category:correctness
theme:testing
skill-level:intermediate
cost:medium</Description>
    <Title_Description>[RyuJit/STRESS_BB_PROFILE] flowgraph.cpp  noway_assert(blockPred-&gt;bbTraversalStamp == curTraversalStamp) fails 1. `fgReplacePred` does not keep the sorted order (#13295);
2. if 1) then `fgAddRefPred` does not find the existing occurrence if the order is not sorted;
3. if 2) then `fgReplacePred` has several occurrences of the same block and when the block dies `fgReplacePred` updates only the first link;
4. if 3) The link to the dead block exposed `noway_assert` in `flowgraph`.

Repro: #18057 

category:correctness
theme:testing
skill-level:intermediate
cost:medium</Title_Description>
    <Label>JitStress</Label>
    <Assignee>sandreenko</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18055</IssueLabelID>
    <Title>[Release/2.1] Use sysconf(_SC_NPROCESSORS_ONLN) in PAL_GetLogicalCpuCountFromOS (#18053)</Title>
    <Description>This is #18053 ifdef-d under `_ARM_` or `_ARM64_` only as suggested in https://github.com/dotnet/coreclr/pull/18053#issuecomment-390349093

/cc @RussKeldorph @dotnet/arm32-contrib @dotnet/arm64-contrib </Description>
    <Title_Description>[Release/2.1] Use sysconf(_SC_NPROCESSORS_ONLN) in PAL_GetLogicalCpuCountFromOS (#18053) This is #18053 ifdef-d under `_ARM_` or `_ARM64_` only as suggested in https://github.com/dotnet/coreclr/pull/18053#issuecomment-390349093

/cc @RussKeldorph @dotnet/arm32-contrib @dotnet/arm64-contrib </Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>18/05/2018 10:56:19 PM +00:00</CreatedAt>
    <ClosedAt>22/05/2018 5:06:14 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18054</IssueLabelID>
    <Title>.NET Core console app hangs</Title>
    <Description>I have a simple ASP.NET Core app with a background service. This background service perform batch data loading. On my dev machine I log these executed SQL commands to the console with EF Core this is a lot of output.
Sometimes in the middle of a batch load the app hangs. Web server is not responding.
OS: Windows 10 Enterprise
.NET Core version 2.1 preview2

I took  dump of the app when it hung. Here is the interesting thread's stack:

Thread   8
Current frame: ntdll!NtWaitForSingleObject + 0x14
Child-SP         RetAddr          Caller Callee
000000554eb3ee90 00007ff97c3e3b7f KERNELBASE!WaitForSingleObjectEx + 0x9f calling ntdll!NtWaitForSingleObject
000000554eb3eea0 00007ff93e320f3b coreclr!Thread::DoAppropriateWaitWorker + 0x2c3 [e:\a\_work\37\s\src\vm\threads.cpp:3780] calling coreclr!ThreadStateNCStackHolder::~ThreadStateNCStackHolder [e:\a\_work\37\s\src\vm\threads.h:7442]
000000554eb3eec0 00007ff93e3bf756 coreclr!EnterMonitorForRestore + 0x5e [e:\a\_work\37\s\src\vm\threads.cpp:4166] calling coreclr!CLRException::HandlerState::CleanupTry [e:\a\_work\37\s\src\vm\clrex.cpp:901]
000000554eb3ef30 00007ff93e37b530 coreclr!CLREventWaitHelper + 0x20 [e:\a\_work\37\s\src\vm\synch.cpp:411] calling kernel32!WaitForSingleObjectEx
000000554eb3ef90 00007ff93e5fb6dd coreclr!SVR::GCHeap::WaitUntilGCComplete + 0x3d [e:\a\_work\37\s\src\gc\gcee.cpp:402] calling coreclr!CLREventBase::WaitEx [e:\a\_work\37\s\src\vm\synch.cpp:431]
000000554eb3efc0 00007ff93e31f74d coreclr!Thread::RareDisablePreemptiveGC + 0x145 [e:\a\_work\37\s\src\vm\threadsuspend.cpp:3065]
000000554eb3f010 00007ff93e3c78e8 coreclr!JIT_RareDisableHelperWorker + 0x68 [e:\a\_work\37\s\src\vm\jithelpers.cpp:5560] calling coreclr!Thread::RareDisablePreemptiveGC [e:\a\_work\37\s\src\vm\threadsuspend.cpp:2981]
000000554eb3f070 00007ff97c42840a KERNELBASE!WideCharToMultiByte + 0x3ca calling KERNELBASE!GetMBNoDefault
000000554eb3f0b0 00007ff97c3febd9 KERNELBASE!ConsoleCallServerGeneric + 0x119 calling KERNELBASE!_security_check_cookie
000000554eb3f110 00007ff8df304b8b (MethodDesc 00007ff8df419f38 + 0xab DomainBoundILStubClass.IL_STUB_PInvoke(UInt32 UInt32 Char* Int32 Byte* Int32 IntPtr IntPtr))
000000554eb3f120 00007ff97fd516d0 ntdll!RtlSetLastWin32Error + 0x40 calling ntdll!_security_check_cookie
000000554eb3f130 00007ff97c412a3a KERNELBASE!WriteFile + 0x7a calling ntdll!NtWriteFile
000000554eb3f160 00007ff93e3cec54 coreclr!JIT_RareDisableHelper + 0x14 [E:\A\_work\37\s\src\vm\amd64\AsmHelpers.asm:234] calling coreclr!JIT_RareDisableHelperWorker [e:\a\_work\37\s\src\vm\jithelpers.cpp:5523]
000000554eb3f1a0 00007ff8df303fff (MethodDesc 00007ff8df4186d8 + 0xbf DomainBoundILStubClass.IL_STUB_PInvoke(IntPtr Byte* Int32 Int32 ByRef IntPtr))
000000554eb3f200 00007ff8df303fdf (MethodDesc 00007ff8df4186d8 + 0x9f DomainBoundILStubClass.IL_STUB_PInvoke(IntPtr Byte* Int32 Int32 ByRef IntPtr))
000000554eb3f260 00007ff9581391b8 (MethodDesc 00007ff8df418520 + 0x68 System.ConsolePal+WindowsConsoleStream.WriteFileNative(IntPtr Byte[] Int32 Int32 Boolean)) calling 00007ff8df303238 (stub for Interop+Kernel32.WriteFile(IntPtr Byte* Int32 Int32 ByRef IntPtr))
000000554eb3f270 00007ff97c445274 KERNELBASE!SetConsoleTextAttribute + 0x24 calling KERNELBASE!ConsoleCallServer
000000554eb3f2c0 00007ff958138f59 (MethodDesc 00007ff8df418500 + 0x49 System.ConsolePal+WindowsConsoleStream.Write(Byte[] Int32 Int32)) calling (MethodDesc 00007ff8df418520 + 0 System.ConsolePal+WindowsConsoleStream.WriteFileNative(IntPtr Byte[] Int32 Int32 Boolean))
000000554eb3f310 00007ff93de6b600 (MethodDesc 00007ff93d7ed5e8 + 0xe0 System.IO.StreamWriter.Flush(Boolean Boolean))
000000554eb3f390 00007ff93de6bed9 (MethodDesc 00007ff93d7ed668 + 0xf9 System.IO.StreamWriter.Write(System.String)) calling (MethodDesc 00007ff93d7ed5e8 + 0 System.IO.StreamWriter.Flush(Boolean Boolean))
000000554eb3f400 00007ff95813e4f0 (MethodDesc 00007ff8df419b30 + 0x50 System.IO.SyncTextWriter.Write(System.String)) calling 00007ff8de7ed300
000000554eb3f420 00007ff9581345fb (MethodDesc 00007ff8df415fb0 + 0xb System.Console.ResetColor()) calling (MethodDesc 00007ff8df4167e0 + 0 System.ConsolePal.ResetColor())
000000554eb3f450 00007ff93bcca77d (MethodDesc 00007ff8deb0b7b0 + 0x3d Microsoft.Extensions.Logging.Console.Internal.WindowsLogConsole.Write(System.String System.Nullable`1&lt;System.ConsoleColor&gt; System.Nullable`1&lt;System.ConsoleColor&gt;)) calling 00007ff8de7ed340
000000554eb3f480 00007ff93bcca4ad (MethodDesc 00007ff8deafba48 + 0x4d Microsoft.Extensions.Logging.Console.Internal.ConsoleLoggerProcessor.WriteMessage(Microsoft.Extensions.Logging.Console.Internal.LogMessageEntry)) calling 00007ff8de7ed320
000000554eb3f4c0 00007ff93bcca58b (MethodDesc 00007ff8deafba50 + 0xbb Microsoft.Extensions.Logging.Console.Internal.ConsoleLoggerProcessor.ProcessLogQueue()) calling 00007ff8de7ed880
000000554eb3f560 00007ff963236fc0 (MethodDesc 00007ff8deaff048 + 0x40 System.Threading.Thread.ThreadMain_ThreadStart())
000000554eb3f590 00007ff93dc5a4f9 (MethodDesc 00007ff93d7b1d28 + 0x89 System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext System.Threading.ContextCallback System.Object))
000000554eb3f610 00007ff93e3cfa83 coreclr!CallDescrWorkerInternal + 0x83 [E:\A\_work\37\s\src\vm\amd64\CallDescrWorkerAMD64.asm:101]
000000554eb3f628 00007ff93e31733e coreclr!MethodDesc::GetSingleCallableAddrOfVirtualizedCode + 0x92 [e:\a\_work\37\s\src\vm\method.cpp:2010] calling coreclr!MethodTable::GetRestoredSlot [e:\a\_work\37\s\src\vm\methodtable.cpp:9650]
000000554eb3f650 00007ff93e335a39 coreclr!MethodDescCallSite::CallTargetWorker + 0x2b5 [e:\a\_work\37\s\src\vm\callhelpers.cpp:628] calling coreclr!CallDescrWorkerInternal [E:\A\_work\37\s\src\vm\amd64\CallDescrWorkerAMD64.asm:38]
000000554eb3f680 00007ff93e332b0b coreclr!GCToCLREventSink::FirePrvDestroyGCHandle + 0x6b [e:\a\_work\37\s\src\vm\gctoclreventsink.cpp:329] calling coreclr!__security_check_cookie
000000554eb3f6d0 00007ff93e31733e coreclr!MethodDesc::GetSingleCallableAddrOfVirtualizedCode + 0x92 [e:\a\_work\37\s\src\vm\method.cpp:2010] calling coreclr!MethodTable::GetRestoredSlot [e:\a\_work\37\s\src\vm\methodtable.cpp:9650]
000000554eb3f7a0 00007ff93e3a1283 coreclr!ThreadNative::KickOffThread_Worker + 0x143 [e:\a\_work\37\s\src\vm\comsynchronizable.cpp:260] calling coreclr!MethodDescCallSite::CallTargetWorker [e:\a\_work\37\s\src\vm\callhelpers.cpp:333]
000000554eb3f7d0 00007ff97ed99f67 combase!CoVrfNotifyCoInit + 0xf [onecore\com\combase\verifier\threadstate.cxx:490] calling combase!ComVerifierSettings::VerifyThreadStateEnabled [onecore\com\combase\inc\verify.hxx:208]
000000554eb3f830 00007ff97fd4fa44 ntdll!LdrpDropLastInProgressCount + 0x38 calling ntdll!RtlLeaveCriticalSection
000000554eb3f900 00007ff97ed98df6 combase!CoInitializeEx + 0x36 [onecore\com\combase\class\compobj.cxx:3905] calling combase!_CoInitializeEx [onecore\com\combase\class\compobj.cxx:3668]
000000554eb3f910 00007ff93e334ba2 coreclr!ManagedThreadBase_DispatchInner + 0x5a [e:\a\_work\37\s\src\vm\threads.cpp:8852]
000000554eb3f950 00007ff93e3349fe coreclr!ManagedThreadBase_DispatchMiddle + 0x76 [e:\a\_work\37\s\src\vm\threads.cpp:8901] calling coreclr!ManagedThreadBase_DispatchInner [e:\a\_work\37\s\src\vm\threads.cpp:8808]
000000554eb3f960 00007ff93e2d7549 coreclr!EEHeapAllocInProcessHeap + 0x29 [e:\a\_work\37\s\src\vm\hosting.cpp:463] calling ntdll!RtlAllocateHeap
000000554eb3f970 00007ff93e3a8e81 coreclr!ClrFlsIncrementValue + 0x29 [e:\a\_work\37\s\src\inc\clrhost.h:99]
000000554eb3fa50 00007ff93e3348fd coreclr!ManagedThreadBase_DispatchOuter + 0x91 [e:\a\_work\37\s\src\vm\threads.cpp:9140] calling coreclr!ManagedThreadBase_DispatchMiddle [e:\a\_work\37\s\src\vm\threads.cpp:8855]
000000554eb3fac0 00007ff93e3c8573 coreclr!ManagedThreadBase_FullTransitionWithAD + 0x2f [e:\a\_work\37\s\src\vm\threads.cpp:9200] calling coreclr!ManagedThreadBase_DispatchOuter [e:\a\_work\37\s\src\vm\threads.cpp:9092]
000000554eb3fb20 00007ff93e38568a coreclr!ThreadNative::KickOffThread + 0x10a [e:\a\_work\37\s\src\vm\comsynchronizable.cpp:380] calling coreclr!ManagedThreadBase_FullTransitionWithAD [e:\a\_work\37\s\src\vm\threads.cpp:9189]
000000554eb3fc00 00007ff93e385558 coreclr!Thread::intermediateThreadProc + 0x88 [e:\a\_work\37\s\src\vm\threads.cpp:2255]
000000554eb3fe80 00007ff93e385533 coreclr!Thread::intermediateThreadProc + 0x63 [e:\a\_work\37\s\src\vm\threads.cpp:2250] calling coreclr!__chkstk
000000554eb3fec0 00007ff97f6e1fe4 kernel32!BaseThreadInitThunk + 0x14 calling ntdll!LdrpDispatchUserCallTarget
000000554eb3fef0 00007ff97fd7f061 ntdll!RtlUserThreadStart + 0x21 calling ntdll!LdrpDispatchUserCallTarget

Is this a known issue?

</Description>
    <Title_Description>.NET Core console app hangs I have a simple ASP.NET Core app with a background service. This background service perform batch data loading. On my dev machine I log these executed SQL commands to the console with EF Core this is a lot of output.
Sometimes in the middle of a batch load the app hangs. Web server is not responding.
OS: Windows 10 Enterprise
.NET Core version 2.1 preview2

I took  dump of the app when it hung. Here is the interesting thread's stack:

Thread   8
Current frame: ntdll!NtWaitForSingleObject + 0x14
Child-SP         RetAddr          Caller Callee
000000554eb3ee90 00007ff97c3e3b7f KERNELBASE!WaitForSingleObjectEx + 0x9f calling ntdll!NtWaitForSingleObject
000000554eb3eea0 00007ff93e320f3b coreclr!Thread::DoAppropriateWaitWorker + 0x2c3 [e:\a\_work\37\s\src\vm\threads.cpp:3780] calling coreclr!ThreadStateNCStackHolder::~ThreadStateNCStackHolder [e:\a\_work\37\s\src\vm\threads.h:7442]
000000554eb3eec0 00007ff93e3bf756 coreclr!EnterMonitorForRestore + 0x5e [e:\a\_work\37\s\src\vm\threads.cpp:4166] calling coreclr!CLRException::HandlerState::CleanupTry [e:\a\_work\37\s\src\vm\clrex.cpp:901]
000000554eb3ef30 00007ff93e37b530 coreclr!CLREventWaitHelper + 0x20 [e:\a\_work\37\s\src\vm\synch.cpp:411] calling kernel32!WaitForSingleObjectEx
000000554eb3ef90 00007ff93e5fb6dd coreclr!SVR::GCHeap::WaitUntilGCComplete + 0x3d [e:\a\_work\37\s\src\gc\gcee.cpp:402] calling coreclr!CLREventBase::WaitEx [e:\a\_work\37\s\src\vm\synch.cpp:431]
000000554eb3efc0 00007ff93e31f74d coreclr!Thread::RareDisablePreemptiveGC + 0x145 [e:\a\_work\37\s\src\vm\threadsuspend.cpp:3065]
000000554eb3f010 00007ff93e3c78e8 coreclr!JIT_RareDisableHelperWorker + 0x68 [e:\a\_work\37\s\src\vm\jithelpers.cpp:5560] calling coreclr!Thread::RareDisablePreemptiveGC [e:\a\_work\37\s\src\vm\threadsuspend.cpp:2981]
000000554eb3f070 00007ff97c42840a KERNELBASE!WideCharToMultiByte + 0x3ca calling KERNELBASE!GetMBNoDefault
000000554eb3f0b0 00007ff97c3febd9 KERNELBASE!ConsoleCallServerGeneric + 0x119 calling KERNELBASE!_security_check_cookie
000000554eb3f110 00007ff8df304b8b (MethodDesc 00007ff8df419f38 + 0xab DomainBoundILStubClass.IL_STUB_PInvoke(UInt32 UInt32 Char* Int32 Byte* Int32 IntPtr IntPtr))
000000554eb3f120 00007ff97fd516d0 ntdll!RtlSetLastWin32Error + 0x40 calling ntdll!_security_check_cookie
000000554eb3f130 00007ff97c412a3a KERNELBASE!WriteFile + 0x7a calling ntdll!NtWriteFile
000000554eb3f160 00007ff93e3cec54 coreclr!JIT_RareDisableHelper + 0x14 [E:\A\_work\37\s\src\vm\amd64\AsmHelpers.asm:234] calling coreclr!JIT_RareDisableHelperWorker [e:\a\_work\37\s\src\vm\jithelpers.cpp:5523]
000000554eb3f1a0 00007ff8df303fff (MethodDesc 00007ff8df4186d8 + 0xbf DomainBoundILStubClass.IL_STUB_PInvoke(IntPtr Byte* Int32 Int32 ByRef IntPtr))
000000554eb3f200 00007ff8df303fdf (MethodDesc 00007ff8df4186d8 + 0x9f DomainBoundILStubClass.IL_STUB_PInvoke(IntPtr Byte* Int32 Int32 ByRef IntPtr))
000000554eb3f260 00007ff9581391b8 (MethodDesc 00007ff8df418520 + 0x68 System.ConsolePal+WindowsConsoleStream.WriteFileNative(IntPtr Byte[] Int32 Int32 Boolean)) calling 00007ff8df303238 (stub for Interop+Kernel32.WriteFile(IntPtr Byte* Int32 Int32 ByRef IntPtr))
000000554eb3f270 00007ff97c445274 KERNELBASE!SetConsoleTextAttribute + 0x24 calling KERNELBASE!ConsoleCallServer
000000554eb3f2c0 00007ff958138f59 (MethodDesc 00007ff8df418500 + 0x49 System.ConsolePal+WindowsConsoleStream.Write(Byte[] Int32 Int32)) calling (MethodDesc 00007ff8df418520 + 0 System.ConsolePal+WindowsConsoleStream.WriteFileNative(IntPtr Byte[] Int32 Int32 Boolean))
000000554eb3f310 00007ff93de6b600 (MethodDesc 00007ff93d7ed5e8 + 0xe0 System.IO.StreamWriter.Flush(Boolean Boolean))
000000554eb3f390 00007ff93de6bed9 (MethodDesc 00007ff93d7ed668 + 0xf9 System.IO.StreamWriter.Write(System.String)) calling (MethodDesc 00007ff93d7ed5e8 + 0 System.IO.StreamWriter.Flush(Boolean Boolean))
000000554eb3f400 00007ff95813e4f0 (MethodDesc 00007ff8df419b30 + 0x50 System.IO.SyncTextWriter.Write(System.String)) calling 00007ff8de7ed300
000000554eb3f420 00007ff9581345fb (MethodDesc 00007ff8df415fb0 + 0xb System.Console.ResetColor()) calling (MethodDesc 00007ff8df4167e0 + 0 System.ConsolePal.ResetColor())
000000554eb3f450 00007ff93bcca77d (MethodDesc 00007ff8deb0b7b0 + 0x3d Microsoft.Extensions.Logging.Console.Internal.WindowsLogConsole.Write(System.String System.Nullable`1&lt;System.ConsoleColor&gt; System.Nullable`1&lt;System.ConsoleColor&gt;)) calling 00007ff8de7ed340
000000554eb3f480 00007ff93bcca4ad (MethodDesc 00007ff8deafba48 + 0x4d Microsoft.Extensions.Logging.Console.Internal.ConsoleLoggerProcessor.WriteMessage(Microsoft.Extensions.Logging.Console.Internal.LogMessageEntry)) calling 00007ff8de7ed320
000000554eb3f4c0 00007ff93bcca58b (MethodDesc 00007ff8deafba50 + 0xbb Microsoft.Extensions.Logging.Console.Internal.ConsoleLoggerProcessor.ProcessLogQueue()) calling 00007ff8de7ed880
000000554eb3f560 00007ff963236fc0 (MethodDesc 00007ff8deaff048 + 0x40 System.Threading.Thread.ThreadMain_ThreadStart())
000000554eb3f590 00007ff93dc5a4f9 (MethodDesc 00007ff93d7b1d28 + 0x89 System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext System.Threading.ContextCallback System.Object))
000000554eb3f610 00007ff93e3cfa83 coreclr!CallDescrWorkerInternal + 0x83 [E:\A\_work\37\s\src\vm\amd64\CallDescrWorkerAMD64.asm:101]
000000554eb3f628 00007ff93e31733e coreclr!MethodDesc::GetSingleCallableAddrOfVirtualizedCode + 0x92 [e:\a\_work\37\s\src\vm\method.cpp:2010] calling coreclr!MethodTable::GetRestoredSlot [e:\a\_work\37\s\src\vm\methodtable.cpp:9650]
000000554eb3f650 00007ff93e335a39 coreclr!MethodDescCallSite::CallTargetWorker + 0x2b5 [e:\a\_work\37\s\src\vm\callhelpers.cpp:628] calling coreclr!CallDescrWorkerInternal [E:\A\_work\37\s\src\vm\amd64\CallDescrWorkerAMD64.asm:38]
000000554eb3f680 00007ff93e332b0b coreclr!GCToCLREventSink::FirePrvDestroyGCHandle + 0x6b [e:\a\_work\37\s\src\vm\gctoclreventsink.cpp:329] calling coreclr!__security_check_cookie
000000554eb3f6d0 00007ff93e31733e coreclr!MethodDesc::GetSingleCallableAddrOfVirtualizedCode + 0x92 [e:\a\_work\37\s\src\vm\method.cpp:2010] calling coreclr!MethodTable::GetRestoredSlot [e:\a\_work\37\s\src\vm\methodtable.cpp:9650]
000000554eb3f7a0 00007ff93e3a1283 coreclr!ThreadNative::KickOffThread_Worker + 0x143 [e:\a\_work\37\s\src\vm\comsynchronizable.cpp:260] calling coreclr!MethodDescCallSite::CallTargetWorker [e:\a\_work\37\s\src\vm\callhelpers.cpp:333]
000000554eb3f7d0 00007ff97ed99f67 combase!CoVrfNotifyCoInit + 0xf [onecore\com\combase\verifier\threadstate.cxx:490] calling combase!ComVerifierSettings::VerifyThreadStateEnabled [onecore\com\combase\inc\verify.hxx:208]
000000554eb3f830 00007ff97fd4fa44 ntdll!LdrpDropLastInProgressCount + 0x38 calling ntdll!RtlLeaveCriticalSection
000000554eb3f900 00007ff97ed98df6 combase!CoInitializeEx + 0x36 [onecore\com\combase\class\compobj.cxx:3905] calling combase!_CoInitializeEx [onecore\com\combase\class\compobj.cxx:3668]
000000554eb3f910 00007ff93e334ba2 coreclr!ManagedThreadBase_DispatchInner + 0x5a [e:\a\_work\37\s\src\vm\threads.cpp:8852]
000000554eb3f950 00007ff93e3349fe coreclr!ManagedThreadBase_DispatchMiddle + 0x76 [e:\a\_work\37\s\src\vm\threads.cpp:8901] calling coreclr!ManagedThreadBase_DispatchInner [e:\a\_work\37\s\src\vm\threads.cpp:8808]
000000554eb3f960 00007ff93e2d7549 coreclr!EEHeapAllocInProcessHeap + 0x29 [e:\a\_work\37\s\src\vm\hosting.cpp:463] calling ntdll!RtlAllocateHeap
000000554eb3f970 00007ff93e3a8e81 coreclr!ClrFlsIncrementValue + 0x29 [e:\a\_work\37\s\src\inc\clrhost.h:99]
000000554eb3fa50 00007ff93e3348fd coreclr!ManagedThreadBase_DispatchOuter + 0x91 [e:\a\_work\37\s\src\vm\threads.cpp:9140] calling coreclr!ManagedThreadBase_DispatchMiddle [e:\a\_work\37\s\src\vm\threads.cpp:8855]
000000554eb3fac0 00007ff93e3c8573 coreclr!ManagedThreadBase_FullTransitionWithAD + 0x2f [e:\a\_work\37\s\src\vm\threads.cpp:9200] calling coreclr!ManagedThreadBase_DispatchOuter [e:\a\_work\37\s\src\vm\threads.cpp:9092]
000000554eb3fb20 00007ff93e38568a coreclr!ThreadNative::KickOffThread + 0x10a [e:\a\_work\37\s\src\vm\comsynchronizable.cpp:380] calling coreclr!ManagedThreadBase_FullTransitionWithAD [e:\a\_work\37\s\src\vm\threads.cpp:9189]
000000554eb3fc00 00007ff93e385558 coreclr!Thread::intermediateThreadProc + 0x88 [e:\a\_work\37\s\src\vm\threads.cpp:2255]
000000554eb3fe80 00007ff93e385533 coreclr!Thread::intermediateThreadProc + 0x63 [e:\a\_work\37\s\src\vm\threads.cpp:2250] calling coreclr!__chkstk
000000554eb3fec0 00007ff97f6e1fe4 kernel32!BaseThreadInitThunk + 0x14 calling ntdll!LdrpDispatchUserCallTarget
000000554eb3fef0 00007ff97fd7f061 ntdll!RtlUserThreadStart + 0x21 calling ntdll!LdrpDispatchUserCallTarget

Is this a known issue?

</Title_Description>
    <Label>area-GC</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>18/05/2018 10:32:51 PM +00:00</CreatedAt>
    <ClosedAt>22/05/2018 1:01:27 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18053</IssueLabelID>
    <Title>Use sysconf(_SC_NPROCESSORS_CONF) in PAL_GetLogicalCpuCountFromOS</Title>
    <Description>As we found in #17851 `sysconf(_SC_NPROCESSORS_ONLN)` should not be used in `GetLogicalCpuCountFromOS` since it could return arbitrary number between 1 and actual number of logical CPU cores which causes VM to make wrong decision about which JIT_WriteBarrier to be used (SP vs MP).

When I tested `sysconf(_SC_NPROCESSORS_ONLN)` on NVIDIA Jetson TK1 I got all the values 1234 depending on how busy the processor is.

As suggested in https://github.com/dotnet/coreclr/issues/17851#issuecomment-390333775 `sysconf(_SC_NPROCESSORS_CONF)` and https://github.com/seanmonstar/num_cpus/issues/34 should be used instead.</Description>
    <Title_Description>Use sysconf(_SC_NPROCESSORS_CONF) in PAL_GetLogicalCpuCountFromOS As we found in #17851 `sysconf(_SC_NPROCESSORS_ONLN)` should not be used in `GetLogicalCpuCountFromOS` since it could return arbitrary number between 1 and actual number of logical CPU cores which causes VM to make wrong decision about which JIT_WriteBarrier to be used (SP vs MP).

When I tested `sysconf(_SC_NPROCESSORS_ONLN)` on NVIDIA Jetson TK1 I got all the values 1234 depending on how busy the processor is.

As suggested in https://github.com/dotnet/coreclr/issues/17851#issuecomment-390333775 `sysconf(_SC_NPROCESSORS_CONF)` and https://github.com/seanmonstar/num_cpus/issues/34 should be used instead.</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>echesakovMSFT</Assignee>
    <CreatedAt>18/05/2018 10:12:31 PM +00:00</CreatedAt>
    <ClosedAt>24/05/2018 8:57:48 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18052</IssueLabelID>
    <Title>[Arm64] jitStressRegs=3 failures</Title>
    <Description>The following tests fail with jitStressRegs=3 when run on x64/windows using the arm64 altjit:

CoreMangLib\cti\system\mathf\MathFSign\MathFSign.cmd
JIT\Generics\Locals\static_assignment_class01\static_assignment_class01.cmd
JIT\Generics\Constraints\convert_static01\convert_static01.cmd
JIT\IL_Conformance\Old\Conformance_Base\add_ovf_u2\add_ovf_u2.cmd
JIT\jit64\opt\regress\vswhidbey\481244\foo_opt\foo_opt.cmd

Note that this test leg was last run in the CI system on 16 Feb.</Description>
    <Title_Description>[Arm64] jitStressRegs=3 failures The following tests fail with jitStressRegs=3 when run on x64/windows using the arm64 altjit:

CoreMangLib\cti\system\mathf\MathFSign\MathFSign.cmd
JIT\Generics\Locals\static_assignment_class01\static_assignment_class01.cmd
JIT\Generics\Constraints\convert_static01\convert_static01.cmd
JIT\IL_Conformance\Old\Conformance_Base\add_ovf_u2\add_ovf_u2.cmd
JIT\jit64\opt\regress\vswhidbey\481244\foo_opt\foo_opt.cmd

Note that this test leg was last run in the CI system on 16 Feb.</Title_Description>
    <Label>JitStress</Label>
    <Assignee>CarolEidt</Assignee>
    <CreatedAt>18/05/2018 10:09:45 PM +00:00</CreatedAt>
    <ClosedAt>19/05/2018 1:47:58 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18051</IssueLabelID>
    <Title>Mirror changes from dotnet/corert</Title>
    <Description>This PR contains mirrored changes from dotnet/corert


**Please REBASE this PR when merging**</Description>
    <Title_Description>Mirror changes from dotnet/corert This PR contains mirrored changes from dotnet/corert


**Please REBASE this PR when merging**</Title_Description>
    <Label>
    </Label>
    <Assignee>jkotas</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18049</IssueLabelID>
    <Title>Move InsufficientMemory OutOfMemory and ThreadInterrupted exceptions</Title>
    <Description>Moving InsufficientMemoryException OutOfMemoryException and ThreadInterruptedException to shared

The diff shows the difference between the coreclr and corert files.

GetMessageFromNativeResources() is available in Exception.cs. Click [here](https://github.com/dotnet/coreclr/blame/85374ceaed177f71472cc4c23c69daf7402e5048/src/System.Private.CoreLib/src/System/Exception.cs#L731-L757) to view:

```
        // This piece of infrastructure exists to help avoid deadlocks 
        // between parts of mscorlib that might throw an exception while 
        // holding a lock that are also used by mscorlib's ResourceManager
        // instance.  As a special case of code that may throw while holding
        // a lock we also need to fix our asynchronous exceptions to use
        // Win32 resources as well (assuming we ever call a managed 
        // constructor on instances of them).  We should grow this set of
        // exception messages as we discover problems then move the resources
        // involved to native code.
        internal enum ExceptionMessageKind
        {
            ThreadAbort = 1
            ThreadInterrupted = 2
            OutOfMemory = 3
        }

        // See comment on ExceptionMessageKind
        internal static String GetMessageFromNativeResources(ExceptionMessageKind kind)
        {
            string retMesg = null;
            GetMessageFromNativeResources(kind JitHelpers.GetStringHandleOnStack(ref retMesg));
            return retMesg;
        }

        [DllImport(JitHelpers.QCall CharSet = CharSet.Unicode)]
        private static extern void GetMessageFromNativeResources(ExceptionMessageKind kind StringHandleOnStack retMesg);
    }
```

cc: @jkotas @danmosemsft should I instead keep using the GetMessageFromNativeResources() (shown above) as I move these exception classes to shared?

Related to: dotnet/coreclr#17904</Description>
    <Title_Description>Move InsufficientMemory, OutOfMemory and ThreadInterrupted exceptions Moving InsufficientMemoryException OutOfMemoryException and ThreadInterruptedException to shared

The diff shows the difference between the coreclr and corert files.

GetMessageFromNativeResources() is available in Exception.cs. Click [here](https://github.com/dotnet/coreclr/blame/85374ceaed177f71472cc4c23c69daf7402e5048/src/System.Private.CoreLib/src/System/Exception.cs#L731-L757) to view:

```
        // This piece of infrastructure exists to help avoid deadlocks 
        // between parts of mscorlib that might throw an exception while 
        // holding a lock that are also used by mscorlib's ResourceManager
        // instance.  As a special case of code that may throw while holding
        // a lock we also need to fix our asynchronous exceptions to use
        // Win32 resources as well (assuming we ever call a managed 
        // constructor on instances of them).  We should grow this set of
        // exception messages as we discover problems then move the resources
        // involved to native code.
        internal enum ExceptionMessageKind
        {
            ThreadAbort = 1
            ThreadInterrupted = 2
            OutOfMemory = 3
        }

        // See comment on ExceptionMessageKind
        internal static String GetMessageFromNativeResources(ExceptionMessageKind kind)
        {
            string retMesg = null;
            GetMessageFromNativeResources(kind JitHelpers.GetStringHandleOnStack(ref retMesg));
            return retMesg;
        }

        [DllImport(JitHelpers.QCall CharSet = CharSet.Unicode)]
        private static extern void GetMessageFromNativeResources(ExceptionMessageKind kind StringHandleOnStack retMesg);
    }
```

cc: @jkotas @danmosemsft should I instead keep using the GetMessageFromNativeResources() (shown above) as I move these exception classes to shared?

Related to: dotnet/coreclr#17904</Title_Description>
    <Label>
    </Label>
    <Assignee>maryamariyan</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18048</IssueLabelID>
    <Title>[arm64/Windows] Build using public SDK</Title>
    <Description>Arm64/Windows is currently built in the CI (and locally) using a private Microsoft SDK. With Windows 10 SDK 10.0.17134.0 (shipped with VS 2017 15.7.1) I believe all required arm64 files are public. Also Visual Studio has (since 15.4?) public arm64 Windows compilers. And recent cmake versions supposedly support these new tools.

Thus we should change the build infrastructure including CI and official builds to build arm64/Windows with all public tools and stop using the private toolset.
</Description>
    <Title_Description>[arm64/Windows] Build using public SDK Arm64/Windows is currently built in the CI (and locally) using a private Microsoft SDK. With Windows 10 SDK 10.0.17134.0 (shipped with VS 2017 15.7.1) I believe all required arm64 files are public. Also Visual Studio has (since 15.4?) public arm64 Windows compilers. And recent cmake versions supposedly support these new tools.

Thus we should change the build infrastructure including CI and official builds to build arm64/Windows with all public tools and stop using the private toolset.
</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>BruceForstall</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18047</IssueLabelID>
    <Title>[Arm64/Linux] Intermittent thread failures</Title>
    <Description>There are occasional intermittent failures in thread related tests.

In an effort to fix #18026 it seems worthwhile to track and investigate these.
</Description>
    <Title_Description>[Arm64/Linux] Intermittent thread failures There are occasional intermittent failures in thread related tests.

In an effort to fix #18026 it seems worthwhile to track and investigate these.
</Title_Description>
    <Label>area-System.Threading</Label>
    <Assignee>kouvel</Assignee>
    <CreatedAt>18/05/2018 6:24:44 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18045</IssueLabelID>
    <Title>Intel Hardware Intrinsics test framework design deficiences</Title>
    <Description>A while ago we have had a long discussion about the scope of testing which should be done during Intel Hardware Intrinsics development (for details see https://github.com/dotnet/coreclr/pull/15771).

There were two proposals put forward:
1. Test as little as possible concentrating on a check if expected assembly instruction is emitted;
2. Test for wider range of values including known problematic ones

Currently we use approach from point 1 which IMO opinion is deficient since it led to several missed implementation bugs i.e.:

https://github.com/dotnet/coreclr/issues/17957
https://github.com/dotnet/coreclr/issues/18039
https://github.com/dotnet/coreclr/issues/18041
https://github.com/dotnet/coreclr/issues/18043

It seems that using small set of problematic values for each numeric type would solve that problem without need for creating complex test scenarios i.e.:

1) for integral types: min max -1 0 1
2) for unsigned integral types: min max 1
3) for floating types: +/- infinity +/- max/min +/- 0 subnormal

@AndyAyersMS  @CarolEidt @fiigii @sdmaclea @tannergooding

category:testing
theme:intrinsics
skill-level:intermediate
cost:small
</Description>
    <Title_Description>Intel Hardware Intrinsics test framework design deficiences A while ago we have had a long discussion about the scope of testing which should be done during Intel Hardware Intrinsics development (for details see https://github.com/dotnet/coreclr/pull/15771).

There were two proposals put forward:
1. Test as little as possible concentrating on a check if expected assembly instruction is emitted;
2. Test for wider range of values including known problematic ones

Currently we use approach from point 1 which IMO opinion is deficient since it led to several missed implementation bugs i.e.:

https://github.com/dotnet/coreclr/issues/17957
https://github.com/dotnet/coreclr/issues/18039
https://github.com/dotnet/coreclr/issues/18041
https://github.com/dotnet/coreclr/issues/18043

It seems that using small set of problematic values for each numeric type would solve that problem without need for creating complex test scenarios i.e.:

1) for integral types: min max -1 0 1
2) for unsigned integral types: min max 1
3) for floating types: +/- infinity +/- max/min +/- 0 subnormal

@AndyAyersMS  @CarolEidt @fiigii @sdmaclea @tannergooding

category:testing
theme:intrinsics
skill-level:intermediate
cost:small
</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
    <CreatedAt>18/05/2018 4:29:49 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18044</IssueLabelID>
    <Title>.NET Core application running in docker gets OOMKilled if swapping is disabled</Title>
    <Description>We are running .NET Core applications inside docker containers on a kubernetes cluster. Docker containers get OOMKilled because GC is not executed.

To test this we created a test program which allocates arrays in a loop. These arrays should get deleted by the GC. The program is executed in a docker container with 100Mb memory limit. Kubernetes is not involved in the tests.

When running the test with **swap enabled** everything works as expected and the GC gets triggered when the total memory reaches 100Mb. The test never gets killed.

When running the test with **swap disabled** the test gets OOMKilled when the total memory reaches 100Mb. We have tested this behaviour with ServerGC=true|false and with .NET Core 2.0 and 2.1

Enabling swap is not an option cause it's neither recommended nor supported by Kubernetes.

# Code
you can find out test program here: https://github.com/devKlausS/dotnet_mem_allocator
      
    var rand = new Random();
    List&lt;byte[]&gt; m_arrays = new List&lt;byte[]&gt;();
    
    int iLoop = 0;
    while (true)
    {
        var array = new byte[iAllocBytes];
        var value = (byte)rand.Next();
        Parallel.ForEach(array (item) =&gt;
        {
            item = value;
        });
        rand.NextBytes(array);
    
        if(!bFree)
            m_arrays.Add(array);
    
        if(iCollect &gt; 0 &amp;&amp; iLoop % iCollect == 0)
        {
            Console.WriteLine("run GC");
            GC.Collect();
        }
    
        Console.Write("AllocatedBytesForCurrentThread: " + GC.GetAllocatedBytesForCurrentThread() / 1000000 + "Mb " +
            "TotalMemory: " + GC.GetTotalMemory(bForceFullCollection) / 1000000 + "Mb ");
    
        for(int i = 0; i &lt; GC.MaxGeneration; i++)
        {
            Console.Write("CollectionCount("+i+"): " + GC.CollectionCount(i) + " ");
        }
    
        Console.WriteLine("");
    
        Thread.Sleep(iSleepMs);
        iLoop++;
    }
# Docker images 

### ServerGC=false alloc/free .NET CORE 2.0
    docker run -ti -m 100M schaefferlinkbit/dotnet_mem_allocator:1.0.3895_20_client_GC /alloc_mb=20 /free=false
### ServerGC=true alloc/free .NET CORE 2.0
    docker run -ti -m 100M schaefferlinkbit/dotnet_mem_allocator:1.0.3895_20_server_GC /alloc_mb=20
### ServerGC=false alloc/free .NET CORE 2.1
    docker run -ti -m 100M schaefferlinkbit/dotnet_mem_allocator:1.0.3895_21_client_GC /alloc_mb=20 /free=false
### ServerGC=true alloc/free .NET CORE 2.1
    docker run -ti -m 100M schaefferlinkbit/dotnet_mem_allocator:1.0.3895_21_server_GC /alloc_mb=20

# cgroup limits
After reading multiple issues according to .NET Core GC and docker limits we started to dig into the cgroup limits. We compiled https://github.com/dotnet/coreclr/blob/master/src/gc/unix/cgroup.cpp and executed the program inside the docker container. As shown in the following screenshot the the path of the memory.limit_in_bytes file is pointing to the directory of the host machine and the file open operation fails.
![screenshot from 2018-05-18 11-27-29](https://user-images.githubusercontent.com/13675575/40230729-f77807ba-5a98-11e8-9740-7da4217a4777.png)
The next screenshot shows the volume mounts of the container. The host machine path is mounted to /sys/fs/memory inside the container. When reading memory.limit_in_bytes we see ~300MB (we pass -m 300M to the docker container)
![screenshot from 2018-05-18 11-27-40](https://user-images.githubusercontent.com/13675575/40230855-64052d4a-5a99-11e8-854f-c5751ab2f56b.png)

It seems like CLR is not able to read the physical memory limits from cgroup and therefore the GC is not triggered correctly. As a result the process is killed because of OOM. We guess that CLR is triggering GC when it has to do swapping and this is the reason why our process is not killed when swapping is enabled.
</Description>
    <Title_Description>.NET Core application running in docker gets OOMKilled if swapping is disabled We are running .NET Core applications inside docker containers on a kubernetes cluster. Docker containers get OOMKilled because GC is not executed.

To test this we created a test program which allocates arrays in a loop. These arrays should get deleted by the GC. The program is executed in a docker container with 100Mb memory limit. Kubernetes is not involved in the tests.

When running the test with **swap enabled** everything works as expected and the GC gets triggered when the total memory reaches 100Mb. The test never gets killed.

When running the test with **swap disabled** the test gets OOMKilled when the total memory reaches 100Mb. We have tested this behaviour with ServerGC=true|false and with .NET Core 2.0 and 2.1

Enabling swap is not an option cause it's neither recommended nor supported by Kubernetes.

# Code
you can find out test program here: https://github.com/devKlausS/dotnet_mem_allocator
      
    var rand = new Random();
    List&lt;byte[]&gt; m_arrays = new List&lt;byte[]&gt;();
    
    int iLoop = 0;
    while (true)
    {
        var array = new byte[iAllocBytes];
        var value = (byte)rand.Next();
        Parallel.ForEach(array (item) =&gt;
        {
            item = value;
        });
        rand.NextBytes(array);
    
        if(!bFree)
            m_arrays.Add(array);
    
        if(iCollect &gt; 0 &amp;&amp; iLoop % iCollect == 0)
        {
            Console.WriteLine("run GC");
            GC.Collect();
        }
    
        Console.Write("AllocatedBytesForCurrentThread: " + GC.GetAllocatedBytesForCurrentThread() / 1000000 + "Mb " +
            "TotalMemory: " + GC.GetTotalMemory(bForceFullCollection) / 1000000 + "Mb ");
    
        for(int i = 0; i &lt; GC.MaxGeneration; i++)
        {
            Console.Write("CollectionCount("+i+"): " + GC.CollectionCount(i) + " ");
        }
    
        Console.WriteLine("");
    
        Thread.Sleep(iSleepMs);
        iLoop++;
    }
# Docker images 

### ServerGC=false alloc/free .NET CORE 2.0
    docker run -ti -m 100M schaefferlinkbit/dotnet_mem_allocator:1.0.3895_20_client_GC /alloc_mb=20 /free=false
### ServerGC=true alloc/free .NET CORE 2.0
    docker run -ti -m 100M schaefferlinkbit/dotnet_mem_allocator:1.0.3895_20_server_GC /alloc_mb=20
### ServerGC=false alloc/free .NET CORE 2.1
    docker run -ti -m 100M schaefferlinkbit/dotnet_mem_allocator:1.0.3895_21_client_GC /alloc_mb=20 /free=false
### ServerGC=true alloc/free .NET CORE 2.1
    docker run -ti -m 100M schaefferlinkbit/dotnet_mem_allocator:1.0.3895_21_server_GC /alloc_mb=20

# cgroup limits
After reading multiple issues according to .NET Core GC and docker limits we started to dig into the cgroup limits. We compiled https://github.com/dotnet/coreclr/blob/master/src/gc/unix/cgroup.cpp and executed the program inside the docker container. As shown in the following screenshot the the path of the memory.limit_in_bytes file is pointing to the directory of the host machine and the file open operation fails.
![screenshot from 2018-05-18 11-27-29](https://user-images.githubusercontent.com/13675575/40230729-f77807ba-5a98-11e8-9740-7da4217a4777.png)
The next screenshot shows the volume mounts of the container. The host machine path is mounted to /sys/fs/memory inside the container. When reading memory.limit_in_bytes we see ~300MB (we pass -m 300M to the docker container)
![screenshot from 2018-05-18 11-27-40](https://user-images.githubusercontent.com/13675575/40230855-64052d4a-5a99-11e8-854f-c5751ab2f56b.png)

It seems like CLR is not able to read the physical memory limits from cgroup and therefore the GC is not triggered correctly. As a result the process is killed because of OOM. We guess that CLR is triggering GC when it has to do swapping and this is the reason why our process is not killed when swapping is enabled.
</Title_Description>
    <Label>area-GC</Label>
    <Assignee>janvorli</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18043</IssueLabelID>
    <Title>JIT: assert in test with call to Array&lt;T&gt;.IndexOf with Vector type</Title>
    <Description>```C#
using System;
using System.Numerics;
using System.Collections.Generic;

class X
{
    public static int Main()
    {
        Vector&lt;float&gt; f = new Vector&lt;float&gt;();
        Vector&lt;float&gt;[] a = new Vector&lt;float&gt;[10];
        return Array.IndexOf(a f);
    }
}
```
If you compile and run with CHECKED jit you hit the following assert:
```
Assert failure(PID 24440 [0x00005f78] Thread: 7436 [0x1d0c]): 
Assertion failed '!IsDummyUse()' in 
'System.Collections.Generic.GenericEqualityComparer`1[Vector`1]
 [System.Numerics.Vector`1[System.Single]]:IndexOf(refstructintint):int:this' (IL size 96)

File: d:\repos\coreclr\src\jit\lir.cpp Line: 110
```
</Description>
    <Title_Description>JIT: assert in test with call to Array&lt;T&gt;.IndexOf with Vector type ```C#
using System;
using System.Numerics;
using System.Collections.Generic;

class X
{
    public static int Main()
    {
        Vector&lt;float&gt; f = new Vector&lt;float&gt;();
        Vector&lt;float&gt;[] a = new Vector&lt;float&gt;[10];
        return Array.IndexOf(a f);
    }
}
```
If you compile and run with CHECKED jit you hit the following assert:
```
Assert failure(PID 24440 [0x00005f78] Thread: 7436 [0x1d0c]): 
Assertion failed '!IsDummyUse()' in 
'System.Collections.Generic.GenericEqualityComparer`1[Vector`1]
 [System.Numerics.Vector`1[System.Single]]:IndexOf(refstructintint):int:this' (IL size 96)

File: d:\repos\coreclr\src\jit\lir.cpp Line: 110
```
</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
    <CreatedAt>18/05/2018 8:40:45 AM +00:00</CreatedAt>
    <ClosedAt>18/05/2018 8:00:30 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18042</IssueLabelID>
    <Title>CoreCLR failed when build with MSVC on Windows</Title>
    <Description>Hello

I tried to build CoreCLR on Windows with VS2017 Update2. It failed to build due to the error CS2001: Source file 'D:\CoreCLR\src\bin\obj\Windows_NT.x86.Release\System.Private.CoreLib\..\eventing\DotNETRuntimeEventSource.cs' could not be found. This issue is caused by master branch revision [0fbd0f5](https://github.com/dotnet/coreclr/commit/0fbd0f535e566bcde591701adc2de51ee0f020af). Could you please help take a look at this? Thank you!

**You can repro this issue as the steps below:**
1. git clone https://github.com/dotnet/coreclr D:\CoreCLR\src
2. Open a clean x86 prompt (C:\windows\syswow64\cmd.exe) and browse to D:\CoreCLR\src
3. build x86 release -Rebuild -- /clp:ShowCommandLine

**Error info:**
CSC : error CS2001: Source file 'D:\CoreCLR\src\bin\obj\Windows_NT.x86.Release\System.Private.CoreLib\..\eventing\DotNETRuntimeEventSource.cs' could not be found. [D:\CoreCLR\src\src\System.Private.CoreLib\System.Private.CoreLib.csproj]</Description>
    <Title_Description>CoreCLR failed when build with MSVC on Windows Hello

I tried to build CoreCLR on Windows with VS2017 Update2. It failed to build due to the error CS2001: Source file 'D:\CoreCLR\src\bin\obj\Windows_NT.x86.Release\System.Private.CoreLib\..\eventing\DotNETRuntimeEventSource.cs' could not be found. This issue is caused by master branch revision [0fbd0f5](https://github.com/dotnet/coreclr/commit/0fbd0f535e566bcde591701adc2de51ee0f020af). Could you please help take a look at this? Thank you!

**You can repro this issue as the steps below:**
1. git clone https://github.com/dotnet/coreclr D:\CoreCLR\src
2. Open a clean x86 prompt (C:\windows\syswow64\cmd.exe) and browse to D:\CoreCLR\src
3. build x86 release -Rebuild -- /clp:ShowCommandLine

**Error info:**
CSC : error CS2001: Source file 'D:\CoreCLR\src\bin\obj\Windows_NT.x86.Release\System.Private.CoreLib\..\eventing\DotNETRuntimeEventSource.cs' could not be found. [D:\CoreCLR\src\src\System.Private.CoreLib\System.Private.CoreLib.csproj]</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>brianrob</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18041</IssueLabelID>
    <Title>JIT: assert when jitting Sse2.ConvertToInt32WithTruncation</Title>
    <Description>```C#
using System;
using System.Runtime.Intrinsics;
using System.Runtime.Intrinsics.X86;

class X
{
    public static int Main()
    {
        Vector128&lt;double&gt; x = new Vector128&lt;double&gt;();
        int y = Sse2.ConvertToInt32WithTruncation(x);
        return y;
    }
}
```
Running this with a CHECKED build hits an assert:
```
Assert failure(PID 25028 [0x000061c4] Thread: 14596 [0x3904]): 
Assertion failed 'unreached' in 'X:Main():int' (IL size 23)

    File: d:\repos\coreclr\src\jit\hwintrinsiccodegenxarch.cpp Line: 1103
    Image: D:\repos\coreclr\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root\CoreRun.exe
```</Description>
    <Title_Description>JIT: assert when jitting Sse2.ConvertToInt32WithTruncation ```C#
using System;
using System.Runtime.Intrinsics;
using System.Runtime.Intrinsics.X86;

class X
{
    public static int Main()
    {
        Vector128&lt;double&gt; x = new Vector128&lt;double&gt;();
        int y = Sse2.ConvertToInt32WithTruncation(x);
        return y;
    }
}
```
Running this with a CHECKED build hits an assert:
```
Assert failure(PID 25028 [0x000061c4] Thread: 14596 [0x3904]): 
Assertion failed 'unreached' in 'X:Main():int' (IL size 23)

    File: d:\repos\coreclr\src\jit\hwintrinsiccodegenxarch.cpp Line: 1103
    Image: D:\repos\coreclr\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root\CoreRun.exe
```</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>4creators</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18040</IssueLabelID>
    <Title>Broken conv.ovf.i8.un decomposition</Title>
    <Description>IL sample:
```
ldind.i1
conv.ovf.i8.un
```
IR post decomposition:
```
N001 (  1  1) [000002] -------------        t2 =    LCL_VAR   byref  V00 arg0         u:2 (last use) $80
                                                  /--*  t2     byref  
N002 (  4  3) [000003] *--XG--------        t3 = *  IND       byte   &lt;l:$140 c:$180&gt;
                                                  /--*  t3     byte   
               [000012] ---XG----U---       t12 = *  CAST      int &lt;- byte &lt;- uint
               [000013] -------------       t13 =    CNS_INT   int    0
                                                  /--*  t12    int    
                                                  +--*  t13    int    
               [000014] ---XG--------       t14 = *  LONG      long  
```
x86 generated code:
```asm
       0FBE01       movsx    eax byte  ptr [ecx]
       0FBEC0       movsx    eax al
       8902         mov      dword ptr [edx] eax
       33C0         xor      eax eax
       894204       mov      dword ptr [edx+4] eax
```
ARM32 generated code:
```asm
000006  F990 3000      ldrsb   r3 [r0]
00000A  B2DB           uxtb    r3 r3
00000C  460A           mov     r2 r1
00000E  6013           str     r3 [r2]
000010  2300           movs    r3 0
000012  6053           str     r3 [r2+4]
```
There seem to be 2 distinct issues:
* This is a zero extending cast from U4 to I8. Neither `movsx` nor `uxtb` make sense in this context. Sign extending from I1 to I4 is the job of the load.
* For the same cast node x86 and ARM32 emit different instructions one sign extends and the other zero extends. One of them is wrong but probably that's a side effect of the unusual cast - the IL equivalent of that cast would be `conv.i1.un` but that does not exist. On x86 `movsx` hides the issue since is sign extends again the byte previously loaded.

Found while adding tests for #12676. Test coverage for casts seems to be lacking I keep running into bugs (either existing or of my own doing) and existing tests fail to catch them so I generated some. This case failed on ARM32 but not on x86.</Description>
    <Title_Description>Broken conv.ovf.i8.un decomposition IL sample:
```
ldind.i1
conv.ovf.i8.un
```
IR post decomposition:
```
N001 (  1  1) [000002] -------------        t2 =    LCL_VAR   byref  V00 arg0         u:2 (last use) $80
                                                  /--*  t2     byref  
N002 (  4  3) [000003] *--XG--------        t3 = *  IND       byte   &lt;l:$140 c:$180&gt;
                                                  /--*  t3     byte   
               [000012] ---XG----U---       t12 = *  CAST      int &lt;- byte &lt;- uint
               [000013] -------------       t13 =    CNS_INT   int    0
                                                  /--*  t12    int    
                                                  +--*  t13    int    
               [000014] ---XG--------       t14 = *  LONG      long  
```
x86 generated code:
```asm
       0FBE01       movsx    eax byte  ptr [ecx]
       0FBEC0       movsx    eax al
       8902         mov      dword ptr [edx] eax
       33C0         xor      eax eax
       894204       mov      dword ptr [edx+4] eax
```
ARM32 generated code:
```asm
000006  F990 3000      ldrsb   r3 [r0]
00000A  B2DB           uxtb    r3 r3
00000C  460A           mov     r2 r1
00000E  6013           str     r3 [r2]
000010  2300           movs    r3 0
000012  6053           str     r3 [r2+4]
```
There seem to be 2 distinct issues:
* This is a zero extending cast from U4 to I8. Neither `movsx` nor `uxtb` make sense in this context. Sign extending from I1 to I4 is the job of the load.
* For the same cast node x86 and ARM32 emit different instructions one sign extends and the other zero extends. One of them is wrong but probably that's a side effect of the unusual cast - the IL equivalent of that cast would be `conv.i1.un` but that does not exist. On x86 `movsx` hides the issue since is sign extends again the byte previously loaded.

Found while adding tests for #12676. Test coverage for casts seems to be lacking I keep running into bugs (either existing or of my own doing) and existing tests fail to catch them so I generated some. This case failed on ARM32 but not on x86.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
    <CreatedAt>18/05/2018 6:37:04 AM +00:00</CreatedAt>
    <ClosedAt>7/06/2018 5:19:00 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18039</IssueLabelID>
    <Title>JIT: assert when jitting Sse2.MoveScalar(Vector128&lt;long&gt;)</Title>
    <Description>```C#
using System;
using System.Runtime.Intrinsics;
using System.Runtime.Intrinsics.X86;

class X
{
    public static int Main()
    {
        Vector128&lt;long&gt; x = new Vector128&lt;long&gt;();
        Vector128&lt;long&gt; y = Sse2.MoveScalar(x);

        return 100;
    }
}
```
Running this on a CHECK build:
```
Assert failure(PID 22072 [0x00005638] Thread: 27064 [0x69b8]): 
Assertion failed 'insOfHWIntrinsic(intrinsic baseType) != INS_invalid' 
in 'X:Main():int' (IL size 18)

    File: d:\repos\coreclr\src\jit\hwintrinsicxarch.cpp Line: 816
    Image: D:\repos\coreclr\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root\CoreRun.exe
```
</Description>
    <Title_Description>JIT: assert when jitting Sse2.MoveScalar(Vector128&lt;long&gt;) ```C#
using System;
using System.Runtime.Intrinsics;
using System.Runtime.Intrinsics.X86;

class X
{
    public static int Main()
    {
        Vector128&lt;long&gt; x = new Vector128&lt;long&gt;();
        Vector128&lt;long&gt; y = Sse2.MoveScalar(x);

        return 100;
    }
}
```
Running this on a CHECK build:
```
Assert failure(PID 22072 [0x00005638] Thread: 27064 [0x69b8]): 
Assertion failed 'insOfHWIntrinsic(intrinsic baseType) != INS_invalid' 
in 'X:Main():int' (IL size 18)

    File: d:\repos\coreclr\src\jit\hwintrinsicxarch.cpp Line: 816
    Image: D:\repos\coreclr\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root\CoreRun.exe
```
</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
    <CreatedAt>18/05/2018 12:39:24 AM +00:00</CreatedAt>
    <ClosedAt>1/06/2018 11:57:00 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18037</IssueLabelID>
    <Title>Extra stloc and ldloc in switch statement compared to if statement</Title>
    <Description>I noticed an extra stloc and ldloc in the following switch statement compared to the equivalent if statement (this is just a shortened version of a longer and nested statement).
The il and disassembly looks pretty much the same except for the ``stloc.0`` and ``ldloc.0`` in the switch version which adds an extra ``mov`` to a register and then compares the register against the value instead of doing a direct memory location compare against the value (like in the if version).
I looked for other bugs similar to this but couldn't find anything specific.

The disassembly produced by benchmark.net looks like the following (including source and il annotation):
**If**
```asm
00007ffe`f18327b0 ConsoleApp23.LookupBenchmark.If()
            if (Bytes[2] == (byte)'l')
            ^^^^^^^^^^^^^^^^^^^^^^^^^^
IL_0000: ldsfld System.Byte[] ConsoleApp23.LookupBenchmark::Bytes
IL_0005: ldc.i4.2
IL_0006: ldelem.u1
IL_0007: ldc.i4.s 108
IL_0009: bne.un.s IL_000d
00007ffe`f18327b4 48b900f98df1fe7f0000 mov rcx7FFEF18DF900h
00007ffe`f18327be ba06000000      mov     edx6
00007ffe`f18327c3 e828e4ab5f      call    coreclr!coreclr_shutdown_2+0x39680 (00007fff`512f0bf0)
00007ffe`f18327c8 48b8386d0010a9020000 mov rax2A910006D38h
00007ffe`f18327d2 488b00          mov     raxqword ptr [rax]
00007ffe`f18327d5 83780802        cmp     dword ptr [rax+8]2
00007ffe`f18327d9 7617            jbe     00007ffe`f18327f2
00007ffe`f18327db 8078126c        cmp     byte ptr [rax+12h]6Ch
00007ffe`f18327df 750a            jne     00007ffe`f18327eb
                return 1;
                ^^^^^^^^^
IL_000b: ldc.i4.1
IL_000c: ret
00007ffe`f18327e1 b801000000      mov     eax1
00007ffe`f18327e6 4883c428        add     rsp28h
00007ffe`f18327ea c3              ret
            return 0;
            ^^^^^^^^^
IL_000d: ldc.i4.0
IL_000e: ret
00007ffe`f18327eb 33c0            xor     eaxeax

```
**Switch** 
```asm
00007ffe`f18327b0 ConsoleApp23.LookupBenchmark.Switch()
            switch (Bytes[2])
            ^^^^^^^^^^^^^^^^^
IL_0000: ldsfld System.Byte[] ConsoleApp23.LookupBenchmark::Bytes
IL_0005: ldc.i4.2
IL_0006: ldelem.u1
IL_0007: stloc.0
00007ffe`f18327b4 48b900f98df1fe7f0000 mov rcx7FFEF18DF900h
00007ffe`f18327be ba06000000      mov     edx6
00007ffe`f18327c3 e828e4ab5f      call    coreclr!coreclr_shutdown_2+0x39680 (00007fff`512f0bf0)
00007ffe`f18327c8 48b8386d265871020000 mov rax27158266D38h
00007ffe`f18327d2 488b00          mov     raxqword ptr [rax]
00007ffe`f18327d5 83780802        cmp     dword ptr [rax+8]2
00007ffe`f18327d9 761a            jbe     00007ffe`f18327f5
00007ffe`f18327db 0fb64012        movzx   eaxbyte ptr [rax+12h]
                    return 1;
                    ^^^^^^^^^
IL_0008: ldloc.0
IL_0009: ldc.i4.s 108
IL_000b: bne.un.s IL_000f
00007ffe`f18327df 83f86c          cmp     eax6Ch
00007ffe`f18327e2 750a            jne     00007ffe`f18327ee
IL_000d: ldc.i4.1
IL_000e: ret
00007ffe`f18327e4 b801000000      mov     eax1
00007ffe`f18327e9 4883c428        add     rsp28h
00007ffe`f18327ed c3              ret
            return 0;
            ^^^^^^^^^
IL_000f: ldc.i4.0
IL_0010: ret
00007ffe`f18327ee 33c0            xor     eaxeax

```

&lt;details&gt;

```csharp
private static readonly byte[] Bytes = Encoding.UTF8.GetBytes("Hello");

[Benchmark]
public int If()
{
    if (Bytes[2] == (byte)'l')
    {
        return 1;
    }

    return 0;
}

[Benchmark]
public int Switch()
{
    switch (Bytes[2])
    {
        case (byte)'l':
        {
            return 1;
        }
    }

    return 0;
}
```
&lt;/details&gt;
category:cq
theme:basic-cq
skill-level:beginner
cost:small</Description>
    <Title_Description>Extra stloc and ldloc in switch statement compared to if statement I noticed an extra stloc and ldloc in the following switch statement compared to the equivalent if statement (this is just a shortened version of a longer and nested statement).
The il and disassembly looks pretty much the same except for the ``stloc.0`` and ``ldloc.0`` in the switch version which adds an extra ``mov`` to a register and then compares the register against the value instead of doing a direct memory location compare against the value (like in the if version).
I looked for other bugs similar to this but couldn't find anything specific.

The disassembly produced by benchmark.net looks like the following (including source and il annotation):
**If**
```asm
00007ffe`f18327b0 ConsoleApp23.LookupBenchmark.If()
            if (Bytes[2] == (byte)'l')
            ^^^^^^^^^^^^^^^^^^^^^^^^^^
IL_0000: ldsfld System.Byte[] ConsoleApp23.LookupBenchmark::Bytes
IL_0005: ldc.i4.2
IL_0006: ldelem.u1
IL_0007: ldc.i4.s 108
IL_0009: bne.un.s IL_000d
00007ffe`f18327b4 48b900f98df1fe7f0000 mov rcx7FFEF18DF900h
00007ffe`f18327be ba06000000      mov     edx6
00007ffe`f18327c3 e828e4ab5f      call    coreclr!coreclr_shutdown_2+0x39680 (00007fff`512f0bf0)
00007ffe`f18327c8 48b8386d0010a9020000 mov rax2A910006D38h
00007ffe`f18327d2 488b00          mov     raxqword ptr [rax]
00007ffe`f18327d5 83780802        cmp     dword ptr [rax+8]2
00007ffe`f18327d9 7617            jbe     00007ffe`f18327f2
00007ffe`f18327db 8078126c        cmp     byte ptr [rax+12h]6Ch
00007ffe`f18327df 750a            jne     00007ffe`f18327eb
                return 1;
                ^^^^^^^^^
IL_000b: ldc.i4.1
IL_000c: ret
00007ffe`f18327e1 b801000000      mov     eax1
00007ffe`f18327e6 4883c428        add     rsp28h
00007ffe`f18327ea c3              ret
            return 0;
            ^^^^^^^^^
IL_000d: ldc.i4.0
IL_000e: ret
00007ffe`f18327eb 33c0            xor     eaxeax

```
**Switch** 
```asm
00007ffe`f18327b0 ConsoleApp23.LookupBenchmark.Switch()
            switch (Bytes[2])
            ^^^^^^^^^^^^^^^^^
IL_0000: ldsfld System.Byte[] ConsoleApp23.LookupBenchmark::Bytes
IL_0005: ldc.i4.2
IL_0006: ldelem.u1
IL_0007: stloc.0
00007ffe`f18327b4 48b900f98df1fe7f0000 mov rcx7FFEF18DF900h
00007ffe`f18327be ba06000000      mov     edx6
00007ffe`f18327c3 e828e4ab5f      call    coreclr!coreclr_shutdown_2+0x39680 (00007fff`512f0bf0)
00007ffe`f18327c8 48b8386d265871020000 mov rax27158266D38h
00007ffe`f18327d2 488b00          mov     raxqword ptr [rax]
00007ffe`f18327d5 83780802        cmp     dword ptr [rax+8]2
00007ffe`f18327d9 761a            jbe     00007ffe`f18327f5
00007ffe`f18327db 0fb64012        movzx   eaxbyte ptr [rax+12h]
                    return 1;
                    ^^^^^^^^^
IL_0008: ldloc.0
IL_0009: ldc.i4.s 108
IL_000b: bne.un.s IL_000f
00007ffe`f18327df 83f86c          cmp     eax6Ch
00007ffe`f18327e2 750a            jne     00007ffe`f18327ee
IL_000d: ldc.i4.1
IL_000e: ret
00007ffe`f18327e4 b801000000      mov     eax1
00007ffe`f18327e9 4883c428        add     rsp28h
00007ffe`f18327ed c3              ret
            return 0;
            ^^^^^^^^^
IL_000f: ldc.i4.0
IL_0010: ret
00007ffe`f18327ee 33c0            xor     eaxeax

```

&lt;details&gt;

```csharp
private static readonly byte[] Bytes = Encoding.UTF8.GetBytes("Hello");

[Benchmark]
public int If()
{
    if (Bytes[2] == (byte)'l')
    {
        return 1;
    }

    return 0;
}

[Benchmark]
public int Switch()
{
    switch (Bytes[2])
    {
        case (byte)'l':
        {
            return 1;
        }
    }

    return 0;
}
```
&lt;/details&gt;
category:cq
theme:basic-cq
skill-level:beginner
cost:small</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>17/05/2018 10:12:53 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18034</IssueLabelID>
    <Title>[Arm64] System.Reflection.Emit.Tests.TypeBuilderIsGenericTypeDefinition.IsGenericTypeDefinition_GenericType_ReturnsTrue [FAIL]</Title>
    <Description>This is a recent regression on tip.
```
corerun xunit.console.netcore.exe System.Reflection.Emit.Tests.dll -xml testResults.xml -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonlinuxtests -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing
xUnit.net console test runner (64-bit .NET Core)
Copyright (C) 2014 Outercurve Foundation.

Discovering: System.Reflection.Emit.Tests
Discovered:  System.Reflection.Emit.Tests
Starting:    System.Reflection.Emit.Tests
   System.Reflection.Emit.Tests.TypeBuilderIsGenericTypeDefinition.IsGenericTypeDefinition_GenericType_ReturnsTrue [FAIL]
      System.NotSupportedException : The invoked member is not supported before the type is created.
      Stack Trace:
            at System.Reflection.Emit.TypeBuilder.GetConstructorImpl(BindingFlags bindingAttr Binder binder CallingConventions callConvention Type[] types ParameterModifier[] modifiers)
            at System.Type.GetConstructor(BindingFlags bindingAttr Binder binder CallingConventions callConvention Type[] types ParameterModifier[] modifiers)
            at System.Reflection.Emit.ConstructorBuilder.GetParameters()
            at System.Reflection.Emit.ModuleBuilder.GetMemberRefToken(MethodBase method IEnumerable`1 optionalParameterTypes)
            at System.Reflection.Emit.ModuleBuilder.GetMethodTokenInternal(MethodBase method IEnumerable`1 optionalParameterTypes Boolean useMethodDef)
            at System.Reflection.Emit.ILGenerator.GetMethodToken(MethodBase method Type[] optionalParameterTypes Boolean useMethodDef)
            at System.Reflection.Emit.ILGenerator.Emit(OpCode opcode ConstructorInfo con)
```         
</Description>
    <Title_Description>[Arm64] System.Reflection.Emit.Tests.TypeBuilderIsGenericTypeDefinition.IsGenericTypeDefinition_GenericType_ReturnsTrue [FAIL] This is a recent regression on tip.
```
corerun xunit.console.netcore.exe System.Reflection.Emit.Tests.dll -xml testResults.xml -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonlinuxtests -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing
xUnit.net console test runner (64-bit .NET Core)
Copyright (C) 2014 Outercurve Foundation.

Discovering: System.Reflection.Emit.Tests
Discovered:  System.Reflection.Emit.Tests
Starting:    System.Reflection.Emit.Tests
   System.Reflection.Emit.Tests.TypeBuilderIsGenericTypeDefinition.IsGenericTypeDefinition_GenericType_ReturnsTrue [FAIL]
      System.NotSupportedException : The invoked member is not supported before the type is created.
      Stack Trace:
            at System.Reflection.Emit.TypeBuilder.GetConstructorImpl(BindingFlags bindingAttr Binder binder CallingConventions callConvention Type[] types ParameterModifier[] modifiers)
            at System.Type.GetConstructor(BindingFlags bindingAttr Binder binder CallingConventions callConvention Type[] types ParameterModifier[] modifiers)
            at System.Reflection.Emit.ConstructorBuilder.GetParameters()
            at System.Reflection.Emit.ModuleBuilder.GetMemberRefToken(MethodBase method IEnumerable`1 optionalParameterTypes)
            at System.Reflection.Emit.ModuleBuilder.GetMethodTokenInternal(MethodBase method IEnumerable`1 optionalParameterTypes Boolean useMethodDef)
            at System.Reflection.Emit.ILGenerator.GetMethodToken(MethodBase method Type[] optionalParameterTypes Boolean useMethodDef)
            at System.Reflection.Emit.ILGenerator.Emit(OpCode opcode ConstructorInfo con)
```         
</Title_Description>
    <Label>area-System.Reflection</Label>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18033</IssueLabelID>
    <Title>JIT: examine need for canInlineTypeCheckWithObjectVTable</Title>
    <Description>When the jit is optimizing type equality and inequality tests it may run into the following case:
```
    object.GetType() == typeof(X)
```
This can usually be optimized into a comparison of the object's method table pointer versus a known method table address. But historically that has not always been a valid optimization. So the jit calls `canInlineTypeCheckWithObjectVTable` to identify the cases where the optimization is valid.

https://github.com/dotnet/coreclr/blob/3c01252879f2d2223f63d5b222b6584c28fc07f4/src/jit/gentree.cpp#L13141-L13147

Per Jan's comments in #18005 it seems in CoreCLR this optimization is likely always valid and the check is no longer needed.

category:cq
theme:basic-cq
skill-level:intermediate
cost:small</Description>
    <Title_Description>JIT: examine need for canInlineTypeCheckWithObjectVTable When the jit is optimizing type equality and inequality tests it may run into the following case:
```
    object.GetType() == typeof(X)
```
This can usually be optimized into a comparison of the object's method table pointer versus a known method table address. But historically that has not always been a valid optimization. So the jit calls `canInlineTypeCheckWithObjectVTable` to identify the cases where the optimization is valid.

https://github.com/dotnet/coreclr/blob/3c01252879f2d2223f63d5b222b6584c28fc07f4/src/jit/gentree.cpp#L13141-L13147

Per Jan's comments in #18005 it seems in CoreCLR this optimization is likely always valid and the check is no longer needed.

category:cq
theme:basic-cq
skill-level:intermediate
cost:small</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
    <CreatedAt>17/05/2018 5:50:45 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18031</IssueLabelID>
    <Title>[JIT/ARM] Fix Compiler::lvaFrameAddress</Title>
    <Description>Use sp-based offset only if r10 reserved or offset is lower than encoding limit.

Fixes https://github.com/dotnet/coreclr/issues/17882</Description>
    <Title_Description>[JIT/ARM] Fix Compiler::lvaFrameAddress Use sp-based offset only if r10 reserved or offset is lower than encoding limit.

Fixes https://github.com/dotnet/coreclr/issues/17882</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>alpencolt</Assignee>
    <CreatedAt>17/05/2018 2:45:38 PM +00:00</CreatedAt>
    <ClosedAt>21/06/2018 3:57:45 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18030</IssueLabelID>
    <Title>Possible Bug: Complete lock-up in ASP.NET Core startup due to StubHelpers?</Title>
    <Description>Hi all

This is potentially a difficult issue to track down. I have been developing with ASP.NET Core for a few months now and (very) rarely the application locks-up completely during start up. I am currently running version 2.1.101 but don't recall which version I was running when I first encountered this issue. The time between manifestations is measured in weeks. I assume this is some kind of unlucky race condition.

I captured this screenshot from the latest occurrence. The lock-up always occurs within WebHostBuilder.Build(). The rest of the stack trace might be variable because this is the first time I've had a proper look at it.

In this instance the code appears to be stuck in StubHelpers.AddToCleanupList (hence why I am posting this here). Resuming the application has no effect. We remain stuck in the same place. I need to restart the application to get past this point. 

![image](https://user-images.githubusercontent.com/16805881/40167385-cecbed26-59b8-11e8-8b6c-e57aef1681ac.png)</Description>
    <Title_Description>Possible Bug: Complete lock-up in ASP.NET Core startup due to StubHelpers? Hi all

This is potentially a difficult issue to track down. I have been developing with ASP.NET Core for a few months now and (very) rarely the application locks-up completely during start up. I am currently running version 2.1.101 but don't recall which version I was running when I first encountered this issue. The time between manifestations is measured in weeks. I assume this is some kind of unlucky race condition.

I captured this screenshot from the latest occurrence. The lock-up always occurs within WebHostBuilder.Build(). The rest of the stack trace might be variable because this is the first time I've had a proper look at it.

In this instance the code appears to be stuck in StubHelpers.AddToCleanupList (hence why I am posting this here). Resuming the application has no effect. We remain stuck in the same place. I need to restart the application to get past this point. 

![image](https://user-images.githubusercontent.com/16805881/40167385-cecbed26-59b8-11e8-8b6c-e57aef1681ac.png)</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>cshung</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18026</IssueLabelID>
    <Title>[Arm64/Linux] Stabilize SDK</Title>
    <Description>#17933 will be fixed by #17991 

Using a variant of the patch in #17991 I was able to bootstrap build a linux-arm64 cli/sdk based on 2.1.300-rtm-008820.  To check stability I tried to use it to build coreclr natively.

```
export COMPlus_ZapDisable=1
cd git/coreclr
git clean -x -d -f
export DotNetBootstrapCliTarPath=/home/sdmaclea/dotnetcli-2.1.300-rtm-008820-linux-arm64-qdt.tgz
./init-tools.sh
./build.sh -msbuildonunsupportedplatform -nopgooptimize
```

It is not clear to me why ZapDisable=1 is needed.  This could be due to a bug in the buildbootstrap script my bootstrap build process or in the usage of init-tools.sh with arm64.  I am assuming this is a side effect of the build bootstrap process.  

The build sequence above more often than not fails.  The typical failure looks a lot like the thread pool memory ordering race conditions fixed by #17567.  FYI @kouvel @stephentoub 

For instance
```
No antecedent was set for the ContinuationTaskFromTask.

   at System.Threading.Tasks.ContinuationTaskFromTask.InnerInvoke()
   at System.Threading.Tasks.Task.&lt;&gt;c.&lt;.cctor&gt;b__278_1(Object obj)
   at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext ContextCallback callback Object state)
   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(Task&amp; currentTaskSlot)
   at System.Threading.Tasks.Task.ExecuteEntryUnsafe()
   at System.Threading.Tasks.Task.System.Threading.IThreadPoolWorkItem.ExecuteWorkItem()
   at System.Threading.ThreadPoolWorkQueue.Dispatch()
   at System.Threading._ThreadPoolWaitCallback.PerformWaitCallback()
```

```
Unhandled Exception: System.InvalidCastException: Unable to cast object of type 'System.Object' to type 'System.Collections.Generic.List`1[System.Object]'.
   at System.Threading.Tasks.Task.RunContinuations(Object continuationObject)
   at System.Threading.Tasks.Task.FinishContinuations()
   at System.Threading.Tasks.Task.FinishStageThree()
   at System.Threading.Tasks.Task.FinishStageTwo()
   at System.Threading.Tasks.Task.FinishSlow(Boolean userDelegateExecute)
   at System.Threading.Tasks.Task.Finish(Boolean userDelegateExecute)
   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(Task&amp; currentTaskSlot)
   at System.Threading.Tasks.Task.ExecuteEntryUnsafe()
   at System.Threading.Tasks.Task.System.Threading.IThreadPoolWorkItem.ExecuteWorkItem()
   at System.Threading.ThreadPoolWorkQueue.Dispatch()
   at System.Threading._ThreadPoolWaitCallback.PerformWaitCallback()
```
```
Assertion Failed
Null action in InnerInvoke()

   at System.Threading.Tasks.Task.InnerInvoke()
   at System.Threading.Tasks.Task.&lt;&gt;c.&lt;.cctor&gt;b__278_1(Object obj)
   at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext ContextCallback callback Object state)
   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(Task&amp; currentTaskSlot)
   at System.Threading.Tasks.Task.ExecuteEntryUnsafe()
   at System.Threading.Tasks.Task.System.Threading.IThreadPoolWorkItem.ExecuteWorkItem()
   at System.Threading.ThreadPoolWorkQueue.Dispatch()
   at System.Threading._ThreadPoolWaitCallback.PerformWaitCallback()
```

</Description>
    <Title_Description>[Arm64/Linux] Stabilize SDK #17933 will be fixed by #17991 

Using a variant of the patch in #17991 I was able to bootstrap build a linux-arm64 cli/sdk based on 2.1.300-rtm-008820.  To check stability I tried to use it to build coreclr natively.

```
export COMPlus_ZapDisable=1
cd git/coreclr
git clean -x -d -f
export DotNetBootstrapCliTarPath=/home/sdmaclea/dotnetcli-2.1.300-rtm-008820-linux-arm64-qdt.tgz
./init-tools.sh
./build.sh -msbuildonunsupportedplatform -nopgooptimize
```

It is not clear to me why ZapDisable=1 is needed.  This could be due to a bug in the buildbootstrap script my bootstrap build process or in the usage of init-tools.sh with arm64.  I am assuming this is a side effect of the build bootstrap process.  

The build sequence above more often than not fails.  The typical failure looks a lot like the thread pool memory ordering race conditions fixed by #17567.  FYI @kouvel @stephentoub 

For instance
```
No antecedent was set for the ContinuationTaskFromTask.

   at System.Threading.Tasks.ContinuationTaskFromTask.InnerInvoke()
   at System.Threading.Tasks.Task.&lt;&gt;c.&lt;.cctor&gt;b__278_1(Object obj)
   at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext ContextCallback callback Object state)
   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(Task&amp; currentTaskSlot)
   at System.Threading.Tasks.Task.ExecuteEntryUnsafe()
   at System.Threading.Tasks.Task.System.Threading.IThreadPoolWorkItem.ExecuteWorkItem()
   at System.Threading.ThreadPoolWorkQueue.Dispatch()
   at System.Threading._ThreadPoolWaitCallback.PerformWaitCallback()
```

```
Unhandled Exception: System.InvalidCastException: Unable to cast object of type 'System.Object' to type 'System.Collections.Generic.List`1[System.Object]'.
   at System.Threading.Tasks.Task.RunContinuations(Object continuationObject)
   at System.Threading.Tasks.Task.FinishContinuations()
   at System.Threading.Tasks.Task.FinishStageThree()
   at System.Threading.Tasks.Task.FinishStageTwo()
   at System.Threading.Tasks.Task.FinishSlow(Boolean userDelegateExecute)
   at System.Threading.Tasks.Task.Finish(Boolean userDelegateExecute)
   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(Task&amp; currentTaskSlot)
   at System.Threading.Tasks.Task.ExecuteEntryUnsafe()
   at System.Threading.Tasks.Task.System.Threading.IThreadPoolWorkItem.ExecuteWorkItem()
   at System.Threading.ThreadPoolWorkQueue.Dispatch()
   at System.Threading._ThreadPoolWaitCallback.PerformWaitCallback()
```
```
Assertion Failed
Null action in InnerInvoke()

   at System.Threading.Tasks.Task.InnerInvoke()
   at System.Threading.Tasks.Task.&lt;&gt;c.&lt;.cctor&gt;b__278_1(Object obj)
   at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext ContextCallback callback Object state)
   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(Task&amp; currentTaskSlot)
   at System.Threading.Tasks.Task.ExecuteEntryUnsafe()
   at System.Threading.Tasks.Task.System.Threading.IThreadPoolWorkItem.ExecuteWorkItem()
   at System.Threading.ThreadPoolWorkQueue.Dispatch()
   at System.Threading._ThreadPoolWaitCallback.PerformWaitCallback()
```

</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>kouvel</Assignee>
    <CreatedAt>16/05/2018 8:50:13 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18025</IssueLabelID>
    <Title>Mirror changes from dotnet/corefx</Title>
    <Description>This PR contains mirrored changes from dotnet/corefx


**Please REBASE this PR when merging**</Description>
    <Title_Description>Mirror changes from dotnet/corefx This PR contains mirrored changes from dotnet/corefx


**Please REBASE this PR when merging**</Title_Description>
    <Label>
    </Label>
    <Assignee>stephentoub</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18024</IssueLabelID>
    <Title>Making IProducerConsumerCollectionDebugView APIs public</Title>
    <Description>Moving ConcurrentQueue to shared

Applying code review feedbacks: 

1- Making IProducerConsumerCollectionDebugView apis public

2- Renaming 
- Segment to ConcurrentQueueSegment. 
- ProducerConsumerCollectionDebugView  to IProducerConsumerCollectionDebugView 

Fixes: #17751

cc: @jkotas @stephentoub @danmosemsft @safern </Description>
    <Title_Description>Making IProducerConsumerCollectionDebugView APIs public Moving ConcurrentQueue to shared

Applying code review feedbacks: 

1- Making IProducerConsumerCollectionDebugView apis public

2- Renaming 
- Segment to ConcurrentQueueSegment. 
- ProducerConsumerCollectionDebugView  to IProducerConsumerCollectionDebugView 

Fixes: #17751

cc: @jkotas @stephentoub @danmosemsft @safern </Title_Description>
    <Label>area-System.Collections</Label>
    <Assignee>maryamariyan</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18022</IssueLabelID>
    <Title>Suboptimal codegen when comparing sbyte and 16-bit values</Title>
    <Description>I have the following two repro methods along with their x64 codegen using the latest RyuJIT.

```cs
[MethodImpl(MethodImplOptions.NoInlining)]
public static bool MethodFoo(byte x)
{
    return ((byte)x &lt; 128);
}
```

```asm
ConsoleApp12!ConsoleApp12.Program.MethodFoo(Byte):
00007ffe`2cb01630 80f980          cmp     cl80h
00007ffe`2cb01633 0f92c0          setb    al
00007ffe`2cb01636 0fb6c0          movzx   eaxal
00007ffe`2cb01639 c3              ret
```

```cs
[MethodImpl(MethodImplOptions.NoInlining)]
public static bool MethodBar(byte x)
{
    return ((sbyte)x &lt; -64);
}
```

```asm
ConsoleApp12!ConsoleApp12.Program.MethodBar(Byte):
00007ffe`2cb01650 0fb6c1          movzx   eaxcl
00007ffe`2cb01653 480fbec0        movsx   raxal
00007ffe`2cb01657 83f8c0          cmp     eax0FFFFFFC0h
00007ffe`2cb0165a 0f9cc0          setl    al
00007ffe`2cb0165d 0fb6c0          movzx   eaxal
00007ffe`2cb01660 c3              ret
```

The _Foo_ method checks to see if the high bit is clear and the _Bar_ method checks to see if the byte has input pattern `10xxxxxx`. These are both common operations when performing UTF-8 text processing. In the examples above the _Bar_ method has suboptimal codegen. I would instead expect the codegen to be the following.

```asm
cmp     clC0h
setl    al
movzx   eaxal
ret
```
category:cq
theme:basic-cq
skill-level:intermediate
cost:small
</Description>
    <Title_Description>Suboptimal codegen when comparing sbyte and 16-bit values I have the following two repro methods along with their x64 codegen using the latest RyuJIT.

```cs
[MethodImpl(MethodImplOptions.NoInlining)]
public static bool MethodFoo(byte x)
{
    return ((byte)x &lt; 128);
}
```

```asm
ConsoleApp12!ConsoleApp12.Program.MethodFoo(Byte):
00007ffe`2cb01630 80f980          cmp     cl80h
00007ffe`2cb01633 0f92c0          setb    al
00007ffe`2cb01636 0fb6c0          movzx   eaxal
00007ffe`2cb01639 c3              ret
```

```cs
[MethodImpl(MethodImplOptions.NoInlining)]
public static bool MethodBar(byte x)
{
    return ((sbyte)x &lt; -64);
}
```

```asm
ConsoleApp12!ConsoleApp12.Program.MethodBar(Byte):
00007ffe`2cb01650 0fb6c1          movzx   eaxcl
00007ffe`2cb01653 480fbec0        movsx   raxal
00007ffe`2cb01657 83f8c0          cmp     eax0FFFFFFC0h
00007ffe`2cb0165a 0f9cc0          setl    al
00007ffe`2cb0165d 0fb6c0          movzx   eaxal
00007ffe`2cb01660 c3              ret
```

The _Foo_ method checks to see if the high bit is clear and the _Bar_ method checks to see if the byte has input pattern `10xxxxxx`. These are both common operations when performing UTF-8 text processing. In the examples above the _Bar_ method has suboptimal codegen. I would instead expect the codegen to be the following.

```asm
cmp     clC0h
setl    al
movzx   eaxal
ret
```
category:cq
theme:basic-cq
skill-level:intermediate
cost:small
</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>16/05/2018 5:53:08 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18019</IssueLabelID>
    <Title>Proposal - Incorporate deadlock detection into the CLR.</Title>
    <Description>Given that the `lock `keyword simply "wraps" a critical section and critical sections are confined to a single process it strikes me as possible - in principle - for the CLR to be able to perform a kind of deadlock detection.

It could do this when any thread attempts to acquire a `lock `by examining if the calling thread currently owns any other `locks `and then for each of those examine if any of these are being waited for by any other thread.

It could then abort the attempted lockwith some specific `DeadlockException` or something.

Because critical sections are process wide it does beg the question in my mind about if it is possible for two `AppDomains `(in the same process) to ever share a `lock` I suspect this isn't ordinarily something one would design though.

The proof of concept could just be a small API that wraps the Monitor class and maintains the data structures necessary to track `lock `ownership by threads. The API would manage a static tree/list (that is itself thread safe) that records which threads currently hold which `locks`. Given the potential performance impact this could be something that is enabled/disabled at runtime at the `AppDomain `level.

The algorithm is then to deny a request from thread X to acquire a `lock `if doing so would lead to a hang because some other thread is trying to acquire a `lock `already held by thread X. The key observation here being that any thread that has `locks `held and is waiting for some other `lock `- by definition - cannot release the `locks `it already holds.

The `exception `that would be thrown could contain metadata describing why a deadlock was detected which is far better than seeing an `AppDomain `simply freeze.

The ultimate benefit is not that deadlocks would be eliminated but that they could be detected at the instant they arise and used during testing or when attempting to reproduce a deadlock that has been reported in an app or class library.

Thoughts?</Description>
    <Title_Description>Proposal - Incorporate deadlock detection into the CLR. Given that the `lock `keyword simply "wraps" a critical section and critical sections are confined to a single process it strikes me as possible - in principle - for the CLR to be able to perform a kind of deadlock detection.

It could do this when any thread attempts to acquire a `lock `by examining if the calling thread currently owns any other `locks `and then for each of those examine if any of these are being waited for by any other thread.

It could then abort the attempted lockwith some specific `DeadlockException` or something.

Because critical sections are process wide it does beg the question in my mind about if it is possible for two `AppDomains `(in the same process) to ever share a `lock` I suspect this isn't ordinarily something one would design though.

The proof of concept could just be a small API that wraps the Monitor class and maintains the data structures necessary to track `lock `ownership by threads. The API would manage a static tree/list (that is itself thread safe) that records which threads currently hold which `locks`. Given the potential performance impact this could be something that is enabled/disabled at runtime at the `AppDomain `level.

The algorithm is then to deny a request from thread X to acquire a `lock `if doing so would lead to a hang because some other thread is trying to acquire a `lock `already held by thread X. The key observation here being that any thread that has `locks `held and is waiting for some other `lock `- by definition - cannot release the `locks `it already holds.

The `exception `that would be thrown could contain metadata describing why a deadlock was detected which is far better than seeing an `AppDomain `simply freeze.

The ultimate benefit is not that deadlocks would be eliminated but that they could be detected at the instant they arise and used during testing or when attempting to reproduce a deadlock that has been reported in an app or class library.

Thoughts?</Title_Description>
    <Label>Design Discussion</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>16/05/2018 3:25:34 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18016</IssueLabelID>
    <Title>Allow partial loop-unrolling for JIT(optUnrollLoops)</Title>
    <Description>https://github.com/dotnet/coreclr/issues/11606

following methods will be fixed.
1. Support non-vector unrolling.
2. Support partial unrolling. and threshold.
3. Support unsafe array access unrolling.</Description>
    <Title_Description>Allow partial loop-unrolling for JIT(optUnrollLoops) https://github.com/dotnet/coreclr/issues/11606

following methods will be fixed.
1. Support non-vector unrolling.
2. Support partial unrolling. and threshold.
3. Support unsafe array access unrolling.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
    <CreatedAt>16/05/2018 3:52:12 AM +00:00</CreatedAt>
    <ClosedAt>25/06/2018 7:22:18 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18014</IssueLabelID>
    <Title>Add mixed-mode Book of the Runtime entry</Title>
    <Description>Adds a Book of the Runtime entry to document how mixed-mode assemblies are specified and work in general. This is not a design for how it will be integrated into .NET Core (that will be done separately). 

Progress toward #18013 </Description>
    <Title_Description>Add mixed-mode Book of the Runtime entry Adds a Book of the Runtime entry to document how mixed-mode assemblies are specified and work in general. This is not a design for how it will be integrated into .NET Core (that will be done separately). 

Progress toward #18013 </Title_Description>
    <Label>documentation</Label>
    <Assignee>morganbr</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18013</IssueLabelID>
    <Title>Support mixed-mode assemblies on Windows</Title>
    <Description>This issue will track progress toward supporting loading and running mixed-mode assemblies on CoreCLR. The main goal is to provide support for WPF and other existing C++/CLI code on .NET Core. Some of the work will be dependent on updates to the MSVC compiler.

Steps include:
- [x] Documenting how mixed-mode assemblies work in general
- [x] Proposing a .NET Core design
- [x] Loading mixed-mode assemblies into running managed code
- [x] Starting the runtime from native code in mixed-mode assemblies

This is related to #659 but cross-platform support is outside of the scope of this issue as it's a compiler feature not a runtime feature.</Description>
    <Title_Description>Support mixed-mode assemblies on Windows This issue will track progress toward supporting loading and running mixed-mode assemblies on CoreCLR. The main goal is to provide support for WPF and other existing C++/CLI code on .NET Core. Some of the work will be dependent on updates to the MSVC compiler.

Steps include:
- [x] Documenting how mixed-mode assemblies work in general
- [x] Proposing a .NET Core design
- [x] Loading mixed-mode assemblies into running managed code
- [x] Starting the runtime from native code in mixed-mode assemblies

This is related to #659 but cross-platform support is outside of the scope of this issue as it's a compiler feature not a runtime feature.</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jkoritzinsky</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18005</IssueLabelID>
    <Title>ReadOnlySpan.CopyTo is surprisingly (relatively) expensive and doesn't inline</Title>
    <Description>Its mostly a wrapper on BufferMemmove with some checks
```
[FAILED: unprofitable inline] ReadOnlySpan`1:CopyTo(struct):this
```
![image](https://user-images.githubusercontent.com/1142958/40074205-f446ed1a-5870-11e8-8b2a-61b37db700c8.png)

First occurrence in `System.Private.CoreLib.dasm`
```asm
; Assembly listing for method ReadOnlySpan`1:CopyTo(struct):this
; Lcl frame size = 48
G_M47339_IG01:
       push     rdi
       push     rsi
       push     rbx
       sub      rsp 48
       mov      qword ptr [rsp+28H] rdx
G_M47339_IG02:
       mov      eax dword ptr [rcx+8]
       mov      r9d eax
       mov      r10 qword ptr [rdx+48]
       mov      r10 qword ptr [r10]
       cmp      r9d dword ptr [r8+8]
       ja       SHORT G_M47339_IG05
       mov      rsi bword ptr [r8]
       mov      rcx bword ptr [rcx]
       mov      rdi rcx
       movsxd   rbx eax
       mov      rcx qword ptr [r10+64]
       test     rcx rcx
       jne      SHORT G_M47339_IG03
       mov      rcx rdx
       lea      rdx [(reloc)]
       call     CORINFO_HELP_RUNTIMEHANDLE_CLASS
       mov      rcx rax
G_M47339_IG03:
       mov      rdx rsi
       mov      r8 rdi
       mov      r9 rbx
       call     Buffer:Memmove(byrefbyreflong)
       nop      
G_M47339_IG04:
       add      rsp 48
       pop      rbx
       pop      rsi
       pop      rdi
       ret      
G_M47339_IG05:
       call     ThrowHelper:ThrowArgumentException_DestinationTooShort()
       int3     
; Total bytes of code 99 prolog size 12 for method ReadOnlySpan`1:CopyTo(struct):this
```
Second occurrence in `System.Private.CoreLib.dasm`
```asm
; Assembly listing for method ReadOnlySpan`1:CopyTo(struct):this
; Lcl frame size = 40
G_M648_IG01:
       sub      rsp 40
       nop      
G_M648_IG02:
       mov      r8d dword ptr [rcx+8]
       mov      eax r8d
       cmp      eax dword ptr [rdx+8]
       ja       SHORT G_M648_IG04
       mov      rdx bword ptr [rdx]
       mov      rax rdx
       mov      rdx bword ptr [rcx]
       movsxd   r8 r8d
       mov      rcx rax
       shl      r8 1
       call     Buffer:Memmove(structstructlong)
       nop      
G_M648_IG03:
       add      rsp 40
       ret      
G_M648_IG04:
       call     ThrowHelper:ThrowArgumentException_DestinationTooShort()
       int3     
; Total bytes of code 52 prolog size 5 for method ReadOnlySpan`1:CopyTo(struct):this
```</Description>
    <Title_Description>ReadOnlySpan.CopyTo is surprisingly (relatively) expensive and doesn't inline Its mostly a wrapper on BufferMemmove with some checks
```
[FAILED: unprofitable inline] ReadOnlySpan`1:CopyTo(struct):this
```
![image](https://user-images.githubusercontent.com/1142958/40074205-f446ed1a-5870-11e8-8b2a-61b37db700c8.png)

First occurrence in `System.Private.CoreLib.dasm`
```asm
; Assembly listing for method ReadOnlySpan`1:CopyTo(struct):this
; Lcl frame size = 48
G_M47339_IG01:
       push     rdi
       push     rsi
       push     rbx
       sub      rsp 48
       mov      qword ptr [rsp+28H] rdx
G_M47339_IG02:
       mov      eax dword ptr [rcx+8]
       mov      r9d eax
       mov      r10 qword ptr [rdx+48]
       mov      r10 qword ptr [r10]
       cmp      r9d dword ptr [r8+8]
       ja       SHORT G_M47339_IG05
       mov      rsi bword ptr [r8]
       mov      rcx bword ptr [rcx]
       mov      rdi rcx
       movsxd   rbx eax
       mov      rcx qword ptr [r10+64]
       test     rcx rcx
       jne      SHORT G_M47339_IG03
       mov      rcx rdx
       lea      rdx [(reloc)]
       call     CORINFO_HELP_RUNTIMEHANDLE_CLASS
       mov      rcx rax
G_M47339_IG03:
       mov      rdx rsi
       mov      r8 rdi
       mov      r9 rbx
       call     Buffer:Memmove(byrefbyreflong)
       nop      
G_M47339_IG04:
       add      rsp 48
       pop      rbx
       pop      rsi
       pop      rdi
       ret      
G_M47339_IG05:
       call     ThrowHelper:ThrowArgumentException_DestinationTooShort()
       int3     
; Total bytes of code 99 prolog size 12 for method ReadOnlySpan`1:CopyTo(struct):this
```
Second occurrence in `System.Private.CoreLib.dasm`
```asm
; Assembly listing for method ReadOnlySpan`1:CopyTo(struct):this
; Lcl frame size = 40
G_M648_IG01:
       sub      rsp 40
       nop      
G_M648_IG02:
       mov      r8d dword ptr [rcx+8]
       mov      eax r8d
       cmp      eax dword ptr [rdx+8]
       ja       SHORT G_M648_IG04
       mov      rdx bword ptr [rdx]
       mov      rax rdx
       mov      rdx bword ptr [rcx]
       movsxd   r8 r8d
       mov      rcx rax
       shl      r8 1
       call     Buffer:Memmove(structstructlong)
       nop      
G_M648_IG03:
       add      rsp 40
       ret      
G_M648_IG04:
       call     ThrowHelper:ThrowArgumentException_DestinationTooShort()
       int3     
; Total bytes of code 52 prolog size 5 for method ReadOnlySpan`1:CopyTo(struct):this
```</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>15/05/2018 5:55:50 PM +00:00</CreatedAt>
    <ClosedAt>30/05/2018 6:03:05 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18004</IssueLabelID>
    <Title>Publish master branch symbols to symweb and MSDL endpoints</Title>
    <Description>Right now the official builds of `master` only publish to the MSDL/public endpoint but both are required.

Tasks exist in the symbol publish leg that target each endpoint but only one is enabled right now by `PB_PublishType`.

Docs on how to do this correctly aren't currently available tracked by https://github.com/dotnet/core-eng/issues/3382.</Description>
    <Title_Description>Publish master branch symbols to symweb and MSDL endpoints Right now the official builds of `master` only publish to the MSDL/public endpoint but both are required.

Tasks exist in the symbol publish leg that target each endpoint but only one is enabled right now by `PB_PublishType`.

Docs on how to do this correctly aren't currently available tracked by https://github.com/dotnet/core-eng/issues/3382.</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>dagood</Assignee>
    <CreatedAt>15/05/2018 5:50:16 PM +00:00</CreatedAt>
    <ClosedAt>15/05/2018 6:07:46 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18003</IssueLabelID>
    <Title>format spmi sources</Title>
    <Description>
    </Description>
    <Title_Description>format spmi sources </Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>15/05/2018 5:22:02 PM +00:00</CreatedAt>
    <ClosedAt>15/05/2018 6:17:48 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18002</IssueLabelID>
    <Title>ignore .tail opcode on arm64</Title>
    <Description>when Jit can't do a fast tail call.

Fixes #18001.</Description>
    <Title_Description>ignore .tail opcode on arm64 when Jit can't do a fast tail call.

Fixes #18001.</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>15/05/2018 5:10:48 PM +00:00</CreatedAt>
    <ClosedAt>16/05/2018 2:02:01 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>18001</IssueLabelID>
    <Title>[Arm64] Tailcall regression</Title>
    <Description>Tailcode opcode should be treated as a hint to the JIT.  When it is not supported it should not assert.

The following tests have recently regressed 
```
CoreMangLib/system/span/SlowTailCallArgs/SlowTailCallArgs.sh
JIT/Methodical/Invoke/25params/25param2c_il_d/25param2c_il_d.sh
JIT/Methodical/Invoke/25params/25param2c_il_r/25param2c_il_r.sh
JIT/Regression/JitBlue/GitHub_17585/GitHub_17585/GitHub_17585.sh
```
They now fire an assertion 
```
'NYI_ARM64: Arm64 does not support tail calls via helpers.' in 'DynamicClass:TailCaller(struct)' (IL size 13)
```

This was probably introduced as a diagnostic by @sandreenko as mentioned in here 
https://github.com/dotnet/coreclr/issues/6675#issuecomment-388917599

@janvorli @dotnet/arm64-contrib </Description>
    <Title_Description>[Arm64] Tailcall regression Tailcode opcode should be treated as a hint to the JIT.  When it is not supported it should not assert.

The following tests have recently regressed 
```
CoreMangLib/system/span/SlowTailCallArgs/SlowTailCallArgs.sh
JIT/Methodical/Invoke/25params/25param2c_il_d/25param2c_il_d.sh
JIT/Methodical/Invoke/25params/25param2c_il_r/25param2c_il_r.sh
JIT/Regression/JitBlue/GitHub_17585/GitHub_17585/GitHub_17585.sh
```
They now fire an assertion 
```
'NYI_ARM64: Arm64 does not support tail calls via helpers.' in 'DynamicClass:TailCaller(struct)' (IL size 13)
```

This was probably introduced as a diagnostic by @sandreenko as mentioned in here 
https://github.com/dotnet/coreclr/issues/6675#issuecomment-388917599

@janvorli @dotnet/arm64-contrib </Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>sandreenko</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17997</IssueLabelID>
    <Title>Tolerate spmi misses</Title>
    <Description>before:
```
F:\CodegenMirror\src\NDP\clr\src&gt;F:\CodegenMirror\SuperPMI\1698405\amd64\SuperPMI\SuperPMI.exe   -v ewim F:\CodegenMirror\binaries\amd64dbg\clrjit.dll F:\CodegenMirror\SuperPMI\1698405\amd64\MCH\CQ_PERF_clean_thin_unique.mch
ERROR: main method 19 of size 43 failed to load and compile correctly.
ERROR: main method 21 of size 419 failed to load and compile correctly.
MISSING: Method context 27 failed to replay: SuperPMI assertion 'IsFieldStatic != nullptr' failed ("Didn't find anything for 00007FFEBDB4BD18")
ERROR: Exception thrown: SuperPMI assertion 'index != -1' failed ("Didn't find Key")
ERROR: main method 32 of size 141 failed to load and compile correctly.

```
return value = 1

after:
```
F:\CodegenMirror\src\NDP\clr\src&gt;"F:\CodegenMirror\src\NDP\clr\src\ToolBox\superpmi\vssln\bin\x64Debug\superpmi.exe"   -v ewim F:\CodegenMirror\binaries\amd64dbg\clrjit.dll F:\CodegenMirror\SuperPMI\1698405\amd64\MCH\CQ_PERF_clean_thin_unique.mch
MISSING: Method context 19 failed to replay: SuperPMI assertion 'this != nullptr' failed ("There is no such LWM (in GetIndex)")
MISSING: Method context 21 failed to replay: SuperPMI assertion 'this != nullptr' failed ("There is no such LWM (in GetIndex)")
MISSING: Method context 27 failed to replay: SuperPMI assertion 'IsFieldStatic != nullptr' failed ("Didn't find anything for 00007FFEBDB4BD18")
MISSING: Method context 32 failed to replay: SuperPMI assertion 'index != -1' failed ("Didn't find Item (in Get)")
```
return value = 3.


This PR allows us to clean `False negative` failure notifications.

PTAL @BruceForstall 
cc @dotnet/jit-contrib </Description>
    <Title_Description>Tolerate spmi misses before:
```
F:\CodegenMirror\src\NDP\clr\src&gt;F:\CodegenMirror\SuperPMI\1698405\amd64\SuperPMI\SuperPMI.exe   -v ewim F:\CodegenMirror\binaries\amd64dbg\clrjit.dll F:\CodegenMirror\SuperPMI\1698405\amd64\MCH\CQ_PERF_clean_thin_unique.mch
ERROR: main method 19 of size 43 failed to load and compile correctly.
ERROR: main method 21 of size 419 failed to load and compile correctly.
MISSING: Method context 27 failed to replay: SuperPMI assertion 'IsFieldStatic != nullptr' failed ("Didn't find anything for 00007FFEBDB4BD18")
ERROR: Exception thrown: SuperPMI assertion 'index != -1' failed ("Didn't find Key")
ERROR: main method 32 of size 141 failed to load and compile correctly.

```
return value = 1

after:
```
F:\CodegenMirror\src\NDP\clr\src&gt;"F:\CodegenMirror\src\NDP\clr\src\ToolBox\superpmi\vssln\bin\x64Debug\superpmi.exe"   -v ewim F:\CodegenMirror\binaries\amd64dbg\clrjit.dll F:\CodegenMirror\SuperPMI\1698405\amd64\MCH\CQ_PERF_clean_thin_unique.mch
MISSING: Method context 19 failed to replay: SuperPMI assertion 'this != nullptr' failed ("There is no such LWM (in GetIndex)")
MISSING: Method context 21 failed to replay: SuperPMI assertion 'this != nullptr' failed ("There is no such LWM (in GetIndex)")
MISSING: Method context 27 failed to replay: SuperPMI assertion 'IsFieldStatic != nullptr' failed ("Didn't find anything for 00007FFEBDB4BD18")
MISSING: Method context 32 failed to replay: SuperPMI assertion 'index != -1' failed ("Didn't find Item (in Get)")
```
return value = 3.


This PR allows us to clean `False negative` failure notifications.

PTAL @BruceForstall 
cc @dotnet/jit-contrib </Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>15/05/2018 6:41:23 AM +00:00</CreatedAt>
    <ClosedAt>15/05/2018 11:29:27 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17992</IssueLabelID>
    <Title>[Linux/arm] baseservices/compilerservices/FixedAddressValueType failure</Title>
    <Description>`baseservices/compilerservices/FixedAddressValueType/FixedAddressValueType/FixedAddressValueType.sh` failed in the following test runs
[Ubuntu arm Cross Checked r2r_jitminopts Build and Test](https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_ubuntu_r2r_jitminopts_tst_prtest/4/consoleText) and [Ubuntu arm Cross Checked r2r_jitstressregs4 Build and Test](https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_ubuntu_r2r_jitstressregs4_tst_prtest/4/consoleText) 

```
FAILED   - baseservices/compilerservices/FixedAddressValueType/FixedAddressValueType/FixedAddressValueType.sh
               BEGIN EXECUTION
               in takeLock
               /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_r2r_jitminopts_tst_prtest/bin/tests/Linux.arm.Checked/Tests/Core_Root/crossgen /Platform_Assemblies_Paths /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_r2r_jitminopts_tst_prtest/bin/tests/Linux.arm.Checked/Tests/Core_Root:/ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_r2r_jitminopts_tst_prtest/bin/tests/Linux.arm.Checked/baseservices/compilerservices/FixedAddressValueType/FixedAddressValueType/IL:/ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_r2r_jitminopts_tst_prtest/bin/tests/Linux.arm.Checked/baseservices/compilerservices/FixedAddressValueType/FixedAddressValueType /in FixedAddressValueType.org /out FixedAddressValueType.exe
               Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0
               Copyright (c) Microsoft Corporation.  All rights reserved.
               
               Native image FixedAddressValueType.exe generated successfully.
               in ReleaseLock
               in takeLock
               /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_r2r_jitminopts_tst_prtest/bin/tests/Linux.arm.Checked/Tests/Core_Root/corerun FixedAddressValueType.exe
               in ReleaseLock
               Expected: 100
               Actual: 255
               END EXECUTION - FAILED
```</Description>
    <Title_Description>[Linux/arm] baseservices/compilerservices/FixedAddressValueType failure `baseservices/compilerservices/FixedAddressValueType/FixedAddressValueType/FixedAddressValueType.sh` failed in the following test runs
[Ubuntu arm Cross Checked r2r_jitminopts Build and Test](https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_ubuntu_r2r_jitminopts_tst_prtest/4/consoleText) and [Ubuntu arm Cross Checked r2r_jitstressregs4 Build and Test](https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_ubuntu_r2r_jitstressregs4_tst_prtest/4/consoleText) 

```
FAILED   - baseservices/compilerservices/FixedAddressValueType/FixedAddressValueType/FixedAddressValueType.sh
               BEGIN EXECUTION
               in takeLock
               /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_r2r_jitminopts_tst_prtest/bin/tests/Linux.arm.Checked/Tests/Core_Root/crossgen /Platform_Assemblies_Paths /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_r2r_jitminopts_tst_prtest/bin/tests/Linux.arm.Checked/Tests/Core_Root:/ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_r2r_jitminopts_tst_prtest/bin/tests/Linux.arm.Checked/baseservices/compilerservices/FixedAddressValueType/FixedAddressValueType/IL:/ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_r2r_jitminopts_tst_prtest/bin/tests/Linux.arm.Checked/baseservices/compilerservices/FixedAddressValueType/FixedAddressValueType /in FixedAddressValueType.org /out FixedAddressValueType.exe
               Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0
               Copyright (c) Microsoft Corporation.  All rights reserved.
               
               Native image FixedAddressValueType.exe generated successfully.
               in ReleaseLock
               in takeLock
               /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_r2r_jitminopts_tst_prtest/bin/tests/Linux.arm.Checked/Tests/Core_Root/corerun FixedAddressValueType.exe
               in ReleaseLock
               Expected: 100
               Actual: 255
               END EXECUTION - FAILED
```</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>BruceForstall</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17986</IssueLabelID>
    <Title>Reflection.Emit: Assertion failure in SignatureHelper.AddOneArgTypeHelper. Missing argument validation in public API?</Title>
    <Description>I've come across a failing `Debug.Assert` in System.Reflection.Emit using an up-to-date debug build of System.Private.CoreLib. It's probably a fairly benign case but since I don't know how much value you place on fixing something like this I thought I'd report it. Suggestions on how to fix it at the end of this post.

We're talking about the second `Debug.Assert` here: https://github.com/dotnet/coreclr/blob/4c716dc92ccc3c22e175576af426a8a972401f07/src/System.Private.CoreLib/src/System/Reflection/Emit/SignatureHelper.cs#L286-L292

This code makes it fail:

```csharp
using System;
using System.Reflection;
using System.Reflection.Emit;

public interface IType
{
    T Method&lt;T&gt;();
}

class Program
{
    static void Main()
    {
        // The following code creates an implementation `class Type : IType`:
        var assemblyBuilder = AssemblyBuilder.DefineDynamicAssembly(new AssemblyName("Assembly") AssemblyBuilderAccess.Run);
        var moduleBuilder = assemblyBuilder.DefineDynamicModule("Module");
        var typeBuilder = moduleBuilder.DefineType("Type" TypeAttributes.Class typeof(object) new[] { typeof(IType) });
        var methodBuilder = typeBuilder.DefineMethod("Method" MethodAttributes.Public | MethodAttributes.Final | MethodAttributes.Virtual);
        var genericParamBuilder = methodBuilder.DefineGenericParameters("T")[0];

        methodBuilder.SetSignature(genericParamBuilder Type.EmptyTypes Type.EmptyTypes null null null);
        //                         ^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^
        //                  This combination of arguments is what will make the assertion fail.
        //                  Note that user code ought to pass `null` instead of empty arrays!

        // Generate method body corresponding to `return default(T)`:
        var il = methodBuilder.GetILGenerator();
        il.DeclareLocal(genericParamBuilder);
        il.Emit(OpCodes.Ldloca_S 0);
        il.Emit(OpCodes.Initobj genericParamBuilder);
        il.Emit(OpCodes.Ldloc_0);
        il.Emit(OpCodes.Ret);

        typeBuilder.DefineMethodOverride(methodBuilder typeof(IType).GetMethod("Method")); // BOOM!

        var type = typeBuilder.CreateType();
    }
}
```

```
Assertion Failed

   at System.Reflection.Emit.SignatureHelper.AddOneArgTypeHelper(Type clsArgument Type[] requiredCustomModifiers Type[] optionalCustomModifiers) in ...\coreclr\src\mscorlib\src\System\Reflection\Emit\SignatureHelper.cs:line 292
   at System.Reflection.Emit.SignatureHelper..ctor(Module mod MdSigCallingConvention callingConvention Int32 cGenericParameters Type returnType Type[] requiredCustomModifiers Type[] optionalCustomModifiers) in ...\coreclr\src\mscorlib\src\System\Reflection\Emit\SignatureHelper.cs:line 221
   at System.Reflection.Emit.SignatureHelper.GetMethodSigHelper(Module scope CallingConventions callingConvention Int32 cGenericParam Type returnType Type[] requiredReturnTypeCustomModifiers Type[] optionalReturnTypeCustomModifiers Type[] parameterTypes Type[][] requiredParameterTypeCustomModifiers Type[][] optionalParameterTypeCustomModifiers) in ...\coreclr\src\mscorlib\src\System\Reflection\Emit\SignatureHelper.cs:line 83
   at System.Reflection.Emit.MethodBuilder.GetMethodSignature() in ...\coreclr\src\mscorlib\src\System\Reflection\Emit\MethodBuilder.cs:line 378
   at System.Reflection.Emit.MethodBuilder.GetTokenNoLock() in ...\coreclr\src\mscorlib\src\System\Reflection\Emit\MethodBuilder.cs:line 758
   at System.Reflection.Emit.MethodBuilder.GetToken() in ...\src\mscorlib\src\System\Reflection\Emit\MethodBuilder.cs:line 738
   at System.Reflection.Emit.MethodBuilder.get_MetadataTokenInternal() in ...\coreclr\src\mscorlib\src\System\Reflection\Emit\MethodBuilder.cs:line 517
   at System.Reflection.Emit.ModuleBuilder.GetMethodTokenNoLock(MethodInfo method Boolean getGenericTypeDefinition) in ...\coreclr\src\mscorlib\src\System\Reflection\Emit\ModuleBuilder.cs:line 1215
   at System.Reflection.Emit.ModuleBuilder.GetMethodTokenInternal(MethodInfo method) in ...\coreclr\src\mscorlib\src\System\Reflection\Emit\ModuleBuilder.cs:line 1192
   at System.Reflection.Emit.TypeBuilder.DefineMethodOverrideNoLock(MethodInfo methodInfoBody MethodInfo methodInfoDeclaration) in ...\coreclr\src\mscorlib\src\System\Reflection\Emit\TypeBuilder.cs:line 1322
   at System.Reflection.Emit.TypeBuilder.DefineMethodOverride(MethodInfo methodInfoBody MethodInfo methodInfoDeclaration) in ...\coreclr\src\mscorlib\src\System\Reflection\Emit\TypeBuilder.cs:line 1301
   at Program.Main() in ...\Program.cs:line 34
```

The assertion failure happens in `AddOneArgTypeHelper` which is being called for the return type. It is triggered by the user code passing in empty arrays (`Type.EmptyTypes`) for the return type's modreqs and modopts instead of `null` (as it should according to the [documentation for `MethodBuilder.SetSignature`](https://docs.microsoft.com/en-us/dotnet/api/system.reflection.emit.methodbuilder.setsignature)).

It seems to me that instead of trusting user code to pass in `null` instead of empty arrays `MethodBuilder.SetSignature` should actively check for empty arrays and correct them.</Description>
    <Title_Description>Reflection.Emit: Assertion failure in SignatureHelper.AddOneArgTypeHelper. Missing argument validation in public API? I've come across a failing `Debug.Assert` in System.Reflection.Emit using an up-to-date debug build of System.Private.CoreLib. It's probably a fairly benign case but since I don't know how much value you place on fixing something like this I thought I'd report it. Suggestions on how to fix it at the end of this post.

We're talking about the second `Debug.Assert` here: https://github.com/dotnet/coreclr/blob/4c716dc92ccc3c22e175576af426a8a972401f07/src/System.Private.CoreLib/src/System/Reflection/Emit/SignatureHelper.cs#L286-L292

This code makes it fail:

```csharp
using System;
using System.Reflection;
using System.Reflection.Emit;

public interface IType
{
    T Method&lt;T&gt;();
}

class Program
{
    static void Main()
    {
        // The following code creates an implementation `class Type : IType`:
        var assemblyBuilder = AssemblyBuilder.DefineDynamicAssembly(new AssemblyName("Assembly") AssemblyBuilderAccess.Run);
        var moduleBuilder = assemblyBuilder.DefineDynamicModule("Module");
        var typeBuilder = moduleBuilder.DefineType("Type" TypeAttributes.Class typeof(object) new[] { typeof(IType) });
        var methodBuilder = typeBuilder.DefineMethod("Method" MethodAttributes.Public | MethodAttributes.Final | MethodAttributes.Virtual);
        var genericParamBuilder = methodBuilder.DefineGenericParameters("T")[0];

        methodBuilder.SetSignature(genericParamBuilder Type.EmptyTypes Type.EmptyTypes null null null);
        //                         ^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^
        //                  This combination of arguments is what will make the assertion fail.
        //                  Note that user code ought to pass `null` instead of empty arrays!

        // Generate method body corresponding to `return default(T)`:
        var il = methodBuilder.GetILGenerator();
        il.DeclareLocal(genericParamBuilder);
        il.Emit(OpCodes.Ldloca_S 0);
        il.Emit(OpCodes.Initobj genericParamBuilder);
        il.Emit(OpCodes.Ldloc_0);
        il.Emit(OpCodes.Ret);

        typeBuilder.DefineMethodOverride(methodBuilder typeof(IType).GetMethod("Method")); // BOOM!

        var type = typeBuilder.CreateType();
    }
}
```

```
Assertion Failed

   at System.Reflection.Emit.SignatureHelper.AddOneArgTypeHelper(Type clsArgument Type[] requiredCustomModifiers Type[] optionalCustomModifiers) in ...\coreclr\src\mscorlib\src\System\Reflection\Emit\SignatureHelper.cs:line 292
   at System.Reflection.Emit.SignatureHelper..ctor(Module mod MdSigCallingConvention callingConvention Int32 cGenericParameters Type returnType Type[] requiredCustomModifiers Type[] optionalCustomModifiers) in ...\coreclr\src\mscorlib\src\System\Reflection\Emit\SignatureHelper.cs:line 221
   at System.Reflection.Emit.SignatureHelper.GetMethodSigHelper(Module scope CallingConventions callingConvention Int32 cGenericParam Type returnType Type[] requiredReturnTypeCustomModifiers Type[] optionalReturnTypeCustomModifiers Type[] parameterTypes Type[][] requiredParameterTypeCustomModifiers Type[][] optionalParameterTypeCustomModifiers) in ...\coreclr\src\mscorlib\src\System\Reflection\Emit\SignatureHelper.cs:line 83
   at System.Reflection.Emit.MethodBuilder.GetMethodSignature() in ...\coreclr\src\mscorlib\src\System\Reflection\Emit\MethodBuilder.cs:line 378
   at System.Reflection.Emit.MethodBuilder.GetTokenNoLock() in ...\coreclr\src\mscorlib\src\System\Reflection\Emit\MethodBuilder.cs:line 758
   at System.Reflection.Emit.MethodBuilder.GetToken() in ...\src\mscorlib\src\System\Reflection\Emit\MethodBuilder.cs:line 738
   at System.Reflection.Emit.MethodBuilder.get_MetadataTokenInternal() in ...\coreclr\src\mscorlib\src\System\Reflection\Emit\MethodBuilder.cs:line 517
   at System.Reflection.Emit.ModuleBuilder.GetMethodTokenNoLock(MethodInfo method Boolean getGenericTypeDefinition) in ...\coreclr\src\mscorlib\src\System\Reflection\Emit\ModuleBuilder.cs:line 1215
   at System.Reflection.Emit.ModuleBuilder.GetMethodTokenInternal(MethodInfo method) in ...\coreclr\src\mscorlib\src\System\Reflection\Emit\ModuleBuilder.cs:line 1192
   at System.Reflection.Emit.TypeBuilder.DefineMethodOverrideNoLock(MethodInfo methodInfoBody MethodInfo methodInfoDeclaration) in ...\coreclr\src\mscorlib\src\System\Reflection\Emit\TypeBuilder.cs:line 1322
   at System.Reflection.Emit.TypeBuilder.DefineMethodOverride(MethodInfo methodInfoBody MethodInfo methodInfoDeclaration) in ...\coreclr\src\mscorlib\src\System\Reflection\Emit\TypeBuilder.cs:line 1301
   at Program.Main() in ...\Program.cs:line 34
```

The assertion failure happens in `AddOneArgTypeHelper` which is being called for the return type. It is triggered by the user code passing in empty arrays (`Type.EmptyTypes`) for the return type's modreqs and modopts instead of `null` (as it should according to the [documentation for `MethodBuilder.SetSignature`](https://docs.microsoft.com/en-us/dotnet/api/system.reflection.emit.methodbuilder.setsignature)).

It seems to me that instead of trusting user code to pass in `null` instead of empty arrays `MethodBuilder.SetSignature` should actively check for empty arrays and correct them.</Title_Description>
    <Label>area-System.Reflection</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>14/05/2018 7:54:44 AM +00:00</CreatedAt>
    <ClosedAt>15/05/2018 10:39:03 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17984</IssueLabelID>
    <Title>Odd side-effect check code generation with fixed keyword</Title>
    <Description>There is something wired side-effect check code generation on fixed pointers.
I don't know its because Roslyn generates wrong MSIL. but first. I am writing here.

Example here.
```
static unsafe int Test(int[] arr)
{
    int total = 0;

    fixed (int* pArr = arr)
    {
        for (int i = 0; i &lt; 4; ++i)
        {
            total += pArr[i];
        }
    }

    return total;
}
```
This code generates some odd check codes. here is disassembles.
```
    12:             int total = 0;
00007FFC545304E2 EC                   in          aldx  
00007FFC545304E3 28 33                sub         byte ptr [rbx]dh  
00007FFC545304E5 C0 48 89 44          ror         byte ptr [rax-77h]44h  
00007FFC545304E9 24 20                and         al20h  
00007FFC545304EB 33 C0                xor         eaxeax  
    13: 
    14:             fixed (int* pArr = arr)
00007FFC545304ED 48 89 4C 24 20       mov         qword ptr [rsp+20h]rcx  
00007FFC545304F2 48 85 C9             test        rcxrcx  
00007FFC545304F5 74 0B                je          00007FFC54530502  
00007FFC545304F7 48 8B 54 24 20       mov         rdxqword ptr [rsp+20h]  
00007FFC545304FC 83 7A 08 00          cmp         dword ptr [rdx+8]0  
00007FFC54530500 75 04                jne         00007FFC54530506  
00007FFC54530502 33 D2                xor         edxedx  
00007FFC54530504 EB 14                jmp         00007FFC5453051A  
00007FFC54530506 48 8B 54 24 20       mov         rdxqword ptr [rsp+20h]  
00007FFC5453050B 83 7A 08 00          cmp         dword ptr [rdx+8]0  
00007FFC5453050F 76 25                jbe         00007FFC54530536  
00007FFC54530511 48 8B 54 24 20       mov         rdxqword ptr [rsp+20h]  
00007FFC54530516 48 83 C2 10          add         rdx10h  
    15:             {
    16:                 for (int i = 0; i &lt; 4; ++i)
00007FFC5453051A 33 C9                xor         ecxecx  
    17:                 {
    18:                     total += pArr[i];
00007FFC5453051C 4C 63 C1             movsxd      r8ecx  
00007FFC5453051F 42 03 04 82          add         eaxdword ptr [rdx+r8*4]  
    16:                 for (int i = 0; i &lt; 4; ++i)
00007FFC54530523 FF C1                inc         ecx  
00007FFC54530525 83 F9 04             cmp         ecx4  
00007FFC54530528 7C F2                jl          00007FFC5453051C  
00007FFC5453052A 33 D2                xor         edxedx  
00007FFC5453052C 48 89 54 24 20       mov         qword ptr [rsp+20h]rdx  
00007FFC54530531 48 83 C4 28          add         rsp28h  
00007FFC54530535 C3                   ret  
00007FFC54530536 E8 05 50 C4 5F       call        00007FFCB4175540  
00007FFC5453053B CC                   int         3  
```
As you can see. its double checking object.

But this code. generates as I excepted.
```
static unsafe int Test(int[] arr)
{
    int total = 0;

    fixed (int* pArr = &amp;arr[0])
    {
        for (int i = 0; i &lt; 4; ++i)
        {
            total += pArr[i];
        }
    }

    return total;
}
```

```
    12:             int total = 0;
00007FFC545604E2 EC                   in          aldx  
00007FFC545604E3 28 33                sub         byte ptr [rbx]dh  
00007FFC545604E5 C0 48 89 44          ror         byte ptr [rax-77h]44h  
00007FFC545604E9 24 20                and         al20h  
00007FFC545604EB 33 C0                xor         eaxeax  
00007FFC545604ED 83 79 08 00          cmp         dword ptr [rcx+8]0  
00007FFC545604F1 76 2A                jbe         00007FFC5456051D  
00007FFC545604F3 48 83 C1 10          add         rcx10h  
00007FFC545604F7 48 89 4C 24 20       mov         qword ptr [rsp+20h]rcx  
    13: 
    14:             fixed (int* pArr = &amp;arr[0])
00007FFC545604FC 48 8B 54 24 20       mov         rdxqword ptr [rsp+20h]  
    15:             {
    16:                 for (int i = 0; i &lt; 4; ++i)
00007FFC54560501 33 C9                xor         ecxecx  
    17:                 {
    18:                     total += pArr[i];
00007FFC54560503 4C 63 C1             movsxd      r8ecx  
00007FFC54560506 42 03 04 82          add         eaxdword ptr [rdx+r8*4]  
    16:                 for (int i = 0; i &lt; 4; ++i)
00007FFC5456050A FF C1                inc         ecx  
00007FFC5456050C 83 F9 04             cmp         ecx4  
00007FFC5456050F 7C F2                jl          00007FFC54560503  
00007FFC54560511 33 D2                xor         edxedx  
00007FFC54560513 48 89 54 24 20       mov         qword ptr [rsp+20h]rdx  
00007FFC54560518 48 83 C4 28          add         rsp28h  
00007FFC5456051C C3                   ret  
00007FFC5456051D E8 1E 50 C1 5F       call        00007FFCB4175540  
00007FFC54560522 CC                   int         3  
```
category:cq
theme:basic-cq
skill-level:intermediate
cost:small</Description>
    <Title_Description>Odd side-effect check code generation with fixed keyword There is something wired side-effect check code generation on fixed pointers.
I don't know its because Roslyn generates wrong MSIL. but first. I am writing here.

Example here.
```
static unsafe int Test(int[] arr)
{
    int total = 0;

    fixed (int* pArr = arr)
    {
        for (int i = 0; i &lt; 4; ++i)
        {
            total += pArr[i];
        }
    }

    return total;
}
```
This code generates some odd check codes. here is disassembles.
```
    12:             int total = 0;
00007FFC545304E2 EC                   in          aldx  
00007FFC545304E3 28 33                sub         byte ptr [rbx]dh  
00007FFC545304E5 C0 48 89 44          ror         byte ptr [rax-77h]44h  
00007FFC545304E9 24 20                and         al20h  
00007FFC545304EB 33 C0                xor         eaxeax  
    13: 
    14:             fixed (int* pArr = arr)
00007FFC545304ED 48 89 4C 24 20       mov         qword ptr [rsp+20h]rcx  
00007FFC545304F2 48 85 C9             test        rcxrcx  
00007FFC545304F5 74 0B                je          00007FFC54530502  
00007FFC545304F7 48 8B 54 24 20       mov         rdxqword ptr [rsp+20h]  
00007FFC545304FC 83 7A 08 00          cmp         dword ptr [rdx+8]0  
00007FFC54530500 75 04                jne         00007FFC54530506  
00007FFC54530502 33 D2                xor         edxedx  
00007FFC54530504 EB 14                jmp         00007FFC5453051A  
00007FFC54530506 48 8B 54 24 20       mov         rdxqword ptr [rsp+20h]  
00007FFC5453050B 83 7A 08 00          cmp         dword ptr [rdx+8]0  
00007FFC5453050F 76 25                jbe         00007FFC54530536  
00007FFC54530511 48 8B 54 24 20       mov         rdxqword ptr [rsp+20h]  
00007FFC54530516 48 83 C2 10          add         rdx10h  
    15:             {
    16:                 for (int i = 0; i &lt; 4; ++i)
00007FFC5453051A 33 C9                xor         ecxecx  
    17:                 {
    18:                     total += pArr[i];
00007FFC5453051C 4C 63 C1             movsxd      r8ecx  
00007FFC5453051F 42 03 04 82          add         eaxdword ptr [rdx+r8*4]  
    16:                 for (int i = 0; i &lt; 4; ++i)
00007FFC54530523 FF C1                inc         ecx  
00007FFC54530525 83 F9 04             cmp         ecx4  
00007FFC54530528 7C F2                jl          00007FFC5453051C  
00007FFC5453052A 33 D2                xor         edxedx  
00007FFC5453052C 48 89 54 24 20       mov         qword ptr [rsp+20h]rdx  
00007FFC54530531 48 83 C4 28          add         rsp28h  
00007FFC54530535 C3                   ret  
00007FFC54530536 E8 05 50 C4 5F       call        00007FFCB4175540  
00007FFC5453053B CC                   int         3  
```
As you can see. its double checking object.

But this code. generates as I excepted.
```
static unsafe int Test(int[] arr)
{
    int total = 0;

    fixed (int* pArr = &amp;arr[0])
    {
        for (int i = 0; i &lt; 4; ++i)
        {
            total += pArr[i];
        }
    }

    return total;
}
```

```
    12:             int total = 0;
00007FFC545604E2 EC                   in          aldx  
00007FFC545604E3 28 33                sub         byte ptr [rbx]dh  
00007FFC545604E5 C0 48 89 44          ror         byte ptr [rax-77h]44h  
00007FFC545604E9 24 20                and         al20h  
00007FFC545604EB 33 C0                xor         eaxeax  
00007FFC545604ED 83 79 08 00          cmp         dword ptr [rcx+8]0  
00007FFC545604F1 76 2A                jbe         00007FFC5456051D  
00007FFC545604F3 48 83 C1 10          add         rcx10h  
00007FFC545604F7 48 89 4C 24 20       mov         qword ptr [rsp+20h]rcx  
    13: 
    14:             fixed (int* pArr = &amp;arr[0])
00007FFC545604FC 48 8B 54 24 20       mov         rdxqword ptr [rsp+20h]  
    15:             {
    16:                 for (int i = 0; i &lt; 4; ++i)
00007FFC54560501 33 C9                xor         ecxecx  
    17:                 {
    18:                     total += pArr[i];
00007FFC54560503 4C 63 C1             movsxd      r8ecx  
00007FFC54560506 42 03 04 82          add         eaxdword ptr [rdx+r8*4]  
    16:                 for (int i = 0; i &lt; 4; ++i)
00007FFC5456050A FF C1                inc         ecx  
00007FFC5456050C 83 F9 04             cmp         ecx4  
00007FFC5456050F 7C F2                jl          00007FFC54560503  
00007FFC54560511 33 D2                xor         edxedx  
00007FFC54560513 48 89 54 24 20       mov         qword ptr [rsp+20h]rdx  
00007FFC54560518 48 83 C4 28          add         rsp28h  
00007FFC5456051C C3                   ret  
00007FFC5456051D E8 1E 50 C1 5F       call        00007FFCB4175540  
00007FFC54560522 CC                   int         3  
```
category:cq
theme:basic-cq
skill-level:intermediate
cost:small</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>mikedn</Assignee>
    <CreatedAt>14/05/2018 4:11:30 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17980</IssueLabelID>
    <Title>What's data stored in method handle?</Title>
    <Description>```
MethodInfo mi=...;
int data = Marshal.ReadInt32(mi.MethodHandle.Value);
int mask=0xffff;//how to set the mask?
int order=data&amp;mask;
MethodInfo method=module.ResolveMethod(0x06000000+order);
```

I know the lower bits is the order number of a method but I don't know which position is the first bit.

What's the meaning of all the bits?</Description>
    <Title_Description>What's data stored in method handle? ```
MethodInfo mi=...;
int data = Marshal.ReadInt32(mi.MethodHandle.Value);
int mask=0xffff;//how to set the mask?
int order=data&amp;mask;
MethodInfo method=module.ResolveMethod(0x06000000+order);
```

I know the lower bits is the order number of a method but I don't know which position is the first bit.

What's the meaning of all the bits?</Title_Description>
    <Label>question</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>13/05/2018 10:12:52 AM +00:00</CreatedAt>
    <ClosedAt>13/05/2018 7:56:01 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17977</IssueLabelID>
    <Title>Reflection: Allow ParameterBuilder.SetConstant(nonNullValue) for nullable enum parameters</Title>
    <Description>This is a fix for #17893.

* Makes it possible to call `ParameterBuilder.SetConstant(nonNullValue)` for a parameter of type `TEnum?`.

* But does not change the behavior of `ParameterInfo.DefaultValue` which will report a default value of the enum's underlying type for `TEnum?` parameters (unlike with `TEnum` parameters where the reported default value has type `TEnum`). While it would be nice to change this it might also break existing user code:

   ```csharp
   class Class
   {
       public void Method(AttributeTargets? arg = AttributeTargets.Constructor) { }
   }

   // This assertion currently succeeds perhaps safest to keep it that way for now:
   Debug.Assert(typeof(Class).GetMethod("Method").GetParameters()[0].DefaultValue is int);
   ```

/cc @AtsushiKan</Description>
    <Title_Description>Reflection: Allow ParameterBuilder.SetConstant(nonNullValue) for nullable enum parameters This is a fix for #17893.

* Makes it possible to call `ParameterBuilder.SetConstant(nonNullValue)` for a parameter of type `TEnum?`.

* But does not change the behavior of `ParameterInfo.DefaultValue` which will report a default value of the enum's underlying type for `TEnum?` parameters (unlike with `TEnum` parameters where the reported default value has type `TEnum`). While it would be nice to change this it might also break existing user code:

   ```csharp
   class Class
   {
       public void Method(AttributeTargets? arg = AttributeTargets.Constructor) { }
   }

   // This assertion currently succeeds perhaps safest to keep it that way for now:
   Debug.Assert(typeof(Class).GetMethod("Method").GetParameters()[0].DefaultValue is int);
   ```

/cc @AtsushiKan</Title_Description>
    <Label>netfx-port-consider</Label>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17969</IssueLabelID>
    <Title>Don't eliminate a cpblk when offsets are different</Title>
    <Description>When the JIT encounters a cpblk between two different offsets of the same local if both fields are not recognizable to the JIT (i.e. the `FieldSeqNode` returned by `IsLocalAddrExpr()` and/or the `gtFieldSeq` field of a `GT_LCL_FLD` is `FieldSeqStore::NotAField()`) it will incorrectly optimize away the cpblk.</Description>
    <Title_Description>Don't eliminate a cpblk when offsets are different When the JIT encounters a cpblk between two different offsets of the same local if both fields are not recognizable to the JIT (i.e. the `FieldSeqNode` returned by `IsLocalAddrExpr()` and/or the `gtFieldSeq` field of a `GT_LCL_FLD` is `FieldSeqStore::NotAField()`) it will incorrectly optimize away the cpblk.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17968</IssueLabelID>
    <Title>[arm64/RyuJit] assert(!"Shouldn't see an integer typed GT_MOD node in ARM64");</Title>
    <Description>It was found in our internal test runs I have added an IL test for this issue: tests/src/JIT/Regression/JitBlue/DevDiv_590772/DevDiv_590772.il  (#17759)
To repro crossgen this test with altjit_arm64 or on arm64 itself.
Once it fixed delete change tests/arm64/Tests.lst to enable the test.</Description>
    <Title_Description>[arm64/RyuJit] assert(!"Shouldn't see an integer typed GT_MOD node in ARM64"); It was found in our internal test runs I have added an IL test for this issue: tests/src/JIT/Regression/JitBlue/DevDiv_590772/DevDiv_590772.il  (#17759)
To repro crossgen this test with altjit_arm64 or on arm64 itself.
Once it fixed delete change tests/arm64/Tests.lst to enable the test.</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>sandreenko</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17967</IssueLabelID>
    <Title>[arm64/RyuJit] assert(!"We should never encounter a reference to a lclVar that has a zero refCnt.");</Title>
    <Description>It was found in our internal test runs I have added an IL test for this issue: tests/src/JIT/Regression/JitBlue/DevDiv_590771/DevDiv_590771.il  (#17759)

To repro crossgen this test with altjit_arm64 or on arm64 itself.

Once it fixed delete change `tests/arm64/Tests.lst` to enable the test.</Description>
    <Title_Description>[arm64/RyuJit] assert(!"We should never encounter a reference to a lclVar that has a zero refCnt."); It was found in our internal test runs I have added an IL test for this issue: tests/src/JIT/Regression/JitBlue/DevDiv_590771/DevDiv_590771.il  (#17759)

To repro crossgen this test with altjit_arm64 or on arm64 itself.

Once it fixed delete change `tests/arm64/Tests.lst` to enable the test.</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>AndyAyersMS</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17966</IssueLabelID>
    <Title>[arm64/RyuJit] NYI("Initialize floating-point register to zero");</Title>
    <Description>It was found in our internal test runs I have added an IL test for this issue: tests/src/JIT/Regression/JitBlue/DevDiv_605447/DevDiv_605447.il (#17759)

To repro crossgen this test with altjit_arm64 or on arm64 itself.

Once it fixed delete change `tests/arm64/Tests.lst` to enable the test.</Description>
    <Title_Description>[arm64/RyuJit] NYI("Initialize floating-point register to zero"); It was found in our internal test runs I have added an IL test for this issue: tests/src/JIT/Regression/JitBlue/DevDiv_605447/DevDiv_605447.il (#17759)

To repro crossgen this test with altjit_arm64 or on arm64 itself.

Once it fixed delete change `tests/arm64/Tests.lst` to enable the test.</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>sdmaclea</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17963</IssueLabelID>
    <Title>Jit can generate pointless movs</Title>
    <Description>e.g.
```asm 
 mov    r8ddword ptr [rax]  
 add    rax4  
 mov    r8dr8d                 ; pointless mov
 ...
 movzx  eaxbyte ptr [rax]  
 mov    eaxeax                 ; pointless mov   
```
Example

The Checksum routine [Magma.Common/Checksum.cs](https://github.com/ProjectMagma/Magma/blob/53dd7f73986945c041b98ebf752fb842eddeb963/src/Magma.Common/Checksum.cs#L11-L94)

```csharp
// Internet Checksum as defined by RFC 791 RFC 793 RFC 1071 RFC 1141 RFC 1624
public static ushort Calcuate(ref byte buffer int length)
{
    ref var current = ref buffer;
    ulong sum = 0;

    while (length &gt;= sizeof(ulong))
    {
        length -= sizeof(ulong);

        var ulong0 = Unsafe.As&lt;byte ulong&gt;(ref current);
        current = ref Unsafe.Add(ref current sizeof(ulong));

        // Add with carry
        sum += ulong0;
        if (sum &lt; ulong0)
        {
            sum++;
        }
    }

    if ((length &amp; sizeof(uint)) != 0)
    {
        var uint0 = Unsafe.As&lt;byte uint&gt;(ref current);
        current = ref Unsafe.Add(ref current sizeof(uint));

        // Add with carry
        sum += uint0;
        if (sum &lt; uint0)
        {
            sum++;
        }
    }

    if ((length &amp; sizeof(ushort)) != 0)
    {
        var ushort0 = Unsafe.As&lt;byte ushort&gt;(ref current);
        current = ref Unsafe.Add(ref current sizeof(ushort));

        // Add with carry
        sum += ushort0;
        if (sum &lt; ushort0)
        {
            sum++;
        }
    }

    if ((length &amp; sizeof(byte)) != 0)
    {
        var byte0 = current;

        // Add with carry
        sum += byte0;
        if (sum &lt; byte0)
        {
            sum++;
        }
    }

    // Fold down to 16 bits

    var uint1 = (uint)(sum &gt;&gt; 32);
    var uint2 = (uint)sum;

    // Add with carry
    uint1 += uint2;
    if (uint1 &lt; uint2)
    {
        uint1++;
    }

    var ushort2 = (ushort)uint1;
    var ushort1 = (ushort)(uint1 &gt;&gt; 16);

    // Add with carry
    ushort1 = (ushort)(ushort1 + ushort2);
    if (ushort1 &lt; ushort2)
    {
        ushort1++;
    }

    // Invert to get ones-complement result 
    return (ushort)~ushort1;
}
```
Generates asm with 3 pointless movs
```asm
 mov    raxrcx  
 xor    ecxecx  
 cmp    edx8  
 jl     00007FFB767741B4  
 add    edx0FFFFFFF8h  
 mov    r8qword ptr [rax]  
 add    rax8  
 add    rcxr8  
 cmp    rcxr8  
 jae    00007FFB767741AF  
 inc    rcx  
 cmp    edx8  
 jge    00007FFB7677419A  
 test   dl4  
 je     00007FFB767741CE  
 mov    r8ddword ptr [rax]  
 add    rax4  
 mov    r8dr8d                 ; pointless mov 
 add    rcxr8  
 cmp    rcxr8  
 jae    00007FFB767741CE  
 inc    rcx  
 test   dl2  
 je     00007FFB767741E9  
 movzx  r8dword ptr [rax]  
 add    rax2  
 mov    r8dr8d                 ; pointless mov   
 add    rcxr8  
 cmp    rcxr8  
 jae    00007FFB767741E9  
 inc    rcx  
 test   dl1  
 je     00007FFB767741FE  
 movzx  eaxbyte ptr [rax]  
 mov    eaxeax                 ; pointless mov   
 add    rcxrax  
 cmp    rcxrax  
 jae    00007FFB767741FE  
 inc    rcx  
 mov    raxrcx  
 shr    rax20h  
 add    eaxecx  
 cmp    eaxecx  
 jae    00007FFB7677420D  
 inc    eax  
 movzx  edxax  
 shr    eax10h  
 movzx  eaxax  
 add    eaxedx  
 movzx  eaxax  
 cmp    eaxedx  
 jge    00007FFB76774224  
 inc    eax  
 movzx  eaxax  
 not    eax  
 movzx  eaxax  
 ret    
```
category:cq
theme:basic-cq
skill-level:intermediate
cost:medium</Description>
    <Title_Description>Jit can generate pointless movs e.g.
```asm 
 mov    r8ddword ptr [rax]  
 add    rax4  
 mov    r8dr8d                 ; pointless mov
 ...
 movzx  eaxbyte ptr [rax]  
 mov    eaxeax                 ; pointless mov   
```
Example

The Checksum routine [Magma.Common/Checksum.cs](https://github.com/ProjectMagma/Magma/blob/53dd7f73986945c041b98ebf752fb842eddeb963/src/Magma.Common/Checksum.cs#L11-L94)

```csharp
// Internet Checksum as defined by RFC 791 RFC 793 RFC 1071 RFC 1141 RFC 1624
public static ushort Calcuate(ref byte buffer int length)
{
    ref var current = ref buffer;
    ulong sum = 0;

    while (length &gt;= sizeof(ulong))
    {
        length -= sizeof(ulong);

        var ulong0 = Unsafe.As&lt;byte ulong&gt;(ref current);
        current = ref Unsafe.Add(ref current sizeof(ulong));

        // Add with carry
        sum += ulong0;
        if (sum &lt; ulong0)
        {
            sum++;
        }
    }

    if ((length &amp; sizeof(uint)) != 0)
    {
        var uint0 = Unsafe.As&lt;byte uint&gt;(ref current);
        current = ref Unsafe.Add(ref current sizeof(uint));

        // Add with carry
        sum += uint0;
        if (sum &lt; uint0)
        {
            sum++;
        }
    }

    if ((length &amp; sizeof(ushort)) != 0)
    {
        var ushort0 = Unsafe.As&lt;byte ushort&gt;(ref current);
        current = ref Unsafe.Add(ref current sizeof(ushort));

        // Add with carry
        sum += ushort0;
        if (sum &lt; ushort0)
        {
            sum++;
        }
    }

    if ((length &amp; sizeof(byte)) != 0)
    {
        var byte0 = current;

        // Add with carry
        sum += byte0;
        if (sum &lt; byte0)
        {
            sum++;
        }
    }

    // Fold down to 16 bits

    var uint1 = (uint)(sum &gt;&gt; 32);
    var uint2 = (uint)sum;

    // Add with carry
    uint1 += uint2;
    if (uint1 &lt; uint2)
    {
        uint1++;
    }

    var ushort2 = (ushort)uint1;
    var ushort1 = (ushort)(uint1 &gt;&gt; 16);

    // Add with carry
    ushort1 = (ushort)(ushort1 + ushort2);
    if (ushort1 &lt; ushort2)
    {
        ushort1++;
    }

    // Invert to get ones-complement result 
    return (ushort)~ushort1;
}
```
Generates asm with 3 pointless movs
```asm
 mov    raxrcx  
 xor    ecxecx  
 cmp    edx8  
 jl     00007FFB767741B4  
 add    edx0FFFFFFF8h  
 mov    r8qword ptr [rax]  
 add    rax8  
 add    rcxr8  
 cmp    rcxr8  
 jae    00007FFB767741AF  
 inc    rcx  
 cmp    edx8  
 jge    00007FFB7677419A  
 test   dl4  
 je     00007FFB767741CE  
 mov    r8ddword ptr [rax]  
 add    rax4  
 mov    r8dr8d                 ; pointless mov 
 add    rcxr8  
 cmp    rcxr8  
 jae    00007FFB767741CE  
 inc    rcx  
 test   dl2  
 je     00007FFB767741E9  
 movzx  r8dword ptr [rax]  
 add    rax2  
 mov    r8dr8d                 ; pointless mov   
 add    rcxr8  
 cmp    rcxr8  
 jae    00007FFB767741E9  
 inc    rcx  
 test   dl1  
 je     00007FFB767741FE  
 movzx  eaxbyte ptr [rax]  
 mov    eaxeax                 ; pointless mov   
 add    rcxrax  
 cmp    rcxrax  
 jae    00007FFB767741FE  
 inc    rcx  
 mov    raxrcx  
 shr    rax20h  
 add    eaxecx  
 cmp    eaxecx  
 jae    00007FFB7677420D  
 inc    eax  
 movzx  edxax  
 shr    eax10h  
 movzx  eaxax  
 add    eaxedx  
 movzx  eaxax  
 cmp    eaxedx  
 jge    00007FFB76774224  
 inc    eax  
 movzx  eaxax  
 not    eax  
 movzx  eaxax  
 ret    
```
category:cq
theme:basic-cq
skill-level:intermediate
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>11/05/2018 3:53:33 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17962</IssueLabelID>
    <Title>Mirror changes from dotnet/corefx</Title>
    <Description>This PR contains mirrored changes from dotnet/corefx


**Please REBASE this PR when merging**</Description>
    <Title_Description>Mirror changes from dotnet/corefx This PR contains mirrored changes from dotnet/corefx


**Please REBASE this PR when merging**</Title_Description>
    <Label>
    </Label>
    <Assignee>stephentoub</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17960</IssueLabelID>
    <Title>Add explicit null check for VSD via tail call stub.</Title>
    <Description>Always add explicit null check before calling tail call stub that calls VSD.

Fixes #17585.

For arm64 it hits #6675.</Description>
    <Title_Description>Add explicit null check for VSD via tail call stub. Always add explicit null check before calling tail call stub that calls VSD.

Fixes #17585.

For arm64 it hits #6675.</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>11/05/2018 12:57:15 AM +00:00</CreatedAt>
    <ClosedAt>13/05/2018 4:58:33 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17959</IssueLabelID>
    <Title>LoopCloneContext::EvaluateConditions need to evaluate for const init limit condition. </Title>
    <Description>current EvaluateConditions should evaluate const-init const-limit for not cloning very natural loops
this is **actually** statically known as true. (always taken)

this makes loop to clone(evaluate as not statically known as true or false) which causes not to unroll general natural loops (flagged as `LPFLG_DONT_UNROLL`)
``` 
int[] arr = { 1 2 3 4 };
int total = 0;

for(int i = 0; i &lt; 4; ++i)
{
    total += arr[i];
}
```
actually this loop dosn't really needs to be cloned. (or maybe needs implements for evaluate loop taken count?)
reason why evaluate conditions needs to evaluate const-init const-limit because if this code unrolled the `for` expressions is be always taken.  so its **statically** taken.

here is example
```
int[] arr = { 1 2 3 4 };
int total = 0;

do {
    total += arr[0];
    total += arr[1];
    total += arr[2];
    total += arr[3];
} while(false);
```

but after loop-cloning will not to perform unroll-loop.
this is like ironic like a deadlock.

&gt; Perform `optUnrollLoops` after `optCloneLoops`
https://github.com/dotnet/coreclr/blob/e5299e87b6eda43acb12a3cb341b71e8a3121960/src/jit/compiler.cpp#L4802-L4812

I think transforming `for` or `foreach` expressions into `do~while` need to be separated method from `optCloneLoops`  which that doesn't really need to be cloned.

category:cq
theme:loop-opt
skill-level:expert
cost:medium</Description>
    <Title_Description>LoopCloneContext::EvaluateConditions need to evaluate for const init, limit condition.  current EvaluateConditions should evaluate const-init const-limit for not cloning very natural loops
this is **actually** statically known as true. (always taken)

this makes loop to clone(evaluate as not statically known as true or false) which causes not to unroll general natural loops (flagged as `LPFLG_DONT_UNROLL`)
``` 
int[] arr = { 1 2 3 4 };
int total = 0;

for(int i = 0; i &lt; 4; ++i)
{
    total += arr[i];
}
```
actually this loop dosn't really needs to be cloned. (or maybe needs implements for evaluate loop taken count?)
reason why evaluate conditions needs to evaluate const-init const-limit because if this code unrolled the `for` expressions is be always taken.  so its **statically** taken.

here is example
```
int[] arr = { 1 2 3 4 };
int total = 0;

do {
    total += arr[0];
    total += arr[1];
    total += arr[2];
    total += arr[3];
} while(false);
```

but after loop-cloning will not to perform unroll-loop.
this is like ironic like a deadlock.

&gt; Perform `optUnrollLoops` after `optCloneLoops`
https://github.com/dotnet/coreclr/blob/e5299e87b6eda43acb12a3cb341b71e8a3121960/src/jit/compiler.cpp#L4802-L4812

I think transforming `for` or `foreach` expressions into `do~while` need to be separated method from `optCloneLoops`  which that doesn't really need to be cloned.

category:cq
theme:loop-opt
skill-level:expert
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
    <CreatedAt>11/05/2018 12:31:09 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17958</IssueLabelID>
    <Title>[Arm64] System.Linq.Expressions.Tests.ArrayBoundsTests.SingleNegativeBoundErrorMessage regression</Title>
    <Description>This test case was passing near 2.1 fork.
```
   System.Linq.Expressions.Tests.ArrayBoundsTests.SingleNegativeBoundErrorMessage(useInterpreter: True) [FAIL]
      Assert.Equal() Failure
                   (pos 2)
      Expected: Array dimensions exceeded supported range.
      Actual:   Arithmetic operation resulted in an overflo
                   (pos 2)
```

@dotnet/arm64-contrib @VSadov @OmarTawfik  FYI</Description>
    <Title_Description>[Arm64] System.Linq.Expressions.Tests.ArrayBoundsTests.SingleNegativeBoundErrorMessage regression This test case was passing near 2.1 fork.
```
   System.Linq.Expressions.Tests.ArrayBoundsTests.SingleNegativeBoundErrorMessage(useInterpreter: True) [FAIL]
      Assert.Equal() Failure
                   (pos 2)
      Expected: Array dimensions exceeded supported range.
      Actual:   Arithmetic operation resulted in an overflo
                   (pos 2)
```

@dotnet/arm64-contrib @VSadov @OmarTawfik  FYI</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>VSadov</Assignee>
    <CreatedAt>10/05/2018 10:27:19 PM +00:00</CreatedAt>
    <ClosedAt>20/09/2019 6:43:20 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17956</IssueLabelID>
    <Title>Moving ConcurrentQueue to shared folder</Title>
    <Description>corefx PR: dotnet/corefx#29643

Fixes coreclr issue: #17751 

Related to this [comment](https://github.com/dotnet/coreclr/pull/17800#issuecomment-385092192) made by @stephentoub:
&gt; That just leaves ConcurrentQueue which is used by ThreadPool. I agree that one is reasonable to move down.

cc: @stephentoub @jkotas @safern @danmosemsft </Description>
    <Title_Description>Moving ConcurrentQueue to shared folder corefx PR: dotnet/corefx#29643

Fixes coreclr issue: #17751 

Related to this [comment](https://github.com/dotnet/coreclr/pull/17800#issuecomment-385092192) made by @stephentoub:
&gt; That just leaves ConcurrentQueue which is used by ThreadPool. I agree that one is reasonable to move down.

cc: @stephentoub @jkotas @safern @danmosemsft </Title_Description>
    <Label>area-System.Collections</Label>
    <Assignee>maryamariyan</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17950</IssueLabelID>
    <Title>Build error: PE file is already strong-name signed</Title>
    <Description>Hello.

Next errors happen during build of current master:
```
error : System.Private.CoreLib.dll: PE file is already strong-name signed
error : SOS.NETCore.dll: PE file is already strong-name signed
```

This happens for both Linux x64 and Linux armel cross builds:
```
./build.sh x64 release clang5.0 verbose -rebuild
./build.sh armel release clang5.0 skipgenerateversion verbose cross skipnuget -rebuild
```

Specifically errors happen during execution of the next part of build:

`
Running: msbuild.sh /nologo /verbosity:minimal /clp:Summary  /l:BinClashLoggerTools/Microsoft.DotNet.Build.Tasks.dll;LogFile=binclash.log  build.proj /p:__BuildType=Release /p:__BuildArch=armel /p:__BuildOS=Linux /p:__RootBinDir=bin /p:__IntermediatesDir=bin/obj/Linux.armel.Release  /maxcpucount /p:EnableProfileGuidedOptimization=true /p:RestoreDefaultOptimizationDataPackage=false /p:UsePartialNGENOptimization=false /p:OptimizationDataDir="packages/optimization.Linux-armel.IBC.CoreCLR//data/" /p:PortableBuild=false /t:Rebuild  /flp:Verbosity=normal;LogFile=bin/Logs/System.Private.CoreLib_Release.log     /p:BuildNugetPackage=false  /v:detailed /t:Build /p:UseSharedCompilation=false
`

The errors seem to appear only if flag `-rebuild` is passed to `build.sh`

Do you know what could be the reason of this?

cc @alpencolt @Dmitri-Botcharnikov </Description>
    <Title_Description>Build error: PE file is already strong-name signed Hello.

Next errors happen during build of current master:
```
error : System.Private.CoreLib.dll: PE file is already strong-name signed
error : SOS.NETCore.dll: PE file is already strong-name signed
```

This happens for both Linux x64 and Linux armel cross builds:
```
./build.sh x64 release clang5.0 verbose -rebuild
./build.sh armel release clang5.0 skipgenerateversion verbose cross skipnuget -rebuild
```

Specifically errors happen during execution of the next part of build:

`
Running: msbuild.sh /nologo /verbosity:minimal /clp:Summary  /l:BinClashLoggerTools/Microsoft.DotNet.Build.Tasks.dll;LogFile=binclash.log  build.proj /p:__BuildType=Release /p:__BuildArch=armel /p:__BuildOS=Linux /p:__RootBinDir=bin /p:__IntermediatesDir=bin/obj/Linux.armel.Release  /maxcpucount /p:EnableProfileGuidedOptimization=true /p:RestoreDefaultOptimizationDataPackage=false /p:UsePartialNGENOptimization=false /p:OptimizationDataDir="packages/optimization.Linux-armel.IBC.CoreCLR//data/" /p:PortableBuild=false /t:Rebuild  /flp:Verbosity=normal;LogFile=bin/Logs/System.Private.CoreLib_Release.log     /p:BuildNugetPackage=false  /v:detailed /t:Build /p:UseSharedCompilation=false
`

The errors seem to appear only if flag `-rebuild` is passed to `build.sh`

Do you know what could be the reason of this?

cc @alpencolt @Dmitri-Botcharnikov </Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>alpencolt</Assignee>
    <CreatedAt>10/05/2018 6:16:36 PM +00:00</CreatedAt>
    <ClosedAt>10/05/2018 10:46:44 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17949</IssueLabelID>
    <Title>JIT: track more information about variable definitions in the importer</Title>
    <Description>In many cases the use of a variable has a single reaching definition. We should consider tracking this information in the importer and using it to drive early optimizations.

The idea for now is to look at only the simplest cases ones where a variable has:
* a single definition and all uses are clearly dominated by the definition
  * arguments that are not exposed or redefined
  * a subset of the temps introduced by the jit like the `newobj` temps for ref types
* a single definition where all uses can be shown to be dominated by the definition
  * non-zero init locals that are not exposed or redefined
* zero init locals with one in-method definition where the zero init does not reach any uses

Because these track at most one definition per variable and (for locals) one dataflow bit per local per block the representation shouldn't be super costly.

There are already some precursors of this in the importer code:
* tracking of ref types
* tracking the "this init state" 

We can consider tracking the full definition expression or just some properties of that definition. For instance in some prototypes for #1784 I added non-null tracking for `newobj` temps for ref types. But likely the full expression would be cheap enough to track.

The tracking mechanism needs to be robust in the presence of reimportation and should have some kind of post-importer sanity check.

It would also be good if this information remained viable through the early phases of the jit -- for instance it could be used and maintained during inlining.

category:cq
theme:basic-cq
skill-level:expert
cost:medium</Description>
    <Title_Description>JIT: track more information about variable definitions in the importer In many cases the use of a variable has a single reaching definition. We should consider tracking this information in the importer and using it to drive early optimizations.

The idea for now is to look at only the simplest cases ones where a variable has:
* a single definition and all uses are clearly dominated by the definition
  * arguments that are not exposed or redefined
  * a subset of the temps introduced by the jit like the `newobj` temps for ref types
* a single definition where all uses can be shown to be dominated by the definition
  * non-zero init locals that are not exposed or redefined
* zero init locals with one in-method definition where the zero init does not reach any uses

Because these track at most one definition per variable and (for locals) one dataflow bit per local per block the representation shouldn't be super costly.

There are already some precursors of this in the importer code:
* tracking of ref types
* tracking the "this init state" 

We can consider tracking the full definition expression or just some properties of that definition. For instance in some prototypes for #1784 I added non-null tracking for `newobj` temps for ref types. But likely the full expression would be cheap enough to track.

The tracking mechanism needs to be robust in the presence of reimportation and should have some kind of post-importer sanity check.

It would also be good if this information remained viable through the early phases of the jit -- for instance it could be used and maintained during inlining.

category:cq
theme:basic-cq
skill-level:expert
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
    <CreatedAt>10/05/2018 4:00:58 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17947</IssueLabelID>
    <Title>Add reporting exception from ResolveEHClause</Title>
    <Description>When an exception like EEFileLoadException happens in the
ResolveEHClause it was not caught by the runtime and so it caused exit
with `terminating with uncaught exception of type EEFileLoadException*`
message without any additional details.

This change adds catching the exception reporting its details and call
stack and then failing fast.

Close #16438</Description>
    <Title_Description>Add reporting exception from ResolveEHClause When an exception like EEFileLoadException happens in the
ResolveEHClause it was not caught by the runtime and so it caused exit
with `terminating with uncaught exception of type EEFileLoadException*`
message without any additional details.

This change adds catching the exception reporting its details and call
stack and then failing fast.

Close #16438</Title_Description>
    <Label>area-VM</Label>
    <Assignee>janvorli</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17946</IssueLabelID>
    <Title>ResourceReader Cannot Read Resource File</Title>
    <Description>We are in the process of migrating an application from the .NET Framework to .NET Core 2 but it looks like the ResourceReader cannot process a valid resx file.

When I create the ResourceReader I get 

```
System.ArgumentException: Stream is not a valid resource file.
   at System.Resources.ResourceReader._ReadResources()
   at System.Resources.ResourceReader.ReadResources()
   at System.Resources.ResourceReader..ctor(String fileName)
```


Here is a [gist](https://gist.github.com/zeus82/e45838a029f58784ebe2e118b11f21cf) to the contents of the resx file.</Description>
    <Title_Description>ResourceReader Cannot Read Resource File We are in the process of migrating an application from the .NET Framework to .NET Core 2 but it looks like the ResourceReader cannot process a valid resx file.

When I create the ResourceReader I get 

```
System.ArgumentException: Stream is not a valid resource file.
   at System.Resources.ResourceReader._ReadResources()
   at System.Resources.ResourceReader.ReadResources()
   at System.Resources.ResourceReader..ctor(String fileName)
```


Here is a [gist](https://gist.github.com/zeus82/e45838a029f58784ebe2e118b11f21cf) to the contents of the resx file.</Title_Description>
    <Label>question</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>10/05/2018 12:38:32 PM +00:00</CreatedAt>
    <ClosedAt>10/05/2018 6:47:59 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17944</IssueLabelID>
    <Title>CoreCLR failures when build permissive- + msvc on windows</Title>
    <Description>Hi
We found 3 failures when build CoreCLR with permissive- by msvc on windows could you help take a look?

You can repro this issue as the steps below:
1.	git clone https://github.com/dotnet/coreclr D:\CoreCLR\src
2.	Open VS2017 x86 command prompt and browse to D:\CoreCLR\src
3.	Set  _CL_=/wd5043 /permissive-
4.	build x86 release -Rebuild -- /clp:ShowCommandLine
5.	build-test.cmd x86 release -- /clp:ShowCommandLine

See the issue as following:
Issue #1: 
d:\coreclr\src\src\classlibnative\bcltype\grisu3.h(36): error C4596: 'BiggestPowerTenLessThanOrEqualTo': illegal qualified name in member declaration
Probably fix:
Change
   static void Grisu3::BiggestPowerTenLessThanOrEqualTo(UINT32 number int bits UINT32 *power int *exponent);
To
static void BiggestPowerTenLessThanOrEqualTo(UINT32 number int bits UINT32 *power int *exponent);

Issue #2
d:\coreclr\src\src\vm\dllimport.cpp(6098): error C2664: 'BOOL SString::Find(SString::CIterator &amp;WCHAR) const': cannot convert argument 1 from 'SString::CIterator' to 'SString::CIterator &amp;' [D:\CoreCLR\src\bin\obj\Windows_NT.x86.Release\src\vm\wks\cee_wks.vcxproj]
  d:\coreclr\src\src\vm\dllimport.cpp(6098): note: A non-const reference may only be bound to an lvalue
Probably fix:
Needs to change from:
if (!libNameIsRelativePath ||
!libName.Find(libName.Begin() W('.')) ||

To:
auto it = libName.Begin();
if (!libNameIsRelativePath ||
!libName.Find(it W('.')) ||

Issue #3 
d:\coreclr\src\src\inc\winrt\paraminstanceapi.h(422): error C3861: '_size': identifier not found (compiling source file D:\CoreCLR\src\src\vm\interoputil.cpp
Probably fix:
Change
for (size_t i = 0; i != _size; ++i) 
To
for (size_t i = 0; i != size; ++i)
</Description>
    <Title_Description>CoreCLR failures when build permissive- + msvc on windows Hi
We found 3 failures when build CoreCLR with permissive- by msvc on windows could you help take a look?

You can repro this issue as the steps below:
1.	git clone https://github.com/dotnet/coreclr D:\CoreCLR\src
2.	Open VS2017 x86 command prompt and browse to D:\CoreCLR\src
3.	Set  _CL_=/wd5043 /permissive-
4.	build x86 release -Rebuild -- /clp:ShowCommandLine
5.	build-test.cmd x86 release -- /clp:ShowCommandLine

See the issue as following:
Issue #1: 
d:\coreclr\src\src\classlibnative\bcltype\grisu3.h(36): error C4596: 'BiggestPowerTenLessThanOrEqualTo': illegal qualified name in member declaration
Probably fix:
Change
   static void Grisu3::BiggestPowerTenLessThanOrEqualTo(UINT32 number int bits UINT32 *power int *exponent);
To
static void BiggestPowerTenLessThanOrEqualTo(UINT32 number int bits UINT32 *power int *exponent);

Issue #2
d:\coreclr\src\src\vm\dllimport.cpp(6098): error C2664: 'BOOL SString::Find(SString::CIterator &amp;WCHAR) const': cannot convert argument 1 from 'SString::CIterator' to 'SString::CIterator &amp;' [D:\CoreCLR\src\bin\obj\Windows_NT.x86.Release\src\vm\wks\cee_wks.vcxproj]
  d:\coreclr\src\src\vm\dllimport.cpp(6098): note: A non-const reference may only be bound to an lvalue
Probably fix:
Needs to change from:
if (!libNameIsRelativePath ||
!libName.Find(libName.Begin() W('.')) ||

To:
auto it = libName.Begin();
if (!libNameIsRelativePath ||
!libName.Find(it W('.')) ||

Issue #3 
d:\coreclr\src\src\inc\winrt\paraminstanceapi.h(422): error C3861: '_size': identifier not found (compiling source file D:\CoreCLR\src\src\vm\interoputil.cpp
Probably fix:
Change
for (size_t i = 0; i != _size; ++i) 
To
for (size_t i = 0; i != size; ++i)
</Title_Description>
    <Label>Hackathon</Label>
    <Assignee>kant2002</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17943</IssueLabelID>
    <Title>Reliability - Watson crash in AssemblySpec::Bind  </Title>
    <Description>We have a failure during EEStartup tracked by this internal Watson bucket:
https://watson/Failure?FailureSearchText=4a3aff04-3ef6-bbbe-2ae8-2cffa0b278c3

This accounts for 91.6% of reported external failures in coreclr.dll:

    0 coreclr!AssemblySpec::Bind  0x0000000000000183    coreassemblyspec.cpp 
    1 coreclr!AppDomain::BindAssemblySpec  0x0000000000000126    appdomain.cpp 
    2 coreclr!PEFile::LoadAssembly  0x000000000000010C    pefile.cpp 
    3 coreclr!Module::LoadAssembly  0x00000000000000F6    ceeload.cpp 
    4 coreclr!Assembly::FindModuleByTypeRef  0x00000000000001F9    assembly.cpp 
    5 coreclr!ClassLoader::LoadTypeDefOrRefThrowing  0x00000000000002AE    clsload.cpp 
    6 coreclr!SigPointer::GetTypeHandleThrowing  0x000000000000021F    siginfo.cpp 
    7 coreclr!MemberLoader::GetDescFromMemberRef  0x000000000000039B    memberload.cpp 
    8 coreclr!CEEInfo::resolveToken  0x00000000000005A6    jitinterface.cpp 
    9 clrjit!Compiler::impImportBlockCode  0x0000000000000927    importer.cpp 
    10 clrjit!Compiler::impImportBlock  0x0000000000000093    importer.cpp 
    11 clrjit!Compiler::impImport  0x00000000000002DB    importer.cpp 
    12 clrjit!Compiler::compCompile  0x00000000000000A4    compiler.cpp 
    13 clrjit!Compiler::compCompileHelper  0x0000000000000299    compiler.cpp 
    14 clrjit!Compiler::compCompile  0x000000000000025D    compiler.cpp 
    15 clrjit!jitNativeCode  0x000000000000026E    compiler.cpp 
    16 clrjit!CILJit::compileMethod  0x00000000000000A2    ee_il_dll.cpp 
    17 coreclr!invokeCompileMethod  0x00000000000000E5    jitinterface.cpp 
    18 coreclr!CallCompileMethodWithSEHWrapper  0x0000000000000052    jitinterface.cpp 
    19 coreclr!UnsafeJitFunction  0x00000000000004F5    jitinterface.cpp 
    20 coreclr!MethodDesc::JitCompileCodeLocked  0x00000000000001FE    prestub.cpp 
    21 coreclr!MethodDesc::JitCompileCodeLockedEventWrapper  0x00000000001313C1    prestub.cpp 
    22 coreclr!MethodDesc::JitCompileCode  0x0000000000000399    prestub.cpp 
    23 coreclr!MethodDesc::DoPrestub  0x000000000000059E    prestub.cpp 
    24 coreclr!PreStubWorker  0x000000000000037A    prestub.cpp 
    25 coreclr!ThePreStub  0x0000000000000055    ThePreStubAMD64.asm 
    26 coreclr!CallDescrWorkerInternal  0x0000000000000083    CallDescrWorkerAMD64.asm 
    27 coreclr!MethodDescCallSite::CallTargetWorker  0x00000000000002B5    callhelpers.cpp 
    28 coreclr!AppDomain::InitializeDomainContext  0x0000000000000105    appdomain.cpp 
    29 coreclr!SystemDomain::InitializeDefaultDomain  0x000000000000004E    appdomain.cpp 
    30 coreclr!SystemDomain::SetupDefaultDomain  0x0000000000000199    appdomain.cpp 
    31 coreclr!SystemDomain::SetupDefaultDomainNoThrow  0x000000000000004D    appdomain.cpp 
    32 coreclr!EEStartup  0x000000000000006E    ceemain.cpp 
</Description>
    <Title_Description>Reliability - Watson crash in AssemblySpec::Bind   We have a failure during EEStartup tracked by this internal Watson bucket:
https://watson/Failure?FailureSearchText=4a3aff04-3ef6-bbbe-2ae8-2cffa0b278c3

This accounts for 91.6% of reported external failures in coreclr.dll:

    0 coreclr!AssemblySpec::Bind  0x0000000000000183    coreassemblyspec.cpp 
    1 coreclr!AppDomain::BindAssemblySpec  0x0000000000000126    appdomain.cpp 
    2 coreclr!PEFile::LoadAssembly  0x000000000000010C    pefile.cpp 
    3 coreclr!Module::LoadAssembly  0x00000000000000F6    ceeload.cpp 
    4 coreclr!Assembly::FindModuleByTypeRef  0x00000000000001F9    assembly.cpp 
    5 coreclr!ClassLoader::LoadTypeDefOrRefThrowing  0x00000000000002AE    clsload.cpp 
    6 coreclr!SigPointer::GetTypeHandleThrowing  0x000000000000021F    siginfo.cpp 
    7 coreclr!MemberLoader::GetDescFromMemberRef  0x000000000000039B    memberload.cpp 
    8 coreclr!CEEInfo::resolveToken  0x00000000000005A6    jitinterface.cpp 
    9 clrjit!Compiler::impImportBlockCode  0x0000000000000927    importer.cpp 
    10 clrjit!Compiler::impImportBlock  0x0000000000000093    importer.cpp 
    11 clrjit!Compiler::impImport  0x00000000000002DB    importer.cpp 
    12 clrjit!Compiler::compCompile  0x00000000000000A4    compiler.cpp 
    13 clrjit!Compiler::compCompileHelper  0x0000000000000299    compiler.cpp 
    14 clrjit!Compiler::compCompile  0x000000000000025D    compiler.cpp 
    15 clrjit!jitNativeCode  0x000000000000026E    compiler.cpp 
    16 clrjit!CILJit::compileMethod  0x00000000000000A2    ee_il_dll.cpp 
    17 coreclr!invokeCompileMethod  0x00000000000000E5    jitinterface.cpp 
    18 coreclr!CallCompileMethodWithSEHWrapper  0x0000000000000052    jitinterface.cpp 
    19 coreclr!UnsafeJitFunction  0x00000000000004F5    jitinterface.cpp 
    20 coreclr!MethodDesc::JitCompileCodeLocked  0x00000000000001FE    prestub.cpp 
    21 coreclr!MethodDesc::JitCompileCodeLockedEventWrapper  0x00000000001313C1    prestub.cpp 
    22 coreclr!MethodDesc::JitCompileCode  0x0000000000000399    prestub.cpp 
    23 coreclr!MethodDesc::DoPrestub  0x000000000000059E    prestub.cpp 
    24 coreclr!PreStubWorker  0x000000000000037A    prestub.cpp 
    25 coreclr!ThePreStub  0x0000000000000055    ThePreStubAMD64.asm 
    26 coreclr!CallDescrWorkerInternal  0x0000000000000083    CallDescrWorkerAMD64.asm 
    27 coreclr!MethodDescCallSite::CallTargetWorker  0x00000000000002B5    callhelpers.cpp 
    28 coreclr!AppDomain::InitializeDomainContext  0x0000000000000105    appdomain.cpp 
    29 coreclr!SystemDomain::InitializeDefaultDomain  0x000000000000004E    appdomain.cpp 
    30 coreclr!SystemDomain::SetupDefaultDomain  0x0000000000000199    appdomain.cpp 
    31 coreclr!SystemDomain::SetupDefaultDomainNoThrow  0x000000000000004D    appdomain.cpp 
    32 coreclr!EEStartup  0x000000000000006E    ceemain.cpp 
</Title_Description>
    <Label>area-AssemblyLoader</Label>
    <Assignee>jeffschwMSFT</Assignee>
    <CreatedAt>10/05/2018 1:50:51 AM +00:00</CreatedAt>
    <ClosedAt>13/06/2018 4:35:17 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17936</IssueLabelID>
    <Title>Fix alternate stack for Alpine docker on SELinux</Title>
    <Description>For some reason the Alpine docker container running on a SELinux host maps
heap as RWX. When we allocate alternate stack from the heap we also
change the protection of the first page to PROT_NONE so that it can
serve as a guard page to catch stack overflow. And when we free the
alternate stack we restore the protection back to PROT_READ |
PROT_WRITE. The restoration fails in Alpine docker container running on
a SELinux host with EPROT failure and the SELinux log reports that an
attempt to change heap to executable was made. So it looks like the
kernel has added the PERM_EXEC to the permissions we have passed to the
mprotect call. There is a code in the mprotect implementation that can
do that although I don't fully understand the exact conditions under which it
happens yet. This is driven by the VM_MAYEXEC flag in the internal VMA block
structure. 
To fix that I've modified the alternate stack allocation to use mmap /
munmap instead of C heap allocation.

Close #17931</Description>
    <Title_Description>Fix alternate stack for Alpine docker on SELinux For some reason the Alpine docker container running on a SELinux host maps
heap as RWX. When we allocate alternate stack from the heap we also
change the protection of the first page to PROT_NONE so that it can
serve as a guard page to catch stack overflow. And when we free the
alternate stack we restore the protection back to PROT_READ |
PROT_WRITE. The restoration fails in Alpine docker container running on
a SELinux host with EPROT failure and the SELinux log reports that an
attempt to change heap to executable was made. So it looks like the
kernel has added the PERM_EXEC to the permissions we have passed to the
mprotect call. There is a code in the mprotect implementation that can
do that although I don't fully understand the exact conditions under which it
happens yet. This is driven by the VM_MAYEXEC flag in the internal VMA block
structure. 
To fix that I've modified the alternate stack allocation to use mmap /
munmap instead of C heap allocation.

Close #17931</Title_Description>
    <Label>area-PAL</Label>
    <Assignee>janvorli</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17935</IssueLabelID>
    <Title>JIT: have inlining heuristics look for cases where inlining might enable devirtualization</Title>
    <Description>When a caller argument is an exact type and feeds a virtual or interface call in the callee we might want to inline more aggressively.

A toy example of this can be found in [this BenchmarkDotNet sample](https://github.com/dotnet/BenchmarkDotNet/blob/master/samples/BenchmarkDotNet.Samples/JIT/Jit_InterfaceMethod.cs). Here `Run` if inlined would allow the interface calls to devirtualize.

`Run` is currently pretty far from being a viable inline candidate:
```
Inline candidate callsite is boring.  Multiplier increased to 1.3.
calleeNativeSizeEstimate=545
callsiteNativeSizeEstimate=115
benefit multiplier=1.3
threshold=149
Native estimate for function size exceeds threshold for inlining 54.5 &gt; 14.9 (multiplier = 1.3)

Inline expansion aborted inline not profitable

INLINER: during 'fgInline' result 'failed this call site' reason 'unprofitable inline' for
'Jit_InterfaceMethod:Run1():double:this' calling 'Jit_InterfaceMethod:Run(ref):double:this'
```
Caller knows that the argument to `Run` is exact:
```
lvaUpdateClass: Updating class for V01 (00007FF966344CD0) Foo1 to be exact

               [000029] ------------              *  STMT      void  (IL 0x00C...  ???)
               [000027] I-C-G-------              \--*  CALL      double Jit_InterfaceMethod.Run
               [000025] ------------ this in rcx     +--*  LCL_VAR   ref    V00 this         
               [000026] ------------ arg1            \--*  LCL_VAR   ref    V01 loc0         
```

Likely we would not give a ~3.65x boost to inlining benefit based on one argument reaching one call site. But if we also realized the call site was in a loop perhaps the net effect would be enough to justify an inline.

Currently we don't know when observing arg uses whether that use is in a loop or not. But if we were to associate uses with callee IL offsets we could circle back after finding all the branch targets and develop a crude estimator for loop depth then sum up the weighted observations.

It would also be nice to tabulate a few more opportunities of this kind. The basic observational part change is simple enough to prototype that perhaps just building it is one way to make forward progress.

category:cq
theme:inlining
skill-level:intermediate
cost:medium</Description>
    <Title_Description>JIT: have inlining heuristics look for cases where inlining might enable devirtualization When a caller argument is an exact type and feeds a virtual or interface call in the callee we might want to inline more aggressively.

A toy example of this can be found in [this BenchmarkDotNet sample](https://github.com/dotnet/BenchmarkDotNet/blob/master/samples/BenchmarkDotNet.Samples/JIT/Jit_InterfaceMethod.cs). Here `Run` if inlined would allow the interface calls to devirtualize.

`Run` is currently pretty far from being a viable inline candidate:
```
Inline candidate callsite is boring.  Multiplier increased to 1.3.
calleeNativeSizeEstimate=545
callsiteNativeSizeEstimate=115
benefit multiplier=1.3
threshold=149
Native estimate for function size exceeds threshold for inlining 54.5 &gt; 14.9 (multiplier = 1.3)

Inline expansion aborted inline not profitable

INLINER: during 'fgInline' result 'failed this call site' reason 'unprofitable inline' for
'Jit_InterfaceMethod:Run1():double:this' calling 'Jit_InterfaceMethod:Run(ref):double:this'
```
Caller knows that the argument to `Run` is exact:
```
lvaUpdateClass: Updating class for V01 (00007FF966344CD0) Foo1 to be exact

               [000029] ------------              *  STMT      void  (IL 0x00C...  ???)
               [000027] I-C-G-------              \--*  CALL      double Jit_InterfaceMethod.Run
               [000025] ------------ this in rcx     +--*  LCL_VAR   ref    V00 this         
               [000026] ------------ arg1            \--*  LCL_VAR   ref    V01 loc0         
```

Likely we would not give a ~3.65x boost to inlining benefit based on one argument reaching one call site. But if we also realized the call site was in a loop perhaps the net effect would be enough to justify an inline.

Currently we don't know when observing arg uses whether that use is in a loop or not. But if we were to associate uses with callee IL offsets we could circle back after finding all the branch targets and develop a crude estimator for loop depth then sum up the weighted observations.

It would also be nice to tabulate a few more opportunities of this kind. The basic observational part change is simple enough to prototype that perhaps just building it is one way to make forward progress.

category:cq
theme:inlining
skill-level:intermediate
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
    <CreatedAt>9/05/2018 10:06:21 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17934</IssueLabelID>
    <Title>[arm/arm64] fix semicolon and priorities for new excluded tests</Title>
    <Description>Small fix for #17855.</Description>
    <Title_Description>[arm/arm64] fix semicolon and priorities for new excluded tests Small fix for #17855.</Title_Description>
    <Label>test enhancement</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>9/05/2018 9:48:36 PM +00:00</CreatedAt>
    <ClosedAt>10/05/2018 12:14:25 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17933</IssueLabelID>
    <Title>[Arm64/Linux] SDK fails to build hello world</Title>
    <Description>@richlander @dotnet/arm64-contrib @Petermarcu 

As noted in various places the 2.1 arm64-linux SDK is failing during the build of Hello World with either an assertion or a segmentation fault</Description>
    <Title_Description>[Arm64/Linux] SDK fails to build hello world @richlander @dotnet/arm64-contrib @Petermarcu 

As noted in various places the 2.1 arm64-linux SDK is failing during the build of Hello World with either an assertion or a segmentation fault</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>richlander</Assignee>
    <CreatedAt>9/05/2018 5:20:33 PM +00:00</CreatedAt>
    <ClosedAt>18/05/2018 6:11:51 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17932</IssueLabelID>
    <Title>Possible Performance Regression from 2.0.7 to 2.1-RC1 on Windows Server 2016 w/ Hyper-V Role</Title>
    <Description>@Mike-EEE commented on [Wed May 09 2018](https://github.com/dotnet/core/issues/1524)

Hello .NET Core Team and Community

I have a very interesting performance issue for you here.  I have produced some code that demonstrates a regressing difference in performance when switching from the .NET Core 2.0.x runtime to 2.1-RC1 on my Windows Server 2016 machine that I am using as a Hyper-V server.  Please note that I am also using Visual Studio 2017 15.7.1 in producing my output here.

To start this issue has context that is most recently rooted in a Benchmark.NET issue that you [can view here](https://github.com/dotnet/BenchmarkDotNet/issues/739).  I have created a series of five benchmarks using the exact same underlying test code.  Each have a slight modification that produce different results in 2.0.7 when run on my Windows Server host machine (note: the host machine and not a VM instance).  You can see an [overview of this information here](https://github.com/dotnet/BenchmarkDotNet/issues/739#issuecomment-386811232).

I took the code that is in the 3rd example and by simply rebuilding it and running it in the 2.1 runtime it produced slower results.  I have [created this 2.1 branch here](https://github.com/Mike-EEE/BenchmarkDotNet.InProcess/tree/TheWeird_03a) for your convenience.

(Please do note that the results of each scenario are found in the README.md of their respective branches.)

Additionally with a small change I was once again able to produce the faster result times as seen in 2.0.7 but within the 2.1 runtime.  I have published this [branch here](https://github.com/Mike-EEE/BenchmarkDotNet.InProcess/tree/TheWeird_03b).  This is consistent with the bizarre behavior referenced in the five earlier examples but seen here in a different form (or configuration for lack of a better term) in 2.1.

I feel it's worthy to note that I believe that this is a gremlin of a problem that I have been chasing in .NET Core tooling since 1.1.  I have encountered the most weird of circumstances around this behavior while trying to benchmark code using Benchmark.NET.  You can see previous iterations of my previous more complicated attempts at wrestling this beast here for your reference:
https://github.com/dotnet/BenchmarkDotNet/issues/330
https://github.com/dotnet/BenchmarkDotNet/issues/433

Now that I have been able to show a (regressing) discrepancy in performance between 2.0.7 and 2.1 RC1 with a simple recompile I believe this could be due to a tooling/SDK problem that has been around for some time now.  Fortunately I have been able to capture it using a very simple project this time and am more than happy to share it now in hopes to finally tracking down this very weird issue. 😄 

Finally I will provide an overview of my Windows Server specifications here.

```
Summary
		Operating System
			Windows Server 2016 Standard 64-bit
		CPU
			Intel Core i7 4820K @ 3.70GHz	38 °C
			Ivy Bridge-E 22nm Technology
		RAM
			48.0GB DDR3 @ 792MHz (9-9-9-27)
		Motherboard
			ASUSTeK COMPUTER INC. RAMPAGE IV EXTREME (LGA2011)	30 °C
		Graphics
			VW246 (1920x1080@60Hz)
			G246HL (1920x1080@60Hz)
			VW246 (1920x1080@60Hz)
			VW246 (1920x1080@60Hz)
			2047MB NVIDIA GeForce GTX 660 (Gigabyte)	30 °C
		Storage
			238GB Samsung SSD 840 PRO Series (SSD)	25 °C
			892GB Microsoft Storage Space Device (SSD)	28 °C
			463GB Microsoft Storage Space Device (SSD)	28 °C
			1536GB SYNOLOGY iSCSI Storage SCSI Disk Device (iSCSI)
		Optical Drives
			No optical disk drives detected
		Audio
			High Definition Audio Device
Operating System
	Windows Server 2016 Standard 64-bit
	Computer type: Virtual
	Installation Date: 5/8/2017 4:41:12 PM

CPU
		Intel Core i7 4820K
			Cores	4
			Threads	8
			Name	Intel Core i7 4820K
			Code Name	Ivy Bridge-E
			Package	Socket 2011 LGA
			Technology	22nm
			Specification	Intel Core i7-4820K CPU @ 3.70GHz
			Family	6
			Extended Family	6
			Model	E
			Extended Model	3E
			Stepping	4
			Revision	S0/S1
			Instructions	MMX SSE SSE2 SSE3 SSSE3 SSE4.1 SSE4.2 Intel 64 NX AES AVX
			Virtualization	Not supported
			Hyperthreading	Supported Enabled
			Fan Speed	594 RPM
			Rated Bus Speed	3167.2 MHz
			Stock Core Speed	3700 MHz
			Stock Bus Speed	100 MHz
			Average Temperature	38 °C
				Caches
					L1 Data Cache Size	4 x 32 KBytes
					L1 Instructions Cache Size	4 x 32 KBytes
					L2 Unified Cache Size	4 x 256 KBytes
					L3 Unified Cache Size	10240 KBytes
				Cores
						Core 0
							Core Speed	4552.8 MHz
							Multiplier	x 46.0
							Bus Speed	99.0 MHz
							Rated Bus Speed	3167.2 MHz
							Temperature	35 °C
							Threads	APIC ID: 0 1
						Core 1
							Core Speed	4651.8 MHz
							Multiplier	x 47.0
							Bus Speed	99.0 MHz
							Rated Bus Speed	3167.2 MHz
							Temperature	36 °C
							Threads	APIC ID: 2 3
						Core 2
							Core Speed	4552.8 MHz
							Multiplier	x 46.0
							Bus Speed	99.0 MHz
							Rated Bus Speed	3167.2 MHz
							Temperature	42 °C
							Threads	APIC ID: 4 5
						Core 3
							Core Speed	4552.8 MHz
							Multiplier	x 46.0
							Bus Speed	99.0 MHz
							Rated Bus Speed	3167.2 MHz
							Temperature	38 °C
							Threads	APIC ID: 6 7
RAM
		Memory slots
			Total memory slots	8
			Used memory slots	6
			Free memory slots	2
		Memory
			Type	DDR3
			Size	49152 MBytes
			DRAM Frequency	791.8 MHz
			CAS# Latency (CL)	9 clocks
			RAS# to CAS# Delay (tRCD)	9 clocks
			RAS# Precharge (tRP)	9 clocks
			Cycle Time (tRAS)	27 clocks
			Command Rate (CR)	2T
		Physical Memory
			Memory Usage	64 %
			Total Physical	48 GB
			Available Physical	17 GB
			Total Virtual	96 GB
			Available Virtual	64 GB
		SPD
			Number Of SPD Modules	6
				Slot #1
					Type	DDR3
					Size	8192 MBytes
					Manufacturer	Kingston
					Max Bandwidth	PC3-10700 (667 MHz)
					Part Number	KHX2133C11D3/8GX
					Week/year	42 / 13
					SPD Ext.	XMP
						Timing table
								JEDEC #1
									Frequency	457.1 MHz
									CAS# Latency	6.0
									RAS# To CAS#	6
									RAS# Precharge	6
									tRAS	17
									tRC	23
									Voltage	1.500 V
								JEDEC #2
									Frequency	533.3 MHz
									CAS# Latency	7.0
									RAS# To CAS#	7
									RAS# Precharge	7
									tRAS	20
									tRC	27
									Voltage	1.500 V
								JEDEC #3
									Frequency	609.5 MHz
									CAS# Latency	8.0
									RAS# To CAS#	8
									RAS# Precharge	8
									tRAS	22
									tRC	30
									Voltage	1.500 V
								JEDEC #4
									Frequency	666.7 MHz
									CAS# Latency	9.0
									RAS# To CAS#	9
									RAS# Precharge	9
									tRAS	24
									tRC	33
									Voltage	1.500 V
								XMP-2132
									Frequency	1066 MHz
									CAS# Latency	11.0
									RAS# To CAS#	12
									RAS# Precharge	11
									tRAS	30
									Voltage	1.600 V
				Slot #2
					Type	DDR3
					Size	8192 MBytes
					Manufacturer	Kingston
					Max Bandwidth	PC3-10700 (667 MHz)
					Part Number	KHX2133C11D3/8GX
					Week/year	42 / 13
					SPD Ext.	XMP
						Timing table
								JEDEC #1
									Frequency	457.1 MHz
									CAS# Latency	6.0
									RAS# To CAS#	6
									RAS# Precharge	6
									tRAS	17
									tRC	23
									Voltage	1.500 V
								JEDEC #2
									Frequency	533.3 MHz
									CAS# Latency	7.0
									RAS# To CAS#	7
									RAS# Precharge	7
									tRAS	20
									tRC	27
									Voltage	1.500 V
								JEDEC #3
									Frequency	609.5 MHz
									CAS# Latency	8.0
									RAS# To CAS#	8
									RAS# Precharge	8
									tRAS	22
									tRC	30
									Voltage	1.500 V
								JEDEC #4
									Frequency	666.7 MHz
									CAS# Latency	9.0
									RAS# To CAS#	9
									RAS# Precharge	9
									tRAS	24
									tRC	33
									Voltage	1.500 V
								XMP-2132
									Frequency	1066 MHz
									CAS# Latency	11.0
									RAS# To CAS#	12
									RAS# Precharge	11
									tRAS	30
									Voltage	1.600 V
				Slot #3
					Type	DDR3
					Size	8192 MBytes
					Manufacturer	Kingston
					Max Bandwidth	PC3-10700 (667 MHz)
					Part Number	KHX2133C11D3/8GX
					Week/year	42 / 13
					SPD Ext.	XMP
						Timing table
								JEDEC #1
									Frequency	457.1 MHz
									CAS# Latency	6.0
									RAS# To CAS#	6
									RAS# Precharge	6
									tRAS	17
									tRC	23
									Voltage	1.500 V
								JEDEC #2
									Frequency	533.3 MHz
									CAS# Latency	7.0
									RAS# To CAS#	7
									RAS# Precharge	7
									tRAS	20
									tRC	27
									Voltage	1.500 V
								JEDEC #3
									Frequency	609.5 MHz
									CAS# Latency	8.0
									RAS# To CAS#	8
									RAS# Precharge	8
									tRAS	22
									tRC	30
									Voltage	1.500 V
								JEDEC #4
									Frequency	666.7 MHz
									CAS# Latency	9.0
									RAS# To CAS#	9
									RAS# Precharge	9
									tRAS	24
									tRC	33
									Voltage	1.500 V
								XMP-2132
									Frequency	1066 MHz
									CAS# Latency	11.0
									RAS# To CAS#	12
									RAS# Precharge	11
									tRAS	30
									Voltage	1.600 V
				Slot #4
					Type	DDR3
					Size	8192 MBytes
					Manufacturer	Kingston
					Max Bandwidth	PC3-10700 (667 MHz)
					Part Number	KHX2133C11D3/8GX
					Week/year	42 / 13
					SPD Ext.	XMP
						Timing table
								JEDEC #1
									Frequency	457.1 MHz
									CAS# Latency	6.0
									RAS# To CAS#	6
									RAS# Precharge	6
									tRAS	17
									tRC	23
									Voltage	1.500 V
								JEDEC #2
									Frequency	533.3 MHz
									CAS# Latency	7.0
									RAS# To CAS#	7
									RAS# Precharge	7
									tRAS	20
									tRC	27
									Voltage	1.500 V
								JEDEC #3
									Frequency	609.5 MHz
									CAS# Latency	8.0
									RAS# To CAS#	8
									RAS# Precharge	8
									tRAS	22
									tRC	30
									Voltage	1.500 V
								JEDEC #4
									Frequency	666.7 MHz
									CAS# Latency	9.0
									RAS# To CAS#	9
									RAS# Precharge	9
									tRAS	24
									tRC	33
									Voltage	1.500 V
								XMP-2132
									Frequency	1066 MHz
									CAS# Latency	11.0
									RAS# To CAS#	12
									RAS# Precharge	11
									tRAS	30
									Voltage	1.600 V
				Slot #5
					Type	DDR3
					Size	8192 MBytes
					Manufacturer	Kingston
					Max Bandwidth	PC3-10700 (667 MHz)
					Part Number	KHX2133C11D3/8GX
					Week/year	42 / 13
					SPD Ext.	XMP
						Timing table
								JEDEC #1
									Frequency	457.1 MHz
									CAS# Latency	6.0
									RAS# To CAS#	6
									RAS# Precharge	6
									tRAS	17
									tRC	23
									Voltage	1.500 V
								JEDEC #2
									Frequency	533.3 MHz
									CAS# Latency	7.0
									RAS# To CAS#	7
									RAS# Precharge	7
									tRAS	20
									tRC	27
									Voltage	1.500 V
								JEDEC #3
									Frequency	609.5 MHz
									CAS# Latency	8.0
									RAS# To CAS#	8
									RAS# Precharge	8
									tRAS	22
									tRC	30
									Voltage	1.500 V
								JEDEC #4
									Frequency	666.7 MHz
									CAS# Latency	9.0
									RAS# To CAS#	9
									RAS# Precharge	9
									tRAS	24
									tRC	33
									Voltage	1.500 V
								XMP-2132
									Frequency	1066 MHz
									CAS# Latency	11.0
									RAS# To CAS#	12
									RAS# Precharge	11
									tRAS	30
									Voltage	1.600 V
				Slot #6
					Type	DDR3
					Size	8192 MBytes
					Manufacturer	Kingston
					Max Bandwidth	PC3-10700 (667 MHz)
					Part Number	KHX2133C11D3/8GX
					Week/year	42 / 13
					SPD Ext.	XMP
						Timing table
								JEDEC #1
									Frequency	457.1 MHz
									CAS# Latency	6.0
									RAS# To CAS#	6
									RAS# Precharge	6
									tRAS	17
									tRC	23
									Voltage	1.500 V
								JEDEC #2
									Frequency	533.3 MHz
									CAS# Latency	7.0
									RAS# To CAS#	7
									RAS# Precharge	7
									tRAS	20
									tRC	27
									Voltage	1.500 V
								JEDEC #3
									Frequency	609.5 MHz
									CAS# Latency	8.0
									RAS# To CAS#	8
									RAS# Precharge	8
									tRAS	22
									tRC	30
									Voltage	1.500 V
								JEDEC #4
									Frequency	666.7 MHz
									CAS# Latency	9.0
									RAS# To CAS#	9
									RAS# Precharge	9
									tRAS	24
									tRC	33
									Voltage	1.500 V
								XMP-2132
									Frequency	1066 MHz
									CAS# Latency	11.0
									RAS# To CAS#	12
									RAS# Precharge	11
									tRAS	30
									Voltage	1.600 V
```

Please let me know if you require any further information around this issue or my environment and I will be happy to get it for you.

Thank you for any assistance you can provide towards solving this issue!

</Description>
    <Title_Description>Possible Performance Regression from 2.0.7 to 2.1-RC1 on Windows Server 2016 w/ Hyper-V Role @Mike-EEE commented on [Wed May 09 2018](https://github.com/dotnet/core/issues/1524)

Hello .NET Core Team and Community

I have a very interesting performance issue for you here.  I have produced some code that demonstrates a regressing difference in performance when switching from the .NET Core 2.0.x runtime to 2.1-RC1 on my Windows Server 2016 machine that I am using as a Hyper-V server.  Please note that I am also using Visual Studio 2017 15.7.1 in producing my output here.

To start this issue has context that is most recently rooted in a Benchmark.NET issue that you [can view here](https://github.com/dotnet/BenchmarkDotNet/issues/739).  I have created a series of five benchmarks using the exact same underlying test code.  Each have a slight modification that produce different results in 2.0.7 when run on my Windows Server host machine (note: the host machine and not a VM instance).  You can see an [overview of this information here](https://github.com/dotnet/BenchmarkDotNet/issues/739#issuecomment-386811232).

I took the code that is in the 3rd example and by simply rebuilding it and running it in the 2.1 runtime it produced slower results.  I have [created this 2.1 branch here](https://github.com/Mike-EEE/BenchmarkDotNet.InProcess/tree/TheWeird_03a) for your convenience.

(Please do note that the results of each scenario are found in the README.md of their respective branches.)

Additionally with a small change I was once again able to produce the faster result times as seen in 2.0.7 but within the 2.1 runtime.  I have published this [branch here](https://github.com/Mike-EEE/BenchmarkDotNet.InProcess/tree/TheWeird_03b).  This is consistent with the bizarre behavior referenced in the five earlier examples but seen here in a different form (or configuration for lack of a better term) in 2.1.

I feel it's worthy to note that I believe that this is a gremlin of a problem that I have been chasing in .NET Core tooling since 1.1.  I have encountered the most weird of circumstances around this behavior while trying to benchmark code using Benchmark.NET.  You can see previous iterations of my previous more complicated attempts at wrestling this beast here for your reference:
https://github.com/dotnet/BenchmarkDotNet/issues/330
https://github.com/dotnet/BenchmarkDotNet/issues/433

Now that I have been able to show a (regressing) discrepancy in performance between 2.0.7 and 2.1 RC1 with a simple recompile I believe this could be due to a tooling/SDK problem that has been around for some time now.  Fortunately I have been able to capture it using a very simple project this time and am more than happy to share it now in hopes to finally tracking down this very weird issue. 😄 

Finally I will provide an overview of my Windows Server specifications here.

```
Summary
		Operating System
			Windows Server 2016 Standard 64-bit
		CPU
			Intel Core i7 4820K @ 3.70GHz	38 °C
			Ivy Bridge-E 22nm Technology
		RAM
			48.0GB DDR3 @ 792MHz (9-9-9-27)
		Motherboard
			ASUSTeK COMPUTER INC. RAMPAGE IV EXTREME (LGA2011)	30 °C
		Graphics
			VW246 (1920x1080@60Hz)
			G246HL (1920x1080@60Hz)
			VW246 (1920x1080@60Hz)
			VW246 (1920x1080@60Hz)
			2047MB NVIDIA GeForce GTX 660 (Gigabyte)	30 °C
		Storage
			238GB Samsung SSD 840 PRO Series (SSD)	25 °C
			892GB Microsoft Storage Space Device (SSD)	28 °C
			463GB Microsoft Storage Space Device (SSD)	28 °C
			1536GB SYNOLOGY iSCSI Storage SCSI Disk Device (iSCSI)
		Optical Drives
			No optical disk drives detected
		Audio
			High Definition Audio Device
Operating System
	Windows Server 2016 Standard 64-bit
	Computer type: Virtual
	Installation Date: 5/8/2017 4:41:12 PM

CPU
		Intel Core i7 4820K
			Cores	4
			Threads	8
			Name	Intel Core i7 4820K
			Code Name	Ivy Bridge-E
			Package	Socket 2011 LGA
			Technology	22nm
			Specification	Intel Core i7-4820K CPU @ 3.70GHz
			Family	6
			Extended Family	6
			Model	E
			Extended Model	3E
			Stepping	4
			Revision	S0/S1
			Instructions	MMX SSE SSE2 SSE3 SSSE3 SSE4.1 SSE4.2 Intel 64 NX AES AVX
			Virtualization	Not supported
			Hyperthreading	Supported Enabled
			Fan Speed	594 RPM
			Rated Bus Speed	3167.2 MHz
			Stock Core Speed	3700 MHz
			Stock Bus Speed	100 MHz
			Average Temperature	38 °C
				Caches
					L1 Data Cache Size	4 x 32 KBytes
					L1 Instructions Cache Size	4 x 32 KBytes
					L2 Unified Cache Size	4 x 256 KBytes
					L3 Unified Cache Size	10240 KBytes
				Cores
						Core 0
							Core Speed	4552.8 MHz
							Multiplier	x 46.0
							Bus Speed	99.0 MHz
							Rated Bus Speed	3167.2 MHz
							Temperature	35 °C
							Threads	APIC ID: 0 1
						Core 1
							Core Speed	4651.8 MHz
							Multiplier	x 47.0
							Bus Speed	99.0 MHz
							Rated Bus Speed	3167.2 MHz
							Temperature	36 °C
							Threads	APIC ID: 2 3
						Core 2
							Core Speed	4552.8 MHz
							Multiplier	x 46.0
							Bus Speed	99.0 MHz
							Rated Bus Speed	3167.2 MHz
							Temperature	42 °C
							Threads	APIC ID: 4 5
						Core 3
							Core Speed	4552.8 MHz
							Multiplier	x 46.0
							Bus Speed	99.0 MHz
							Rated Bus Speed	3167.2 MHz
							Temperature	38 °C
							Threads	APIC ID: 6 7
RAM
		Memory slots
			Total memory slots	8
			Used memory slots	6
			Free memory slots	2
		Memory
			Type	DDR3
			Size	49152 MBytes
			DRAM Frequency	791.8 MHz
			CAS# Latency (CL)	9 clocks
			RAS# to CAS# Delay (tRCD)	9 clocks
			RAS# Precharge (tRP)	9 clocks
			Cycle Time (tRAS)	27 clocks
			Command Rate (CR)	2T
		Physical Memory
			Memory Usage	64 %
			Total Physical	48 GB
			Available Physical	17 GB
			Total Virtual	96 GB
			Available Virtual	64 GB
		SPD
			Number Of SPD Modules	6
				Slot #1
					Type	DDR3
					Size	8192 MBytes
					Manufacturer	Kingston
					Max Bandwidth	PC3-10700 (667 MHz)
					Part Number	KHX2133C11D3/8GX
					Week/year	42 / 13
					SPD Ext.	XMP
						Timing table
								JEDEC #1
									Frequency	457.1 MHz
									CAS# Latency	6.0
									RAS# To CAS#	6
									RAS# Precharge	6
									tRAS	17
									tRC	23
									Voltage	1.500 V
								JEDEC #2
									Frequency	533.3 MHz
									CAS# Latency	7.0
									RAS# To CAS#	7
									RAS# Precharge	7
									tRAS	20
									tRC	27
									Voltage	1.500 V
								JEDEC #3
									Frequency	609.5 MHz
									CAS# Latency	8.0
									RAS# To CAS#	8
									RAS# Precharge	8
									tRAS	22
									tRC	30
									Voltage	1.500 V
								JEDEC #4
									Frequency	666.7 MHz
									CAS# Latency	9.0
									RAS# To CAS#	9
									RAS# Precharge	9
									tRAS	24
									tRC	33
									Voltage	1.500 V
								XMP-2132
									Frequency	1066 MHz
									CAS# Latency	11.0
									RAS# To CAS#	12
									RAS# Precharge	11
									tRAS	30
									Voltage	1.600 V
				Slot #2
					Type	DDR3
					Size	8192 MBytes
					Manufacturer	Kingston
					Max Bandwidth	PC3-10700 (667 MHz)
					Part Number	KHX2133C11D3/8GX
					Week/year	42 / 13
					SPD Ext.	XMP
						Timing table
								JEDEC #1
									Frequency	457.1 MHz
									CAS# Latency	6.0
									RAS# To CAS#	6
									RAS# Precharge	6
									tRAS	17
									tRC	23
									Voltage	1.500 V
								JEDEC #2
									Frequency	533.3 MHz
									CAS# Latency	7.0
									RAS# To CAS#	7
									RAS# Precharge	7
									tRAS	20
									tRC	27
									Voltage	1.500 V
								JEDEC #3
									Frequency	609.5 MHz
									CAS# Latency	8.0
									RAS# To CAS#	8
									RAS# Precharge	8
									tRAS	22
									tRC	30
									Voltage	1.500 V
								JEDEC #4
									Frequency	666.7 MHz
									CAS# Latency	9.0
									RAS# To CAS#	9
									RAS# Precharge	9
									tRAS	24
									tRC	33
									Voltage	1.500 V
								XMP-2132
									Frequency	1066 MHz
									CAS# Latency	11.0
									RAS# To CAS#	12
									RAS# Precharge	11
									tRAS	30
									Voltage	1.600 V
				Slot #3
					Type	DDR3
					Size	8192 MBytes
					Manufacturer	Kingston
					Max Bandwidth	PC3-10700 (667 MHz)
					Part Number	KHX2133C11D3/8GX
					Week/year	42 / 13
					SPD Ext.	XMP
						Timing table
								JEDEC #1
									Frequency	457.1 MHz
									CAS# Latency	6.0
									RAS# To CAS#	6
									RAS# Precharge	6
									tRAS	17
									tRC	23
									Voltage	1.500 V
								JEDEC #2
									Frequency	533.3 MHz
									CAS# Latency	7.0
									RAS# To CAS#	7
									RAS# Precharge	7
									tRAS	20
									tRC	27
									Voltage	1.500 V
								JEDEC #3
									Frequency	609.5 MHz
									CAS# Latency	8.0
									RAS# To CAS#	8
									RAS# Precharge	8
									tRAS	22
									tRC	30
									Voltage	1.500 V
								JEDEC #4
									Frequency	666.7 MHz
									CAS# Latency	9.0
									RAS# To CAS#	9
									RAS# Precharge	9
									tRAS	24
									tRC	33
									Voltage	1.500 V
								XMP-2132
									Frequency	1066 MHz
									CAS# Latency	11.0
									RAS# To CAS#	12
									RAS# Precharge	11
									tRAS	30
									Voltage	1.600 V
				Slot #4
					Type	DDR3
					Size	8192 MBytes
					Manufacturer	Kingston
					Max Bandwidth	PC3-10700 (667 MHz)
					Part Number	KHX2133C11D3/8GX
					Week/year	42 / 13
					SPD Ext.	XMP
						Timing table
								JEDEC #1
									Frequency	457.1 MHz
									CAS# Latency	6.0
									RAS# To CAS#	6
									RAS# Precharge	6
									tRAS	17
									tRC	23
									Voltage	1.500 V
								JEDEC #2
									Frequency	533.3 MHz
									CAS# Latency	7.0
									RAS# To CAS#	7
									RAS# Precharge	7
									tRAS	20
									tRC	27
									Voltage	1.500 V
								JEDEC #3
									Frequency	609.5 MHz
									CAS# Latency	8.0
									RAS# To CAS#	8
									RAS# Precharge	8
									tRAS	22
									tRC	30
									Voltage	1.500 V
								JEDEC #4
									Frequency	666.7 MHz
									CAS# Latency	9.0
									RAS# To CAS#	9
									RAS# Precharge	9
									tRAS	24
									tRC	33
									Voltage	1.500 V
								XMP-2132
									Frequency	1066 MHz
									CAS# Latency	11.0
									RAS# To CAS#	12
									RAS# Precharge	11
									tRAS	30
									Voltage	1.600 V
				Slot #5
					Type	DDR3
					Size	8192 MBytes
					Manufacturer	Kingston
					Max Bandwidth	PC3-10700 (667 MHz)
					Part Number	KHX2133C11D3/8GX
					Week/year	42 / 13
					SPD Ext.	XMP
						Timing table
								JEDEC #1
									Frequency	457.1 MHz
									CAS# Latency	6.0
									RAS# To CAS#	6
									RAS# Precharge	6
									tRAS	17
									tRC	23
									Voltage	1.500 V
								JEDEC #2
									Frequency	533.3 MHz
									CAS# Latency	7.0
									RAS# To CAS#	7
									RAS# Precharge	7
									tRAS	20
									tRC	27
									Voltage	1.500 V
								JEDEC #3
									Frequency	609.5 MHz
									CAS# Latency	8.0
									RAS# To CAS#	8
									RAS# Precharge	8
									tRAS	22
									tRC	30
									Voltage	1.500 V
								JEDEC #4
									Frequency	666.7 MHz
									CAS# Latency	9.0
									RAS# To CAS#	9
									RAS# Precharge	9
									tRAS	24
									tRC	33
									Voltage	1.500 V
								XMP-2132
									Frequency	1066 MHz
									CAS# Latency	11.0
									RAS# To CAS#	12
									RAS# Precharge	11
									tRAS	30
									Voltage	1.600 V
				Slot #6
					Type	DDR3
					Size	8192 MBytes
					Manufacturer	Kingston
					Max Bandwidth	PC3-10700 (667 MHz)
					Part Number	KHX2133C11D3/8GX
					Week/year	42 / 13
					SPD Ext.	XMP
						Timing table
								JEDEC #1
									Frequency	457.1 MHz
									CAS# Latency	6.0
									RAS# To CAS#	6
									RAS# Precharge	6
									tRAS	17
									tRC	23
									Voltage	1.500 V
								JEDEC #2
									Frequency	533.3 MHz
									CAS# Latency	7.0
									RAS# To CAS#	7
									RAS# Precharge	7
									tRAS	20
									tRC	27
									Voltage	1.500 V
								JEDEC #3
									Frequency	609.5 MHz
									CAS# Latency	8.0
									RAS# To CAS#	8
									RAS# Precharge	8
									tRAS	22
									tRC	30
									Voltage	1.500 V
								JEDEC #4
									Frequency	666.7 MHz
									CAS# Latency	9.0
									RAS# To CAS#	9
									RAS# Precharge	9
									tRAS	24
									tRC	33
									Voltage	1.500 V
								XMP-2132
									Frequency	1066 MHz
									CAS# Latency	11.0
									RAS# To CAS#	12
									RAS# Precharge	11
									tRAS	30
									Voltage	1.600 V
```

Please let me know if you require any further information around this issue or my environment and I will be happy to get it for you.

Thank you for any assistance you can provide towards solving this issue!

</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>Petermarcu</Assignee>
    <CreatedAt>9/05/2018 3:26:12 PM +00:00</CreatedAt>
    <ClosedAt>22/10/2018 8:52:00 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17931</IssueLabelID>
    <Title>Using Alpine docker image from system w/ SELinux execheap enforcement triggers segfault</Title>
    <Description>@petejohanson commented on [Sun May 06 2018](https://github.com/dotnet/core/issues/1503)

# Alpine docker image segfault when run from a host system w/ SELinux execheap enforcement

From my Fedora laptop attempting to use the `microsoft/dotnet:2.1-sdk-alpine` docker image as soon as the 'dotnet' tool is invoked it immediately segfaults within the container and the "SELinux Alert Browser" notes that the dotnet process attempted execheap access which triggered a denial.

The same is true if I attempt to use a non-alpine docker image for my build and use the alpine runtime docker image.

# General

Host OS: Fedora 28
Docker image: microsoft/dotnet:2.1-sdk-alpine (70f0d46441ae)

Build output:

```
[peter@respect:~/git/fore-scorer/api] λ docker build .
Sending build context to Docker daemon  32.96MB
Step 1/22 : FROM node:8.9-alpine as COUCHDB_COMPILE
 ---&gt; 144aaf4b1367
Step 2/22 : WORKDIR /opt/couchdb-compile
 ---&gt; Using cache
 ---&gt; a73eb9708461
Step 3/22 : COPY ./package.json ./package-lock.json ./
 ---&gt; Using cache
 ---&gt; bbe9529d56c7
Step 4/22 : RUN npm install
 ---&gt; Using cache
 ---&gt; 8fe6cdf59401
Step 5/22 : COPY ./api/couchdb ./api/couchdb
 ---&gt; Using cache
 ---&gt; 92a45a0c55db
Step 6/22 : RUN npm run couchdb-compile
 ---&gt; Using cache
 ---&gt; 101eb5d568bd
Step 7/22 : FROM microsoft/dotnet:2.1-sdk-alpine AS BUILD_IMAGE
 ---&gt; 70f0d46441ae
Step 8/22 : ENV APP_HOME=/opt/fore-scorer
 ---&gt; Using cache
 ---&gt; beb01f7d9dd6
Step 9/22 : WORKDIR $APP_HOME
 ---&gt; Using cache
 ---&gt; 9e39bca48f48
Step 10/22 : COPY ./api/api.fsproj .
 ---&gt; e4da0674d419
Step 11/22 : RUN dotnet restore
 ---&gt; Running in 15e922a4bcfd
Segmentation fault (core dumped)
The command '/bin/sh -c dotnet restore' returned a non-zero code: 139
```

---

@Petermarcu commented on [Mon May 07 2018](https://github.com/dotnet/core/issues/1503#issuecomment-387288664)

@MichaelSimons is this something you can try to get a repro for?

---

@MichaelSimons commented on [Tue May 08 2018](https://github.com/dotnet/core/issues/1503#issuecomment-387431175)

@Petermarcu I have no bandwidth w/Docker releases this week.  Will try to find time next week.

---

@Petermarcu commented on [Tue May 08 2018](https://github.com/dotnet/core/issues/1503#issuecomment-387436063)

Ok we need to figure out if it's something that has to get fixed in 2.1 RTM. I'll see if I can get someone else to figure out what is causing the failure.

---

@joperezr commented on [Tue May 08 2018](https://github.com/dotnet/core/issues/1503#issuecomment-387540223)

I'm not able to reproduce this when the host is a different Unix OS (tried Mac OS and Ubuntu) but I was able to repro when using Fedora 28 as the host as described in the issue. I'm taking an initial look now.

---

@joperezr commented on [Tue May 08 2018](https://github.com/dotnet/core/issues/1503#issuecomment-387555071)

I know this is not ideal but with the help of @wfurt  did verify that by disabling SELINUX on the host now the docker container works correclty. To do this on the host machine you can change the `/etc/selinux/config` to contain the line like: `SELINUX=disabled` and then rebooting the machine. After doing that and spinning up a new container dotnet seems to work correctly.

---

@joperezr commented on [Tue May 08 2018](https://github.com/dotnet/core/issues/1503#issuecomment-387562597)

One more targetted workaround (so you don't have to disable the whole SELinux) is to run these two commands on the host machine before launching the container:
```sh
ausearch -c 'dotnet' --raw | audit2allow -M my-dotnet
semodule -X 300 -i my-dotnet.pp
```

---

@joperezr commented on [Tue May 08 2018](https://github.com/dotnet/core/issues/1503#issuecomment-387568332)

This is the dump we got from the process when the segmentation fault happens:
```
Thread 8 "dotnet" received signal SIGSEGV Segmentation fault.
[Switching to LWP 148]
0x00007ffff7d95d87 in free (p=&lt;optimized out&gt;) at src/malloc/malloc.c:515
515    src/malloc/malloc.c: No such file or directory.
(gdb) bt
#0  0x00007ffff7d95d87 in free (p=&lt;optimized out&gt;) at src/malloc/malloc.c:515
#1  0x00007ffff6d3fc36 in FreeSignalAlternateStack() ()
   from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.0-rc1/libcoreclr.so
#2  0x00007ffff7dc484b in __pthread_tsd_run_dtors () at src/thread/pthread_key_create.c:48
#3  0x00007ffff7dc3e09 in __pthread_exit (result=&lt;optimized out&gt;) at src/thread/pthread_create.c:38
#4  0x00007ffff6d79d95 in ExitThread () from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.0-rc1/libcoreclr.so
#5  0x00007ffff6d79d09 in CorUnix::CPalThread::ThreadEntry(void*) ()
   from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.0-rc1/libcoreclr.so
#6  0x00007ffff7dc3ff8 in start (p=0x7ffff268bae0) at src/thread/pthread_create.c:150
#7  0x00007ffff7dc5f00 in __clone () at src/thread/x86_64/clone.s:21
Backtrace stopped: frame did not save the PC
```

---

@janvorli commented on [Wed May 09 2018](https://github.com/dotnet/core/issues/1503#issuecomment-387740675)

I've debugged the issue. The issue is that the FreeSignalAlternateStack fails to reset the guard page on the alternate stack that we create for handling hardware exceptions. 
We change the protection of the first page in the allocated area to `PROT_NONE` when we allocate the alternate stack in `EnsureSignalAlternateStack`. This makes the page serve as a guard page for stack overflow detection.
When we are freeing the alternate stack we need to reset the protection back. And that `mprotect` call fails. Since such a failure is not expected to happen we only have debug assert to check for it. So in release build the failure goes unnoticed and we call "free" to free the alternate stack memory. But since the first page is still inaccessible the `free` function crashes when trying to access it.
I am still looking into why the `mprotect` fails to restore the protection of the page. It fails with `EPERM` which means "permission denied". We are trying to change the page protection from `PROT_NONE` to `PROT_READ | PROT_WRITE` so that should just work.

---

@janvorli commented on [Wed May 09 2018](https://github.com/dotnet/core/issues/1503#issuecomment-387766924)

So my assumption is that kernel adds PROT_EXEC as a result of VM_MAYEXEC being set for mprotect in the memory allocated from the heap. I've noticed that when running in the alpine docker container on the SELinux enabled Fedora 28 the heap has all three RWX flags set. 

I've tried to fix it by allocating the alternate stack using mmap instead of getting it from the heap and it worked fine. I am going to create a PR for this fix.


---

@Petermarcu commented on [Wed May 09 2018](https://github.com/dotnet/core/issues/1503#issuecomment-387770480)

Is this Alpine specific or SE Linux? Is this a regression from 2.0?

</Description>
    <Title_Description>Using Alpine docker image from system w/ SELinux execheap enforcement triggers segfault @petejohanson commented on [Sun May 06 2018](https://github.com/dotnet/core/issues/1503)

# Alpine docker image segfault when run from a host system w/ SELinux execheap enforcement

From my Fedora laptop attempting to use the `microsoft/dotnet:2.1-sdk-alpine` docker image as soon as the 'dotnet' tool is invoked it immediately segfaults within the container and the "SELinux Alert Browser" notes that the dotnet process attempted execheap access which triggered a denial.

The same is true if I attempt to use a non-alpine docker image for my build and use the alpine runtime docker image.

# General

Host OS: Fedora 28
Docker image: microsoft/dotnet:2.1-sdk-alpine (70f0d46441ae)

Build output:

```
[peter@respect:~/git/fore-scorer/api] λ docker build .
Sending build context to Docker daemon  32.96MB
Step 1/22 : FROM node:8.9-alpine as COUCHDB_COMPILE
 ---&gt; 144aaf4b1367
Step 2/22 : WORKDIR /opt/couchdb-compile
 ---&gt; Using cache
 ---&gt; a73eb9708461
Step 3/22 : COPY ./package.json ./package-lock.json ./
 ---&gt; Using cache
 ---&gt; bbe9529d56c7
Step 4/22 : RUN npm install
 ---&gt; Using cache
 ---&gt; 8fe6cdf59401
Step 5/22 : COPY ./api/couchdb ./api/couchdb
 ---&gt; Using cache
 ---&gt; 92a45a0c55db
Step 6/22 : RUN npm run couchdb-compile
 ---&gt; Using cache
 ---&gt; 101eb5d568bd
Step 7/22 : FROM microsoft/dotnet:2.1-sdk-alpine AS BUILD_IMAGE
 ---&gt; 70f0d46441ae
Step 8/22 : ENV APP_HOME=/opt/fore-scorer
 ---&gt; Using cache
 ---&gt; beb01f7d9dd6
Step 9/22 : WORKDIR $APP_HOME
 ---&gt; Using cache
 ---&gt; 9e39bca48f48
Step 10/22 : COPY ./api/api.fsproj .
 ---&gt; e4da0674d419
Step 11/22 : RUN dotnet restore
 ---&gt; Running in 15e922a4bcfd
Segmentation fault (core dumped)
The command '/bin/sh -c dotnet restore' returned a non-zero code: 139
```

---

@Petermarcu commented on [Mon May 07 2018](https://github.com/dotnet/core/issues/1503#issuecomment-387288664)

@MichaelSimons is this something you can try to get a repro for?

---

@MichaelSimons commented on [Tue May 08 2018](https://github.com/dotnet/core/issues/1503#issuecomment-387431175)

@Petermarcu I have no bandwidth w/Docker releases this week.  Will try to find time next week.

---

@Petermarcu commented on [Tue May 08 2018](https://github.com/dotnet/core/issues/1503#issuecomment-387436063)

Ok we need to figure out if it's something that has to get fixed in 2.1 RTM. I'll see if I can get someone else to figure out what is causing the failure.

---

@joperezr commented on [Tue May 08 2018](https://github.com/dotnet/core/issues/1503#issuecomment-387540223)

I'm not able to reproduce this when the host is a different Unix OS (tried Mac OS and Ubuntu) but I was able to repro when using Fedora 28 as the host as described in the issue. I'm taking an initial look now.

---

@joperezr commented on [Tue May 08 2018](https://github.com/dotnet/core/issues/1503#issuecomment-387555071)

I know this is not ideal but with the help of @wfurt  did verify that by disabling SELINUX on the host now the docker container works correclty. To do this on the host machine you can change the `/etc/selinux/config` to contain the line like: `SELINUX=disabled` and then rebooting the machine. After doing that and spinning up a new container dotnet seems to work correctly.

---

@joperezr commented on [Tue May 08 2018](https://github.com/dotnet/core/issues/1503#issuecomment-387562597)

One more targetted workaround (so you don't have to disable the whole SELinux) is to run these two commands on the host machine before launching the container:
```sh
ausearch -c 'dotnet' --raw | audit2allow -M my-dotnet
semodule -X 300 -i my-dotnet.pp
```

---

@joperezr commented on [Tue May 08 2018](https://github.com/dotnet/core/issues/1503#issuecomment-387568332)

This is the dump we got from the process when the segmentation fault happens:
```
Thread 8 "dotnet" received signal SIGSEGV Segmentation fault.
[Switching to LWP 148]
0x00007ffff7d95d87 in free (p=&lt;optimized out&gt;) at src/malloc/malloc.c:515
515    src/malloc/malloc.c: No such file or directory.
(gdb) bt
#0  0x00007ffff7d95d87 in free (p=&lt;optimized out&gt;) at src/malloc/malloc.c:515
#1  0x00007ffff6d3fc36 in FreeSignalAlternateStack() ()
   from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.0-rc1/libcoreclr.so
#2  0x00007ffff7dc484b in __pthread_tsd_run_dtors () at src/thread/pthread_key_create.c:48
#3  0x00007ffff7dc3e09 in __pthread_exit (result=&lt;optimized out&gt;) at src/thread/pthread_create.c:38
#4  0x00007ffff6d79d95 in ExitThread () from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.0-rc1/libcoreclr.so
#5  0x00007ffff6d79d09 in CorUnix::CPalThread::ThreadEntry(void*) ()
   from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.1.0-rc1/libcoreclr.so
#6  0x00007ffff7dc3ff8 in start (p=0x7ffff268bae0) at src/thread/pthread_create.c:150
#7  0x00007ffff7dc5f00 in __clone () at src/thread/x86_64/clone.s:21
Backtrace stopped: frame did not save the PC
```

---

@janvorli commented on [Wed May 09 2018](https://github.com/dotnet/core/issues/1503#issuecomment-387740675)

I've debugged the issue. The issue is that the FreeSignalAlternateStack fails to reset the guard page on the alternate stack that we create for handling hardware exceptions. 
We change the protection of the first page in the allocated area to `PROT_NONE` when we allocate the alternate stack in `EnsureSignalAlternateStack`. This makes the page serve as a guard page for stack overflow detection.
When we are freeing the alternate stack we need to reset the protection back. And that `mprotect` call fails. Since such a failure is not expected to happen we only have debug assert to check for it. So in release build the failure goes unnoticed and we call "free" to free the alternate stack memory. But since the first page is still inaccessible the `free` function crashes when trying to access it.
I am still looking into why the `mprotect` fails to restore the protection of the page. It fails with `EPERM` which means "permission denied". We are trying to change the page protection from `PROT_NONE` to `PROT_READ | PROT_WRITE` so that should just work.

---

@janvorli commented on [Wed May 09 2018](https://github.com/dotnet/core/issues/1503#issuecomment-387766924)

So my assumption is that kernel adds PROT_EXEC as a result of VM_MAYEXEC being set for mprotect in the memory allocated from the heap. I've noticed that when running in the alpine docker container on the SELinux enabled Fedora 28 the heap has all three RWX flags set. 

I've tried to fix it by allocating the alternate stack using mmap instead of getting it from the heap and it worked fine. I am going to create a PR for this fix.


---

@Petermarcu commented on [Wed May 09 2018](https://github.com/dotnet/core/issues/1503#issuecomment-387770480)

Is this Alpine specific or SE Linux? Is this a regression from 2.0?

</Title_Description>
    <Label>area-PAL</Label>
    <Assignee>janvorli</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17929</IssueLabelID>
    <Title>Unexpected coredumps</Title>
    <Description>I notice my system was creating coredumps for .NET Core processes.

Repro:
```C#
using System;

namespace console
{
    class Program
    {
        static void Main(string[] args)
        {
            throw new Exception();
        }
    }
}
```
Running this will cause a coredump (`abort` called).
```
Stack trace of thread 5943:
#0  0x00007fd3108cb660 raise (libc.so.6)
#1  0x00007fd3108ccc41 abort (libc.so.6)
#2  0x00007fd30fe1101c PROCAbort (libcoreclr.so)
#3  0x00007fd30fe0fe2b _ZL14PROCEndProcessPvji (libcoreclr.so)
#4  0x00007fd30fb5c3d8 _Z27UnwindManagedExceptionPass1R16PAL_SEHExceptionP8_CONTEXT (libcoreclr.so)
#5  0x00007fd30fb5c563 _Z24DispatchManagedExceptionR16PAL_SEHExceptionb (libcoreclr.so)
#6  0x00007fd30facc135 _Z8IL_ThrowP6Object (libcoreclr.so)
#7  0x00007fd2969304ce n/a (n/a)
#8  0x00007fd30fb68ff3 CallDescrWorkerInternal (libcoreclr.so)
#9  0x00007fd30fa7817c _ZN18MethodDescCallSite16CallTargetWorkerEPKmPmi (libcoreclr.so)
#10 0x00007fd30fb8b714 _Z7RunMainP10MethodDescsPiPP8PtrArray (libcoreclr.so)
#11 0x00007fd30fb8b9a1 _ZN8Assembly17ExecuteMainMethodEPP8PtrArrayi (libcoreclr.so)
#12 0x00007fd30f9b4922 _ZN8CorHost215ExecuteAssemblyEjPKDsiPS1_Pj (libcoreclr.so)
#13 0x00007fd30f98d6e2 coreclr_execute_assembly (libcoreclr.so)
#14 0x00007fd31039d706 _ZN7coreclr16execute_assemblyEPvjiPPKcS2_Pj (libhostpolicy.so)
#15 0x00007fd310392fb5 _Z3runRK11arguments_t (libhostpolicy.so)
#16 0x00007fd310393656 corehost_main (libhostpolicy.so)
#17 0x00007fd310661d8f _Z11execute_appRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEP15corehost_init_tiPPKc (libhostfxr.so)
#18 0x00007fd31066bd16 _ZN10fx_muxer_t23read_config_and_executeERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES7_RKSt13unordered_mapIS5_St6vectorIS5_SaIS5_EESt4hashIS5_ESt8equal_toIS5_ESaISt4pairIS6_SB_EEEiPPKc11host_mode_t (libhostfxr.so)
#19 0x00007fd31066ad1d _ZN10fx_muxer_t22parse_args_and_executeERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES7_iiPPKcb11host_mode_tPb (libhostfxr.so)
#20 0x00007fd31066c3a0 _ZN10fx_muxer_t7executeEiPPKc (libhostfxr.so)
#21 0x00007fd310661e15 hostfxr_main (libhostfxr.so)
#22 0x000000000040fd38 _Z3runiPPKc (dotnet)
#23 0x000000000040fec5 main (dotnet)
#24 0x00007fd3108b7f2a __libc_start_main (libc.so.6)
#25 0x000000000040db8a _start (dotnet)
```
I didn't expect this program to generate a coredump.</Description>
    <Title_Description>Unexpected coredumps I notice my system was creating coredumps for .NET Core processes.

Repro:
```C#
using System;

namespace console
{
    class Program
    {
        static void Main(string[] args)
        {
            throw new Exception();
        }
    }
}
```
Running this will cause a coredump (`abort` called).
```
Stack trace of thread 5943:
#0  0x00007fd3108cb660 raise (libc.so.6)
#1  0x00007fd3108ccc41 abort (libc.so.6)
#2  0x00007fd30fe1101c PROCAbort (libcoreclr.so)
#3  0x00007fd30fe0fe2b _ZL14PROCEndProcessPvji (libcoreclr.so)
#4  0x00007fd30fb5c3d8 _Z27UnwindManagedExceptionPass1R16PAL_SEHExceptionP8_CONTEXT (libcoreclr.so)
#5  0x00007fd30fb5c563 _Z24DispatchManagedExceptionR16PAL_SEHExceptionb (libcoreclr.so)
#6  0x00007fd30facc135 _Z8IL_ThrowP6Object (libcoreclr.so)
#7  0x00007fd2969304ce n/a (n/a)
#8  0x00007fd30fb68ff3 CallDescrWorkerInternal (libcoreclr.so)
#9  0x00007fd30fa7817c _ZN18MethodDescCallSite16CallTargetWorkerEPKmPmi (libcoreclr.so)
#10 0x00007fd30fb8b714 _Z7RunMainP10MethodDescsPiPP8PtrArray (libcoreclr.so)
#11 0x00007fd30fb8b9a1 _ZN8Assembly17ExecuteMainMethodEPP8PtrArrayi (libcoreclr.so)
#12 0x00007fd30f9b4922 _ZN8CorHost215ExecuteAssemblyEjPKDsiPS1_Pj (libcoreclr.so)
#13 0x00007fd30f98d6e2 coreclr_execute_assembly (libcoreclr.so)
#14 0x00007fd31039d706 _ZN7coreclr16execute_assemblyEPvjiPPKcS2_Pj (libhostpolicy.so)
#15 0x00007fd310392fb5 _Z3runRK11arguments_t (libhostpolicy.so)
#16 0x00007fd310393656 corehost_main (libhostpolicy.so)
#17 0x00007fd310661d8f _Z11execute_appRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEP15corehost_init_tiPPKc (libhostfxr.so)
#18 0x00007fd31066bd16 _ZN10fx_muxer_t23read_config_and_executeERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES7_RKSt13unordered_mapIS5_St6vectorIS5_SaIS5_EESt4hashIS5_ESt8equal_toIS5_ESaISt4pairIS6_SB_EEEiPPKc11host_mode_t (libhostfxr.so)
#19 0x00007fd31066ad1d _ZN10fx_muxer_t22parse_args_and_executeERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES7_iiPPKcb11host_mode_tPb (libhostfxr.so)
#20 0x00007fd31066c3a0 _ZN10fx_muxer_t7executeEiPPKc (libhostfxr.so)
#21 0x00007fd310661e15 hostfxr_main (libhostfxr.so)
#22 0x000000000040fd38 _Z3runiPPKc (dotnet)
#23 0x000000000040fec5 main (dotnet)
#24 0x00007fd3108b7f2a __libc_start_main (libc.so.6)
#25 0x000000000040db8a _start (dotnet)
```
I didn't expect this program to generate a coredump.</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>mikedn</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17926</IssueLabelID>
    <Title>Rename mscorlib to System.Private.Corelib</Title>
    <Description>cc: @jkotas @safern @danmosemsft 

Fixes: #17905</Description>
    <Title_Description>Rename mscorlib to System.Private.Corelib cc: @jkotas @safern @danmosemsft 

Fixes: #17905</Title_Description>
    <Label>area-Meta-corelib</Label>
    <Assignee>maryamariyan</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17924</IssueLabelID>
    <Title>Following build/test instructions doesn't build any tests</Title>
    <Description>I'm trying to build coreclr release/2.1 on Amazon Linux 2017.03 and can't get the tests to build.  (I have the same issue on Ubuntu)
Here are the instructions I'm following:
https://github.com/dotnet/coreclr/blob/release/2.1/Documentation/building/linux-instructions.md
https://github.com/dotnet/coreclr/blob/release/2.1/Documentation/building/unix-test-instructions.md

Here's my script:
```
# build coreclr
mkdir -p ~/build
cd ~/build
git clone https://github.com/dotnet/coreclr.git
cd coreclr
git checkout release/2.1

./build.sh x64 release msbuildonunsupportedplatform
./build-test.sh x64 release msbuildonunsupportedplatform

# build corefx
cd ~/build
git clone https://github.com/dotnet/corefx.git
cd corefx
git checkout release/2.1

./build.sh -release -RuntimeOS=linux

# test coreclr
cd ~/build/coreclr

tests/runtest.sh \
    --testRootDir=/home/user/build/coreclr/bin/tests/Linux.x64.Release \
    --testNativeBinDir=/home/user/build/coreclr/bin/obj/Linux.x64.Release/tests \
    --coreClrBinDir=/home/user/build/coreclr/bin/Product/Linux.x64.Release \
    --mscorlibDir=/home/user/build/coreclr/bin/Product/Linux.x64.Release \
    --coreFxBinDir=/home/user/build/corefx/bin/runtime/netcoreapp-Linux-Release-x64
```

This results in:
```
.
.
.
The tests have been prepared

=======================
     Test Results
=======================
# CoreCLR Bin Dir  : /home/user/build/coreclr/bin/Product/Linux.x64.Release
# Tests Discovered : 0
# Passed           : 0
# Failed           : 0
# Skipped          : 0
=======================
0 minutes and 0 seconds taken to run CoreCLR tests.
```
The main problem is that build-test.sh isn't building the tests.  If I build an individual test:
```
# from https://github.com/dotnet/coreclr/blob/release/2.1/Documentation/building/unix-test-instructions.md
coreclr/Tools/msbuild.sh /maxcpucount coreclr/tests/src/JIT/CodeGenBringUpTests/Array1.csproj /p:__BuildType=Release /p:__BuildOS=Linux
```
Then when I run my runtest.sh command from above the test is run.

How do I get the tests to build?

</Description>
    <Title_Description>Following build/test instructions doesn't build any tests I'm trying to build coreclr release/2.1 on Amazon Linux 2017.03 and can't get the tests to build.  (I have the same issue on Ubuntu)
Here are the instructions I'm following:
https://github.com/dotnet/coreclr/blob/release/2.1/Documentation/building/linux-instructions.md
https://github.com/dotnet/coreclr/blob/release/2.1/Documentation/building/unix-test-instructions.md

Here's my script:
```
# build coreclr
mkdir -p ~/build
cd ~/build
git clone https://github.com/dotnet/coreclr.git
cd coreclr
git checkout release/2.1

./build.sh x64 release msbuildonunsupportedplatform
./build-test.sh x64 release msbuildonunsupportedplatform

# build corefx
cd ~/build
git clone https://github.com/dotnet/corefx.git
cd corefx
git checkout release/2.1

./build.sh -release -RuntimeOS=linux

# test coreclr
cd ~/build/coreclr

tests/runtest.sh \
    --testRootDir=/home/user/build/coreclr/bin/tests/Linux.x64.Release \
    --testNativeBinDir=/home/user/build/coreclr/bin/obj/Linux.x64.Release/tests \
    --coreClrBinDir=/home/user/build/coreclr/bin/Product/Linux.x64.Release \
    --mscorlibDir=/home/user/build/coreclr/bin/Product/Linux.x64.Release \
    --coreFxBinDir=/home/user/build/corefx/bin/runtime/netcoreapp-Linux-Release-x64
```

This results in:
```
.
.
.
The tests have been prepared

=======================
     Test Results
=======================
# CoreCLR Bin Dir  : /home/user/build/coreclr/bin/Product/Linux.x64.Release
# Tests Discovered : 0
# Passed           : 0
# Failed           : 0
# Skipped          : 0
=======================
0 minutes and 0 seconds taken to run CoreCLR tests.
```
The main problem is that build-test.sh isn't building the tests.  If I build an individual test:
```
# from https://github.com/dotnet/coreclr/blob/release/2.1/Documentation/building/unix-test-instructions.md
coreclr/Tools/msbuild.sh /maxcpucount coreclr/tests/src/JIT/CodeGenBringUpTests/Array1.csproj /p:__BuildType=Release /p:__BuildOS=Linux
```
Then when I run my runtest.sh command from above the test is run.

How do I get the tests to build?

</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>jashook</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17922</IssueLabelID>
    <Title>Mirror changes from dotnet/corert</Title>
    <Description>This PR contains mirrored changes from dotnet/corert


**Please REBASE this PR when merging**</Description>
    <Title_Description>Mirror changes from dotnet/corert This PR contains mirrored changes from dotnet/corert


**Please REBASE this PR when merging**</Title_Description>
    <Label>
    </Label>
    <Assignee>jkotas</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17917</IssueLabelID>
    <Title>Reflection: Fix FormatException when querying ParameterInfo.DefaultValue of optional (closed generic) enum parameter</Title>
    <Description>This is similar to #17877 but about enums instead of `DateTime`. This should fix https://github.com/dotnet/corefx/issues/29570.

Given e.g. a generic method with a parameter `T arg = default(T)` where `T` is the generic type parameter if that is instantiated with some enum as the generic type argument then querying the default value of `arg` using `ParameterInfo.[Raw]DefaultValue` will throw a `FormatException`.

(The use of generics means that the C# compiler always records a `null` constant in metadata which isn't usually the case for enums.)

/cc @AtsushiKan</Description>
    <Title_Description>Reflection: Fix FormatException when querying ParameterInfo.DefaultValue of optional (closed generic) enum parameter This is similar to #17877 but about enums instead of `DateTime`. This should fix https://github.com/dotnet/corefx/issues/29570.

Given e.g. a generic method with a parameter `T arg = default(T)` where `T` is the generic type parameter if that is instantiated with some enum as the generic type argument then querying the default value of `arg` using `ParameterInfo.[Raw]DefaultValue` will throw a `FormatException`.

(The use of generics means that the C# compiler always records a `null` constant in metadata which isn't usually the case for enums.)

/cc @AtsushiKan</Title_Description>
    <Label>netfx-port-consider</Label>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17915</IssueLabelID>
    <Title>[WIP] Fix failing System.Reflection.Emit tests</Title>
    <Description>Commit fceac03e82 removed a test from `TypeBuilder.SetConstantValue` that was too strict when called from `ParameterBuilder` but that both `FieldBuilder` and `EnumBuilder` require. Add the same test back but in `FieldBuilder.SetConstant`.</Description>
    <Title_Description>[WIP] Fix failing System.Reflection.Emit tests Commit fceac03e82 removed a test from `TypeBuilder.SetConstantValue` that was too strict when called from `ParameterBuilder` but that both `FieldBuilder` and `EnumBuilder` require. Add the same test back but in `FieldBuilder.SetConstant`.</Title_Description>
    <Label>netfx-port-consider</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>8/05/2018 11:28:35 AM +00:00</CreatedAt>
    <ClosedAt>8/05/2018 2:39:18 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17909</IssueLabelID>
    <Title>Remove ConcurrentStack from System.Private.CoreLib </Title>
    <Description>This issue is opened to track removing ConcurrentStack from System.Private.CoreLib 

Referring to [comment](https://github.com/dotnet/coreclr/pull/17800#issuecomment-385092192) _From @stephentoub on Apr 27 2018 1:57 PM PDT_:

&gt; ConcurrentStack is to my knowledge used in only one place in corelib by PinnableBufferCache which is in turn only used by Overlapped as a way to cache OverlappedData instances and I think we could come up with something better than ConcurrentStack for this use case in particular since every Push ends up allocating a Node in ConcurrentStack.

Related to issue: https://github.com/dotnet/coreclr/issues/17751

cc: @stephentoub @danmosemsft @jkotas </Description>
    <Title_Description>Remove ConcurrentStack from System.Private.CoreLib  This issue is opened to track removing ConcurrentStack from System.Private.CoreLib 

Referring to [comment](https://github.com/dotnet/coreclr/pull/17800#issuecomment-385092192) _From @stephentoub on Apr 27 2018 1:57 PM PDT_:

&gt; ConcurrentStack is to my knowledge used in only one place in corelib by PinnableBufferCache which is in turn only used by Overlapped as a way to cache OverlappedData instances and I think we could come up with something better than ConcurrentStack for this use case in particular since every Push ends up allocating a Node in ConcurrentStack.

Related to issue: https://github.com/dotnet/coreclr/issues/17751

cc: @stephentoub @danmosemsft @jkotas </Title_Description>
    <Label>area-System.Collections</Label>
    <Assignee>stephentoub</Assignee>
    <CreatedAt>7/05/2018 5:04:42 PM +00:00</CreatedAt>
    <ClosedAt>9/06/2018 8:40:00 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17842</IssueLabelID>
    <Title>Add better portable PDB caching to System.Diagnostics.StackTrace</Title>
    <Description>Issue #17701

Add portable PDB caching to StackTrace.

This is the mscorlib/System.Private.Corelib side of the change.</Description>
    <Title_Description>Add better portable PDB caching to System.Diagnostics.StackTrace Issue #17701

Add portable PDB caching to StackTrace.

This is the mscorlib/System.Private.Corelib side of the change.</Title_Description>
    <Label>
    </Label>
    <Assignee>mikem8361</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17841</IssueLabelID>
    <Title>[Arm64] GitHub_17777  - Assertion failed 'emitCurIG != emitPrologIG' in </Title>
    <Description>JIT/Regression/JitBlue/GitHub_17777/GitHub_17777/GitHub_17777.sh

```
corerun GitHub_17777.exe

Assert failure(PID 15635 [0x00003d13] Thread: 15635 [0x3d13]): 
Assertion failed 'emitCurIG != emitPrologIG' in 
'Repro.Program:Test(intintintintintintintintintintintintintintintintint \
    intintintintintintintintintintintintintintintintintintintintint \
    intintintintintintintintintintintintintintintintintintintintint \
    intintintintintintintintintintintintintintintintintintintintint \
    intintintintintintintintintintintintintintintintintintintintint \
    intintintintintintintintintintintintintintintintintintintintint \
    intintintintintintintintintintintintintintintintintintintintint \
    intintintintintintintintintintintintintintintintintintintintint \
    intintintintintintintintintintintintintintintintintintintintint \
    intintintintintintintintintintintintintintint):int' (IL size 2418)

    File: ./src/jit/emit.cpp Line: 6689
```</Description>
    <Title_Description>[Arm64] GitHub_17777  - Assertion failed 'emitCurIG != emitPrologIG' in  JIT/Regression/JitBlue/GitHub_17777/GitHub_17777/GitHub_17777.sh

```
corerun GitHub_17777.exe

Assert failure(PID 15635 [0x00003d13] Thread: 15635 [0x3d13]): 
Assertion failed 'emitCurIG != emitPrologIG' in 
'Repro.Program:Test(intintintintintintintintintintintintintintintintint \
    intintintintintintintintintintintintintintintintintintintintint \
    intintintintintintintintintintintintintintintintintintintintint \
    intintintintintintintintintintintintintintintintintintintintint \
    intintintintintintintintintintintintintintintintintintintintint \
    intintintintintintintintintintintintintintintintintintintintint \
    intintintintintintintintintintintintintintintintintintintintint \
    intintintintintintintintintintintintintintintintintintintintint \
    intintintintintintintintintintintintintintintintintintintintint \
    intintintintintintintintintintintintintintint):int' (IL size 2418)

    File: ./src/jit/emit.cpp Line: 6689
```</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>briansull</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17840</IssueLabelID>
    <Title>[master] Add runtimeconfig.json support for tiered compilation</Title>
    <Description>cc @kouvel @4creators </Description>
    <Title_Description>[master] Add runtimeconfig.json support for tiered compilation cc @kouvel @4creators </Title_Description>
    <Label>area-TieredCompilation</Label>
    <Assignee>kouvel</Assignee>
    <CreatedAt>30/04/2018 9:00:41 PM +00:00</CreatedAt>
    <ClosedAt>30/04/2018 10:51:04 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17839</IssueLabelID>
    <Title>Add runtimeconfig.json support for tiered compilation</Title>
    <Description>
    </Description>
    <Title_Description>Add runtimeconfig.json support for tiered compilation </Title_Description>
    <Label>area-TieredCompilation</Label>
    <Assignee>noahfalk</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17838</IssueLabelID>
    <Title>JIT: volatile compares should not be foldable</Title>
    <Description>```C#
using System;

class X
{
    volatile int a;
    
    public static int Main()
    {
        var x = new X();
        x.a = 50;
        x.a = 100;
        if (x.a == x.a) return 100;
        return -1;
    }
}
```
currently generates:
```asm
G_M32182_IG01:
       4883EC28             sub      rsp 40

G_M32182_IG02:
       48B95852BB61F97F0000 mov      rcx 0x7FF961BB5258
       E85DFA7F5F           call     CORINFO_HELP_NEWSFAST
       C7400832000000       mov      dword ptr [rax+8] 50
       C7400864000000       mov      dword ptr [rax+8] 100
       B864000000           mov      eax 100

G_M32182_IG03:
       4883C428             add      rsp 40
       C3                   ret
```
Folding the compare is unsafe in general.

See also the somewhat related #6172.

category:correctness
theme:basic-cq
skill-level:intermediate
cost:small</Description>
    <Title_Description>JIT: volatile compares should not be foldable ```C#
using System;

class X
{
    volatile int a;
    
    public static int Main()
    {
        var x = new X();
        x.a = 50;
        x.a = 100;
        if (x.a == x.a) return 100;
        return -1;
    }
}
```
currently generates:
```asm
G_M32182_IG01:
       4883EC28             sub      rsp 40

G_M32182_IG02:
       48B95852BB61F97F0000 mov      rcx 0x7FF961BB5258
       E85DFA7F5F           call     CORINFO_HELP_NEWSFAST
       C7400832000000       mov      dword ptr [rax+8] 50
       C7400864000000       mov      dword ptr [rax+8] 100
       B864000000           mov      eax 100

G_M32182_IG03:
       4883C428             add      rsp 40
       C3                   ret
```
Folding the compare is unsafe in general.

See also the somewhat related #6172.

category:correctness
theme:basic-cq
skill-level:intermediate
cost:small</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>AndyAyersMS</Assignee>
    <CreatedAt>30/04/2018 8:29:36 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17837</IssueLabelID>
    <Title>GC env vars</Title>
    <Description>Remove CORECLR_SERVER_GC and CORECLR_CONCURRENT_GC and make COMPlus_gcServer and COMPlus_gcConcurrent available on Windows.</Description>
    <Title_Description>GC env vars Remove CORECLR_SERVER_GC and CORECLR_CONCURRENT_GC and make COMPlus_gcServer and COMPlus_gcConcurrent available on Windows.</Title_Description>
    <Label>
    </Label>
    <Assignee>sywhang</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17835</IssueLabelID>
    <Title>[arm/corefx] System.Tests.TypedReferenceTests.NegativeMakeTypedReference fails</Title>
    <Description>[ci run](https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_corefx_baseline_tst/13/consoleText) shows:
```
Discovering: System.Runtime.Tests
Discovered:  System.Runtime.Tests
Starting:    System.Runtime.Tests

Assert failure(PID 1708 [0x000006ac] Thread: 3612 [0x0e1c]): !"You cannot use this function for arbitrary value types. You must preallocate a box object and copy the value in yourself."

&lt;no module&gt;! &lt;no symbol&gt; + 0x0 (0x00000000)
    File: d:\j\workspace\arm_cross_che---99792267\src\vm\invokeutil.cpp Line: 693
    Image: C:\Users\robox\j\workspace\arm_cross_che---eb7b805d\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm\dotnet.exe
```

local runs fail with:
```
Z:\bin\tests\System.Runtime.Tests\netcoreapp-Windows_NT-Release-arm&gt;call Z:\bin\testhost\netcoreapp-Windows_NT-Release-arm\dotnet.exe xunit.console.netcore.exe System.Runtime.Tests.dll -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonwindowstests  -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing -method System.Tests.TypedReferenceTests.NegativeMakeTypedReference
xUnit.net console test runner (32-bit .NET Core)
Copyright (C) 2014 Outercurve Foundation.

Discovering: System.Runtime.Tests
Discovered:  System.Runtime.Tests
Starting:    System.Runtime.Tests
   System.Tests.TypedReferenceTests.NegativeMakeTypedReference [FAIL]
      Assert.Equal() Failure
      Expected: (null)
      Actual:   flds
      Stack Trace:
         F:\git\corefx\src\CoreFx.Private.TestUtilities\src\System\AssertExtensions.cs(480): at System.AssertExtensions.Throws[T](String paramName Action action)
         F:\git\corefx\src\System.Runtime\tests\System\TypedReferenceTests.cs(600): at System.Tests.TypedReferenceTests.NegativeMakeTypedReference()
Finished:    System.Runtime.Tests

=== TEST EXECUTION SUMMARY ===
   System.Runtime.Tests  Total: 1 Errors: 0 Failed: 1 Skipped: 0 Time: 4.239s
```

link  https://github.com/dotnet/coreclr/issues/16001#issuecomment-385319873.

Probably it will fix #17585.</Description>
    <Title_Description>[arm/corefx] System.Tests.TypedReferenceTests.NegativeMakeTypedReference fails [ci run](https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_corefx_baseline_tst/13/consoleText) shows:
```
Discovering: System.Runtime.Tests
Discovered:  System.Runtime.Tests
Starting:    System.Runtime.Tests

Assert failure(PID 1708 [0x000006ac] Thread: 3612 [0x0e1c]): !"You cannot use this function for arbitrary value types. You must preallocate a box object and copy the value in yourself."

&lt;no module&gt;! &lt;no symbol&gt; + 0x0 (0x00000000)
    File: d:\j\workspace\arm_cross_che---99792267\src\vm\invokeutil.cpp Line: 693
    Image: C:\Users\robox\j\workspace\arm_cross_che---eb7b805d\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm\dotnet.exe
```

local runs fail with:
```
Z:\bin\tests\System.Runtime.Tests\netcoreapp-Windows_NT-Release-arm&gt;call Z:\bin\testhost\netcoreapp-Windows_NT-Release-arm\dotnet.exe xunit.console.netcore.exe System.Runtime.Tests.dll -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonwindowstests  -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing -method System.Tests.TypedReferenceTests.NegativeMakeTypedReference
xUnit.net console test runner (32-bit .NET Core)
Copyright (C) 2014 Outercurve Foundation.

Discovering: System.Runtime.Tests
Discovered:  System.Runtime.Tests
Starting:    System.Runtime.Tests
   System.Tests.TypedReferenceTests.NegativeMakeTypedReference [FAIL]
      Assert.Equal() Failure
      Expected: (null)
      Actual:   flds
      Stack Trace:
         F:\git\corefx\src\CoreFx.Private.TestUtilities\src\System\AssertExtensions.cs(480): at System.AssertExtensions.Throws[T](String paramName Action action)
         F:\git\corefx\src\System.Runtime\tests\System\TypedReferenceTests.cs(600): at System.Tests.TypedReferenceTests.NegativeMakeTypedReference()
Finished:    System.Runtime.Tests

=== TEST EXECUTION SUMMARY ===
   System.Runtime.Tests  Total: 1 Errors: 0 Failed: 1 Skipped: 0 Time: 4.239s
```

link  https://github.com/dotnet/coreclr/issues/16001#issuecomment-385319873.

Probably it will fix #17585.</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>sandreenko</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17833</IssueLabelID>
    <Title>PropertyInfo.SetValue on ref-returning members</Title>
    <Description>https://github.com/dotnet/corefx/issues/15960

This invokes the getter and writes the argument
value into the reference. InvalidOpException
if the property is readonly ref.</Description>
    <Title_Description>PropertyInfo.SetValue on ref-returning members https://github.com/dotnet/corefx/issues/15960

This invokes the getter and writes the argument
value into the reference. InvalidOpException
if the property is readonly ref.</Title_Description>
    <Label>area-System.Reflection</Label>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17831</IssueLabelID>
    <Title>Mirror changes from dotnet/corefx</Title>
    <Description>This PR contains mirrored changes from dotnet/corefx


**Please REBASE this PR when merging**</Description>
    <Title_Description>Mirror changes from dotnet/corefx This PR contains mirrored changes from dotnet/corefx


**Please REBASE this PR when merging**</Title_Description>
    <Label>
    </Label>
    <Assignee>jkotas</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17828</IssueLabelID>
    <Title>[JIT]: Stack allocation to Span</Title>
    <Description>I looked at what IL and x86 code is generated for different ways of allocating memory on stack
and think there is room for optimizations. 

1. Roslyn could generate better IL for `Span&lt;byte&gt; span = stackalloc byte[512];` (see `StackAllocFixedAsSpan`). It should be similar to the IL generated for `byte* ptr = stackalloc byte[512];` (`StackAllocFixedAsPtr`). I will create  an issue in Roslyn repo for that.

2. JIT could recognize fixed size stack allocations and  generate simpler code.
    Compare `StackAllocFixedAsPtr` to `LocalAsPtr` and `StackAllocFixedAsSpan` to `LocalAsSpan`.

@VSadov @jkotas 

```C#
[StructLayout(LayoutKind.Sequential Size = 512)]
struct WideStruct { }

[MethodImpl(MethodImplOptions.NoInlining)]
private static unsafe void Consume(byte* ptr) {}

[MethodImpl(MethodImplOptions.NoInlining)]
private static unsafe void Consume(Span&lt;byte&gt; span) {}
```

&lt;details&gt;&lt;summary&gt;LocalAsPtr&lt;/summary&gt;
&lt;p&gt;

```C#
[MethodImpl(MethodImplOptions.NoInlining)]
private static unsafe void LocalAsPtr()
{
    WideStruct i;
    Consume((byte*)&amp;i);
}
```
```
.method private hidebysig static 
	void LocalAsPtr () cil managed noinlining 
{
	// Method begins at RVA 0x20dc
	// Code size 9 (0x9)
	.maxstack 1
	.locals init (
		[0] valuetype TestDotNetCore.Program/WideStruct
	)

	IL_0000: ldloca.s 0
	IL_0002: conv.u
	IL_0003: call void TestDotNetCore.Program::Consume(uint8*)
	IL_0008: ret
}
```
```ASM
; Assembly listing for method Program:LocalAsPtr()
; Emitting BLENDED_CODE for X64 CPU with AVX
; optimized code
; rsp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 loc0         [V00    ] (  1  1   )  struct (512) [rsp+0x20]   do-not-enreg[XS] must-init addr-exposed ld-addr-op
;  V01 OutArgs      [V01    ] (  1  1   )  lclBlk (32) [rsp+0x00]  
;
; Lcl frame size = 544

G_M54392_IG01:
       57                   push     rdi
       4881EC20020000       sub      rsp 544
       488D7C2420           lea      rdi [rsp+20H]
       B980000000           mov      ecx 128
       33C0                 xor      rax rax
       F3AB                 rep stosd 

G_M54392_IG02:
       488D4C2420           lea      rcx bword ptr [rsp+20H]
       E8A0FDFFFF           call     Program:Consume(long)
       90                   nop      

G_M54392_IG03:
       4881C420020000       add      rsp 544
       5F                   pop      rdi
       C3                   ret      

; Total bytes of code 42 prolog size 22 for method Program:LocalAsPtr()
; ============================================================
```
&lt;/p&gt;
&lt;/details&gt;

&lt;details&gt;&lt;summary&gt;LocalAsSpan&lt;/summary&gt;
&lt;p&gt;

```C#
[MethodImpl(MethodImplOptions.NoInlining)]
private static unsafe void LocalAsSpan()
{
    WideStruct i;
    Consume(new Span&lt;byte&gt;((byte*)&amp;i sizeof(WideStruct)));
}
```
```
.method private hidebysig static 
	void LocalAsSpan () cil managed noinlining 
{
	// Code size 20 (0x14)
	.maxstack 2
	.locals init (
		[0] valuetype TestDotNetCore.Program/WideStruct
	)

	IL_0000: ldloca.s 0
	IL_0002: conv.u
	IL_0003: sizeof TestDotNetCore.Program/WideStruct
	IL_0009: newobj instance void valuetype [System.Memory]System.Span`1&lt;uint8&gt;::.ctor(void* int32)
	IL_000e: call void TestDotNetCore.Program::Consume(valuetype [System.Memory]System.Span`1&lt;uint8&gt;)
	IL_0013: ret
}
```
```ASM
; Assembly listing for method Program:LocalAsSpan()
; Emitting BLENDED_CODE for X64 CPU with AVX
; optimized code
; rsp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 loc0         [V00    ] (  1  1   )  struct (512) [rsp+0x30]   do-not-enreg[XS] must-init addr-exposed ld-addr-op
;  V01 OutArgs      [V01    ] (  1  1   )  lclBlk (32) [rsp+0x00]  
;* V02 tmp1         [V02    ] (  0  0   )  struct (16) zero-ref   
;  V03 tmp2         [V03T01] (  2  4   )    long  -&gt;  rcx        
;* V04 tmp3         [V04    ] (  0  0   )  struct ( 8) zero-ref   
;  V05 tmp4         [V05T02] (  2  2   )   byref  -&gt;  rcx         V02._pointer(offs=0x00) P-INDEP
;  V06 tmp5         [V06T04] (  2  2   )     int  -&gt;  rax         V02._length(offs=0x08) P-INDEP
;  V07 tmp6         [V07T03] (  2  2   )   byref  -&gt;  rcx         V04._value(offs=0x00) P-INDEP
;  V08 tmp7         [V08    ] (  3  6   )  struct (16) [rsp+0x20]   do-not-enreg[XSB] must-init addr-exposed
;  V09 tmp8         [V09T00] (  3  6   )   byref  -&gt;  rdx         stack-byref
;
; Lcl frame size = 560

G_M21189_IG01:
       57                   push     rdi
       4881EC30020000       sub      rsp 560
       488D7C2420           lea      rdi [rsp+20H]
       B984000000           mov      ecx 132
       33C0                 xor      rax rax
       F3AB                 rep stosd 

G_M21189_IG02:
       488D4C2430           lea      rcx bword ptr [rsp+30H]
       B800020000           mov      eax 512
       488D542420           lea      rdx bword ptr [rsp+20H]
       48890A               mov      bword ptr [rdx] rcx
       894208               mov      dword ptr [rdx+8] eax
       488D4C2420           lea      rcx bword ptr [rsp+20H]
       E89BFEFFFF           call     Program:Consume(struct)
       90                   nop      

G_M21189_IG03:
       4881C430020000       add      rsp 560
       5F                   pop      rdi
       C3                   ret      

; Total bytes of code 63 prolog size 22 for method Program:LocalAsSpan()
; ============================================================
```
&lt;/p&gt;
&lt;/details&gt;

&lt;details&gt;&lt;summary&gt;StackAllocFixedAsPtr&lt;/summary&gt;
&lt;p&gt;

```C#
[MethodImpl(MethodImplOptions.NoInlining)]
private static unsafe void StackAllocFixedAsPtr()
{
    byte* ptr = stackalloc byte[512];
    Consume(ptr);
}
```
```
.method private hidebysig static 
	void StackAllocFixedAsPtr () cil managed noinlining 
{
	// Code size 14 (0xe)
	.maxstack 8

	IL_0000: ldc.i4 512
	IL_0005: conv.u
	IL_0006: localloc
	IL_0008: call void TestDotNetCore.Program::Consume(uint8*)
	IL_000d: ret
}
```
```ASM
; Assembly listing for method Program:StackAllocFixedAsPtr()
; Emitting BLENDED_CODE for X64 CPU with AVX
; optimized code
; rbp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 OutArgs      [V00    ] (  1  1   )  lclBlk (32) [rsp+0x00]  
;* V01 GsCookie     [V01    ] (  0  0   )    long  -&gt;  zero-ref    do-not-enreg[X] addr-exposed
;  V02 LocAllocSP   [V02    ] (  1  1   )    long  -&gt;  [rbp+0x08]   do-not-enreg[X] addr-exposed
;
; Lcl frame size = 48

G_M56192_IG01:
       55                   push     rbp
       4883EC30             sub      rsp 48
       488D6C2420           lea      rbp [rsp+20H]
       48896508             mov      qword ptr [rbp+08H] rsp
       48B8818FC0ED9AA70000 mov      rax 0xA79AEDC08F81
       48894500             mov      qword ptr [rbp] rax

G_M56192_IG02:
       4883C420             add      rsp 32
       852424               test     dword ptr [rsp] esp
       4881EC00020000       sub      rsp 512
       4883EC20             sub      rsp 32
       488D4C2420           lea      rcx [rsp+20H]
       48896508             mov      qword ptr [rbp+08H] rsp
       E8E4FDFFFF           call     Program:Consume(long)
       48B9818FC0ED9AA70000 mov      rcx 0xA79AEDC08F81
       48394D00             cmp      qword ptr [rbp] rcx
       7405                 je       SHORT G_M56192_IG03
       E8EFEFC35F           call     CORINFO_HELP_FAIL_FAST

G_M56192_IG03:
       90                   nop      

G_M56192_IG04:
       488D6510             lea      rsp [rbp+10H]
       5D                   pop      rbp
       C3                   ret      

; Total bytes of code 88 prolog size 28 for method Program:StackAllocFixedAsPtr()
; ============================================================
```
&lt;/p&gt;
&lt;/details&gt;

&lt;details&gt;&lt;summary&gt;StackAllocDynamicAsPtr&lt;/summary&gt;
&lt;p&gt;

```C#
[MethodImpl(MethodImplOptions.NoInlining)]
private static unsafe void StackAllocDynamicAsPtr(int size)
{
    byte* ptr = stackalloc byte[size];
    Consume(ptr);
} 
```
```
.method private hidebysig static 
	void StackAllocDynamicAsPtr (
		int32 size
	) cil managed noinlining 
{
	// Code size 10 (0xa)
	.maxstack 8

	IL_0000: ldarg.0
	IL_0001: conv.u
	IL_0002: localloc
	IL_0004: call void TestDotNetCore.Program::Consume(uint8*)
	IL_0009: ret
}
```
```ASM
; Assembly listing for method Program:StackAllocDynamicAsPtr(int)
; Emitting BLENDED_CODE for X64 CPU with AVX
; optimized code
; rbp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00T00] (  3  3   )     int  -&gt;  rcx        
;  V01 OutArgs      [V01    ] (  1  1   )  lclBlk (32) [rsp+0x00]  
;* V02 GsCookie     [V02    ] (  0  0   )    long  -&gt;  zero-ref    do-not-enreg[X] addr-exposed
;  V03 LocAllocSP   [V03    ] (  1  1   )    long  -&gt;  [rbp+0x08]   do-not-enreg[X] addr-exposed
;
; Lcl frame size = 48

G_M8739_IG01:
       55                   push     rbp
       4883EC30             sub      rsp 48
       488D6C2420           lea      rbp [rsp+20H]
       48896508             mov      qword ptr [rbp+08H] rsp
       48B8818FC0ED9AA70000 mov      rax 0xA79AEDC08F81
       48894500             mov      qword ptr [rbp] rax

G_M8739_IG02:
       8BC9                 mov      ecx ecx
       4885C9               test     rcx rcx
       743A                 je       SHORT G_M8739_IG04
       488BC1               mov      rax rcx
       4883C00F             add      rax 15
       4883E0F0             and      rax -16
       4883C420             add      rsp 32
       48F7D8               neg      rax
       4803C4               add      rax rsp
       7202                 jb       SHORT G_M8739_IG03
       33C0                 xor      rax rax

G_M8739_IG03:
       852424               test     dword ptr [rsp] esp
       488BD4               mov      rdx rsp
       4881EA00100000       sub      rdx 0x1000
       488BE2               mov      rsp rdx
       483BE0               cmp      rsp rax
       73EB                 jae      SHORT G_M8739_IG03
       488BE0               mov      rsp rax
       4883EC20             sub      rsp 32
       488D4C2420           lea      rcx [rsp+20H]

G_M8739_IG04:
       48896508             mov      qword ptr [rbp+08H] rsp
       E87AFFFFFF           call     Program:Consume(long)
       48B9818FC0ED9AA70000 mov      rcx 0xA79AEDC08F81
       48394D00             cmp      qword ptr [rbp] rcx
       7405                 je       SHORT G_M8739_IG05
       E835EFC35F           call     CORINFO_HELP_FAIL_FAST

G_M8739_IG05:
       90                   nop      

G_M8739_IG06:
       488D6510             lea      rsp [rbp+10H]
       5D                   pop      rbp
       C3                   ret      

; Total bytes of code 130 prolog size 28 for method Program:StackAllocDynamicAsPtr(int)
; ============================================================
```
&lt;/p&gt;
&lt;/details&gt;

&lt;details&gt;&lt;summary&gt;StackAllocFixedAsSpan&lt;/summary&gt;
&lt;p&gt;

```C#
[MethodImpl(MethodImplOptions.NoInlining)]
private static unsafe void StackAllocFixedAsSpan()
{
    Span&lt;byte&gt; span = stackalloc byte[512];
    Consume(span);
}
```
```
.method private hidebysig static 
	void StackAllocFixedAsSpan () cil managed noinlining 
{
	// Code size 22 (0x16)
	.maxstack 2
	.locals init (
		[0] int32
	)

	IL_0000: ldc.i4 512
	IL_0005: stloc.0
	IL_0006: ldloc.0
	IL_0007: conv.u
	IL_0008: localloc
	IL_000a: ldloc.0
	IL_000b: newobj instance void valuetype [System.Memory]System.Span`1&lt;uint8&gt;::.ctor(void* int32)
	IL_0010: call void TestDotNetCore.Program::Consume(valuetype [System.Memory]System.Span`1&lt;uint8&gt;)
	IL_0015: ret
}
```
```ASM
; Assembly listing for method Program:StackAllocFixedAsSpan()
; Emitting BLENDED_CODE for X64 CPU with AVX
; optimized code
; rbp based frame
; partially interruptible
; Final local variable assignments
;
;* V00 loc0         [V00T05] (  0  0   )     int  -&gt;  zero-ref   
;  V01 OutArgs      [V01    ] (  1  1   )  lclBlk (32) [rsp+0x00]  
;* V02 tmp1         [V02    ] (  0  0   )  struct (16) zero-ref   
;  V03 tmp2         [V03T01] (  2  4   )    long  -&gt;  rcx        
;* V04 tmp3         [V04    ] (  0  0   )  struct ( 8) zero-ref   
;  V05 tmp4         [V05T03] (  2  2   )   byref  -&gt;  rcx         V02._pointer(offs=0x00) P-INDEP
;  V06 tmp5         [V06T02] (  3  3   )     int  -&gt;  rax         V02._length(offs=0x08) P-INDEP
;  V07 tmp6         [V07T04] (  2  2   )   byref  -&gt;  rcx         V04._value(offs=0x00) P-INDEP
;  V08 tmp7         [V08    ] (  3  6   )  struct (16) [rbp+0x10]   do-not-enreg[XSB] must-init addr-exposed
;  V09 tmp8         [V09T00] (  3  6   )   byref  -&gt;  rdx         stack-byref
;* V10 GsCookie     [V10    ] (  0  0   )    long  -&gt;  zero-ref    do-not-enreg[X] must-init addr-exposed
;  V11 LocAllocSP   [V11    ] (  1  1   )    long  -&gt;  [rbp+0x20]   do-not-enreg[X] must-init addr-exposed
;
; Lcl frame size = 72

G_M31550_IG01:
       55                   push     rbp
       57                   push     rdi
       4883EC48             sub      rsp 72
       488D6C2420           lea      rbp [rsp+20H]
       488D7D08             lea      rdi [rbp+08H]
       B908000000           mov      ecx 8
       33C0                 xor      rax rax
       F3AB                 rep stosd 
       48896520             mov      qword ptr [rbp+20H] rsp
       48B8818FC0ED9AA70000 mov      rax 0xA79AEDC08F81
       48894508             mov      qword ptr [rbp+08H] rax

G_M31550_IG02:
       4883C420             add      rsp 32
       B920000000           mov      ecx 32

G_M31550_IG03:
       6A00                 push     0
       6A00                 push     0
       48FFC9               dec      rcx
       75F7                 jne      SHORT G_M31550_IG03
       4883EC20             sub      rsp 32
       488D4C2420           lea      rcx [rsp+20H]
       48896520             mov      qword ptr [rbp+20H] rsp
       B800020000           mov      eax 512
       488D5510             lea      rdx bword ptr [rbp+10H]
       48890A               mov      bword ptr [rdx] rcx
       894208               mov      dword ptr [rdx+8] eax
       488D4D10             lea      rcx bword ptr [rbp+10H]
       E897FCFFFF           call     Program:Consume(struct)
       48B9818FC0ED9AA70000 mov      rcx 0xA79AEDC08F81
       48394D08             cmp      qword ptr [rbp+08H] rcx
       7405                 je       SHORT G_M31550_IG04
       E89AEEC35F           call     CORINFO_HELP_FAIL_FAST

G_M31550_IG04:
       90                   nop      

G_M31550_IG05:
       488D6528             lea      rsp [rbp+28H]
       5F                   pop      rdi
       5D                   pop      rbp
       C3                   ret      

; Total bytes of code 126 prolog size 42 for method Program:StackAllocFixedAsSpan()
; ============================================================
```
&lt;/p&gt;
&lt;/details&gt;

&lt;details&gt;&lt;summary&gt;StackAllocDynamicAsSpan&lt;/summary&gt;
&lt;p&gt;

```C#
[MethodImpl(MethodImplOptions.NoInlining)]
private static unsafe void StackAllocDynamicAsSpan(int size)
{
    Span&lt;byte&gt; span = stackalloc byte[size];
    Consume(span);
}
```
```
.method private hidebysig static 
	void StackAllocDynamicAsSpan (
		int32 size
	) cil managed noinlining 
{
	// Code size 18 (0x12)
	.maxstack 2
	.locals init (
		[0] int32
	)

	IL_0000: ldarg.0
	IL_0001: stloc.0
	IL_0002: ldloc.0
	IL_0003: conv.u
	IL_0004: localloc
	IL_0006: ldloc.0
	IL_0007: newobj instance void valuetype [System.Memory]System.Span`1&lt;uint8&gt;::.ctor(void* int32)
	IL_000c: call void TestDotNetCore.Program::Consume(valuetype [System.Memory]System.Span`1&lt;uint8&gt;)
	IL_0011: ret
}
```
```ASM
; Assembly listing for method Program:StackAllocDynamicAsSpan(int)
; Emitting BLENDED_CODE for X64 CPU with AVX
; optimized code
; rbp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00T01] (  3  3   )     int  -&gt;  rcx        
;  V01 loc0         [V01T02] (  4  4   )     int  -&gt;  rcx        
;  V02 OutArgs      [V02    ] (  1  1   )  lclBlk (32) [rsp+0x00]  
;* V03 tmp1         [V03    ] (  0  0   )  struct (16) zero-ref   
;  V04 tmp2         [V04T03] (  2  4   )    long  -&gt;  rax        
;* V05 tmp3         [V05    ] (  0  0   )  struct ( 8) zero-ref   
;  V06 tmp4         [V06T04] (  2  2   )   byref  -&gt;  rax         V03._pointer(offs=0x00) P-INDEP
;  V07 tmp5         [V07T06] (  2  2   )     int  -&gt;  rcx         V03._length(offs=0x08) P-INDEP
;  V08 tmp6         [V08T05] (  2  2   )   byref  -&gt;  rax         V05._value(offs=0x00) P-INDEP
;  V09 tmp7         [V09    ] (  3  6   )  struct (16) [rbp+0x08]   do-not-enreg[XSB] must-init addr-exposed
;  V10 tmp8         [V10T00] (  3  6   )   byref  -&gt;  rdx         stack-byref
;* V11 GsCookie     [V11    ] (  0  0   )    long  -&gt;  zero-ref    do-not-enreg[X] must-init addr-exposed
;  V12 LocAllocSP   [V12    ] (  1  1   )    long  -&gt;  [rbp+0x18]   do-not-enreg[X] must-init addr-exposed
;
; Lcl frame size = 64

G_M16477_IG01:
       55                   push     rbp
       57                   push     rdi
       56                   push     rsi
       4883EC40             sub      rsp 64
       488D6C2420           lea      rbp [rsp+20H]
       488BF1               mov      rsi rcx
       488D7D00             lea      rdi [rbp]
       B908000000           mov      ecx 8
       33C0                 xor      rax rax
       F3AB                 rep stosd 
       488BCE               mov      rcx rsi
       48896518             mov      qword ptr [rbp+18H] rsp
       48B8818FC0ED9AA70000 mov      rax 0xA79AEDC08F81
       48894500             mov      qword ptr [rbp] rax

G_M16477_IG02:
       8BC1                 mov      eax ecx
       4885C0               test     rax rax
       741E                 je       SHORT G_M16477_IG04
       4883C00F             add      rax 15
       48C1E804             shr      rax 4
       4883C420             add      rsp 32

G_M16477_IG03:
       6A00                 push     0
       6A00                 push     0
       48FFC8               dec      rax
       75F7                 jne      SHORT G_M16477_IG03
       4883EC20             sub      rsp 32
       488D442420           lea      rax [rsp+20H]

G_M16477_IG04:
       48896518             mov      qword ptr [rbp+18H] rsp
       85C9                 test     ecx ecx
       7C31                 jl       SHORT G_M16477_IG08

G_M16477_IG05:
       488D5508             lea      rdx bword ptr [rbp+08H]
       488902               mov      bword ptr [rdx] rax
       894A08               mov      dword ptr [rdx+8] ecx
       488D4D08             lea      rcx bword ptr [rbp+08H]
       E86FFFFFFF           call     Program:Consume(struct)
       48B9818FC0ED9AA70000 mov      rcx 0xA79AEDC08F81
       48394D00             cmp      qword ptr [rbp] rcx
       7405                 je       SHORT G_M16477_IG06
       E8CAEDC35F           call     CORINFO_HELP_FAIL_FAST

G_M16477_IG06:
       90                   nop      

G_M16477_IG07:
       488D6520             lea      rsp [rbp+20H]
       5E                   pop      rsi
       5F                   pop      rdi
       5D                   pop      rbp
       C3                   ret      

G_M16477_IG08:
       E8BC0E7F59           call     ThrowHelper:ThrowArgumentOutOfRangeException()
       CC                   int3     

; Total bytes of code 149 prolog size 49 for method Program:StackAllocDynamicAsSpan(int)
; ============================================================
```
&lt;/p&gt;
&lt;/details&gt;



</Description>
    <Title_Description>[JIT]: Stack allocation to Span I looked at what IL and x86 code is generated for different ways of allocating memory on stack
and think there is room for optimizations. 

1. Roslyn could generate better IL for `Span&lt;byte&gt; span = stackalloc byte[512];` (see `StackAllocFixedAsSpan`). It should be similar to the IL generated for `byte* ptr = stackalloc byte[512];` (`StackAllocFixedAsPtr`). I will create  an issue in Roslyn repo for that.

2. JIT could recognize fixed size stack allocations and  generate simpler code.
    Compare `StackAllocFixedAsPtr` to `LocalAsPtr` and `StackAllocFixedAsSpan` to `LocalAsSpan`.

@VSadov @jkotas 

```C#
[StructLayout(LayoutKind.Sequential Size = 512)]
struct WideStruct { }

[MethodImpl(MethodImplOptions.NoInlining)]
private static unsafe void Consume(byte* ptr) {}

[MethodImpl(MethodImplOptions.NoInlining)]
private static unsafe void Consume(Span&lt;byte&gt; span) {}
```

&lt;details&gt;&lt;summary&gt;LocalAsPtr&lt;/summary&gt;
&lt;p&gt;

```C#
[MethodImpl(MethodImplOptions.NoInlining)]
private static unsafe void LocalAsPtr()
{
    WideStruct i;
    Consume((byte*)&amp;i);
}
```
```
.method private hidebysig static 
	void LocalAsPtr () cil managed noinlining 
{
	// Method begins at RVA 0x20dc
	// Code size 9 (0x9)
	.maxstack 1
	.locals init (
		[0] valuetype TestDotNetCore.Program/WideStruct
	)

	IL_0000: ldloca.s 0
	IL_0002: conv.u
	IL_0003: call void TestDotNetCore.Program::Consume(uint8*)
	IL_0008: ret
}
```
```ASM
; Assembly listing for method Program:LocalAsPtr()
; Emitting BLENDED_CODE for X64 CPU with AVX
; optimized code
; rsp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 loc0         [V00    ] (  1  1   )  struct (512) [rsp+0x20]   do-not-enreg[XS] must-init addr-exposed ld-addr-op
;  V01 OutArgs      [V01    ] (  1  1   )  lclBlk (32) [rsp+0x00]  
;
; Lcl frame size = 544

G_M54392_IG01:
       57                   push     rdi
       4881EC20020000       sub      rsp 544
       488D7C2420           lea      rdi [rsp+20H]
       B980000000           mov      ecx 128
       33C0                 xor      rax rax
       F3AB                 rep stosd 

G_M54392_IG02:
       488D4C2420           lea      rcx bword ptr [rsp+20H]
       E8A0FDFFFF           call     Program:Consume(long)
       90                   nop      

G_M54392_IG03:
       4881C420020000       add      rsp 544
       5F                   pop      rdi
       C3                   ret      

; Total bytes of code 42 prolog size 22 for method Program:LocalAsPtr()
; ============================================================
```
&lt;/p&gt;
&lt;/details&gt;

&lt;details&gt;&lt;summary&gt;LocalAsSpan&lt;/summary&gt;
&lt;p&gt;

```C#
[MethodImpl(MethodImplOptions.NoInlining)]
private static unsafe void LocalAsSpan()
{
    WideStruct i;
    Consume(new Span&lt;byte&gt;((byte*)&amp;i sizeof(WideStruct)));
}
```
```
.method private hidebysig static 
	void LocalAsSpan () cil managed noinlining 
{
	// Code size 20 (0x14)
	.maxstack 2
	.locals init (
		[0] valuetype TestDotNetCore.Program/WideStruct
	)

	IL_0000: ldloca.s 0
	IL_0002: conv.u
	IL_0003: sizeof TestDotNetCore.Program/WideStruct
	IL_0009: newobj instance void valuetype [System.Memory]System.Span`1&lt;uint8&gt;::.ctor(void* int32)
	IL_000e: call void TestDotNetCore.Program::Consume(valuetype [System.Memory]System.Span`1&lt;uint8&gt;)
	IL_0013: ret
}
```
```ASM
; Assembly listing for method Program:LocalAsSpan()
; Emitting BLENDED_CODE for X64 CPU with AVX
; optimized code
; rsp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 loc0         [V00    ] (  1  1   )  struct (512) [rsp+0x30]   do-not-enreg[XS] must-init addr-exposed ld-addr-op
;  V01 OutArgs      [V01    ] (  1  1   )  lclBlk (32) [rsp+0x00]  
;* V02 tmp1         [V02    ] (  0  0   )  struct (16) zero-ref   
;  V03 tmp2         [V03T01] (  2  4   )    long  -&gt;  rcx        
;* V04 tmp3         [V04    ] (  0  0   )  struct ( 8) zero-ref   
;  V05 tmp4         [V05T02] (  2  2   )   byref  -&gt;  rcx         V02._pointer(offs=0x00) P-INDEP
;  V06 tmp5         [V06T04] (  2  2   )     int  -&gt;  rax         V02._length(offs=0x08) P-INDEP
;  V07 tmp6         [V07T03] (  2  2   )   byref  -&gt;  rcx         V04._value(offs=0x00) P-INDEP
;  V08 tmp7         [V08    ] (  3  6   )  struct (16) [rsp+0x20]   do-not-enreg[XSB] must-init addr-exposed
;  V09 tmp8         [V09T00] (  3  6   )   byref  -&gt;  rdx         stack-byref
;
; Lcl frame size = 560

G_M21189_IG01:
       57                   push     rdi
       4881EC30020000       sub      rsp 560
       488D7C2420           lea      rdi [rsp+20H]
       B984000000           mov      ecx 132
       33C0                 xor      rax rax
       F3AB                 rep stosd 

G_M21189_IG02:
       488D4C2430           lea      rcx bword ptr [rsp+30H]
       B800020000           mov      eax 512
       488D542420           lea      rdx bword ptr [rsp+20H]
       48890A               mov      bword ptr [rdx] rcx
       894208               mov      dword ptr [rdx+8] eax
       488D4C2420           lea      rcx bword ptr [rsp+20H]
       E89BFEFFFF           call     Program:Consume(struct)
       90                   nop      

G_M21189_IG03:
       4881C430020000       add      rsp 560
       5F                   pop      rdi
       C3                   ret      

; Total bytes of code 63 prolog size 22 for method Program:LocalAsSpan()
; ============================================================
```
&lt;/p&gt;
&lt;/details&gt;

&lt;details&gt;&lt;summary&gt;StackAllocFixedAsPtr&lt;/summary&gt;
&lt;p&gt;

```C#
[MethodImpl(MethodImplOptions.NoInlining)]
private static unsafe void StackAllocFixedAsPtr()
{
    byte* ptr = stackalloc byte[512];
    Consume(ptr);
}
```
```
.method private hidebysig static 
	void StackAllocFixedAsPtr () cil managed noinlining 
{
	// Code size 14 (0xe)
	.maxstack 8

	IL_0000: ldc.i4 512
	IL_0005: conv.u
	IL_0006: localloc
	IL_0008: call void TestDotNetCore.Program::Consume(uint8*)
	IL_000d: ret
}
```
```ASM
; Assembly listing for method Program:StackAllocFixedAsPtr()
; Emitting BLENDED_CODE for X64 CPU with AVX
; optimized code
; rbp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 OutArgs      [V00    ] (  1  1   )  lclBlk (32) [rsp+0x00]  
;* V01 GsCookie     [V01    ] (  0  0   )    long  -&gt;  zero-ref    do-not-enreg[X] addr-exposed
;  V02 LocAllocSP   [V02    ] (  1  1   )    long  -&gt;  [rbp+0x08]   do-not-enreg[X] addr-exposed
;
; Lcl frame size = 48

G_M56192_IG01:
       55                   push     rbp
       4883EC30             sub      rsp 48
       488D6C2420           lea      rbp [rsp+20H]
       48896508             mov      qword ptr [rbp+08H] rsp
       48B8818FC0ED9AA70000 mov      rax 0xA79AEDC08F81
       48894500             mov      qword ptr [rbp] rax

G_M56192_IG02:
       4883C420             add      rsp 32
       852424               test     dword ptr [rsp] esp
       4881EC00020000       sub      rsp 512
       4883EC20             sub      rsp 32
       488D4C2420           lea      rcx [rsp+20H]
       48896508             mov      qword ptr [rbp+08H] rsp
       E8E4FDFFFF           call     Program:Consume(long)
       48B9818FC0ED9AA70000 mov      rcx 0xA79AEDC08F81
       48394D00             cmp      qword ptr [rbp] rcx
       7405                 je       SHORT G_M56192_IG03
       E8EFEFC35F           call     CORINFO_HELP_FAIL_FAST

G_M56192_IG03:
       90                   nop      

G_M56192_IG04:
       488D6510             lea      rsp [rbp+10H]
       5D                   pop      rbp
       C3                   ret      

; Total bytes of code 88 prolog size 28 for method Program:StackAllocFixedAsPtr()
; ============================================================
```
&lt;/p&gt;
&lt;/details&gt;

&lt;details&gt;&lt;summary&gt;StackAllocDynamicAsPtr&lt;/summary&gt;
&lt;p&gt;

```C#
[MethodImpl(MethodImplOptions.NoInlining)]
private static unsafe void StackAllocDynamicAsPtr(int size)
{
    byte* ptr = stackalloc byte[size];
    Consume(ptr);
} 
```
```
.method private hidebysig static 
	void StackAllocDynamicAsPtr (
		int32 size
	) cil managed noinlining 
{
	// Code size 10 (0xa)
	.maxstack 8

	IL_0000: ldarg.0
	IL_0001: conv.u
	IL_0002: localloc
	IL_0004: call void TestDotNetCore.Program::Consume(uint8*)
	IL_0009: ret
}
```
```ASM
; Assembly listing for method Program:StackAllocDynamicAsPtr(int)
; Emitting BLENDED_CODE for X64 CPU with AVX
; optimized code
; rbp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00T00] (  3  3   )     int  -&gt;  rcx        
;  V01 OutArgs      [V01    ] (  1  1   )  lclBlk (32) [rsp+0x00]  
;* V02 GsCookie     [V02    ] (  0  0   )    long  -&gt;  zero-ref    do-not-enreg[X] addr-exposed
;  V03 LocAllocSP   [V03    ] (  1  1   )    long  -&gt;  [rbp+0x08]   do-not-enreg[X] addr-exposed
;
; Lcl frame size = 48

G_M8739_IG01:
       55                   push     rbp
       4883EC30             sub      rsp 48
       488D6C2420           lea      rbp [rsp+20H]
       48896508             mov      qword ptr [rbp+08H] rsp
       48B8818FC0ED9AA70000 mov      rax 0xA79AEDC08F81
       48894500             mov      qword ptr [rbp] rax

G_M8739_IG02:
       8BC9                 mov      ecx ecx
       4885C9               test     rcx rcx
       743A                 je       SHORT G_M8739_IG04
       488BC1               mov      rax rcx
       4883C00F             add      rax 15
       4883E0F0             and      rax -16
       4883C420             add      rsp 32
       48F7D8               neg      rax
       4803C4               add      rax rsp
       7202                 jb       SHORT G_M8739_IG03
       33C0                 xor      rax rax

G_M8739_IG03:
       852424               test     dword ptr [rsp] esp
       488BD4               mov      rdx rsp
       4881EA00100000       sub      rdx 0x1000
       488BE2               mov      rsp rdx
       483BE0               cmp      rsp rax
       73EB                 jae      SHORT G_M8739_IG03
       488BE0               mov      rsp rax
       4883EC20             sub      rsp 32
       488D4C2420           lea      rcx [rsp+20H]

G_M8739_IG04:
       48896508             mov      qword ptr [rbp+08H] rsp
       E87AFFFFFF           call     Program:Consume(long)
       48B9818FC0ED9AA70000 mov      rcx 0xA79AEDC08F81
       48394D00             cmp      qword ptr [rbp] rcx
       7405                 je       SHORT G_M8739_IG05
       E835EFC35F           call     CORINFO_HELP_FAIL_FAST

G_M8739_IG05:
       90                   nop      

G_M8739_IG06:
       488D6510             lea      rsp [rbp+10H]
       5D                   pop      rbp
       C3                   ret      

; Total bytes of code 130 prolog size 28 for method Program:StackAllocDynamicAsPtr(int)
; ============================================================
```
&lt;/p&gt;
&lt;/details&gt;

&lt;details&gt;&lt;summary&gt;StackAllocFixedAsSpan&lt;/summary&gt;
&lt;p&gt;

```C#
[MethodImpl(MethodImplOptions.NoInlining)]
private static unsafe void StackAllocFixedAsSpan()
{
    Span&lt;byte&gt; span = stackalloc byte[512];
    Consume(span);
}
```
```
.method private hidebysig static 
	void StackAllocFixedAsSpan () cil managed noinlining 
{
	// Code size 22 (0x16)
	.maxstack 2
	.locals init (
		[0] int32
	)

	IL_0000: ldc.i4 512
	IL_0005: stloc.0
	IL_0006: ldloc.0
	IL_0007: conv.u
	IL_0008: localloc
	IL_000a: ldloc.0
	IL_000b: newobj instance void valuetype [System.Memory]System.Span`1&lt;uint8&gt;::.ctor(void* int32)
	IL_0010: call void TestDotNetCore.Program::Consume(valuetype [System.Memory]System.Span`1&lt;uint8&gt;)
	IL_0015: ret
}
```
```ASM
; Assembly listing for method Program:StackAllocFixedAsSpan()
; Emitting BLENDED_CODE for X64 CPU with AVX
; optimized code
; rbp based frame
; partially interruptible
; Final local variable assignments
;
;* V00 loc0         [V00T05] (  0  0   )     int  -&gt;  zero-ref   
;  V01 OutArgs      [V01    ] (  1  1   )  lclBlk (32) [rsp+0x00]  
;* V02 tmp1         [V02    ] (  0  0   )  struct (16) zero-ref   
;  V03 tmp2         [V03T01] (  2  4   )    long  -&gt;  rcx        
;* V04 tmp3         [V04    ] (  0  0   )  struct ( 8) zero-ref   
;  V05 tmp4         [V05T03] (  2  2   )   byref  -&gt;  rcx         V02._pointer(offs=0x00) P-INDEP
;  V06 tmp5         [V06T02] (  3  3   )     int  -&gt;  rax         V02._length(offs=0x08) P-INDEP
;  V07 tmp6         [V07T04] (  2  2   )   byref  -&gt;  rcx         V04._value(offs=0x00) P-INDEP
;  V08 tmp7         [V08    ] (  3  6   )  struct (16) [rbp+0x10]   do-not-enreg[XSB] must-init addr-exposed
;  V09 tmp8         [V09T00] (  3  6   )   byref  -&gt;  rdx         stack-byref
;* V10 GsCookie     [V10    ] (  0  0   )    long  -&gt;  zero-ref    do-not-enreg[X] must-init addr-exposed
;  V11 LocAllocSP   [V11    ] (  1  1   )    long  -&gt;  [rbp+0x20]   do-not-enreg[X] must-init addr-exposed
;
; Lcl frame size = 72

G_M31550_IG01:
       55                   push     rbp
       57                   push     rdi
       4883EC48             sub      rsp 72
       488D6C2420           lea      rbp [rsp+20H]
       488D7D08             lea      rdi [rbp+08H]
       B908000000           mov      ecx 8
       33C0                 xor      rax rax
       F3AB                 rep stosd 
       48896520             mov      qword ptr [rbp+20H] rsp
       48B8818FC0ED9AA70000 mov      rax 0xA79AEDC08F81
       48894508             mov      qword ptr [rbp+08H] rax

G_M31550_IG02:
       4883C420             add      rsp 32
       B920000000           mov      ecx 32

G_M31550_IG03:
       6A00                 push     0
       6A00                 push     0
       48FFC9               dec      rcx
       75F7                 jne      SHORT G_M31550_IG03
       4883EC20             sub      rsp 32
       488D4C2420           lea      rcx [rsp+20H]
       48896520             mov      qword ptr [rbp+20H] rsp
       B800020000           mov      eax 512
       488D5510             lea      rdx bword ptr [rbp+10H]
       48890A               mov      bword ptr [rdx] rcx
       894208               mov      dword ptr [rdx+8] eax
       488D4D10             lea      rcx bword ptr [rbp+10H]
       E897FCFFFF           call     Program:Consume(struct)
       48B9818FC0ED9AA70000 mov      rcx 0xA79AEDC08F81
       48394D08             cmp      qword ptr [rbp+08H] rcx
       7405                 je       SHORT G_M31550_IG04
       E89AEEC35F           call     CORINFO_HELP_FAIL_FAST

G_M31550_IG04:
       90                   nop      

G_M31550_IG05:
       488D6528             lea      rsp [rbp+28H]
       5F                   pop      rdi
       5D                   pop      rbp
       C3                   ret      

; Total bytes of code 126 prolog size 42 for method Program:StackAllocFixedAsSpan()
; ============================================================
```
&lt;/p&gt;
&lt;/details&gt;

&lt;details&gt;&lt;summary&gt;StackAllocDynamicAsSpan&lt;/summary&gt;
&lt;p&gt;

```C#
[MethodImpl(MethodImplOptions.NoInlining)]
private static unsafe void StackAllocDynamicAsSpan(int size)
{
    Span&lt;byte&gt; span = stackalloc byte[size];
    Consume(span);
}
```
```
.method private hidebysig static 
	void StackAllocDynamicAsSpan (
		int32 size
	) cil managed noinlining 
{
	// Code size 18 (0x12)
	.maxstack 2
	.locals init (
		[0] int32
	)

	IL_0000: ldarg.0
	IL_0001: stloc.0
	IL_0002: ldloc.0
	IL_0003: conv.u
	IL_0004: localloc
	IL_0006: ldloc.0
	IL_0007: newobj instance void valuetype [System.Memory]System.Span`1&lt;uint8&gt;::.ctor(void* int32)
	IL_000c: call void TestDotNetCore.Program::Consume(valuetype [System.Memory]System.Span`1&lt;uint8&gt;)
	IL_0011: ret
}
```
```ASM
; Assembly listing for method Program:StackAllocDynamicAsSpan(int)
; Emitting BLENDED_CODE for X64 CPU with AVX
; optimized code
; rbp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00T01] (  3  3   )     int  -&gt;  rcx        
;  V01 loc0         [V01T02] (  4  4   )     int  -&gt;  rcx        
;  V02 OutArgs      [V02    ] (  1  1   )  lclBlk (32) [rsp+0x00]  
;* V03 tmp1         [V03    ] (  0  0   )  struct (16) zero-ref   
;  V04 tmp2         [V04T03] (  2  4   )    long  -&gt;  rax        
;* V05 tmp3         [V05    ] (  0  0   )  struct ( 8) zero-ref   
;  V06 tmp4         [V06T04] (  2  2   )   byref  -&gt;  rax         V03._pointer(offs=0x00) P-INDEP
;  V07 tmp5         [V07T06] (  2  2   )     int  -&gt;  rcx         V03._length(offs=0x08) P-INDEP
;  V08 tmp6         [V08T05] (  2  2   )   byref  -&gt;  rax         V05._value(offs=0x00) P-INDEP
;  V09 tmp7         [V09    ] (  3  6   )  struct (16) [rbp+0x08]   do-not-enreg[XSB] must-init addr-exposed
;  V10 tmp8         [V10T00] (  3  6   )   byref  -&gt;  rdx         stack-byref
;* V11 GsCookie     [V11    ] (  0  0   )    long  -&gt;  zero-ref    do-not-enreg[X] must-init addr-exposed
;  V12 LocAllocSP   [V12    ] (  1  1   )    long  -&gt;  [rbp+0x18]   do-not-enreg[X] must-init addr-exposed
;
; Lcl frame size = 64

G_M16477_IG01:
       55                   push     rbp
       57                   push     rdi
       56                   push     rsi
       4883EC40             sub      rsp 64
       488D6C2420           lea      rbp [rsp+20H]
       488BF1               mov      rsi rcx
       488D7D00             lea      rdi [rbp]
       B908000000           mov      ecx 8
       33C0                 xor      rax rax
       F3AB                 rep stosd 
       488BCE               mov      rcx rsi
       48896518             mov      qword ptr [rbp+18H] rsp
       48B8818FC0ED9AA70000 mov      rax 0xA79AEDC08F81
       48894500             mov      qword ptr [rbp] rax

G_M16477_IG02:
       8BC1                 mov      eax ecx
       4885C0               test     rax rax
       741E                 je       SHORT G_M16477_IG04
       4883C00F             add      rax 15
       48C1E804             shr      rax 4
       4883C420             add      rsp 32

G_M16477_IG03:
       6A00                 push     0
       6A00                 push     0
       48FFC8               dec      rax
       75F7                 jne      SHORT G_M16477_IG03
       4883EC20             sub      rsp 32
       488D442420           lea      rax [rsp+20H]

G_M16477_IG04:
       48896518             mov      qword ptr [rbp+18H] rsp
       85C9                 test     ecx ecx
       7C31                 jl       SHORT G_M16477_IG08

G_M16477_IG05:
       488D5508             lea      rdx bword ptr [rbp+08H]
       488902               mov      bword ptr [rdx] rax
       894A08               mov      dword ptr [rdx+8] ecx
       488D4D08             lea      rcx bword ptr [rbp+08H]
       E86FFFFFFF           call     Program:Consume(struct)
       48B9818FC0ED9AA70000 mov      rcx 0xA79AEDC08F81
       48394D00             cmp      qword ptr [rbp] rcx
       7405                 je       SHORT G_M16477_IG06
       E8CAEDC35F           call     CORINFO_HELP_FAIL_FAST

G_M16477_IG06:
       90                   nop      

G_M16477_IG07:
       488D6520             lea      rsp [rbp+20H]
       5E                   pop      rsi
       5F                   pop      rdi
       5D                   pop      rbp
       C3                   ret      

G_M16477_IG08:
       E8BC0E7F59           call     ThrowHelper:ThrowArgumentOutOfRangeException()
       CC                   int3     

; Total bytes of code 149 prolog size 49 for method Program:StackAllocDynamicAsSpan(int)
; ============================================================
```
&lt;/p&gt;
&lt;/details&gt;



</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>VSadov</Assignee>
    <CreatedAt>28/04/2018 2:10:13 PM +00:00</CreatedAt>
    <ClosedAt>6/05/2018 6:27:50 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17827</IssueLabelID>
    <Title>Should FEATURE_APPX be enabled in coreclr builds?</Title>
    <Description>`AppDomain.Flags` is behind `#if FEATURE_APPX`

```csharp
private static APPX_FLAGS Flags
{
    get
    {
        if (s_flags == 0)
            s_flags = nGetAppXFlags();

        Debug.Assert(s_flags != 0);
        return s_flags;
    }
}
```
However its output in a crossgen build?
```asm
; Assembly listing for method AppDomain:get_Flags():int
; Emitting BLENDED_CODE for X64 CPU with SSE2
; optimized code
; rbp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 OutArgs      [V00    ] (  1  1   )  lclBlk (32) [rsp+0x00]  
;  V01 cse0         [V01T00] ( 10  8.50)    long  -&gt;  rsi        
;
; Lcl frame size = 40
G_M62617_IG01:
       push     rbp
       push     rsi
       sub      rsp 40
       lea      rbp [rsp+30H]
G_M62617_IG02:
       mov      rcx qword ptr [(reloc)]
       call     CORINFO_HELP_GETSHARED_NONGCSTATIC_BASE_NOCTOR
       mov      rsi rax
       cmp      dword ptr [rsi+07F0H] 0
       jne      SHORT G_M62617_IG03
       call     AppDomain:nGetAppXFlags():int
       mov      dword ptr [rsi+07F0H] eax
G_M62617_IG03:
       mov      eax dword ptr [rsi+07F0H]
G_M62617_IG04:
       lea      rsp [rbp-08H]
       pop      rsi
       pop      rbp
       ret      
; Total bytes of code 59 prolog size 11 for method AppDomain:get_Flags():int
```
/cc @jkotas @danmosemsft </Description>
    <Title_Description>Should FEATURE_APPX be enabled in coreclr builds? `AppDomain.Flags` is behind `#if FEATURE_APPX`

```csharp
private static APPX_FLAGS Flags
{
    get
    {
        if (s_flags == 0)
            s_flags = nGetAppXFlags();

        Debug.Assert(s_flags != 0);
        return s_flags;
    }
}
```
However its output in a crossgen build?
```asm
; Assembly listing for method AppDomain:get_Flags():int
; Emitting BLENDED_CODE for X64 CPU with SSE2
; optimized code
; rbp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 OutArgs      [V00    ] (  1  1   )  lclBlk (32) [rsp+0x00]  
;  V01 cse0         [V01T00] ( 10  8.50)    long  -&gt;  rsi        
;
; Lcl frame size = 40
G_M62617_IG01:
       push     rbp
       push     rsi
       sub      rsp 40
       lea      rbp [rsp+30H]
G_M62617_IG02:
       mov      rcx qword ptr [(reloc)]
       call     CORINFO_HELP_GETSHARED_NONGCSTATIC_BASE_NOCTOR
       mov      rsi rax
       cmp      dword ptr [rsi+07F0H] 0
       jne      SHORT G_M62617_IG03
       call     AppDomain:nGetAppXFlags():int
       mov      dword ptr [rsi+07F0H] eax
G_M62617_IG03:
       mov      eax dword ptr [rsi+07F0H]
G_M62617_IG04:
       lea      rsp [rbp-08H]
       pop      rsi
       pop      rbp
       ret      
; Total bytes of code 59 prolog size 11 for method AppDomain:get_Flags():int
```
/cc @jkotas @danmosemsft </Title_Description>
    <Label>area-Interop</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>28/04/2018 12:57:27 PM +00:00</CreatedAt>
    <ClosedAt>28/04/2018 1:44:54 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17825</IssueLabelID>
    <Title>SEHException occurs VS 2017 Remote Debugging on Windows  to debug Linux ASP.NET Core application</Title>
    <Description>Application Environment: Oracle Linux 7.4 (RedHat 7.4)
Debugging Environment: Visual Studio Enterprise 2017 v15.6.6 on Windows
.NET Core SDK Version on both Windows and Linux: 2.1.101

VS is able to attach the Linux ASP .NET Core process in the debugger.  However when trying to step over or continue the execution SEHException occurs.  Here is the exception information:
 - Data: System.Collections.ListDictionaryInternal
 - ErrorCode/HResult: -2147467259
 - Message: "External component has thrown an exception."

We have Microsoft sessions on site to talk about VS remote debugging for ASP.NET Core on Linux  and have documentation to describe how to do that.  However the documentation is based on ubuntu Linux.    We follow similar steps in Oracle Linux v7.4 and encountered SEHException.  We also tried Console Application and also encountered exception.

We need to know if VS Remote debugging on Window can debug .NET Core process in  Oracle Linux v7.1 or above.    
</Description>
    <Title_Description>SEHException occurs VS 2017 Remote Debugging on Windows  to debug Linux ASP.NET Core application Application Environment: Oracle Linux 7.4 (RedHat 7.4)
Debugging Environment: Visual Studio Enterprise 2017 v15.6.6 on Windows
.NET Core SDK Version on both Windows and Linux: 2.1.101

VS is able to attach the Linux ASP .NET Core process in the debugger.  However when trying to step over or continue the execution SEHException occurs.  Here is the exception information:
 - Data: System.Collections.ListDictionaryInternal
 - ErrorCode/HResult: -2147467259
 - Message: "External component has thrown an exception."

We have Microsoft sessions on site to talk about VS remote debugging for ASP.NET Core on Linux  and have documentation to describe how to do that.  However the documentation is based on ubuntu Linux.    We follow similar steps in Oracle Linux v7.4 and encountered SEHException.  We also tried Console Application and also encountered exception.

We need to know if VS Remote debugging on Window can debug .NET Core process in  Oracle Linux v7.1 or above.    
</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>28/04/2018 1:18:41 AM +00:00</CreatedAt>
    <ClosedAt>1/05/2018 7:13:01 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17824</IssueLabelID>
    <Title>Concurrent GC enabled with multiple env vars</Title>
    <Description>Concurrent GC can be enabled by setting environment variable COMPlus_gcConcurrent=1

There is another variable that sets this: CORECLR_CONCURRENT_GC.

We should only have one variable that sets concurrent GC instead of having multiple of them.

Similar issue to https://github.com/dotnet/coreclr/issues/17760</Description>
    <Title_Description>Concurrent GC enabled with multiple env vars Concurrent GC can be enabled by setting environment variable COMPlus_gcConcurrent=1

There is another variable that sets this: CORECLR_CONCURRENT_GC.

We should only have one variable that sets concurrent GC instead of having multiple of them.

Similar issue to https://github.com/dotnet/coreclr/issues/17760</Title_Description>
    <Label>area-GC</Label>
    <Assignee>sywhang</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17823</IssueLabelID>
    <Title>Ensure that any byrefs created in genCodeForIndexAddr cannot point outside of the array</Title>
    <Description>For Arm/arm64 in `CodeGen::genCodeForIndexAddr(GenTreeIndexAddr* node)` we need to insure that we don't create a byref that might point outside of the array object.

</Description>
    <Title_Description>Ensure that any byrefs created in genCodeForIndexAddr cannot point outside of the array For Arm/arm64 in `CodeGen::genCodeForIndexAddr(GenTreeIndexAddr* node)` we need to insure that we don't create a byref that might point outside of the array object.

</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>briansull</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17822</IssueLabelID>
    <Title>Main thread is not CoInitializeEx'ed to MTA by default</Title>
    <Description>When the attribute is not present. Forked from https://github.com/dotnet/coreclr/issues/17787. Fixes for both issues would be breaking changes and should be fixed for the next major version release (3.0).

https://github.com/dotnet/coreclr/blob/53450d7cd4f3d73aa976d2d6be96a3bfe6c028c9/src/vm/assembly.cpp#L1804 and `SystemDomain::SetThreadAptState` would need to be fixed (`state` is `AS_Unknown` at this point).

[Milestone = 3.0]</Description>
    <Title_Description>Main thread is not CoInitializeEx'ed to MTA by default When the attribute is not present. Forked from https://github.com/dotnet/coreclr/issues/17787. Fixes for both issues would be breaking changes and should be fixed for the next major version release (3.0).

https://github.com/dotnet/coreclr/blob/53450d7cd4f3d73aa976d2d6be96a3bfe6c028c9/src/vm/assembly.cpp#L1804 and `SystemDomain::SetThreadAptState` would need to be fixed (`state` is `AS_Unknown` at this point).

[Milestone = 3.0]</Title_Description>
    <Label>area-System.Threading</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17821</IssueLabelID>
    <Title>Adding back test for windows event log</Title>
    <Description>This test was added with https://github.com/dotnet/coreclr/pull/17401 but had to be removed in https://github.com/dotnet/coreclr/pull/17482 because the tests were failing. Fixed it by allowing more leeway in checking for timestamps in the event log entries and moving the test dependency into Common directory instead of the test itself.</Description>
    <Title_Description>Adding back test for windows event log This test was added with https://github.com/dotnet/coreclr/pull/17401 but had to be removed in https://github.com/dotnet/coreclr/pull/17482 because the tests were failing. Fixed it by allowing more leeway in checking for timestamps in the event log entries and moving the test dependency into Common directory instead of the test itself.</Title_Description>
    <Label>
    </Label>
    <Assignee>sywhang</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17818</IssueLabelID>
    <Title>Post-2.1 plan of Intel hardware intrinsic</Title>
    <Description>1. Refine the API design of Intel hardware intrinsic
    - related issues/PRs: https://github.com/dotnet/coreclr/pull/17637 https://github.com/dotnet/corefx/issues/29247
2. Implement remaining AVX2 intrinsic [rely on (1)]
    - related issues/PRs: https://github.com/dotnet/coreclr/issues/16653
3. Implement remaining SSE4.2 intrinsic [rely on (1)]
    - related issues/PRs: https://github.com/dotnet/coreclr/issues/16270
4. Enable containment analysis on more hardware intrinsic forms (e.g. imm 1-arg 3-arg etc.)
5. Implement FMA intrinsic [rely on (4)]
    - FMA intrinsic codegen is different from other ISAs whose instruction selection depends on the operator's position (e.g. in registers or memory?)
6. Implement other ISA classes (`Bmi1` `Bmi2` `Aes` and `Pclmulqdq`)
    - fully support all the Intel hardware intrinsic of existing APIs 
7. Create non-trivial benchmarks for Intel hardware intrinsic
    - related issues/PRs: https://github.com/dotnet/coreclr/issues/17798
8. Improve the CQ of Intel hardware intrinsic base-on key scenarios [partially rely on (7)]
    - especially when intrinsics are used in combination or with things like Vectors and identify areas that need work.
    - related issues/PRs: https://github.com/dotnet/coreclr/issues/17073 https://github.com/dotnet/coreclr/issues/17108
9. Investigate the JIT throughput impact from hardware intrinsic recognition [rely on (7)]
    - related discussion: https://github.com/dotnet/coreclr/pull/14020#issuecomment-331611668
10. Identify candidates that can be optimized using HW intrinsics and implement them using intrinsics (CoreFX mscorlib HPC ML etc.)
    - related issues/PRs: https://github.com/dotnet/coreclr/issues/15506 https://github.com/dotnet/corefx/issues/25386
11. more...

category:cq
theme:intrinsics
skill-level:intermediate
cost:extra-large</Description>
    <Title_Description>Post-2.1 plan of Intel hardware intrinsic 1. Refine the API design of Intel hardware intrinsic
    - related issues/PRs: https://github.com/dotnet/coreclr/pull/17637 https://github.com/dotnet/corefx/issues/29247
2. Implement remaining AVX2 intrinsic [rely on (1)]
    - related issues/PRs: https://github.com/dotnet/coreclr/issues/16653
3. Implement remaining SSE4.2 intrinsic [rely on (1)]
    - related issues/PRs: https://github.com/dotnet/coreclr/issues/16270
4. Enable containment analysis on more hardware intrinsic forms (e.g. imm 1-arg 3-arg etc.)
5. Implement FMA intrinsic [rely on (4)]
    - FMA intrinsic codegen is different from other ISAs whose instruction selection depends on the operator's position (e.g. in registers or memory?)
6. Implement other ISA classes (`Bmi1` `Bmi2` `Aes` and `Pclmulqdq`)
    - fully support all the Intel hardware intrinsic of existing APIs 
7. Create non-trivial benchmarks for Intel hardware intrinsic
    - related issues/PRs: https://github.com/dotnet/coreclr/issues/17798
8. Improve the CQ of Intel hardware intrinsic base-on key scenarios [partially rely on (7)]
    - especially when intrinsics are used in combination or with things like Vectors and identify areas that need work.
    - related issues/PRs: https://github.com/dotnet/coreclr/issues/17073 https://github.com/dotnet/coreclr/issues/17108
9. Investigate the JIT throughput impact from hardware intrinsic recognition [rely on (7)]
    - related discussion: https://github.com/dotnet/coreclr/pull/14020#issuecomment-331611668
10. Identify candidates that can be optimized using HW intrinsics and implement them using intrinsics (CoreFX mscorlib HPC ML etc.)
    - related issues/PRs: https://github.com/dotnet/coreclr/issues/15506 https://github.com/dotnet/corefx/issues/25386
11. more...

category:cq
theme:intrinsics
skill-level:intermediate
cost:extra-large</Title_Description>
    <Label>Design Discussion</Label>
    <Assignee>CarolEidt</Assignee>
    <CreatedAt>27/04/2018 6:10:53 PM +00:00</CreatedAt>
    <ClosedAt>11/01/2019 10:24:57 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17816</IssueLabelID>
    <Title>ResourceManager doesn't take the SatelliteContractVersion attribute into account</Title>
    <Description>I have a third-party .NET Standard 2.0 class library built with MSBuild via VisualStudio. The library has the SatelliteContractVersion attribute. The corresponding satellite assembly with localization resources has an assembly version that differs from the main library's assembly version.
The main assembly is loaded successfully by the .NET Framework 4.6.1 and .NET Core framework. But the satellite assembly is loaded only if an application that uses the library is built with .NET Framework 4.6.1. 
 
The issue occurs in .NET Core because the ResourceManager.GetSatelliteContractVersion() method always returns the 'null' value. So the ResourceManager in .NET Core ignores the version of the satellite assembly which is specified in the SatelliteContractVersion attribute of the main assembly. Instead the ResourceManager tries to load the satellite assembly with the version specified in the AssemblyVersion attribute of the main assembly.

For example the following attributes are applied to the assembly:
- [assembly: AssemblyVersion("1.2.3.4")]
- [assembly: SatelliteContractVersion("1.2.0.0")]

After building using MSBuild the following assemblies are created:
- a main assembly "A.dll" with version 1.2.3.4;
- a satellite assembly "A.resources.dll" with version 1.2.0.0.

.NET Core framework loads assembly "A.dll" with version 1.2.3.4 and tries to load the "A.resource.dll" assembly with version 1.2.3.4.

.NET Framework 4.6.1 loads assembly "A.dll" with version 1.2.3.4 and tries to load the "A.resouces.dll" assembly with version 1.2.0.0.

The issue leads to different behavior if the existing libraries with the SatelliteContractVersionAttribute are built by MSBuild in .NET Framework applications and .NET Core applications.</Description>
    <Title_Description>ResourceManager doesn't take the SatelliteContractVersion attribute into account I have a third-party .NET Standard 2.0 class library built with MSBuild via VisualStudio. The library has the SatelliteContractVersion attribute. The corresponding satellite assembly with localization resources has an assembly version that differs from the main library's assembly version.
The main assembly is loaded successfully by the .NET Framework 4.6.1 and .NET Core framework. But the satellite assembly is loaded only if an application that uses the library is built with .NET Framework 4.6.1. 
 
The issue occurs in .NET Core because the ResourceManager.GetSatelliteContractVersion() method always returns the 'null' value. So the ResourceManager in .NET Core ignores the version of the satellite assembly which is specified in the SatelliteContractVersion attribute of the main assembly. Instead the ResourceManager tries to load the satellite assembly with the version specified in the AssemblyVersion attribute of the main assembly.

For example the following attributes are applied to the assembly:
- [assembly: AssemblyVersion("1.2.3.4")]
- [assembly: SatelliteContractVersion("1.2.0.0")]

After building using MSBuild the following assemblies are created:
- a main assembly "A.dll" with version 1.2.3.4;
- a satellite assembly "A.resources.dll" with version 1.2.0.0.

.NET Core framework loads assembly "A.dll" with version 1.2.3.4 and tries to load the "A.resource.dll" assembly with version 1.2.3.4.

.NET Framework 4.6.1 loads assembly "A.dll" with version 1.2.3.4 and tries to load the "A.resouces.dll" assembly with version 1.2.0.0.

The issue leads to different behavior if the existing libraries with the SatelliteContractVersionAttribute are built by MSBuild in .NET Framework applications and .NET Core applications.</Title_Description>
    <Label>area-AssemblyLoader</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>27/04/2018 3:38:01 PM +00:00</CreatedAt>
    <ClosedAt>16/03/2019 4:30:59 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17815</IssueLabelID>
    <Title>HW intrinsics shouldn't assert for unsupported</Title>
    <Description>For example here:
https://github.com/dotnet/coreclr/blob/master/src/jit/hwintrinsicxarch.cpp#L816
As described in the comments for https://github.com/dotnet/coreclr/pull/17737 this can lead to an assert in the case where the user knows the path will not be taken. Such cases should simply return `nullptr` so that the IL method will be invoked.

category:correctness
theme:intrinsics
skill-level:beginner
cost:small</Description>
    <Title_Description>HW intrinsics shouldn't assert for unsupported For example here:
https://github.com/dotnet/coreclr/blob/master/src/jit/hwintrinsicxarch.cpp#L816
As described in the comments for https://github.com/dotnet/coreclr/pull/17737 this can lead to an assert in the case where the user knows the path will not be taken. Such cases should simply return `nullptr` so that the IL method will be invoked.

category:correctness
theme:intrinsics
skill-level:beginner
cost:small</Title_Description>
    <Label>arch-x64</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17812</IssueLabelID>
    <Title>Whether to support.Net native and how to use it</Title>
    <Description>Whether to support.Net native and how to use the .net native，
thank you</Description>
    <Title_Description>Whether to support.Net native and how to use it Whether to support.Net native and how to use the .net native，
thank you</Title_Description>
    <Label>question</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>27/04/2018 12:10:48 PM +00:00</CreatedAt>
    <ClosedAt>27/04/2018 12:37:37 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17810</IssueLabelID>
    <Title>Test failure: Interop_StructPacking._StructPacking_StructPacking_/_StructPacking_StructPacking_cmd</Title>
    <Description>Opened on behalf of @Sunny-pu

The test `Interop_StructPacking._StructPacking_StructPacking_/_StructPacking_StructPacking_cmd` has failed.
```
Error: Could not load file or assembly 'System.Runtime.Intrinsics.Experimental Version=4.0.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. The system cannot find the file specified.
     (Exception from HRESULT: 0x80070002)
    Error compiling StructPacking.org: Could not find or load a specific file. (Exception from HRESULT: 0x80131621)
    Error: compilation failed for "StructPacking.org" (0x80131621)
    
    
    Return code:      1
    Raw output file:      /home/helixbot/dotnetbuild/work/1db3eb44-4841-48bb-9805-f82ba51aafc3/Work/23138be3-f67f-4f5c-9e8a-b6351b0f207f/Unzip/Reports\Interop.StructPacking\StructPacking\StructPacking.output.txt
    Raw output:
    BEGIN EXECUTION
    in takeLock
    /home/helixbot/dotnetbuild/work/1db3eb44-4841-48bb-9805-f82ba51aafc3/Payload/crossgen /Platform_Assemblies_Paths /home/helixbot/dotnetbuild/work/1db3eb44-4841-48bb-9805-f82ba51aafc3/Payload:/home/helixbot/dotnetbuild/work/1db3eb44-4841-48bb-9805-f82ba51aafc3/Work/23138be3-f67f-4f5c-9e8a-b6351b0f207f/Unzip/StructPacking/IL:/home/helixbot/dotnetbuild/work/1db3eb44-4841-48bb-9805-f82ba51aafc3/Work/23138be3-f67f-4f5c-9e8a-b6351b0f207f/Unzip/StructPacking /in StructPacking.org /out StructPacking.exe
    Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0
    Copyright (c) Microsoft Corporation.  All rights reserved.
    
    Crossgen failed with exitcode: 33
    in ReleaseLock
    Test Harness Exitcode is : 1
    
    To run the test:
    &gt; set CORE_ROOT=/home/helixbot/dotnetbuild/work/1db3eb44-4841-48bb-9805-f82ba51aafc3/Payload
    &gt; /home/helixbot/dotnetbuild/work/1db3eb44-4841-48bb-9805-f82ba51aafc3/Work/23138be3-f67f-4f5c-9e8a-b6351b0f207f/Unzip/StructPacking/StructPacking.sh
    
    Expected: True
    Actual:   False

        Stack Trace:
```
        
Build : Master - 20180427.01 (Core Tests)
Failing configurations:
- redhat.69.amd64-x64
  - 

Details:
https://mc.dot.net/#/product/netcore/master/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fcli~2F/build/20180427.01/workItem/Interop.StructPacking.XUnitWrapper/analysis/xunit/Interop_StructPacking._StructPacking_StructPacking_~2F_StructPacking_StructPacking_cmd</Description>
    <Title_Description>Test failure: Interop_StructPacking._StructPacking_StructPacking_/_StructPacking_StructPacking_cmd Opened on behalf of @Sunny-pu

The test `Interop_StructPacking._StructPacking_StructPacking_/_StructPacking_StructPacking_cmd` has failed.
```
Error: Could not load file or assembly 'System.Runtime.Intrinsics.Experimental Version=4.0.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. The system cannot find the file specified.
     (Exception from HRESULT: 0x80070002)
    Error compiling StructPacking.org: Could not find or load a specific file. (Exception from HRESULT: 0x80131621)
    Error: compilation failed for "StructPacking.org" (0x80131621)
    
    
    Return code:      1
    Raw output file:      /home/helixbot/dotnetbuild/work/1db3eb44-4841-48bb-9805-f82ba51aafc3/Work/23138be3-f67f-4f5c-9e8a-b6351b0f207f/Unzip/Reports\Interop.StructPacking\StructPacking\StructPacking.output.txt
    Raw output:
    BEGIN EXECUTION
    in takeLock
    /home/helixbot/dotnetbuild/work/1db3eb44-4841-48bb-9805-f82ba51aafc3/Payload/crossgen /Platform_Assemblies_Paths /home/helixbot/dotnetbuild/work/1db3eb44-4841-48bb-9805-f82ba51aafc3/Payload:/home/helixbot/dotnetbuild/work/1db3eb44-4841-48bb-9805-f82ba51aafc3/Work/23138be3-f67f-4f5c-9e8a-b6351b0f207f/Unzip/StructPacking/IL:/home/helixbot/dotnetbuild/work/1db3eb44-4841-48bb-9805-f82ba51aafc3/Work/23138be3-f67f-4f5c-9e8a-b6351b0f207f/Unzip/StructPacking /in StructPacking.org /out StructPacking.exe
    Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0
    Copyright (c) Microsoft Corporation.  All rights reserved.
    
    Crossgen failed with exitcode: 33
    in ReleaseLock
    Test Harness Exitcode is : 1
    
    To run the test:
    &gt; set CORE_ROOT=/home/helixbot/dotnetbuild/work/1db3eb44-4841-48bb-9805-f82ba51aafc3/Payload
    &gt; /home/helixbot/dotnetbuild/work/1db3eb44-4841-48bb-9805-f82ba51aafc3/Work/23138be3-f67f-4f5c-9e8a-b6351b0f207f/Unzip/StructPacking/StructPacking.sh
    
    Expected: True
    Actual:   False

        Stack Trace:
```
        
Build : Master - 20180427.01 (Core Tests)
Failing configurations:
- redhat.69.amd64-x64
  - 

Details:
https://mc.dot.net/#/product/netcore/master/source/official~2Fcoreclr~2Fmaster~2F/type/test~2Ffunctional~2Fcli~2F/build/20180427.01/workItem/Interop.StructPacking.XUnitWrapper/analysis/xunit/Interop_StructPacking._StructPacking_StructPacking_~2F_StructPacking_StructPacking_cmd</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>27/04/2018 8:49:40 AM +00:00</CreatedAt>
    <ClosedAt>22/05/2019 6:09:35 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17809</IssueLabelID>
    <Title>Request safe non-allocation bit converter between value type and byte array</Title>
    <Description>I always face some needs like write some value type to a chunk of memory (and read back) byte by byte.
But there is no way to write a struct or struct array to an existing byte array for now except the unsafe pointer way.

Add APIs like below will be a big help:

public static void Write&lt; T &gt;(Span&lt; T &gt; elem Span&lt; byte &gt;)where T:struct
public static void Read&lt; T &gt;(Span&lt; T &gt; elem Span&lt; byte &gt;)where T:struct</Description>
    <Title_Description>Request safe non-allocation bit converter between value type and byte array I always face some needs like write some value type to a chunk of memory (and read back) byte by byte.
But there is no way to write a struct or struct array to an existing byte array for now except the unsafe pointer way.

Add APIs like below will be a big help:

public static void Write&lt; T &gt;(Span&lt; T &gt; elem Span&lt; byte &gt;)where T:struct
public static void Read&lt; T &gt;(Span&lt; T &gt; elem Span&lt; byte &gt;)where T:struct</Title_Description>
    <Label>area-System.Memory</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>27/04/2018 7:02:27 AM +00:00</CreatedAt>
    <ClosedAt>27/04/2018 12:44:32 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17807</IssueLabelID>
    <Title>Add runtimeconfig.json support for tiered compilation</Title>
    <Description>Previously this feature could only be enabled via COMPLUS_TieredCompilation variable. Now it can also be enabled from configProperties in the runtimeconfig.json.</Description>
    <Title_Description>Add runtimeconfig.json support for tiered compilation Previously this feature could only be enabled via COMPLUS_TieredCompilation variable. Now it can also be enabled from configProperties in the runtimeconfig.json.</Title_Description>
    <Label>area-TieredCompilation</Label>
    <Assignee>dotnet-bot</Assignee>
    <CreatedAt>27/04/2018 4:36:24 AM +00:00</CreatedAt>
    <ClosedAt>30/04/2018 8:40:48 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17805</IssueLabelID>
    <Title>Floating point formatting changed 2.0 -&gt; 2.1</Title>
    <Description>Repro:

```csharp
using System;

class Program
{
    static void Main(string[] args)
    {
        float value;
        float.TryParse("-122.1944580078135" out value);
        Console.WriteLine("Float test gives {0}" (double)value);
    }
}
```

.NET Core 2.0: -122.194458007813
.NET Core 2.1: -122.194458007812

Reported by @mjsabby @ Bing</Description>
    <Title_Description>Floating point formatting changed 2.0 -&gt; 2.1 Repro:

```csharp
using System;

class Program
{
    static void Main(string[] args)
    {
        float value;
        float.TryParse("-122.1944580078135" out value);
        Console.WriteLine("Float test gives {0}" (double)value);
    }
}
```

.NET Core 2.0: -122.194458007813
.NET Core 2.1: -122.194458007812

Reported by @mjsabby @ Bing</Title_Description>
    <Label>area-System.Runtime</Label>
    <Assignee>mjsabby</Assignee>
    <CreatedAt>27/04/2018 1:42:51 AM +00:00</CreatedAt>
    <ClosedAt>27/04/2018 5:24:01 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17804</IssueLabelID>
    <Title>Add better portable PDB caching to System.Diagnostics.StackTrace.</Title>
    <Description>This is the mscorlib/System.Private.CoreLib side of the change.</Description>
    <Title_Description>Add better portable PDB caching to System.Diagnostics.StackTrace. This is the mscorlib/System.Private.CoreLib side of the change.</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>mikem8361</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17801</IssueLabelID>
    <Title>[arm32] corefx System.Security.Cryptography.X509Certificates.Tests failures</Title>
    <Description>Windows/arm32 corefx System.Security.Cryptography.X509Certificates.Tests failure with COMPlus_JitStressRegs=0x1000 or COMPlus_JitStressRegs=3 or COMPlus_JitMinOpts=1

https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_corefx_jitstressregs0x1000_tst/12/consoleText
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_corefx_jitstressregs3_tst/12/consoleText
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_corefx_minopts_tst/11/consoleText

```
Running: C:\Users\robox\j\workspace\arm_cross_che---94625fe4\_\fx\bin\tests\System.Security.Cryptography.X509Certificates.Tests\netcoreapp-Windows_NT-Release-arm\RunTests.cmd C:\Users\robox\j\workspace\arm_cross_che---94625fe4\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm
Using C:\Users\robox\j\workspace\arm_cross_che---94625fe4\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm as the test runtime folder.
Executing in C:\Users\robox\j\workspace\arm_cross_che---94625fe4\_\fx\bin\tests\System.Security.Cryptography.X509Certificates.Tests\netcoreapp-Windows_NT-Release-arm\ 
----- start 13:25:56.69 ===============  To repro directly: ===================================================== 
pushd C:\Users\robox\j\workspace\arm_cross_che---94625fe4\_\fx\bin\tests\System.Security.Cryptography.X509Certificates.Tests\netcoreapp-Windows_NT-Release-arm\
set COMPlus_JitStressRegs=0x1000
call C:\Users\robox\j\workspace\arm_cross_che---94625fe4\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm\dotnet.exe xunit.console.netcore.exe System.Security.Cryptography.X509Certificates.Tests.dll  -xml testResults.xml -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonwindowstests  -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing
popd
===========================================================================================================

C:\Users\robox\j\workspace\arm_cross_che---94625fe4\_\fx\bin\tests\System.Security.Cryptography.X509Certificates.Tests\netcoreapp-Windows_NT-Release-arm&gt;set COMPlus_JitStressRegs=0x1000 

C:\Users\robox\j\workspace\arm_cross_che---94625fe4\_\fx\bin\tests\System.Security.Cryptography.X509Certificates.Tests\netcoreapp-Windows_NT-Release-arm&gt;call C:\Users\robox\j\workspace\arm_cross_che---94625fe4\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm\dotnet.exe xunit.console.netcore.exe System.Security.Cryptography.X509Certificates.Tests.dll  -xml testResults.xml -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonwindowstests  -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing 
xUnit.net console test runner (32-bit .NET Core)
Copyright (C) 2014 Outercurve Foundation.

Discovering: System.Security.Cryptography.X509Certificates.Tests
Discovered:  System.Security.Cryptography.X509Certificates.Tests
Starting:    System.Security.Cryptography.X509Certificates.Tests
   System.Security.Cryptography.X509Certificates.Tests.CertificateCreation.PrivateKeyAssociationTests.AssociatePersistedKey_CAPIviaCNG_DSA(provType: 3) [FAIL]
      Internal.Cryptography.CryptoThrowHelper+WindowsCryptographicException : Keyset as registered is invalid
      Stack Trace:
         D:\j\workspace\arm_cross_che---ab665b7f\_\fx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\CapiHelper.Windows.cs(2980): at Internal.NativeCrypto.CapiHelper.CreateProvHandle(CspParameters parameters Boolean randomKeyContainer)
         D:\j\workspace\arm_cross_che---ab665b7f\_\fx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\DSACryptoServiceProvider.Windows.cs(970): at System.Security.Cryptography.DSACryptoServiceProvider.get_SafeProvHandle()
         D:\j\workspace\arm_cross_che---ab665b7f\_\fx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\DSACryptoServiceProvider.Windows.cs(1460): at System.Security.Cryptography.DSACryptoServiceProvider.get_SafeKeyHandle()
         D:\j\workspace\arm_cross_che---ab665b7f\_\fx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\DSACryptoServiceProvider.Windows.cs(820): at System.Security.Cryptography.DSACryptoServiceProvider..ctor(Int32 dwKeySize CspParameters parameters)
         D:\j\workspace\arm_cross_che---ab665b7f\_\fx\src\System.Security.Cryptography.X509Certificates\tests\CertificateCreation\PrivateKeyAssociationTests.cs(3210): at System.Security.Cryptography.X509Certificates.Tests.CertificateCreation.PrivateKeyAssociationTests.AssociatePersistedKey_CAPIviaCNG_DSA(Int32 provType)
   System.Security.Cryptography.X509Certificates.Tests.CertificateCreation.PrivateKeyAssociationTests.AssociatePersistedKey_CAPIviaCNG_DSA(provType: 13) [FAIL]
      Internal.Cryptography.CryptoThrowHelper+WindowsCryptographicException : Keyset as registered is invalid
      Stack Trace:
         D:\j\workspace\arm_cross_che---ab665b7f\_\fx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\CapiHelper.Windows.cs(2980): at Internal.NativeCrypto.CapiHelper.CreateProvHandle(CspParameters parameters Boolean randomKeyContainer)
         D:\j\workspace\arm_cross_che---ab665b7f\_\fx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\DSACryptoServiceProvider.Windows.cs(970): at System.Security.Cryptography.DSACryptoServiceProvider.get_SafeProvHandle()
         D:\j\workspace\arm_cross_che---ab665b7f\_\fx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\DSACryptoServiceProvider.Windows.cs(1460): at System.Security.Cryptography.DSACryptoServiceProvider.get_SafeKeyHandle()
         D:\j\workspace\arm_cross_che---ab665b7f\_\fx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\DSACryptoServiceProvider.Windows.cs(820): at System.Security.Cryptography.DSACryptoServiceProvider..ctor(Int32 dwKeySize CspParameters parameters)
         D:\j\workspace\arm_cross_che---ab665b7f\_\fx\src\System.Security.Cryptography.X509Certificates\tests\CertificateCreation\PrivateKeyAssociationTests.cs(3210): at System.Security.Cryptography.X509Certificates.Tests.CertificateCreation.PrivateKeyAssociationTests.AssociatePersistedKey_CAPIviaCNG_DSA(Int32 provType)
Finished:    System.Security.Cryptography.X509Certificates.Tests

=== TEST EXECUTION SUMMARY ===
   System.Security.Cryptography.X509Certificates.Tests  Total: 762 Errors: 0 Failed: 2 Skipped: 0 Time: 10.467s
----- end 13:26:16.87 ----- exit code 1 ----------------------------------------------------------
COREFX TEST FAILED
```
</Description>
    <Title_Description>[arm32] corefx System.Security.Cryptography.X509Certificates.Tests failures Windows/arm32 corefx System.Security.Cryptography.X509Certificates.Tests failure with COMPlus_JitStressRegs=0x1000 or COMPlus_JitStressRegs=3 or COMPlus_JitMinOpts=1

https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_corefx_jitstressregs0x1000_tst/12/consoleText
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_corefx_jitstressregs3_tst/12/consoleText
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_corefx_minopts_tst/11/consoleText

```
Running: C:\Users\robox\j\workspace\arm_cross_che---94625fe4\_\fx\bin\tests\System.Security.Cryptography.X509Certificates.Tests\netcoreapp-Windows_NT-Release-arm\RunTests.cmd C:\Users\robox\j\workspace\arm_cross_che---94625fe4\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm
Using C:\Users\robox\j\workspace\arm_cross_che---94625fe4\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm as the test runtime folder.
Executing in C:\Users\robox\j\workspace\arm_cross_che---94625fe4\_\fx\bin\tests\System.Security.Cryptography.X509Certificates.Tests\netcoreapp-Windows_NT-Release-arm\ 
----- start 13:25:56.69 ===============  To repro directly: ===================================================== 
pushd C:\Users\robox\j\workspace\arm_cross_che---94625fe4\_\fx\bin\tests\System.Security.Cryptography.X509Certificates.Tests\netcoreapp-Windows_NT-Release-arm\
set COMPlus_JitStressRegs=0x1000
call C:\Users\robox\j\workspace\arm_cross_che---94625fe4\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm\dotnet.exe xunit.console.netcore.exe System.Security.Cryptography.X509Certificates.Tests.dll  -xml testResults.xml -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonwindowstests  -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing
popd
===========================================================================================================

C:\Users\robox\j\workspace\arm_cross_che---94625fe4\_\fx\bin\tests\System.Security.Cryptography.X509Certificates.Tests\netcoreapp-Windows_NT-Release-arm&gt;set COMPlus_JitStressRegs=0x1000 

C:\Users\robox\j\workspace\arm_cross_che---94625fe4\_\fx\bin\tests\System.Security.Cryptography.X509Certificates.Tests\netcoreapp-Windows_NT-Release-arm&gt;call C:\Users\robox\j\workspace\arm_cross_che---94625fe4\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm\dotnet.exe xunit.console.netcore.exe System.Security.Cryptography.X509Certificates.Tests.dll  -xml testResults.xml -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonwindowstests  -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing 
xUnit.net console test runner (32-bit .NET Core)
Copyright (C) 2014 Outercurve Foundation.

Discovering: System.Security.Cryptography.X509Certificates.Tests
Discovered:  System.Security.Cryptography.X509Certificates.Tests
Starting:    System.Security.Cryptography.X509Certificates.Tests
   System.Security.Cryptography.X509Certificates.Tests.CertificateCreation.PrivateKeyAssociationTests.AssociatePersistedKey_CAPIviaCNG_DSA(provType: 3) [FAIL]
      Internal.Cryptography.CryptoThrowHelper+WindowsCryptographicException : Keyset as registered is invalid
      Stack Trace:
         D:\j\workspace\arm_cross_che---ab665b7f\_\fx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\CapiHelper.Windows.cs(2980): at Internal.NativeCrypto.CapiHelper.CreateProvHandle(CspParameters parameters Boolean randomKeyContainer)
         D:\j\workspace\arm_cross_che---ab665b7f\_\fx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\DSACryptoServiceProvider.Windows.cs(970): at System.Security.Cryptography.DSACryptoServiceProvider.get_SafeProvHandle()
         D:\j\workspace\arm_cross_che---ab665b7f\_\fx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\DSACryptoServiceProvider.Windows.cs(1460): at System.Security.Cryptography.DSACryptoServiceProvider.get_SafeKeyHandle()
         D:\j\workspace\arm_cross_che---ab665b7f\_\fx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\DSACryptoServiceProvider.Windows.cs(820): at System.Security.Cryptography.DSACryptoServiceProvider..ctor(Int32 dwKeySize CspParameters parameters)
         D:\j\workspace\arm_cross_che---ab665b7f\_\fx\src\System.Security.Cryptography.X509Certificates\tests\CertificateCreation\PrivateKeyAssociationTests.cs(3210): at System.Security.Cryptography.X509Certificates.Tests.CertificateCreation.PrivateKeyAssociationTests.AssociatePersistedKey_CAPIviaCNG_DSA(Int32 provType)
   System.Security.Cryptography.X509Certificates.Tests.CertificateCreation.PrivateKeyAssociationTests.AssociatePersistedKey_CAPIviaCNG_DSA(provType: 13) [FAIL]
      Internal.Cryptography.CryptoThrowHelper+WindowsCryptographicException : Keyset as registered is invalid
      Stack Trace:
         D:\j\workspace\arm_cross_che---ab665b7f\_\fx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\CapiHelper.Windows.cs(2980): at Internal.NativeCrypto.CapiHelper.CreateProvHandle(CspParameters parameters Boolean randomKeyContainer)
         D:\j\workspace\arm_cross_che---ab665b7f\_\fx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\DSACryptoServiceProvider.Windows.cs(970): at System.Security.Cryptography.DSACryptoServiceProvider.get_SafeProvHandle()
         D:\j\workspace\arm_cross_che---ab665b7f\_\fx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\DSACryptoServiceProvider.Windows.cs(1460): at System.Security.Cryptography.DSACryptoServiceProvider.get_SafeKeyHandle()
         D:\j\workspace\arm_cross_che---ab665b7f\_\fx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\DSACryptoServiceProvider.Windows.cs(820): at System.Security.Cryptography.DSACryptoServiceProvider..ctor(Int32 dwKeySize CspParameters parameters)
         D:\j\workspace\arm_cross_che---ab665b7f\_\fx\src\System.Security.Cryptography.X509Certificates\tests\CertificateCreation\PrivateKeyAssociationTests.cs(3210): at System.Security.Cryptography.X509Certificates.Tests.CertificateCreation.PrivateKeyAssociationTests.AssociatePersistedKey_CAPIviaCNG_DSA(Int32 provType)
Finished:    System.Security.Cryptography.X509Certificates.Tests

=== TEST EXECUTION SUMMARY ===
   System.Security.Cryptography.X509Certificates.Tests  Total: 762 Errors: 0 Failed: 2 Skipped: 0 Time: 10.467s
----- end 13:26:16.87 ----- exit code 1 ----------------------------------------------------------
COREFX TEST FAILED
```
</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>echesakovMSFT</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17800</IssueLabelID>
    <Title>[WIP] Move Concurrent collections into shared</Title>
    <Description>cc: @safern @danmosemsft @jkotas 

corefx PR: dotnet/corefx#29356

Fixes coreclr issue: #17751 </Description>
    <Title_Description>[WIP] Move Concurrent collections into shared cc: @safern @danmosemsft @jkotas 

corefx PR: dotnet/corefx#29356

Fixes coreclr issue: #17751 </Title_Description>
    <Label>area-System.Collections</Label>
    <Assignee>maryamariyan</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17799</IssueLabelID>
    <Title>[arm32] corefx System.Diagnostics.PerformanceCounter.Tests failure</Title>
    <Description>arm32/Windows corefx test System.Diagnostics.PerformanceCounter.Tests fails:

https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_corefx_baseline_tst/14/consoleText

```
Running: C:\Users\robox\j\workspace\arm_cross_che---eb7b805d\_\fx\bin\tests\System.Diagnostics.PerformanceCounter.Tests\netcoreapp-Windows_NT-Release-arm\RunTests.cmd C:\Users\robox\j\workspace\arm_cross_che---eb7b805d\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm
Using C:\Users\robox\j\workspace\arm_cross_che---eb7b805d\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm as the test runtime folder.
Executing in C:\Users\robox\j\workspace\arm_cross_che---eb7b805d\_\fx\bin\tests\System.Diagnostics.PerformanceCounter.Tests\netcoreapp-Windows_NT-Release-arm\ 
----- start  4:55:44.36 ===============  To repro directly: ===================================================== 
pushd C:\Users\robox\j\workspace\arm_cross_che---eb7b805d\_\fx\bin\tests\System.Diagnostics.PerformanceCounter.Tests\netcoreapp-Windows_NT-Release-arm\
call C:\Users\robox\j\workspace\arm_cross_che---eb7b805d\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm\dotnet.exe xunit.console.netcore.exe System.Diagnostics.PerformanceCounter.Tests.dll  -xml testResults.xml -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonwindowstests  -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing
popd
===========================================================================================================

C:\Users\robox\j\workspace\arm_cross_che---eb7b805d\_\fx\bin\tests\System.Diagnostics.PerformanceCounter.Tests\netcoreapp-Windows_NT-Release-arm&gt;call C:\Users\robox\j\workspace\arm_cross_che---eb7b805d\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm\dotnet.exe xunit.console.netcore.exe System.Diagnostics.PerformanceCounter.Tests.dll  -xml testResults.xml -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonwindowstests  -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing 
xUnit.net console test runner (32-bit .NET Core)
Copyright (C) 2014 Outercurve Foundation.

Discovering: System.Diagnostics.PerformanceCounter.Tests
Discovered:  System.Diagnostics.PerformanceCounter.Tests
Starting:    System.Diagnostics.PerformanceCounter.Tests
   System.Diagnostics.Tests.CounterSampleCalculatorTests.CounterSampleCalculator_ElapsedTime [FAIL]
      Assert.NotEqual() Failure
      Expected: Not 0
      Actual:   0
      Stack Trace:
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\tests\Helpers.cs(740): at System.Diagnostics.Tests.Helpers.RetryOnAllPlatforms[T](Func`1 func)
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\tests\CounterSampleCalculatorTests.cs(240): at System.Diagnostics.Tests.CounterSampleCalculatorTests.CounterSampleCalculator_ElapsedTime()
   System.Diagnostics.Tests.CounterSampleTests.CounterSample_Calculate_CalculateCounterSampleCounterSample [FAIL]
      System.ComponentModel.Win32Exception : The specified module could not be found
      Stack Trace:
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\src\System\Diagnostics\CounterSampleCalculator.cs(2420): at System.Diagnostics.CounterSampleCalculator.LoadPerfCounterDll()
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\src\System\Diagnostics\CounterSampleCalculator.cs(930): at System.Diagnostics.CounterSampleCalculator.ComputeCounterValue(CounterSample oldSample CounterSample newSample)
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\tests\CounterSampleTests.cs(580): at System.Diagnostics.Tests.CounterSampleTests.CounterSample_Calculate_CalculateCounterSampleCounterSample()
   System.Diagnostics.Tests.CounterSampleTests.CounterSample_Calculate_CalculateCounterSample [FAIL]
      System.ComponentModel.Win32Exception : The specified module could not be found
      Stack Trace:
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\src\System\Diagnostics\CounterSampleCalculator.cs(2420): at System.Diagnostics.CounterSampleCalculator.LoadPerfCounterDll()
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\src\System\Diagnostics\CounterSampleCalculator.cs(930): at System.Diagnostics.CounterSampleCalculator.ComputeCounterValue(CounterSample oldSample CounterSample newSample)
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\src\System\Diagnostics\CounterSampleCalculator.cs(560): at System.Diagnostics.CounterSampleCalculator.ComputeCounterValue(CounterSample newSample)
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\tests\CounterSampleTests.cs(490): at System.Diagnostics.Tests.CounterSampleTests.CounterSample_Calculate_CalculateCounterSample()
   System.Diagnostics.Tests.PerformanceCounterCategoryTests.PerformanceCounterCategory_CategoryType_MultiInstance [FAIL]
      Assert.NotEqual() Failure
      Expected: Not 0
      Actual:   0
      Stack Trace:
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\tests\Helpers.cs(740): at System.Diagnostics.Tests.Helpers.RetryOnAllPlatforms[T](Func`1 func)
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\tests\PerformanceCounterCategoryTests.cs(910): at System.Diagnostics.Tests.PerformanceCounterCategoryTests.PerformanceCounterCategory_CategoryType_MultiInstance()
   System.Diagnostics.Tests.PerformanceCounterCategoryTests.PerformanceCounterCategory_GetCounters [FAIL]
      System.InvalidOperationException : Category does not exist.
      Stack Trace:
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\src\System\Diagnostics\PerformanceCounterLib.cs(8200): at System.Diagnostics.PerformanceCounterLib.GetCategorySample(String machine String category)
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\src\System\Diagnostics\PerformanceCounterCategory.cs(4430): at System.Diagnostics.PerformanceCounterCategory.GetCounterInstances(String categoryName String machineName)
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\src\System\Diagnostics\PerformanceCounterCategory.cs(5170): at System.Diagnostics.PerformanceCounterCategory.GetInstanceNames()
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\src\System\Diagnostics\PerformanceCounterCategory.cs(4600): at System.Diagnostics.PerformanceCounterCategory.GetCounters()
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\tests\PerformanceCounterCategoryTests.cs(2340): at System.Diagnostics.Tests.PerformanceCounterCategoryTests.PerformanceCounterCategory_GetCounters()
   System.Diagnostics.Tests.PerformanceCounterCategoryTests.PerformanceCounterCategory_CategoryType_SingleInstance [FAIL]
      Assert.NotEqual() Failure
      Expected: Not 0
      Actual:   0
      Stack Trace:
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\tests\Helpers.cs(740): at System.Diagnostics.Tests.Helpers.RetryOnAllPlatforms[T](Func`1 func)
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\tests\PerformanceCounterCategoryTests.cs(1040): at System.Diagnostics.Tests.PerformanceCounterCategoryTests.PerformanceCounterCategory_CategoryType_SingleInstance()
   System.Diagnostics.Tests.PerformanceCounterTests.PerformanceCounter_Decrement_DecrementReadOnly [FAIL]
      Assert.NotEqual() Failure
      Expected: Not 0
      Actual:   0
      Stack Trace:
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\tests\Helpers.cs(740): at System.Diagnostics.Tests.Helpers.RetryOnAllPlatforms[T](Func`1 func)
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\tests\PerformanceCounterTests.cs(2960): at System.Diagnostics.Tests.PerformanceCounterTests.CreateCounterWithCategory(String name Boolean readOnly PerformanceCounterCategoryType categoryType)
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\tests\PerformanceCounterTests.cs(2510): at System.Diagnostics.Tests.PerformanceCounterTests.PerformanceCounter_Decrement_DecrementReadOnly()
   System.Diagnostics.Tests.PerformanceCounterTests.PerformanceCounter_NextValue_ProcessorCounter [FAIL]
      System.ComponentModel.Win32Exception : The specified module could not be found
      Stack Trace:
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\src\System\Diagnostics\CounterSampleCalculator.cs(2420): at System.Diagnostics.CounterSampleCalculator.LoadPerfCounterDll()
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\src\System\Diagnostics\CounterSampleCalculator.cs(930): at System.Diagnostics.CounterSampleCalculator.ComputeCounterValue(CounterSample oldSample CounterSample newSample)
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\src\System\Diagnostics\PerformanceCounter.cs(5750): at System.Diagnostics.PerformanceCounter.NextValue()
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\tests\PerformanceCounterTests.cs(1560): at System.Diagnostics.Tests.PerformanceCounterTests.&lt;&gt;c__DisplayClass10_0.&lt;PerformanceCounter_NextValue_ProcessorCounter&gt;b__1()
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\tests\Helpers.cs(590): at System.Diagnostics.Tests.Helpers.RetryOnAllPlatforms[T](Func`1 func)
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\tests\PerformanceCounterTests.cs(1560): at System.Diagnostics.Tests.PerformanceCounterTests.PerformanceCounter_NextValue_ProcessorCounter()
   System.Diagnostics.Tests.PerformanceCounterTests.PerformanceCounter_Increment [FAIL]
      Assert.NotEqual() Failure
      Expected: Not 0
      Actual:   0
      Stack Trace:
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\tests\Helpers.cs(740): at System.Diagnostics.Tests.Helpers.RetryOnAllPlatforms[T](Func`1 func)
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\tests\PerformanceCounterTests.cs(2060): at System.Diagnostics.Tests.PerformanceCounterTests.PerformanceCounter_Increment()
   System.Diagnostics.Tests.PerformanceCounterTests.PerformanceCounter_Increment_IncrementReadOnly [FAIL]
      Assert.NotEqual() Failure
      Expected: Not 0
      Actual:   0
      Stack Trace:
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\tests\Helpers.cs(740): at System.Diagnostics.Tests.Helpers.RetryOnAllPlatforms[T](Func`1 func)
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\tests\PerformanceCounterTests.cs(2960): at System.Diagnostics.Tests.PerformanceCounterTests.CreateCounterWithCategory(String name Boolean readOnly PerformanceCounterCategoryType categoryType)
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\tests\PerformanceCounterTests.cs(2400): at System.Diagnostics.Tests.PerformanceCounterTests.PerformanceCounter_Increment_IncrementReadOnly()
   System.Diagnostics.Tests.PerformanceCounterTests.PerformanceCounter_CreateCounter_SetReadOnly [FAIL]
      Assert.NotEqual() Failure
      Expected: Not 0
      Actual:   0
      Stack Trace:
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\tests\Helpers.cs(740): at System.Diagnostics.Tests.Helpers.RetryOnAllPlatforms[T](Func`1 func)
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\tests\PerformanceCounterTests.cs(780): at System.Diagnostics.Tests.PerformanceCounterTests.PerformanceCounter_CreateCounter_SetReadOnly()
   System.Diagnostics.Tests.PerformanceCounterTests.PerformanceCounter_CreateCounter_MultiInstanceReadOnly [FAIL]
      Assert.NotEqual() Failure
      Expected: Not 0
      Actual:   0
      Stack Trace:
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\tests\Helpers.cs(740): at System.Diagnostics.Tests.Helpers.RetryOnAllPlatforms[T](Func`1 func)
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\tests\PerformanceCounterTests.cs(600): at System.Diagnostics.Tests.PerformanceCounterTests.PerformanceCounter_CreateCounter_MultiInstanceReadOnly()
Finished:    System.Diagnostics.PerformanceCounter.Tests

=== TEST EXECUTION SUMMARY ===
   System.Diagnostics.PerformanceCounter.Tests  Total: 81 Errors: 0 Failed: 12 Skipped: 0 Time: 35.242s
----- end  4:56:24.56 ----- exit code 1 ----------------------------------------------------------
COREFX TEST FAILED
```</Description>
    <Title_Description>[arm32] corefx System.Diagnostics.PerformanceCounter.Tests failure arm32/Windows corefx test System.Diagnostics.PerformanceCounter.Tests fails:

https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_corefx_baseline_tst/14/consoleText

```
Running: C:\Users\robox\j\workspace\arm_cross_che---eb7b805d\_\fx\bin\tests\System.Diagnostics.PerformanceCounter.Tests\netcoreapp-Windows_NT-Release-arm\RunTests.cmd C:\Users\robox\j\workspace\arm_cross_che---eb7b805d\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm
Using C:\Users\robox\j\workspace\arm_cross_che---eb7b805d\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm as the test runtime folder.
Executing in C:\Users\robox\j\workspace\arm_cross_che---eb7b805d\_\fx\bin\tests\System.Diagnostics.PerformanceCounter.Tests\netcoreapp-Windows_NT-Release-arm\ 
----- start  4:55:44.36 ===============  To repro directly: ===================================================== 
pushd C:\Users\robox\j\workspace\arm_cross_che---eb7b805d\_\fx\bin\tests\System.Diagnostics.PerformanceCounter.Tests\netcoreapp-Windows_NT-Release-arm\
call C:\Users\robox\j\workspace\arm_cross_che---eb7b805d\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm\dotnet.exe xunit.console.netcore.exe System.Diagnostics.PerformanceCounter.Tests.dll  -xml testResults.xml -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonwindowstests  -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing
popd
===========================================================================================================

C:\Users\robox\j\workspace\arm_cross_che---eb7b805d\_\fx\bin\tests\System.Diagnostics.PerformanceCounter.Tests\netcoreapp-Windows_NT-Release-arm&gt;call C:\Users\robox\j\workspace\arm_cross_che---eb7b805d\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm\dotnet.exe xunit.console.netcore.exe System.Diagnostics.PerformanceCounter.Tests.dll  -xml testResults.xml -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonwindowstests  -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing 
xUnit.net console test runner (32-bit .NET Core)
Copyright (C) 2014 Outercurve Foundation.

Discovering: System.Diagnostics.PerformanceCounter.Tests
Discovered:  System.Diagnostics.PerformanceCounter.Tests
Starting:    System.Diagnostics.PerformanceCounter.Tests
   System.Diagnostics.Tests.CounterSampleCalculatorTests.CounterSampleCalculator_ElapsedTime [FAIL]
      Assert.NotEqual() Failure
      Expected: Not 0
      Actual:   0
      Stack Trace:
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\tests\Helpers.cs(740): at System.Diagnostics.Tests.Helpers.RetryOnAllPlatforms[T](Func`1 func)
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\tests\CounterSampleCalculatorTests.cs(240): at System.Diagnostics.Tests.CounterSampleCalculatorTests.CounterSampleCalculator_ElapsedTime()
   System.Diagnostics.Tests.CounterSampleTests.CounterSample_Calculate_CalculateCounterSampleCounterSample [FAIL]
      System.ComponentModel.Win32Exception : The specified module could not be found
      Stack Trace:
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\src\System\Diagnostics\CounterSampleCalculator.cs(2420): at System.Diagnostics.CounterSampleCalculator.LoadPerfCounterDll()
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\src\System\Diagnostics\CounterSampleCalculator.cs(930): at System.Diagnostics.CounterSampleCalculator.ComputeCounterValue(CounterSample oldSample CounterSample newSample)
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\tests\CounterSampleTests.cs(580): at System.Diagnostics.Tests.CounterSampleTests.CounterSample_Calculate_CalculateCounterSampleCounterSample()
   System.Diagnostics.Tests.CounterSampleTests.CounterSample_Calculate_CalculateCounterSample [FAIL]
      System.ComponentModel.Win32Exception : The specified module could not be found
      Stack Trace:
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\src\System\Diagnostics\CounterSampleCalculator.cs(2420): at System.Diagnostics.CounterSampleCalculator.LoadPerfCounterDll()
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\src\System\Diagnostics\CounterSampleCalculator.cs(930): at System.Diagnostics.CounterSampleCalculator.ComputeCounterValue(CounterSample oldSample CounterSample newSample)
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\src\System\Diagnostics\CounterSampleCalculator.cs(560): at System.Diagnostics.CounterSampleCalculator.ComputeCounterValue(CounterSample newSample)
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\tests\CounterSampleTests.cs(490): at System.Diagnostics.Tests.CounterSampleTests.CounterSample_Calculate_CalculateCounterSample()
   System.Diagnostics.Tests.PerformanceCounterCategoryTests.PerformanceCounterCategory_CategoryType_MultiInstance [FAIL]
      Assert.NotEqual() Failure
      Expected: Not 0
      Actual:   0
      Stack Trace:
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\tests\Helpers.cs(740): at System.Diagnostics.Tests.Helpers.RetryOnAllPlatforms[T](Func`1 func)
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\tests\PerformanceCounterCategoryTests.cs(910): at System.Diagnostics.Tests.PerformanceCounterCategoryTests.PerformanceCounterCategory_CategoryType_MultiInstance()
   System.Diagnostics.Tests.PerformanceCounterCategoryTests.PerformanceCounterCategory_GetCounters [FAIL]
      System.InvalidOperationException : Category does not exist.
      Stack Trace:
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\src\System\Diagnostics\PerformanceCounterLib.cs(8200): at System.Diagnostics.PerformanceCounterLib.GetCategorySample(String machine String category)
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\src\System\Diagnostics\PerformanceCounterCategory.cs(4430): at System.Diagnostics.PerformanceCounterCategory.GetCounterInstances(String categoryName String machineName)
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\src\System\Diagnostics\PerformanceCounterCategory.cs(5170): at System.Diagnostics.PerformanceCounterCategory.GetInstanceNames()
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\src\System\Diagnostics\PerformanceCounterCategory.cs(4600): at System.Diagnostics.PerformanceCounterCategory.GetCounters()
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\tests\PerformanceCounterCategoryTests.cs(2340): at System.Diagnostics.Tests.PerformanceCounterCategoryTests.PerformanceCounterCategory_GetCounters()
   System.Diagnostics.Tests.PerformanceCounterCategoryTests.PerformanceCounterCategory_CategoryType_SingleInstance [FAIL]
      Assert.NotEqual() Failure
      Expected: Not 0
      Actual:   0
      Stack Trace:
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\tests\Helpers.cs(740): at System.Diagnostics.Tests.Helpers.RetryOnAllPlatforms[T](Func`1 func)
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\tests\PerformanceCounterCategoryTests.cs(1040): at System.Diagnostics.Tests.PerformanceCounterCategoryTests.PerformanceCounterCategory_CategoryType_SingleInstance()
   System.Diagnostics.Tests.PerformanceCounterTests.PerformanceCounter_Decrement_DecrementReadOnly [FAIL]
      Assert.NotEqual() Failure
      Expected: Not 0
      Actual:   0
      Stack Trace:
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\tests\Helpers.cs(740): at System.Diagnostics.Tests.Helpers.RetryOnAllPlatforms[T](Func`1 func)
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\tests\PerformanceCounterTests.cs(2960): at System.Diagnostics.Tests.PerformanceCounterTests.CreateCounterWithCategory(String name Boolean readOnly PerformanceCounterCategoryType categoryType)
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\tests\PerformanceCounterTests.cs(2510): at System.Diagnostics.Tests.PerformanceCounterTests.PerformanceCounter_Decrement_DecrementReadOnly()
   System.Diagnostics.Tests.PerformanceCounterTests.PerformanceCounter_NextValue_ProcessorCounter [FAIL]
      System.ComponentModel.Win32Exception : The specified module could not be found
      Stack Trace:
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\src\System\Diagnostics\CounterSampleCalculator.cs(2420): at System.Diagnostics.CounterSampleCalculator.LoadPerfCounterDll()
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\src\System\Diagnostics\CounterSampleCalculator.cs(930): at System.Diagnostics.CounterSampleCalculator.ComputeCounterValue(CounterSample oldSample CounterSample newSample)
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\src\System\Diagnostics\PerformanceCounter.cs(5750): at System.Diagnostics.PerformanceCounter.NextValue()
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\tests\PerformanceCounterTests.cs(1560): at System.Diagnostics.Tests.PerformanceCounterTests.&lt;&gt;c__DisplayClass10_0.&lt;PerformanceCounter_NextValue_ProcessorCounter&gt;b__1()
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\tests\Helpers.cs(590): at System.Diagnostics.Tests.Helpers.RetryOnAllPlatforms[T](Func`1 func)
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\tests\PerformanceCounterTests.cs(1560): at System.Diagnostics.Tests.PerformanceCounterTests.PerformanceCounter_NextValue_ProcessorCounter()
   System.Diagnostics.Tests.PerformanceCounterTests.PerformanceCounter_Increment [FAIL]
      Assert.NotEqual() Failure
      Expected: Not 0
      Actual:   0
      Stack Trace:
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\tests\Helpers.cs(740): at System.Diagnostics.Tests.Helpers.RetryOnAllPlatforms[T](Func`1 func)
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\tests\PerformanceCounterTests.cs(2060): at System.Diagnostics.Tests.PerformanceCounterTests.PerformanceCounter_Increment()
   System.Diagnostics.Tests.PerformanceCounterTests.PerformanceCounter_Increment_IncrementReadOnly [FAIL]
      Assert.NotEqual() Failure
      Expected: Not 0
      Actual:   0
      Stack Trace:
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\tests\Helpers.cs(740): at System.Diagnostics.Tests.Helpers.RetryOnAllPlatforms[T](Func`1 func)
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\tests\PerformanceCounterTests.cs(2960): at System.Diagnostics.Tests.PerformanceCounterTests.CreateCounterWithCategory(String name Boolean readOnly PerformanceCounterCategoryType categoryType)
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\tests\PerformanceCounterTests.cs(2400): at System.Diagnostics.Tests.PerformanceCounterTests.PerformanceCounter_Increment_IncrementReadOnly()
   System.Diagnostics.Tests.PerformanceCounterTests.PerformanceCounter_CreateCounter_SetReadOnly [FAIL]
      Assert.NotEqual() Failure
      Expected: Not 0
      Actual:   0
      Stack Trace:
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\tests\Helpers.cs(740): at System.Diagnostics.Tests.Helpers.RetryOnAllPlatforms[T](Func`1 func)
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\tests\PerformanceCounterTests.cs(780): at System.Diagnostics.Tests.PerformanceCounterTests.PerformanceCounter_CreateCounter_SetReadOnly()
   System.Diagnostics.Tests.PerformanceCounterTests.PerformanceCounter_CreateCounter_MultiInstanceReadOnly [FAIL]
      Assert.NotEqual() Failure
      Expected: Not 0
      Actual:   0
      Stack Trace:
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\tests\Helpers.cs(740): at System.Diagnostics.Tests.Helpers.RetryOnAllPlatforms[T](Func`1 func)
         D:\j\workspace\arm_cross_che---99792267\_\fx\src\System.Diagnostics.PerformanceCounter\tests\PerformanceCounterTests.cs(600): at System.Diagnostics.Tests.PerformanceCounterTests.PerformanceCounter_CreateCounter_MultiInstanceReadOnly()
Finished:    System.Diagnostics.PerformanceCounter.Tests

=== TEST EXECUTION SUMMARY ===
   System.Diagnostics.PerformanceCounter.Tests  Total: 81 Errors: 0 Failed: 12 Skipped: 0 Time: 35.242s
----- end  4:56:24.56 ----- exit code 1 ----------------------------------------------------------
COREFX TEST FAILED
```</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>26/04/2018 11:08:42 PM +00:00</CreatedAt>
    <ClosedAt>27/04/2018 7:51:30 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17798</IssueLabelID>
    <Title>Port RayTracer benchmark to SoA algorithm using Vector128/256&lt;T&gt;</Title>
    <Description>The current SIMD benchmark [RayTracer](https://github.com/dotnet/coreclr/tree/master/tests/src/JIT/Performance/CodeQuality/SIMD/RayTracer) is using `Vector3` to vectorize the basic 3D vector operations. However this program is an AoS algorithm that cannot leverage wider SIMD operations. So we should port RayTracer to a SoA algorithm using AVX intrinsics with `Vector256&lt;T&gt;` then extend it to SSE* intrinsic with `Vector128&lt;T&gt;`.

cc @CarolEidt @tannergooding @AndyAyersMS @jkotas 
</Description>
    <Title_Description>Port RayTracer benchmark to SoA algorithm using Vector128/256&lt;T&gt; The current SIMD benchmark [RayTracer](https://github.com/dotnet/coreclr/tree/master/tests/src/JIT/Performance/CodeQuality/SIMD/RayTracer) is using `Vector3` to vectorize the basic 3D vector operations. However this program is an AoS algorithm that cannot leverage wider SIMD operations. So we should port RayTracer to a SoA algorithm using AVX intrinsics with `Vector256&lt;T&gt;` then extend it to SSE* intrinsic with `Vector128&lt;T&gt;`.

cc @CarolEidt @tannergooding @AndyAyersMS @jkotas 
</Title_Description>
    <Label>arch-x64</Label>
    <Assignee>fiigii</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17797</IssueLabelID>
    <Title>RyuJIT: Add side effect flag checking to LIR::Range::CheckLIR()</Title>
    <Description>We check for correctness of side effect flags in fgDebugCheckFlags. We should do that for LIR as well in LIR::Range::CheckLIR().

There is a fundamental difference between side-effects in HIR and LIR in that the flags on a node do not need to be a summary of that node's side effects along with those of its operands: instead the flags for a node should reflect only that node's side effects.

category:correctness
theme:ir
skill-level:intermediate
cost:medium</Description>
    <Title_Description>RyuJIT: Add side effect flag checking to LIR::Range::CheckLIR() We check for correctness of side effect flags in fgDebugCheckFlags. We should do that for LIR as well in LIR::Range::CheckLIR().

There is a fundamental difference between side-effects in HIR and LIR in that the flags on a node do not need to be a summary of that node's side effects along with those of its operands: instead the flags for a node should reflect only that node's side effects.

category:correctness
theme:ir
skill-level:intermediate
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>erozenfeld</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17796</IssueLabelID>
    <Title>RyuJIT: Improve checking of GTF_ORDER_SIDEEFF flags</Title>
    <Description>#13668 enabled strict checking of GTF_EXCEPT and GTF_ASG flags in fgDebugCheckFlags.
The same should be done for GTF_ORDER_SIDEEFF flags.

category:correctness
theme:ir
skill-level:intermediate
cost:medium</Description>
    <Title_Description>RyuJIT: Improve checking of GTF_ORDER_SIDEEFF flags #13668 enabled strict checking of GTF_EXCEPT and GTF_ASG flags in fgDebugCheckFlags.
The same should be done for GTF_ORDER_SIDEEFF flags.

category:correctness
theme:ir
skill-level:intermediate
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>erozenfeld</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17795</IssueLabelID>
    <Title>RyuJIT: Improve checking of GTF_GLOB_REF flags</Title>
    <Description>#13668 enabled strict checking of GTF_EXCEPT and GTF_ASG flags in fgDebugCheckFlags.
The same should be done for GTF_GLOB_REF flags.

category:correctness
theme:ir
skill-level:intermediate
cost:medium</Description>
    <Title_Description>RyuJIT: Improve checking of GTF_GLOB_REF flags #13668 enabled strict checking of GTF_EXCEPT and GTF_ASG flags in fgDebugCheckFlags.
The same should be done for GTF_GLOB_REF flags.

category:correctness
theme:ir
skill-level:intermediate
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>erozenfeld</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17794</IssueLabelID>
    <Title>RyuJIT: Improve checking of GTF_CALL flag</Title>
    <Description>#13668 enabled strict checking of GTF_EXCEPT and GTF_ASG flags in fgDebugCheckFlags.
The same should be done for GTF_CALL flags.
</Description>
    <Title_Description>RyuJIT: Improve checking of GTF_CALL flag #13668 enabled strict checking of GTF_EXCEPT and GTF_ASG flags in fgDebugCheckFlags.
The same should be done for GTF_CALL flags.
</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>erozenfeld</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17790</IssueLabelID>
    <Title>ICLRRuntimeHost2，is it multithread  safe？</Title>
    <Description>ICLRRuntimeHost2，is it multithread  safe？
thank you</Description>
    <Title_Description>ICLRRuntimeHost2，is it multithread  safe？ ICLRRuntimeHost2，is it multithread  safe？
thank you</Title_Description>
    <Label>question</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>26/04/2018 1:03:47 PM +00:00</CreatedAt>
    <ClosedAt>27/04/2018 12:35:51 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17789</IssueLabelID>
    <Title>[local gc] fix com interop issues on local gc</Title>
    <Description>See https://github.com/dotnet/coreclr/blob/54bdc1681c08cf9230561733d4728bc13cbc494e/src/gc/objecthandle.cpp#L451-L467 </Description>
    <Title_Description>[local gc] fix com interop issues on local gc See https://github.com/dotnet/coreclr/blob/54bdc1681c08cf9230561733d4728bc13cbc494e/src/gc/objecthandle.cpp#L451-L467 </Title_Description>
    <Label>area-GC</Label>
    <Assignee>davmason</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17787</IssueLabelID>
    <Title>AF: WaitAll for multiple handles on a STA thread</Title>
    <Description>Example:
```
Z:\bin\tests\System.Runtime.Tests\netcoreapp-Windows_NT-Release-arm&gt;call Z:\bin\testhost\netcoreapp-Windows_NT-Release-arm\dotnet.exe xunit.console.netcore.exe System.Runtime.Tests.dll -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonwindowstests  -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing -showprogress -parallel none
xUnit.net console test runner (32-bit .NET Core)
***
 System.Tests.TypedReferenceTests.NegativeMakeTypedReference [FAIL]
      Assert.Equal() Failure
      Expected: (null)
      Actual:   flds
      Stack Trace:
         F:\git\corefx\src\CoreFx.Private.TestUtilities\src\System\AssertExtensions.cs(480): at System.AssertExtensions.Throws[T](String paramName Action action)
         F:\git\corefx\src\System.Runtime\tests\System\TypedReferenceTests.cs(600): at System.Tests.TypedReferenceTests.NegativeMakeTypedReference()

Assert failure(PID 5560 [0x000015b8] Thread: 11680 [0x2da0]): (ret != WAIT_TIMEOUT) || (millis != INFINITE)

&lt;no module&gt;! &lt;no symbol&gt; + 0x0 (0x00000000)
    File: c:\git\coreclr\src\vm\threads.cpp Line: 3778
    Image: Z:\bin\testhost\netcoreapp-Windows_NT-Release-arm\dotnet.exe
```

or on x64:
```
F:\git\corefx\bin\tests\System.Runtime.Tests\netcoreapp-Windows_NT-Release-x64&gt;F:\git\corefx\bin\runtime\netcoreapp-Windows_NT-Release-x64\CoreRun.exe xunit.console.netcore.exe System.Runtime.Tests.dll -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonwindowstests  -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing -parallel none
xUnit.net console test runner (64-bit .NET Core)
Copyright (C) 2014 Outercurve Foundation.

Discovering: System.Runtime.Tests
Discovered:  System.Runtime.Tests
Starting:    System.Runtime.Tests
   System.Tests.TypedReferenceTests.NegativeMakeTypedReference [FAIL]
      Assert.Equal() Failure
      Expected: (null)
      Actual:   flds
      Stack Trace:
         F:\git\corefx\src\CoreFx.Private.TestUtilities\src\System\AssertExtensions.cs(500): at System.AssertExtensions.Throws[T](String paramName Action action)
         F:\git\corefx\src\System.Runtime\tests\System\TypedReferenceTests.cs(600): at System.Tests.TypedReferenceTests.NegativeMakeTypedReference()

Assert failure(PID 26052 [0x000065c4] Thread: 16712 [0x4148]): (ret != WAIT_TIMEOUT) || (millis != INFINITE)

CORECLR! Thread::DoAppropriateWaitWorker + 0x5F1 (0x00007ffc`6022948d)
CORECLR! `Thread::DoAppropriateWait'::`11'::__Body::Run + 0x9B (0x00007ffc`60236a63)
CORECLR! Thread::DoAppropriateWait + 0xBE (0x00007ffc`60228e0e)
CORECLR! WaitHandleNative::CorWaitMultipleNative + 0x366 (0x00007ffc`60790806)
SYSTEM.PRIVATE.CORELIB! &lt;no symbol&gt; + 0x0 (0x00007ffc`50c2cbca)
&lt;no module&gt;! &lt;no symbol&gt; + 0x0 (0x00007ffc`021f62a6)
    File: c:\git\coreclr\src\vm\threads.cpp Line: 3778
    Image: F:\git\corefx\bin\runtime\netcoreapp-Windows_NT-Release-x64\CoreRun.exe

```

to repro on x64:
CoreCLR: 
```
build.cmd x64 checked skiptests generatelayout
```
CoreFX: 
```
build.cmd -Release -os:Windows_NT -buildArch:x64 -- /p:CoreCLROverridePath=C:\git\coreclr\bin\Product\Windows_NT.x64.Checked
build-tests -Release -os:Windows_NT -buildArch:x64 -skiptests
```

move to the test location: 
```
cd F:\git\corefx\bin\tests\System.Runtime.Tests\netcoreapp-Windows_NT-Release-x64
```
run: 
```
F:\git\corefx\bin\runtime\netcoreapp-Windows_NT-Release-x64\CoreRun.exe xunit.console.netcore.exe System.Runtime.Tests.dll -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonwindowstests  -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing -parallel none
```

It works fine if you do not pass ` -parallel none`.

Is it something expected? Found during work on #17585.
</Description>
    <Title_Description>AF: WaitAll for multiple handles on a STA thread Example:
```
Z:\bin\tests\System.Runtime.Tests\netcoreapp-Windows_NT-Release-arm&gt;call Z:\bin\testhost\netcoreapp-Windows_NT-Release-arm\dotnet.exe xunit.console.netcore.exe System.Runtime.Tests.dll -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonwindowstests  -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing -showprogress -parallel none
xUnit.net console test runner (32-bit .NET Core)
***
 System.Tests.TypedReferenceTests.NegativeMakeTypedReference [FAIL]
      Assert.Equal() Failure
      Expected: (null)
      Actual:   flds
      Stack Trace:
         F:\git\corefx\src\CoreFx.Private.TestUtilities\src\System\AssertExtensions.cs(480): at System.AssertExtensions.Throws[T](String paramName Action action)
         F:\git\corefx\src\System.Runtime\tests\System\TypedReferenceTests.cs(600): at System.Tests.TypedReferenceTests.NegativeMakeTypedReference()

Assert failure(PID 5560 [0x000015b8] Thread: 11680 [0x2da0]): (ret != WAIT_TIMEOUT) || (millis != INFINITE)

&lt;no module&gt;! &lt;no symbol&gt; + 0x0 (0x00000000)
    File: c:\git\coreclr\src\vm\threads.cpp Line: 3778
    Image: Z:\bin\testhost\netcoreapp-Windows_NT-Release-arm\dotnet.exe
```

or on x64:
```
F:\git\corefx\bin\tests\System.Runtime.Tests\netcoreapp-Windows_NT-Release-x64&gt;F:\git\corefx\bin\runtime\netcoreapp-Windows_NT-Release-x64\CoreRun.exe xunit.console.netcore.exe System.Runtime.Tests.dll -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonwindowstests  -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing -parallel none
xUnit.net console test runner (64-bit .NET Core)
Copyright (C) 2014 Outercurve Foundation.

Discovering: System.Runtime.Tests
Discovered:  System.Runtime.Tests
Starting:    System.Runtime.Tests
   System.Tests.TypedReferenceTests.NegativeMakeTypedReference [FAIL]
      Assert.Equal() Failure
      Expected: (null)
      Actual:   flds
      Stack Trace:
         F:\git\corefx\src\CoreFx.Private.TestUtilities\src\System\AssertExtensions.cs(500): at System.AssertExtensions.Throws[T](String paramName Action action)
         F:\git\corefx\src\System.Runtime\tests\System\TypedReferenceTests.cs(600): at System.Tests.TypedReferenceTests.NegativeMakeTypedReference()

Assert failure(PID 26052 [0x000065c4] Thread: 16712 [0x4148]): (ret != WAIT_TIMEOUT) || (millis != INFINITE)

CORECLR! Thread::DoAppropriateWaitWorker + 0x5F1 (0x00007ffc`6022948d)
CORECLR! `Thread::DoAppropriateWait'::`11'::__Body::Run + 0x9B (0x00007ffc`60236a63)
CORECLR! Thread::DoAppropriateWait + 0xBE (0x00007ffc`60228e0e)
CORECLR! WaitHandleNative::CorWaitMultipleNative + 0x366 (0x00007ffc`60790806)
SYSTEM.PRIVATE.CORELIB! &lt;no symbol&gt; + 0x0 (0x00007ffc`50c2cbca)
&lt;no module&gt;! &lt;no symbol&gt; + 0x0 (0x00007ffc`021f62a6)
    File: c:\git\coreclr\src\vm\threads.cpp Line: 3778
    Image: F:\git\corefx\bin\runtime\netcoreapp-Windows_NT-Release-x64\CoreRun.exe

```

to repro on x64:
CoreCLR: 
```
build.cmd x64 checked skiptests generatelayout
```
CoreFX: 
```
build.cmd -Release -os:Windows_NT -buildArch:x64 -- /p:CoreCLROverridePath=C:\git\coreclr\bin\Product\Windows_NT.x64.Checked
build-tests -Release -os:Windows_NT -buildArch:x64 -skiptests
```

move to the test location: 
```
cd F:\git\corefx\bin\tests\System.Runtime.Tests\netcoreapp-Windows_NT-Release-x64
```
run: 
```
F:\git\corefx\bin\runtime\netcoreapp-Windows_NT-Release-x64\CoreRun.exe xunit.console.netcore.exe System.Runtime.Tests.dll -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonwindowstests  -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing -parallel none
```

It works fine if you do not pass ` -parallel none`.

Is it something expected? Found during work on #17585.
</Title_Description>
    <Label>area-System.Threading</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17783</IssueLabelID>
    <Title>Publish release/uwp6.0 and release/uwp6.1 symbols Publish symbols using Microsoft.SymbolUploader.Build.Task package</Title>
    <Description>See https://github.com/dotnet/coreclr/issues/16482. This tracks porting infrastructure to the `release/uwp6.0` and `release/uwp6.1` branches.</Description>
    <Title_Description>Publish release/uwp6.0 and release/uwp6.1 symbols Publish symbols using Microsoft.SymbolUploader.Build.Task package See https://github.com/dotnet/coreclr/issues/16482. This tracks porting infrastructure to the `release/uwp6.0` and `release/uwp6.1` branches.</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>25/04/2018 9:38:27 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17782</IssueLabelID>
    <Title>XPlat C# Debugger is failing to show Async Callstack frames</Title>
    <Description>Found by @chuckries during scenario testing.</Description>
    <Title_Description>XPlat C# Debugger is failing to show Async Callstack frames Found by @chuckries during scenario testing.</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>chuckries</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17778</IssueLabelID>
    <Title>release/uwp6.0 and release/uwp6.1 long-name DAC/SOS have incorrect version</Title>
    <Description>See https://github.com/dotnet/coreclr/issues/17619. The long-name DAC/SOS aren't indexed properly because the DLLs have the wrong name in the symbol packages.

~~The same~~ A similar problem to `release/1.1.0` is present in `release/uwp6.0` and `release/uwp6.1`:

 * `..._4.6.00001.0.dll`
 * `..._4.6.25707.02.dll` (expected)

https://github.com/dotnet/coreclr/blob/9afe551aa13b52d7ebca9aeed1da97edc51b843f/src/.nuget/Microsoft.NETCore.Runtime.CoreCLR/runtime.Windows_NT.Microsoft.NETCore.Runtime.CoreCLR.props#L9-L10

https://github.com/dotnet/coreclr/blob/25c45ac5da9e2f709be7b8fb115e116d3ae44ac4/src/.nuget/Microsoft.NETCore.Runtime.CoreCLR/runtime.Windows_NT.Microsoft.NETCore.Runtime.CoreCLR.props#L9-L10

These branches should be fixed before they're next released or there will have to be more manual fix-ups on the symbol packages for the long-name DAC/SOS files. @nattress @zamont do you know the status of these CoreCLR branches?

/cc @lt72 @mikem8361 @leculver @weshaggard </Description>
    <Title_Description>release/uwp6.0 and release/uwp6.1 long-name DAC/SOS have incorrect version See https://github.com/dotnet/coreclr/issues/17619. The long-name DAC/SOS aren't indexed properly because the DLLs have the wrong name in the symbol packages.

~~The same~~ A similar problem to `release/1.1.0` is present in `release/uwp6.0` and `release/uwp6.1`:

 * `..._4.6.00001.0.dll`
 * `..._4.6.25707.02.dll` (expected)

https://github.com/dotnet/coreclr/blob/9afe551aa13b52d7ebca9aeed1da97edc51b843f/src/.nuget/Microsoft.NETCore.Runtime.CoreCLR/runtime.Windows_NT.Microsoft.NETCore.Runtime.CoreCLR.props#L9-L10

https://github.com/dotnet/coreclr/blob/25c45ac5da9e2f709be7b8fb115e116d3ae44ac4/src/.nuget/Microsoft.NETCore.Runtime.CoreCLR/runtime.Windows_NT.Microsoft.NETCore.Runtime.CoreCLR.props#L9-L10

These branches should be fixed before they're next released or there will have to be more manual fix-ups on the symbol packages for the long-name DAC/SOS files. @nattress @zamont do you know the status of these CoreCLR branches?

/cc @lt72 @mikem8361 @leculver @weshaggard </Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>nattress</Assignee>
    <CreatedAt>25/04/2018 8:01:57 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17777</IssueLabelID>
    <Title>Fix IMPL_LIMITATION on Struct LclVar Offsets for 64-bit targets</Title>
    <Description>The emitter has a `struct emitLclVarAddr` which has  a limitation on offset values for large LclVars numbers (above 32767)   For our 64-bit targets we can use some extra bits to eliminate this limiation.
</Description>
    <Title_Description>Fix IMPL_LIMITATION on Struct LclVar Offsets for 64-bit targets The emitter has a `struct emitLclVarAddr` which has  a limitation on offset values for large LclVars numbers (above 32767)   For our 64-bit targets we can use some extra bits to eliminate this limiation.
</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>briansull</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17775</IssueLabelID>
    <Title>Fix instruction groups offset on the border between cold/hot code.</Title>
    <Description>Fixes DevDiv_601045; assert while generating diffs:
https://github.com/dotnet/coreclr/blob/71f4199f7dd043c4901a187b9bd88ab40e2b87e2/src/jit/emit.cpp#L7185

I was not able to repro the original issue on Core and it did not allow me to go back and find when the desktop issue appeared. The new checks show that the problem exists in CoreCLR as well.

The fix doesn't change the generated code (it changes only unused allocated parts) and doesn't cause any diffs.

The important changes are in the fourth commit.</Description>
    <Title_Description>Fix instruction groups offset on the border between cold/hot code. Fixes DevDiv_601045; assert while generating diffs:
https://github.com/dotnet/coreclr/blob/71f4199f7dd043c4901a187b9bd88ab40e2b87e2/src/jit/emit.cpp#L7185

I was not able to repro the original issue on Core and it did not allow me to go back and find when the desktop issue appeared. The new checks show that the problem exists in CoreCLR as well.

The fix doesn't change the generated code (it changes only unused allocated parts) and doesn't cause any diffs.

The important changes are in the fourth commit.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>25/04/2018 6:13:09 PM +00:00</CreatedAt>
    <ClosedAt>20/06/2018 1:02:12 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17772</IssueLabelID>
    <Title>Use of created nested types in dynamic assembly builders cause TypeLoadExceptions</Title>
    <Description>When attempting to generate a dynamic type that contains a nested type use of the type to generate fields on the parent type fails with a [TypeLoadException][exception] if the type has been realized using `GetTypeInfo()`.

This issue is not present on Mono and the type can be successfully created. Furthermore defining the type as a non-nested type in the dynamic module also succeeds.

A minimal [reproduction project][repro-project] has been included which targets both the full framework and .NET Core 2.0. The aforementioned exception is thrown at line 23 when the project is ran using .NET Core 2.0.

To run the project unzip the file and open it in your IDE of choice then compile and run. If you are not using an IDE execute the following commands:

```
unzip Scratchpad.zip
cd Scratchpad
dotnet run --project Scratchpad --framework netcoreapp2.0 // for .net core
dotnet run --project Scratchpad --framework net461 // for .net 4.6.1
```

[repro-project]: https://github.com/dotnet/core/files/1947057/Scratchpad.zip
[exception]: https://gist.github.com/Nihlus/63eb35f3ee3a2f38456002c60bb5d057</Description>
    <Title_Description>Use of created nested types in dynamic assembly builders cause TypeLoadExceptions When attempting to generate a dynamic type that contains a nested type use of the type to generate fields on the parent type fails with a [TypeLoadException][exception] if the type has been realized using `GetTypeInfo()`.

This issue is not present on Mono and the type can be successfully created. Furthermore defining the type as a non-nested type in the dynamic module also succeeds.

A minimal [reproduction project][repro-project] has been included which targets both the full framework and .NET Core 2.0. The aforementioned exception is thrown at line 23 when the project is ran using .NET Core 2.0.

To run the project unzip the file and open it in your IDE of choice then compile and run. If you are not using an IDE execute the following commands:

```
unzip Scratchpad.zip
cd Scratchpad
dotnet run --project Scratchpad --framework netcoreapp2.0 // for .net core
dotnet run --project Scratchpad --framework net461 // for .net 4.6.1
```

[repro-project]: https://github.com/dotnet/core/files/1947057/Scratchpad.zip
[exception]: https://gist.github.com/Nihlus/63eb35f3ee3a2f38456002c60bb5d057</Title_Description>
    <Label>area-System.Reflection</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>25/04/2018 1:12:58 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17771</IssueLabelID>
    <Title>[local gc] enable AnalyzeSurvivorsRequested and DACNotifyGcMarkEnd </Title>
    <Description>AnalyzeSurvivorsRequested and DACNotifyGcMarkEnd are disabled for local gc because they require GCnotifications which doesn't currently work across the GC interface</Description>
    <Title_Description>[local gc] enable AnalyzeSurvivorsRequested and DACNotifyGcMarkEnd  AnalyzeSurvivorsRequested and DACNotifyGcMarkEnd are disabled for local gc because they require GCnotifications which doesn't currently work across the GC interface</Title_Description>
    <Label>area-GC</Label>
    <Assignee>davmason</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17770</IssueLabelID>
    <Title>[local gc] enable use of NumaNodeInfo for local gc and PAL</Title>
    <Description>Right now we skip NumaNodeInfo for local gc and pal. See virtual_alloc_commit_for_heap in gc.cpp.</Description>
    <Title_Description>[local gc] enable use of NumaNodeInfo for local gc and PAL Right now we skip NumaNodeInfo for local gc and pal. See virtual_alloc_commit_for_heap in gc.cpp.</Title_Description>
    <Label>area-GC</Label>
    <Assignee>davmason</Assignee>
    <CreatedAt>25/04/2018 7:46:22 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17768</IssueLabelID>
    <Title>Delete InternalsVisibleTo attributes from S.P.CoreLib</Title>
    <Description>https://github.com/dotnet/coreclr/blob/master/src/mscorlib/src/mscorlib.Friends.cs

There attributes are needed for WinRT interop on Windows today. They prevent ILLinker from stripping unreachable code from S.P.CoreLib.

Fixing this should reduce size of S.P.CoreLib IL image by ~80kB.</Description>
    <Title_Description>Delete InternalsVisibleTo attributes from S.P.CoreLib https://github.com/dotnet/coreclr/blob/master/src/mscorlib/src/mscorlib.Friends.cs

There attributes are needed for WinRT interop on Windows today. They prevent ILLinker from stripping unreachable code from S.P.CoreLib.

Fixing this should reduce size of S.P.CoreLib IL image by ~80kB.</Title_Description>
    <Label>area-Meta-corelib</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>25/04/2018 3:19:44 AM +00:00</CreatedAt>
    <ClosedAt>16/07/2018 5:27:55 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17767</IssueLabelID>
    <Title>Fix AsyncLocal&lt;class&gt; changed event to not be raised multiple times for one change in value</Title>
    <Description>Functional fix for https://github.com/dotnet/coreclr/issues/17758</Description>
    <Title_Description>Fix AsyncLocal&lt;class&gt; changed event to not be raised multiple times for one change in value Functional fix for https://github.com/dotnet/coreclr/issues/17758</Title_Description>
    <Label>area-System.Threading</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17760</IssueLabelID>
    <Title>Server GC is set with different env vars across platforms</Title>
    <Description>On Unix we set server gc by setting ```COMPlus_gcServer=1``` but this does not work on Windows.

On Windows we use ```complus_buildflavor=svr```. 

There is also this in ```coreruncommon.cpp``` and ```corerun.cpp```
```
// Name of the environment variable controlling server GC.
// If set to 1 server GC is enabled on startup. If 0 server GC is
// disabled. Server GC is off by default.
static const char* serverGcVar = "CORECLR_SERVER_GC"; 
```

We should try to make these into one variable that works across all platforms. </Description>
    <Title_Description>Server GC is set with different env vars across platforms On Unix we set server gc by setting ```COMPlus_gcServer=1``` but this does not work on Windows.

On Windows we use ```complus_buildflavor=svr```. 

There is also this in ```coreruncommon.cpp``` and ```corerun.cpp```
```
// Name of the environment variable controlling server GC.
// If set to 1 server GC is enabled on startup. If 0 server GC is
// disabled. Server GC is off by default.
static const char* serverGcVar = "CORECLR_SERVER_GC"; 
```

We should try to make these into one variable that works across all platforms. </Title_Description>
    <Label>area-GC</Label>
    <Assignee>sywhang</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17759</IssueLabelID>
    <Title>Add tests for arm64 il issues.</Title>
    <Description>The PR adds tests that are failing in our internal test system with arm64 altjit.
Failures are:
```
codegencommon_cpp__6797____Assertion_failed__NYI__Initialize_floating_point_register_to_zero
liveness_cpp__39____Assertion_failed____We_should_never_encounter_a_reference_to_a_lclVar_that_has_a_zero_refCnt__
lsraarm64_cpp__241____Assertion_failed____Shouldn_t_see_an_integer_typed_GT_MOD_node_in_ARM64_
```
</Description>
    <Title_Description>Add tests for arm64 il issues. The PR adds tests that are failing in our internal test system with arm64 altjit.
Failures are:
```
codegencommon_cpp__6797____Assertion_failed__NYI__Initialize_floating_point_register_to_zero
liveness_cpp__39____Assertion_failed____We_should_never_encounter_a_reference_to_a_lclVar_that_has_a_zero_refCnt__
lsraarm64_cpp__241____Assertion_failed____Shouldn_t_see_an_integer_typed_GT_MOD_node_in_ARM64_
```
</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>24/04/2018 9:36:31 PM +00:00</CreatedAt>
    <ClosedAt>14/05/2018 8:29:43 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17758</IssueLabelID>
    <Title>AsyncLocal&lt;class&gt; changed event can be raised multiple times for one change in value</Title>
    <Description>```c#
        var al1 = new AsyncLocal&lt;object&gt;();
        al1.Value = new object();
        var ec = ExecutionContext.Capture();

        Action&lt;AsyncLocalValueChangedArgs&lt;object&gt;&gt; onChanged = e =&gt; Console.WriteLine("changed");
        Console.WriteLine("--- new AsyncLocal&lt;object&gt;");
        var al = new AsyncLocal&lt;object&gt;(onChanged);
        Console.WriteLine("--- new object");
        al.Value = new object();
        Console.WriteLine("--- null");
        al.Value = null;
        Console.WriteLine("--- new object");
        al.Value = new object();
        Console.WriteLine("--- before EC.Run");
        ExecutionContext.Run(ec data =&gt; Console.WriteLine("--- in EC.Run") null);
```

Expected output:
```
--- new AsyncLocal&lt;object&gt;
--- new object
changed
--- null
changed
--- new object
changed
--- before EC.Run
changed
--- in EC.Run
changed
```

Observed output:
```
--- new AsyncLocal&lt;object&gt;
--- new object
changed
--- null
changed
--- new object
changed
--- before EC.Run
changed
changed
--- in EC.Run
changed
changed
```

This seems to be a regression from https://github.com/dotnet/coreclr/pull/8216 which treats a value of null as though the key does not exist but in `ExecutionContext.SetLocalValue` the key not existing means it will add a new change notification. So each transition of an AsyncLocal&lt;class&gt;'s value from null to non-null will add an additional change notification. The fix would probably be to keep the key in the IAsyncLocalValueMap despite its value becoming null.

The issue currently requires two AsyncLocals to reproduce because [for the first AsyncLocal](https://github.com/dotnet/coreclr/blob/master/src/mscorlib/shared/System/Threading/ExecutionContext.cs#L337) it does not consider whether the new value is null as opposed to AsyncLocalValueMap's implementation.

CC @stephentoub </Description>
    <Title_Description>AsyncLocal&lt;class&gt; changed event can be raised multiple times for one change in value ```c#
        var al1 = new AsyncLocal&lt;object&gt;();
        al1.Value = new object();
        var ec = ExecutionContext.Capture();

        Action&lt;AsyncLocalValueChangedArgs&lt;object&gt;&gt; onChanged = e =&gt; Console.WriteLine("changed");
        Console.WriteLine("--- new AsyncLocal&lt;object&gt;");
        var al = new AsyncLocal&lt;object&gt;(onChanged);
        Console.WriteLine("--- new object");
        al.Value = new object();
        Console.WriteLine("--- null");
        al.Value = null;
        Console.WriteLine("--- new object");
        al.Value = new object();
        Console.WriteLine("--- before EC.Run");
        ExecutionContext.Run(ec data =&gt; Console.WriteLine("--- in EC.Run") null);
```

Expected output:
```
--- new AsyncLocal&lt;object&gt;
--- new object
changed
--- null
changed
--- new object
changed
--- before EC.Run
changed
--- in EC.Run
changed
```

Observed output:
```
--- new AsyncLocal&lt;object&gt;
--- new object
changed
--- null
changed
--- new object
changed
--- before EC.Run
changed
changed
--- in EC.Run
changed
changed
```

This seems to be a regression from https://github.com/dotnet/coreclr/pull/8216 which treats a value of null as though the key does not exist but in `ExecutionContext.SetLocalValue` the key not existing means it will add a new change notification. So each transition of an AsyncLocal&lt;class&gt;'s value from null to non-null will add an additional change notification. The fix would probably be to keep the key in the IAsyncLocalValueMap despite its value becoming null.

The issue currently requires two AsyncLocals to reproduce because [for the first AsyncLocal](https://github.com/dotnet/coreclr/blob/master/src/mscorlib/shared/System/Threading/ExecutionContext.cs#L337) it does not consider whether the new value is null as opposed to AsyncLocalValueMap's implementation.

CC @stephentoub </Title_Description>
    <Label>area-System.Threading</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17756</IssueLabelID>
    <Title>[arm32/Ubuntu][JitStressRegs] corefx System.Net.NameResolution.Functional.Tests failures</Title>
    <Description>With JitStressRegs=0x10

https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_tst_prtest/1/consoleText

```
Running tests in /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_tst_prtest/_/fx/bin/tests/System.Net.NameResolution.Functional.Tests/netcoreapp-Linux-Release-arm
timeout --kill-after=30s 10m ./RunTests.sh /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_tst_prtest/_/fx/bin/testhost/netcoreapp-Linux-Release-arm

----- start 03:14:14 =============== To repro directly: =====================================================
pushd .
#!/usr/bin/env bash
export COMPlus_JitStressRegs=0x10
chmod +x /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_tst_prtest/_/fx/bin/testhost/netcoreapp-Linux-Release-arm/dotnet
/ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_tst_prtest/_/fx/bin/testhost/netcoreapp-Linux-Release-arm/dotnet xunit.console.netcore.exe System.Net.NameResolution.Functional.Tests.dll  -xml testResults.xml -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonlinuxtests  -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing
popd
===========================================================================================================
/ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_tst_prtest/_/fx/bin/tests/System.Net.NameResolution.Functional.Tests/netcoreapp-Linux-Release-arm /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_tst_prtest/_/fx/bin/tests/System.Net.NameResolution.Functional.Tests/netcoreapp-Linux-Release-arm
xUnit.net console test runner (32-bit .NET Core)
Copyright (C) 2014 Outercurve Foundation.

Discovering: System.Net.NameResolution.Functional.Tests
Discovered:  System.Net.NameResolution.Functional.Tests
Starting:    System.Net.NameResolution.Functional.Tests
   System.Net.NameResolution.Tests.GetHostByNameTest.DnsObsoleteGetHostByName_EmptyString_ReturnsHostName [FAIL]
      System.Net.Internals.SocketExceptionFactory+ExtendedSocketException : No such device or address
      Stack Trace:
         /mnt/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_prtest/_/fx/src/System.Net.NameResolution/src/System/Net/DNS.cs(650): at System.Net.Dns.InternalGetHostByName(String hostName)
         /mnt/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_prtest/_/fx/src/System.Net.NameResolution/src/System/Net/DNS.cs(320): at System.Net.Dns.GetHostByName(String hostName)
         /mnt/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_prtest/_/fx/src/System.Net.NameResolution/tests/FunctionalTests/GetHostByNameTest.cs(1080): at System.Net.NameResolution.Tests.GetHostByNameTest.DnsObsoleteGetHostByName_EmptyString_ReturnsHostName()
   System.Net.NameResolution.Tests.GetHostByNameTest.DnsObsoleteBeginEndGetHostByName_EmptyString_ReturnsHostName [FAIL]
      System.Net.Internals.SocketExceptionFactory+ExtendedSocketException : No such device or address
      Stack Trace:
         /mnt/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_prtest/_/fx/src/System.Net.NameResolution/src/System/Net/DNS.cs(650): at System.Net.Dns.InternalGetHostByName(String hostName)
         /mnt/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_prtest/_/fx/src/System.Net.NameResolution/src/System/Net/DNS.cs(2080): at System.Net.Dns.ResolveCallback(Object context)
         --- End of stack trace from previous location where exception was thrown ---
         /mnt/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_prtest/_/fx/src/System.Net.NameResolution/src/System/Net/DNS.cs(3580): at System.Net.Dns.HostResolutionEndHelper(IAsyncResult asyncResult)
         /mnt/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_prtest/_/fx/src/System.Net.NameResolution/src/System/Net/DNS.cs(3830): at System.Net.Dns.EndGetHostByName(IAsyncResult asyncResult)
         /mnt/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_prtest/_/fx/src/System.Net.NameResolution/tests/FunctionalTests/GetHostByNameTest.cs(1170): at System.Net.NameResolution.Tests.GetHostByNameTest.DnsObsoleteBeginEndGetHostByName_EmptyString_ReturnsHostName()
   System.Net.NameResolution.Tests.GetHostEntryTest.Dns_GetHostEntry_HostString_Ok(hostName: \"\") [FAIL]
      System.Net.Internals.SocketExceptionFactory+ExtendedSocketException : No such device or address
      Stack Trace:
         /mnt/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_prtest/_/fx/src/System.Net.NameResolution/src/System/Net/DNS.cs(650): at System.Net.Dns.InternalGetHostByName(String hostName)
         /mnt/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_prtest/_/fx/src/System.Net.NameResolution/src/System/Net/DNS.cs(4040): at System.Net.Dns.GetHostEntry(String hostNameOrAddress)
         /mnt/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_prtest/_/fx/src/System.Net.NameResolution/tests/FunctionalTests/GetHostEntryTest.cs(260): at System.Net.NameResolution.Tests.GetHostEntryTest.&lt;&gt;c__DisplayClass1_0.&lt;Dns_GetHostEntry_HostString_Ok&gt;b__0()
         /mnt/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_prtest/_/fx/src/System.Net.NameResolution/tests/FunctionalTests/GetHostEntryTest.cs(380): at System.Net.NameResolution.Tests.GetHostEntryTest.TestGetHostEntryAsync(Func`1 getHostEntryFunc)
         --- End of stack trace from previous location where exception was thrown ---
   System.Net.NameResolution.Tests.GetHostEntryTest.Dns_GetHostEntryAsync_HostString_Ok(hostName: \"\") [FAIL]
      System.AggregateException : One or more errors occurred. (One or more errors occurred. (No such device or address)) (One or more errors occurred. (No such device or address))
      ---- System.AggregateException : One or more errors occurred. (No such device or address)
      -------- System.Net.Internals.SocketExceptionFactory+ExtendedSocketException : No such device or address
      ---- System.AggregateException : One or more errors occurred. (No such device or address)
      -------- System.Net.Internals.SocketExceptionFactory+ExtendedSocketException : No such device or address
      Stack Trace:
         /mnt/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_prtest/_/fx/src/Common/tests/System/Threading/Tasks/TaskTimeoutExtensions.cs(900): at System.Threading.Tasks.TaskTimeoutExtensions.WhenAllOrAnyFailed(Task[] tasks)
         /mnt/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_prtest/_/fx/src/Common/tests/System/Threading/Tasks/TaskTimeoutExtensions.cs(520): at System.Threading.Tasks.TaskTimeoutExtensions.WhenAllOrAnyFailed(Task[] tasks Int32 millisecondsTimeout)
         /mnt/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_prtest/_/fx/src/System.Net.NameResolution/tests/FunctionalTests/GetHostEntryTest.cs(410): at System.Net.NameResolution.Tests.GetHostEntryTest.TestGetHostEntryAsync(Func`1 getHostEntryFunc)
         --- End of stack trace from previous location where exception was thrown ---
         ----- Inner Stack Trace #1 (System.AggregateException) -----
         
         ----- Inner Stack Trace -----
         /mnt/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_prtest/_/fx/src/System.Net.NameResolution/src/System/Net/DNS.cs(650): at System.Net.Dns.InternalGetHostByName(String hostName)
         /mnt/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_prtest/_/fx/src/System.Net.NameResolution/src/System/Net/DNS.cs(2080): at System.Net.Dns.ResolveCallback(Object context)
         --- End of stack trace from previous location where exception was thrown ---
         /mnt/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_prtest/_/fx/src/System.Net.NameResolution/src/System/Net/DNS.cs(3580): at System.Net.Dns.HostResolutionEndHelper(IAsyncResult asyncResult)
         /mnt/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_prtest/_/fx/src/System.Net.NameResolution/src/System/Net/DNS.cs(5000): at System.Net.Dns.EndGetHostEntry(IAsyncResult asyncResult)
         /mnt/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_prtest/_/fx/src/System.Net.NameResolution/src/System/Net/DNS.cs(5900): at System.Net.Dns.&lt;&gt;c.&lt;GetHostEntryAsync&gt;b__27_1(IAsyncResult asyncResult)
            at System.Threading.Tasks.TaskFactory`1.FromAsyncCoreLogic(IAsyncResult iar Func`2 endFunction Action`1 endAction Task`1 promise Boolean requiresSynchronization)
         --- End of stack trace from previous location where exception was thrown ---
         /mnt/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_prtest/_/fx/src/Common/tests/System/Threading/Tasks/TaskTimeoutExtensions.cs(640): at System.Threading.Tasks.TaskTimeoutExtensions.WhenAllOrAnyFailed(Task[] tasks)
         ----- Inner Stack Trace #2 (System.AggregateException) -----
         
         ----- Inner Stack Trace -----
         /mnt/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_prtest/_/fx/src/System.Net.NameResolution/src/System/Net/DNS.cs(650): at System.Net.Dns.InternalGetHostByName(String hostName)
         /mnt/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_prtest/_/fx/src/System.Net.NameResolution/src/System/Net/DNS.cs(2080): at System.Net.Dns.ResolveCallback(Object context)
         --- End of stack trace from previous location where exception was thrown ---
         /mnt/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_prtest/_/fx/src/System.Net.NameResolution/src/System/Net/DNS.cs(3580): at System.Net.Dns.HostResolutionEndHelper(IAsyncResult asyncResult)
         /mnt/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_prtest/_/fx/src/System.Net.NameResolution/src/System/Net/DNS.cs(5000): at System.Net.Dns.EndGetHostEntry(IAsyncResult asyncResult)
         /mnt/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_prtest/_/fx/src/System.Net.NameResolution/src/System/Net/DNS.cs(5900): at System.Net.Dns.&lt;&gt;c.&lt;GetHostEntryAsync&gt;b__27_1(IAsyncResult asyncResult)
            at System.Threading.Tasks.TaskFactory`1.FromAsyncCoreLogic(IAsyncResult iar Func`2 endFunction Action`1 endAction Task`1 promise Boolean requiresSynchronization)
Finished:    System.Net.NameResolution.Functional.Tests

=== TEST EXECUTION SUMMARY ===
   System.Net.NameResolution.Functional.Tests  Total: 57 Errors: 0 Failed: 4 Skipped: 0 Time: 8.016s
/ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_tst_prtest/_/fx/bin/tests/System.Net.NameResolution.Functional.Tests/netcoreapp-Linux-Release-arm
----- end 03:14:27 ----- exit code 1 ----------------------------------------------------------
Looking around for any Linux dump...
... found no dump in /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_tst_prtest/_/fx/bin/tests/System.Net.NameResolution.Functional.Tests/netcoreapp-Linux-Release-arm
error: One or more tests failed while running tests from ''.  Exit code 1.
```
</Description>
    <Title_Description>[arm32/Ubuntu][JitStressRegs] corefx System.Net.NameResolution.Functional.Tests failures With JitStressRegs=0x10

https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_tst_prtest/1/consoleText

```
Running tests in /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_tst_prtest/_/fx/bin/tests/System.Net.NameResolution.Functional.Tests/netcoreapp-Linux-Release-arm
timeout --kill-after=30s 10m ./RunTests.sh /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_tst_prtest/_/fx/bin/testhost/netcoreapp-Linux-Release-arm

----- start 03:14:14 =============== To repro directly: =====================================================
pushd .
#!/usr/bin/env bash
export COMPlus_JitStressRegs=0x10
chmod +x /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_tst_prtest/_/fx/bin/testhost/netcoreapp-Linux-Release-arm/dotnet
/ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_tst_prtest/_/fx/bin/testhost/netcoreapp-Linux-Release-arm/dotnet xunit.console.netcore.exe System.Net.NameResolution.Functional.Tests.dll  -xml testResults.xml -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonlinuxtests  -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing
popd
===========================================================================================================
/ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_tst_prtest/_/fx/bin/tests/System.Net.NameResolution.Functional.Tests/netcoreapp-Linux-Release-arm /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_tst_prtest/_/fx/bin/tests/System.Net.NameResolution.Functional.Tests/netcoreapp-Linux-Release-arm
xUnit.net console test runner (32-bit .NET Core)
Copyright (C) 2014 Outercurve Foundation.

Discovering: System.Net.NameResolution.Functional.Tests
Discovered:  System.Net.NameResolution.Functional.Tests
Starting:    System.Net.NameResolution.Functional.Tests
   System.Net.NameResolution.Tests.GetHostByNameTest.DnsObsoleteGetHostByName_EmptyString_ReturnsHostName [FAIL]
      System.Net.Internals.SocketExceptionFactory+ExtendedSocketException : No such device or address
      Stack Trace:
         /mnt/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_prtest/_/fx/src/System.Net.NameResolution/src/System/Net/DNS.cs(650): at System.Net.Dns.InternalGetHostByName(String hostName)
         /mnt/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_prtest/_/fx/src/System.Net.NameResolution/src/System/Net/DNS.cs(320): at System.Net.Dns.GetHostByName(String hostName)
         /mnt/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_prtest/_/fx/src/System.Net.NameResolution/tests/FunctionalTests/GetHostByNameTest.cs(1080): at System.Net.NameResolution.Tests.GetHostByNameTest.DnsObsoleteGetHostByName_EmptyString_ReturnsHostName()
   System.Net.NameResolution.Tests.GetHostByNameTest.DnsObsoleteBeginEndGetHostByName_EmptyString_ReturnsHostName [FAIL]
      System.Net.Internals.SocketExceptionFactory+ExtendedSocketException : No such device or address
      Stack Trace:
         /mnt/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_prtest/_/fx/src/System.Net.NameResolution/src/System/Net/DNS.cs(650): at System.Net.Dns.InternalGetHostByName(String hostName)
         /mnt/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_prtest/_/fx/src/System.Net.NameResolution/src/System/Net/DNS.cs(2080): at System.Net.Dns.ResolveCallback(Object context)
         --- End of stack trace from previous location where exception was thrown ---
         /mnt/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_prtest/_/fx/src/System.Net.NameResolution/src/System/Net/DNS.cs(3580): at System.Net.Dns.HostResolutionEndHelper(IAsyncResult asyncResult)
         /mnt/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_prtest/_/fx/src/System.Net.NameResolution/src/System/Net/DNS.cs(3830): at System.Net.Dns.EndGetHostByName(IAsyncResult asyncResult)
         /mnt/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_prtest/_/fx/src/System.Net.NameResolution/tests/FunctionalTests/GetHostByNameTest.cs(1170): at System.Net.NameResolution.Tests.GetHostByNameTest.DnsObsoleteBeginEndGetHostByName_EmptyString_ReturnsHostName()
   System.Net.NameResolution.Tests.GetHostEntryTest.Dns_GetHostEntry_HostString_Ok(hostName: \"\") [FAIL]
      System.Net.Internals.SocketExceptionFactory+ExtendedSocketException : No such device or address
      Stack Trace:
         /mnt/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_prtest/_/fx/src/System.Net.NameResolution/src/System/Net/DNS.cs(650): at System.Net.Dns.InternalGetHostByName(String hostName)
         /mnt/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_prtest/_/fx/src/System.Net.NameResolution/src/System/Net/DNS.cs(4040): at System.Net.Dns.GetHostEntry(String hostNameOrAddress)
         /mnt/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_prtest/_/fx/src/System.Net.NameResolution/tests/FunctionalTests/GetHostEntryTest.cs(260): at System.Net.NameResolution.Tests.GetHostEntryTest.&lt;&gt;c__DisplayClass1_0.&lt;Dns_GetHostEntry_HostString_Ok&gt;b__0()
         /mnt/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_prtest/_/fx/src/System.Net.NameResolution/tests/FunctionalTests/GetHostEntryTest.cs(380): at System.Net.NameResolution.Tests.GetHostEntryTest.TestGetHostEntryAsync(Func`1 getHostEntryFunc)
         --- End of stack trace from previous location where exception was thrown ---
   System.Net.NameResolution.Tests.GetHostEntryTest.Dns_GetHostEntryAsync_HostString_Ok(hostName: \"\") [FAIL]
      System.AggregateException : One or more errors occurred. (One or more errors occurred. (No such device or address)) (One or more errors occurred. (No such device or address))
      ---- System.AggregateException : One or more errors occurred. (No such device or address)
      -------- System.Net.Internals.SocketExceptionFactory+ExtendedSocketException : No such device or address
      ---- System.AggregateException : One or more errors occurred. (No such device or address)
      -------- System.Net.Internals.SocketExceptionFactory+ExtendedSocketException : No such device or address
      Stack Trace:
         /mnt/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_prtest/_/fx/src/Common/tests/System/Threading/Tasks/TaskTimeoutExtensions.cs(900): at System.Threading.Tasks.TaskTimeoutExtensions.WhenAllOrAnyFailed(Task[] tasks)
         /mnt/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_prtest/_/fx/src/Common/tests/System/Threading/Tasks/TaskTimeoutExtensions.cs(520): at System.Threading.Tasks.TaskTimeoutExtensions.WhenAllOrAnyFailed(Task[] tasks Int32 millisecondsTimeout)
         /mnt/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_prtest/_/fx/src/System.Net.NameResolution/tests/FunctionalTests/GetHostEntryTest.cs(410): at System.Net.NameResolution.Tests.GetHostEntryTest.TestGetHostEntryAsync(Func`1 getHostEntryFunc)
         --- End of stack trace from previous location where exception was thrown ---
         ----- Inner Stack Trace #1 (System.AggregateException) -----
         
         ----- Inner Stack Trace -----
         /mnt/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_prtest/_/fx/src/System.Net.NameResolution/src/System/Net/DNS.cs(650): at System.Net.Dns.InternalGetHostByName(String hostName)
         /mnt/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_prtest/_/fx/src/System.Net.NameResolution/src/System/Net/DNS.cs(2080): at System.Net.Dns.ResolveCallback(Object context)
         --- End of stack trace from previous location where exception was thrown ---
         /mnt/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_prtest/_/fx/src/System.Net.NameResolution/src/System/Net/DNS.cs(3580): at System.Net.Dns.HostResolutionEndHelper(IAsyncResult asyncResult)
         /mnt/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_prtest/_/fx/src/System.Net.NameResolution/src/System/Net/DNS.cs(5000): at System.Net.Dns.EndGetHostEntry(IAsyncResult asyncResult)
         /mnt/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_prtest/_/fx/src/System.Net.NameResolution/src/System/Net/DNS.cs(5900): at System.Net.Dns.&lt;&gt;c.&lt;GetHostEntryAsync&gt;b__27_1(IAsyncResult asyncResult)
            at System.Threading.Tasks.TaskFactory`1.FromAsyncCoreLogic(IAsyncResult iar Func`2 endFunction Action`1 endAction Task`1 promise Boolean requiresSynchronization)
         --- End of stack trace from previous location where exception was thrown ---
         /mnt/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_prtest/_/fx/src/Common/tests/System/Threading/Tasks/TaskTimeoutExtensions.cs(640): at System.Threading.Tasks.TaskTimeoutExtensions.WhenAllOrAnyFailed(Task[] tasks)
         ----- Inner Stack Trace #2 (System.AggregateException) -----
         
         ----- Inner Stack Trace -----
         /mnt/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_prtest/_/fx/src/System.Net.NameResolution/src/System/Net/DNS.cs(650): at System.Net.Dns.InternalGetHostByName(String hostName)
         /mnt/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_prtest/_/fx/src/System.Net.NameResolution/src/System/Net/DNS.cs(2080): at System.Net.Dns.ResolveCallback(Object context)
         --- End of stack trace from previous location where exception was thrown ---
         /mnt/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_prtest/_/fx/src/System.Net.NameResolution/src/System/Net/DNS.cs(3580): at System.Net.Dns.HostResolutionEndHelper(IAsyncResult asyncResult)
         /mnt/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_prtest/_/fx/src/System.Net.NameResolution/src/System/Net/DNS.cs(5000): at System.Net.Dns.EndGetHostEntry(IAsyncResult asyncResult)
         /mnt/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_prtest/_/fx/src/System.Net.NameResolution/src/System/Net/DNS.cs(5900): at System.Net.Dns.&lt;&gt;c.&lt;GetHostEntryAsync&gt;b__27_1(IAsyncResult asyncResult)
            at System.Threading.Tasks.TaskFactory`1.FromAsyncCoreLogic(IAsyncResult iar Func`2 endFunction Action`1 endAction Task`1 promise Boolean requiresSynchronization)
Finished:    System.Net.NameResolution.Functional.Tests

=== TEST EXECUTION SUMMARY ===
   System.Net.NameResolution.Functional.Tests  Total: 57 Errors: 0 Failed: 4 Skipped: 0 Time: 8.016s
/ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_tst_prtest/_/fx/bin/tests/System.Net.NameResolution.Functional.Tests/netcoreapp-Linux-Release-arm
----- end 03:14:27 ----- exit code 1 ----------------------------------------------------------
Looking around for any Linux dump...
... found no dump in /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstressregs0x10_tst_prtest/_/fx/bin/tests/System.Net.NameResolution.Functional.Tests/netcoreapp-Linux-Release-arm
error: One or more tests failed while running tests from ''.  Exit code 1.
```
</Title_Description>
    <Label>JitStress</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17755</IssueLabelID>
    <Title>[arm32/Ubuntu][JitStress] corefx System.Runtime.Tests times out</Title>
    <Description>With JitStress=1 or JitStress=2 the test times out (or hangs):

```
Running tests in /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstress1_tst_prtest/_/fx/bin/tests/System.Runtime.Tests/netcoreapp-Linux-Release-arm
timeout --kill-after=30s 10m ./RunTests.sh /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstress1_tst_prtest/_/fx/bin/testhost/netcoreapp-Linux-Release-arm

----- start 04:37:37 =============== To repro directly: =====================================================
pushd .
#!/usr/bin/env bash
export COMPlus_JitStress=1
chmod +x /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstress1_tst_prtest/_/fx/bin/testhost/netcoreapp-Linux-Release-arm/dotnet
/ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstress1_tst_prtest/_/fx/bin/testhost/netcoreapp-Linux-Release-arm/dotnet xunit.console.netcore.exe System.Runtime.Tests.dll  -xml testResults.xml -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonlinuxtests  -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing
popd
===========================================================================================================
/ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstress1_tst_prtest/_/fx/bin/tests/System.Runtime.Tests/netcoreapp-Linux-Release-arm /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstress1_tst_prtest/_/fx/bin/tests/System.Runtime.Tests/netcoreapp-Linux-Release-arm
xUnit.net console test runner (32-bit .NET Core)
Copyright (C) 2014 Outercurve Foundation.

Discovering: System.Runtime.Tests
Discovered:  System.Runtime.Tests
Starting:    System.Runtime.Tests
   System.Tests.UIntPtrTests.TestImplicitCast [SKIP]
      Condition(s) not met: \"Is64Bit\"
   System.Tests.UIntPtrTests.GetHashCodeRespectAllBits [SKIP]
      Condition(s) not met: \"Is64Bit\"
   System.Tests.UIntPtrTests.Subtract [SKIP]
      Condition(s) not met: \"Is64Bit\"
   System.Tests.UIntPtrTests.Ctor_ULong [SKIP]
      Condition(s) not met: \"Is64Bit\"
   System.Tests.UIntPtrTests.Add [SKIP]
      Condition(s) not met: \"Is64Bit\"
   System.Tests.UIntPtrTests.TestCtor_VoidPointer_ToPointer [SKIP]
      Condition(s) not met: \"Is64Bit\"
   System.Tests.UIntPtrTests.TestSize [SKIP]
      Condition(s) not met: \"Is64Bit\"
   System.Tests.IntPtrTests.Subtract [SKIP]
      Condition(s) not met: \"Is64Bit\"
   System.Tests.IntPtrTests.Ctor_Long [SKIP]
      Condition(s) not met: \"Is64Bit\"
   System.Tests.IntPtrTests.Size [SKIP]
      Condition(s) not met: \"Is64Bit\"
   System.Tests.IntPtrTests.Add [SKIP]
      Condition(s) not met: \"Is64Bit\"
   System.Tests.IntPtrTests.Ctor_VoidPointer_ToPointer [SKIP]
      Condition(s) not met: \"Is64Bit\"
   System.Tests.IntPtrTests.ImplicitCast [SKIP]
      Condition(s) not met: \"Is64Bit\"
   System.Tests.IntPtrTests.GetHashCodeRespectAllBits [SKIP]
      Condition(s) not met: \"Is64Bit\"
error: One or more tests failed while running tests from ''.  Exit code 124.
```

https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstress1_tst_prtest/1/consoleText
https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstress2_tst_prtest/1/consoleText</Description>
    <Title_Description>[arm32/Ubuntu][JitStress] corefx System.Runtime.Tests times out With JitStress=1 or JitStress=2 the test times out (or hangs):

```
Running tests in /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstress1_tst_prtest/_/fx/bin/tests/System.Runtime.Tests/netcoreapp-Linux-Release-arm
timeout --kill-after=30s 10m ./RunTests.sh /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstress1_tst_prtest/_/fx/bin/testhost/netcoreapp-Linux-Release-arm

----- start 04:37:37 =============== To repro directly: =====================================================
pushd .
#!/usr/bin/env bash
export COMPlus_JitStress=1
chmod +x /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstress1_tst_prtest/_/fx/bin/testhost/netcoreapp-Linux-Release-arm/dotnet
/ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstress1_tst_prtest/_/fx/bin/testhost/netcoreapp-Linux-Release-arm/dotnet xunit.console.netcore.exe System.Runtime.Tests.dll  -xml testResults.xml -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonlinuxtests  -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing
popd
===========================================================================================================
/ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstress1_tst_prtest/_/fx/bin/tests/System.Runtime.Tests/netcoreapp-Linux-Release-arm /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_corefx_jitstress1_tst_prtest/_/fx/bin/tests/System.Runtime.Tests/netcoreapp-Linux-Release-arm
xUnit.net console test runner (32-bit .NET Core)
Copyright (C) 2014 Outercurve Foundation.

Discovering: System.Runtime.Tests
Discovered:  System.Runtime.Tests
Starting:    System.Runtime.Tests
   System.Tests.UIntPtrTests.TestImplicitCast [SKIP]
      Condition(s) not met: \"Is64Bit\"
   System.Tests.UIntPtrTests.GetHashCodeRespectAllBits [SKIP]
      Condition(s) not met: \"Is64Bit\"
   System.Tests.UIntPtrTests.Subtract [SKIP]
      Condition(s) not met: \"Is64Bit\"
   System.Tests.UIntPtrTests.Ctor_ULong [SKIP]
      Condition(s) not met: \"Is64Bit\"
   System.Tests.UIntPtrTests.Add [SKIP]
      Condition(s) not met: \"Is64Bit\"
   System.Tests.UIntPtrTests.TestCtor_VoidPointer_ToPointer [SKIP]
      Condition(s) not met: \"Is64Bit\"
   System.Tests.UIntPtrTests.TestSize [SKIP]
      Condition(s) not met: \"Is64Bit\"
   System.Tests.IntPtrTests.Subtract [SKIP]
      Condition(s) not met: \"Is64Bit\"
   System.Tests.IntPtrTests.Ctor_Long [SKIP]
      Condition(s) not met: \"Is64Bit\"
   System.Tests.IntPtrTests.Size [SKIP]
      Condition(s) not met: \"Is64Bit\"
   System.Tests.IntPtrTests.Add [SKIP]
      Condition(s) not met: \"Is64Bit\"
   System.Tests.IntPtrTests.Ctor_VoidPointer_ToPointer [SKIP]
      Condition(s) not met: \"Is64Bit\"
   System.Tests.IntPtrTests.ImplicitCast [SKIP]
      Condition(s) not met: \"Is64Bit\"
   System.Tests.IntPtrTests.GetHashCodeRespectAllBits [SKIP]
      Condition(s) not met: \"Is64Bit\"
error: One or more tests failed while running tests from ''.  Exit code 124.
```

https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstress1_tst_prtest/1/consoleText
https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_ubuntu_corefx_jitstress2_tst_prtest/1/consoleText</Title_Description>
    <Label>JitStress</Label>
    <Assignee>echesakovMSFT</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17754</IssueLabelID>
    <Title>[arm32/Ubuntu] corefx test timeouts</Title>
    <Description>The following tests time out (with 10 minute default timeout) in a corefx test run:

```
System.Collections.Tests
System.Transactions.Local.Tests
System.Xml.RW.XmlConvert.Tests
```

e.g.

https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_ubuntu_corefx_baseline_tst_prtest/1/consoleText
</Description>
    <Title_Description>[arm32/Ubuntu] corefx test timeouts The following tests time out (with 10 minute default timeout) in a corefx test run:

```
System.Collections.Tests
System.Transactions.Local.Tests
System.Xml.RW.XmlConvert.Tests
```

e.g.

https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_ubuntu_corefx_baseline_tst_prtest/1/consoleText
</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>echesakovMSFT</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17753</IssueLabelID>
    <Title>[arm32/Ubuntu] corefx test failures: System.Net.NetworkInformation.Functional.Tests System.Net.Sockets.Tests</Title>
    <Description>These tests:
```
System.Net.NetworkInformation.Functional.Tests
System.Net.Sockets.Tests
```

have segmentation faults in the corefx test run e.g.:

https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_ubuntu_corefx_baseline_tst_prtest/1/consoleText
</Description>
    <Title_Description>[arm32/Ubuntu] corefx test failures: System.Net.NetworkInformation.Functional.Tests, System.Net.Sockets.Tests These tests:
```
System.Net.NetworkInformation.Functional.Tests
System.Net.Sockets.Tests
```

have segmentation faults in the corefx test run e.g.:

https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_ubuntu_corefx_baseline_tst_prtest/1/consoleText
</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>echesakovMSFT</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17751</IssueLabelID>
    <Title>Move Concurrent collections into shared</Title>
    <Description>These seem like they can be reconciled 
```
C:\git\coreclr\src\mscorlib\src\System\Collections\Concurrent\ConcurrentDictionary.cs
C:\git\coreclr\src\mscorlib\src\System\Collections\Concurrent\ConcurrentQueue.cs
C:\git\coreclr\src\mscorlib\src\System\Collections\Concurrent\ConcurrentStack.cs
C:\git\coreclr\src\mscorlib\src\System\Collections\Concurrent\IProducerConsumerCollection.cs
```
with their CoreFX cousins:
```
C:\git\corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\ConcurrentDictionary.cs
C:\git\corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\ConcurrentQueue.cs
C:\git\corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\ConcurrentStack.cs
C:\git\corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\IProducerConsumerCollection.cs
```

Usual procedure is 
1. Upgrade CoreCLR versions to have functionality of CoreFX ones. This may mean just copying over the CoreFX ones. Move to C:\git\coreclr\src\mscorlib\shared\System\Collections\Concurrent
1. Prepare a PR in CoreFX that deletes the 4 files there and instead pulls them from C:\git\corefx\src\Common\src\CoreLib\System\Collections\Concurrent
1. When mirror brings those files merge the PR.

@maryamariyan </Description>
    <Title_Description>Move Concurrent collections into shared These seem like they can be reconciled 
```
C:\git\coreclr\src\mscorlib\src\System\Collections\Concurrent\ConcurrentDictionary.cs
C:\git\coreclr\src\mscorlib\src\System\Collections\Concurrent\ConcurrentQueue.cs
C:\git\coreclr\src\mscorlib\src\System\Collections\Concurrent\ConcurrentStack.cs
C:\git\coreclr\src\mscorlib\src\System\Collections\Concurrent\IProducerConsumerCollection.cs
```
with their CoreFX cousins:
```
C:\git\corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\ConcurrentDictionary.cs
C:\git\corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\ConcurrentQueue.cs
C:\git\corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\ConcurrentStack.cs
C:\git\corefx\src\System.Collections.Concurrent\src\System\Collections\Concurrent\IProducerConsumerCollection.cs
```

Usual procedure is 
1. Upgrade CoreCLR versions to have functionality of CoreFX ones. This may mean just copying over the CoreFX ones. Move to C:\git\coreclr\src\mscorlib\shared\System\Collections\Concurrent
1. Prepare a PR in CoreFX that deletes the 4 files there and instead pulls them from C:\git\corefx\src\Common\src\CoreLib\System\Collections\Concurrent
1. When mirror brings those files merge the PR.

@maryamariyan </Title_Description>
    <Label>area-System.Collections</Label>
    <Assignee>maryamariyan</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17748</IssueLabelID>
    <Title>WIP NO MERGE dummy change</Title>
    <Description>
    </Description>
    <Title_Description>WIP NO MERGE dummy change </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>24/04/2018 1:04:30 AM +00:00</CreatedAt>
    <ClosedAt>25/04/2018 4:02:06 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17745</IssueLabelID>
    <Title>Delete unused tests\arm64\fails.testlist</Title>
    <Description>The original issue #9481 was closed long time ago.</Description>
    <Title_Description>Delete unused tests\arm64\fails.testlist The original issue #9481 was closed long time ago.</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>24/04/2018 12:19:47 AM +00:00</CreatedAt>
    <ClosedAt>24/04/2018 10:42:28 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17744</IssueLabelID>
    <Title>GC test failures in checked outerloop job</Title>
    <Description>https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64/job/checked_windows_nt/9461/consoleText

Looks like these started failing after #17680.

@sywhang 

```
D:\j\workspace\checked_windo---14fb495b\bin\tests\Windows_NT.x64.Checked\TestWrappers\GC.API\GC.API.XUnitWrapper.cs(1017): error : GC_API._GCHandle_HandleCopy_HandleCopy_._GCHandle_HandleCopy_HandleCopy_cmd [FAIL] [D:\j\workspace\checked_windo---14fb495b\tests\runtest.proj]
        
  Return code:      1
  Raw output file:      D:\j\workspace\checked_windo---14fb495b\bin\tests\Windows_NT.x64.Checked\Reports\GC.API\GCHandle\HandleCopy\HandleCopy.output.txt
  Raw output:
  BEGIN EXECUTION
         "D:\j\workspace\checked_windo---14fb495b\tests\..\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root\corerun.exe" HandleCopy.exe 
        Allocating a Weak handle to object..
        Test for Copy of GCHandle failed!
        Expected: 100
        Actual: 1
        END EXECUTION - FAILED
        FAILED
        Test Harness Exitcode is : 1
        
  To run the test:
  &gt; set CORE_ROOT=D:\j\workspace\checked_windo---14fb495b\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root
  &gt; D:\j\workspace\checked_windo---14fb495b\bin\tests\Windows_NT.x64.Checked\GC\API\GCHandle\HandleCopy\HandleCopy.cmd
  
        Expected: True
        Actual:   False
D:\j\workspace\checked_windo---14fb495b\bin\tests\Windows_NT.x64.Checked\TestWrappers\GC.API\GC.API.XUnitWrapper.cs(10170): at GC_API._GCHandle_HandleCopy_HandleCopy_._GCHandle_HandleCopy_HandleCopy_cmd()
```

```
D:\j\workspace\checked_windo---14fb495b\bin\tests\Windows_NT.x64.Checked\TestWrappers\GC.Features\GC.Features.XUnitWrapper.cs(247): error : GC_Features._Finalizer_finalizeother_finalizearraysleep_finalizearraysleep_._Finalizer_finalizeother_finalizearraysleep_finalizearraysleep_cmd [FAIL] [D:\j\workspace\checked_windo---14fb495b\tests\runtest.proj]
        
  
  Return code:      1
  Raw output file:      D:\j\workspace\checked_windo---14fb495b\bin\tests\Windows_NT.x64.Checked\Reports\GC.Features\Finalizer\finalizeother\finalizearraysleep\finalizearraysleep.output.txt
  Raw output:
  BEGIN EXECUTION
         "D:\j\workspace\checked_windo---14fb495b\tests\..\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root\corerun.exe" finalizearraysleep.exe 
        Test for Finalize() for array of objects passed!
        Expected: 100
        Actual: 0
        END EXECUTION - FAILED
        FAILED
        Test Harness Exitcode is : 1
        
  To run the test:
  &gt; set CORE_ROOT=D:\j\workspace\checked_windo---14fb495b\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root
  &gt; D:\j\workspace\checked_windo---14fb495b\bin\tests\Windows_NT.x64.Checked\GC\Features\Finalizer\finalizeother\finalizearraysleep\finalizearraysleep.cmd
  
        Expected: True
        Actual:   False
          D:\j\workspace\checked_windo---14fb495b\bin\tests\Windows_NT.x64.Checked\TestWrappers\GC.Features\GC.Features.XUnitWrapper.cs(2470): at GC_Features._Finalizer_finalizeother_finalizearraysleep_finalizearraysleep_._Finalizer_finalizeother_finalizearraysleep_finalizearraysleep_cmd()
```</Description>
    <Title_Description>GC test failures in checked outerloop job https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64/job/checked_windows_nt/9461/consoleText

Looks like these started failing after #17680.

@sywhang 

```
D:\j\workspace\checked_windo---14fb495b\bin\tests\Windows_NT.x64.Checked\TestWrappers\GC.API\GC.API.XUnitWrapper.cs(1017): error : GC_API._GCHandle_HandleCopy_HandleCopy_._GCHandle_HandleCopy_HandleCopy_cmd [FAIL] [D:\j\workspace\checked_windo---14fb495b\tests\runtest.proj]
        
  Return code:      1
  Raw output file:      D:\j\workspace\checked_windo---14fb495b\bin\tests\Windows_NT.x64.Checked\Reports\GC.API\GCHandle\HandleCopy\HandleCopy.output.txt
  Raw output:
  BEGIN EXECUTION
         "D:\j\workspace\checked_windo---14fb495b\tests\..\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root\corerun.exe" HandleCopy.exe 
        Allocating a Weak handle to object..
        Test for Copy of GCHandle failed!
        Expected: 100
        Actual: 1
        END EXECUTION - FAILED
        FAILED
        Test Harness Exitcode is : 1
        
  To run the test:
  &gt; set CORE_ROOT=D:\j\workspace\checked_windo---14fb495b\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root
  &gt; D:\j\workspace\checked_windo---14fb495b\bin\tests\Windows_NT.x64.Checked\GC\API\GCHandle\HandleCopy\HandleCopy.cmd
  
        Expected: True
        Actual:   False
D:\j\workspace\checked_windo---14fb495b\bin\tests\Windows_NT.x64.Checked\TestWrappers\GC.API\GC.API.XUnitWrapper.cs(10170): at GC_API._GCHandle_HandleCopy_HandleCopy_._GCHandle_HandleCopy_HandleCopy_cmd()
```

```
D:\j\workspace\checked_windo---14fb495b\bin\tests\Windows_NT.x64.Checked\TestWrappers\GC.Features\GC.Features.XUnitWrapper.cs(247): error : GC_Features._Finalizer_finalizeother_finalizearraysleep_finalizearraysleep_._Finalizer_finalizeother_finalizearraysleep_finalizearraysleep_cmd [FAIL] [D:\j\workspace\checked_windo---14fb495b\tests\runtest.proj]
        
  
  Return code:      1
  Raw output file:      D:\j\workspace\checked_windo---14fb495b\bin\tests\Windows_NT.x64.Checked\Reports\GC.Features\Finalizer\finalizeother\finalizearraysleep\finalizearraysleep.output.txt
  Raw output:
  BEGIN EXECUTION
         "D:\j\workspace\checked_windo---14fb495b\tests\..\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root\corerun.exe" finalizearraysleep.exe 
        Test for Finalize() for array of objects passed!
        Expected: 100
        Actual: 0
        END EXECUTION - FAILED
        FAILED
        Test Harness Exitcode is : 1
        
  To run the test:
  &gt; set CORE_ROOT=D:\j\workspace\checked_windo---14fb495b\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root
  &gt; D:\j\workspace\checked_windo---14fb495b\bin\tests\Windows_NT.x64.Checked\GC\Features\Finalizer\finalizeother\finalizearraysleep\finalizearraysleep.cmd
  
        Expected: True
        Actual:   False
          D:\j\workspace\checked_windo---14fb495b\bin\tests\Windows_NT.x64.Checked\TestWrappers\GC.Features\GC.Features.XUnitWrapper.cs(2470): at GC_Features._Finalizer_finalizeother_finalizearraysleep_finalizearraysleep_._Finalizer_finalizeother_finalizearraysleep_finalizearraysleep_cmd()
```</Title_Description>
    <Label>test bug</Label>
    <Assignee>sywhang</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17741</IssueLabelID>
    <Title>ICorProfiler retrieve function arguments in JitCompilationStarted</Title>
    <Description>I've seen this done before but for the life of me I'm having trouble finding a function's arguments when my ICorProfiler profiler's JitCompilationStarted event is called. I've got the `PCCOR_SIGNATURE` from `IMetaDataImport-&gt;GetMethodProps` but I don't have the actual arguments being passed in the function.

Is there an interface method I can call to get them?

thanks.</Description>
    <Title_Description>ICorProfiler retrieve function arguments in JitCompilationStarted I've seen this done before but for the life of me I'm having trouble finding a function's arguments when my ICorProfiler profiler's JitCompilationStarted event is called. I've got the `PCCOR_SIGNATURE` from `IMetaDataImport-&gt;GetMethodProps` but I don't have the actual arguments being passed in the function.

Is there an interface method I can call to get them?

thanks.</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>23/04/2018 10:37:59 PM +00:00</CreatedAt>
    <ClosedAt>2/01/2019 10:54:14 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17740</IssueLabelID>
    <Title>[arm32] corefx System.Net.NameResolution.Pal.Tests fails</Title>
    <Description>https://ci.dot.net/job/dotnet_coreclr/job/dev_unix_test_workflow/job/jitstress/job/arm_cross_checked_ubuntu_corefx_baseline_tst_prtest/3/consoleText

```
Running tests in /ssd/j/workspace/dotnet_coreclr/dev_unix_test_workflow/jitstress/arm_cross_checked_ubuntu_corefx_baseline_tst_prtest/_/fx/bin/tests/System.Net.NameResolution.Pal.Tests/netcoreapp-Linux-Release-arm
./RunTests.sh /ssd/j/workspace/dotnet_coreclr/dev_unix_test_workflow/jitstress/arm_cross_checked_ubuntu_corefx_baseline_tst_prtest/_/fx/bin/testhost/netcoreapp-Linux-Release-arm

----- start 04:53:57 =============== To repro directly: =====================================================
pushd .
#!/usr/bin/env bash
chmod +x /ssd/j/workspace/dotnet_coreclr/dev_unix_test_workflow/jitstress/arm_cross_checked_ubuntu_corefx_baseline_tst_prtest/_/fx/bin/testhost/netcoreapp-Linux-Release-arm/dotnet
/ssd/j/workspace/dotnet_coreclr/dev_unix_test_workflow/jitstress/arm_cross_checked_ubuntu_corefx_baseline_tst_prtest/_/fx/bin/testhost/netcoreapp-Linux-Release-arm/dotnet xunit.console.netcore.exe System.Net.NameResolution.Pal.Tests.dll  -xml testResults.xml -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonlinuxtests  -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing
popd
===========================================================================================================
/ssd/j/workspace/dotnet_coreclr/dev_unix_test_workflow/jitstress/arm_cross_checked_ubuntu_corefx_baseline_tst_prtest/_/fx/bin/tests/System.Net.NameResolution.Pal.Tests/netcoreapp-Linux-Release-arm /ssd/j/workspace/dotnet_coreclr/dev_unix_test_workflow/jitstress/arm_cross_checked_ubuntu_corefx_baseline_tst_prtest/_/fx/bin/tests/System.Net.NameResolution.Pal.Tests/netcoreapp-Linux-Release-arm
xUnit.net console test runner (32-bit .NET Core)
Copyright (C) 2014 Outercurve Foundation.

Discovering: System.Net.NameResolution.Pal.Tests
Discovered:  System.Net.NameResolution.Pal.Tests
Starting:    System.Net.NameResolution.Pal.Tests
   System.Net.NameResolution.PalTests.NameResolutionPalTests.TryGetNameInfo_LocalHost_IPv6_TryGetAddrInfo [FAIL]
      Assert.Equal() Failure
      Expected: Success
      Actual:   HostNotFound
      Stack Trace:
         /mnt/j/workspace/dotnet_coreclr/dev_unix_test_workflow/jitstress/arm_cross_checked_ubuntu_corefx_baseline_prtest/_/fx/src/System.Net.NameResolution/tests/PalTests/NameResolutionPalTests.cs(1610): at System.Net.NameResolution.PalTests.NameResolutionPalTests.TryGetNameInfo_LocalHost_IPv6_TryGetAddrInfo()
   System.Net.NameResolution.PalTests.NameResolutionPalTests.TryGetNameInfo_LocalHost_IPv6 [FAIL]
      Assert.Equal() Failure
      Expected: Success
      Actual:   HostNotFound
      Stack Trace:
         /mnt/j/workspace/dotnet_coreclr/dev_unix_test_workflow/jitstress/arm_cross_checked_ubuntu_corefx_baseline_prtest/_/fx/src/System.Net.NameResolution/tests/PalTests/NameResolutionPalTests.cs(770): at System.Net.NameResolution.PalTests.NameResolutionPalTests.TryGetNameInfo_LocalHost_IPv6()
Finished:    System.Net.NameResolution.Pal.Tests

=== TEST EXECUTION SUMMARY ===
   System.Net.NameResolution.Pal.Tests  Total: 10 Errors: 0 Failed: 2 Skipped: 0 Time: 4.381s
/ssd/j/workspace/dotnet_coreclr/dev_unix_test_workflow/jitstress/arm_cross_checked_ubuntu_corefx_baseline_tst_prtest/_/fx/bin/tests/System.Net.NameResolution.Pal.Tests/netcoreapp-Linux-Release-arm
----- end 04:54:07 ----- exit code 1 ----------------------------------------------------------
```
</Description>
    <Title_Description>[arm32] corefx System.Net.NameResolution.Pal.Tests fails https://ci.dot.net/job/dotnet_coreclr/job/dev_unix_test_workflow/job/jitstress/job/arm_cross_checked_ubuntu_corefx_baseline_tst_prtest/3/consoleText

```
Running tests in /ssd/j/workspace/dotnet_coreclr/dev_unix_test_workflow/jitstress/arm_cross_checked_ubuntu_corefx_baseline_tst_prtest/_/fx/bin/tests/System.Net.NameResolution.Pal.Tests/netcoreapp-Linux-Release-arm
./RunTests.sh /ssd/j/workspace/dotnet_coreclr/dev_unix_test_workflow/jitstress/arm_cross_checked_ubuntu_corefx_baseline_tst_prtest/_/fx/bin/testhost/netcoreapp-Linux-Release-arm

----- start 04:53:57 =============== To repro directly: =====================================================
pushd .
#!/usr/bin/env bash
chmod +x /ssd/j/workspace/dotnet_coreclr/dev_unix_test_workflow/jitstress/arm_cross_checked_ubuntu_corefx_baseline_tst_prtest/_/fx/bin/testhost/netcoreapp-Linux-Release-arm/dotnet
/ssd/j/workspace/dotnet_coreclr/dev_unix_test_workflow/jitstress/arm_cross_checked_ubuntu_corefx_baseline_tst_prtest/_/fx/bin/testhost/netcoreapp-Linux-Release-arm/dotnet xunit.console.netcore.exe System.Net.NameResolution.Pal.Tests.dll  -xml testResults.xml -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonlinuxtests  -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing
popd
===========================================================================================================
/ssd/j/workspace/dotnet_coreclr/dev_unix_test_workflow/jitstress/arm_cross_checked_ubuntu_corefx_baseline_tst_prtest/_/fx/bin/tests/System.Net.NameResolution.Pal.Tests/netcoreapp-Linux-Release-arm /ssd/j/workspace/dotnet_coreclr/dev_unix_test_workflow/jitstress/arm_cross_checked_ubuntu_corefx_baseline_tst_prtest/_/fx/bin/tests/System.Net.NameResolution.Pal.Tests/netcoreapp-Linux-Release-arm
xUnit.net console test runner (32-bit .NET Core)
Copyright (C) 2014 Outercurve Foundation.

Discovering: System.Net.NameResolution.Pal.Tests
Discovered:  System.Net.NameResolution.Pal.Tests
Starting:    System.Net.NameResolution.Pal.Tests
   System.Net.NameResolution.PalTests.NameResolutionPalTests.TryGetNameInfo_LocalHost_IPv6_TryGetAddrInfo [FAIL]
      Assert.Equal() Failure
      Expected: Success
      Actual:   HostNotFound
      Stack Trace:
         /mnt/j/workspace/dotnet_coreclr/dev_unix_test_workflow/jitstress/arm_cross_checked_ubuntu_corefx_baseline_prtest/_/fx/src/System.Net.NameResolution/tests/PalTests/NameResolutionPalTests.cs(1610): at System.Net.NameResolution.PalTests.NameResolutionPalTests.TryGetNameInfo_LocalHost_IPv6_TryGetAddrInfo()
   System.Net.NameResolution.PalTests.NameResolutionPalTests.TryGetNameInfo_LocalHost_IPv6 [FAIL]
      Assert.Equal() Failure
      Expected: Success
      Actual:   HostNotFound
      Stack Trace:
         /mnt/j/workspace/dotnet_coreclr/dev_unix_test_workflow/jitstress/arm_cross_checked_ubuntu_corefx_baseline_prtest/_/fx/src/System.Net.NameResolution/tests/PalTests/NameResolutionPalTests.cs(770): at System.Net.NameResolution.PalTests.NameResolutionPalTests.TryGetNameInfo_LocalHost_IPv6()
Finished:    System.Net.NameResolution.Pal.Tests

=== TEST EXECUTION SUMMARY ===
   System.Net.NameResolution.Pal.Tests  Total: 10 Errors: 0 Failed: 2 Skipped: 0 Time: 4.381s
/ssd/j/workspace/dotnet_coreclr/dev_unix_test_workflow/jitstress/arm_cross_checked_ubuntu_corefx_baseline_tst_prtest/_/fx/bin/tests/System.Net.NameResolution.Pal.Tests/netcoreapp-Linux-Release-arm
----- end 04:54:07 ----- exit code 1 ----------------------------------------------------------
```
</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>23/04/2018 9:46:45 PM +00:00</CreatedAt>
    <ClosedAt>23/04/2018 11:47:38 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17739</IssueLabelID>
    <Title>[arm32] corefx System.Net.Http.Functional.Tests fails</Title>
    <Description>60 failures in this test suite:

https://ci.dot.net/job/dotnet_coreclr/job/dev_unix_test_workflow/job/jitstress/job/arm_cross_checked_ubuntu_corefx_baseline_tst_prtest/3/consoleText

Some seem like timeout (which is probably just too tight):
```
System.Net.Http.Functional.Tests.PlatformHandler_HttpClientHandler_Cancellation_Test.GetAsync_CancelDuringResponseHeadersReceived_TaskCanceledQuickly(chunkedTransfer: True connectionClose: True mode: Token) [FAIL]
      Elapsed time 00:00:31.6604110 should be less than 30 seconds was 31.660411
      Expected: True
      Actual:   False
```

There are many other error modes though e.g.
```
      Assert.Throws() Failure
      Expected: typeof(System.Net.Http.HttpRequestException)
      Actual:   typeof(System.Threading.Tasks.TaskCanceledException): A task was canceled.
```
</Description>
    <Title_Description>[arm32] corefx System.Net.Http.Functional.Tests fails 60 failures in this test suite:

https://ci.dot.net/job/dotnet_coreclr/job/dev_unix_test_workflow/job/jitstress/job/arm_cross_checked_ubuntu_corefx_baseline_tst_prtest/3/consoleText

Some seem like timeout (which is probably just too tight):
```
System.Net.Http.Functional.Tests.PlatformHandler_HttpClientHandler_Cancellation_Test.GetAsync_CancelDuringResponseHeadersReceived_TaskCanceledQuickly(chunkedTransfer: True connectionClose: True mode: Token) [FAIL]
      Elapsed time 00:00:31.6604110 should be less than 30 seconds was 31.660411
      Expected: True
      Actual:   False
```

There are many other error modes though e.g.
```
      Assert.Throws() Failure
      Expected: typeof(System.Net.Http.HttpRequestException)
      Actual:   typeof(System.Threading.Tasks.TaskCanceledException): A task was canceled.
```
</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>23/04/2018 9:44:47 PM +00:00</CreatedAt>
    <ClosedAt>23/04/2018 11:47:00 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17738</IssueLabelID>
    <Title>[arm32] Compiler optimization assumption invalid: FAILED: pMgr != 0</Title>
    <Description>In the corefx tests System.Linq.Expressions.Tests:

https://ci.dot.net/job/dotnet_coreclr/job/dev_unix_test_workflow/job/jitstress/job/arm_cross_checked_ubuntu_corefx_baseline_tst_prtest/3/consoleText

```
Running tests in /ssd/j/workspace/dotnet_coreclr/dev_unix_test_workflow/jitstress/arm_cross_checked_ubuntu_corefx_baseline_tst_prtest/_/fx/bin/tests/System.Linq.Expressions.Tests/netcoreapp-Linux-Release-arm
./RunTests.sh /ssd/j/workspace/dotnet_coreclr/dev_unix_test_workflow/jitstress/arm_cross_checked_ubuntu_corefx_baseline_tst_prtest/_/fx/bin/testhost/netcoreapp-Linux-Release-arm

----- start 04:16:15 =============== To repro directly: =====================================================
pushd .
#!/usr/bin/env bash
chmod +x /ssd/j/workspace/dotnet_coreclr/dev_unix_test_workflow/jitstress/arm_cross_checked_ubuntu_corefx_baseline_tst_prtest/_/fx/bin/testhost/netcoreapp-Linux-Release-arm/dotnet
/ssd/j/workspace/dotnet_coreclr/dev_unix_test_workflow/jitstress/arm_cross_checked_ubuntu_corefx_baseline_tst_prtest/_/fx/bin/testhost/netcoreapp-Linux-Release-arm/dotnet xunit.console.netcore.exe System.Linq.Expressions.Tests.dll  -xml testResults.xml -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonlinuxtests  -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing
popd
===========================================================================================================
/ssd/j/workspace/dotnet_coreclr/dev_unix_test_workflow/jitstress/arm_cross_checked_ubuntu_corefx_baseline_tst_prtest/_/fx/bin/tests/System.Linq.Expressions.Tests/netcoreapp-Linux-Release-arm /ssd/j/workspace/dotnet_coreclr/dev_unix_test_workflow/jitstress/arm_cross_checked_ubuntu_corefx_baseline_tst_prtest/_/fx/bin/tests/System.Linq.Expressions.Tests/netcoreapp-Linux-Release-arm
xUnit.net console test runner (32-bit .NET Core)
Copyright (C) 2014 Outercurve Foundation.

Discovering: System.Linq.Expressions.Tests
Discovered:  System.Linq.Expressions.Tests
Starting:    System.Linq.Expressions.Tests

Assert failure(PID 31436 [0x00007acc] Thread: 31465 [0x7ae9]): Compiler optimization assumption invalid: FAILED: pMgr != 0
    File: /mnt/j/workspace/dotnet_coreclr/dev_unix_test_workflow/jitstress/arm_cross_checked_ubuntu_corefx_baseline_prtest/src/vm/virtualcallstub.cpp Line: 1601
    Image: /ssd/j/workspace/dotnet_coreclr/dev_unix_test_workflow/jitstress/arm_cross_checked_ubuntu_corefx_baseline_tst_prtest/_/fx/bin/testhost/netcoreapp-Linux-Release-arm/dotnet


Assert failure(PID 31436 [0x00007acc] Thread: 31465 [0x7ae9]): Compiler optimization assumption invalid: FAILED: pMgr != 0
    File: /mnt/j/workspace/dotnet_coreclr/dev_unix_test_workflow/jitstress/arm_cross_checked_ubuntu_corefx_baseline_prtest/src/vm/virtualcallstub.cpp Line: 1601
    Image: /ssd/j/workspace/dotnet_coreclr/dev_unix_test_workflow/jitstress/arm_cross_checked_ubuntu_corefx_baseline_tst_prtest/_/fx/bin/testhost/netcoreapp-Linux-Release-arm/dotnet

./RunTests.sh: line 126: 31436 Aborted                 $RUNTIME_PATH/dotnet xunit.console.netcore.exe System.Linq.Expressions.Tests.dll -xml testResults.xml -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonlinuxtests -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing
/ssd/j/workspace/dotnet_coreclr/dev_unix_test_workflow/jitstress/arm_cross_checked_ubuntu_corefx_baseline_tst_prtest/_/fx/bin/tests/System.Linq.Expressions.Tests/netcoreapp-Linux-Release-arm
----- end 04:27:34 ----- exit code 134 ----------------------------------------------------------
```
</Description>
    <Title_Description>[arm32] Compiler optimization assumption invalid: FAILED: pMgr != 0 In the corefx tests System.Linq.Expressions.Tests:

https://ci.dot.net/job/dotnet_coreclr/job/dev_unix_test_workflow/job/jitstress/job/arm_cross_checked_ubuntu_corefx_baseline_tst_prtest/3/consoleText

```
Running tests in /ssd/j/workspace/dotnet_coreclr/dev_unix_test_workflow/jitstress/arm_cross_checked_ubuntu_corefx_baseline_tst_prtest/_/fx/bin/tests/System.Linq.Expressions.Tests/netcoreapp-Linux-Release-arm
./RunTests.sh /ssd/j/workspace/dotnet_coreclr/dev_unix_test_workflow/jitstress/arm_cross_checked_ubuntu_corefx_baseline_tst_prtest/_/fx/bin/testhost/netcoreapp-Linux-Release-arm

----- start 04:16:15 =============== To repro directly: =====================================================
pushd .
#!/usr/bin/env bash
chmod +x /ssd/j/workspace/dotnet_coreclr/dev_unix_test_workflow/jitstress/arm_cross_checked_ubuntu_corefx_baseline_tst_prtest/_/fx/bin/testhost/netcoreapp-Linux-Release-arm/dotnet
/ssd/j/workspace/dotnet_coreclr/dev_unix_test_workflow/jitstress/arm_cross_checked_ubuntu_corefx_baseline_tst_prtest/_/fx/bin/testhost/netcoreapp-Linux-Release-arm/dotnet xunit.console.netcore.exe System.Linq.Expressions.Tests.dll  -xml testResults.xml -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonlinuxtests  -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing
popd
===========================================================================================================
/ssd/j/workspace/dotnet_coreclr/dev_unix_test_workflow/jitstress/arm_cross_checked_ubuntu_corefx_baseline_tst_prtest/_/fx/bin/tests/System.Linq.Expressions.Tests/netcoreapp-Linux-Release-arm /ssd/j/workspace/dotnet_coreclr/dev_unix_test_workflow/jitstress/arm_cross_checked_ubuntu_corefx_baseline_tst_prtest/_/fx/bin/tests/System.Linq.Expressions.Tests/netcoreapp-Linux-Release-arm
xUnit.net console test runner (32-bit .NET Core)
Copyright (C) 2014 Outercurve Foundation.

Discovering: System.Linq.Expressions.Tests
Discovered:  System.Linq.Expressions.Tests
Starting:    System.Linq.Expressions.Tests

Assert failure(PID 31436 [0x00007acc] Thread: 31465 [0x7ae9]): Compiler optimization assumption invalid: FAILED: pMgr != 0
    File: /mnt/j/workspace/dotnet_coreclr/dev_unix_test_workflow/jitstress/arm_cross_checked_ubuntu_corefx_baseline_prtest/src/vm/virtualcallstub.cpp Line: 1601
    Image: /ssd/j/workspace/dotnet_coreclr/dev_unix_test_workflow/jitstress/arm_cross_checked_ubuntu_corefx_baseline_tst_prtest/_/fx/bin/testhost/netcoreapp-Linux-Release-arm/dotnet


Assert failure(PID 31436 [0x00007acc] Thread: 31465 [0x7ae9]): Compiler optimization assumption invalid: FAILED: pMgr != 0
    File: /mnt/j/workspace/dotnet_coreclr/dev_unix_test_workflow/jitstress/arm_cross_checked_ubuntu_corefx_baseline_prtest/src/vm/virtualcallstub.cpp Line: 1601
    Image: /ssd/j/workspace/dotnet_coreclr/dev_unix_test_workflow/jitstress/arm_cross_checked_ubuntu_corefx_baseline_tst_prtest/_/fx/bin/testhost/netcoreapp-Linux-Release-arm/dotnet

./RunTests.sh: line 126: 31436 Aborted                 $RUNTIME_PATH/dotnet xunit.console.netcore.exe System.Linq.Expressions.Tests.dll -xml testResults.xml -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonlinuxtests -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing
/ssd/j/workspace/dotnet_coreclr/dev_unix_test_workflow/jitstress/arm_cross_checked_ubuntu_corefx_baseline_tst_prtest/_/fx/bin/tests/System.Linq.Expressions.Tests/netcoreapp-Linux-Release-arm
----- end 04:27:34 ----- exit code 134 ----------------------------------------------------------
```
</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>BruceForstall</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17736</IssueLabelID>
    <Title>headers to use when porting Profiler from windows to linux</Title>
    <Description>I have a CLR profiler that supports dotnet core 2.0 on Windows. Now i wish to port it to build and work on  Linux. I think i need some guidance on what are the best practices and/or an relatively realistic example.

I had started my research based on a sample dotnet core profiler written by MS folks:
https://github.com/Microsoft/clr-samples/tree/master/ProfilingAPI/ReJITEnterLeaveHooks
(recommended starting point as is stated in this issue: https://github.com/dotnet/coreclr/issues/14786). 

This Sample Profiler uses **PAL** and uses `PAL_STDCPP_COMPAT` which i believe would simplify the porting of Windows API. However i found that:
`typedef char16_t WCHAR;` in file `pal_mstypes.h`. 

This is not good because `WCHAR` on Linux is now no longer wchar_t but the old windows code interchangeably uses WCHAR and wchar_t in lots places. So i see lots of compilation error trying to pass `L"foobar"` to Profiling related API that takes `LPWSTR` (e.g. `IMetaDataAssemblyImport-&gt;GetAssemblyProps`).  porting `wchar_t` to `char16_t` is not ideal in this case either. So i concluded that the way that the Sample Profiler is setup probably doesn't suit me well.

In fact there was an issue in the sampler profiler complaining the exact same type compilation error i.e. passing `wchar_t*` to a API that takes `WCHAR*`. And looking at the fix https://github.com/Microsoft/clr-samples/commit/e9e57e5526da374dc8012afee0395aa946515921 the author didn't fix it. He just simply removed the code so it's not helpful. 

Then i start looking at the coreclr source code. I think the Profiler should perhaps use same types defined in the clr itself simply because how closely these two interact.  So My observation shows that `cor.h` (a necessary piece for a profiler) uses **PAL**( e.g. It has to reference `STDMETHOD ` defined in `palrt.h`) however the clr itself uses `WCHAR` defined as `wchar_t` in `pal_mstypes.h` under condition that `PAL_STDCPP_COMPAT` is not defined. So the CLR itself probably doesn't need to port wchar_t string literal to chart_16. 

I feel that Profiler better off uses **PAL** because **CLR** uses it. But Should i use `PAL_STDCPP_COMPAT` as the sample profiler did? If i use it i get WCHAR defined as char16_t which is defined different from coreclr which seems wrong for the Profiler. 

I am little confused because types like `WCHAR `are defined in 3 places(`pal_mstypes.h/PAL_STDCPP_COMPAT` `pal_mtypes.h``clr_types.h`). what headers/Compilation flags should i use  so the types of the Profiler can be the same as in the CoreCLR. It feels like the Profiler writer has to carefully arrange those include headers but i have no clue how?  OR i guess it might be helpful if someone explains in general how the Profiling Interface piece in CLR is built if the Profiler should be doing the same?

</Description>
    <Title_Description>headers to use when porting Profiler from windows to linux I have a CLR profiler that supports dotnet core 2.0 on Windows. Now i wish to port it to build and work on  Linux. I think i need some guidance on what are the best practices and/or an relatively realistic example.

I had started my research based on a sample dotnet core profiler written by MS folks:
https://github.com/Microsoft/clr-samples/tree/master/ProfilingAPI/ReJITEnterLeaveHooks
(recommended starting point as is stated in this issue: https://github.com/dotnet/coreclr/issues/14786). 

This Sample Profiler uses **PAL** and uses `PAL_STDCPP_COMPAT` which i believe would simplify the porting of Windows API. However i found that:
`typedef char16_t WCHAR;` in file `pal_mstypes.h`. 

This is not good because `WCHAR` on Linux is now no longer wchar_t but the old windows code interchangeably uses WCHAR and wchar_t in lots places. So i see lots of compilation error trying to pass `L"foobar"` to Profiling related API that takes `LPWSTR` (e.g. `IMetaDataAssemblyImport-&gt;GetAssemblyProps`).  porting `wchar_t` to `char16_t` is not ideal in this case either. So i concluded that the way that the Sample Profiler is setup probably doesn't suit me well.

In fact there was an issue in the sampler profiler complaining the exact same type compilation error i.e. passing `wchar_t*` to a API that takes `WCHAR*`. And looking at the fix https://github.com/Microsoft/clr-samples/commit/e9e57e5526da374dc8012afee0395aa946515921 the author didn't fix it. He just simply removed the code so it's not helpful. 

Then i start looking at the coreclr source code. I think the Profiler should perhaps use same types defined in the clr itself simply because how closely these two interact.  So My observation shows that `cor.h` (a necessary piece for a profiler) uses **PAL**( e.g. It has to reference `STDMETHOD ` defined in `palrt.h`) however the clr itself uses `WCHAR` defined as `wchar_t` in `pal_mstypes.h` under condition that `PAL_STDCPP_COMPAT` is not defined. So the CLR itself probably doesn't need to port wchar_t string literal to chart_16. 

I feel that Profiler better off uses **PAL** because **CLR** uses it. But Should i use `PAL_STDCPP_COMPAT` as the sample profiler did? If i use it i get WCHAR defined as char16_t which is defined different from coreclr which seems wrong for the Profiler. 

I am little confused because types like `WCHAR `are defined in 3 places(`pal_mstypes.h/PAL_STDCPP_COMPAT` `pal_mtypes.h``clr_types.h`). what headers/Compilation flags should i use  so the types of the Profiler can be the same as in the CoreCLR. It feels like the Profiler writer has to carefully arrange those include headers but i have no clue how?  OR i guess it might be helpful if someone explains in general how the Profiling Interface piece in CLR is built if the Profiler should be doing the same?

</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>23/04/2018 4:28:50 PM +00:00</CreatedAt>
    <ClosedAt>24/04/2018 1:58:54 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17735</IssueLabelID>
    <Title>[Question] R2R and version bubbles</Title>
    <Description>As I understand the main motivation to create Ready To Run mode of crossgen is making native images are more independent from runtime change. What is the current state of it? Should we regenerate application native images in case of updating runtime or system libraries (of course I mean case when API isn't changed)?

Second question is about version bubbles. As I see from source code (https://github.com/dotnet/coreclr/blob/master/src/vm/jitinterface.cpp#L654) `Version bubble == Assembly`. Are there any plans to implement this concept?
What projects will needed changes to support this? Except CoreCLR I think compiler should know about bubbles. Are there any other projects?

cc @jkotas @BruceForstall @gbalykov </Description>
    <Title_Description>[Question] R2R and version bubbles As I understand the main motivation to create Ready To Run mode of crossgen is making native images are more independent from runtime change. What is the current state of it? Should we regenerate application native images in case of updating runtime or system libraries (of course I mean case when API isn't changed)?

Second question is about version bubbles. As I see from source code (https://github.com/dotnet/coreclr/blob/master/src/vm/jitinterface.cpp#L654) `Version bubble == Assembly`. Are there any plans to implement this concept?
What projects will needed changes to support this? Except CoreCLR I think compiler should know about bubbles. Are there any other projects?

cc @jkotas @BruceForstall @gbalykov </Title_Description>
    <Label>area-ReadyToRun</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>23/04/2018 4:05:10 PM +00:00</CreatedAt>
    <ClosedAt>4/05/2018 4:36:28 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17733</IssueLabelID>
    <Title>Expand GT_JCC/SETCC condition support</Title>
    <Description>Currently GT_JCC/SETCC nodes use relops as condition codes and this prevents the use of flag specific conditions (e.g. S NS P NP) and floating point conditions. Additionally the code used by GT_JTRUE and relop codegen is rather convoluted and not very easy to reuse for GT_JCC/SETCC codegen.

This changes GT_JCC/SETCC's condition to `GenCondition` a class that can encode all necessary conditions - signed/unsigned integral conditions ordered/unordered floating point conditions and flag specific conditions. Mapping between `GenCondition` codes and emitter jump kinds is done via arch specific tables instead of `genJumpKindForOper` and `genJumpKindsForTree`.

GT_JTRUE codegen has been updated to also use `GenCondition` so that `genJumpKindForOper` and `genJumpKindsForTree` can be removed.

Contributes to #17073</Description>
    <Title_Description>Expand GT_JCC/SETCC condition support Currently GT_JCC/SETCC nodes use relops as condition codes and this prevents the use of flag specific conditions (e.g. S NS P NP) and floating point conditions. Additionally the code used by GT_JTRUE and relop codegen is rather convoluted and not very easy to reuse for GT_JCC/SETCC codegen.

This changes GT_JCC/SETCC's condition to `GenCondition` a class that can encode all necessary conditions - signed/unsigned integral conditions ordered/unordered floating point conditions and flag specific conditions. Mapping between `GenCondition` codes and emitter jump kinds is done via arch specific tables instead of `genJumpKindForOper` and `genJumpKindsForTree`.

GT_JTRUE codegen has been updated to also use `GenCondition` so that `genJumpKindForOper` and `genJumpKindsForTree` can be removed.

Contributes to #17073</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>dotnet-bot</Assignee>
    <CreatedAt>23/04/2018 3:18:51 PM +00:00</CreatedAt>
    <ClosedAt>11/01/2019 12:29:43 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17732</IssueLabelID>
    <Title>Enable Invoke and GetValue for ref-returning members</Title>
    <Description>https://github.com/dotnet/corefx/issues/15960

(Attempt #2)

Returned magic object is the object pointed to by
the ref. If the ref is null NullReferenceException.

</Description>
    <Title_Description>Enable Invoke and GetValue for ref-returning members https://github.com/dotnet/corefx/issues/15960

(Attempt #2)

Returned magic object is the object pointed to by
the ref. If the ref is null NullReferenceException.

</Title_Description>
    <Label>area-System.Reflection</Label>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>26685</IssueLabelID>
    <Title>Requesting support for Linux-ARM w/ 16 FPU registers</Title>
    <Description>Hi

Our Business Units widely use ARM based CPU to develop hardware solutions for automation and energy management.

We appreciate Microsoft’s decision to support native .Net Core deployment for linux-arm target. We have positive results of self-contained deployments for Cortex-A9 based devices. It’ll really speed up development-to-deployment-to-market process.

During one of our POC projects we’ve identified that some of chips (e.q. RZ/N1D) extensively used by our BU aren’t compatible with current linux-arm runtime and generate “Illegal Instruction” exception.

Further investigation revealed very simple but critical incompatibility: this chip’s FPU includes only 16 double-precision registers. Seems like simple change of cross-compiler option from vfpv3 to vfpv3-d16 [or vfpv4-d16] to generate runtime libraries should solve this problem. 

An alternative solution would be to support linux-armel target i.e. do not use Floating Point Unit at all though the previously outlined solution would be preferable.

Would you please consider building and including runtime specific packages for linux-arm-VFPv4-d16 and/or linux-armel devices. 

</Description>
    <Title_Description>Requesting support for Linux-ARM w/ 16 FPU registers Hi

Our Business Units widely use ARM based CPU to develop hardware solutions for automation and energy management.

We appreciate Microsoft’s decision to support native .Net Core deployment for linux-arm target. We have positive results of self-contained deployments for Cortex-A9 based devices. It’ll really speed up development-to-deployment-to-market process.

During one of our POC projects we’ve identified that some of chips (e.q. RZ/N1D) extensively used by our BU aren’t compatible with current linux-arm runtime and generate “Illegal Instruction” exception.

Further investigation revealed very simple but critical incompatibility: this chip’s FPU includes only 16 double-precision registers. Seems like simple change of cross-compiler option from vfpv3 to vfpv3-d16 [or vfpv4-d16] to generate runtime libraries should solve this problem. 

An alternative solution would be to support linux-armel target i.e. do not use Floating Point Unit at all though the previously outlined solution would be preferable.

Would you please consider building and including runtime specific packages for linux-arm-VFPv4-d16 and/or linux-armel devices. 

</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>richlander</Assignee>
    <CreatedAt>23/04/2018 12:49:39 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17731</IssueLabelID>
    <Title>C++ calls.Netcore through coreclr</Title>
    <Description>Hi
https://docs.microsoft.com/en-us/dotnet/core/tutorials/netcore-hosting
In accordance with this document I call the.Netcore class library through the coreclr host when I execute it.
CreateDelegate function times error error: the given assembly name or base code is invalid.</Description>
    <Title_Description>C++ calls.Netcore through coreclr Hi
https://docs.microsoft.com/en-us/dotnet/core/tutorials/netcore-hosting
In accordance with this document I call the.Netcore class library through the coreclr host when I execute it.
CreateDelegate function times error error: the given assembly name or base code is invalid.</Title_Description>
    <Label>area-AssemblyLoader</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>23/04/2018 4:25:41 AM +00:00</CreatedAt>
    <ClosedAt>1/05/2018 3:49:21 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17724</IssueLabelID>
    <Title>Fix FakePromote assert</Title>
    <Description>This assert was firing when there was a struct with explicit layout and
two byref fields overlapping each other. The assert was checking that
the respective location on the stack was not reported yet.
To fix that I have changed the assert to fire only if the already
reported kind of reference was different from the current one. That
enables overlapping of two byref fields or two ref fields but not a
byref and ref fields.

Close #17565</Description>
    <Title_Description>Fix FakePromote assert This assert was firing when there was a struct with explicit layout and
two byref fields overlapping each other. The assert was checking that
the respective location on the stack was not reported yet.
To fix that I have changed the assert to fire only if the already
reported kind of reference was different from the current one. That
enables overlapping of two byref fields or two ref fields but not a
byref and ref fields.

Close #17565</Title_Description>
    <Label>area-CrossGen/NGEN</Label>
    <Assignee>janvorli</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17716</IssueLabelID>
    <Title>GC crash in Kestrel Libuv and Sockets FunctionalTests/netcoreapp2.1</Title>
    <Description>_From @mikeharder on April 18 2018 18:42_

Kestrel FunctionalTests are hanging frequently on CI:

# KestrelHttpServer
```
[17:46:13] :	 [Step 4/7]   Starting test group: Libuv.FunctionalTests/netcoreapp2.1
[17:46:13] :	 [Step 4/7]   Microsoft (R) Test Execution Command Line Tool Version 15.7.0-preview-20180221-13
[17:46:13] :	 [Step 4/7]   Copyright (c) Microsoft Corporation.  All rights reserved.
[17:46:13] :	 [Step 4/7]   
[17:46:14] :	 [Step 4/7]   Starting test execution please wait...
[17:46:14] :	 [Step 4/7]   Logging Vstest Diagnostics in file: C:\b\w\1e8cd6334ef22651\artifacts\logs\Libuv.FunctionalTests-netcoreapp2.1-17674.diag
[17:46:15] :	 [Step 4/7]   [xUnit.net 00:00:00.7203468]     RegisterAddresses_IPv6_Success [SKIP]
[17:46:15] :	 [Step 4/7]   Skipped  RegisterAddresses_IPv6_Success
[17:46:15] :	 [Step 4/7]   [xUnit.net 00:00:01.2412585]     ConnectionCountingReturnsToZero [SKIP]
[17:46:15] :	 [Step 4/7]   Skipped  ConnectionCountingReturnsToZero
[17:46:15] :	 [Step 4/7]   [xUnit.net 00:00:01.3837697]     CanListenToOpenTcpSocketHandle [SKIP]
[17:46:15] :	 [Step 4/7]   Skipped  CanListenToOpenTcpSocketHandle
[17:46:16] :	 [Step 4/7]   [xUnit.net 00:00:02.0159475]     RegisterAddresses_IPv4Port80_Success(addressInput: "http://*" testUrl: "http://127.0.0.1") [SKIP]
[17:46:16] :	 [Step 4/7]   [xUnit.net 00:00:02.0164664]     RegisterAddresses_IPv4Port80_Success(addressInput: "http://127.0.0.1" testUrl: "http://127.0.0.1") [SKIP]
[17:46:16] :	 [Step 4/7]   [xUnit.net 00:00:02.0178708]     RegisterAddresses_IPv4Port80_Success(addressInput: "http://localhost" testUrl: "http://127.0.0.1") [SKIP]
[17:46:16] :	 [Step 4/7]   Skipped  RegisterAddresses_IPv4Port80_Success(addressInput: "http://*" testUrl: "http://127.0.0.1")
[17:46:16] :	 [Step 4/7]   Skipped  RegisterAddresses_IPv4Port80_Success(addressInput: "http://127.0.0.1" testUrl: "http://127.0.0.1")
[17:46:16] :	 [Step 4/7]   Skipped  RegisterAddresses_IPv4Port80_Success(addressInput: "http://localhost" testUrl: "http://127.0.0.1")
[17:46:16] :	 [Step 4/7]   [xUnit.net 00:00:02.2575826]     ConnectionClosedEvenIfAppSwallowsException [SKIP]
[17:46:16] :	 [Step 4/7]   Skipped  ConnectionClosedEvenIfAppSwallowsException
[17:46:18] :	 [Step 4/7]   [xUnit.net 00:00:03.6803851]     RegisterAddresses_IPv6Port80_Success(addressInput: "http://localhost" testUrls: ["http://127.0.0.1/" "http://[::1]/"]) [SKIP]
[17:46:18] :	 [Step 4/7]   [xUnit.net 00:00:03.6808460]     RegisterAddresses_IPv6Port80_Success(addressInput: "http://*" testUrls: ["http://[::1]/"]) [SKIP]
[17:46:18] :	 [Step 4/7]   [xUnit.net 00:00:03.6812519]     RegisterAddresses_IPv6Port80_Success(addressInput: "http://[::1]" testUrls: ["http://[::1]/"]) [SKIP]
[17:46:18] :	 [Step 4/7]   Skipped  RegisterAddresses_IPv6Port80_Success(addressInput: "http://localhost" testUrls: ["http://127.0.0.1/" "http://[::1]/"])
[17:46:18] :	 [Step 4/7]   Skipped  RegisterAddresses_IPv6Port80_Success(addressInput: "http://*" testUrls: ["http://[::1]/"])
[17:46:18] :	 [Step 4/7]   Skipped  RegisterAddresses_IPv6Port80_Success(addressInput: "http://[::1]" testUrls: ["http://[::1]/"])
[18:39:33]E:	 [Step 4/7] The build Projects::KestrelHttpServer #17674 {buildId=449083} has been running for more than 60 minutes. Terminating...
```
http://aspnetci/viewLog.html?buildId=449083&amp;buildTypeId=Lite_KestrelHttpServer&amp;tab=buildLog&amp;_focus=39538

```
[14:35:15] :	 [Step 4/7]   Starting test group: Libuv.FunctionalTests/netcoreapp2.1
[14:35:15] :	 [Step 4/7] Microsoft (R) Test Execution Command Line Tool Version 15.7.0-preview-20180221-13
[14:35:15] :	 [Step 4/7] Copyright (c) Microsoft Corporation.  All rights reserved.
[14:35:15] :	 [Step 4/7] 
[14:35:15] :	 [Step 4/7] Starting test execution please wait...
[14:35:15] :	 [Step 4/7] Logging Vstest Diagnostics in file: D:\b\w\1e8cd6334ef22651\artifacts\logs\Libuv.FunctionalTests-netcoreapp2.1-17658.diag
[14:35:17] :	 [Step 4/7] [xUnit.net 00:00:00.9797507]     CanListenToOpenTcpSocketHandle [SKIP]
[14:35:17] :	 [Step 4/7] Skipped  CanListenToOpenTcpSocketHandle
[14:35:17] :	 [Step 4/7] [xUnit.net 00:00:01.1545963]     ConnectionClosedEvenIfAppSwallowsException [SKIP]
[14:35:17] :	 [Step 4/7] Skipped  ConnectionClosedEvenIfAppSwallowsException
[14:35:18] :	 [Step 4/7] [xUnit.net 00:00:01.9128535]     ConnectionCountingReturnsToZero [SKIP]
[14:35:18] :	 [Step 4/7] Skipped  ConnectionCountingReturnsToZero
[14:35:19] :	 [Step 4/7] [xUnit.net 00:00:03.0442866]     RegisterAddresses_IPv6Port80_Success(addressInput: "http://[::1]" testUrls: ["http://[::1]/"]) [SKIP]
[14:35:19] :	 [Step 4/7] [xUnit.net 00:00:03.0448370]     RegisterAddresses_IPv6Port80_Success(addressInput: "http://*" testUrls: ["http://[::1]/"]) [SKIP]
[14:35:19] :	 [Step 4/7] Skipped  RegisterAddresses_IPv6Port80_Success(addressInput: "http://[::1]" testUrls: ["http://[::1]/"])
[14:35:19] :	 [Step 4/7] Skipped  RegisterAddresses_IPv6Port80_Success(addressInput: "http://*" testUrls: ["http://[::1]/"])
[14:35:19] :	 [Step 4/7] [xUnit.net 00:00:03.0461888]     RegisterAddresses_IPv6Port80_Success(addressInput: "http://localhost" testUrls: ["http://127.0.0.1/" "http://[::1]/"]) [SKIP]
[14:35:19] :	 [Step 4/7] Skipped  RegisterAddresses_IPv6Port80_Success(addressInput: "http://localhost" testUrls: ["http://127.0.0.1/" "http://[::1]/"])
[14:35:19] :	 [Step 4/7] [xUnit.net 00:00:03.0852291]     RegisterAddresses_IPv4Port80_Success(addressInput: "http://127.0.0.1" testUrl: "http://127.0.0.1") [SKIP]
[14:35:19] :	 [Step 4/7] [xUnit.net 00:00:03.0856344]     RegisterAddresses_IPv4Port80_Success(addressInput: "http://*" testUrl: "http://127.0.0.1") [SKIP]
[14:35:19] :	 [Step 4/7] [xUnit.net 00:00:03.0858760]     RegisterAddresses_IPv4Port80_Success(addressInput: "http://localhost" testUrl: "http://127.0.0.1") [SKIP]
[14:35:19] :	 [Step 4/7] Skipped  RegisterAddresses_IPv4Port80_Success(addressInput: "http://127.0.0.1" testUrl: "http://127.0.0.1")
[14:35:19] :	 [Step 4/7] Skipped  RegisterAddresses_IPv4Port80_Success(addressInput: "http://*" testUrl: "http://127.0.0.1")
[14:35:19] :	 [Step 4/7] Skipped  RegisterAddresses_IPv4Port80_Success(addressInput: "http://localhost" testUrl: "http://127.0.0.1")
[14:35:20] :	 [Step 4/7] [xUnit.net 00:00:03.6085756]     RegisterAddresses_IPv6_Success [SKIP]
[14:35:20] :	 [Step 4/7] Skipped  RegisterAddresses_IPv6_Success
[15:28:52]E:	 [Step 4/7] The build Projects::KestrelHttpServer #17658 {buildId=445522} has been running for more than 60 minutes. Terminating...
[15:28:52]E:	 [Step 4/7] Execution timeout
```
http://aspnetci/viewLog.html?buildId=445522&amp;buildTypeId=Lite_KestrelHttpServer&amp;tab=buildLog

# Win2012-Kestrel
```
[23:37:09] :     [Step 8/9]   Skipped  RegisterAddresses_IPv6Port80_Success(addressInput: "http://localhost" testUrls: ["http://127.0.0.1/" "http://[::1]/"])
[23:37:09] :     [Step 8/9]   Skipped  RegisterAddresses_IPv6Port80_Success(addressInput: "http://[::1]" testUrls: ["http://[::1]/"])
[00:50:45]E:     [Step 8/9] The build Test::Win2012-Kestrel #2.2.0-preview1-34007 {buildId=449994} has been running for more than 120 minutes. Terminating...
[00:50:45]E:     [Step 8/9] Execution timeout
```
http://aspnetci/viewLog.html?buildId=449994&amp;tab=buildLog&amp;buildTypeId=Lite_KestrelStressTest&amp;logTab=tail

_Copied from original issue: aspnet/KestrelHttpServer#2503_</Description>
    <Title_Description>GC crash in Kestrel Libuv and Sockets FunctionalTests/netcoreapp2.1 _From @mikeharder on April 18 2018 18:42_

Kestrel FunctionalTests are hanging frequently on CI:

# KestrelHttpServer
```
[17:46:13] :	 [Step 4/7]   Starting test group: Libuv.FunctionalTests/netcoreapp2.1
[17:46:13] :	 [Step 4/7]   Microsoft (R) Test Execution Command Line Tool Version 15.7.0-preview-20180221-13
[17:46:13] :	 [Step 4/7]   Copyright (c) Microsoft Corporation.  All rights reserved.
[17:46:13] :	 [Step 4/7]   
[17:46:14] :	 [Step 4/7]   Starting test execution please wait...
[17:46:14] :	 [Step 4/7]   Logging Vstest Diagnostics in file: C:\b\w\1e8cd6334ef22651\artifacts\logs\Libuv.FunctionalTests-netcoreapp2.1-17674.diag
[17:46:15] :	 [Step 4/7]   [xUnit.net 00:00:00.7203468]     RegisterAddresses_IPv6_Success [SKIP]
[17:46:15] :	 [Step 4/7]   Skipped  RegisterAddresses_IPv6_Success
[17:46:15] :	 [Step 4/7]   [xUnit.net 00:00:01.2412585]     ConnectionCountingReturnsToZero [SKIP]
[17:46:15] :	 [Step 4/7]   Skipped  ConnectionCountingReturnsToZero
[17:46:15] :	 [Step 4/7]   [xUnit.net 00:00:01.3837697]     CanListenToOpenTcpSocketHandle [SKIP]
[17:46:15] :	 [Step 4/7]   Skipped  CanListenToOpenTcpSocketHandle
[17:46:16] :	 [Step 4/7]   [xUnit.net 00:00:02.0159475]     RegisterAddresses_IPv4Port80_Success(addressInput: "http://*" testUrl: "http://127.0.0.1") [SKIP]
[17:46:16] :	 [Step 4/7]   [xUnit.net 00:00:02.0164664]     RegisterAddresses_IPv4Port80_Success(addressInput: "http://127.0.0.1" testUrl: "http://127.0.0.1") [SKIP]
[17:46:16] :	 [Step 4/7]   [xUnit.net 00:00:02.0178708]     RegisterAddresses_IPv4Port80_Success(addressInput: "http://localhost" testUrl: "http://127.0.0.1") [SKIP]
[17:46:16] :	 [Step 4/7]   Skipped  RegisterAddresses_IPv4Port80_Success(addressInput: "http://*" testUrl: "http://127.0.0.1")
[17:46:16] :	 [Step 4/7]   Skipped  RegisterAddresses_IPv4Port80_Success(addressInput: "http://127.0.0.1" testUrl: "http://127.0.0.1")
[17:46:16] :	 [Step 4/7]   Skipped  RegisterAddresses_IPv4Port80_Success(addressInput: "http://localhost" testUrl: "http://127.0.0.1")
[17:46:16] :	 [Step 4/7]   [xUnit.net 00:00:02.2575826]     ConnectionClosedEvenIfAppSwallowsException [SKIP]
[17:46:16] :	 [Step 4/7]   Skipped  ConnectionClosedEvenIfAppSwallowsException
[17:46:18] :	 [Step 4/7]   [xUnit.net 00:00:03.6803851]     RegisterAddresses_IPv6Port80_Success(addressInput: "http://localhost" testUrls: ["http://127.0.0.1/" "http://[::1]/"]) [SKIP]
[17:46:18] :	 [Step 4/7]   [xUnit.net 00:00:03.6808460]     RegisterAddresses_IPv6Port80_Success(addressInput: "http://*" testUrls: ["http://[::1]/"]) [SKIP]
[17:46:18] :	 [Step 4/7]   [xUnit.net 00:00:03.6812519]     RegisterAddresses_IPv6Port80_Success(addressInput: "http://[::1]" testUrls: ["http://[::1]/"]) [SKIP]
[17:46:18] :	 [Step 4/7]   Skipped  RegisterAddresses_IPv6Port80_Success(addressInput: "http://localhost" testUrls: ["http://127.0.0.1/" "http://[::1]/"])
[17:46:18] :	 [Step 4/7]   Skipped  RegisterAddresses_IPv6Port80_Success(addressInput: "http://*" testUrls: ["http://[::1]/"])
[17:46:18] :	 [Step 4/7]   Skipped  RegisterAddresses_IPv6Port80_Success(addressInput: "http://[::1]" testUrls: ["http://[::1]/"])
[18:39:33]E:	 [Step 4/7] The build Projects::KestrelHttpServer #17674 {buildId=449083} has been running for more than 60 minutes. Terminating...
```
http://aspnetci/viewLog.html?buildId=449083&amp;buildTypeId=Lite_KestrelHttpServer&amp;tab=buildLog&amp;_focus=39538

```
[14:35:15] :	 [Step 4/7]   Starting test group: Libuv.FunctionalTests/netcoreapp2.1
[14:35:15] :	 [Step 4/7] Microsoft (R) Test Execution Command Line Tool Version 15.7.0-preview-20180221-13
[14:35:15] :	 [Step 4/7] Copyright (c) Microsoft Corporation.  All rights reserved.
[14:35:15] :	 [Step 4/7] 
[14:35:15] :	 [Step 4/7] Starting test execution please wait...
[14:35:15] :	 [Step 4/7] Logging Vstest Diagnostics in file: D:\b\w\1e8cd6334ef22651\artifacts\logs\Libuv.FunctionalTests-netcoreapp2.1-17658.diag
[14:35:17] :	 [Step 4/7] [xUnit.net 00:00:00.9797507]     CanListenToOpenTcpSocketHandle [SKIP]
[14:35:17] :	 [Step 4/7] Skipped  CanListenToOpenTcpSocketHandle
[14:35:17] :	 [Step 4/7] [xUnit.net 00:00:01.1545963]     ConnectionClosedEvenIfAppSwallowsException [SKIP]
[14:35:17] :	 [Step 4/7] Skipped  ConnectionClosedEvenIfAppSwallowsException
[14:35:18] :	 [Step 4/7] [xUnit.net 00:00:01.9128535]     ConnectionCountingReturnsToZero [SKIP]
[14:35:18] :	 [Step 4/7] Skipped  ConnectionCountingReturnsToZero
[14:35:19] :	 [Step 4/7] [xUnit.net 00:00:03.0442866]     RegisterAddresses_IPv6Port80_Success(addressInput: "http://[::1]" testUrls: ["http://[::1]/"]) [SKIP]
[14:35:19] :	 [Step 4/7] [xUnit.net 00:00:03.0448370]     RegisterAddresses_IPv6Port80_Success(addressInput: "http://*" testUrls: ["http://[::1]/"]) [SKIP]
[14:35:19] :	 [Step 4/7] Skipped  RegisterAddresses_IPv6Port80_Success(addressInput: "http://[::1]" testUrls: ["http://[::1]/"])
[14:35:19] :	 [Step 4/7] Skipped  RegisterAddresses_IPv6Port80_Success(addressInput: "http://*" testUrls: ["http://[::1]/"])
[14:35:19] :	 [Step 4/7] [xUnit.net 00:00:03.0461888]     RegisterAddresses_IPv6Port80_Success(addressInput: "http://localhost" testUrls: ["http://127.0.0.1/" "http://[::1]/"]) [SKIP]
[14:35:19] :	 [Step 4/7] Skipped  RegisterAddresses_IPv6Port80_Success(addressInput: "http://localhost" testUrls: ["http://127.0.0.1/" "http://[::1]/"])
[14:35:19] :	 [Step 4/7] [xUnit.net 00:00:03.0852291]     RegisterAddresses_IPv4Port80_Success(addressInput: "http://127.0.0.1" testUrl: "http://127.0.0.1") [SKIP]
[14:35:19] :	 [Step 4/7] [xUnit.net 00:00:03.0856344]     RegisterAddresses_IPv4Port80_Success(addressInput: "http://*" testUrl: "http://127.0.0.1") [SKIP]
[14:35:19] :	 [Step 4/7] [xUnit.net 00:00:03.0858760]     RegisterAddresses_IPv4Port80_Success(addressInput: "http://localhost" testUrl: "http://127.0.0.1") [SKIP]
[14:35:19] :	 [Step 4/7] Skipped  RegisterAddresses_IPv4Port80_Success(addressInput: "http://127.0.0.1" testUrl: "http://127.0.0.1")
[14:35:19] :	 [Step 4/7] Skipped  RegisterAddresses_IPv4Port80_Success(addressInput: "http://*" testUrl: "http://127.0.0.1")
[14:35:19] :	 [Step 4/7] Skipped  RegisterAddresses_IPv4Port80_Success(addressInput: "http://localhost" testUrl: "http://127.0.0.1")
[14:35:20] :	 [Step 4/7] [xUnit.net 00:00:03.6085756]     RegisterAddresses_IPv6_Success [SKIP]
[14:35:20] :	 [Step 4/7] Skipped  RegisterAddresses_IPv6_Success
[15:28:52]E:	 [Step 4/7] The build Projects::KestrelHttpServer #17658 {buildId=445522} has been running for more than 60 minutes. Terminating...
[15:28:52]E:	 [Step 4/7] Execution timeout
```
http://aspnetci/viewLog.html?buildId=445522&amp;buildTypeId=Lite_KestrelHttpServer&amp;tab=buildLog

# Win2012-Kestrel
```
[23:37:09] :     [Step 8/9]   Skipped  RegisterAddresses_IPv6Port80_Success(addressInput: "http://localhost" testUrls: ["http://127.0.0.1/" "http://[::1]/"])
[23:37:09] :     [Step 8/9]   Skipped  RegisterAddresses_IPv6Port80_Success(addressInput: "http://[::1]" testUrls: ["http://[::1]/"])
[00:50:45]E:     [Step 8/9] The build Test::Win2012-Kestrel #2.2.0-preview1-34007 {buildId=449994} has been running for more than 120 minutes. Terminating...
[00:50:45]E:     [Step 8/9] Execution timeout
```
http://aspnetci/viewLog.html?buildId=449994&amp;tab=buildLog&amp;buildTypeId=Lite_KestrelStressTest&amp;logTab=tail

_Copied from original issue: aspnet/KestrelHttpServer#2503_</Title_Description>
    <Label>area-GC</Label>
    <Assignee>jkotas</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17714</IssueLabelID>
    <Title>[release/2.1] Port Preserve pinned flag in {ReadOnly}Memory&lt;T&gt;.Slice</Title>
    <Description>Fixes https://github.com/dotnet/corefx/issues/29239 (from https://github.com/dotnet/coreclr/pull/17712)

cc @joshfree @GrabYourPitchforks @geoffkizer @stephentoub @benaadams @davidfowl  </Description>
    <Title_Description>[release/2.1] Port Preserve pinned flag in {ReadOnly}Memory&lt;T&gt;.Slice Fixes https://github.com/dotnet/corefx/issues/29239 (from https://github.com/dotnet/coreclr/pull/17712)

cc @joshfree @GrabYourPitchforks @geoffkizer @stephentoub @benaadams @davidfowl  </Title_Description>
    <Label>area-System.Memory</Label>
    <Assignee>ahsonkhan</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17712</IssueLabelID>
    <Title>Mirror changes from dotnet/corefx</Title>
    <Description>This PR contains mirrored changes from dotnet/corefx


**Please REBASE this PR when merging**</Description>
    <Title_Description>Mirror changes from dotnet/corefx This PR contains mirrored changes from dotnet/corefx


**Please REBASE this PR when merging**</Title_Description>
    <Label>
    </Label>
    <Assignee>ahsonkhan</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17711</IssueLabelID>
    <Title>Fix getting the Absolute path while looking up the TZ files</Title>
    <Description>We used to call Path.Combine and passing 2 file paths (and not really a directory paths) which always produced a wrong full path. This causes us to always go and enumerate TZ files and compare the content of each file to the current TZ data we have. So this should speed up the TZ creation on Linux as we'll not enumerate the TZ files. 

Also this will fix getting the correct Id of the TZ. for example when trying to get the Iran time zone currently we'll get the Id= "Iran" as this is the TZ file name. while after the fix we'll get the correct Id= "Asia/Tehran" </Description>
    <Title_Description>Fix getting the Absolute path while looking up the TZ files We used to call Path.Combine and passing 2 file paths (and not really a directory paths) which always produced a wrong full path. This causes us to always go and enumerate TZ files and compare the content of each file to the current TZ data we have. So this should speed up the TZ creation on Linux as we'll not enumerate the TZ files. 

Also this will fix getting the correct Id of the TZ. for example when trying to get the Iran time zone currently we'll get the Id= "Iran" as this is the TZ file name. while after the fix we'll get the correct Id= "Asia/Tehran" </Title_Description>
    <Label>area-System.Runtime</Label>
    <Assignee>tarekgh</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17709</IssueLabelID>
    <Title>Mirror changes from dotnet/corefx</Title>
    <Description>This PR contains mirrored changes from dotnet/corefx


**Please REBASE this PR when merging**</Description>
    <Title_Description>Mirror changes from dotnet/corefx This PR contains mirrored changes from dotnet/corefx


**Please REBASE this PR when merging**</Title_Description>
    <Label>
    </Label>
    <Assignee>ahsonkhan</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17706</IssueLabelID>
    <Title>[x86|Windows|Full Framework|NativeVararg] Passing an eight byte struct of long</Title>
    <Description>c#

```
[DllImport("examplenativedll" CallingConvention = CallingConvention.Cdecl]
extern static int test_passing_struct(int count __arglist);

struct EightByteStruct
{
   public long a;
}

...

EightByteStruct ebs = new EightByteStruct();
ebs.a = 100.0;

// va_list in native function will read 0.
test_passing_struct(1 ebs);

```
</Description>
    <Title_Description>[x86|Windows|Full Framework|NativeVararg] Passing an eight byte struct of long c#

```
[DllImport("examplenativedll" CallingConvention = CallingConvention.Cdecl]
extern static int test_passing_struct(int count __arglist);

struct EightByteStruct
{
   public long a;
}

...

EightByteStruct ebs = new EightByteStruct();
ebs.a = 100.0;

// va_list in native function will read 0.
test_passing_struct(1 ebs);

```
</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>pgavlin</Assignee>
    <CreatedAt>20/04/2018 7:08:31 PM +00:00</CreatedAt>
    <ClosedAt>21/04/2018 2:31:42 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17704</IssueLabelID>
    <Title>[x86|Windows|Full Framework| NativeVararg] Passing a double after an int/long results in bad codegen</Title>
    <Description>C#

```
[DllImport("msvcrt" CallingConvention = CallingConvention.Cdecl]
extern static void printf(string s __arglist);


...

string format = "%d%d%f\n"

// Prints most likely 0 2 0.000
printf(format __arglist(0 2 2.1));

```
</Description>
    <Title_Description>[x86|Windows|Full Framework| NativeVararg] Passing a double after an int/long results in bad codegen C#

```
[DllImport("msvcrt" CallingConvention = CallingConvention.Cdecl]
extern static void printf(string s __arglist);


...

string format = "%d%d%f\n"

// Prints most likely 0 2 0.000
printf(format __arglist(0 2 2.1));

```
</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>jashook</Assignee>
    <CreatedAt>20/04/2018 7:04:20 PM +00:00</CreatedAt>
    <ClosedAt>21/04/2018 2:31:56 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17703</IssueLabelID>
    <Title>[x64|Windows|Full Framework] Passing 32 byte struct of four doubles with native varargs results in bad codegen</Title>
    <Description>c#

```
[DllImport("examplenativedll" CallingConvention = CallingConvention.Cdecl]
extern static int test_passing_struct(int count __arglist);

struct ThirtyTwoByteStruct
{
   public double a;
   public double b;
   public double c;
   public double d;
}

...

ThirtyTwoByteStruct ebs = new ThirtyTwoByteStruct();
ebs.a = 100.0;
ebs.b = 101.0;
ebs.c = 102.0;
ebs.d = 103.0;

// va_list in native function will read junk.
test_passing_struct(1 ebs);

```

Note this is may be related to #17702.
</Description>
    <Title_Description>[x64|Windows|Full Framework] Passing 32 byte struct of four doubles with native varargs results in bad codegen c#

```
[DllImport("examplenativedll" CallingConvention = CallingConvention.Cdecl]
extern static int test_passing_struct(int count __arglist);

struct ThirtyTwoByteStruct
{
   public double a;
   public double b;
   public double c;
   public double d;
}

...

ThirtyTwoByteStruct ebs = new ThirtyTwoByteStruct();
ebs.a = 100.0;
ebs.b = 101.0;
ebs.c = 102.0;
ebs.d = 103.0;

// va_list in native function will read junk.
test_passing_struct(1 ebs);

```

Note this is may be related to #17702.
</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>jashook</Assignee>
    <CreatedAt>20/04/2018 6:40:07 PM +00:00</CreatedAt>
    <ClosedAt>20/04/2018 7:10:59 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17702</IssueLabelID>
    <Title>[x86|x64|Windows|Full Framework|NativeVararg] Passing 16 byte struct of two longs results in bad codegen</Title>
    <Description>C#

```
[DllImport("examplenativedll" CallingConvention = CallingConvention.Cdecl]
extern static int test_passing_struct(int count __arglist);

struct SixteenByteStruct
{
   long a;
   long b;
}

...

SixteenByteStruct ebs = new SixteenByteStruct();
ebs.a = 100;
ebs.b = 101;

// va_list in native function will read junk.
test_passing_struct(1 ebs);

```

Note this fails on x86 as well as x64 but may be two separate issues.</Description>
    <Title_Description>[x86|x64|Windows|Full Framework|NativeVararg] Passing 16 byte struct of two longs results in bad codegen C#

```
[DllImport("examplenativedll" CallingConvention = CallingConvention.Cdecl]
extern static int test_passing_struct(int count __arglist);

struct SixteenByteStruct
{
   long a;
   long b;
}

...

SixteenByteStruct ebs = new SixteenByteStruct();
ebs.a = 100;
ebs.b = 101;

// va_list in native function will read junk.
test_passing_struct(1 ebs);

```

Note this fails on x86 as well as x64 but may be two separate issues.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>pgavlin</Assignee>
    <CreatedAt>20/04/2018 6:30:37 PM +00:00</CreatedAt>
    <ClosedAt>1/05/2018 10:26:33 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17701</IssueLabelID>
    <Title>System.Diagnostics.StackTrace slow on .NET Core</Title>
    <Description>Consider the following program:

```CSharp
using System;
using System.Diagnostics;

static void Main()
{
    var start = DateTime.Now;

    for (var i = 0; i &lt; 5000; i++)
    {
        new StackTrace(0 true);
    }

    var timeSpent = DateTime.Now - start;
    Console.WriteLine($"Spent time: {timeSpent.TotalMilliseconds} ms");
    Console.ReadKey();
}
```

This takes **4133.3539 ms** in .NET Core 2.0 while targeting .NET 4.7.1 this takes 108.1025 ms to execute. Making a full dump on this with procdump I can see the following stack trace typically being called:

```
System.Private.CoreLib.dll!00007ffee4a6bfb9()	Unknown
[Managed to Native Transition]	
System.Private.CoreLib.dll!System.IO.FileStream.SeekCore(long offset System.IO.SeekOrigin origin) Line 608	C#
System.Private.CoreLib.dll!System.IO.FileStream.Seek(long offset System.IO.SeekOrigin origin) Line 542	C#
System.Reflection.Metadata.dll!System.Reflection.PortableExecutable.PEHeaders.PEHeaders(System.IO.Stream peStream int size bool isLoadedImage)	Unknown
System.Reflection.Metadata.dll!System.Reflection.PortableExecutable.PEReader.InitializePEHeaders()	Unknown
System.Reflection.Metadata.dll!System.Reflection.PortableExecutable.PEReader.ReadDebugDirectory()	Unknown
System.Reflection.Metadata.dll!System.Reflection.PortableExecutable.PEReader.TryOpenAssociatedPortablePdb(string peImagePath System.Func&lt;string System.IO.Stream&gt; pdbFileStreamProvider out System.Reflection.Metadata.MetadataReaderProvider pdbReaderProvider out string pdbPath)	Unknown
System.Diagnostics.StackTrace.dll!System.Diagnostics.StackTraceSymbols.TryOpenReaderFromAssemblyFile(string assemblyPath System.IntPtr loadedPeAddress int loadedPeSize) Line 198	C#
System.Diagnostics.StackTrace.dll!System.Diagnostics.StackTraceSymbols.TryGetReader(string assemblyPath System.IntPtr loadedPeAddress int loadedPeSize System.IntPtr inMemoryPdbAddress int inMemoryPdbSize) Line 129	C#
System.Diagnostics.StackTrace.dll!System.Diagnostics.StackTraceSymbols.GetSourceLineInfo(string assemblyPath System.IntPtr loadedPeAddress int loadedPeSize System.IntPtr inMemoryPdbAddress int inMemoryPdbSize int methodToken int ilOffset out string sourceFile out int sourceLine out int sourceColumn) Line 59	C#
System.Private.CoreLib.dll!System.Diagnostics.StackFrameHelper.InitializeSourceInfo(int iSkip bool fNeedFileInfo System.Exception exception) Line 140	C#
System.Private.CoreLib.dll!System.Diagnostics.StackTrace.CaptureStackTrace(int iSkip bool fNeedFileInfo System.Threading.Thread targetThread System.Exception e) Line 426	C#
System.Private.CoreLib.dll!System.Diagnostics.StackTrace.StackTrace(int skipFrames bool fNeedFileInfo) Line 307	C#
```
</Description>
    <Title_Description>System.Diagnostics.StackTrace slow on .NET Core Consider the following program:

```CSharp
using System;
using System.Diagnostics;

static void Main()
{
    var start = DateTime.Now;

    for (var i = 0; i &lt; 5000; i++)
    {
        new StackTrace(0 true);
    }

    var timeSpent = DateTime.Now - start;
    Console.WriteLine($"Spent time: {timeSpent.TotalMilliseconds} ms");
    Console.ReadKey();
}
```

This takes **4133.3539 ms** in .NET Core 2.0 while targeting .NET 4.7.1 this takes 108.1025 ms to execute. Making a full dump on this with procdump I can see the following stack trace typically being called:

```
System.Private.CoreLib.dll!00007ffee4a6bfb9()	Unknown
[Managed to Native Transition]	
System.Private.CoreLib.dll!System.IO.FileStream.SeekCore(long offset System.IO.SeekOrigin origin) Line 608	C#
System.Private.CoreLib.dll!System.IO.FileStream.Seek(long offset System.IO.SeekOrigin origin) Line 542	C#
System.Reflection.Metadata.dll!System.Reflection.PortableExecutable.PEHeaders.PEHeaders(System.IO.Stream peStream int size bool isLoadedImage)	Unknown
System.Reflection.Metadata.dll!System.Reflection.PortableExecutable.PEReader.InitializePEHeaders()	Unknown
System.Reflection.Metadata.dll!System.Reflection.PortableExecutable.PEReader.ReadDebugDirectory()	Unknown
System.Reflection.Metadata.dll!System.Reflection.PortableExecutable.PEReader.TryOpenAssociatedPortablePdb(string peImagePath System.Func&lt;string System.IO.Stream&gt; pdbFileStreamProvider out System.Reflection.Metadata.MetadataReaderProvider pdbReaderProvider out string pdbPath)	Unknown
System.Diagnostics.StackTrace.dll!System.Diagnostics.StackTraceSymbols.TryOpenReaderFromAssemblyFile(string assemblyPath System.IntPtr loadedPeAddress int loadedPeSize) Line 198	C#
System.Diagnostics.StackTrace.dll!System.Diagnostics.StackTraceSymbols.TryGetReader(string assemblyPath System.IntPtr loadedPeAddress int loadedPeSize System.IntPtr inMemoryPdbAddress int inMemoryPdbSize) Line 129	C#
System.Diagnostics.StackTrace.dll!System.Diagnostics.StackTraceSymbols.GetSourceLineInfo(string assemblyPath System.IntPtr loadedPeAddress int loadedPeSize System.IntPtr inMemoryPdbAddress int inMemoryPdbSize int methodToken int ilOffset out string sourceFile out int sourceLine out int sourceColumn) Line 59	C#
System.Private.CoreLib.dll!System.Diagnostics.StackFrameHelper.InitializeSourceInfo(int iSkip bool fNeedFileInfo System.Exception exception) Line 140	C#
System.Private.CoreLib.dll!System.Diagnostics.StackTrace.CaptureStackTrace(int iSkip bool fNeedFileInfo System.Threading.Thread targetThread System.Exception e) Line 426	C#
System.Private.CoreLib.dll!System.Diagnostics.StackTrace.StackTrace(int skipFrames bool fNeedFileInfo) Line 307	C#
```
</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>mikem8361</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17698</IssueLabelID>
    <Title>corefx test failure: Assert failure: !"You cannot use this function for arbitrary value types. You must preallocate a box object and copy the value in yourself."</Title>
    <Description>https://ci.dot.net/job/dotnet_coreclr/job/master/view/x86/job/jitstress/job/x86_checked_windows_nt_corefx_baseline/462/consoleText

many tests fail with:
```
  Assert failure(PID 4732 [0x0000127c] Thread: 3760 [0x0eb0]): !"You cannot use this function for arbitrary value types. You must preallocate a box object and copy the value in yourself."
  
  CORECLR! InvokeUtil::CreateObjectAfterInvoke + 0x1B4 (0x7197b820)
  CORECLR! RuntimeMethodHandle::InvokeMethod + 0xCF3 (0x71ab9013)
  SYSTEM.PRIVATE.CORELIB! &lt;no symbol&gt; + 0x0 (0x70fde7e9)
  SYSTEM.PRIVATE.CORELIB! &lt;no symbol&gt; + 0x0 (0x70fe0217)
  SYSTEM.PRIVATE.CORELIB! &lt;no symbol&gt; + 0x0 (0x70fe01c2)
  CORECLR! PreStubWorker + 0x3D8 (0x717618bf)
      File: d:\j\workspace\x86_checked_w---fbe14ed2\src\vm\invokeutil.cpp Line: 693
      Image: D:\j\workspace\x86_checked_w---fbe14ed2\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-x86\dotnet.exe
```

Also seen on ARM.
</Description>
    <Title_Description>corefx test failure: Assert failure: !"You cannot use this function for arbitrary value types. You must preallocate a box object and copy the value in yourself." https://ci.dot.net/job/dotnet_coreclr/job/master/view/x86/job/jitstress/job/x86_checked_windows_nt_corefx_baseline/462/consoleText

many tests fail with:
```
  Assert failure(PID 4732 [0x0000127c] Thread: 3760 [0x0eb0]): !"You cannot use this function for arbitrary value types. You must preallocate a box object and copy the value in yourself."
  
  CORECLR! InvokeUtil::CreateObjectAfterInvoke + 0x1B4 (0x7197b820)
  CORECLR! RuntimeMethodHandle::InvokeMethod + 0xCF3 (0x71ab9013)
  SYSTEM.PRIVATE.CORELIB! &lt;no symbol&gt; + 0x0 (0x70fde7e9)
  SYSTEM.PRIVATE.CORELIB! &lt;no symbol&gt; + 0x0 (0x70fe0217)
  SYSTEM.PRIVATE.CORELIB! &lt;no symbol&gt; + 0x0 (0x70fe01c2)
  CORECLR! PreStubWorker + 0x3D8 (0x717618bf)
      File: d:\j\workspace\x86_checked_w---fbe14ed2\src\vm\invokeutil.cpp Line: 693
      Image: D:\j\workspace\x86_checked_w---fbe14ed2\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-x86\dotnet.exe
```

Also seen on ARM.
</Title_Description>
    <Label>bug</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>20/04/2018 4:43:23 PM +00:00</CreatedAt>
    <ClosedAt>20/04/2018 5:24:34 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17695</IssueLabelID>
    <Title>Question about typeforwarding public types</Title>
    <Description>I have an executable named `typeforward` and it refers to library `LibA`. Everything works.
If I type-forward a public type from `LibA` to `LibB` then executable fails.

If my final executable `typeforward` refers to public type `LibA.Moved` then moving `LibA.Moved` to `LibB` does not work as `dotnet typeforward.dll` fails to start with exception :

```
Unhandled Exception: System.IO.FileNotFoundException: Could not load file or assembly 'LibB Version=1.0.0.0 Culture=neutral PublicKeyToken=null'. The system cannot find the file specified.
   at typeforward.Program.Main(String[] args)
```

**Is it possible to type-forward public type ?**

Since `LibB` entry is not in `typeforward.deps.json`  I added an AssemblyResolver to `typeforward` but that does not work. Exception is thrown before `Main` is called and resolver is registered.

Is this because of no entry in `typeforward.deps.json` ? But that is by promise of `typeforwarding` as I should not recompile `typeforward` executable.

I have tested that `typeforwarding` is working when I move `internal` types from `LibA` to `LibB`. i.e. when `typeforward` executable does not refer to moved types directly.

But do I need type-forwarding in that case ? I can just use dynamic loading which has to be added even with typeforwarding.

[typeforwarding.zip](https://github.com/dotnet/coreclr/files/1931103/typeforwarding.zip)
```
# steps to repro :

git checkout typeforwarder_usecase
cd typeforward

dotnet.exe bin_moved\Debug\netcoreapp2.0\typeforward.dll

Unhandled Exception: System.IO.FileNotFoundException: Could not load file or assembly 'LibB Version=1.0.0.0 Culture=neutral PublicKeyToken=null'. The system cannot find the file specified.
   at typeforward.Program.Main(String[] args)
```

`typeforward\bin_moved` folder has `typeforward.dll` with `LibA` and `LibB` replaced after `LibA` 's public type is moved to `LibB`.


</Description>
    <Title_Description>Question about typeforwarding public types I have an executable named `typeforward` and it refers to library `LibA`. Everything works.
If I type-forward a public type from `LibA` to `LibB` then executable fails.

If my final executable `typeforward` refers to public type `LibA.Moved` then moving `LibA.Moved` to `LibB` does not work as `dotnet typeforward.dll` fails to start with exception :

```
Unhandled Exception: System.IO.FileNotFoundException: Could not load file or assembly 'LibB Version=1.0.0.0 Culture=neutral PublicKeyToken=null'. The system cannot find the file specified.
   at typeforward.Program.Main(String[] args)
```

**Is it possible to type-forward public type ?**

Since `LibB` entry is not in `typeforward.deps.json`  I added an AssemblyResolver to `typeforward` but that does not work. Exception is thrown before `Main` is called and resolver is registered.

Is this because of no entry in `typeforward.deps.json` ? But that is by promise of `typeforwarding` as I should not recompile `typeforward` executable.

I have tested that `typeforwarding` is working when I move `internal` types from `LibA` to `LibB`. i.e. when `typeforward` executable does not refer to moved types directly.

But do I need type-forwarding in that case ? I can just use dynamic loading which has to be added even with typeforwarding.

[typeforwarding.zip](https://github.com/dotnet/coreclr/files/1931103/typeforwarding.zip)
```
# steps to repro :

git checkout typeforwarder_usecase
cd typeforward

dotnet.exe bin_moved\Debug\netcoreapp2.0\typeforward.dll

Unhandled Exception: System.IO.FileNotFoundException: Could not load file or assembly 'LibB Version=1.0.0.0 Culture=neutral PublicKeyToken=null'. The system cannot find the file specified.
   at typeforward.Program.Main(String[] args)
```

`typeforward\bin_moved` folder has `typeforward.dll` with `LibA` and `LibB` replaced after `LibA` 's public type is moved to `LibB`.


</Title_Description>
    <Label>area-TypeSystem</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>20/04/2018 7:17:36 AM +00:00</CreatedAt>
    <ClosedAt>20/04/2018 5:19:52 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17694</IssueLabelID>
    <Title>Account for copied bytes in struct copy loop when generating GT_PUTARG_STK code [ARM64]</Title>
    <Description>When generating code for a GT_PUTARG_STK where there's an HFA struct being passed on the stack we have a loop that copies the struct 16 bytes at a time with ldp/stp. However in the case where we have a var node for the struct we weren't increasing the offset of the ldp to account for the portion of the struct we've already copied. Thus a struct with size 16*_n_ would just end up having _n_ copies of its first 16 bytes.

The fix is simple: instead of hardcoding the offset to 0 when we emit the ldp we set it to be the number of bytes we've copied which is conveniently already captured for us in `structOffset`.

@BruceForstall @jkotas @janvorli </Description>
    <Title_Description>Account for copied bytes in struct copy loop when generating GT_PUTARG_STK code [ARM64] When generating code for a GT_PUTARG_STK where there's an HFA struct being passed on the stack we have a loop that copies the struct 16 bytes at a time with ldp/stp. However in the case where we have a var node for the struct we weren't increasing the offset of the ldp to account for the portion of the struct we've already copied. Thus a struct with size 16*_n_ would just end up having _n_ copies of its first 16 bytes.

The fix is simple: instead of hardcoding the offset to 0 when we emit the ldp we set it to be the number of bytes we've copied which is conveniently already captured for us in `structOffset`.

@BruceForstall @jkotas @janvorli </Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>20/04/2018 2:23:55 AM +00:00</CreatedAt>
    <ClosedAt>26/04/2018 5:40:46 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17693</IssueLabelID>
    <Title>[clrdbg] Add support for inline values</Title>
    <Description>VSCode Debugger Protocol now supports inline values for variables when debugging. It would be great if vsdbg/vsdbg-ui adds support for this.

Debugger Protocol:
[https://github.com/Microsoft/vscode-debugadapter-node/issues/78](url)
[https://github.com/Microsoft/vscode-debugadapter-node/blob/896566e0be3f48e5cf90fb715b3b3ffbfa777888/protocol/src/debugProtocol.ts#L1329-L1337](url)

VSCode Support:
[https://github.com/Microsoft/vscode/pull/16129](url)</Description>
    <Title_Description>[clrdbg] Add support for inline values VSCode Debugger Protocol now supports inline values for variables when debugging. It would be great if vsdbg/vsdbg-ui adds support for this.

Debugger Protocol:
[https://github.com/Microsoft/vscode-debugadapter-node/issues/78](url)
[https://github.com/Microsoft/vscode-debugadapter-node/blob/896566e0be3f48e5cf90fb715b3b3ffbfa777888/protocol/src/debugProtocol.ts#L1329-L1337](url)

VSCode Support:
[https://github.com/Microsoft/vscode/pull/16129](url)</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>20/04/2018 2:12:56 AM +00:00</CreatedAt>
    <ClosedAt>21/04/2018 12:53:47 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17692</IssueLabelID>
    <Title>Mscordbi uses incorrect layout for MDInternalRW.</Title>
    <Description>Mscordbi uses incorrect layout for MDInternalRW when marshaling to Target_MDInternalRW in a couple of places. Specifically for Target_RecordPool (aligned to 4 bytes on Linux rather than 8) and Target_MapSHash (don't need to skip a byte at the beginning of struct on Linux). The mismatch causes CordbModule::GetMetadataInterface to fail for dump debugging on Linux.</Description>
    <Title_Description>Mscordbi uses incorrect layout for MDInternalRW. Mscordbi uses incorrect layout for MDInternalRW when marshaling to Target_MDInternalRW in a couple of places. Specifically for Target_RecordPool (aligned to 4 bytes on Linux rather than 8) and Target_MapSHash (don't need to skip a byte at the beginning of struct on Linux). The mismatch causes CordbModule::GetMetadataInterface to fail for dump debugging on Linux.</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>mikem8361</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17691</IssueLabelID>
    <Title>Fix SSE2 SetZeroVector128 on float type</Title>
    <Description>fix https://github.com/dotnet/coreclr/issues/17689

@CarolEidt PTAL</Description>
    <Title_Description>Fix SSE2 SetZeroVector128 on float type fix https://github.com/dotnet/coreclr/issues/17689

@CarolEidt PTAL</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
    <CreatedAt>20/04/2018 12:42:24 AM +00:00</CreatedAt>
    <ClosedAt>6/08/2018 8:40:06 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17689</IssueLabelID>
    <Title>[RyuJIT] SSE2 SetZeroVector128 does not support float base type </Title>
    <Description>`Sse2.SetZeroVector128&lt;T&gt;` is a generic helper intrinsic that should generate SSE `xorps` instruction for `Vector128&lt;float&gt;`. </Description>
    <Title_Description>[RyuJIT] SSE2 SetZeroVector128 does not support float base type  `Sse2.SetZeroVector128&lt;T&gt;` is a generic helper intrinsic that should generate SSE `xorps` instruction for `Vector128&lt;float&gt;`. </Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>fiigii</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17687</IssueLabelID>
    <Title>Lower memory usage expected?</Title>
    <Description>On the reliability testing we are doing in the aspnet team I noticed a drop in memory usage around April 11-12. Is this something that could be explained by Server GC changes?

| OS | Before (MB) | After (MB) | Delta |
| -- | -- | -- | -- |
| Linux | 430 | 360 |  -27% |
| Windows | 345 | 245 | -29% |

This graph show the Windows consumption overtime. The application was the same the load constant. Only ASP.NET and the runtime were updated. (MVC + EF + Razor). CPU usage remained constant.

![image](https://user-images.githubusercontent.com/1165805/39024187-0436c0d8-43f4-11e8-82ff-6d30b7e07985.png)

If this is not expected I might be able to run the app with the version that were used and get some dumps/traces. It can also be related to changes in other repos but I am trying here first.</Description>
    <Title_Description>Lower memory usage, expected? On the reliability testing we are doing in the aspnet team I noticed a drop in memory usage around April 11-12. Is this something that could be explained by Server GC changes?

| OS | Before (MB) | After (MB) | Delta |
| -- | -- | -- | -- |
| Linux | 430 | 360 |  -27% |
| Windows | 345 | 245 | -29% |

This graph show the Windows consumption overtime. The application was the same the load constant. Only ASP.NET and the runtime were updated. (MVC + EF + Razor). CPU usage remained constant.

![image](https://user-images.githubusercontent.com/1165805/39024187-0436c0d8-43f4-11e8-82ff-6d30b7e07985.png)

If this is not expected I might be able to run the app with the version that were used and get some dumps/traces. It can also be related to changes in other repos but I am trying here first.</Title_Description>
    <Label>area-GC</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>20/04/2018 12:17:20 AM +00:00</CreatedAt>
    <ClosedAt>20/04/2018 7:14:37 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17684</IssueLabelID>
    <Title>Updating coreclr toolset</Title>
    <Description>For non-Windows builds we generally build with clang 3.9 though for arm32 we build with clang 5.0 and at least in the CI arm64 builds with clang 3.8.

Should these all be updated to something consistent and newer e.g. clang 6.0?

What is the process for making this decision and making it happen?

@RussKeldorph @janvorli @jkotas </Description>
    <Title_Description>Updating coreclr toolset For non-Windows builds we generally build with clang 3.9 though for arm32 we build with clang 5.0 and at least in the CI arm64 builds with clang 3.8.

Should these all be updated to something consistent and newer e.g. clang 6.0?

What is the process for making this decision and making it happen?

@RussKeldorph @janvorli @jkotas </Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>19/04/2018 10:33:12 PM +00:00</CreatedAt>
    <ClosedAt>11/11/2019 5:57:44 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17682</IssueLabelID>
    <Title>Make intra-build containers private</Title>
    <Description>
    </Description>
    <Title_Description>Make intra-build containers private </Title_Description>
    <Label>
    </Label>
    <Assignee>weshaggard</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17680</IssueLabelID>
    <Title>Fix GC tests that contain GC.Collect() used in wrong scope</Title>
    <Description>This same fix has been made in #17656 and #17594. I went through all the GC tests and fixed places where we observe a similar issue. Note that most of these tests don't necessarily depend on this fix since the JIT won't inline methods / extend lifetime of temps for most of these tests but wanted to fix these before we see more test failures coming from the various scenarios these tests will be running against. </Description>
    <Title_Description>Fix GC tests that contain GC.Collect() used in wrong scope This same fix has been made in #17656 and #17594. I went through all the GC tests and fixed places where we observe a similar issue. Note that most of these tests don't necessarily depend on this fix since the JIT won't inline methods / extend lifetime of temps for most of these tests but wanted to fix these before we see more test failures coming from the various scenarios these tests will be running against. </Title_Description>
    <Label>
    </Label>
    <Assignee>sywhang</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17679</IssueLabelID>
    <Title>Fatal error reporting deadlocks with GC</Title>
    <Description>Found while investigating https://github.com/aspnet/KestrelHttpServer/issues/2503

From Maoni:

This is an age old problem…managed heap corruption causes exception triggered on the GC thread which then needs to wait for GC so deadlock…looping in Noah. He did some work to accommodate I believe.

```
  54  Id: 48c.1b30 Suspend: 0 Teb: 000000ed`15540000 Unfrozen
# Child-SP          RetAddr           Call Site
00 000000ed`27e7c868 00007fff`1be03acf ntdll!NtWaitForSingleObject+0x14
01 000000ed`27e7c870 00007ffe`f8716ba0 KERNELBASE!WaitForSingleObjectEx+0x8f
02 (Inline Function) --------`-------- coreclr!CLREventWaitHelper2+0x6 [e:\a\_work\104\s\src\vm\synch.cpp @ 385] 
03 000000ed`27e7c910 00007ffe`f89de32d coreclr!CLREventWaitHelper+0x20 [e:\a\_work\104\s\src\vm\synch.cpp @ 411] 
04 (Inline Function) --------`-------- coreclr!CLREventBase::Wait+0x11 [e:\a\_work\104\s\src\vm\synch.cpp @ 426] 
05 (Inline Function) --------`-------- coreclr!GCEvent::Impl::Wait+0x11 [e:\a\_work\104\s\src\vm\gcenv.os.cpp @ 789] 
06 (Inline Function) --------`-------- coreclr!GCEvent::Wait+0x18 [e:\a\_work\104\s\src\vm\gcenv.os.cpp @ 867] 
07 000000ed`27e7c970 00007ffe`f86777c3 coreclr!SVR::GCHeap::WaitUntilGCComplete+0x3d [e:\a\_work\104\s\src\gc\gcee.cpp @ 402] 
08 000000ed`27e7c9a0 00007ffe`f869c5d0 coreclr!Thread::RareDisablePreemptiveGC+0x10f [e:\a\_work\104\s\src\vm\threadsuspend.cpp @ 3065] 
09 (Inline Function) --------`-------- coreclr!Thread::DisablePreemptiveGC+0x1f [e:\a\_work\104\s\src\vm\threads.h @ 2107] 
0a (Inline Function) --------`-------- coreclr!GCHolderBase::EnterInternalCoop+0x37 [e:\a\_work\104\s\src\vm\threads.h @ 6068] 
0b 000000ed`27e7c9f0 00007ffe`f889f8a1 coreclr!GCCoop::GCCoop+0x54 [e:\a\_work\104\s\src\vm\threads.h @ 6188] 
0c 000000ed`27e7ca20 00007ffe`f8897e0d coreclr!GetThreadUICultureId+0x51 [e:\a\_work\104\s\src\vm\ceemain.cpp @ 3137] 
0d 000000ed`27e7ca70 00007ffe`f88967e0 coreclr!CCompRC::LoadString+0x55 [e:\a\_work\104\s\src\utilcode\ccomprc.cpp @ 687] 
0e 000000ed`27e7cbb0 00007ffe`f898a19d coreclr!SString::LoadResourceAndReturnHR+0xd8 [e:\a\_work\104\s\src\utilcode\sstring_com.cpp @ 63] 
0f (Inline Function) --------`-------- coreclr!SString::LoadResourceAndReturnHR+0x19 [e:\a\_work\104\s\src\utilcode\sstring_com.cpp @ 27] 
10 (Inline Function) --------`-------- coreclr!SString::LoadResource+0x19 [e:\a\_work\104\s\src\utilcode\sstring_com.cpp @ 21] 
11 000000ed`27e7cc70 00007ffe`f88feb85 coreclr!EventReporter::EventReporter+0x115 [e:\a\_work\104\s\src\vm\eventreporter.cpp @ 56] 
12 000000ed`27e7cf50 00007ffe`f88fe311 coreclr!EEPolicy::LogFatalError+0x15d [e:\a\_work\104\s\src\vm\eepolicy.cpp @ 1264] 
13 000000ed`27e7dcc0 00007ffe`f883cc5b coreclr!EEPolicy::HandleFatalError+0x179 [e:\a\_work\104\s\src\vm\eepolicy.cpp @ 1545] 
14 (Inline Function) --------`-------- coreclr!CLRVectoredExceptionHandlerPhase3+0x12472e [e:\a\_work\104\s\src\vm\excep.cpp @ 7840] 
15 000000ed`27e7e2b0 00007ffe`f87184eb coreclr!CLRVectoredExceptionHandlerPhase2+0x12475f [e:\a\_work\104\s\src\vm\excep.cpp @ 7547] 
16 000000ed`27e7e310 00007ffe`f8718427 coreclr!CLRVectoredExceptionHandler+0x8b [e:\a\_work\104\s\src\vm\excep.cpp @ 7514] 
17 000000ed`27e7e370 00007fff`1f60c810 coreclr!CLRVectoredExceptionHandlerShim+0xb7 [e:\a\_work\104\s\src\vm\excep.cpp @ 8207] 
18 000000ed`27e7e3a0 00007fff`1f5e962b ntdll!RtlInitializeCriticalSection+0x190
19 000000ed`27e7e440 00007fff`1f649c8a ntdll!RtlImageNtHeaderEx+0x17b
1a 000000ed`27e7eb40 00007ffe`f89ea658 ntdll!KiUserExceptionDispatcher+0x3a
1b (Inline Function) --------`-------- coreclr!SVR::CObjectHeader::GetMethodTable+0x7 [e:\a\_work\104\s\src\gc\gc.cpp @ 3962] 
1c (Inline Function) --------`-------- coreclr!SVR::my_get_size+0x7 [e:\a\_work\104\s\src\gc\gc.cpp @ 9007] 
1d 000000ed`27e7f250 00007ffe`f89f7850 coreclr!SVR::gc_heap::find_first_object+0x90 [e:\a\_work\104\s\src\gc\gc.cpp @ 27343] 
1e 000000ed`27e7f2a0 00007ffe`f89f7ec1 coreclr!SVR::gc_heap::revisit_written_page+0x88 [e:\a\_work\104\s\src\gc\gc.cpp @ 26257] 
1f 000000ed`27e7f340 00007ffe`f89e2fd2 coreclr!SVR::gc_heap::revisit_written_pages+0x2c1 [e:\a\_work\104\s\src\gc\gc.cpp @ 26544] 
20 000000ed`27e7f420 00007ffe`f89eb92c coreclr!SVR::gc_heap::background_mark_phase+0x6ca [e:\a\_work\104\s\src\gc\gc.cpp @ 25973] 
21 000000ed`27e7f4c0 00007ffe`f89e5624 coreclr!SVR::gc_heap::gc1+0xc8 [e:\a\_work\104\s\src\gc\gc.cpp @ 15388] 
22 000000ed`27e7f510 00007ffe`f87b98e4 coreclr!SVR::gc_heap::bgc_thread_function+0x120 [e:\a\_work\104\s\src\gc\gc.cpp @ 26991] 
23 000000ed`27e7f560 00007ffe`f8717658 coreclr!&lt;lambda_50311027edc69684c2f6a68020e9a683&gt;::operator()+0x8c [e:\a\_work\104\s\src\vm\gcenv.ee.cpp @ 1238] 
24 000000ed`27e7f590 00007fff`1cd68364 coreclr!Thread::intermediateThreadProc+0x88 [e:\a\_work\104\s\src\vm\threads.cpp @ 2255] 
25 000000ed`27e7fd50 00007fff`1f607091 kernel32!BaseThreadInitThunk+0x14
26 000000ed`27e7fd80 00000000`00000000 ntdll!RtlUserThreadStart+0x21
```</Description>
    <Title_Description>Fatal error reporting deadlocks with GC Found while investigating https://github.com/aspnet/KestrelHttpServer/issues/2503

From Maoni:

This is an age old problem…managed heap corruption causes exception triggered on the GC thread which then needs to wait for GC so deadlock…looping in Noah. He did some work to accommodate I believe.

```
  54  Id: 48c.1b30 Suspend: 0 Teb: 000000ed`15540000 Unfrozen
# Child-SP          RetAddr           Call Site
00 000000ed`27e7c868 00007fff`1be03acf ntdll!NtWaitForSingleObject+0x14
01 000000ed`27e7c870 00007ffe`f8716ba0 KERNELBASE!WaitForSingleObjectEx+0x8f
02 (Inline Function) --------`-------- coreclr!CLREventWaitHelper2+0x6 [e:\a\_work\104\s\src\vm\synch.cpp @ 385] 
03 000000ed`27e7c910 00007ffe`f89de32d coreclr!CLREventWaitHelper+0x20 [e:\a\_work\104\s\src\vm\synch.cpp @ 411] 
04 (Inline Function) --------`-------- coreclr!CLREventBase::Wait+0x11 [e:\a\_work\104\s\src\vm\synch.cpp @ 426] 
05 (Inline Function) --------`-------- coreclr!GCEvent::Impl::Wait+0x11 [e:\a\_work\104\s\src\vm\gcenv.os.cpp @ 789] 
06 (Inline Function) --------`-------- coreclr!GCEvent::Wait+0x18 [e:\a\_work\104\s\src\vm\gcenv.os.cpp @ 867] 
07 000000ed`27e7c970 00007ffe`f86777c3 coreclr!SVR::GCHeap::WaitUntilGCComplete+0x3d [e:\a\_work\104\s\src\gc\gcee.cpp @ 402] 
08 000000ed`27e7c9a0 00007ffe`f869c5d0 coreclr!Thread::RareDisablePreemptiveGC+0x10f [e:\a\_work\104\s\src\vm\threadsuspend.cpp @ 3065] 
09 (Inline Function) --------`-------- coreclr!Thread::DisablePreemptiveGC+0x1f [e:\a\_work\104\s\src\vm\threads.h @ 2107] 
0a (Inline Function) --------`-------- coreclr!GCHolderBase::EnterInternalCoop+0x37 [e:\a\_work\104\s\src\vm\threads.h @ 6068] 
0b 000000ed`27e7c9f0 00007ffe`f889f8a1 coreclr!GCCoop::GCCoop+0x54 [e:\a\_work\104\s\src\vm\threads.h @ 6188] 
0c 000000ed`27e7ca20 00007ffe`f8897e0d coreclr!GetThreadUICultureId+0x51 [e:\a\_work\104\s\src\vm\ceemain.cpp @ 3137] 
0d 000000ed`27e7ca70 00007ffe`f88967e0 coreclr!CCompRC::LoadString+0x55 [e:\a\_work\104\s\src\utilcode\ccomprc.cpp @ 687] 
0e 000000ed`27e7cbb0 00007ffe`f898a19d coreclr!SString::LoadResourceAndReturnHR+0xd8 [e:\a\_work\104\s\src\utilcode\sstring_com.cpp @ 63] 
0f (Inline Function) --------`-------- coreclr!SString::LoadResourceAndReturnHR+0x19 [e:\a\_work\104\s\src\utilcode\sstring_com.cpp @ 27] 
10 (Inline Function) --------`-------- coreclr!SString::LoadResource+0x19 [e:\a\_work\104\s\src\utilcode\sstring_com.cpp @ 21] 
11 000000ed`27e7cc70 00007ffe`f88feb85 coreclr!EventReporter::EventReporter+0x115 [e:\a\_work\104\s\src\vm\eventreporter.cpp @ 56] 
12 000000ed`27e7cf50 00007ffe`f88fe311 coreclr!EEPolicy::LogFatalError+0x15d [e:\a\_work\104\s\src\vm\eepolicy.cpp @ 1264] 
13 000000ed`27e7dcc0 00007ffe`f883cc5b coreclr!EEPolicy::HandleFatalError+0x179 [e:\a\_work\104\s\src\vm\eepolicy.cpp @ 1545] 
14 (Inline Function) --------`-------- coreclr!CLRVectoredExceptionHandlerPhase3+0x12472e [e:\a\_work\104\s\src\vm\excep.cpp @ 7840] 
15 000000ed`27e7e2b0 00007ffe`f87184eb coreclr!CLRVectoredExceptionHandlerPhase2+0x12475f [e:\a\_work\104\s\src\vm\excep.cpp @ 7547] 
16 000000ed`27e7e310 00007ffe`f8718427 coreclr!CLRVectoredExceptionHandler+0x8b [e:\a\_work\104\s\src\vm\excep.cpp @ 7514] 
17 000000ed`27e7e370 00007fff`1f60c810 coreclr!CLRVectoredExceptionHandlerShim+0xb7 [e:\a\_work\104\s\src\vm\excep.cpp @ 8207] 
18 000000ed`27e7e3a0 00007fff`1f5e962b ntdll!RtlInitializeCriticalSection+0x190
19 000000ed`27e7e440 00007fff`1f649c8a ntdll!RtlImageNtHeaderEx+0x17b
1a 000000ed`27e7eb40 00007ffe`f89ea658 ntdll!KiUserExceptionDispatcher+0x3a
1b (Inline Function) --------`-------- coreclr!SVR::CObjectHeader::GetMethodTable+0x7 [e:\a\_work\104\s\src\gc\gc.cpp @ 3962] 
1c (Inline Function) --------`-------- coreclr!SVR::my_get_size+0x7 [e:\a\_work\104\s\src\gc\gc.cpp @ 9007] 
1d 000000ed`27e7f250 00007ffe`f89f7850 coreclr!SVR::gc_heap::find_first_object+0x90 [e:\a\_work\104\s\src\gc\gc.cpp @ 27343] 
1e 000000ed`27e7f2a0 00007ffe`f89f7ec1 coreclr!SVR::gc_heap::revisit_written_page+0x88 [e:\a\_work\104\s\src\gc\gc.cpp @ 26257] 
1f 000000ed`27e7f340 00007ffe`f89e2fd2 coreclr!SVR::gc_heap::revisit_written_pages+0x2c1 [e:\a\_work\104\s\src\gc\gc.cpp @ 26544] 
20 000000ed`27e7f420 00007ffe`f89eb92c coreclr!SVR::gc_heap::background_mark_phase+0x6ca [e:\a\_work\104\s\src\gc\gc.cpp @ 25973] 
21 000000ed`27e7f4c0 00007ffe`f89e5624 coreclr!SVR::gc_heap::gc1+0xc8 [e:\a\_work\104\s\src\gc\gc.cpp @ 15388] 
22 000000ed`27e7f510 00007ffe`f87b98e4 coreclr!SVR::gc_heap::bgc_thread_function+0x120 [e:\a\_work\104\s\src\gc\gc.cpp @ 26991] 
23 000000ed`27e7f560 00007ffe`f8717658 coreclr!&lt;lambda_50311027edc69684c2f6a68020e9a683&gt;::operator()+0x8c [e:\a\_work\104\s\src\vm\gcenv.ee.cpp @ 1238] 
24 000000ed`27e7f590 00007fff`1cd68364 coreclr!Thread::intermediateThreadProc+0x88 [e:\a\_work\104\s\src\vm\threads.cpp @ 2255] 
25 000000ed`27e7fd50 00007fff`1f607091 kernel32!BaseThreadInitThunk+0x14
26 000000ed`27e7fd80 00000000`00000000 ntdll!RtlUserThreadStart+0x21
```</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>sywhang</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17678</IssueLabelID>
    <Title>WIP Test all jitting at tier 1</Title>
    <Description>
    </Description>
    <Title_Description>WIP Test all jitting at tier 1 </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17677</IssueLabelID>
    <Title>Fix nested spin locks in thread pool etw firing</Title>
    <Description>`UnManagedPerAppDomainTPCount::QueueUnmanagedWorkRequest` fires an ETW event inside a spin lock and a nested spin lock is taken here:

```
SpinLock::GetLock + 0x8E (0x719da71d)
EventPipeBufferManager::AllocateBufferForThread + 0x7B (0x71afa92e)
EventPipeBufferManager::WriteEvent + 0x250 (0x71afbe0a)
EventPipe::WriteEventInternal + 0x125 (0x71951c93)
EventPipe::WriteEvent + 0x91 (0x71951714)
EventPipeWriteEventThreadPoolEnqueue + 0x9E (0x71d468a6)
FireEtwThreadPoolEnqueue + 0xF (0x71b7a04b)
UnManagedPerAppDomainTPCount::QueueUnmanagedWorkRequest + 0x21D (0x71b7a597)
```

Nesting spin locks is not allowed moved the ETW firing outside the lock.</Description>
    <Title_Description>Fix nested spin locks in thread pool etw firing `UnManagedPerAppDomainTPCount::QueueUnmanagedWorkRequest` fires an ETW event inside a spin lock and a nested spin lock is taken here:

```
SpinLock::GetLock + 0x8E (0x719da71d)
EventPipeBufferManager::AllocateBufferForThread + 0x7B (0x71afa92e)
EventPipeBufferManager::WriteEvent + 0x250 (0x71afbe0a)
EventPipe::WriteEventInternal + 0x125 (0x71951c93)
EventPipe::WriteEvent + 0x91 (0x71951714)
EventPipeWriteEventThreadPoolEnqueue + 0x9E (0x71d468a6)
FireEtwThreadPoolEnqueue + 0xF (0x71b7a04b)
UnManagedPerAppDomainTPCount::QueueUnmanagedWorkRequest + 0x21D (0x71b7a597)
```

Nesting spin locks is not allowed moved the ETW firing outside the lock.</Title_Description>
    <Label>area-System.Threading</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17676</IssueLabelID>
    <Title>[arm] Warnings with crossgen generating S.P.C.dll</Title>
    <Description>The following warnings are seen in the build:
```
ReadyToRun: JIT helper not supported: CORINFO_HELP_TYPEHANDLE_TO_RUNTIMETYPE_MAYBENULL
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
```

For example:
https://ci.dot.net/job/dotnet_coreclr/job/master/job/arm_cross_checked_ubuntu_innerloop_prtest/739/consoleText
```
Generating native image for System.Private.CoreLib.dll
/mnt/j/workspace/dotnet_coreclr/master/arm_cross_checked_ubuntu_innerloop_prtest/bin/Product/Linux.arm.Checked/x86/crossgen /Platform_Assemblies_Paths /mnt/j/workspace/dotnet_coreclr/master/arm_cross_checked_ubuntu_innerloop_prtest/bin/Product/Linux.arm.Checked/IL  /out /mnt/j/workspace/dotnet_coreclr/master/arm_cross_checked_ubuntu_innerloop_prtest/bin/Product/Linux.arm.Checked/System.Private.CoreLib.dll /mnt/j/workspace/dotnet_coreclr/master/arm_cross_checked_ubuntu_innerloop_prtest/bin/Product/Linux.arm.Checked/IL/System.Private.CoreLib.dll
Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0
Copyright (c) Microsoft Corporation.  All rights reserved.

ReadyToRun: JIT helper not supported: CORINFO_HELP_TYPEHANDLE_TO_RUNTIMETYPE_MAYBENULL
ReadyToRun: JIT helper not supported: CORINFO_HELP_TYPEHANDLE_TO_RUNTIMETYPE_MAYBENULL
ReadyToRun: JIT helper not supported: CORINFO_HELP_TYPEHANDLE_TO_RUNTIMETYPE_MAYBENULL
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
Native image /mnt/j/workspace/dotnet_coreclr/master/arm_cross_checked_ubuntu_innerloop_prtest/bin/Product/Linux.arm.Checked/System.Private.CoreLib.dll generated successfully.
```
</Description>
    <Title_Description>[arm] Warnings with crossgen generating S.P.C.dll The following warnings are seen in the build:
```
ReadyToRun: JIT helper not supported: CORINFO_HELP_TYPEHANDLE_TO_RUNTIMETYPE_MAYBENULL
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
```

For example:
https://ci.dot.net/job/dotnet_coreclr/job/master/job/arm_cross_checked_ubuntu_innerloop_prtest/739/consoleText
```
Generating native image for System.Private.CoreLib.dll
/mnt/j/workspace/dotnet_coreclr/master/arm_cross_checked_ubuntu_innerloop_prtest/bin/Product/Linux.arm.Checked/x86/crossgen /Platform_Assemblies_Paths /mnt/j/workspace/dotnet_coreclr/master/arm_cross_checked_ubuntu_innerloop_prtest/bin/Product/Linux.arm.Checked/IL  /out /mnt/j/workspace/dotnet_coreclr/master/arm_cross_checked_ubuntu_innerloop_prtest/bin/Product/Linux.arm.Checked/System.Private.CoreLib.dll /mnt/j/workspace/dotnet_coreclr/master/arm_cross_checked_ubuntu_innerloop_prtest/bin/Product/Linux.arm.Checked/IL/System.Private.CoreLib.dll
Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0
Copyright (c) Microsoft Corporation.  All rights reserved.

ReadyToRun: JIT helper not supported: CORINFO_HELP_TYPEHANDLE_TO_RUNTIMETYPE_MAYBENULL
ReadyToRun: JIT helper not supported: CORINFO_HELP_TYPEHANDLE_TO_RUNTIMETYPE_MAYBENULL
ReadyToRun: JIT helper not supported: CORINFO_HELP_TYPEHANDLE_TO_RUNTIMETYPE_MAYBENULL
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
ReadyToRun: JIT helper not supported: CORINFO_HELP_MON_ENTER
Native image /mnt/j/workspace/dotnet_coreclr/master/arm_cross_checked_ubuntu_innerloop_prtest/bin/Product/Linux.arm.Checked/System.Private.CoreLib.dll generated successfully.
```
</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>19/04/2018 6:20:29 PM +00:00</CreatedAt>
    <ClosedAt>19/04/2018 10:35:23 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17674</IssueLabelID>
    <Title>LSRA: Don't change register assignments for def/use conflicts</Title>
    <Description>Currently `LinearScan::resolveConflictingDefAndUse()` may change the register assignment on the def or use of a tree temp (SDSU) when there is a conflict. This may increase the likelihood that at least one of the references will get a desired register but it can cause problems when a necessary fixed register is not actually assigned. This is because although there is a `RefTypeFixedRef` associated with it that will only discourage other `Interval`s from taking that register and will not actually cause it to be spilled if it is occupied. A solution (see #17634 and #17673) is to also mark the register as killed but that is overly conservative since if it is allocated to an `Interval` that remains live (e.g. a lclVar) it will be unnecessarily killed. 

category:correctness
theme:register-allocator
skill-level:expert
cost:small</Description>
    <Title_Description>LSRA: Don't change register assignments for def/use conflicts Currently `LinearScan::resolveConflictingDefAndUse()` may change the register assignment on the def or use of a tree temp (SDSU) when there is a conflict. This may increase the likelihood that at least one of the references will get a desired register but it can cause problems when a necessary fixed register is not actually assigned. This is because although there is a `RefTypeFixedRef` associated with it that will only discourage other `Interval`s from taking that register and will not actually cause it to be spilled if it is occupied. A solution (see #17634 and #17673) is to also mark the register as killed but that is overly conservative since if it is allocated to an `Interval` that remains live (e.g. a lclVar) it will be unnecessarily killed. 

category:correctness
theme:register-allocator
skill-level:expert
cost:small</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>19/04/2018 5:20:13 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17673</IssueLabelID>
    <Title>Treat EDI as killed by MaskMove</Title>
    <Description>It should really only be a fixed reference not a kill but if the reference is changed by `LinearScan::resolveConflictingDefAndUse()` it can fail to cause the value in EDI to be killed.</Description>
    <Title_Description>Treat EDI as killed by MaskMove It should really only be a fixed reference not a kill but if the reference is changed by `LinearScan::resolveConflictingDefAndUse()` it can fail to cause the value in EDI to be killed.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>dotnet-bot</Assignee>
    <CreatedAt>19/04/2018 5:15:05 PM +00:00</CreatedAt>
    <ClosedAt>21/04/2018 4:10:18 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17670</IssueLabelID>
    <Title>Undoing boxing doesn't work with C# 7 pattern matching</Title>
    <Description>Short version: I was reading @stephentoub's article [*Performance Improvements in .NET Core 2.1*](https://blogs.msdn.microsoft.com/dotnet/2018/04/18/performance-improvements-in-net-core-2-1/). I noticed that his example for avoiding boxing allocations thanks to https://github.com/dotnet/coreclr/pull/14698 uses `is` followed by a cast when in C# 7 the same code could be simplified using pattern matching. So I was wondering if using C# 7 features also results in the same efficient code. It turns out it doesn't and I think this should be improved.

More details:

Consider this code:

```c#
using System.Runtime.CompilerServices;

class Program
{
    static void Main()
    {
        Cast(new Dog());
        Pattern(new Dog());
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    static void Cast&lt;T&gt;(T thing)
    {
        if (thing is IAnimal)
            ((IAnimal)thing).MakeSound();
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    static void Pattern&lt;T&gt;(T thing)
    {
        if (thing is IAnimal animal)
            animal.MakeSound();
    }    
}

struct Dog : IAnimal
{
    public void Bark() { }
    void IAnimal.MakeSound() =&gt; Bark();
}

interface IAnimal
{
    void MakeSound();
}
```

The IL for the relevant methods is:

```cil
.method private hidebysig static void  Cast&lt;T&gt;(!!T thing) cil managed noinlining
{
  // Code size       30 (0x1e)
  .maxstack  8
  IL_0000:  ldarg.0
  IL_0001:  box        !!T
  IL_0006:  isinst     IAnimal
  IL_000b:  brfalse.s  IL_001d
  IL_000d:  ldarg.0
  IL_000e:  box        !!T
  IL_0013:  castclass  IAnimal
  IL_0018:  callvirt   instance void IAnimal::MakeSound()
  IL_001d:  ret
}

.method private hidebysig static void  Pattern&lt;T&gt;(!!T thing) cil managed noinlining
{
  // Code size       22 (0x16)
  .maxstack  2
  .locals init (class IAnimal V_0)
  IL_0000:  ldarg.0
  IL_0001:  box        !!T
  IL_0006:  isinst     IAnimal
  IL_000b:  dup
  IL_000c:  stloc.0
  IL_000d:  brfalse.s  IL_0015
  IL_000f:  ldloc.0
  IL_0010:  callvirt   instance void IAnimal::MakeSound()
  IL_0015:  ret
}
```

Notice how in `Pattern` the boxed object is saved to a local variable (typed as the interface).

The disassembly from .Net Core 2.1.0-preview2-26406-04 win10-x64 is:

```asm
; Assembly listing for method Program:Cast(struct)
; Emitting BLENDED_CODE for X64 CPU with AVX
; optimized code
; rsp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  2  2   )  struct ( 8) [rsp+0x08]   do-not-enreg[XS] addr-exposed
;* V01 tmp0         [V01    ] (  0  0   )     ref  -&gt;  zero-ref    class-hnd exact
;* V02 tmp1         [V02    ] (  0  0   )  struct ( 8) zero-ref    do-not-enreg[SF] class-hnd exact
;# V03 OutArgs      [V03    ] (  1  1   )  lclBlk ( 0) [rsp+0x00]  
;
; Lcl frame size = 0

G_M19994_IG01:
       48894C2408           mov      qword ptr [rsp+08H] rcx

G_M19994_IG02:
       C3                   ret      

; Total bytes of code 6 prolog size 0 for method Program:Cast(struct)
; ============================================================
; Assembly listing for method Program:Pattern(struct)
; Emitting BLENDED_CODE for X64 CPU with AVX
; optimized code
; rsp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  4  4   )  struct ( 8) [rsp+0x30]   do-not-enreg[XSF] addr-exposed
;  V01 loc0         [V01T02] (  3  2   )     ref  -&gt;  rax         class-hnd exact
;  V02 tmp0         [V02T00] (  4  8   )     ref  -&gt;  rax         class-hnd exact
;  V03 tmp1         [V03T01] (  2  4   )     ref  -&gt;  rax         class-hnd exact
;  V04 OutArgs      [V04    ] (  1  1   )  lclBlk (32) [rsp+0x00]  
;
; Lcl frame size = 40

G_M22101_IG01:
       4883EC28             sub      rsp 40
       48894C2430           mov      qword ptr [rsp+30H] rcx

G_M22101_IG02:
       48B9005F64B2F87F0000 mov      rcx 0x7FF8B2645F00
       E8A86B0F5F           call     CORINFO_HELP_NEWSFAST
       480FBE4C2430         movsx    rcx byte  ptr [rsp+30H]
       884808               mov      byte  ptr [rax+8] cl
       488BC8               mov      rcx rax
       E897FBFFFF           call     Dog:IAnimal.MakeSound():this
       90                   nop      

G_M22101_IG03:
       4883C428             add      rsp 40
       C3                   ret      

; Total bytes of code 47 prolog size 4 for method Program:Pattern(struct)
; ============================================================
```

Notice how for `Cast` almost all the code including the boxing allocation is optimized away (the remaining `mov` seems to be unnecessary but that's not really relevant here). But for `Pattern` all the code is still there including an allocation and a non-inlined call to `Dog.IAnimal.MakeSound`.

The two versions of the code do the same thing so I think they should have comparable performance. Especially since the pattern matching version is more readable and I suspect it's also going to be more common in new code than the other version.

How hard would it be to make this optimization work even in the pattern matching version?

If it would be too hard to perform this optimization in the JIT is there a reasonable way for the C# compiler to emit IL that would be optmized?

cc (?): @AndyAyersMS @benaadams @justinvp

category:cq
theme:importer
skill-level:expert
cost:medium</Description>
    <Title_Description>Undoing boxing doesn't work with C# 7 pattern matching Short version: I was reading @stephentoub's article [*Performance Improvements in .NET Core 2.1*](https://blogs.msdn.microsoft.com/dotnet/2018/04/18/performance-improvements-in-net-core-2-1/). I noticed that his example for avoiding boxing allocations thanks to https://github.com/dotnet/coreclr/pull/14698 uses `is` followed by a cast when in C# 7 the same code could be simplified using pattern matching. So I was wondering if using C# 7 features also results in the same efficient code. It turns out it doesn't and I think this should be improved.

More details:

Consider this code:

```c#
using System.Runtime.CompilerServices;

class Program
{
    static void Main()
    {
        Cast(new Dog());
        Pattern(new Dog());
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    static void Cast&lt;T&gt;(T thing)
    {
        if (thing is IAnimal)
            ((IAnimal)thing).MakeSound();
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    static void Pattern&lt;T&gt;(T thing)
    {
        if (thing is IAnimal animal)
            animal.MakeSound();
    }    
}

struct Dog : IAnimal
{
    public void Bark() { }
    void IAnimal.MakeSound() =&gt; Bark();
}

interface IAnimal
{
    void MakeSound();
}
```

The IL for the relevant methods is:

```cil
.method private hidebysig static void  Cast&lt;T&gt;(!!T thing) cil managed noinlining
{
  // Code size       30 (0x1e)
  .maxstack  8
  IL_0000:  ldarg.0
  IL_0001:  box        !!T
  IL_0006:  isinst     IAnimal
  IL_000b:  brfalse.s  IL_001d
  IL_000d:  ldarg.0
  IL_000e:  box        !!T
  IL_0013:  castclass  IAnimal
  IL_0018:  callvirt   instance void IAnimal::MakeSound()
  IL_001d:  ret
}

.method private hidebysig static void  Pattern&lt;T&gt;(!!T thing) cil managed noinlining
{
  // Code size       22 (0x16)
  .maxstack  2
  .locals init (class IAnimal V_0)
  IL_0000:  ldarg.0
  IL_0001:  box        !!T
  IL_0006:  isinst     IAnimal
  IL_000b:  dup
  IL_000c:  stloc.0
  IL_000d:  brfalse.s  IL_0015
  IL_000f:  ldloc.0
  IL_0010:  callvirt   instance void IAnimal::MakeSound()
  IL_0015:  ret
}
```

Notice how in `Pattern` the boxed object is saved to a local variable (typed as the interface).

The disassembly from .Net Core 2.1.0-preview2-26406-04 win10-x64 is:

```asm
; Assembly listing for method Program:Cast(struct)
; Emitting BLENDED_CODE for X64 CPU with AVX
; optimized code
; rsp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  2  2   )  struct ( 8) [rsp+0x08]   do-not-enreg[XS] addr-exposed
;* V01 tmp0         [V01    ] (  0  0   )     ref  -&gt;  zero-ref    class-hnd exact
;* V02 tmp1         [V02    ] (  0  0   )  struct ( 8) zero-ref    do-not-enreg[SF] class-hnd exact
;# V03 OutArgs      [V03    ] (  1  1   )  lclBlk ( 0) [rsp+0x00]  
;
; Lcl frame size = 0

G_M19994_IG01:
       48894C2408           mov      qword ptr [rsp+08H] rcx

G_M19994_IG02:
       C3                   ret      

; Total bytes of code 6 prolog size 0 for method Program:Cast(struct)
; ============================================================
; Assembly listing for method Program:Pattern(struct)
; Emitting BLENDED_CODE for X64 CPU with AVX
; optimized code
; rsp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00    ] (  4  4   )  struct ( 8) [rsp+0x30]   do-not-enreg[XSF] addr-exposed
;  V01 loc0         [V01T02] (  3  2   )     ref  -&gt;  rax         class-hnd exact
;  V02 tmp0         [V02T00] (  4  8   )     ref  -&gt;  rax         class-hnd exact
;  V03 tmp1         [V03T01] (  2  4   )     ref  -&gt;  rax         class-hnd exact
;  V04 OutArgs      [V04    ] (  1  1   )  lclBlk (32) [rsp+0x00]  
;
; Lcl frame size = 40

G_M22101_IG01:
       4883EC28             sub      rsp 40
       48894C2430           mov      qword ptr [rsp+30H] rcx

G_M22101_IG02:
       48B9005F64B2F87F0000 mov      rcx 0x7FF8B2645F00
       E8A86B0F5F           call     CORINFO_HELP_NEWSFAST
       480FBE4C2430         movsx    rcx byte  ptr [rsp+30H]
       884808               mov      byte  ptr [rax+8] cl
       488BC8               mov      rcx rax
       E897FBFFFF           call     Dog:IAnimal.MakeSound():this
       90                   nop      

G_M22101_IG03:
       4883C428             add      rsp 40
       C3                   ret      

; Total bytes of code 47 prolog size 4 for method Program:Pattern(struct)
; ============================================================
```

Notice how for `Cast` almost all the code including the boxing allocation is optimized away (the remaining `mov` seems to be unnecessary but that's not really relevant here). But for `Pattern` all the code is still there including an allocation and a non-inlined call to `Dog.IAnimal.MakeSound`.

The two versions of the code do the same thing so I think they should have comparable performance. Especially since the pattern matching version is more readable and I suspect it's also going to be more common in new code than the other version.

How hard would it be to make this optimization work even in the pattern matching version?

If it would be too hard to perform this optimization in the JIT is there a reasonable way for the C# compiler to emit IL that would be optmized?

cc (?): @AndyAyersMS @benaadams @justinvp

category:cq
theme:importer
skill-level:expert
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>stephentoub</Assignee>
    <CreatedAt>19/04/2018 3:44:24 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17669</IssueLabelID>
    <Title>There is something fishy going on with CLRVectoredExceptionHandler/DontCallDirectlyForceStackOverflow</Title>
    <Description>At the ISV I work for we have been getting some strange crashes from our C++ application recently with the following "signature": our process crashed because of a (recursive) stack overflow but the actual exception was an access violation and not a stack overflow.

This suggests that the guard area on the stack was committed and that extra stack space provided by the guard area also ran out. I confirmed this by looking at some minidumps with the `!address` command of windbg and inspecting the stack regions of the crashing thread. My initial suspicion was that some 3rd party must be swallowing stack overflows essentially leaving the guard area "disarmed" on the stack which later leads to an access violation when the stack "physically runs out".

Some time later I got my hands on a repro. Even though I couldn't repro the exact scenario above I was faced with this call stack:

```
00 clr!DontCallDirectlyForceStackOverflow+0x10
01 clr!CLRVectoredExceptionHandler+0xa8
02 clr!CLRVectoredExceptionHandlerShim+0xa3
03 ntdll!RtlpCallVectoredHandlers+0xea
04 ntdll!RtlDispatchException+0x6b
05 ntdll!KiUserExceptionDispatch+0x2e
06 clr!DontCallDirectlyForceStackOverflow+0x10
07 clr!CLRVectoredExceptionHandler+0xa8
08 clr!CLRVectoredExceptionHandlerShim+0xa3
09 ntdll!RtlpCallVectoredHandlers+0xea
0a ntdll!RtlDispatchException+0x6b
0b ntdll!RtlRaiseException+0x303
0c KERNELBASE!RaiseException+0x68
0d [our application throws an SEH exception with a custom code here]
[...] /* we are close to a stack overflow at this point but not quite there yet... */
```

Not so long ago we started using a mixed DLL (a mostly-C++ module compiled with /clr) in our application which explains why we are getting this kind of crashes only recently.

I had a peek at `src\vm\excep.cpp` and quickly realized that there are things going on way above my pay grade so I thought it would be more productive to open a GitHub issue and ask around. From what I could understand in this particular case your VEH:
- decides that this is an exception it's interested in
- checks if there is enough stack space left with `IsStackSpaceAvailable` (2 pages at least because of `ADJUST_PROBE`) for handling this exception
- detects that there are less than 2 pages between the ~current stack pointer and the guard area so it calls `DontCallDirectlyForceStackOverflow`
- `DontCallDirectlyForceStackOverflow` induces a stack overflow which will implicitly commit the guard area
- your VEH is called back (again)
- it decides again that it's interested and calls `DontCallDirectlyForceStackOverflow` again
- this causes an unrecoverable access violation

I have the following questions:

1. What are you trying to achieve with committing the guard area?
Are you trying to make more space for handling the exception? What kind of handling? This might be a bit stubborn on my side but I'd think that if you reach the point on the stack when the guard area "can't slide upwards anymore" that's a stack overflow by definition and you shouldn't be doing anything other than maybe reporting and tearing down the process.
2. Do you know of any scenario where you commit the guard area but swallow/survive the exception?
I'm looking for an explanation of our "original" scenario where the stack overflow manifests in an access violation with no apparent sight of a 3rd party module/component (such as clr.dll).
3. Are there any guidelines/recommendations on living together with a mixed DLL in the same process?

I don't know if this is relevant but on all of our threads we set the stack guarantee to 5 pages (20'480).

If you'd like to have a closer look at this I can provide you with minidumps (on some private channel).

Thanks!</Description>
    <Title_Description>There is something fishy going on with CLRVectoredExceptionHandler/DontCallDirectlyForceStackOverflow At the ISV I work for we have been getting some strange crashes from our C++ application recently with the following "signature": our process crashed because of a (recursive) stack overflow but the actual exception was an access violation and not a stack overflow.

This suggests that the guard area on the stack was committed and that extra stack space provided by the guard area also ran out. I confirmed this by looking at some minidumps with the `!address` command of windbg and inspecting the stack regions of the crashing thread. My initial suspicion was that some 3rd party must be swallowing stack overflows essentially leaving the guard area "disarmed" on the stack which later leads to an access violation when the stack "physically runs out".

Some time later I got my hands on a repro. Even though I couldn't repro the exact scenario above I was faced with this call stack:

```
00 clr!DontCallDirectlyForceStackOverflow+0x10
01 clr!CLRVectoredExceptionHandler+0xa8
02 clr!CLRVectoredExceptionHandlerShim+0xa3
03 ntdll!RtlpCallVectoredHandlers+0xea
04 ntdll!RtlDispatchException+0x6b
05 ntdll!KiUserExceptionDispatch+0x2e
06 clr!DontCallDirectlyForceStackOverflow+0x10
07 clr!CLRVectoredExceptionHandler+0xa8
08 clr!CLRVectoredExceptionHandlerShim+0xa3
09 ntdll!RtlpCallVectoredHandlers+0xea
0a ntdll!RtlDispatchException+0x6b
0b ntdll!RtlRaiseException+0x303
0c KERNELBASE!RaiseException+0x68
0d [our application throws an SEH exception with a custom code here]
[...] /* we are close to a stack overflow at this point but not quite there yet... */
```

Not so long ago we started using a mixed DLL (a mostly-C++ module compiled with /clr) in our application which explains why we are getting this kind of crashes only recently.

I had a peek at `src\vm\excep.cpp` and quickly realized that there are things going on way above my pay grade so I thought it would be more productive to open a GitHub issue and ask around. From what I could understand in this particular case your VEH:
- decides that this is an exception it's interested in
- checks if there is enough stack space left with `IsStackSpaceAvailable` (2 pages at least because of `ADJUST_PROBE`) for handling this exception
- detects that there are less than 2 pages between the ~current stack pointer and the guard area so it calls `DontCallDirectlyForceStackOverflow`
- `DontCallDirectlyForceStackOverflow` induces a stack overflow which will implicitly commit the guard area
- your VEH is called back (again)
- it decides again that it's interested and calls `DontCallDirectlyForceStackOverflow` again
- this causes an unrecoverable access violation

I have the following questions:

1. What are you trying to achieve with committing the guard area?
Are you trying to make more space for handling the exception? What kind of handling? This might be a bit stubborn on my side but I'd think that if you reach the point on the stack when the guard area "can't slide upwards anymore" that's a stack overflow by definition and you shouldn't be doing anything other than maybe reporting and tearing down the process.
2. Do you know of any scenario where you commit the guard area but swallow/survive the exception?
I'm looking for an explanation of our "original" scenario where the stack overflow manifests in an access violation with no apparent sight of a 3rd party module/component (such as clr.dll).
3. Are there any guidelines/recommendations on living together with a mixed DLL in the same process?

I don't know if this is relevant but on all of our threads we set the stack guarantee to 5 pages (20'480).

If you'd like to have a closer look at this I can provide you with minidumps (on some private channel).

Thanks!</Title_Description>
    <Label>area-ExceptionHandling</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>19/04/2018 3:03:22 PM +00:00</CreatedAt>
    <ClosedAt>9/05/2018 9:32:17 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17666</IssueLabelID>
    <Title>Azure Sphere Support</Title>
    <Description>Understanding [Azure Sphere](https://azure.microsoft.com/en-us/blog/introducing-microsoft-azure-sphere-secure-and-power-the-intelligent-edge/) has not even been released yet I was wondering if .NET Core will be supported?</Description>
    <Title_Description>Azure Sphere Support Understanding [Azure Sphere](https://azure.microsoft.com/en-us/blog/introducing-microsoft-azure-sphere-secure-and-power-the-intelligent-edge/) has not even been released yet I was wondering if .NET Core will be supported?</Title_Description>
    <Label>area-Meta</Label>
    <Assignee>richlander</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17665</IssueLabelID>
    <Title>[Arm64] Use proper lowering for TYP_SIMD8/TYP_LONG type</Title>
    <Description>Not sure if this function call (FixupIfSIMDLocal) is needed for ARM64.
@CarolEidt @sdmaclea PTAL.

Removing the FixupIfSIMDLocal() in Rationalizer  fixes the SIMD assertion error seen with JITMinOpts=1 (Ref #17111 ) for type TYP_SIMD8 below.

Assert failure(PID 9366 [0x00002496] Thread: 9366 [0x2496]): Assertion failed '(consume &gt; 1) || (regType(store-&gt;gtOp1-&gt;TypeGet()) == regType(store-&gt;TypeGet()))' in 'Arm64intrisicsTest.Program:testBinOp(refrefref)' (IL size 408)
File: /home/debayan/coreclr/src/jit/lsrabuild.cpp Line: 1383

</Description>
    <Title_Description>[Arm64] Use proper lowering for TYP_SIMD8/TYP_LONG type Not sure if this function call (FixupIfSIMDLocal) is needed for ARM64.
@CarolEidt @sdmaclea PTAL.

Removing the FixupIfSIMDLocal() in Rationalizer  fixes the SIMD assertion error seen with JITMinOpts=1 (Ref #17111 ) for type TYP_SIMD8 below.

Assert failure(PID 9366 [0x00002496] Thread: 9366 [0x2496]): Assertion failed '(consume &gt; 1) || (regType(store-&gt;gtOp1-&gt;TypeGet()) == regType(store-&gt;TypeGet()))' in 'Arm64intrisicsTest.Program:testBinOp(refrefref)' (IL size 408)
File: /home/debayan/coreclr/src/jit/lsrabuild.cpp Line: 1383

</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>CarolEidt</Assignee>
    <CreatedAt>19/04/2018 10:49:21 AM +00:00</CreatedAt>
    <ClosedAt>29/07/2019 6:27:27 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17663</IssueLabelID>
    <Title>Remove debug/checked builds</Title>
    <Description>The debug/checked builds don't publish and aren't submitted for testing currently.  To reduce resource usage during the build do not build these pipelines for now.</Description>
    <Title_Description>Remove debug/checked builds The debug/checked builds don't publish and aren't submitted for testing currently.  To reduce resource usage during the build do not build these pipelines for now.</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>mmitche</Assignee>
    <CreatedAt>19/04/2018 3:30:19 AM +00:00</CreatedAt>
    <ClosedAt>19/04/2018 7:55:55 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17661</IssueLabelID>
    <Title>MediaType.GetHashCode() throws System.ExecutionEngineException</Title>
    <Description>_From @austindrenski on April 17 2018 20:49_

`MediaType.GetHashCode()` throws a `System.ExecutionEngineException` in an ASP.NET Core application. 

I've included a minimal project that consistently reproduces the exception on my local machine. 

Does anyone have an idea of what's behind this?

__Program.cs:__
```c#
using System;
using Microsoft.AspNetCore;
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Mvc.Formatters;

namespace test
{
    public static class Program
    {
        public static void Main(string[] args)
        {
            MediaType t = new MediaType("text/csv");

            // throws =&gt; System.ExecutionEngineException
            Console.WriteLine(t.GetHashCode());

            WebHost.CreateDefaultBuilder(args)
                   .Build()
                   .Run();
        }
    }
}
```
__test.csproj__
```xml
&lt;Project Sdk="Microsoft.NET.Sdk.Web"&gt;

  &lt;PropertyGroup&gt;
    &lt;OutputType&gt;Exe&lt;/OutputType&gt;
    &lt;TargetFramework&gt;netcoreapp2.0&lt;/TargetFramework&gt;
    &lt;LangVersion&gt;latest&lt;/LangVersion&gt;
  &lt;/PropertyGroup&gt;

  &lt;ItemGroup&gt;
    &lt;PackageReference Include="Microsoft.AspNetCore.All" Version="2.0.5" /&gt;
  &lt;/ItemGroup&gt;

&lt;/Project&gt;
```

_Copied from original issue: aspnet/Mvc#7673_</Description>
    <Title_Description>MediaType.GetHashCode() throws System.ExecutionEngineException _From @austindrenski on April 17 2018 20:49_

`MediaType.GetHashCode()` throws a `System.ExecutionEngineException` in an ASP.NET Core application. 

I've included a minimal project that consistently reproduces the exception on my local machine. 

Does anyone have an idea of what's behind this?

__Program.cs:__
```c#
using System;
using Microsoft.AspNetCore;
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Mvc.Formatters;

namespace test
{
    public static class Program
    {
        public static void Main(string[] args)
        {
            MediaType t = new MediaType("text/csv");

            // throws =&gt; System.ExecutionEngineException
            Console.WriteLine(t.GetHashCode());

            WebHost.CreateDefaultBuilder(args)
                   .Build()
                   .Run();
        }
    }
}
```
__test.csproj__
```xml
&lt;Project Sdk="Microsoft.NET.Sdk.Web"&gt;

  &lt;PropertyGroup&gt;
    &lt;OutputType&gt;Exe&lt;/OutputType&gt;
    &lt;TargetFramework&gt;netcoreapp2.0&lt;/TargetFramework&gt;
    &lt;LangVersion&gt;latest&lt;/LangVersion&gt;
  &lt;/PropertyGroup&gt;

  &lt;ItemGroup&gt;
    &lt;PackageReference Include="Microsoft.AspNetCore.All" Version="2.0.5" /&gt;
  &lt;/ItemGroup&gt;

&lt;/Project&gt;
```

_Copied from original issue: aspnet/Mvc#7673_</Title_Description>
    <Label>
    </Label>
    <Assignee>jkotas</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17657</IssueLabelID>
    <Title>Port to 2.1: Fix ephemeral limits checks in write barrier for ARM64</Title>
    <Description>The code was incorrectly using signed conditions which doesn't work for
server GC where the high ephemeral limit is 0xffffffffffffffff and so it
was checking if the address is less than -1 which is never the case. So
the card table was never updated.</Description>
    <Title_Description>Port to 2.1: Fix ephemeral limits checks in write barrier for ARM64 The code was incorrectly using signed conditions which doesn't work for
server GC where the high ephemeral limit is 0xffffffffffffffff and so it
was checking if the address is less than -1 which is never the case. So
the card table was never updated.</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>janvorli</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17656</IssueLabelID>
    <Title>Fix GC leakwheel scenario test</Title>
    <Description>Related to #16061 - JIT may extend the lifetime of the object causing some objects to not get added to finalizer queue. This should at least stabilize the CI part but I'm not sure why calling GC.Collect(2) and GC.WaitForPendingFinalizers() 3 times instead of 2 should do any change in behavior. Will look into that part and follow up with subsequent fixes if I find anything.</Description>
    <Title_Description>Fix GC leakwheel scenario test Related to #16061 - JIT may extend the lifetime of the object causing some objects to not get added to finalizer queue. This should at least stabilize the CI part but I'm not sure why calling GC.Collect(2) and GC.WaitForPendingFinalizers() 3 times instead of 2 should do any change in behavior. Will look into that part and follow up with subsequent fixes if I find anything.</Title_Description>
    <Label>
    </Label>
    <Assignee>sywhang</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17654</IssueLabelID>
    <Title>[Arm64/Linux] #16962 Broke arm64 crosscomponent build</Title>
    <Description>@CarolEidt 
cc/ @weshaggard </Description>
    <Title_Description>[Arm64/Linux] #16962 Broke arm64 crosscomponent build @CarolEidt 
cc/ @weshaggard </Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17653</IssueLabelID>
    <Title>GCStress: force fully interruptible GC info</Title>
    <Description>Does the JIT have a stress mode that forces fully interruptible GC info?

An interesting stress mode would be:
1. GCStress=4
2. ZapDisable=1
3. force fully interruptible GC info


category:correctness
theme:testing
skill-level:beginner
cost:small</Description>
    <Title_Description>GCStress: force fully interruptible GC info Does the JIT have a stress mode that forces fully interruptible GC info?

An interesting stress mode would be:
1. GCStress=4
2. ZapDisable=1
3. force fully interruptible GC info


category:correctness
theme:testing
skill-level:beginner
cost:small</Title_Description>
    <Label>GCStress</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>18/04/2018 7:49:47 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17651</IssueLabelID>
    <Title>GCStress: instrumented instructions only force a GC once</Title>
    <Description>One possible limitation of GCStress today is that each instruction is instrumented and stressed only once. After GC is run on an instrumented instruction that instrumented instruction is replaced by its original instruction so it never triggers a GC again. This means if a hole exists at an instruction but isn't triggered by the first run of the instruction we will miss it. This was potentially the case with the JIT creating illegal byrefs fixed by https://github.com/dotnet/coreclr/pull/17524.

Possibly introduce a (super slow) mode where we don't replace the instrumented instructions by their original instructions or not immediately. Or periodically re-instrument functions.</Description>
    <Title_Description>GCStress: instrumented instructions only force a GC once One possible limitation of GCStress today is that each instruction is instrumented and stressed only once. After GC is run on an instrumented instruction that instrumented instruction is replaced by its original instruction so it never triggers a GC again. This means if a hole exists at an instruction but isn't triggered by the first run of the instruction we will miss it. This was potentially the case with the JIT creating illegal byrefs fixed by https://github.com/dotnet/coreclr/pull/17524.

Possibly introduce a (super slow) mode where we don't replace the instrumented instructions by their original instructions or not immediately. Or periodically re-instrument functions.</Title_Description>
    <Label>GCStress</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>18/04/2018 7:48:19 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17650</IssueLabelID>
    <Title>[Arm64/Linux] Enable crosscomponent build in CI</Title>
    <Description>#16962 Broke arm64 crosscomponent build.  It would be better to catch these earlier during build.  This would also provide some JIT testing as the S.P.C.dll will be crossgened</Description>
    <Title_Description>[Arm64/Linux] Enable crosscomponent build in CI #16962 Broke arm64 crosscomponent build.  It would be better to catch these earlier during build.  This would also provide some JIT testing as the S.P.C.dll will be crossgened</Title_Description>
    <Label>
    </Label>
    <Assignee>sdmaclea</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17649</IssueLabelID>
    <Title>GCStress: ensure every object moves on a GC</Title>
    <Description>At least every object that is legal to move should move.

One problem with GCStress today is that when a GC occurs most of the time (in some measurement I've done) objects don't actually move. This means that bad GC info doesn't get noticed.
</Description>
    <Title_Description>GCStress: ensure every object moves on a GC At least every object that is legal to move should move.

One problem with GCStress today is that when a GC occurs most of the time (in some measurement I've done) objects don't actually move. This means that bad GC info doesn't get noticed.
</Title_Description>
    <Label>GCStress</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>18/04/2018 6:46:13 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17647</IssueLabelID>
    <Title>GcStress: need some way to verify that all expected methods get instrumented</Title>
    <Description>In the instrumenting GC stress modes we should introduce some mechanism to verify that all the methods we expect to get instrumented actually do end up getting instrumented. Otherwise we risk losing stress coverage.

Because un-instrumented methods won't provoke additional GCs the fact that they are not instrumented tends to be hard to observe.</Description>
    <Title_Description>GcStress: need some way to verify that all expected methods get instrumented In the instrumenting GC stress modes we should introduce some mechanism to verify that all the methods we expect to get instrumented actually do end up getting instrumented. Otherwise we risk losing stress coverage.

Because un-instrumented methods won't provoke additional GCs the fact that they are not instrumented tends to be hard to observe.</Title_Description>
    <Label>GCStress</Label>
    <Assignee>AndyAyersMS</Assignee>
    <CreatedAt>18/04/2018 6:34:17 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17646</IssueLabelID>
    <Title>GcStress: handle rejitting </Title>
    <Description>Rejitted code is currently not getting instrumented for GC stress.

Since the original code is still viable we can't simply clear/clobber the `m_GcCover` field in the MethodDescriptor on a rejit -- instead we need a way of having a code version specific set of GcCover infos for a method.

Similar issues likely apply to profiler-initiated rejitting.

cc @noahfalk 

</Description>
    <Title_Description>GcStress: handle rejitting  Rejitted code is currently not getting instrumented for GC stress.

Since the original code is still viable we can't simply clear/clobber the `m_GcCover` field in the MethodDescriptor on a rejit -- instead we need a way of having a code version specific set of GcCover infos for a method.

Similar issues likely apply to profiler-initiated rejitting.

cc @noahfalk 

</Title_Description>
    <Label>GCStress</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17645</IssueLabelID>
    <Title>GcStress: choose strategy for instrumenting prejitted code</Title>
    <Description>GcStress currently tries to instrument NGEN precompiled methods twice: once during `Module::Initialize` (with a twist for the core library) and a second time during `MethodDesc::PrepareILBasedCode` (with a twist for prejitted IL stubs).

R2R precompiled methods are never instrumented currently.

Seems like we should have only one strategy and it should apply to all cases of prejitted code.

Early instrumentation during module load is nice because it avoids race conditions that can plague on-demand instrumentation. But there is an upfront cost as potentially thousands of methods need to be instrumented but only a few of them will ever be executed.

Late instrumentation is more pay for play but must be done carefully so that no thread can see a partially instrumented method.</Description>
    <Title_Description>GcStress: choose strategy for instrumenting prejitted code GcStress currently tries to instrument NGEN precompiled methods twice: once during `Module::Initialize` (with a twist for the core library) and a second time during `MethodDesc::PrepareILBasedCode` (with a twist for prejitted IL stubs).

R2R precompiled methods are never instrumented currently.

Seems like we should have only one strategy and it should apply to all cases of prejitted code.

Early instrumentation during module load is nice because it avoids race conditions that can plague on-demand instrumentation. But there is an upfront cost as potentially thousands of methods need to be instrumented but only a few of them will ever be executed.

Late instrumentation is more pay for play but must be done carefully so that no thread can see a partially instrumented method.</Title_Description>
    <Label>GCStress</Label>
    <Assignee>AndyAyersMS</Assignee>
    <CreatedAt>18/04/2018 6:26:24 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17644</IssueLabelID>
    <Title>port #17618 to the 2.1 branch (Disable timeout test)</Title>
    <Description>disable DevDiv_255294 in stress modes. (PR to master #17618 issue #17605) 

It is a test only change.</Description>
    <Title_Description>port #17618 to the 2.1 branch (Disable timeout test) disable DevDiv_255294 in stress modes. (PR to master #17618 issue #17605) 

It is a test only change.</Title_Description>
    <Label>disabled-test</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>18/04/2018 6:26:06 PM +00:00</CreatedAt>
    <ClosedAt>21/04/2018 2:14:21 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17641</IssueLabelID>
    <Title>Fix ephemeral limits checks in write barrier for ARM64</Title>
    <Description>The code was incorrectly using signed conditions which doesn't work for
server GC where the high ephemeral limit is 0xffffffffffffffff and so it
was checking if the address is less than -1 which is never the case. So
the card table was never updated.

Close #17640</Description>
    <Title_Description>Fix ephemeral limits checks in write barrier for ARM64 The code was incorrectly using signed conditions which doesn't work for
server GC where the high ephemeral limit is 0xffffffffffffffff and so it
was checking if the address is less than -1 which is never the case. So
the card table was never updated.

Close #17640</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>janvorli</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17640</IssueLabelID>
    <Title>Wrong check of ephemeral limits in JIT_WriteBarrier for ARM64</Title>
    <Description>The code is incorrectly using signed comparison which doesn't work for
server GC where the high ephemeral limit is 0xffffffffffffffff and so it
is checking if the address is less than -1 which is never the case. So
the card table is never updated.</Description>
    <Title_Description>Wrong check of ephemeral limits in JIT_WriteBarrier for ARM64 The code is incorrectly using signed comparison which doesn't work for
server GC where the high ephemeral limit is 0xffffffffffffffff and so it
is checking if the address is less than -1 which is never the case. So
the card table is never updated.</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>janvorli</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17639</IssueLabelID>
    <Title>Enable Invoke and GetValue for ref-returning members</Title>
    <Description>https://github.com/dotnet/corefx/issues/15960

Returned magic object is the object pointed to by
the ref. If the ref is null NullReferenceException.</Description>
    <Title_Description>Enable Invoke and GetValue for ref-returning members https://github.com/dotnet/corefx/issues/15960

Returned magic object is the object pointed to by
the ref. If the ref is null NullReferenceException.</Title_Description>
    <Label>area-System.Reflection</Label>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17637</IssueLabelID>
    <Title>Improve Intel hardware intrinsic APIs</Title>
    <Description>This PR
1. fixes https://github.com/dotnet/coreclr/issues/17058 and temporarily disables AVX MaskLoad test cases.
2. &lt;del&gt;encodes the result flags in the names of certain SSE4.2 string processing intrinsic. That provides more stable runtime behaviors and simplifies JIT implementation discussed in https://github.com/dotnet/coreclr/issues/16270&lt;/del&gt;
3. Fixes SSE4.1 `Insert` API on `float` base type closes https://github.com/dotnet/coreclr/issues/18143.
4. Fixes SSE2/SSE4.1/AVX `Extract` return type to reflect the underlying instruction behavior closes https://github.com/dotnet/coreclr/issues/17957

@CarolEidt @tannergooding @eerhardt </Description>
    <Title_Description>Improve Intel hardware intrinsic APIs This PR
1. fixes https://github.com/dotnet/coreclr/issues/17058 and temporarily disables AVX MaskLoad test cases.
2. &lt;del&gt;encodes the result flags in the names of certain SSE4.2 string processing intrinsic. That provides more stable runtime behaviors and simplifies JIT implementation discussed in https://github.com/dotnet/coreclr/issues/16270&lt;/del&gt;
3. Fixes SSE4.1 `Insert` API on `float` base type closes https://github.com/dotnet/coreclr/issues/18143.
4. Fixes SSE2/SSE4.1/AVX `Extract` return type to reflect the underlying instruction behavior closes https://github.com/dotnet/coreclr/issues/17957

@CarolEidt @tannergooding @eerhardt </Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
    <CreatedAt>18/04/2018 9:17:11 AM +00:00</CreatedAt>
    <ClosedAt>18/06/2018 8:17:42 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17634</IssueLabelID>
    <Title>[x86/Windows] Failure in jitstress=2 jitstressregs=3 job</Title>
    <Description>https://ci.dot.net/job/dotnet_coreclr/job/master/view/x86/job/jitstress/job/x86_checked_windows_nt_jitstress2_jitstressregs3/473/consoleText

BEGIN EXECUTION
         "D:\j\workspace\x86_checked_w---508bfa85\tests\..\bin\tests\Windows_NT.x86.Checked\Tests\Core_Root\corerun.exe" MaskMove_r.exe 
        Expected: 100
        Actual: 73294136
        END EXECUTION - FAILED
        FAILED
        Test Harness Exitcode is : 1
        
  To run the test:
  &gt; set CORE_ROOT=D:\j\workspace\x86_checked_w---508bfa85\bin\tests\Windows_NT.x86.Checked\Tests\Core_Root
  &gt; D:\j\workspace\x86_checked_w---508bfa85\bin\tests\Windows_NT.x86.Checked\JIT\HardwareIntrinsics\X86\Sse2\MaskMove_r\MaskMove_r.cmd
  
        Expected: True
        Actual:   False</Description>
    <Title_Description>[x86/Windows] Failure in jitstress=2 jitstressregs=3 job https://ci.dot.net/job/dotnet_coreclr/job/master/view/x86/job/jitstress/job/x86_checked_windows_nt_jitstress2_jitstressregs3/473/consoleText

BEGIN EXECUTION
         "D:\j\workspace\x86_checked_w---508bfa85\tests\..\bin\tests\Windows_NT.x86.Checked\Tests\Core_Root\corerun.exe" MaskMove_r.exe 
        Expected: 100
        Actual: 73294136
        END EXECUTION - FAILED
        FAILED
        Test Harness Exitcode is : 1
        
  To run the test:
  &gt; set CORE_ROOT=D:\j\workspace\x86_checked_w---508bfa85\bin\tests\Windows_NT.x86.Checked\Tests\Core_Root
  &gt; D:\j\workspace\x86_checked_w---508bfa85\bin\tests\Windows_NT.x86.Checked\JIT\HardwareIntrinsics\X86\Sse2\MaskMove_r\MaskMove_r.cmd
  
        Expected: True
        Actual:   False</Title_Description>
    <Label>JitStress</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17632</IssueLabelID>
    <Title>[x64/Windows] waitone2 test failures</Title>
    <Description>https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64/job/jitstress/job/x64_checked_windows_nt_jitstress1/491/consoleText

BEGIN EXECUTION
         "D:\j\workspace\x64_checked_w---02832afb\tests\..\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root\corerun.exe" waitone2.exe 
        Beginning test case MutexWaitOne2 at 4/16/2018 7:33:49 PM
        Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
        
        [Positive]
        Beginning scenario: PosTest1: Wait Infinite
        Beginning scenario: PosTest2: Wait some finite time
        Beginning scenario: PosTest3: Wait some finite time will quit for timeout
        ERROR!!!-004: WaitOne returns true when wait time out
        Beginning scenario: PosTest4: Wait some finite time will quit for timeout when another thread is in nondefault managed context
        Beginning scenario: PosTest5: Wait some finite time will quit for timeout when another thread is in nondefault managed context
        Beginning scenario: PosTest6: Wait infinite time when another thread is in nondefault managed context
        Beginning scenario: PosTest7: Wait infinite time when another thread is in nondefault managed context
        [Negative]
        Beginning scenario: NegTest1: AbandonedMutexException should be thrown if a thread exited without releasing a mutex
        Beginning scenario: NegTest2: ObjectDisposedException should be thrown if current instance has already been disposed
        Beginning scenario: NegTest3: Check ArgumentOutOfRangeException will be thrown if millisecondsTimeout is a negative number other than -1
        
        Ending test case at 4/16/2018 7:34:22 PM
        FAIL
        Expected: 100
        Actual: 0
        END EXECUTION - FAILED
        FAILED
        Test Harness Exitcode is : 1
        
  To run the test:
  &gt; set CORE_ROOT=D:\j\workspace\x64_checked_w---02832afb\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root
  &gt; D:\j\workspace\x64_checked_w---02832afb\bin\tests\Windows_NT.x64.Checked\baseservices\threading\mutex\misc\waitone2\waitone2.cmd
  
        Expected: True
        Actual:   False</Description>
    <Title_Description>[x64/Windows] waitone2 test failures https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64/job/jitstress/job/x64_checked_windows_nt_jitstress1/491/consoleText

BEGIN EXECUTION
         "D:\j\workspace\x64_checked_w---02832afb\tests\..\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root\corerun.exe" waitone2.exe 
        Beginning test case MutexWaitOne2 at 4/16/2018 7:33:49 PM
        Random seed: 20010415; set environment variable CORECLR_SEED to this value to repro
        
        [Positive]
        Beginning scenario: PosTest1: Wait Infinite
        Beginning scenario: PosTest2: Wait some finite time
        Beginning scenario: PosTest3: Wait some finite time will quit for timeout
        ERROR!!!-004: WaitOne returns true when wait time out
        Beginning scenario: PosTest4: Wait some finite time will quit for timeout when another thread is in nondefault managed context
        Beginning scenario: PosTest5: Wait some finite time will quit for timeout when another thread is in nondefault managed context
        Beginning scenario: PosTest6: Wait infinite time when another thread is in nondefault managed context
        Beginning scenario: PosTest7: Wait infinite time when another thread is in nondefault managed context
        [Negative]
        Beginning scenario: NegTest1: AbandonedMutexException should be thrown if a thread exited without releasing a mutex
        Beginning scenario: NegTest2: ObjectDisposedException should be thrown if current instance has already been disposed
        Beginning scenario: NegTest3: Check ArgumentOutOfRangeException will be thrown if millisecondsTimeout is a negative number other than -1
        
        Ending test case at 4/16/2018 7:34:22 PM
        FAIL
        Expected: 100
        Actual: 0
        END EXECUTION - FAILED
        FAILED
        Test Harness Exitcode is : 1
        
  To run the test:
  &gt; set CORE_ROOT=D:\j\workspace\x64_checked_w---02832afb\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root
  &gt; D:\j\workspace\x64_checked_w---02832afb\bin\tests\Windows_NT.x64.Checked\baseservices\threading\mutex\misc\waitone2\waitone2.cmd
  
        Expected: True
        Actual:   False</Title_Description>
    <Label>area-System.Threading</Label>
    <Assignee>erozenfeld</Assignee>
    <CreatedAt>18/04/2018 12:06:46 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17631</IssueLabelID>
    <Title>[x64/Windows] Failure in heapverify=1 job</Title>
    <Description>https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64/job/jitstress/job/x64_checked_windows_nt_heapverify1/73/consoleText

BEGIN EXECUTION
         "D:\j\workspace\x64_checked_w---facfb6a0\tests\..\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root\corerun.exe" unregister03.exe 
        Test Failed
        Expected: 100
        Actual: 0
        END EXECUTION - FAILED
        FAILED
        Test Harness Exitcode is : 1
        
  To run the test:
  &gt; set CORE_ROOT=D:\j\workspace\x64_checked_w---facfb6a0\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root
  &gt; D:\j\workspace\x64_checked_w---facfb6a0\bin\tests\Windows_NT.x64.Checked\baseservices\threading\threadpool\unregister\unregister03\unregister03.cmd
  
        Expected: True
        Actual:   False
</Description>
    <Title_Description>[x64/Windows] Failure in heapverify=1 job https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64/job/jitstress/job/x64_checked_windows_nt_heapverify1/73/consoleText

BEGIN EXECUTION
         "D:\j\workspace\x64_checked_w---facfb6a0\tests\..\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root\corerun.exe" unregister03.exe 
        Test Failed
        Expected: 100
        Actual: 0
        END EXECUTION - FAILED
        FAILED
        Test Harness Exitcode is : 1
        
  To run the test:
  &gt; set CORE_ROOT=D:\j\workspace\x64_checked_w---facfb6a0\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root
  &gt; D:\j\workspace\x64_checked_w---facfb6a0\bin\tests\Windows_NT.x64.Checked\baseservices\threading\threadpool\unregister\unregister03\unregister03.cmd
  
        Expected: True
        Actual:   False
</Title_Description>
    <Label>arch-x64</Label>
    <Assignee>briansull</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17630</IssueLabelID>
    <Title>Feature Request: During a profiler walk of the GC heap reference graph distinguish references that aren't backed by metadata fields</Title>
    <Description>This is a request from https://github.com/dotnet/coreclr/issues/16274#issuecomment-381434436

&gt; Well could you please add the markers for virtual references in ICorProfilerCallback? I need to know that the reference to LoaderAllocator is virtual. I have the list of classes where the reference to LoaderAllocator isn't virtual. How can I understand after CLR/CoreCLR update that I have to add the new type in the list?


FWIW I don't think that the information needs to be directly provided as an argument of the ICorProfilerCallback::ObjectReferences API (or a numbered extension of the API) but there would need to be some not too complicated and reasonably performant mechanism for a profiler to learn the information. This is part of a broader ask that the profiler wants to understand not just what references an object has but specifically how those references correlate to its fields nested fields array elements etc. Right now profilers are using heuristics because the APIs to access types and type layouts have difficulties in some cases. The implicit references created by collectible assemblies add an additional layer of complexity.</Description>
    <Title_Description>Feature Request: During a profiler walk of the GC heap reference graph, distinguish references that aren't backed by metadata fields This is a request from https://github.com/dotnet/coreclr/issues/16274#issuecomment-381434436

&gt; Well could you please add the markers for virtual references in ICorProfilerCallback? I need to know that the reference to LoaderAllocator is virtual. I have the list of classes where the reference to LoaderAllocator isn't virtual. How can I understand after CLR/CoreCLR update that I have to add the new type in the list?


FWIW I don't think that the information needs to be directly provided as an argument of the ICorProfilerCallback::ObjectReferences API (or a numbered extension of the API) but there would need to be some not too complicated and reasonably performant mechanism for a profiler to learn the information. This is part of a broader ask that the profiler wants to understand not just what references an object has but specifically how those references correlate to its fields nested fields array elements etc. Right now profilers are using heuristics because the APIs to access types and type layouts have difficulties in some cases. The implicit references created by collectible assemblies add an additional layer of complexity.</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>18/04/2018 12:00:32 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17629</IssueLabelID>
    <Title> [x64/Ubuntu] Failures in tailcallstress job</Title>
    <Description>https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64/job/jitstress/job/x64_checked_ubuntu_tailcallstress_tst/323/consoleText

FAILED   - tracing/tracevalidation/tracelogging/tracelogging/tracelogging.sh
               BEGIN EXECUTION
               /mnt/j/workspace/dotnet_coreclr/master/jitstress/x64_checked_ubuntu_tailcallstress_tst/bin/tests/Linux.x64.Checked/Tests/Core_Root/corerun tracelogging.exe
               
               Unhandled Exception: System.TypeLoadException: Could not find type Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses+ILToNativeMap
                  at FastSerialization.Deserializer.GetFactory(String fullName)
                  at FastSerialization.SerializationType.FastSerialization.IFastSerializable.FromStream(Deserializer deserializer)
                  at FastSerialization.Deserializer.ReadObjectDefinition(Tags tag StreamLabel objectLabel)
                  at FastSerialization.Deserializer.ReadObject()
                  at FastSerialization.Deserializer.ReadObjectDefinition(Tags tag StreamLabel objectLabel)
                  at FastSerialization.Deserializer.ReadObject()
                  at Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.&lt;&gt;c__DisplayClass42_0.&lt;FastSerialization.IFastSerializable.FromStream&gt;b__0()
                  at FastSerialization.DeferedRegion.FinishReadHelper(Boolean preserveStreamPosition)
                  at FastSerialization.Deserializer.ReadObjectDefinition(Tags tag StreamLabel objectLabel)
                  at FastSerialization.Deserializer.ReadObject()
                  at Microsoft.Diagnostics.Tracing.Etlx.TraceLog.FastSerialization.IFastSerializable.FromStream(Deserializer deserializer)
                  at FastSerialization.Deserializer.ReadObjectDefinition(Tags tag StreamLabel objectLabel)
                  at FastSerialization.Deserializer.GetEntryObject()
                  at Microsoft.Diagnostics.Tracing.Etlx.TraceLog.InitializeFromFile(String etlxFilePath)
                  at Tracing.Tests.Common.EventSourceTestSuite.RunTests()
                  at Tracing.Tests.TraceLogging.Main(String[] args)
               ./tracelogging.sh: line 244: 64297 Aborted                 (core dumped) $_DebuggerFullPath "$CORE_ROOT/corerun" $ExePath $CLRTestExecutionArguments
               Expected: 100
               Actual: 134
               END EXECUTION - FAILED

FAILED   - tracing/eventsourcetrace/eventsourcetrace/eventsourcetrace.sh
               BEGIN EXECUTION
               /mnt/j/workspace/dotnet_coreclr/master/jitstress/x64_checked_ubuntu_tailcallstress_tst/bin/tests/Linux.x64.Checked/Tests/Core_Root/corerun eventsourcetrace.exe
               	Start: Enable tracing.
               	End: Enable tracing.
               
               	Start: Messaging.
               	End: Messaging.
               
               	Start: Disable tracing.
               	End: Disable tracing.
               
               	Start: Processing events from file.
               
               Unhandled Exception: System.TypeLoadException: Could not find type Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses+ILToNativeMap
                  at FastSerialization.Deserializer.GetFactory(String fullName)
                  at FastSerialization.SerializationType.FastSerialization.IFastSerializable.FromStream(Deserializer deserializer)
                  at FastSerialization.Deserializer.ReadObjectDefinition(Tags tag StreamLabel objectLabel)
                  at FastSerialization.Deserializer.ReadObject()
                  at FastSerialization.Deserializer.ReadObjectDefinition(Tags tag StreamLabel objectLabel)
                  at FastSerialization.Deserializer.ReadObject()
                  at Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.&lt;&gt;c__DisplayClass42_0.&lt;FastSerialization.IFastSerializable.FromStream&gt;b__0()
                  at FastSerialization.DeferedRegion.FinishReadHelper(Boolean preserveStreamPosition)
                  at FastSerialization.Deserializer.ReadObjectDefinition(Tags tag StreamLabel objectLabel)
                  at FastSerialization.Deserializer.ReadObject()
                  at Microsoft.Diagnostics.Tracing.Etlx.TraceLog.FastSerialization.IFastSerializable.FromStream(Deserializer deserializer)
                  at FastSerialization.Deserializer.ReadObjectDefinition(Tags tag StreamLabel objectLabel)
                  at FastSerialization.Deserializer.GetEntryObject()
                  at Microsoft.Diagnostics.Tracing.Etlx.TraceLog.InitializeFromFile(String etlxFilePath)
                  at Tracing.Tests.EventSourceTrace.Main(String[] args)
               ./eventsourcetrace.sh: line 244: 64063 Aborted                 (core dumped) $_DebuggerFullPath "$CORE_ROOT/corerun" $ExePath $CLRTestExecutionArguments
               Expected: 100
               Actual: 134
               END EXECUTION - FAILED</Description>
    <Title_Description> [x64/Ubuntu] Failures in tailcallstress job https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64/job/jitstress/job/x64_checked_ubuntu_tailcallstress_tst/323/consoleText

FAILED   - tracing/tracevalidation/tracelogging/tracelogging/tracelogging.sh
               BEGIN EXECUTION
               /mnt/j/workspace/dotnet_coreclr/master/jitstress/x64_checked_ubuntu_tailcallstress_tst/bin/tests/Linux.x64.Checked/Tests/Core_Root/corerun tracelogging.exe
               
               Unhandled Exception: System.TypeLoadException: Could not find type Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses+ILToNativeMap
                  at FastSerialization.Deserializer.GetFactory(String fullName)
                  at FastSerialization.SerializationType.FastSerialization.IFastSerializable.FromStream(Deserializer deserializer)
                  at FastSerialization.Deserializer.ReadObjectDefinition(Tags tag StreamLabel objectLabel)
                  at FastSerialization.Deserializer.ReadObject()
                  at FastSerialization.Deserializer.ReadObjectDefinition(Tags tag StreamLabel objectLabel)
                  at FastSerialization.Deserializer.ReadObject()
                  at Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.&lt;&gt;c__DisplayClass42_0.&lt;FastSerialization.IFastSerializable.FromStream&gt;b__0()
                  at FastSerialization.DeferedRegion.FinishReadHelper(Boolean preserveStreamPosition)
                  at FastSerialization.Deserializer.ReadObjectDefinition(Tags tag StreamLabel objectLabel)
                  at FastSerialization.Deserializer.ReadObject()
                  at Microsoft.Diagnostics.Tracing.Etlx.TraceLog.FastSerialization.IFastSerializable.FromStream(Deserializer deserializer)
                  at FastSerialization.Deserializer.ReadObjectDefinition(Tags tag StreamLabel objectLabel)
                  at FastSerialization.Deserializer.GetEntryObject()
                  at Microsoft.Diagnostics.Tracing.Etlx.TraceLog.InitializeFromFile(String etlxFilePath)
                  at Tracing.Tests.Common.EventSourceTestSuite.RunTests()
                  at Tracing.Tests.TraceLogging.Main(String[] args)
               ./tracelogging.sh: line 244: 64297 Aborted                 (core dumped) $_DebuggerFullPath "$CORE_ROOT/corerun" $ExePath $CLRTestExecutionArguments
               Expected: 100
               Actual: 134
               END EXECUTION - FAILED

FAILED   - tracing/eventsourcetrace/eventsourcetrace/eventsourcetrace.sh
               BEGIN EXECUTION
               /mnt/j/workspace/dotnet_coreclr/master/jitstress/x64_checked_ubuntu_tailcallstress_tst/bin/tests/Linux.x64.Checked/Tests/Core_Root/corerun eventsourcetrace.exe
               	Start: Enable tracing.
               	End: Enable tracing.
               
               	Start: Messaging.
               	End: Messaging.
               
               	Start: Disable tracing.
               	End: Disable tracing.
               
               	Start: Processing events from file.
               
               Unhandled Exception: System.TypeLoadException: Could not find type Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses+ILToNativeMap
                  at FastSerialization.Deserializer.GetFactory(String fullName)
                  at FastSerialization.SerializationType.FastSerialization.IFastSerializable.FromStream(Deserializer deserializer)
                  at FastSerialization.Deserializer.ReadObjectDefinition(Tags tag StreamLabel objectLabel)
                  at FastSerialization.Deserializer.ReadObject()
                  at FastSerialization.Deserializer.ReadObjectDefinition(Tags tag StreamLabel objectLabel)
                  at FastSerialization.Deserializer.ReadObject()
                  at Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.&lt;&gt;c__DisplayClass42_0.&lt;FastSerialization.IFastSerializable.FromStream&gt;b__0()
                  at FastSerialization.DeferedRegion.FinishReadHelper(Boolean preserveStreamPosition)
                  at FastSerialization.Deserializer.ReadObjectDefinition(Tags tag StreamLabel objectLabel)
                  at FastSerialization.Deserializer.ReadObject()
                  at Microsoft.Diagnostics.Tracing.Etlx.TraceLog.FastSerialization.IFastSerializable.FromStream(Deserializer deserializer)
                  at FastSerialization.Deserializer.ReadObjectDefinition(Tags tag StreamLabel objectLabel)
                  at FastSerialization.Deserializer.GetEntryObject()
                  at Microsoft.Diagnostics.Tracing.Etlx.TraceLog.InitializeFromFile(String etlxFilePath)
                  at Tracing.Tests.EventSourceTrace.Main(String[] args)
               ./eventsourcetrace.sh: line 244: 64063 Aborted                 (core dumped) $_DebuggerFullPath "$CORE_ROOT/corerun" $ExePath $CLRTestExecutionArguments
               Expected: 100
               Actual: 134
               END EXECUTION - FAILED</Title_Description>
    <Label>arch-x64</Label>
    <Assignee>erozenfeld</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17628</IssueLabelID>
    <Title>[x64/Ubuntu] Failure in JitStress=2 JitStressRegs=4 job</Title>
    <Description>https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64/job/jitstress/job/x64_checked_ubuntu_jitstress2_jitstressregs4_tst/438/consoleText

FAILED   - baseservices/threading/waithandle/waitany/waitanyex5a/waitanyex5a.sh
               BEGIN EXECUTION
               /mnt/j/workspace/dotnet_coreclr/master/jitstress/x64_checked_ubuntu_jitstress2_jitstressregs4_tst/bin/tests/Linux.x64.Checked/Tests/Core_Root/corerun waitanyex5a.exe
               Abandoning only one Mutex in array with other WaitHandles signaling other mutexes
               Waiting...
               WaitAny did not throw AbandonedMutexExcpetion
               Test Failed
               Expected: 100
               Actual: 255
               END EXECUTION - FAILED</Description>
    <Title_Description>[x64/Ubuntu] Failure in JitStress=2 JitStressRegs=4 job https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64/job/jitstress/job/x64_checked_ubuntu_jitstress2_jitstressregs4_tst/438/consoleText

FAILED   - baseservices/threading/waithandle/waitany/waitanyex5a/waitanyex5a.sh
               BEGIN EXECUTION
               /mnt/j/workspace/dotnet_coreclr/master/jitstress/x64_checked_ubuntu_jitstress2_jitstressregs4_tst/bin/tests/Linux.x64.Checked/Tests/Core_Root/corerun waitanyex5a.exe
               Abandoning only one Mutex in array with other WaitHandles signaling other mutexes
               Waiting...
               WaitAny did not throw AbandonedMutexExcpetion
               Test Failed
               Expected: 100
               Actual: 255
               END EXECUTION - FAILED</Title_Description>
    <Label>JitStress</Label>
    <Assignee>erozenfeld</Assignee>
    <CreatedAt>17/04/2018 11:44:47 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17627</IssueLabelID>
    <Title>increase timeout for debug jobs</Title>
    <Description>Allow to get results from arm32 debug ubuntu build.

[arm_cross_debug_ubuntu_tst_prtest](https://ci.dot.net/job/dotnet_coreclr/job/master/job/arm_cross_debug_ubuntu_tst_prtest/) fails with timeout it is not a single test that hangs because it can be aborted during different tests.

Our current timeout is 420 minutes and it allows to run ~10000 tests so we need to be able to finish another 1000 test to make this green. 2 hours should be enough.</Description>
    <Title_Description>increase timeout for debug jobs Allow to get results from arm32 debug ubuntu build.

[arm_cross_debug_ubuntu_tst_prtest](https://ci.dot.net/job/dotnet_coreclr/job/master/job/arm_cross_debug_ubuntu_tst_prtest/) fails with timeout it is not a single test that hangs because it can be aborted during different tests.

Our current timeout is 420 minutes and it allows to run ~10000 tests so we need to be able to finish another 1000 test to make this green. 2 hours should be enough.</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>17/04/2018 11:27:48 PM +00:00</CreatedAt>
    <ClosedAt>18/04/2018 5:58:18 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17626</IssueLabelID>
    <Title>Cannot get light-up technique of assembly load to work with .NET Core 2.0</Title>
    <Description>First of all please let me know if this type of issue should be addressed in another repo. I did see some mention of this light-up technique here so that's why I chose this repo.

I recently learned about the light-up technique that Application Insights uses to get their assemblies loaded into any ASP.NET app. [Here](https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/platform-specific-configuration?view=aspnetcore-2.1) is a link to it.

I've implemented an IHostingStartup class in an assembly.  I'm using a target of `netcoreapp2.0`. One thing I'm not sure if it could be an issue is that I had installed the .NET Core 2.1 preview (first and the second one) and the SDK that comes with it. So my .NET Core SDK is 2.1.

I followed exactly the same process of making sure my assembly symbols and deps.json are put in the right place in the my user profile tree under the `.dotnet` subdirectory paths. In fact I used the nice Powershell script that I think Luke Latham wrote and referred to [here](https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/platform-specific-configuration?view=aspnetcore-2.1). 

I verified that the files are copied correctly and that my deps.json file has the necessary entries.

When I run a hosting app like the `HostingStartupSample` that Luke used (all of the source is [here](https://github.com/aspnet/Docs/tree/master/aspnetcore/host-and-deploy/platform-specific-configuration/sample) I get this exception as it starts up:

```
System.InvalidOperationException: Startup assembly ShiftLeft.NetCore.Agent failed to execute. See the inner exception for more details. ---&gt; System.IO.FileNotFoundException: Could not load file or assembly 'ShiftLeft.NetCore.Agent Culture=neutral PublicKeyToken=null'. The system cannot find the file specified.
   at System.Reflection.RuntimeAssembly._nLoad(AssemblyName fileName String codeBase Evidence assemblySecurity RuntimeAssembly locationHint StackCrawlMark&amp; stackMark IntPtr pPrivHostBinder Boolean throwOnFileNotFound Boolean forIntrospection Boolean suppressSecurityChecks IntPtr ptrLoadContextBinder)
   at System.Reflection.RuntimeAssembly.InternalLoadAssemblyName(AssemblyName assemblyRef Evidence assemblySecurity RuntimeAssembly reqAssembly StackCrawlMark&amp; stackMark IntPtr pPrivHostBinder Boolean throwOnFileNotFound Boolean forIntrospection IntPtr ptrLoadContextBinder)
   at System.Reflection.Assembly.Load(AssemblyName assemblyRef)
   at Microsoft.AspNetCore.Hosting.WebHostBuilder.BuildCommonServices(AggregateException&amp; hostingStartupErrors)
   --- End of inner exception stack trace ---
```

I have no idea why it cannot find it. I set the COREHOST_TRACE=1 environment  variable but didn't see anything more than what I already knew. 

Here is the code:

```
using Microsoft.AspNetCore.Hosting;
using ShiftLeft.Agent;

// Use a Hosting Startup Attribute to identify the IHostingStartup implementation.
[assembly: HostingStartup(typeof(ShiftLeft.NetCore.Agent.AgentHostingStartup))]

namespace ShiftLeft.NetCore.Agent
{
    public class AgentHostingStartup : IHostingStartup
    {
        public static void Main(string[] args)
        { }

        public void Configure(IWebHostBuilder builder)
        {
            Logger.Instance.Log("AgentHostingStartup.Configure...");
        }
    }
}
```

The Main() entrypoint is to make the compiler happy -- apparently I cannot use that interface without having a Main entrypoint? All I do for my configuration is simply use a logger class to tell me if it gets loaded.

I could use some additional tips on troubleshooting this or if you think there's a bug. Thanks Bob
</Description>
    <Title_Description>Cannot get light-up technique of assembly load to work with .NET Core 2.0 First of all please let me know if this type of issue should be addressed in another repo. I did see some mention of this light-up technique here so that's why I chose this repo.

I recently learned about the light-up technique that Application Insights uses to get their assemblies loaded into any ASP.NET app. [Here](https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/platform-specific-configuration?view=aspnetcore-2.1) is a link to it.

I've implemented an IHostingStartup class in an assembly.  I'm using a target of `netcoreapp2.0`. One thing I'm not sure if it could be an issue is that I had installed the .NET Core 2.1 preview (first and the second one) and the SDK that comes with it. So my .NET Core SDK is 2.1.

I followed exactly the same process of making sure my assembly symbols and deps.json are put in the right place in the my user profile tree under the `.dotnet` subdirectory paths. In fact I used the nice Powershell script that I think Luke Latham wrote and referred to [here](https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/platform-specific-configuration?view=aspnetcore-2.1). 

I verified that the files are copied correctly and that my deps.json file has the necessary entries.

When I run a hosting app like the `HostingStartupSample` that Luke used (all of the source is [here](https://github.com/aspnet/Docs/tree/master/aspnetcore/host-and-deploy/platform-specific-configuration/sample) I get this exception as it starts up:

```
System.InvalidOperationException: Startup assembly ShiftLeft.NetCore.Agent failed to execute. See the inner exception for more details. ---&gt; System.IO.FileNotFoundException: Could not load file or assembly 'ShiftLeft.NetCore.Agent Culture=neutral PublicKeyToken=null'. The system cannot find the file specified.
   at System.Reflection.RuntimeAssembly._nLoad(AssemblyName fileName String codeBase Evidence assemblySecurity RuntimeAssembly locationHint StackCrawlMark&amp; stackMark IntPtr pPrivHostBinder Boolean throwOnFileNotFound Boolean forIntrospection Boolean suppressSecurityChecks IntPtr ptrLoadContextBinder)
   at System.Reflection.RuntimeAssembly.InternalLoadAssemblyName(AssemblyName assemblyRef Evidence assemblySecurity RuntimeAssembly reqAssembly StackCrawlMark&amp; stackMark IntPtr pPrivHostBinder Boolean throwOnFileNotFound Boolean forIntrospection IntPtr ptrLoadContextBinder)
   at System.Reflection.Assembly.Load(AssemblyName assemblyRef)
   at Microsoft.AspNetCore.Hosting.WebHostBuilder.BuildCommonServices(AggregateException&amp; hostingStartupErrors)
   --- End of inner exception stack trace ---
```

I have no idea why it cannot find it. I set the COREHOST_TRACE=1 environment  variable but didn't see anything more than what I already knew. 

Here is the code:

```
using Microsoft.AspNetCore.Hosting;
using ShiftLeft.Agent;

// Use a Hosting Startup Attribute to identify the IHostingStartup implementation.
[assembly: HostingStartup(typeof(ShiftLeft.NetCore.Agent.AgentHostingStartup))]

namespace ShiftLeft.NetCore.Agent
{
    public class AgentHostingStartup : IHostingStartup
    {
        public static void Main(string[] args)
        { }

        public void Configure(IWebHostBuilder builder)
        {
            Logger.Instance.Log("AgentHostingStartup.Configure...");
        }
    }
}
```

The Main() entrypoint is to make the compiler happy -- apparently I cannot use that interface without having a Main entrypoint? All I do for my configuration is simply use a logger class to tell me if it gets loaded.

I could use some additional tips on troubleshooting this or if you think there's a bug. Thanks Bob
</Title_Description>
    <Label>question</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>17/04/2018 11:26:59 PM +00:00</CreatedAt>
    <ClosedAt>18/04/2018 3:32:43 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17625</IssueLabelID>
    <Title>[TEST] Test GC/HeapExpansion/bestfit test on ARM64</Title>
    <Description>This is just a test of whether the bestfit tests works on arm64 or not</Description>
    <Title_Description>[TEST] Test GC/HeapExpansion/bestfit test on ARM64 This is just a test of whether the bestfit tests works on arm64 or not</Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>janvorli</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17622</IssueLabelID>
    <Title>WIP Test tier 1 in CI</Title>
    <Description>
    </Description>
    <Title_Description>WIP Test tier 1 in CI </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17619</IssueLabelID>
    <Title>1.1.8 long-name DAC/SOS has incorrect version (001 expected 01)</Title>
    <Description>I ran some basic symbol validation on the recent 1.1.8 release and found that the long-name DAC/SOS has incorrect versions:

 * ..._4.6.26328.**001**.dll
 * ..._4.6.26328.**01**.dll (expected)

This was fixed in `release/2.0.0`+ by https://github.com/dotnet/coreclr/pull/15583 merging to `master`.

Should the fix be ported to `release/1.1.0`?
Should the 1.1.8 build in particular be manually fixed by renaming the dll and republishing symbols?

/cc @lt72 @mikem8361 @leculver @weshaggard </Description>
    <Title_Description>1.1.8 long-name DAC/SOS has incorrect version (001, expected 01) I ran some basic symbol validation on the recent 1.1.8 release and found that the long-name DAC/SOS has incorrect versions:

 * ..._4.6.26328.**001**.dll
 * ..._4.6.26328.**01**.dll (expected)

This was fixed in `release/2.0.0`+ by https://github.com/dotnet/coreclr/pull/15583 merging to `master`.

Should the fix be ported to `release/1.1.0`?
Should the 1.1.8 build in particular be manually fixed by renaming the dll and republishing symbols?

/cc @lt72 @mikem8361 @leculver @weshaggard </Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>mikem8361</Assignee>
    <CreatedAt>17/04/2018 9:14:30 PM +00:00</CreatedAt>
    <ClosedAt>22/03/2019 11:39:58 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17618</IssueLabelID>
    <Title>disable DevDiv_255294 in stress modes.</Title>
    <Description>Closes #17605.

cc @dotnet/jit-contrib </Description>
    <Title_Description>disable DevDiv_255294 in stress modes. Closes #17605.

cc @dotnet/jit-contrib </Title_Description>
    <Label>disabled-test</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>17/04/2018 9:14:25 PM +00:00</CreatedAt>
    <ClosedAt>18/04/2018 7:24:00 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17614</IssueLabelID>
    <Title>fix build.cmd generateLayout</Title>
    <Description>output before:
```
build.cmd x64 debug skiptests generatelayout
C:\git\coreclr&gt;call C:\git\coreclr\test\runtest.cmd x64 Debug GenerateLayoutOnly
The system cannot find the path specified.
```

PTAL @tannergooding @jashook.
cc @dotnet/jit-contrib 

@tannergooding Is it a typo? Did it work in #15673?</Description>
    <Title_Description>fix build.cmd generateLayout output before:
```
build.cmd x64 debug skiptests generatelayout
C:\git\coreclr&gt;call C:\git\coreclr\test\runtest.cmd x64 Debug GenerateLayoutOnly
The system cannot find the path specified.
```

PTAL @tannergooding @jashook.
cc @dotnet/jit-contrib 

@tannergooding Is it a typo? Did it work in #15673?</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>tannergooding</Assignee>
    <CreatedAt>17/04/2018 6:23:12 PM +00:00</CreatedAt>
    <ClosedAt>18/04/2018 6:25:58 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17613</IssueLabelID>
    <Title>Port #17594 to the 2.1 branch (Fix GC tests)</Title>
    <Description>Port #17594 to the release branch. 
Fixes #17588.</Description>
    <Title_Description>Port #17594 to the 2.1 branch (Fix GC tests) Port #17594 to the release branch. 
Fixes #17588.</Title_Description>
    <Label>test bug</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>17/04/2018 5:49:37 PM +00:00</CreatedAt>
    <ClosedAt>18/04/2018 6:25:44 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17612</IssueLabelID>
    <Title>About 10% performance regression for Perf_BigInteger tests</Title>
    <Description>Ctor_ByteArray
![capture04](https://user-images.githubusercontent.com/5897654/38886242-355e249c-422a-11e8-87a5-c2af03d8c409.PNG)

Ctor_ByteSpan
![capture05](https://user-images.githubusercontent.com/5897654/38886356-92c6bb58-422a-11e8-9819-39a0eb4424d5.PNG)

ToByteArray
![capture06](https://user-images.githubusercontent.com/5897654/38886484-efe301e8-422a-11e8-8db6-b2a38acb5bd1.PNG)

TryWriteBytes
![capture07](https://user-images.githubusercontent.com/5897654/38886552-23aa80be-422b-11e8-90fe-4a9b2dd512d7.PNG)

[Updated]:
For all of the above the corefx diff below is causing the regression increase: 
dotnet/corefx@7ec7367

Check [benchview ](https://benchview/trendline?build_selector=latest&amp;count=2000&amp;aggregate=arithmeticMean&amp;filterTail=one&amp;filterVal=100&amp;interval=INTERVAL_MIN_MAX&amp;rtids=[957]&amp;archids=[23]&amp;mpids=[1292]&amp;cfgids=[2706]&amp;testids=[642966429564297643056430464306642996429864300643086430764309]&amp;jobgroup=CoreFX&amp;jobtype=rolling&amp;branchId=42&amp;) for more detail.

cc: @kouvel @danmosemsft </Description>
    <Title_Description>About 10% performance regression for Perf_BigInteger tests Ctor_ByteArray
![capture04](https://user-images.githubusercontent.com/5897654/38886242-355e249c-422a-11e8-87a5-c2af03d8c409.PNG)

Ctor_ByteSpan
![capture05](https://user-images.githubusercontent.com/5897654/38886356-92c6bb58-422a-11e8-9819-39a0eb4424d5.PNG)

ToByteArray
![capture06](https://user-images.githubusercontent.com/5897654/38886484-efe301e8-422a-11e8-8db6-b2a38acb5bd1.PNG)

TryWriteBytes
![capture07](https://user-images.githubusercontent.com/5897654/38886552-23aa80be-422b-11e8-90fe-4a9b2dd512d7.PNG)

[Updated]:
For all of the above the corefx diff below is causing the regression increase: 
dotnet/corefx@7ec7367

Check [benchview ](https://benchview/trendline?build_selector=latest&amp;count=2000&amp;aggregate=arithmeticMean&amp;filterTail=one&amp;filterVal=100&amp;interval=INTERVAL_MIN_MAX&amp;rtids=[957]&amp;archids=[23]&amp;mpids=[1292]&amp;cfgids=[2706]&amp;testids=[642966429564297643056430464306642996429864300643086430764309]&amp;jobgroup=CoreFX&amp;jobtype=rolling&amp;branchId=42&amp;) for more detail.

cc: @kouvel @danmosemsft </Title_Description>
    <Label>area-System.Runtime</Label>
    <Assignee>kouvel</Assignee>
    <CreatedAt>17/04/2018 5:41:09 PM +00:00</CreatedAt>
    <ClosedAt>18/04/2018 1:05:14 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17610</IssueLabelID>
    <Title>[arm32/Ubuntu] Assert failure: Consistency check failed: hit privileged instruction!</Title>
    <Description>In GCStress=0xc

https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_ubuntu_gcstress0xc_tst/2/consoleText

```
FAILED   - baseservices/threading/generics/WaitCallback/thread23/thread23.sh
               BEGIN EXECUTION
               /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_gcstress0xc_tst/bin/tests/Linux.arm.Checked/Tests/Core_Root/corerun thread23.exe
               
               Assert failure(PID 13815 [0x000035f7] Thread: 13888 [0x3640]): Consistency check failed: hit privileged instruction!FAILED: !ExecutionManager::IsManagedCode(GetIP(pContext))
                   File: /mnt/j/workspace/dotnet_coreclr/master/arm_cross_checked_ubuntu/src/vm/excep.cpp Line: 6856
                   Image: /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_gcstress0xc_tst/bin/tests/Linux.arm.Checked/Tests/Core_Root/corerun
               
               ./thread23.sh: line 244: 13815 Aborted                 $_DebuggerFullPath "$CORE_ROOT/corerun" $ExePath $CLRTestExecutionArguments
               Expected: 100
               Actual: 134
               END EXECUTION - FAILED
```

Related to https://github.com/dotnet/coreclr/issues/17585 and/or https://github.com/dotnet/coreclr/issues/17598?

</Description>
    <Title_Description>[arm32/Ubuntu] Assert failure: Consistency check failed: hit privileged instruction! In GCStress=0xc

https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_ubuntu_gcstress0xc_tst/2/consoleText

```
FAILED   - baseservices/threading/generics/WaitCallback/thread23/thread23.sh
               BEGIN EXECUTION
               /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_gcstress0xc_tst/bin/tests/Linux.arm.Checked/Tests/Core_Root/corerun thread23.exe
               
               Assert failure(PID 13815 [0x000035f7] Thread: 13888 [0x3640]): Consistency check failed: hit privileged instruction!FAILED: !ExecutionManager::IsManagedCode(GetIP(pContext))
                   File: /mnt/j/workspace/dotnet_coreclr/master/arm_cross_checked_ubuntu/src/vm/excep.cpp Line: 6856
                   Image: /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_gcstress0xc_tst/bin/tests/Linux.arm.Checked/Tests/Core_Root/corerun
               
               ./thread23.sh: line 244: 13815 Aborted                 $_DebuggerFullPath "$CORE_ROOT/corerun" $ExePath $CLRTestExecutionArguments
               Expected: 100
               Actual: 134
               END EXECUTION - FAILED
```

Related to https://github.com/dotnet/coreclr/issues/17585 and/or https://github.com/dotnet/coreclr/issues/17598?

</Title_Description>
    <Label>GCStress</Label>
    <Assignee>AndyAyersMS</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17609</IssueLabelID>
    <Title>[x86/x64|Windows|Full Framework] Native vararg generates bad code.</Title>
    <Description>C#
```
[DllImport("exampledll" CallingConvention = CallingConvention.Cdecl)]
extern static long test_passing_int_and_longs(int int_count int long_count __arglist);

// If the VaList is read in C the values returned will be junk.
test_passing_int_and_longs(2 2 __arglist(1 2 3L 4L));
```

Currently have not investigated more than the value read from the va_list in C is junk. Will post more information if/when I investigate further.

Note this also fails when passing other different types together eg:

```
[DllImport("exampledll" CallingConvention = CallingConvention.Cdecl)]
extern static long test_passing_float_and_doubles(int float_count int double_count __arglist);

// If the VaList is read in C the values returned will be junk.
test_passing_float_and_doubles(2 2 __arglist(1.0F 2.0F 3.0 4.0));
```</Description>
    <Title_Description>[x86/x64|Windows|Full Framework] Native vararg generates bad code. C#
```
[DllImport("exampledll" CallingConvention = CallingConvention.Cdecl)]
extern static long test_passing_int_and_longs(int int_count int long_count __arglist);

// If the VaList is read in C the values returned will be junk.
test_passing_int_and_longs(2 2 __arglist(1 2 3L 4L));
```

Currently have not investigated more than the value read from the va_list in C is junk. Will post more information if/when I investigate further.

Note this also fails when passing other different types together eg:

```
[DllImport("exampledll" CallingConvention = CallingConvention.Cdecl)]
extern static long test_passing_float_and_doubles(int float_count int double_count __arglist);

// If the VaList is read in C the values returned will be junk.
test_passing_float_and_doubles(2 2 __arglist(1.0F 2.0F 3.0 4.0));
```</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>jashook</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17608</IssueLabelID>
    <Title>[1.1] Fix Debian packaging bug.</Title>
    <Description>- Fixes packaging for Debian8 and Debian9
- Further narrows down the scope of tool-runtime replacement with restored dotnetcli to only Debian9 and only the x509certififactes assembly.</Description>
    <Title_Description>[1.1] Fix Debian packaging bug. - Fixes packaging for Debian8 and Debian9
- Further narrows down the scope of tool-runtime replacement with restored dotnetcli to only Debian9 and only the x509certififactes assembly.</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>ianhays</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17605</IssueLabelID>
    <Title>[arm32/Ubuntu] Failure in R2R JitStress=1 job</Title>
    <Description>https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_r2r_jitstress1_flow/

It appears to fail with a hang in this test:
```
FAILED   - JIT/Regression/JitBlue/DevDiv_255294/DevDiv_255294/DevDiv_255294.sh
               BEGIN EXECUTION
               in takeLock
               /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_r2r_jitstress1_tst/bin/tests/Linux.arm.Checked/Tests/Core_Root/crossgen /Platform_Assemblies_Paths /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_r2r_jitstress1_tst/bin/tests/Linux.arm.Checked/Tests/Core_Root:/ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_r2r_jitstress1_tst/bin/tests/Linux.arm.Checked/JIT/Regression/JitBlue/DevDiv_255294/DevDiv_255294/IL:/ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_r2r_jitstress1_tst/bin/tests/Linux.arm.Checked/JIT/Regression/JitBlue/DevDiv_255294/DevDiv_255294 /in DevDiv_255294.org /out DevDiv_255294.exe
               ./DevDiv_255294.sh: line 156: 17678 Terminated              $_DebuggerFullPath "$CORE_ROOT/crossgen" /Platform_Assemblies_Paths $CORE_ROOT:$PWD/IL:$PWD /in DevDiv_255294.org /out DevDiv_255294.exe
               Crossgen failed with exitcode: 143
               in ReleaseLock
```

This is consistent in multiple runs e.g.:

https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_ubuntu_r2r_jitstress1_tst/3/consoleText

</Description>
    <Title_Description>[arm32/Ubuntu] Failure in R2R JitStress=1 job https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_r2r_jitstress1_flow/

It appears to fail with a hang in this test:
```
FAILED   - JIT/Regression/JitBlue/DevDiv_255294/DevDiv_255294/DevDiv_255294.sh
               BEGIN EXECUTION
               in takeLock
               /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_r2r_jitstress1_tst/bin/tests/Linux.arm.Checked/Tests/Core_Root/crossgen /Platform_Assemblies_Paths /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_r2r_jitstress1_tst/bin/tests/Linux.arm.Checked/Tests/Core_Root:/ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_r2r_jitstress1_tst/bin/tests/Linux.arm.Checked/JIT/Regression/JitBlue/DevDiv_255294/DevDiv_255294/IL:/ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_r2r_jitstress1_tst/bin/tests/Linux.arm.Checked/JIT/Regression/JitBlue/DevDiv_255294/DevDiv_255294 /in DevDiv_255294.org /out DevDiv_255294.exe
               ./DevDiv_255294.sh: line 156: 17678 Terminated              $_DebuggerFullPath "$CORE_ROOT/crossgen" /Platform_Assemblies_Paths $CORE_ROOT:$PWD/IL:$PWD /in DevDiv_255294.org /out DevDiv_255294.exe
               Crossgen failed with exitcode: 143
               in ReleaseLock
```

This is consistent in multiple runs e.g.:

https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_ubuntu_r2r_jitstress1_tst/3/consoleText

</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>sandreenko</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17604</IssueLabelID>
    <Title>Incorrect prefix appended when the native library lives in "relative" directory in Unix</Title>
    <Description>_From @luqunl on April 17 2018 6:3_

The issue is found by Jkotas:

https://github.com/dotnet/coreclr/blob/9d45401c6056a5b9c92d036e25c34ad34c03385e/src/vm/dllimport.cpp#L6054

libNameIsRelativePath is going to be true for a paths like:
XXX\YYY\library
or
\XXX\YYY\library.

On Unix we will end up trying paths like:
**lib**XXX\YYY\library.so
or
**lib**\XXX\YYY\library.so.

_Copied from original issue: dotnet/corert#5719_</Description>
    <Title_Description>Incorrect prefix appended when the native library lives in "relative" directory in Unix _From @luqunl on April 17 2018 6:3_

The issue is found by Jkotas:

https://github.com/dotnet/coreclr/blob/9d45401c6056a5b9c92d036e25c34ad34c03385e/src/vm/dllimport.cpp#L6054

libNameIsRelativePath is going to be true for a paths like:
XXX\YYY\library
or
\XXX\YYY\library.

On Unix we will end up trying paths like:
**lib**XXX\YYY\library.so
or
**lib**\XXX\YYY\library.so.

_Copied from original issue: dotnet/corert#5719_</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>AaronRobinsonMSFT</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17603</IssueLabelID>
    <Title>About 20% performance regression for OrderBy() and OrderByThenBy() on windows</Title>
    <Description>Here are the graphs showing timings from Aug to now for these tests.

&lt;img width="1060" alt="screen shot 2018-04-16 at 11 07 19 pm" src="https://user-images.githubusercontent.com/5897654/38851560-08d96c2e-41cb-11e8-8154-4730865ce439.png"&gt;

&lt;img width="1063" alt="screen shot 2018-04-16 at 11 17 43 pm" src="https://user-images.githubusercontent.com/5897654/38851868-6f25fda2-41cc-11e8-9884-ea79f7e50ed1.png"&gt;


There was a noticeable jump in October for OrderBy() and OrderByThenBy() tests that does not seem to have been corrected since.

For Windows:
The corefx commit related to this regression is https://github.com/dotnet/corefx/commit/2b25c6c739ada3e8da8b8783e008f48f9078fb33 which in turn points to code changes are in CoreCLR. 
Here's the coreclr commit bd7493440cefe9cdfb3648de99178e208f8df5df  and here's a [github diff](https://github.com/dotnet/coreclr/commit/bd7493440cefe9cdfb3648de99178e208f8df5df) 

Refer to [benchview](https://benchview/trendline?build_selector=latest&amp;count=2000&amp;aggregate=arithmeticMean&amp;filterTail=one&amp;filterVal=100&amp;interval=INTERVAL_MIN_MAX&amp;rtids=[957]&amp;archids=[23]&amp;mpids=[1292]&amp;cfgids=[2706]&amp;testids=[6030360301603026030060319603176031860316]&amp;jobgroup=CoreFX&amp;jobtype=rolling&amp;branchId=42&amp;) for more details.

cc: @kouvel @danmosemsft

category:cq
theme:benchmarks
skill-level:expert
cost:small</Description>
    <Title_Description>About 20% performance regression for OrderBy() and OrderByThenBy() on windows Here are the graphs showing timings from Aug to now for these tests.

&lt;img width="1060" alt="screen shot 2018-04-16 at 11 07 19 pm" src="https://user-images.githubusercontent.com/5897654/38851560-08d96c2e-41cb-11e8-8154-4730865ce439.png"&gt;

&lt;img width="1063" alt="screen shot 2018-04-16 at 11 17 43 pm" src="https://user-images.githubusercontent.com/5897654/38851868-6f25fda2-41cc-11e8-9884-ea79f7e50ed1.png"&gt;


There was a noticeable jump in October for OrderBy() and OrderByThenBy() tests that does not seem to have been corrected since.

For Windows:
The corefx commit related to this regression is https://github.com/dotnet/corefx/commit/2b25c6c739ada3e8da8b8783e008f48f9078fb33 which in turn points to code changes are in CoreCLR. 
Here's the coreclr commit bd7493440cefe9cdfb3648de99178e208f8df5df  and here's a [github diff](https://github.com/dotnet/coreclr/commit/bd7493440cefe9cdfb3648de99178e208f8df5df) 

Refer to [benchview](https://benchview/trendline?build_selector=latest&amp;count=2000&amp;aggregate=arithmeticMean&amp;filterTail=one&amp;filterVal=100&amp;interval=INTERVAL_MIN_MAX&amp;rtids=[957]&amp;archids=[23]&amp;mpids=[1292]&amp;cfgids=[2706]&amp;testids=[6030360301603026030060319603176031860316]&amp;jobgroup=CoreFX&amp;jobtype=rolling&amp;branchId=42&amp;) for more details.

cc: @kouvel @danmosemsft

category:cq
theme:benchmarks
skill-level:expert
cost:small</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17602</IssueLabelID>
    <Title>Clean up FlushInstructionCache for precodes and interlocked target change operations</Title>
    <Description>Updated based on discussion below

~~Add missing FlushInstructionCache to ResetTargetInterlocked~~

~~Not sure if it's necessary considering the interlocked operation but it's there in Precode::SetTargetInterlocked so I assume it's necessary. Probably no issue anyway it's unlikely that call counting won't be done as a result of the instruction cache. No change to perf on JitBench with tiering enabled. On arm32 and arm64 executable code is not changed so no need for the flush there.~~</Description>
    <Title_Description>Clean up FlushInstructionCache for precodes and interlocked target change operations Updated based on discussion below

~~Add missing FlushInstructionCache to ResetTargetInterlocked~~

~~Not sure if it's necessary considering the interlocked operation but it's there in Precode::SetTargetInterlocked so I assume it's necessary. Probably no issue anyway it's unlikely that call counting won't be done as a result of the instruction cache. No change to perf on JitBench with tiering enabled. On arm32 and arm64 executable code is not changed so no need for the flush there.~~</Title_Description>
    <Label>area-VM</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17600</IssueLabelID>
    <Title>Bug in CodeGen::getFirstArgWithStackSlot()</Title>
    <Description>There is a typo in `CodeGen::getFirstArgWithStackSlot()` where it uses

```
#if defined(FEATURE_UNIX_AMR64_STRUCT_PASSING)
```

instead of apparently `FEATURE_UNIX_AMD64_STRUCT_PASSING` (presumably it is a `D=&gt;R` typo not a `ARM64=&gt;AMR64` typo since nobody sets or uses the version with `ARM64`).

Thus the Unix amd64 code is not doing what it was written to do since the mistyped `#ifdef` is never defined:
```
#if defined(FEATURE_UNIX_AMD64_STRUCT_PASSING) || defined(_TARGET_ARMARCH_)
    unsigned baseVarNum = 0;
#if defined(FEATURE_UNIX_AMR64_STRUCT_PASSING)
    baseVarNum = compiler-&gt;lvaFirstStackIncomingArgNum;

    if (compiler-&gt;lvaFirstStackIncomingArgNum != BAD_VAR_NUM)
    {
        baseVarNum = compiler-&gt;lvaFirstStackIncomingArgNum;
    }
    else
#endif // FEATURE_UNIX_ARM64_STRUCT_PASSING
    {
        // Iterate over all the local variables in the Lcl var table.
        // They contain all the implicit arguments - thisPtr retBuf
        // generic context PInvoke cookie var arg cookieno-standard args etc.
        LclVarDsc* varDsc = nullptr;
        for (unsigned i = 0; i &lt; compiler-&gt;info.compArgsCount; i++)
        {
            varDsc = &amp;(compiler-&gt;lvaTable[i]);

            // We are iterating over the arguments only.
            assert(varDsc-&gt;lvIsParam);

            if (varDsc-&gt;lvArgReg == REG_STK)
            {
                baseVarNum = i;
#if defined(FEATURE_UNIX_AMR64_STRUCT_PASSING)
                compiler-&gt;lvaFirstStackIncomingArgNum = baseVarNum;
#endif // FEATURE_UNIX_ARM64_STRUCT_PASSING
                break;
            }
        }
        assert(varDsc != nullptr);
    }

    return baseVarNum;
```
</Description>
    <Title_Description>Bug in CodeGen::getFirstArgWithStackSlot() There is a typo in `CodeGen::getFirstArgWithStackSlot()` where it uses

```
#if defined(FEATURE_UNIX_AMR64_STRUCT_PASSING)
```

instead of apparently `FEATURE_UNIX_AMD64_STRUCT_PASSING` (presumably it is a `D=&gt;R` typo not a `ARM64=&gt;AMR64` typo since nobody sets or uses the version with `ARM64`).

Thus the Unix amd64 code is not doing what it was written to do since the mistyped `#ifdef` is never defined:
```
#if defined(FEATURE_UNIX_AMD64_STRUCT_PASSING) || defined(_TARGET_ARMARCH_)
    unsigned baseVarNum = 0;
#if defined(FEATURE_UNIX_AMR64_STRUCT_PASSING)
    baseVarNum = compiler-&gt;lvaFirstStackIncomingArgNum;

    if (compiler-&gt;lvaFirstStackIncomingArgNum != BAD_VAR_NUM)
    {
        baseVarNum = compiler-&gt;lvaFirstStackIncomingArgNum;
    }
    else
#endif // FEATURE_UNIX_ARM64_STRUCT_PASSING
    {
        // Iterate over all the local variables in the Lcl var table.
        // They contain all the implicit arguments - thisPtr retBuf
        // generic context PInvoke cookie var arg cookieno-standard args etc.
        LclVarDsc* varDsc = nullptr;
        for (unsigned i = 0; i &lt; compiler-&gt;info.compArgsCount; i++)
        {
            varDsc = &amp;(compiler-&gt;lvaTable[i]);

            // We are iterating over the arguments only.
            assert(varDsc-&gt;lvIsParam);

            if (varDsc-&gt;lvArgReg == REG_STK)
            {
                baseVarNum = i;
#if defined(FEATURE_UNIX_AMR64_STRUCT_PASSING)
                compiler-&gt;lvaFirstStackIncomingArgNum = baseVarNum;
#endif // FEATURE_UNIX_ARM64_STRUCT_PASSING
                break;
            }
        }
        assert(varDsc != nullptr);
    }

    return baseVarNum;
```
</Title_Description>
    <Label>arch-x64</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17598</IssueLabelID>
    <Title>[arm32/Ubuntu] GCStress failures: "Consistency check failed: FAILED: !pThread-&gt;HasPendingGCStressInstructionUpdate()"</Title>
    <Description>When I run GCStress=0xc on Ubuntu arm32 the most common failure is:

```
               Assert failure(PID 23543 [0x00005bf7] Thread: 23543 [0x5bf7]): Consistency check failed: FAILED: !pThread-&gt;HasPendingGCStressInstructionUpdate()
                   File: /mnt/coreclr/src/vm/gccover.cpp Line: 1772
                   Image: /ssd/brucefo/checked/coreclr/bin/tests/Linux.arm.Checked/Tests/Core_Root/corerun

               ./30032.sh: line 243: 23543 Aborted                 $_DebuggerFullPath "$CORE_ROOT/corerun" $ExePath $CLRTestExecutionArguments
               Expected: 100
               Actual: 134
               END EXECUTION - FAILED
```

The most common failures are the tests in these directories:
```
baseservices/threading/generics/TimerCallback
baseservices/threading/generics/WaitCallback
```

as well as
```
baseservices/threading/regressions/beta2/437044/437044.sh
```
which in at least one of my runs required 5 retries to pass.

This is https://github.com/dotnet/coreclr/issues/5310.
</Description>
    <Title_Description>[arm32/Ubuntu] GCStress failures: "Consistency check failed: FAILED: !pThread-&gt;HasPendingGCStressInstructionUpdate()" When I run GCStress=0xc on Ubuntu arm32 the most common failure is:

```
               Assert failure(PID 23543 [0x00005bf7] Thread: 23543 [0x5bf7]): Consistency check failed: FAILED: !pThread-&gt;HasPendingGCStressInstructionUpdate()
                   File: /mnt/coreclr/src/vm/gccover.cpp Line: 1772
                   Image: /ssd/brucefo/checked/coreclr/bin/tests/Linux.arm.Checked/Tests/Core_Root/corerun

               ./30032.sh: line 243: 23543 Aborted                 $_DebuggerFullPath "$CORE_ROOT/corerun" $ExePath $CLRTestExecutionArguments
               Expected: 100
               Actual: 134
               END EXECUTION - FAILED
```

The most common failures are the tests in these directories:
```
baseservices/threading/generics/TimerCallback
baseservices/threading/generics/WaitCallback
```

as well as
```
baseservices/threading/regressions/beta2/437044/437044.sh
```
which in at least one of my runs required 5 retries to pass.

This is https://github.com/dotnet/coreclr/issues/5310.
</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>16/04/2018 10:11:14 PM +00:00</CreatedAt>
    <ClosedAt>30/05/2018 10:21:28 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17597</IssueLabelID>
    <Title>[Arm64] Add memory barrier after interlocked operations</Title>
    <Description>Port of https://github.com/dotnet/coreclr/pull/17595 to release/2.1
Fixes https://github.com/dotnet/coreclr/issues/17591

CC @sdmaclea </Description>
    <Title_Description>[Arm64] Add memory barrier after interlocked operations Port of https://github.com/dotnet/coreclr/pull/17595 to release/2.1
Fixes https://github.com/dotnet/coreclr/issues/17591

CC @sdmaclea </Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17596</IssueLabelID>
    <Title>[1.1] Add missing fed28 and deb9 requirements</Title>
    <Description>- Adds some tags necessary to produce managed components of the build for fed28 and deb9
- Makes the tool-runtime CLI override only happen on platforms where it's required.</Description>
    <Title_Description>[1.1] Add missing fed28 and deb9 requirements - Adds some tags necessary to produce managed components of the build for fed28 and deb9
- Makes the tool-runtime CLI override only happen on platforms where it's required.</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>ianhays</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17595</IssueLabelID>
    <Title>[Arm64] Add memory barrier after interlocked operations</Title>
    <Description>Fixes https://github.com/dotnet/coreclr/issues/17591</Description>
    <Title_Description>[Arm64] Add memory barrier after interlocked operations Fixes https://github.com/dotnet/coreclr/issues/17591</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17594</IssueLabelID>
    <Title>Fix GC tests.</Title>
    <Description>Jit can extend lifetime of temp objects after call to GC.Collect() so we should not have any temp in the same scope with final `GC.Collect();`.

incorrect example 1:
```
var a = new Object(); // Jit can create a temp that will be alive after GC.Collect().
a = null;
GC.Collect();
GC.WaitForPendingFinalizers();
GC.Collect();
```

incorrect example 2:
```
SetLink();
GC.Collect();
GC.WaitForPendingFinalizers();
GC.Collect();

void SetLink() // this method could be inlined we will get the first example.
{
       var a = new Object();
       a = null;
}
```

Incorrect example 3:
```
var a = SetLink(); // Jit can create a temp here with a long lifetime.
a = null;
GC.Collect();
GC.WaitForPendingFinalizers();
GC.Collect();

[MethodImpl(MethodImplOptions.NoInlining)]
Object SetLink()
{
       return new Object();
}
```

correct example 1:
```
SetLink();
GC.Collect();
GC.WaitForPendingFinalizers();
GC.Collect();

[MethodImpl(MethodImplOptions.NoInlining)]
void SetLink() // All temps are in this method and it is protected with NoInlining attribute.
{
       var a = new Object();
       a = null;
}
```





Fixes #17588.

The same problem as #15156.</Description>
    <Title_Description>Fix GC tests. Jit can extend lifetime of temp objects after call to GC.Collect() so we should not have any temp in the same scope with final `GC.Collect();`.

incorrect example 1:
```
var a = new Object(); // Jit can create a temp that will be alive after GC.Collect().
a = null;
GC.Collect();
GC.WaitForPendingFinalizers();
GC.Collect();
```

incorrect example 2:
```
SetLink();
GC.Collect();
GC.WaitForPendingFinalizers();
GC.Collect();

void SetLink() // this method could be inlined we will get the first example.
{
       var a = new Object();
       a = null;
}
```

Incorrect example 3:
```
var a = SetLink(); // Jit can create a temp here with a long lifetime.
a = null;
GC.Collect();
GC.WaitForPendingFinalizers();
GC.Collect();

[MethodImpl(MethodImplOptions.NoInlining)]
Object SetLink()
{
       return new Object();
}
```

correct example 1:
```
SetLink();
GC.Collect();
GC.WaitForPendingFinalizers();
GC.Collect();

[MethodImpl(MethodImplOptions.NoInlining)]
void SetLink() // All temps are in this method and it is protected with NoInlining attribute.
{
       var a = new Object();
       a = null;
}
```





Fixes #17588.

The same problem as #15156.</Title_Description>
    <Label>test bug</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>16/04/2018 7:26:44 PM +00:00</CreatedAt>
    <ClosedAt>17/04/2018 4:44:00 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17593</IssueLabelID>
    <Title>Mirror changes from dotnet/corefx</Title>
    <Description>This PR contains mirrored changes from dotnet/corefx


**Please REBASE this PR when merging**</Description>
    <Title_Description>Mirror changes from dotnet/corefx This PR contains mirrored changes from dotnet/corefx


**Please REBASE this PR when merging**</Title_Description>
    <Label>
    </Label>
    <Assignee>ahsonkhan</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17592</IssueLabelID>
    <Title>Handle getTailCallCopyArgsThunk returning NULL in the JIT</Title>
    <Description>This saves the JIT from hardcoding the logic on where getTailCallCopyArgsThunk is implemented</Description>
    <Title_Description>Handle getTailCallCopyArgsThunk returning NULL in the JIT This saves the JIT from hardcoding the logic on where getTailCallCopyArgsThunk is implemented</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>dotnet-bot</Assignee>
    <CreatedAt>16/04/2018 6:34:13 PM +00:00</CreatedAt>
    <ClosedAt>18/04/2018 12:06:33 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17591</IssueLabelID>
    <Title>[Arm64] Interlocked operations in the runtime need an additional memory barrier</Title>
    <Description>The issue is explained in the discussion of PR https://github.com/dotnet/coreclr/pull/17508:
- https://github.com/dotnet/coreclr/pull/17508#issuecomment-381305227
- https://github.com/dotnet/coreclr/pull/17508#issuecomment-381405138

The extra memory barrier is necessary to guarantee that the store from the interlocked operation occurs before a load following the interlocked operation.

https://github.com/dotnet/coreclr/pull/17567 fixes the issue in the JIT which was seen in https://github.com/dotnet/coreclr/issues/17178.

This issue is to track a similar change to the runtime.</Description>
    <Title_Description>[Arm64] Interlocked operations in the runtime need an additional memory barrier The issue is explained in the discussion of PR https://github.com/dotnet/coreclr/pull/17508:
- https://github.com/dotnet/coreclr/pull/17508#issuecomment-381305227
- https://github.com/dotnet/coreclr/pull/17508#issuecomment-381405138

The extra memory barrier is necessary to guarantee that the store from the interlocked operation occurs before a load following the interlocked operation.

https://github.com/dotnet/coreclr/pull/17567 fixes the issue in the JIT which was seen in https://github.com/dotnet/coreclr/issues/17178.

This issue is to track a similar change to the runtime.</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17588</IssueLabelID>
    <Title>[arm32/Ubuntu] Failures in R2R JitStressRegs3</Title>
    <Description>These may occur in the baseline but I haven't seen results there due to infrastructure issues.

https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_r2r_jitstressregs3_tst/2/consoleText

Tests:
```
GC/Scenarios/DoublinkList/dlbigleakthd/dlbigleakthd.sh
GC/Scenarios/DoublinkList/dlbigleakthd_v2/dlbigleakthd_v2.sh
GC/Scenarios/DoublinkList/doublinkstay/doublinkstay.sh
```

Failures:
```
FAILED   - GC/Scenarios/DoublinkList/dlbigleakthd/dlbigleakthd.sh
               BEGIN EXECUTION
               in takeLock
               /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_r2r_jitstressregs3_tst/bin/tests/Linux.arm.Checked/Tests/Core_Root/crossgen /Platform_Assemblies_Paths /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_r2r_jitstressregs3_tst/bin/tests/Linux.arm.Checked/Tests/Core_Root:/ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_r2r_jitstressregs3_tst/bin/tests/Linux.arm.Checked/GC/Scenarios/DoublinkList/dlbigleakthd/IL:/ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_r2r_jitstressregs3_tst/bin/tests/Linux.arm.Checked/GC/Scenarios/DoublinkList/dlbigleakthd /in dlbigleakthd.org /out dlbigleakthd.exe
               Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0
               Copyright (c) Microsoft Corporation.  All rights reserved.
               
               Native image dlbigleakthd.exe generated successfully.
               in ReleaseLock
               in takeLock
               /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_r2r_jitstressregs3_tst/bin/tests/Linux.arm.Checked/Tests/Core_Root/corerun dlbigleakthd.exe
               Test should return with ExitCode 100 ...
               980/1000 DLinkNodes finalized
               Test Failed
               in ReleaseLock
               Expected: 100
               Actual: 1
               END EXECUTION - FAILED
FAILED   - GC/Scenarios/DoublinkList/dlbigleakthd_v2/dlbigleakthd_v2.sh
               BEGIN EXECUTION
               in takeLock
               /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_r2r_jitstressregs3_tst/bin/tests/Linux.arm.Checked/Tests/Core_Root/crossgen /Platform_Assemblies_Paths /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_r2r_jitstressregs3_tst/bin/tests/Linux.arm.Checked/Tests/Core_Root:/ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_r2r_jitstressregs3_tst/bin/tests/Linux.arm.Checked/GC/Scenarios/DoublinkList/dlbigleakthd_v2/IL:/ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_r2r_jitstressregs3_tst/bin/tests/Linux.arm.Checked/GC/Scenarios/DoublinkList/dlbigleakthd_v2 /in dlbigleakthd_v2.org /out dlbigleakthd_v2.exe
               Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0
               Copyright (c) Microsoft Corporation.  All rights reserved.
               
               Native image dlbigleakthd_v2.exe generated successfully.
               in ReleaseLock
               in takeLock
               /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_r2r_jitstressregs3_tst/bin/tests/Linux.arm.Checked/Tests/Core_Root/corerun dlbigleakthd_v2.exe
               Test should return with ExitCode 100 ...
               980/1000 DLinkNodes finalized
               Test Failed
               in ReleaseLock
               Expected: 100
               Actual: 1
               END EXECUTION - FAILED
FAILED   - GC/Scenarios/DoublinkList/doublinkstay/doublinkstay.sh
               BEGIN EXECUTION
               in takeLock
               /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_r2r_jitstressregs3_tst/bin/tests/Linux.arm.Checked/Tests/Core_Root/crossgen /Platform_Assemblies_Paths /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_r2r_jitstressregs3_tst/bin/tests/Linux.arm.Checked/Tests/Core_Root:/ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_r2r_jitstressregs3_tst/bin/tests/Linux.arm.Checked/GC/Scenarios/DoublinkList/doublinkstay/IL:/ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_r2r_jitstressregs3_tst/bin/tests/Linux.arm.Checked/GC/Scenarios/DoublinkList/doublinkstay /in doublinkstay.org /out doublinkstay.exe
               Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0
               Copyright (c) Microsoft Corporation.  All rights reserved.
               
               Native image doublinkstay.exe generated successfully.
               in ReleaseLock
               in takeLock
               /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_r2r_jitstressregs3_tst/bin/tests/Linux.arm.Checked/Tests/Core_Root/corerun doublinkstay.exe
               Test should return with ExitCode 100 ...
               19990 DLinkNodes finalized
               Test Failed
               in ReleaseLock
               Expected: 100
               Actual: 1
```
</Description>
    <Title_Description>[arm32/Ubuntu] Failures in R2R JitStressRegs3 These may occur in the baseline but I haven't seen results there due to infrastructure issues.

https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_ubuntu_r2r_jitstressregs3_tst/2/consoleText

Tests:
```
GC/Scenarios/DoublinkList/dlbigleakthd/dlbigleakthd.sh
GC/Scenarios/DoublinkList/dlbigleakthd_v2/dlbigleakthd_v2.sh
GC/Scenarios/DoublinkList/doublinkstay/doublinkstay.sh
```

Failures:
```
FAILED   - GC/Scenarios/DoublinkList/dlbigleakthd/dlbigleakthd.sh
               BEGIN EXECUTION
               in takeLock
               /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_r2r_jitstressregs3_tst/bin/tests/Linux.arm.Checked/Tests/Core_Root/crossgen /Platform_Assemblies_Paths /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_r2r_jitstressregs3_tst/bin/tests/Linux.arm.Checked/Tests/Core_Root:/ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_r2r_jitstressregs3_tst/bin/tests/Linux.arm.Checked/GC/Scenarios/DoublinkList/dlbigleakthd/IL:/ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_r2r_jitstressregs3_tst/bin/tests/Linux.arm.Checked/GC/Scenarios/DoublinkList/dlbigleakthd /in dlbigleakthd.org /out dlbigleakthd.exe
               Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0
               Copyright (c) Microsoft Corporation.  All rights reserved.
               
               Native image dlbigleakthd.exe generated successfully.
               in ReleaseLock
               in takeLock
               /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_r2r_jitstressregs3_tst/bin/tests/Linux.arm.Checked/Tests/Core_Root/corerun dlbigleakthd.exe
               Test should return with ExitCode 100 ...
               980/1000 DLinkNodes finalized
               Test Failed
               in ReleaseLock
               Expected: 100
               Actual: 1
               END EXECUTION - FAILED
FAILED   - GC/Scenarios/DoublinkList/dlbigleakthd_v2/dlbigleakthd_v2.sh
               BEGIN EXECUTION
               in takeLock
               /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_r2r_jitstressregs3_tst/bin/tests/Linux.arm.Checked/Tests/Core_Root/crossgen /Platform_Assemblies_Paths /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_r2r_jitstressregs3_tst/bin/tests/Linux.arm.Checked/Tests/Core_Root:/ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_r2r_jitstressregs3_tst/bin/tests/Linux.arm.Checked/GC/Scenarios/DoublinkList/dlbigleakthd_v2/IL:/ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_r2r_jitstressregs3_tst/bin/tests/Linux.arm.Checked/GC/Scenarios/DoublinkList/dlbigleakthd_v2 /in dlbigleakthd_v2.org /out dlbigleakthd_v2.exe
               Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0
               Copyright (c) Microsoft Corporation.  All rights reserved.
               
               Native image dlbigleakthd_v2.exe generated successfully.
               in ReleaseLock
               in takeLock
               /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_r2r_jitstressregs3_tst/bin/tests/Linux.arm.Checked/Tests/Core_Root/corerun dlbigleakthd_v2.exe
               Test should return with ExitCode 100 ...
               980/1000 DLinkNodes finalized
               Test Failed
               in ReleaseLock
               Expected: 100
               Actual: 1
               END EXECUTION - FAILED
FAILED   - GC/Scenarios/DoublinkList/doublinkstay/doublinkstay.sh
               BEGIN EXECUTION
               in takeLock
               /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_r2r_jitstressregs3_tst/bin/tests/Linux.arm.Checked/Tests/Core_Root/crossgen /Platform_Assemblies_Paths /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_r2r_jitstressregs3_tst/bin/tests/Linux.arm.Checked/Tests/Core_Root:/ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_r2r_jitstressregs3_tst/bin/tests/Linux.arm.Checked/GC/Scenarios/DoublinkList/doublinkstay/IL:/ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_r2r_jitstressregs3_tst/bin/tests/Linux.arm.Checked/GC/Scenarios/DoublinkList/doublinkstay /in doublinkstay.org /out doublinkstay.exe
               Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0
               Copyright (c) Microsoft Corporation.  All rights reserved.
               
               Native image doublinkstay.exe generated successfully.
               in ReleaseLock
               in takeLock
               /ssd/j/workspace/dotnet_coreclr/master/jitstress/arm_cross_checked_ubuntu_r2r_jitstressregs3_tst/bin/tests/Linux.arm.Checked/Tests/Core_Root/corerun doublinkstay.exe
               Test should return with ExitCode 100 ...
               19990 DLinkNodes finalized
               Test Failed
               in ReleaseLock
               Expected: 100
               Actual: 1
```
</Title_Description>
    <Label>JitStress</Label>
    <Assignee>sandreenko</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17587</IssueLabelID>
    <Title>.NET Core assembly cannot be found when assembly loaded through dynamic IL injected-code</Title>
    <Description> I have a profiler that injects IL into some methods so that they can call into my managed assembly. Since my assembly is in the GAC it works fine for .NET Framework but when I tried it in .NET Core the assembly could not be found. Although this may be a duplicate of https://github.com/dotnet/coreclr/issues/3894 I would like to hear what you think are the best options for accomplishing this assembly load. I do not want to modify the application being profiled (I don't have control over its source) so the solution needs to be something I can do with the profiler or a simplified environment setting.
</Description>
    <Title_Description>.NET Core assembly cannot be found when assembly loaded through dynamic IL injected-code  I have a profiler that injects IL into some methods so that they can call into my managed assembly. Since my assembly is in the GAC it works fine for .NET Framework but when I tried it in .NET Core the assembly could not be found. Although this may be a duplicate of https://github.com/dotnet/coreclr/issues/3894 I would like to hear what you think are the best options for accomplishing this assembly load. I do not want to modify the application being profiled (I don't have control over its source) so the solution needs to be something I can do with the profiler or a simplified environment setting.
</Title_Description>
    <Label>area-Diagnostics</Label>
    <Assignee>noahfalk</Assignee>
    <CreatedAt>16/04/2018 5:50:45 PM +00:00</CreatedAt>
    <ClosedAt>18/04/2018 3:58:36 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17585</IssueLabelID>
    <Title>[arm32] Assert failure: ExecutionManager::IsManagedCode(adrRedirectedIP)</Title>
    <Description>Consistent failure in Windows arm32 corefx test System.Runtime.Tests with COMPlus_JitStress=2:

https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_corefx_jitstress2_tst/10/consoleText

```
Running: C:\Users\robox\j\workspace\arm_cross_che---6fedd1e9\_\fx\bin\tests\System.Runtime.Tests\netcoreapp-Windows_NT-Release-arm\RunTests.cmd C:\Users\robox\j\workspace\arm_cross_che---6fedd1e9\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm
Using C:\Users\robox\j\workspace\arm_cross_che---6fedd1e9\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm as the test runtime folder.
Executing in C:\Users\robox\j\workspace\arm_cross_che---6fedd1e9\_\fx\bin\tests\System.Runtime.Tests\netcoreapp-Windows_NT-Release-arm\ 
----- start  0:15:29.22 ===============  To repro directly: ===================================================== 
pushd C:\Users\robox\j\workspace\arm_cross_che---6fedd1e9\_\fx\bin\tests\System.Runtime.Tests\netcoreapp-Windows_NT-Release-arm\
set COMPlus_JitStress=2
call C:\Users\robox\j\workspace\arm_cross_che---6fedd1e9\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm\dotnet.exe xunit.console.netcore.exe System.Runtime.Tests.dll  -xml testResults.xml -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonwindowstests  -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing
popd
===========================================================================================================

C:\Users\robox\j\workspace\arm_cross_che---6fedd1e9\_\fx\bin\tests\System.Runtime.Tests\netcoreapp-Windows_NT-Release-arm&gt;set COMPlus_JitStress=2 

C:\Users\robox\j\workspace\arm_cross_che---6fedd1e9\_\fx\bin\tests\System.Runtime.Tests\netcoreapp-Windows_NT-Release-arm&gt;call C:\Users\robox\j\workspace\arm_cross_che---6fedd1e9\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm\dotnet.exe xunit.console.netcore.exe System.Runtime.Tests.dll  -xml testResults.xml -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonwindowstests  -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing 
xUnit.net console test runner (32-bit .NET Core)
Copyright (C) 2014 Outercurve Foundation.

Discovering: System.Runtime.Tests
Discovered:  System.Runtime.Tests
Starting:    System.Runtime.Tests

Assert failure(PID 6980 [0x00001b44] Thread: 16036 [0x3ea4]): ExecutionManager::IsManagedCode(adrRedirectedIP)

&lt;no module&gt;! &lt;no symbol&gt; + 0x0 (0x00000000)
    File: d:\j\workspace\arm_cross_che---b006c545\src\vm\exceptionhandling.cpp Line: 5594
    Image: C:\Users\robox\j\workspace\arm_cross_che---6fedd1e9\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm\dotnet.exe

----- end  0:16:09.48 ----- exit code 123456789 ----------------------------------------------------------
COREFX TEST FAILED
```
</Description>
    <Title_Description>[arm32] Assert failure: ExecutionManager::IsManagedCode(adrRedirectedIP) Consistent failure in Windows arm32 corefx test System.Runtime.Tests with COMPlus_JitStress=2:

https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_corefx_jitstress2_tst/10/consoleText

```
Running: C:\Users\robox\j\workspace\arm_cross_che---6fedd1e9\_\fx\bin\tests\System.Runtime.Tests\netcoreapp-Windows_NT-Release-arm\RunTests.cmd C:\Users\robox\j\workspace\arm_cross_che---6fedd1e9\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm
Using C:\Users\robox\j\workspace\arm_cross_che---6fedd1e9\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm as the test runtime folder.
Executing in C:\Users\robox\j\workspace\arm_cross_che---6fedd1e9\_\fx\bin\tests\System.Runtime.Tests\netcoreapp-Windows_NT-Release-arm\ 
----- start  0:15:29.22 ===============  To repro directly: ===================================================== 
pushd C:\Users\robox\j\workspace\arm_cross_che---6fedd1e9\_\fx\bin\tests\System.Runtime.Tests\netcoreapp-Windows_NT-Release-arm\
set COMPlus_JitStress=2
call C:\Users\robox\j\workspace\arm_cross_che---6fedd1e9\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm\dotnet.exe xunit.console.netcore.exe System.Runtime.Tests.dll  -xml testResults.xml -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonwindowstests  -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing
popd
===========================================================================================================

C:\Users\robox\j\workspace\arm_cross_che---6fedd1e9\_\fx\bin\tests\System.Runtime.Tests\netcoreapp-Windows_NT-Release-arm&gt;set COMPlus_JitStress=2 

C:\Users\robox\j\workspace\arm_cross_che---6fedd1e9\_\fx\bin\tests\System.Runtime.Tests\netcoreapp-Windows_NT-Release-arm&gt;call C:\Users\robox\j\workspace\arm_cross_che---6fedd1e9\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm\dotnet.exe xunit.console.netcore.exe System.Runtime.Tests.dll  -xml testResults.xml -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonwindowstests  -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing 
xUnit.net console test runner (32-bit .NET Core)
Copyright (C) 2014 Outercurve Foundation.

Discovering: System.Runtime.Tests
Discovered:  System.Runtime.Tests
Starting:    System.Runtime.Tests

Assert failure(PID 6980 [0x00001b44] Thread: 16036 [0x3ea4]): ExecutionManager::IsManagedCode(adrRedirectedIP)

&lt;no module&gt;! &lt;no symbol&gt; + 0x0 (0x00000000)
    File: d:\j\workspace\arm_cross_che---b006c545\src\vm\exceptionhandling.cpp Line: 5594
    Image: C:\Users\robox\j\workspace\arm_cross_che---6fedd1e9\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm\dotnet.exe

----- end  0:16:09.48 ----- exit code 123456789 ----------------------------------------------------------
COREFX TEST FAILED
```
</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>sandreenko</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17584</IssueLabelID>
    <Title>[arm32/Windows] Test Failed: Failure in corefx System.Net.HttpListener.Tests</Title>
    <Description>Consistent failure in Windows arm32 corefx System.Net.HttpListener.Tests with COMPlus_JitStress=2:

https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_corefx_jitstress2_tst/10/consoleText

```
Running: C:\Users\robox\j\workspace\arm_cross_che---6fedd1e9\_\fx\bin\tests\System.Net.HttpListener.Tests\netcoreapp-Windows_NT-Release-arm\RunTests.cmd C:\Users\robox\j\workspace\arm_cross_che---6fedd1e9\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm
Using C:\Users\robox\j\workspace\arm_cross_che---6fedd1e9\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm as the test runtime folder.
Executing in C:\Users\robox\j\workspace\arm_cross_che---6fedd1e9\_\fx\bin\tests\System.Net.HttpListener.Tests\netcoreapp-Windows_NT-Release-arm\ 
----- start 23:44:22.99 ===============  To repro directly: ===================================================== 
pushd C:\Users\robox\j\workspace\arm_cross_che---6fedd1e9\_\fx\bin\tests\System.Net.HttpListener.Tests\netcoreapp-Windows_NT-Release-arm\
set COMPlus_JitStress=2
call C:\Users\robox\j\workspace\arm_cross_che---6fedd1e9\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm\dotnet.exe xunit.console.netcore.exe System.Net.HttpListener.Tests.dll  -xml testResults.xml -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonwindowstests  -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing
popd
===========================================================================================================

C:\Users\robox\j\workspace\arm_cross_che---6fedd1e9\_\fx\bin\tests\System.Net.HttpListener.Tests\netcoreapp-Windows_NT-Release-arm&gt;set COMPlus_JitStress=2 

C:\Users\robox\j\workspace\arm_cross_che---6fedd1e9\_\fx\bin\tests\System.Net.HttpListener.Tests\netcoreapp-Windows_NT-Release-arm&gt;call C:\Users\robox\j\workspace\arm_cross_che---6fedd1e9\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm\dotnet.exe xunit.console.netcore.exe System.Net.HttpListener.Tests.dll  -xml testResults.xml -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonwindowstests  -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing 
xUnit.net console test runner (32-bit .NET Core)
Copyright (C) 2014 Outercurve Foundation.

Discovering: System.Net.HttpListener.Tests
Discovered:  System.Net.HttpListener.Tests
Starting:    System.Net.HttpListener.Tests
   System.Net.Tests.HttpListenerTimeoutManagerWindowsTests.IdleConnection_SetTimeoutNoStart_GetReturnsNewValue [FAIL]
      Assert.Equal() Failure
      Expected: 0
      Actual:   300
      Stack Trace:
         D:\j\workspace\arm_cross_che---b006c545\_\fx\src\System.Net.HttpListener\tests\HttpListenerTimeoutManagerTests.cs(2740): at System.Net.Tests.HttpListenerTimeoutManagerWindowsTests.IdleConnection_SetTimeoutNoStart_GetReturnsNewValue()
   System.Net.Tests.HttpListenerTimeoutManagerWindowsTests.MinSendBytesPerSecond_SetNoStart_GetReturnsNewValue [FAIL]
      Assert.Equal() Failure
      Expected: 0
      Actual:   10485760
      Stack Trace:
         D:\j\workspace\arm_cross_che---b006c545\_\fx\src\System.Net.HttpListener\tests\HttpListenerTimeoutManagerTests.cs(2960): at System.Net.Tests.HttpListenerTimeoutManagerWindowsTests.MinSendBytesPerSecond_SetNoStart_GetReturnsNewValue()
   System.Net.Tests.HttpListenerTimeoutManagerWindowsTests.IdleConnection_SetTimeoutAfterStart_GetReturnsNewValue [FAIL]
      Assert.Equal() Failure
      Expected: 0
      Actual:   300
      Stack Trace:
         D:\j\workspace\arm_cross_che---b006c545\_\fx\src\System.Net.HttpListener\tests\HttpListenerTimeoutManagerTests.cs(2850): at System.Net.Tests.HttpListenerTimeoutManagerWindowsTests.IdleConnection_SetTimeoutAfterStart_GetReturnsNewValue()
   System.Net.Tests.HttpListenerTimeoutManagerWindowsTests.MinSendBytesPerSecond_SetAfterStart_GetReturnsNewValue [FAIL]
      Assert.Equal() Failure
      Expected: 0
      Actual:   10485760
      Stack Trace:
         D:\j\workspace\arm_cross_che---b006c545\_\fx\src\System.Net.HttpListener\tests\HttpListenerTimeoutManagerTests.cs(3080): at System.Net.Tests.HttpListenerTimeoutManagerWindowsTests.MinSendBytesPerSecond_SetAfterStart_GetReturnsNewValue()
   System.Net.Tests.HttpListenerTimeoutManagerWindowsTests.HeaderWait_SetTimeoutNoStart_GetReturnsNewValue [FAIL]
      Assert.Equal() Failure
      Expected: 0
      Actual:   300
      Stack Trace:
         D:\j\workspace\arm_cross_che---b006c545\_\fx\src\System.Net.HttpListener\tests\HttpListenerTimeoutManagerTests.cs(2290): at System.Net.Tests.HttpListenerTimeoutManagerWindowsTests.HeaderWait_SetTimeoutNoStart_GetReturnsNewValue()
   System.Net.Tests.HttpListenerTimeoutManagerWindowsTests.RequestQueue_SetTimeoutNoStart_GetReturnsNewValue [FAIL]
      Assert.Equal() Failure
      Expected: 0
      Actual:   300
   System.Net.Tests.HttpListenerTimeoutManagerWindowsTests.MinSendBytesPerSecond_SetAfterStop_GetReturnsNewValue [FAIL]
      Assert.Equal() Failure
      Expected: 0
      Actual:   10485760
      Stack Trace:
         D:\j\workspace\arm_cross_che---b006c545\_\fx\src\System.Net.HttpListener\tests\HttpListenerTimeoutManagerTests.cs(3300): at System.Net.Tests.HttpListenerTimeoutManagerWindowsTests.MinSendBytesPerSecond_SetAfterStop_GetReturnsNewValue()
   System.Net.Tests.HttpListenerTimeoutManagerWindowsTests.RequestQueue_SetTimeoutAfterStart_GetReturnsNewValue [FAIL]
      Assert.Equal() Failure
      Expected: 0
      Actual:   300
      Stack Trace:
         D:\j\workspace\arm_cross_che---b006c545\_\fx\src\System.Net.HttpListener\tests\HttpListenerTimeoutManagerTests.cs(2640): at System.Net.Tests.HttpListenerTimeoutManagerWindowsTests.RequestQueue_SetTimeoutAfterStart_GetReturnsNewValue()
   System.Net.Tests.HttpListenerTimeoutManagerWindowsTests.DrainEntityBody_SetTimeoutNoStart_GetReturnsNewValue [FAIL]
      Assert.Equal() Failure
      Expected: 0
      Actual:   300
      Stack Trace:
         D:\j\workspace\arm_cross_che---b006c545\_\fx\src\System.Net.HttpListener\tests\HttpListenerTimeoutManagerTests.cs(1900): at System.Net.Tests.HttpListenerTimeoutManagerWindowsTests.DrainEntityBody_SetTimeoutNoStart_GetReturnsNewValue()
   System.Net.Tests.HttpListenerTimeoutManagerWindowsTests.EntityBody_SetTimeoutNoStart_GetReturnsNewValue [FAIL]
      Assert.Equal() Failure
      Expected: 0
      Actual:   300
      Stack Trace:
         D:\j\workspace\arm_cross_che---b006c545\_\fx\src\System.Net.HttpListener\tests\HttpListenerTimeoutManagerTests.cs(2110): at System.Net.Tests.HttpListenerTimeoutManagerWindowsTests.EntityBody_SetTimeoutNoStart_GetReturnsNewValue()
   System.Net.Tests.HttpListenerTimeoutManagerWindowsTests.EntityBody_SetTimeoutAfterStart_GetReturnsNewValue [FAIL]
      Assert.Equal() Failure
      Expected: 0
      Actual:   300
      Stack Trace:
         D:\j\workspace\arm_cross_che---b006c545\_\fx\src\System.Net.HttpListener\tests\HttpListenerTimeoutManagerTests.cs(2220): at System.Net.Tests.HttpListenerTimeoutManagerWindowsTests.EntityBody_SetTimeoutAfterStart_GetReturnsNewValue()
   System.Net.Tests.HttpListenerTimeoutManagerWindowsTests.DrainEntityBody_SetTimeoutAfterStart_GetReturnsNewValue [FAIL]
      Assert.Equal() Failure
      Expected: 0
      Actual:   300
      Stack Trace:
         D:\j\workspace\arm_cross_che---b006c545\_\fx\src\System.Net.HttpListener\tests\HttpListenerTimeoutManagerTests.cs(2010): at System.Net.Tests.HttpListenerTimeoutManagerWindowsTests.DrainEntityBody_SetTimeoutAfterStart_GetReturnsNewValue()
   System.Net.Tests.HttpListenerTimeoutManagerWindowsTests.HeaderWait_SetTimeoutAfterStart_GetReturnsNewValue [FAIL]
      Assert.Equal() Failure
      Expected: 0
      Actual:   300
      Stack Trace:
         D:\j\workspace\arm_cross_che---b006c545\_\fx\src\System.Net.HttpListener\tests\HttpListenerTimeoutManagerTests.cs(2430): at System.Net.Tests.HttpListenerTimeoutManagerWindowsTests.HeaderWait_SetTimeoutAfterStart_GetReturnsNewValue()
   System.Net.Tests.HttpListenerTimeoutManagerUnixTests.IdleConnection_Roundtrips [SKIP]
      Condition(s) not met: \"IsManagedImplementation\"
   System.Net.Tests.HttpListenerTimeoutManagerUnixTests.UnsupportedProperties_Throw [SKIP]
      Condition(s) not met: \"IsManagedImplementation\"
   System.Net.Tests.HttpListenerTimeoutManagerUnixTests.Properties_DefaultValues [SKIP]
      Condition(s) not met: \"IsManagedImplementation\"
   System.Net.Tests.HttpListenerTimeoutManagerUnixTests.DrainEntityBody_Roundtrips [SKIP]
      Condition(s) not met: \"IsManagedImplementation\"
Finished:    System.Net.HttpListener.Tests

=== TEST EXECUTION SUMMARY ===
   System.Net.HttpListener.Tests  Total: 661 Errors: 0 Failed: 13 Skipped: 4 Time: 52.882s
----- end 23:45:23.83 ----- exit code 1 ----------------------------------------------------------
COREFX TEST FAILED
```
</Description>
    <Title_Description>[arm32/Windows] Test Failed: Failure in corefx System.Net.HttpListener.Tests Consistent failure in Windows arm32 corefx System.Net.HttpListener.Tests with COMPlus_JitStress=2:

https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_corefx_jitstress2_tst/10/consoleText

```
Running: C:\Users\robox\j\workspace\arm_cross_che---6fedd1e9\_\fx\bin\tests\System.Net.HttpListener.Tests\netcoreapp-Windows_NT-Release-arm\RunTests.cmd C:\Users\robox\j\workspace\arm_cross_che---6fedd1e9\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm
Using C:\Users\robox\j\workspace\arm_cross_che---6fedd1e9\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm as the test runtime folder.
Executing in C:\Users\robox\j\workspace\arm_cross_che---6fedd1e9\_\fx\bin\tests\System.Net.HttpListener.Tests\netcoreapp-Windows_NT-Release-arm\ 
----- start 23:44:22.99 ===============  To repro directly: ===================================================== 
pushd C:\Users\robox\j\workspace\arm_cross_che---6fedd1e9\_\fx\bin\tests\System.Net.HttpListener.Tests\netcoreapp-Windows_NT-Release-arm\
set COMPlus_JitStress=2
call C:\Users\robox\j\workspace\arm_cross_che---6fedd1e9\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm\dotnet.exe xunit.console.netcore.exe System.Net.HttpListener.Tests.dll  -xml testResults.xml -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonwindowstests  -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing
popd
===========================================================================================================

C:\Users\robox\j\workspace\arm_cross_che---6fedd1e9\_\fx\bin\tests\System.Net.HttpListener.Tests\netcoreapp-Windows_NT-Release-arm&gt;set COMPlus_JitStress=2 

C:\Users\robox\j\workspace\arm_cross_che---6fedd1e9\_\fx\bin\tests\System.Net.HttpListener.Tests\netcoreapp-Windows_NT-Release-arm&gt;call C:\Users\robox\j\workspace\arm_cross_che---6fedd1e9\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm\dotnet.exe xunit.console.netcore.exe System.Net.HttpListener.Tests.dll  -xml testResults.xml -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonwindowstests  -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing 
xUnit.net console test runner (32-bit .NET Core)
Copyright (C) 2014 Outercurve Foundation.

Discovering: System.Net.HttpListener.Tests
Discovered:  System.Net.HttpListener.Tests
Starting:    System.Net.HttpListener.Tests
   System.Net.Tests.HttpListenerTimeoutManagerWindowsTests.IdleConnection_SetTimeoutNoStart_GetReturnsNewValue [FAIL]
      Assert.Equal() Failure
      Expected: 0
      Actual:   300
      Stack Trace:
         D:\j\workspace\arm_cross_che---b006c545\_\fx\src\System.Net.HttpListener\tests\HttpListenerTimeoutManagerTests.cs(2740): at System.Net.Tests.HttpListenerTimeoutManagerWindowsTests.IdleConnection_SetTimeoutNoStart_GetReturnsNewValue()
   System.Net.Tests.HttpListenerTimeoutManagerWindowsTests.MinSendBytesPerSecond_SetNoStart_GetReturnsNewValue [FAIL]
      Assert.Equal() Failure
      Expected: 0
      Actual:   10485760
      Stack Trace:
         D:\j\workspace\arm_cross_che---b006c545\_\fx\src\System.Net.HttpListener\tests\HttpListenerTimeoutManagerTests.cs(2960): at System.Net.Tests.HttpListenerTimeoutManagerWindowsTests.MinSendBytesPerSecond_SetNoStart_GetReturnsNewValue()
   System.Net.Tests.HttpListenerTimeoutManagerWindowsTests.IdleConnection_SetTimeoutAfterStart_GetReturnsNewValue [FAIL]
      Assert.Equal() Failure
      Expected: 0
      Actual:   300
      Stack Trace:
         D:\j\workspace\arm_cross_che---b006c545\_\fx\src\System.Net.HttpListener\tests\HttpListenerTimeoutManagerTests.cs(2850): at System.Net.Tests.HttpListenerTimeoutManagerWindowsTests.IdleConnection_SetTimeoutAfterStart_GetReturnsNewValue()
   System.Net.Tests.HttpListenerTimeoutManagerWindowsTests.MinSendBytesPerSecond_SetAfterStart_GetReturnsNewValue [FAIL]
      Assert.Equal() Failure
      Expected: 0
      Actual:   10485760
      Stack Trace:
         D:\j\workspace\arm_cross_che---b006c545\_\fx\src\System.Net.HttpListener\tests\HttpListenerTimeoutManagerTests.cs(3080): at System.Net.Tests.HttpListenerTimeoutManagerWindowsTests.MinSendBytesPerSecond_SetAfterStart_GetReturnsNewValue()
   System.Net.Tests.HttpListenerTimeoutManagerWindowsTests.HeaderWait_SetTimeoutNoStart_GetReturnsNewValue [FAIL]
      Assert.Equal() Failure
      Expected: 0
      Actual:   300
      Stack Trace:
         D:\j\workspace\arm_cross_che---b006c545\_\fx\src\System.Net.HttpListener\tests\HttpListenerTimeoutManagerTests.cs(2290): at System.Net.Tests.HttpListenerTimeoutManagerWindowsTests.HeaderWait_SetTimeoutNoStart_GetReturnsNewValue()
   System.Net.Tests.HttpListenerTimeoutManagerWindowsTests.RequestQueue_SetTimeoutNoStart_GetReturnsNewValue [FAIL]
      Assert.Equal() Failure
      Expected: 0
      Actual:   300
   System.Net.Tests.HttpListenerTimeoutManagerWindowsTests.MinSendBytesPerSecond_SetAfterStop_GetReturnsNewValue [FAIL]
      Assert.Equal() Failure
      Expected: 0
      Actual:   10485760
      Stack Trace:
         D:\j\workspace\arm_cross_che---b006c545\_\fx\src\System.Net.HttpListener\tests\HttpListenerTimeoutManagerTests.cs(3300): at System.Net.Tests.HttpListenerTimeoutManagerWindowsTests.MinSendBytesPerSecond_SetAfterStop_GetReturnsNewValue()
   System.Net.Tests.HttpListenerTimeoutManagerWindowsTests.RequestQueue_SetTimeoutAfterStart_GetReturnsNewValue [FAIL]
      Assert.Equal() Failure
      Expected: 0
      Actual:   300
      Stack Trace:
         D:\j\workspace\arm_cross_che---b006c545\_\fx\src\System.Net.HttpListener\tests\HttpListenerTimeoutManagerTests.cs(2640): at System.Net.Tests.HttpListenerTimeoutManagerWindowsTests.RequestQueue_SetTimeoutAfterStart_GetReturnsNewValue()
   System.Net.Tests.HttpListenerTimeoutManagerWindowsTests.DrainEntityBody_SetTimeoutNoStart_GetReturnsNewValue [FAIL]
      Assert.Equal() Failure
      Expected: 0
      Actual:   300
      Stack Trace:
         D:\j\workspace\arm_cross_che---b006c545\_\fx\src\System.Net.HttpListener\tests\HttpListenerTimeoutManagerTests.cs(1900): at System.Net.Tests.HttpListenerTimeoutManagerWindowsTests.DrainEntityBody_SetTimeoutNoStart_GetReturnsNewValue()
   System.Net.Tests.HttpListenerTimeoutManagerWindowsTests.EntityBody_SetTimeoutNoStart_GetReturnsNewValue [FAIL]
      Assert.Equal() Failure
      Expected: 0
      Actual:   300
      Stack Trace:
         D:\j\workspace\arm_cross_che---b006c545\_\fx\src\System.Net.HttpListener\tests\HttpListenerTimeoutManagerTests.cs(2110): at System.Net.Tests.HttpListenerTimeoutManagerWindowsTests.EntityBody_SetTimeoutNoStart_GetReturnsNewValue()
   System.Net.Tests.HttpListenerTimeoutManagerWindowsTests.EntityBody_SetTimeoutAfterStart_GetReturnsNewValue [FAIL]
      Assert.Equal() Failure
      Expected: 0
      Actual:   300
      Stack Trace:
         D:\j\workspace\arm_cross_che---b006c545\_\fx\src\System.Net.HttpListener\tests\HttpListenerTimeoutManagerTests.cs(2220): at System.Net.Tests.HttpListenerTimeoutManagerWindowsTests.EntityBody_SetTimeoutAfterStart_GetReturnsNewValue()
   System.Net.Tests.HttpListenerTimeoutManagerWindowsTests.DrainEntityBody_SetTimeoutAfterStart_GetReturnsNewValue [FAIL]
      Assert.Equal() Failure
      Expected: 0
      Actual:   300
      Stack Trace:
         D:\j\workspace\arm_cross_che---b006c545\_\fx\src\System.Net.HttpListener\tests\HttpListenerTimeoutManagerTests.cs(2010): at System.Net.Tests.HttpListenerTimeoutManagerWindowsTests.DrainEntityBody_SetTimeoutAfterStart_GetReturnsNewValue()
   System.Net.Tests.HttpListenerTimeoutManagerWindowsTests.HeaderWait_SetTimeoutAfterStart_GetReturnsNewValue [FAIL]
      Assert.Equal() Failure
      Expected: 0
      Actual:   300
      Stack Trace:
         D:\j\workspace\arm_cross_che---b006c545\_\fx\src\System.Net.HttpListener\tests\HttpListenerTimeoutManagerTests.cs(2430): at System.Net.Tests.HttpListenerTimeoutManagerWindowsTests.HeaderWait_SetTimeoutAfterStart_GetReturnsNewValue()
   System.Net.Tests.HttpListenerTimeoutManagerUnixTests.IdleConnection_Roundtrips [SKIP]
      Condition(s) not met: \"IsManagedImplementation\"
   System.Net.Tests.HttpListenerTimeoutManagerUnixTests.UnsupportedProperties_Throw [SKIP]
      Condition(s) not met: \"IsManagedImplementation\"
   System.Net.Tests.HttpListenerTimeoutManagerUnixTests.Properties_DefaultValues [SKIP]
      Condition(s) not met: \"IsManagedImplementation\"
   System.Net.Tests.HttpListenerTimeoutManagerUnixTests.DrainEntityBody_Roundtrips [SKIP]
      Condition(s) not met: \"IsManagedImplementation\"
Finished:    System.Net.HttpListener.Tests

=== TEST EXECUTION SUMMARY ===
   System.Net.HttpListener.Tests  Total: 661 Errors: 0 Failed: 13 Skipped: 4 Time: 52.882s
----- end 23:45:23.83 ----- exit code 1 ----------------------------------------------------------
COREFX TEST FAILED
```
</Title_Description>
    <Label>JitStress</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>16/04/2018 5:14:17 PM +00:00</CreatedAt>
    <ClosedAt>20/09/2019 6:39:04 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17583</IssueLabelID>
    <Title>Failure in corefx System.Diagnostics.StackTrace.Tests</Title>
    <Description>Consistent failure in COMPlus_JitStress=2 runs of corefx tests in System.Diagnostics.StackTrace.Tests:

https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_corefx_jitstress2_tst/10/consoleText

```
Running: C:\Users\robox\j\workspace\arm_cross_che---6fedd1e9\_\fx\bin\tests\System.Diagnostics.StackTrace.Tests\netcoreapp-Windows_NT-Release-arm\RunTests.cmd C:\Users\robox\j\workspace\arm_cross_che---6fedd1e9\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm
Using C:\Users\robox\j\workspace\arm_cross_che---6fedd1e9\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm as the test runtime folder.
Executing in C:\Users\robox\j\workspace\arm_cross_che---6fedd1e9\_\fx\bin\tests\System.Diagnostics.StackTrace.Tests\netcoreapp-Windows_NT-Release-arm\ 
----- start 23:12:41.18 ===============  To repro directly: ===================================================== 
pushd C:\Users\robox\j\workspace\arm_cross_che---6fedd1e9\_\fx\bin\tests\System.Diagnostics.StackTrace.Tests\netcoreapp-Windows_NT-Release-arm\
set COMPlus_JitStress=2
call C:\Users\robox\j\workspace\arm_cross_che---6fedd1e9\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm\dotnet.exe xunit.console.netcore.exe System.Diagnostics.StackTrace.Tests.dll  -xml testResults.xml -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonwindowstests  -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing
popd
===========================================================================================================

C:\Users\robox\j\workspace\arm_cross_che---6fedd1e9\_\fx\bin\tests\System.Diagnostics.StackTrace.Tests\netcoreapp-Windows_NT-Release-arm&gt;set COMPlus_JitStress=2 

C:\Users\robox\j\workspace\arm_cross_che---6fedd1e9\_\fx\bin\tests\System.Diagnostics.StackTrace.Tests\netcoreapp-Windows_NT-Release-arm&gt;call C:\Users\robox\j\workspace\arm_cross_che---6fedd1e9\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm\dotnet.exe xunit.console.netcore.exe System.Diagnostics.StackTrace.Tests.dll  -xml testResults.xml -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonwindowstests  -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing 
xUnit.net console test runner (32-bit .NET Core)
Copyright (C) 2014 Outercurve Foundation.

Discovering: System.Diagnostics.StackTrace.Tests
Discovered:  System.Diagnostics.StackTrace.Tests
Starting:    System.Diagnostics.StackTrace.Tests
   System.Diagnostics.Tests.StackFrameTests.SkipFrames_CallMethod_ReturnsExpected [FAIL]
      Assert.NotEqual() Failure
      Expected: Not Void SkipFrames_CallMethod_ReturnsExpected()
      Actual:   Void SkipFrames_CallMethod_ReturnsExpected()
      Stack Trace:
         D:\j\workspace\arm_cross_che---b006c545\_\fx\src\System.Diagnostics.StackTrace\tests\StackFrameTests.cs(690): at System.Diagnostics.Tests.StackFrameTests.SkipFrames_CallMethod_ReturnsExpected()
Finished:    System.Diagnostics.StackTrace.Tests

=== TEST EXECUTION SUMMARY ===
   System.Diagnostics.StackTrace.Tests  Total: 103 Errors: 0 Failed: 1 Skipped: 0 Time: 4.276s
----- end 23:12:50.46 ----- exit code 1 ----------------------------------------------------------
COREFX TEST FAILED
```
</Description>
    <Title_Description>Failure in corefx System.Diagnostics.StackTrace.Tests Consistent failure in COMPlus_JitStress=2 runs of corefx tests in System.Diagnostics.StackTrace.Tests:

https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_corefx_jitstress2_tst/10/consoleText

```
Running: C:\Users\robox\j\workspace\arm_cross_che---6fedd1e9\_\fx\bin\tests\System.Diagnostics.StackTrace.Tests\netcoreapp-Windows_NT-Release-arm\RunTests.cmd C:\Users\robox\j\workspace\arm_cross_che---6fedd1e9\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm
Using C:\Users\robox\j\workspace\arm_cross_che---6fedd1e9\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm as the test runtime folder.
Executing in C:\Users\robox\j\workspace\arm_cross_che---6fedd1e9\_\fx\bin\tests\System.Diagnostics.StackTrace.Tests\netcoreapp-Windows_NT-Release-arm\ 
----- start 23:12:41.18 ===============  To repro directly: ===================================================== 
pushd C:\Users\robox\j\workspace\arm_cross_che---6fedd1e9\_\fx\bin\tests\System.Diagnostics.StackTrace.Tests\netcoreapp-Windows_NT-Release-arm\
set COMPlus_JitStress=2
call C:\Users\robox\j\workspace\arm_cross_che---6fedd1e9\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm\dotnet.exe xunit.console.netcore.exe System.Diagnostics.StackTrace.Tests.dll  -xml testResults.xml -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonwindowstests  -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing
popd
===========================================================================================================

C:\Users\robox\j\workspace\arm_cross_che---6fedd1e9\_\fx\bin\tests\System.Diagnostics.StackTrace.Tests\netcoreapp-Windows_NT-Release-arm&gt;set COMPlus_JitStress=2 

C:\Users\robox\j\workspace\arm_cross_che---6fedd1e9\_\fx\bin\tests\System.Diagnostics.StackTrace.Tests\netcoreapp-Windows_NT-Release-arm&gt;call C:\Users\robox\j\workspace\arm_cross_che---6fedd1e9\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm\dotnet.exe xunit.console.netcore.exe System.Diagnostics.StackTrace.Tests.dll  -xml testResults.xml -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonwindowstests  -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing 
xUnit.net console test runner (32-bit .NET Core)
Copyright (C) 2014 Outercurve Foundation.

Discovering: System.Diagnostics.StackTrace.Tests
Discovered:  System.Diagnostics.StackTrace.Tests
Starting:    System.Diagnostics.StackTrace.Tests
   System.Diagnostics.Tests.StackFrameTests.SkipFrames_CallMethod_ReturnsExpected [FAIL]
      Assert.NotEqual() Failure
      Expected: Not Void SkipFrames_CallMethod_ReturnsExpected()
      Actual:   Void SkipFrames_CallMethod_ReturnsExpected()
      Stack Trace:
         D:\j\workspace\arm_cross_che---b006c545\_\fx\src\System.Diagnostics.StackTrace\tests\StackFrameTests.cs(690): at System.Diagnostics.Tests.StackFrameTests.SkipFrames_CallMethod_ReturnsExpected()
Finished:    System.Diagnostics.StackTrace.Tests

=== TEST EXECUTION SUMMARY ===
   System.Diagnostics.StackTrace.Tests  Total: 103 Errors: 0 Failed: 1 Skipped: 0 Time: 4.276s
----- end 23:12:50.46 ----- exit code 1 ----------------------------------------------------------
COREFX TEST FAILED
```
</Title_Description>
    <Label>JitStress</Label>
    <Assignee>sandreenko</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17582</IssueLabelID>
    <Title>[arm32/Windows] Hang in corefx Microsoft.Win32.SystemEvents.Tests</Title>
    <Description>Many arm32 Windows corefx jobs in the CI are hanging apparently on Microsoft.Win32.SystemEvents.Tests e.g.:

https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_corefx_baseline_tst/11/console
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_corefx_jitstress1_tst/11/console
https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_windows_nt_corefx_jitstressregs2_tst/9/console
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_corefx_jitstressregs0x1000_tst/10/console

They also show failures before the hang.

Sample output:
```
22:52:06 Running: C:\Users\robox\j\workspace\arm_cross_che---eb7b805d\_\fx\bin\tests\Microsoft.Win32.SystemEvents.Tests\netcoreapp-Windows_NT-Release-arm\RunTests.cmd C:\Users\robox\j\workspace\arm_cross_che---eb7b805d\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm
22:52:06 Using C:\Users\robox\j\workspace\arm_cross_che---eb7b805d\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm as the test runtime folder.
22:52:06 Executing in C:\Users\robox\j\workspace\arm_cross_che---eb7b805d\_\fx\bin\tests\Microsoft.Win32.SystemEvents.Tests\netcoreapp-Windows_NT-Release-arm\ 
22:52:06 ----- start 22:52:08.17 ===============  To repro directly: ===================================================== 
22:52:06 pushd C:\Users\robox\j\workspace\arm_cross_che---eb7b805d\_\fx\bin\tests\Microsoft.Win32.SystemEvents.Tests\netcoreapp-Windows_NT-Release-arm\
22:52:06 call C:\Users\robox\j\workspace\arm_cross_che---eb7b805d\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm\dotnet.exe xunit.console.netcore.exe Microsoft.Win32.SystemEvents.Tests.dll  -xml testResults.xml -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonwindowstests  -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing
22:52:06 popd
22:52:06 ===========================================================================================================
22:52:06 
22:52:06 C:\Users\robox\j\workspace\arm_cross_che---eb7b805d\_\fx\bin\tests\Microsoft.Win32.SystemEvents.Tests\netcoreapp-Windows_NT-Release-arm&gt;call C:\Users\robox\j\workspace\arm_cross_che---eb7b805d\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm\dotnet.exe xunit.console.netcore.exe Microsoft.Win32.SystemEvents.Tests.dll  -xml testResults.xml -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonwindowstests  -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing 
22:52:07 xUnit.net console test runner (32-bit .NET Core)
22:52:07 Copyright (C) 2014 Outercurve Foundation.
22:52:07 
22:52:07 Discovering: Microsoft.Win32.SystemEvents.Tests
22:52:09 Discovered:  Microsoft.Win32.SystemEvents.Tests
22:52:10 Starting:    Microsoft.Win32.SystemEvents.Tests
22:52:23 
   Microsoft.Win32.SystemEventsTests.LowMemoryTests.SignalsEventsAsynchronouslyOnMessage [FAIL]
22:52:23       Assert.True() Failure
22:52:23       Expected: True
22:52:23       Actual:   False
22:52:23       Stack Trace:
22:52:24             at Microsoft.Win32.SystemEventsTests.GenericEventTests.SignalsEventsAsynchronouslyOnMessage()
22:52:33    Microsoft.Win32.SystemEventsTests.CreateTimerTests.TimerElapsedSignaled [FAIL]
22:52:33       Assert.True() Failure
22:52:33       Expected: True
22:52:33       Actual:   False
22:52:33       Stack Trace:
22:52:33          D:\j\workspace\arm_cross_che---99792267\_\fx\src\Microsoft.Win32.SystemEvents\tests\SystemEvents.CreateTimer.cs(580): at Microsoft.Win32.SystemEventsTests.CreateTimerTests.TimerElapsedSignaled()
22:52:43    Microsoft.Win32.SystemEventsTests.CreateTimerTests.ConcurrentTimers [FAIL]
22:52:43       Assert.True() Failure
22:52:43       Expected: True
22:52:43       Actual:   False
22:52:43       Stack Trace:
22:52:43          D:\j\workspace\arm_cross_che---99792267\_\fx\src\Microsoft.Win32.SystemEvents\tests\SystemEvents.CreateTimer.cs(1130): at Microsoft.Win32.SystemEventsTests.CreateTimerTests.ConcurrentTimers()
22:52:53    Microsoft.Win32.SystemEventsTests.DisplaySettingsTests.SignalsDisplayEventsAsynchronouslyOnDISPLAYCHANGE [FAIL]
22:52:53       Assert.True() Failure
22:52:53       Expected: True
22:52:53       Actual:   False
22:52:53       Stack Trace:
22:52:53          D:\j\workspace\arm_cross_che---99792267\_\fx\src\Microsoft.Win32.SystemEvents\tests\SystemEvents.DisplaySettings.cs(370): at Microsoft.Win32.SystemEventsTests.DisplaySettingsTests.SignalsDisplayEventsAsynchronouslyOnDISPLAYCHANGE()
22:53:03    Microsoft.Win32.SystemEventsTests.InvokeOnEventsThreadTests.InvokeOnEventsThreadRunsOnSameThreadAsOtherEvents [FAIL]
22:53:03       Assert.True() Failure
22:53:03       Expected: True
22:53:03       Actual:   False
22:53:03       Stack Trace:
22:53:03             at Microsoft.Win32.SystemEventsTests.InvokeOnEventsThreadTests.InvokeOnEventsThreadRunsOnSameThreadAsOtherEvents()
22:53:13    Microsoft.Win32.SystemEventsTests.InvokeOnEventsThreadTests.InvokeOnEventsThreadRunsAsynchronously [FAIL]
22:53:13       Assert.True() Failure
22:53:13       Expected: True
22:53:13       Actual:   False
22:53:13       Stack Trace:
22:53:13          D:\j\workspace\arm_cross_che---99792267\_\fx\src\Microsoft.Win32.SystemEvents\tests\SystemEvents.InvokeOnEventsThread.cs(220): at Microsoft.Win32.SystemEventsTests.InvokeOnEventsThreadTests.InvokeOnEventsThreadRunsAsynchronously()
06:44:16 
Build timed out (after 480 minutes). Marking the build as aborted.
06:44:16 
```
</Description>
    <Title_Description>[arm32/Windows] Hang in corefx Microsoft.Win32.SystemEvents.Tests Many arm32 Windows corefx jobs in the CI are hanging apparently on Microsoft.Win32.SystemEvents.Tests e.g.:

https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_corefx_baseline_tst/11/console
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_corefx_jitstress1_tst/11/console
https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_windows_nt_corefx_jitstressregs2_tst/9/console
https://ci.dot.net/job/dotnet_coreclr/job/master/view/arm/job/jitstress/job/arm_cross_checked_windows_nt_corefx_jitstressregs0x1000_tst/10/console

They also show failures before the hang.

Sample output:
```
22:52:06 Running: C:\Users\robox\j\workspace\arm_cross_che---eb7b805d\_\fx\bin\tests\Microsoft.Win32.SystemEvents.Tests\netcoreapp-Windows_NT-Release-arm\RunTests.cmd C:\Users\robox\j\workspace\arm_cross_che---eb7b805d\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm
22:52:06 Using C:\Users\robox\j\workspace\arm_cross_che---eb7b805d\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm as the test runtime folder.
22:52:06 Executing in C:\Users\robox\j\workspace\arm_cross_che---eb7b805d\_\fx\bin\tests\Microsoft.Win32.SystemEvents.Tests\netcoreapp-Windows_NT-Release-arm\ 
22:52:06 ----- start 22:52:08.17 ===============  To repro directly: ===================================================== 
22:52:06 pushd C:\Users\robox\j\workspace\arm_cross_che---eb7b805d\_\fx\bin\tests\Microsoft.Win32.SystemEvents.Tests\netcoreapp-Windows_NT-Release-arm\
22:52:06 call C:\Users\robox\j\workspace\arm_cross_che---eb7b805d\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm\dotnet.exe xunit.console.netcore.exe Microsoft.Win32.SystemEvents.Tests.dll  -xml testResults.xml -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonwindowstests  -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing
22:52:06 popd
22:52:06 ===========================================================================================================
22:52:06 
22:52:06 C:\Users\robox\j\workspace\arm_cross_che---eb7b805d\_\fx\bin\tests\Microsoft.Win32.SystemEvents.Tests\netcoreapp-Windows_NT-Release-arm&gt;call C:\Users\robox\j\workspace\arm_cross_che---eb7b805d\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-arm\dotnet.exe xunit.console.netcore.exe Microsoft.Win32.SystemEvents.Tests.dll  -xml testResults.xml -notrait Benchmark=true -notrait category=nonnetcoreapptests -notrait category=nonwindowstests  -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing 
22:52:07 xUnit.net console test runner (32-bit .NET Core)
22:52:07 Copyright (C) 2014 Outercurve Foundation.
22:52:07 
22:52:07 Discovering: Microsoft.Win32.SystemEvents.Tests
22:52:09 Discovered:  Microsoft.Win32.SystemEvents.Tests
22:52:10 Starting:    Microsoft.Win32.SystemEvents.Tests
22:52:23 
   Microsoft.Win32.SystemEventsTests.LowMemoryTests.SignalsEventsAsynchronouslyOnMessage [FAIL]
22:52:23       Assert.True() Failure
22:52:23       Expected: True
22:52:23       Actual:   False
22:52:23       Stack Trace:
22:52:24             at Microsoft.Win32.SystemEventsTests.GenericEventTests.SignalsEventsAsynchronouslyOnMessage()
22:52:33    Microsoft.Win32.SystemEventsTests.CreateTimerTests.TimerElapsedSignaled [FAIL]
22:52:33       Assert.True() Failure
22:52:33       Expected: True
22:52:33       Actual:   False
22:52:33       Stack Trace:
22:52:33          D:\j\workspace\arm_cross_che---99792267\_\fx\src\Microsoft.Win32.SystemEvents\tests\SystemEvents.CreateTimer.cs(580): at Microsoft.Win32.SystemEventsTests.CreateTimerTests.TimerElapsedSignaled()
22:52:43    Microsoft.Win32.SystemEventsTests.CreateTimerTests.ConcurrentTimers [FAIL]
22:52:43       Assert.True() Failure
22:52:43       Expected: True
22:52:43       Actual:   False
22:52:43       Stack Trace:
22:52:43          D:\j\workspace\arm_cross_che---99792267\_\fx\src\Microsoft.Win32.SystemEvents\tests\SystemEvents.CreateTimer.cs(1130): at Microsoft.Win32.SystemEventsTests.CreateTimerTests.ConcurrentTimers()
22:52:53    Microsoft.Win32.SystemEventsTests.DisplaySettingsTests.SignalsDisplayEventsAsynchronouslyOnDISPLAYCHANGE [FAIL]
22:52:53       Assert.True() Failure
22:52:53       Expected: True
22:52:53       Actual:   False
22:52:53       Stack Trace:
22:52:53          D:\j\workspace\arm_cross_che---99792267\_\fx\src\Microsoft.Win32.SystemEvents\tests\SystemEvents.DisplaySettings.cs(370): at Microsoft.Win32.SystemEventsTests.DisplaySettingsTests.SignalsDisplayEventsAsynchronouslyOnDISPLAYCHANGE()
22:53:03    Microsoft.Win32.SystemEventsTests.InvokeOnEventsThreadTests.InvokeOnEventsThreadRunsOnSameThreadAsOtherEvents [FAIL]
22:53:03       Assert.True() Failure
22:53:03       Expected: True
22:53:03       Actual:   False
22:53:03       Stack Trace:
22:53:03             at Microsoft.Win32.SystemEventsTests.InvokeOnEventsThreadTests.InvokeOnEventsThreadRunsOnSameThreadAsOtherEvents()
22:53:13    Microsoft.Win32.SystemEventsTests.InvokeOnEventsThreadTests.InvokeOnEventsThreadRunsAsynchronously [FAIL]
22:53:13       Assert.True() Failure
22:53:13       Expected: True
22:53:13       Actual:   False
22:53:13       Stack Trace:
22:53:13          D:\j\workspace\arm_cross_che---99792267\_\fx\src\Microsoft.Win32.SystemEvents\tests\SystemEvents.InvokeOnEventsThread.cs(220): at Microsoft.Win32.SystemEventsTests.InvokeOnEventsThreadTests.InvokeOnEventsThreadRunsAsynchronously()
06:44:16 
Build timed out (after 480 minutes). Marking the build as aborted.
06:44:16 
```
</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>16/04/2018 5:05:27 PM +00:00</CreatedAt>
    <ClosedAt>18/04/2018 1:24:57 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17577</IssueLabelID>
    <Title> Updating the HWIntrinsic APIs to use the unmanaged constraint</Title>
    <Description>FYI. @CarolEidt @fiigii @sdmaclea @eerhardt @jkotas 

This is mostly just for discussion right now since the actual change can't be merged until after the branch opens again.

This is a new (and unshipped API) so back-compat should not be a concern here. However there are some potential other issues with this change:
* The `unmanaged` constraint uses a `modreq` on the constraint there are several known places where tools won't respect this
* The `modreq` also prevents compiler versions prior to C# 7.3 from consuming these APIs.

Some of the benefits are:
* The constraint is more accurate (but still not perfect)
* You can use unsafe operations with these types
  * This includes both unsafe operations that can and cannot be done with `System.Runtime.CompilerServices.Unsafe`
  * Examples of things not possible with a shim API include stackalloc and bypassing definite assignment rules</Description>
    <Title_Description> Updating the HWIntrinsic APIs to use the unmanaged constraint FYI. @CarolEidt @fiigii @sdmaclea @eerhardt @jkotas 

This is mostly just for discussion right now since the actual change can't be merged until after the branch opens again.

This is a new (and unshipped API) so back-compat should not be a concern here. However there are some potential other issues with this change:
* The `unmanaged` constraint uses a `modreq` on the constraint there are several known places where tools won't respect this
* The `modreq` also prevents compiler versions prior to C# 7.3 from consuming these APIs.

Some of the benefits are:
* The constraint is more accurate (but still not perfect)
* You can use unsafe operations with these types
  * This includes both unsafe operations that can and cannot be done with `System.Runtime.CompilerServices.Unsafe`
  * Examples of things not possible with a shim API include stackalloc and bypassing definite assignment rules</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>CarolEidt</Assignee>
    <CreatedAt>15/04/2018 6:03:38 PM +00:00</CreatedAt>
    <ClosedAt>25/05/2018 4:16:43 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17576</IssueLabelID>
    <Title>Port JIT and GC to C#</Title>
    <Description>Is it possible?</Description>
    <Title_Description>Port JIT and GC to C# Is it possible?</Title_Description>
    <Label>Design Discussion</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>15/04/2018 8:52:35 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17575</IssueLabelID>
    <Title>[Arm64] Disable SIMD in crossgen (added as part of #14633)</Title>
    <Description>Disable SIMD feature in crossgen for ARM64 for now as decided in #17543

This will let the following arm64 crossgen tests to pass. (#16541 #16542)</Description>
    <Title_Description>[Arm64] Disable SIMD in crossgen (added as part of #14633) Disable SIMD feature in crossgen for ARM64 for now as decided in #17543

This will let the following arm64 crossgen tests to pass. (#16541 #16542)</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>dotnet-bot</Assignee>
    <CreatedAt>15/04/2018 4:42:59 AM +00:00</CreatedAt>
    <ClosedAt>17/04/2018 1:45:18 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17574</IssueLabelID>
    <Title>[arm64] Assertion failed 'varDsc-&gt;lvOnFrame &amp;&amp; !varDsc-&gt;lvRegister'</Title>
    <Description>x64_arm64_altjit corefx assertion:

https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64_arm64_altjit/job/jitstress/job/x64_arm64_altjit_checked_windows_nt_corefx_baseline/157/consoleFull#-102414311f66db340-b3cd-4e23-8190-9b52cb916333

```
12:06:47   ===========================================================================================================
12:06:47   xUnit.net console test runner (64-bit .NET Core)
12:06:47   Copyright (C) 2014 Outercurve Foundation.
12:06:47   
12:06:48   Discovering: System.ValueTuple.Tests
12:06:50   Discovered:  System.ValueTuple.Tests
12:06:51   Starting:    System.ValueTuple.Tests
12:06:56   
12:06:56 
  Assert failure(PID 5032 [0x000013a8] Thread: 13340 [0x341c]): Assertion failed 'varDsc-&gt;lvOnFrame &amp;&amp; !varDsc-&gt;lvRegister' in 'System.Tests.ValueTupleTests:LongTuplesWithNull()' (IL size 741)
12:06:56   
12:06:56       File: d:\j\workspace\x64_arm64_alt---734a66f6\src\jit\codegenarmarch.cpp Line: 752
12:06:56       Image: D:\j\workspace\x64_arm64_alt---734a66f6\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-x64\dotnet.exe
12:06:56   
12:06:56   ----- end 12:06:56.86 ----- exit code 123456789 ----------------------------------------------------------
12:06:56 D:\j\workspace\x64_arm64_alt---734a66f6\_\fx\Tools\tests.targets(4925): warning MSB3073: The command "D:\j\workspace\x64_arm64_alt---734a66f6\_\fx\bin/tests/System.ValueTuple.Tests/netcoreapp-Windows_NT-Release-x64//RunTests.cmd D:\j\workspace\x64_arm64_alt---734a66f6\_\fx\bin/testhost/netcoreapp-Windows_NT-Release-x64/" exited with code 123456789. [D:\j\workspace\x64_arm64_alt---734a66f6\_\fx\src\System.ValueTuple\tests\System.ValueTuple.Tests.csproj]
12:06:56 
D:\j\workspace\x64_arm64_alt---734a66f6\_\fx\Tools\tests.targets(5005): error : One or more tests failed while running tests from 'System.ValueTuple.Tests' please check D:\j\workspace\x64_arm64_alt---734a66f6\_\fx\bin/tests/System.ValueTuple.Tests/netcoreapp-Windows_NT-Release-x64/testResults.xml for details! [D:\j\workspace\x64_arm64_alt---734a66f6\_\fx\src\System.ValueTuple\tests\System.ValueTuple.Tests.csproj]
```

also: https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64_arm64_altjit/job/jitstress/job/x64_arm64_altjit_checked_windows_nt_corefx_jitstress2/154/
https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64_arm64_altjit/job/jitstress/job/x64_arm64_altjit_checked_windows_nt_corefx_jitstressregs3/158/
https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64_arm64_altjit/job/jitstress/job/x64_arm64_altjit_checked_windows_nt_corefx_jitstressregs4/156/
https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64_arm64_altjit/job/jitstress/job/x64_arm64_altjit_checked_windows_nt_corefx_jitstressregs8/155/

and probably others.

</Description>
    <Title_Description>[arm64] Assertion failed 'varDsc-&gt;lvOnFrame &amp;&amp; !varDsc-&gt;lvRegister' x64_arm64_altjit corefx assertion:

https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64_arm64_altjit/job/jitstress/job/x64_arm64_altjit_checked_windows_nt_corefx_baseline/157/consoleFull#-102414311f66db340-b3cd-4e23-8190-9b52cb916333

```
12:06:47   ===========================================================================================================
12:06:47   xUnit.net console test runner (64-bit .NET Core)
12:06:47   Copyright (C) 2014 Outercurve Foundation.
12:06:47   
12:06:48   Discovering: System.ValueTuple.Tests
12:06:50   Discovered:  System.ValueTuple.Tests
12:06:51   Starting:    System.ValueTuple.Tests
12:06:56   
12:06:56 
  Assert failure(PID 5032 [0x000013a8] Thread: 13340 [0x341c]): Assertion failed 'varDsc-&gt;lvOnFrame &amp;&amp; !varDsc-&gt;lvRegister' in 'System.Tests.ValueTupleTests:LongTuplesWithNull()' (IL size 741)
12:06:56   
12:06:56       File: d:\j\workspace\x64_arm64_alt---734a66f6\src\jit\codegenarmarch.cpp Line: 752
12:06:56       Image: D:\j\workspace\x64_arm64_alt---734a66f6\_\fx\bin\testhost\netcoreapp-Windows_NT-Release-x64\dotnet.exe
12:06:56   
12:06:56   ----- end 12:06:56.86 ----- exit code 123456789 ----------------------------------------------------------
12:06:56 D:\j\workspace\x64_arm64_alt---734a66f6\_\fx\Tools\tests.targets(4925): warning MSB3073: The command "D:\j\workspace\x64_arm64_alt---734a66f6\_\fx\bin/tests/System.ValueTuple.Tests/netcoreapp-Windows_NT-Release-x64//RunTests.cmd D:\j\workspace\x64_arm64_alt---734a66f6\_\fx\bin/testhost/netcoreapp-Windows_NT-Release-x64/" exited with code 123456789. [D:\j\workspace\x64_arm64_alt---734a66f6\_\fx\src\System.ValueTuple\tests\System.ValueTuple.Tests.csproj]
12:06:56 
D:\j\workspace\x64_arm64_alt---734a66f6\_\fx\Tools\tests.targets(5005): error : One or more tests failed while running tests from 'System.ValueTuple.Tests' please check D:\j\workspace\x64_arm64_alt---734a66f6\_\fx\bin/tests/System.ValueTuple.Tests/netcoreapp-Windows_NT-Release-x64/testResults.xml for details! [D:\j\workspace\x64_arm64_alt---734a66f6\_\fx\src\System.ValueTuple\tests\System.ValueTuple.Tests.csproj]
```

also: https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64_arm64_altjit/job/jitstress/job/x64_arm64_altjit_checked_windows_nt_corefx_jitstress2/154/
https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64_arm64_altjit/job/jitstress/job/x64_arm64_altjit_checked_windows_nt_corefx_jitstressregs3/158/
https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64_arm64_altjit/job/jitstress/job/x64_arm64_altjit_checked_windows_nt_corefx_jitstressregs4/156/
https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64_arm64_altjit/job/jitstress/job/x64_arm64_altjit_checked_windows_nt_corefx_jitstressregs8/155/

and probably others.

</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>14/04/2018 10:11:18 PM +00:00</CreatedAt>
    <ClosedAt>15/04/2018 3:49:26 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17573</IssueLabelID>
    <Title>[arm64] Assertion failed '(candidates &amp; allRegs(srcInterval-&gt;registerType)) != 0'</Title>
    <Description>x64_arm64_altjit job failures:

https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64_arm64_altjit/job/jitstress/job/x64_arm64_altjit_checked_windows_nt_jitstress1/
https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64_arm64_altjit/job/jitstress/job/x64_arm64_altjit_checked_windows_nt_jitstress2/

```
D:\j\workspace\x64_arm64_alt---733f8d21\bin\tests\Windows_NT.x64.Checked\TestWrappers\JIT.HardwareIntrinsics\JIT.HardwareIntrinsics.XUnitWrapper.cs(247): error : JIT_HardwareIntrinsics._Arm64_Simd_Simd_._Arm64_Simd_Simd_cmd [FAIL] [D:\j\workspace\x64_arm64_alt---733f8d21\tests\runtest.proj]
07:29:17         
07:29:17 
        Assert failure(PID 6328 [0x000018b8] Thread: 1960 [0x07a8]): Assertion failed '(candidates &amp; allRegs(srcInterval-&gt;registerType)) != 0' in '&lt;&gt;c:&lt;TestAdd&gt;b__21_40(structstruct):struct:this' (IL size 8)
07:29:17         
07:29:17             File: d:\j\workspace\x64_arm64_alt---733f8d21\src\jit\lsrabuild.cpp Line: 1577
07:29:17             Image: D:\j\workspace\x64_arm64_alt---733f8d21\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root\CoreRun.exe
07:29:17         
07:29:17         
07:29:17   
07:29:17   Return code:      1
07:29:17   Raw output file:      D:\j\workspace\x64_arm64_alt---733f8d21\bin\tests\Windows_NT.x64.Checked\Reports\JIT.HardwareIntrinsics\Arm64\Simd\Simd.output.txt
07:29:17   Raw output:
07:29:17   BEGIN EXECUTION
07:29:17          "D:\j\workspace\x64_arm64_alt---733f8d21\tests\..\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root\corerun.exe" Simd.exe 
07:29:17         System.Runtime.Intrinsics.Arm.Arm64.Simd.IsSupported = False
07:29:17         Using default data set
07:29:17         TestAbs passed
07:29:17         Expected: 100
07:29:17         Actual: 123456789
07:29:17         END EXECUTION - FAILED
07:29:17         FAILED
07:29:17         Test Harness Exitcode is : 1
07:29:17         
07:29:17   To run the test:
07:29:17   &gt; set CORE_ROOT=D:\j\workspace\x64_arm64_alt---733f8d21\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root
07:29:17   &gt; D:\j\workspace\x64_arm64_alt---733f8d21\bin\tests\Windows_NT.x64.Checked\JIT\HardwareIntrinsics\Arm64\Simd\Simd.cmd
07:29:17   
07:29:17         Expected: True
07:29:17         Actual:   False
07:29:17           D:\j\workspace\x64_arm64_alt---733f8d21\bin\tests\Windows_NT.x64.Checked\TestWrappers\JIT.HardwareIntrinsics\JIT.HardwareIntrinsics.XUnitWrapper.cs(2470): at JIT_HardwareIntrinsics._Arm64_Simd_Simd_._Arm64_Simd_Simd_cmd()
```
</Description>
    <Title_Description>[arm64] Assertion failed '(candidates &amp; allRegs(srcInterval-&gt;registerType)) != 0' x64_arm64_altjit job failures:

https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64_arm64_altjit/job/jitstress/job/x64_arm64_altjit_checked_windows_nt_jitstress1/
https://ci.dot.net/job/dotnet_coreclr/job/master/view/x64_arm64_altjit/job/jitstress/job/x64_arm64_altjit_checked_windows_nt_jitstress2/

```
D:\j\workspace\x64_arm64_alt---733f8d21\bin\tests\Windows_NT.x64.Checked\TestWrappers\JIT.HardwareIntrinsics\JIT.HardwareIntrinsics.XUnitWrapper.cs(247): error : JIT_HardwareIntrinsics._Arm64_Simd_Simd_._Arm64_Simd_Simd_cmd [FAIL] [D:\j\workspace\x64_arm64_alt---733f8d21\tests\runtest.proj]
07:29:17         
07:29:17 
        Assert failure(PID 6328 [0x000018b8] Thread: 1960 [0x07a8]): Assertion failed '(candidates &amp; allRegs(srcInterval-&gt;registerType)) != 0' in '&lt;&gt;c:&lt;TestAdd&gt;b__21_40(structstruct):struct:this' (IL size 8)
07:29:17         
07:29:17             File: d:\j\workspace\x64_arm64_alt---733f8d21\src\jit\lsrabuild.cpp Line: 1577
07:29:17             Image: D:\j\workspace\x64_arm64_alt---733f8d21\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root\CoreRun.exe
07:29:17         
07:29:17         
07:29:17   
07:29:17   Return code:      1
07:29:17   Raw output file:      D:\j\workspace\x64_arm64_alt---733f8d21\bin\tests\Windows_NT.x64.Checked\Reports\JIT.HardwareIntrinsics\Arm64\Simd\Simd.output.txt
07:29:17   Raw output:
07:29:17   BEGIN EXECUTION
07:29:17          "D:\j\workspace\x64_arm64_alt---733f8d21\tests\..\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root\corerun.exe" Simd.exe 
07:29:17         System.Runtime.Intrinsics.Arm.Arm64.Simd.IsSupported = False
07:29:17         Using default data set
07:29:17         TestAbs passed
07:29:17         Expected: 100
07:29:17         Actual: 123456789
07:29:17         END EXECUTION - FAILED
07:29:17         FAILED
07:29:17         Test Harness Exitcode is : 1
07:29:17         
07:29:17   To run the test:
07:29:17   &gt; set CORE_ROOT=D:\j\workspace\x64_arm64_alt---733f8d21\bin\tests\Windows_NT.x64.Checked\Tests\Core_Root
07:29:17   &gt; D:\j\workspace\x64_arm64_alt---733f8d21\bin\tests\Windows_NT.x64.Checked\JIT\HardwareIntrinsics\Arm64\Simd\Simd.cmd
07:29:17   
07:29:17         Expected: True
07:29:17         Actual:   False
07:29:17           D:\j\workspace\x64_arm64_alt---733f8d21\bin\tests\Windows_NT.x64.Checked\TestWrappers\JIT.HardwareIntrinsics\JIT.HardwareIntrinsics.XUnitWrapper.cs(2470): at JIT_HardwareIntrinsics._Arm64_Simd_Simd_._Arm64_Simd_Simd_cmd()
```
</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>BruceForstall</Assignee>
    <CreatedAt>14/04/2018 10:00:32 PM +00:00</CreatedAt>
    <ClosedAt>15/04/2018 3:50:13 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17572</IssueLabelID>
    <Title>[arm32/Ubuntu] Enable R2R jobs as periodic/cron jobs</Title>
    <Description>The Ubuntu arm32 R2R jobs exist but are not scheduled periodically. Now that they work they should be added to the set of periodic jobs.
</Description>
    <Title_Description>[arm32/Ubuntu] Enable R2R jobs as periodic/cron jobs The Ubuntu arm32 R2R jobs exist but are not scheduled periodically. Now that they work they should be added to the set of periodic jobs.
</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>BruceForstall</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17571</IssueLabelID>
    <Title>Enable `FEATURE_PREVENT_BAD_BYREFS` for all platforms and remove ifdefs</Title>
    <Description>https://github.com/dotnet/coreclr/pull/17524 introduced the `FEATURE_PREVENT_BAD_BYREFS` but only for `_TARGET_ARM_` to avoid perturbing other platforms for .NET Core 2.1.

Remove this `#ifdef` and make the code all-platform after testing all platforms and investigating the (significant number of) asm diffs.


category:correctness
theme:jit-coding-style
skill-level:intermediate
cost:small</Description>
    <Title_Description>Enable `FEATURE_PREVENT_BAD_BYREFS` for all platforms, and remove ifdefs https://github.com/dotnet/coreclr/pull/17524 introduced the `FEATURE_PREVENT_BAD_BYREFS` but only for `_TARGET_ARM_` to avoid perturbing other platforms for .NET Core 2.1.

Remove this `#ifdef` and make the code all-platform after testing all platforms and investigating the (significant number of) asm diffs.


category:correctness
theme:jit-coding-style
skill-level:intermediate
cost:small</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>BruceForstall</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17570</IssueLabelID>
    <Title>Windows ARM32 GCStress=0xc failures in baseservices\threading\generics\WaitCallback thread tests</Title>
    <Description>The `baseservices\threading\generics\WaitCallback` thread tests consistently fail in Windows ARM32 GCStress=0xc runs although it is not always the same set of tests which fail (there are many different "thread" tests). E.g.:

https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_windows_nt_gcstress0xc_tst_prtest/16/artifact/bin/tests/Windows_NT.arm.Checked/Smarty.run.0/Smarty.0.fail.smrt/*view*/
```
Tests.lst=thread23.cmd_867   Smrt00000001  # baseservices\threading\generics\WaitCallback\thread23\thread23.cmd  CATS: EXPECTED_PASS;Pri1
Tests.lst=thread20.cmd_7499   Smrt00000001  # baseservices\threading\generics\WaitCallback\thread20\thread20.cmd  CATS: EXPECTED_PASS;Pri1
Tests.lst=thread22.cmd_10415   Smrt00000001  # baseservices\threading\generics\WaitCallback\thread22\thread22.cmd  CATS: EXPECTED_PASS;Pri1
```

https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_windows_nt_gcstress0xc_tst/19/artifact/bin/tests/Windows_NT.arm.Checked/Smarty.run.0/Smarty.0.fail.smrt/*view*/
```
Tests.lst=thread06.cmd_2550   Smrt00000001  # baseservices\threading\generics\WaitCallback\thread06\thread06.cmd  CATS: EXPECTED_PASS;Pri1
Tests.lst=thread18.cmd_2551   Smrt00000001  # baseservices\threading\generics\WaitCallback\thread18\thread18.cmd  CATS: EXPECTED_PASS;Pri1
```

https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_windows_nt_gcstress0xc_tst/18/artifact/bin/tests/Windows_NT.arm.Checked/Smarty.run.0/Smarty.0.fail.smrt/*view*/
```
Tests.lst=thread24.cmd_1484   Smrt00000001  # baseservices\threading\generics\WaitCallback\thread24\thread24.cmd  CATS: EXPECTED_PASS;Pri1
Tests.lst=thread22.cmd_10415   Smrt00000001  # baseservices\threading\generics\WaitCallback\thread22\thread22.cmd  CATS: EXPECTED_PASS;Pri1
```

https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_windows_nt_gcstress0xc_tst/17/artifact/bin/tests/Windows_NT.arm.Checked/Smarty.run.0/Smarty.0.fail.smrt/*view*/
```
Tests.lst=thread19.cmd_1070   Smrt00000001  # baseservices\threading\generics\WaitCallback\thread19\thread19.cmd  CATS: EXPECTED_PASS;Pri1
Tests.lst=thread24.cmd_1484   Smrt00000001  # baseservices\threading\generics\WaitCallback\thread24\thread24.cmd  CATS: EXPECTED_PASS;Pri1
Tests.lst=thread06.cmd_2550   Smrt00000001  # baseservices\threading\generics\WaitCallback\thread06\thread06.cmd  CATS: EXPECTED_PASS;Pri1
Tests.lst=thread30.cmd_9020   Smrt00000001  # baseservices\threading\generics\WaitCallback\thread30\thread30.cmd  CATS: EXPECTED_PASS;Pri1
```
</Description>
    <Title_Description>Windows ARM32 GCStress=0xc failures in baseservices\threading\generics\WaitCallback thread tests The `baseservices\threading\generics\WaitCallback` thread tests consistently fail in Windows ARM32 GCStress=0xc runs although it is not always the same set of tests which fail (there are many different "thread" tests). E.g.:

https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_windows_nt_gcstress0xc_tst_prtest/16/artifact/bin/tests/Windows_NT.arm.Checked/Smarty.run.0/Smarty.0.fail.smrt/*view*/
```
Tests.lst=thread23.cmd_867   Smrt00000001  # baseservices\threading\generics\WaitCallback\thread23\thread23.cmd  CATS: EXPECTED_PASS;Pri1
Tests.lst=thread20.cmd_7499   Smrt00000001  # baseservices\threading\generics\WaitCallback\thread20\thread20.cmd  CATS: EXPECTED_PASS;Pri1
Tests.lst=thread22.cmd_10415   Smrt00000001  # baseservices\threading\generics\WaitCallback\thread22\thread22.cmd  CATS: EXPECTED_PASS;Pri1
```

https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_windows_nt_gcstress0xc_tst/19/artifact/bin/tests/Windows_NT.arm.Checked/Smarty.run.0/Smarty.0.fail.smrt/*view*/
```
Tests.lst=thread06.cmd_2550   Smrt00000001  # baseservices\threading\generics\WaitCallback\thread06\thread06.cmd  CATS: EXPECTED_PASS;Pri1
Tests.lst=thread18.cmd_2551   Smrt00000001  # baseservices\threading\generics\WaitCallback\thread18\thread18.cmd  CATS: EXPECTED_PASS;Pri1
```

https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_windows_nt_gcstress0xc_tst/18/artifact/bin/tests/Windows_NT.arm.Checked/Smarty.run.0/Smarty.0.fail.smrt/*view*/
```
Tests.lst=thread24.cmd_1484   Smrt00000001  # baseservices\threading\generics\WaitCallback\thread24\thread24.cmd  CATS: EXPECTED_PASS;Pri1
Tests.lst=thread22.cmd_10415   Smrt00000001  # baseservices\threading\generics\WaitCallback\thread22\thread22.cmd  CATS: EXPECTED_PASS;Pri1
```

https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_windows_nt_gcstress0xc_tst/17/artifact/bin/tests/Windows_NT.arm.Checked/Smarty.run.0/Smarty.0.fail.smrt/*view*/
```
Tests.lst=thread19.cmd_1070   Smrt00000001  # baseservices\threading\generics\WaitCallback\thread19\thread19.cmd  CATS: EXPECTED_PASS;Pri1
Tests.lst=thread24.cmd_1484   Smrt00000001  # baseservices\threading\generics\WaitCallback\thread24\thread24.cmd  CATS: EXPECTED_PASS;Pri1
Tests.lst=thread06.cmd_2550   Smrt00000001  # baseservices\threading\generics\WaitCallback\thread06\thread06.cmd  CATS: EXPECTED_PASS;Pri1
Tests.lst=thread30.cmd_9020   Smrt00000001  # baseservices\threading\generics\WaitCallback\thread30\thread30.cmd  CATS: EXPECTED_PASS;Pri1
```
</Title_Description>
    <Label>GCStress</Label>
    <Assignee>echesakovMSFT</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17569</IssueLabelID>
    <Title>Don't use runtesttilstable script for Ubuntu arm jobs</Title>
    <Description>Testing in #17274 </Description>
    <Title_Description>Don't use runtesttilstable script for Ubuntu arm jobs Testing in #17274 </Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>echesakovMSFT</Assignee>
    <CreatedAt>14/04/2018 4:10:45 PM +00:00</CreatedAt>
    <ClosedAt>14/04/2018 8:30:22 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17568</IssueLabelID>
    <Title>Revisit the handling of SIMD types during crossgen</Title>
    <Description>See the comments on PR #17543.

During crossgen the JIT sets `featureSIMD` to false but continues to generate code for calls to fixed-size SIMD types. While this is correct it means that any use of these types in crossgen'd code is quite inefficient.

On x86/x64 this may have some actual benefit due to the fact that we don't know whether the JIT'd code that is generated at runtime will use AVX or SSE encodings. However this is somewhat inconsistent as we generate SSE encodings for other operations.

On Arm64 a change was made (#14633) to enable SIMD during crossgen. However the importing of static field helpers is not calling `impNormStructType()` which led to #16542. Adding a call to  `impNormStructType()` here: https://github.com/dotnet/coreclr/blob/master/src/jit/importer.cpp#L13570 when `lclType == TYP_STRUCT` seemed to fix that issue.

We should consider whether to add support for fixed- or known- size SIMD types during crossgen across architectures.

category:cq
theme:vector-codegen
skill-level:intermediate
cost:small</Description>
    <Title_Description>Revisit the handling of SIMD types during crossgen See the comments on PR #17543.

During crossgen the JIT sets `featureSIMD` to false but continues to generate code for calls to fixed-size SIMD types. While this is correct it means that any use of these types in crossgen'd code is quite inefficient.

On x86/x64 this may have some actual benefit due to the fact that we don't know whether the JIT'd code that is generated at runtime will use AVX or SSE encodings. However this is somewhat inconsistent as we generate SSE encodings for other operations.

On Arm64 a change was made (#14633) to enable SIMD during crossgen. However the importing of static field helpers is not calling `impNormStructType()` which led to #16542. Adding a call to  `impNormStructType()` here: https://github.com/dotnet/coreclr/blob/master/src/jit/importer.cpp#L13570 when `lclType == TYP_STRUCT` seemed to fix that issue.

We should consider whether to add support for fixed- or known- size SIMD types during crossgen across architectures.

category:cq
theme:vector-codegen
skill-level:intermediate
cost:small</Title_Description>
    <Label>Design Discussion</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17567</IssueLabelID>
    <Title>[Arm64] Add full barrier after locking operations</Title>
    <Description>Per discussion with @kouvel in #17508 Interlocked operations should all act as a fully ordering barrier.

Fixes #14346 because we will have have come to a consensus

@jkotas @kouvel @stephentoub @tarekgh 
</Description>
    <Title_Description>[Arm64] Add full barrier after locking operations Per discussion with @kouvel in #17508 Interlocked operations should all act as a fully ordering barrier.

Fixes #14346 because we will have have come to a consensus

@jkotas @kouvel @stephentoub @tarekgh 
</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>kouvel</Assignee>
    <CreatedAt>14/04/2018 9:52:21 AM +00:00</CreatedAt>
    <ClosedAt>15/04/2018 9:36:05 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17566</IssueLabelID>
    <Title>Suprising sliced ReadOnlySpan Equality with strings</Title>
    <Description>If a ``ReadOnlySpan`` is sliced the it does not equal an "equal" (in sense of char by char) string anymore but for an unsliced ``ReadOnlySpan`` it does equal it.
As ``Slice`` can be used for ``SubString`` like described in @stephentoub's article https://msdn.microsoft.com/en-us/magazine/mt814808.aspx this is a bit unexpected.

Repro
```csharp
string fullString = "Hello World and Universe";
ReadOnlySpan&lt;char&gt; span = fullString;
string partialString = "Hello World";
ReadOnlySpan&lt;char&gt; partialSpan = span.Slice(0 11); 

Console.WriteLine(span == fullString);
Console.WriteLine(span.ToString() == fullString);

Console.WriteLine(partialSpan == partialString);
Console.WriteLine(partialSpan.ToString() == partialString);
```
The output is:
```ini
True
True
False
True
```
&lt;details&gt;

```ini
.NET Core SDK (gemäß "global.json"):
 Version:   2.1.300-preview2-008530
 Commit:    822ae6d43a

Laufzeitumgebung:
 OS Name:     Windows
 OS Version:  10.0.17133
 OS Platform: Windows
 RID:         win10-x64
 Base Path:   C:\Program Files\dotnet\sdk\2.1.300-preview2-008530\

Host (useful for support):
  Version: 2.1.0-preview3-26411-01
  Commit:  38de1bfbb8

.NET Core SDKs installed:
  1.0.2 [C:\Program Files\dotnet\sdk]
  1.0.3 [C:\Program Files\dotnet\sdk]
  1.0.4 [C:\Program Files\dotnet\sdk]
  1.1.0 [C:\Program Files\dotnet\sdk]
  2.0.0 [C:\Program Files\dotnet\sdk]
  2.0.2 [C:\Program Files\dotnet\sdk]
  2.0.3 [C:\Program Files\dotnet\sdk]
  2.1.104 [C:\Program Files\dotnet\sdk]
  2.1.300-preview2-008530 [C:\Program Files\dotnet\sdk]

.NET Core runtimes installed:
  Microsoft.AspNetCore.All 2.1.0-preview2-final [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All]
  Microsoft.AspNetCore.App 2.1.0-preview2-final [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]
  Microsoft.NETCore.App 1.0.4 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 1.0.5 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 1.1.1 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 1.1.2 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.0.0 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.0.3 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.0.6 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.1.0-preview2-26406-04 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.1.0-preview3-26411-01 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
```
&lt;/details&gt;</Description>
    <Title_Description>Suprising sliced ReadOnlySpan Equality with strings If a ``ReadOnlySpan`` is sliced the it does not equal an "equal" (in sense of char by char) string anymore but for an unsliced ``ReadOnlySpan`` it does equal it.
As ``Slice`` can be used for ``SubString`` like described in @stephentoub's article https://msdn.microsoft.com/en-us/magazine/mt814808.aspx this is a bit unexpected.

Repro
```csharp
string fullString = "Hello World and Universe";
ReadOnlySpan&lt;char&gt; span = fullString;
string partialString = "Hello World";
ReadOnlySpan&lt;char&gt; partialSpan = span.Slice(0 11); 

Console.WriteLine(span == fullString);
Console.WriteLine(span.ToString() == fullString);

Console.WriteLine(partialSpan == partialString);
Console.WriteLine(partialSpan.ToString() == partialString);
```
The output is:
```ini
True
True
False
True
```
&lt;details&gt;

```ini
.NET Core SDK (gemäß "global.json"):
 Version:   2.1.300-preview2-008530
 Commit:    822ae6d43a

Laufzeitumgebung:
 OS Name:     Windows
 OS Version:  10.0.17133
 OS Platform: Windows
 RID:         win10-x64
 Base Path:   C:\Program Files\dotnet\sdk\2.1.300-preview2-008530\

Host (useful for support):
  Version: 2.1.0-preview3-26411-01
  Commit:  38de1bfbb8

.NET Core SDKs installed:
  1.0.2 [C:\Program Files\dotnet\sdk]
  1.0.3 [C:\Program Files\dotnet\sdk]
  1.0.4 [C:\Program Files\dotnet\sdk]
  1.1.0 [C:\Program Files\dotnet\sdk]
  2.0.0 [C:\Program Files\dotnet\sdk]
  2.0.2 [C:\Program Files\dotnet\sdk]
  2.0.3 [C:\Program Files\dotnet\sdk]
  2.1.104 [C:\Program Files\dotnet\sdk]
  2.1.300-preview2-008530 [C:\Program Files\dotnet\sdk]

.NET Core runtimes installed:
  Microsoft.AspNetCore.All 2.1.0-preview2-final [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All]
  Microsoft.AspNetCore.App 2.1.0-preview2-final [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]
  Microsoft.NETCore.App 1.0.4 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 1.0.5 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 1.1.1 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 1.1.2 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.0.0 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.0.3 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.0.6 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.1.0-preview2-26406-04 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.1.0-preview3-26411-01 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
```
&lt;/details&gt;</Title_Description>
    <Label>area-System.Memory</Label>
    <Assignee>stephentoub</Assignee>
    <CreatedAt>14/04/2018 8:09:07 AM +00:00</CreatedAt>
    <ClosedAt>20/04/2018 2:34:55 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17565</IssueLabelID>
    <Title>[Linux/arm] Crossgen SlowTailCallArgs assert failure</Title>
    <Description>Fails here [Ubuntu arm Cross Checked r2r Build and Test](https://ci.dot.net/job/dotnet_coreclr/job/master/job/arm_cross_checked_ubuntu_r2r_tst_prtest/2/consoleText) with the following output
```       
               BEGIN EXECUTION
               in takeLock
               /ssd/j/workspace/dotnet_coreclr/master/arm_cross_checked_ubuntu_r2r_tst_prtest/bin/tests/Linux.arm.Checked/Tests/Core_Root/crossgen /Platform_Assemblies_Paths /ssd/j/workspace/dotnet_coreclr/master/arm_cross_checked_ubuntu_r2r_tst_prtest/bin/tests/Linux.arm.Checked/Tests/Core_Root:/ssd/j/workspace/dotnet_coreclr/master/arm_cross_checked_ubuntu_r2r_tst_prtest/bin/tests/Linux.arm.Checked/CoreMangLib/system/span/SlowTailCallArgs/IL:/ssd/j/workspace/dotnet_coreclr/master/arm_cross_checked_ubuntu_r2r_tst_prtest/bin/tests/Linux.arm.Checked/CoreMangLib/system/span/SlowTailCallArgs /in SlowTailCallArgs.org /out SlowTailCallArgs.exe
               
               Assert failure(PID 15567 [0x00003ccf] Thread: 15567 [0x3ccf]): *ppObj == NULL
                   File: /mnt/j/workspace/dotnet_coreclr/master/arm_cross_checked_ubuntu_prtest/src/vm/compile.cpp Line: 927
                   Image: /ssd/j/workspace/dotnet_coreclr/master/arm_cross_checked_ubuntu_r2r_tst_prtest/bin/tests/Linux.arm.Checked/Tests/Core_Root/crossgen
               
               Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0
               Copyright (c) Microsoft Corporation.  All rights reserved.
               
               ./SlowTailCallArgs.sh: line 163: 15567 Aborted                 $_DebuggerFullPath \"$CORE_ROOT/crossgen\" /Platform_Assemblies_Paths $CORE_ROOT:$PWD/IL:$PWD /in SlowTailCallArgs.org /out SlowTailCallArgs.exe
               Crossgen failed with exitcode: 134
               in ReleaseLock
```
</Description>
    <Title_Description>[Linux/arm] Crossgen SlowTailCallArgs assert failure Fails here [Ubuntu arm Cross Checked r2r Build and Test](https://ci.dot.net/job/dotnet_coreclr/job/master/job/arm_cross_checked_ubuntu_r2r_tst_prtest/2/consoleText) with the following output
```       
               BEGIN EXECUTION
               in takeLock
               /ssd/j/workspace/dotnet_coreclr/master/arm_cross_checked_ubuntu_r2r_tst_prtest/bin/tests/Linux.arm.Checked/Tests/Core_Root/crossgen /Platform_Assemblies_Paths /ssd/j/workspace/dotnet_coreclr/master/arm_cross_checked_ubuntu_r2r_tst_prtest/bin/tests/Linux.arm.Checked/Tests/Core_Root:/ssd/j/workspace/dotnet_coreclr/master/arm_cross_checked_ubuntu_r2r_tst_prtest/bin/tests/Linux.arm.Checked/CoreMangLib/system/span/SlowTailCallArgs/IL:/ssd/j/workspace/dotnet_coreclr/master/arm_cross_checked_ubuntu_r2r_tst_prtest/bin/tests/Linux.arm.Checked/CoreMangLib/system/span/SlowTailCallArgs /in SlowTailCallArgs.org /out SlowTailCallArgs.exe
               
               Assert failure(PID 15567 [0x00003ccf] Thread: 15567 [0x3ccf]): *ppObj == NULL
                   File: /mnt/j/workspace/dotnet_coreclr/master/arm_cross_checked_ubuntu_prtest/src/vm/compile.cpp Line: 927
                   Image: /ssd/j/workspace/dotnet_coreclr/master/arm_cross_checked_ubuntu_r2r_tst_prtest/bin/tests/Linux.arm.Checked/Tests/Core_Root/crossgen
               
               Microsoft (R) CoreCLR Native Image Generator - Version 4.5.30319.0
               Copyright (c) Microsoft Corporation.  All rights reserved.
               
               ./SlowTailCallArgs.sh: line 163: 15567 Aborted                 $_DebuggerFullPath \"$CORE_ROOT/crossgen\" /Platform_Assemblies_Paths $CORE_ROOT:$PWD/IL:$PWD /in SlowTailCallArgs.org /out SlowTailCallArgs.exe
               Crossgen failed with exitcode: 134
               in ReleaseLock
```
</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>janvorli</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17564</IssueLabelID>
    <Title>[Arm64] Harder Acquire Release cases</Title>
    <Description>#12087 implemented the simplest volatile cases as loadAcquire and storeRelease.  There is room for a more complete set to be implemented.  Signed load cases is one example.

category:cq
theme:barriers
skill-level:expert
cost:medium</Description>
    <Title_Description>[Arm64] Harder Acquire Release cases #12087 implemented the simplest volatile cases as loadAcquire and storeRelease.  There is room for a more complete set to be implemented.  Signed load cases is one example.

category:cq
theme:barriers
skill-level:expert
cost:medium</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>14/04/2018 6:29:16 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17563</IssueLabelID>
    <Title>Optimize ThreadPool WorkStealingQueue</Title>
    <Description>While analyzing for #17508 it became apparent that the use of `volatile` in `WorkStealingQueue` was negatively impacting performance

For example `LocalPop()` 
+ makes two volatile reads in its early out case.  Only one is required
+ makes seven volatile reads in its fast path.  Only three are required

`LocalPush()` has similar issues.

`CanSteal` is making two volatile reads.  Packing head/tail in one int64 could allow this to be a single volatile read.  This would also allow `TrySteal()` to be lockless.
</Description>
    <Title_Description>Optimize ThreadPool WorkStealingQueue While analyzing for #17508 it became apparent that the use of `volatile` in `WorkStealingQueue` was negatively impacting performance

For example `LocalPop()` 
+ makes two volatile reads in its early out case.  Only one is required
+ makes seven volatile reads in its fast path.  Only three are required

`LocalPush()` has similar issues.

`CanSteal` is making two volatile reads.  Packing head/tail in one int64 could allow this to be a single volatile read.  This would also allow `TrySteal()` to be lockless.
</Title_Description>
    <Label>area-System.Threading</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>14/04/2018 6:24:35 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17561</IssueLabelID>
    <Title>[1.1] Replace tool-runtime binaries with portable linux binaries</Title>
    <Description>When we restore the portable runtime on 1.1 we should also use those portable binaries for the tool-runtime. Otherwise we can run into conflicts between the native binaries expected by the portable-cli and the tool-runtime dependencies.

Also removes some platform specific CLI usages that I tested and verified with the portable CLI instead.

@janvorli this resolves the issues you were seeing with the x509certificates dll. Our tools were using an older version of the managed dll instead of the one in your portable CLi resulting in failed attempted loads of native functions in the System.Security.Cryptography.Native .so.</Description>
    <Title_Description>[1.1] Replace tool-runtime binaries with portable linux binaries When we restore the portable runtime on 1.1 we should also use those portable binaries for the tool-runtime. Otherwise we can run into conflicts between the native binaries expected by the portable-cli and the tool-runtime dependencies.

Also removes some platform specific CLI usages that I tested and verified with the portable CLI instead.

@janvorli this resolves the issues you were seeing with the x509certificates dll. Our tools were using an older version of the managed dll instead of the one in your portable CLi resulting in failed attempted loads of native functions in the System.Security.Cryptography.Native .so.</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>ianhays</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17558</IssueLabelID>
    <Title>JitStress=2 failure in corefx System.Diagnostics.StackTrace.Tests</Title>
    <Description>We get the following failure in x64_checked_windows_nt_corefx_jitstress2 jobs (e.g. https://ci.dot.net/job/dotnet_coreclr/job/master/view/Windows_NT/job/jitstress/job/x64_checked_windows_nt_corefx_jitstress2/484/consoleText)

```
Starting:    System.Diagnostics.StackTrace.Tests
     System.Diagnostics.Tests.StackFrameTests.SkipFrames_CallMethod_ReturnsExpected [FAIL]
        Assert.NotEqual() Failure
        Expected: Not Void SkipFrames_CallMethod_ReturnsExpected()
        Actual:   Void SkipFrames_CallMethod_ReturnsExpected()
```

Two other failures from that run are the same as in #17557.</Description>
    <Title_Description>JitStress=2 failure in corefx System.Diagnostics.StackTrace.Tests We get the following failure in x64_checked_windows_nt_corefx_jitstress2 jobs (e.g. https://ci.dot.net/job/dotnet_coreclr/job/master/view/Windows_NT/job/jitstress/job/x64_checked_windows_nt_corefx_jitstress2/484/consoleText)

```
Starting:    System.Diagnostics.StackTrace.Tests
     System.Diagnostics.Tests.StackFrameTests.SkipFrames_CallMethod_ReturnsExpected [FAIL]
        Assert.NotEqual() Failure
        Expected: Not Void SkipFrames_CallMethod_ReturnsExpected()
        Actual:   Void SkipFrames_CallMethod_ReturnsExpected()
```

Two other failures from that run are the same as in #17557.</Title_Description>
    <Label>JitStress</Label>
    <Assignee>erozenfeld</Assignee>
    <CreatedAt>13/04/2018 10:48:22 PM +00:00</CreatedAt>
    <ClosedAt>17/06/2018 2:54:12 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17557</IssueLabelID>
    <Title>Failures in x64_checked_windows_nt_corefx_jitstress1 jobs</Title>
    <Description>We get the following failures in  x64_checked_windows_nt_corefx_jitstress1 jobs (e.g. https://ci.dot.net/job/dotnet_coreclr/job/master/view/Windows_NT/job/jitstress/job/x64_checked_windows_nt_corefx_jitstress1/lastBuild/consoleText)

```
     System.Diagnostics.Tests.StackFrameTests.Ctor_Filename_LineNumber_ColNumber(fileName: null lineNumber: -1 columnNumber: 0) [FAIL]
        Assert.Equal() Failure
        Expected: 0
        Actual:   8
        Stack Trace:
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Diagnostics.StackTrace\tests\StackFrameTests.cs(1700): at System.Diagnostics.Tests.StackFrameTests.VerifyStackFrameSkipFrames(StackFrame stackFrame Boolean isFileConstructor Int32 skipFrames MethodInfo expectedMethod Boolean isCurrentFrame)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Diagnostics.StackTrace\tests\StackFrameTests.cs(1120): at System.Diagnostics.Tests.StackFrameTests.Ctor_Filename_LineNumber_ColNumber(String fileName Int32 lineNumber Int32 columnNumber)
     System.Diagnostics.Tests.StackFrameTests.Ctor_Filename_LineNumber_ColNumber(fileName: \"\" lineNumber: 0 columnNumber: -1) [FAIL]
        Assert.Equal() Failure
        Expected: 0
        Actual:   8
        Stack Trace:
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Diagnostics.StackTrace\tests\StackFrameTests.cs(1700): at System.Diagnostics.Tests.StackFrameTests.VerifyStackFrameSkipFrames(StackFrame stackFrame Boolean isFileConstructor Int32 skipFrames MethodInfo expectedMethod Boolean isCurrentFrame)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Diagnostics.StackTrace\tests\StackFrameTests.cs(1120): at System.Diagnostics.Tests.StackFrameTests.Ctor_Filename_LineNumber_ColNumber(String fileName Int32 lineNumber Int32 columnNumber)
     System.Diagnostics.Tests.StackFrameTests.Ctor_Filename_LineNumber_ColNumber(fileName: \"FileName\" lineNumber: 1 columnNumber: 2) [FAIL]
        Assert.Equal() Failure
        Expected: 0
        Actual:   8
        Stack Trace:
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Diagnostics.StackTrace\tests\StackFrameTests.cs(1700): at System.Diagnostics.Tests.StackFrameTests.VerifyStackFrameSkipFrames(StackFrame stackFrame Boolean isFileConstructor Int32 skipFrames MethodInfo expectedMethod Boolean isCurrentFrame)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Diagnostics.StackTrace\tests\StackFrameTests.cs(1120): at System.Diagnostics.Tests.StackFrameTests.Ctor_Filename_LineNumber_ColNumber(String fileName Int32 lineNumber Int32 columnNumber)
  Finished:    System.Diagnostics.StackTrace.Tests
```
```
DataContractSerializerTests.DCS_ResolveDatacontractBaseType [FAIL]
        System.NullReferenceException : Object reference not set to an instance of an object.
        Stack Trace:
  Finished:    System.Security.Cryptography.Cng.Tests
  
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Runtime.Serialization.Xml\tests\SerializationTestTypes\DataContractResolverLibrary.cs(840): at SerializationTestTypes.ProxyDataContractResolver.ResolveName(String typeName String typeNamespace Type declaredType DataContractResolver knownTypeResolver)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerContext.cs(2760): at System.Runtime.Serialization.XmlObjectSerializerContext.ResolveDataContractFromKnownTypes(String typeName String typeNs DataContract memberTypeContract)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\KnownTypeDataContractResolver.cs(260): at System.Runtime.Serialization.KnownTypeDataContractResolver.TryResolveType(Type type Type declaredType DataContractResolver knownTypeResolver XmlDictionaryString&amp; typeName XmlDictionaryString&amp; typeNamespace)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerWriteContext.cs(6730): at System.Runtime.Serialization.XmlObjectSerializerWriteContext.ResolveType(Type objectType Type declaredType XmlDictionaryString&amp; typeName XmlDictionaryString&amp; typeNamespace)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerWriteContext.cs(6650): at System.Runtime.Serialization.XmlObjectSerializerWriteContext.WriteResolvedTypeInfo(XmlWriterDelegator writer Type objectType Type declaredType)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerWriteContext.cs(7100): at System.Runtime.Serialization.XmlObjectSerializerWriteContext.WriteTypeInfo(XmlWriterDelegator writer DataContract contract DataContract declaredContract)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerWriteContext.cs(1780): at System.Runtime.Serialization.XmlObjectSerializerWriteContext.SerializeWithXsiTypeAtTopLevel(DataContract dataContract XmlWriterDelegator xmlWriter Object obj RuntimeTypeHandle originalDeclaredTypeHandle Type graphType)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContractSerializer.cs(3760): at System.Runtime.Serialization.DataContractSerializer.InternalWriteObjectContent(XmlWriterDelegator writer Object graph DataContractResolver dataContractResolver)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContractSerializer.cs(2370): at System.Runtime.Serialization.DataContractSerializer.InternalWriteObject(XmlWriterDelegator writer Object graph DataContractResolver dataContractResolver)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializer.cs(710): at System.Runtime.Serialization.XmlObjectSerializer.WriteObjectHandleExceptions(XmlWriterDelegator writer Object graph DataContractResolver dataContractResolver)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializer.cs(570): at System.Runtime.Serialization.XmlObjectSerializer.WriteObject(XmlDictionaryWriter writer Object graph)
```
```
DataContractSerializerTests.DCS_ResolveNameReturnsEmptyNamespace [FAIL]
        System.NullReferenceException : Object reference not set to an instance of an object.
        Stack Trace:
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Runtime.Serialization.Xml\tests\SerializationTestTypes\DataContractResolverLibrary.cs(750): at SerializationTestTypes.EmptyNamespaceResolver.ResolveName(String typeName String typeNamespace Type declaredType DataContractResolver knownTypeResolver)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerContext.cs(2760): at System.Runtime.Serialization.XmlObjectSerializerContext.ResolveDataContractFromKnownTypes(String typeName String typeNs DataContract memberTypeContract)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\KnownTypeDataContractResolver.cs(260): at System.Runtime.Serialization.KnownTypeDataContractResolver.TryResolveType(Type type Type declaredType DataContractResolver knownTypeResolver XmlDictionaryString&amp; typeName XmlDictionaryString&amp; typeNamespace)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerWriteContext.cs(6730): at System.Runtime.Serialization.XmlObjectSerializerWriteContext.ResolveType(Type objectType Type declaredType XmlDictionaryString&amp; typeName XmlDictionaryString&amp; typeNamespace)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerWriteContext.cs(6650): at System.Runtime.Serialization.XmlObjectSerializerWriteContext.WriteResolvedTypeInfo(XmlWriterDelegator writer Type objectType Type declaredType)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerWriteContext.cs(7100): at System.Runtime.Serialization.XmlObjectSerializerWriteContext.WriteTypeInfo(XmlWriterDelegator writer DataContract contract DataContract declaredContract)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerWriteContext.cs(2300): at System.Runtime.Serialization.XmlObjectSerializerWriteContext.SerializeWithXsiType(XmlWriterDelegator xmlWriter Object obj RuntimeTypeHandle objectTypeHandle Type objectType Int32 declaredTypeID RuntimeTypeHandle declaredTypeHandle Type declaredType)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerWriteContext.cs(1430): at System.Runtime.Serialization.XmlObjectSerializerWriteContext.InternalSerialize(XmlWriterDelegator xmlWriter Object obj Boolean isDeclaredType Boolean writeXsiType Int32 declaredTypeID RuntimeTypeHandle declaredTypeHandle)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionClassWriter.cs(1580): at System.Runtime.Serialization.ReflectionClassWriter.ReflectionInternalSerialize(XmlWriterDelegator xmlWriter XmlObjectSerializerWriteContext context Object obj Boolean isDeclaredType Boolean writeXsiType Type memberType Boolean isNullableOfT)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionClassWriter.cs(950): at System.Runtime.Serialization.ReflectionClassWriter.ReflectionWriteValue(XmlWriterDelegator xmlWriter XmlObjectSerializerWriteContext context Type type Object value Boolean writeXsiType PrimitiveDataContract primitiveContractForParamType)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionXmlFormatWriter.cs(1870): at System.Runtime.Serialization.ReflectionXmlClassWriter.ReflectionWriteMembers(XmlWriterDelegator xmlWriter Object obj XmlObjectSerializerWriteContext context ClassDataContract classContract ClassDataContract derivedMostClassContract Int32 childElementIndex XmlDictionaryString[] emptyStringArray)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionClassWriter.cs(350): at System.Runtime.Serialization.ReflectionClassWriter.ReflectionWriteClass(XmlWriterDelegator xmlWriter Object obj XmlObjectSerializerWriteContext context ClassDataContract classContract XmlDictionaryString[] memberNames)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionXmlFormatWriter.cs(200): at System.Runtime.Serialization.ReflectionXmlFormatWriter.ReflectionWriteClass(XmlWriterDelegator xmlWriter Object obj XmlObjectSerializerWriteContext context ClassDataContract classContract)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ClassDataContract.cs(5070): at System.Runtime.Serialization.ClassDataContract.WriteXmlValue(XmlWriterDelegator xmlWriter Object obj XmlObjectSerializerWriteContext context)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerWriteContext.cs(6540): at System.Runtime.Serialization.XmlObjectSerializerWriteContext.WriteDataContractValue(DataContract dataContract XmlWriterDelegator xmlWriter Object obj RuntimeTypeHandle declaredTypeHandle)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerWriteContext.cs(1550): at System.Runtime.Serialization.XmlObjectSerializerWriteContext.SerializeWithoutXsiType(DataContract dataContract XmlWriterDelegator xmlWriter Object obj RuntimeTypeHandle declaredTypeHandle)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContractSerializer.cs(3540): at System.Runtime.Serialization.DataContractSerializer.InternalWriteObjectContent(XmlWriterDelegator writer Object graph DataContractResolver dataContractResolver)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContractSerializer.cs(2370): at System.Runtime.Serialization.DataContractSerializer.InternalWriteObject(XmlWriterDelegator writer Object graph DataContractResolver dataContractResolver)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializer.cs(710): at System.Runtime.Serialization.XmlObjectSerializer.WriteObjectHandleExceptions(XmlWriterDelegator writer Object graph DataContractResolver dataContractResolver)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializer.cs(570): at System.Runtime.Serialization.XmlObjectSerializer.WriteObject(XmlDictionaryWriter writer Object graph)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializer.cs(270): at System.Runtime.Serialization.XmlObjectSerializer.WriteObject(Stream stream Object graph)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\Common\tests\System\Runtime\Serialization\DataContractSerializerHelper.cs(290): at System.Runtime.Serialization.Tests.DataContractSerializerHelper.SerializeAndDeserialize[T](T value String baseline DataContractSerializerSettings settings Func`1 serializerFactory Boolean skipStringCompare)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Runtime.Serialization.Xml\tests\DataContractSerializer.cs(27840): at DataContractSerializerTests.DCS_ResolveNameReturnsEmptyNamespace()
```</Description>
    <Title_Description>Failures in x64_checked_windows_nt_corefx_jitstress1 jobs We get the following failures in  x64_checked_windows_nt_corefx_jitstress1 jobs (e.g. https://ci.dot.net/job/dotnet_coreclr/job/master/view/Windows_NT/job/jitstress/job/x64_checked_windows_nt_corefx_jitstress1/lastBuild/consoleText)

```
     System.Diagnostics.Tests.StackFrameTests.Ctor_Filename_LineNumber_ColNumber(fileName: null lineNumber: -1 columnNumber: 0) [FAIL]
        Assert.Equal() Failure
        Expected: 0
        Actual:   8
        Stack Trace:
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Diagnostics.StackTrace\tests\StackFrameTests.cs(1700): at System.Diagnostics.Tests.StackFrameTests.VerifyStackFrameSkipFrames(StackFrame stackFrame Boolean isFileConstructor Int32 skipFrames MethodInfo expectedMethod Boolean isCurrentFrame)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Diagnostics.StackTrace\tests\StackFrameTests.cs(1120): at System.Diagnostics.Tests.StackFrameTests.Ctor_Filename_LineNumber_ColNumber(String fileName Int32 lineNumber Int32 columnNumber)
     System.Diagnostics.Tests.StackFrameTests.Ctor_Filename_LineNumber_ColNumber(fileName: \"\" lineNumber: 0 columnNumber: -1) [FAIL]
        Assert.Equal() Failure
        Expected: 0
        Actual:   8
        Stack Trace:
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Diagnostics.StackTrace\tests\StackFrameTests.cs(1700): at System.Diagnostics.Tests.StackFrameTests.VerifyStackFrameSkipFrames(StackFrame stackFrame Boolean isFileConstructor Int32 skipFrames MethodInfo expectedMethod Boolean isCurrentFrame)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Diagnostics.StackTrace\tests\StackFrameTests.cs(1120): at System.Diagnostics.Tests.StackFrameTests.Ctor_Filename_LineNumber_ColNumber(String fileName Int32 lineNumber Int32 columnNumber)
     System.Diagnostics.Tests.StackFrameTests.Ctor_Filename_LineNumber_ColNumber(fileName: \"FileName\" lineNumber: 1 columnNumber: 2) [FAIL]
        Assert.Equal() Failure
        Expected: 0
        Actual:   8
        Stack Trace:
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Diagnostics.StackTrace\tests\StackFrameTests.cs(1700): at System.Diagnostics.Tests.StackFrameTests.VerifyStackFrameSkipFrames(StackFrame stackFrame Boolean isFileConstructor Int32 skipFrames MethodInfo expectedMethod Boolean isCurrentFrame)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Diagnostics.StackTrace\tests\StackFrameTests.cs(1120): at System.Diagnostics.Tests.StackFrameTests.Ctor_Filename_LineNumber_ColNumber(String fileName Int32 lineNumber Int32 columnNumber)
  Finished:    System.Diagnostics.StackTrace.Tests
```
```
DataContractSerializerTests.DCS_ResolveDatacontractBaseType [FAIL]
        System.NullReferenceException : Object reference not set to an instance of an object.
        Stack Trace:
  Finished:    System.Security.Cryptography.Cng.Tests
  
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Runtime.Serialization.Xml\tests\SerializationTestTypes\DataContractResolverLibrary.cs(840): at SerializationTestTypes.ProxyDataContractResolver.ResolveName(String typeName String typeNamespace Type declaredType DataContractResolver knownTypeResolver)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerContext.cs(2760): at System.Runtime.Serialization.XmlObjectSerializerContext.ResolveDataContractFromKnownTypes(String typeName String typeNs DataContract memberTypeContract)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\KnownTypeDataContractResolver.cs(260): at System.Runtime.Serialization.KnownTypeDataContractResolver.TryResolveType(Type type Type declaredType DataContractResolver knownTypeResolver XmlDictionaryString&amp; typeName XmlDictionaryString&amp; typeNamespace)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerWriteContext.cs(6730): at System.Runtime.Serialization.XmlObjectSerializerWriteContext.ResolveType(Type objectType Type declaredType XmlDictionaryString&amp; typeName XmlDictionaryString&amp; typeNamespace)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerWriteContext.cs(6650): at System.Runtime.Serialization.XmlObjectSerializerWriteContext.WriteResolvedTypeInfo(XmlWriterDelegator writer Type objectType Type declaredType)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerWriteContext.cs(7100): at System.Runtime.Serialization.XmlObjectSerializerWriteContext.WriteTypeInfo(XmlWriterDelegator writer DataContract contract DataContract declaredContract)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerWriteContext.cs(1780): at System.Runtime.Serialization.XmlObjectSerializerWriteContext.SerializeWithXsiTypeAtTopLevel(DataContract dataContract XmlWriterDelegator xmlWriter Object obj RuntimeTypeHandle originalDeclaredTypeHandle Type graphType)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContractSerializer.cs(3760): at System.Runtime.Serialization.DataContractSerializer.InternalWriteObjectContent(XmlWriterDelegator writer Object graph DataContractResolver dataContractResolver)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContractSerializer.cs(2370): at System.Runtime.Serialization.DataContractSerializer.InternalWriteObject(XmlWriterDelegator writer Object graph DataContractResolver dataContractResolver)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializer.cs(710): at System.Runtime.Serialization.XmlObjectSerializer.WriteObjectHandleExceptions(XmlWriterDelegator writer Object graph DataContractResolver dataContractResolver)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializer.cs(570): at System.Runtime.Serialization.XmlObjectSerializer.WriteObject(XmlDictionaryWriter writer Object graph)
```
```
DataContractSerializerTests.DCS_ResolveNameReturnsEmptyNamespace [FAIL]
        System.NullReferenceException : Object reference not set to an instance of an object.
        Stack Trace:
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Runtime.Serialization.Xml\tests\SerializationTestTypes\DataContractResolverLibrary.cs(750): at SerializationTestTypes.EmptyNamespaceResolver.ResolveName(String typeName String typeNamespace Type declaredType DataContractResolver knownTypeResolver)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerContext.cs(2760): at System.Runtime.Serialization.XmlObjectSerializerContext.ResolveDataContractFromKnownTypes(String typeName String typeNs DataContract memberTypeContract)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\KnownTypeDataContractResolver.cs(260): at System.Runtime.Serialization.KnownTypeDataContractResolver.TryResolveType(Type type Type declaredType DataContractResolver knownTypeResolver XmlDictionaryString&amp; typeName XmlDictionaryString&amp; typeNamespace)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerWriteContext.cs(6730): at System.Runtime.Serialization.XmlObjectSerializerWriteContext.ResolveType(Type objectType Type declaredType XmlDictionaryString&amp; typeName XmlDictionaryString&amp; typeNamespace)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerWriteContext.cs(6650): at System.Runtime.Serialization.XmlObjectSerializerWriteContext.WriteResolvedTypeInfo(XmlWriterDelegator writer Type objectType Type declaredType)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerWriteContext.cs(7100): at System.Runtime.Serialization.XmlObjectSerializerWriteContext.WriteTypeInfo(XmlWriterDelegator writer DataContract contract DataContract declaredContract)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerWriteContext.cs(2300): at System.Runtime.Serialization.XmlObjectSerializerWriteContext.SerializeWithXsiType(XmlWriterDelegator xmlWriter Object obj RuntimeTypeHandle objectTypeHandle Type objectType Int32 declaredTypeID RuntimeTypeHandle declaredTypeHandle Type declaredType)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerWriteContext.cs(1430): at System.Runtime.Serialization.XmlObjectSerializerWriteContext.InternalSerialize(XmlWriterDelegator xmlWriter Object obj Boolean isDeclaredType Boolean writeXsiType Int32 declaredTypeID RuntimeTypeHandle declaredTypeHandle)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionClassWriter.cs(1580): at System.Runtime.Serialization.ReflectionClassWriter.ReflectionInternalSerialize(XmlWriterDelegator xmlWriter XmlObjectSerializerWriteContext context Object obj Boolean isDeclaredType Boolean writeXsiType Type memberType Boolean isNullableOfT)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionClassWriter.cs(950): at System.Runtime.Serialization.ReflectionClassWriter.ReflectionWriteValue(XmlWriterDelegator xmlWriter XmlObjectSerializerWriteContext context Type type Object value Boolean writeXsiType PrimitiveDataContract primitiveContractForParamType)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionXmlFormatWriter.cs(1870): at System.Runtime.Serialization.ReflectionXmlClassWriter.ReflectionWriteMembers(XmlWriterDelegator xmlWriter Object obj XmlObjectSerializerWriteContext context ClassDataContract classContract ClassDataContract derivedMostClassContract Int32 childElementIndex XmlDictionaryString[] emptyStringArray)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionClassWriter.cs(350): at System.Runtime.Serialization.ReflectionClassWriter.ReflectionWriteClass(XmlWriterDelegator xmlWriter Object obj XmlObjectSerializerWriteContext context ClassDataContract classContract XmlDictionaryString[] memberNames)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionXmlFormatWriter.cs(200): at System.Runtime.Serialization.ReflectionXmlFormatWriter.ReflectionWriteClass(XmlWriterDelegator xmlWriter Object obj XmlObjectSerializerWriteContext context ClassDataContract classContract)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ClassDataContract.cs(5070): at System.Runtime.Serialization.ClassDataContract.WriteXmlValue(XmlWriterDelegator xmlWriter Object obj XmlObjectSerializerWriteContext context)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerWriteContext.cs(6540): at System.Runtime.Serialization.XmlObjectSerializerWriteContext.WriteDataContractValue(DataContract dataContract XmlWriterDelegator xmlWriter Object obj RuntimeTypeHandle declaredTypeHandle)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerWriteContext.cs(1550): at System.Runtime.Serialization.XmlObjectSerializerWriteContext.SerializeWithoutXsiType(DataContract dataContract XmlWriterDelegator xmlWriter Object obj RuntimeTypeHandle declaredTypeHandle)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContractSerializer.cs(3540): at System.Runtime.Serialization.DataContractSerializer.InternalWriteObjectContent(XmlWriterDelegator writer Object graph DataContractResolver dataContractResolver)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContractSerializer.cs(2370): at System.Runtime.Serialization.DataContractSerializer.InternalWriteObject(XmlWriterDelegator writer Object graph DataContractResolver dataContractResolver)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializer.cs(710): at System.Runtime.Serialization.XmlObjectSerializer.WriteObjectHandleExceptions(XmlWriterDelegator writer Object graph DataContractResolver dataContractResolver)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializer.cs(570): at System.Runtime.Serialization.XmlObjectSerializer.WriteObject(XmlDictionaryWriter writer Object graph)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializer.cs(270): at System.Runtime.Serialization.XmlObjectSerializer.WriteObject(Stream stream Object graph)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\Common\tests\System\Runtime\Serialization\DataContractSerializerHelper.cs(290): at System.Runtime.Serialization.Tests.DataContractSerializerHelper.SerializeAndDeserialize[T](T value String baseline DataContractSerializerSettings settings Func`1 serializerFactory Boolean skipStringCompare)
           D:\j\workspace\x64_checked_w---b16ed97b\_\fx\src\System.Runtime.Serialization.Xml\tests\DataContractSerializer.cs(27840): at DataContractSerializerTests.DCS_ResolveNameReturnsEmptyNamespace()
```</Title_Description>
    <Label>JitStress</Label>
    <Assignee>briansull</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17556</IssueLabelID>
    <Title>Fix default style argument to Double/Single/Decimal.Parse</Title>
    <Description>Contributes to https://github.com/dotnet/coreclr/issues/17553
cc: @jkotas </Description>
    <Title_Description>Fix default style argument to Double/Single/Decimal.Parse Contributes to https://github.com/dotnet/coreclr/issues/17553
cc: @jkotas </Title_Description>
    <Label>area-System.Runtime</Label>
    <Assignee>jkotas</Assignee>
    <CreatedAt>13/04/2018 8:35:23 PM +00:00</CreatedAt>
    <ClosedAt>13/04/2018 11:07:35 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17555</IssueLabelID>
    <Title>WIP Test tiering in CI</Title>
    <Description>
    </Description>
    <Title_Description>WIP Test tiering in CI </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17554</IssueLabelID>
    <Title>[Perf] Span/IndexerBench/KnownSizeArray(length:1024) regression of ~277% on x86</Title>
    <Description>**[Perf] Span/IndexerBench/KnownSizeArray(length:1024) regression of ~277% on x86**

Regression can be seen in Benchview - CoreCLR/Master branch from [commit](https://github.com/dotnet/coreclr/compare/94ab205d5545699a49cc54d72e9d3d07a454f10a...dotnet:4456cc99ba0fbe3c02be3a9f54c34282caeb7218). Orange dotted line is the Release v2.0 baseline. This is affecting x86 only.

![image](https://user-images.githubusercontent.com/19602715/38752900-8f1c9aac-3f11-11e8-90ca-8393cdf46a74.png)
</Description>
    <Title_Description>[Perf] Span/IndexerBench/KnownSizeArray(length:1024) regression of ~277% on x86 **[Perf] Span/IndexerBench/KnownSizeArray(length:1024) regression of ~277% on x86**

Regression can be seen in Benchview - CoreCLR/Master branch from [commit](https://github.com/dotnet/coreclr/compare/94ab205d5545699a49cc54d72e9d3d07a454f10a...dotnet:4456cc99ba0fbe3c02be3a9f54c34282caeb7218). Orange dotted line is the Release v2.0 baseline. This is affecting x86 only.

![image](https://user-images.githubusercontent.com/19602715/38752900-8f1c9aac-3f11-11e8-90ca-8393cdf46a74.png)
</Title_Description>
    <Label>arch-x86</Label>
    <Assignee>erozenfeld</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17553</IssueLabelID>
    <Title>Default NumberStyle in float.Parse and double.Parse is Integer for Span</Title>
    <Description>The default NumberStyle in ``float.Parse`` and ``double.Parse`` is ``NumberStyle.Integer`` for Span.
https://github.com/dotnet/coreclr/blob/bc28740cd5f0533655f347fc315f6a28836a7efe/src/mscorlib/shared/System/Double.cs#L300-L304
https://github.com/dotnet/coreclr/blob/bc28740cd5f0533655f347fc315f6a28836a7efe/src/mscorlib/shared/System/Single.cs#L291-L295

I don't think this is correct. It breaks default parsing of fp numbers with the following exception:

```csharp
System.FormatException: Input string was not in a correct format.
   at System.Number.ParseSingle(ReadOnlySpan`1 value NumberStyles options NumberFormatInfo numfmt)
```

The default NumberStyle in ``float.TryParse`` and ``double.TryParse`` are correct:

https://github.com/dotnet/coreclr/blob/bc28740cd5f0533655f347fc315f6a28836a7efe/src/mscorlib/shared/System/Double.cs#L319-L322

https://github.com/dotnet/coreclr/blob/bc28740cd5f0533655f347fc315f6a28836a7efe/src/mscorlib/shared/System/Single.cs#L308-L311

The same number which throws an exception for ``Parse`` works nicely with ``TryParse``

The NumberStyles for the string overloads are correct:
https://github.com/dotnet/coreclr/blob/bc28740cd5f0533655f347fc315f6a28836a7efe/src/mscorlib/shared/System/Single.cs#L265-L269

https://github.com/dotnet/coreclr/blob/bc28740cd5f0533655f347fc315f6a28836a7efe/src/mscorlib/shared/System/Double.cs#L266-L270

Repo:
```csharp
 ReadOnlySpan&lt;char&gt; value = "123.45".AsSpan();
  var fp = float.Parse(value provider: CultureInfo.InvariantCulture); // breaks
  var dp = double.Parse(value provider: CultureInfo.InvariantCulture); // breaks
```
This appears to be the case even in the original PR from @stephentoub  in #13389 and looks to be a copy/paste error from the integer types.</Description>
    <Title_Description>Default NumberStyle in float.Parse and double.Parse is Integer for Span The default NumberStyle in ``float.Parse`` and ``double.Parse`` is ``NumberStyle.Integer`` for Span.
https://github.com/dotnet/coreclr/blob/bc28740cd5f0533655f347fc315f6a28836a7efe/src/mscorlib/shared/System/Double.cs#L300-L304
https://github.com/dotnet/coreclr/blob/bc28740cd5f0533655f347fc315f6a28836a7efe/src/mscorlib/shared/System/Single.cs#L291-L295

I don't think this is correct. It breaks default parsing of fp numbers with the following exception:

```csharp
System.FormatException: Input string was not in a correct format.
   at System.Number.ParseSingle(ReadOnlySpan`1 value NumberStyles options NumberFormatInfo numfmt)
```

The default NumberStyle in ``float.TryParse`` and ``double.TryParse`` are correct:

https://github.com/dotnet/coreclr/blob/bc28740cd5f0533655f347fc315f6a28836a7efe/src/mscorlib/shared/System/Double.cs#L319-L322

https://github.com/dotnet/coreclr/blob/bc28740cd5f0533655f347fc315f6a28836a7efe/src/mscorlib/shared/System/Single.cs#L308-L311

The same number which throws an exception for ``Parse`` works nicely with ``TryParse``

The NumberStyles for the string overloads are correct:
https://github.com/dotnet/coreclr/blob/bc28740cd5f0533655f347fc315f6a28836a7efe/src/mscorlib/shared/System/Single.cs#L265-L269

https://github.com/dotnet/coreclr/blob/bc28740cd5f0533655f347fc315f6a28836a7efe/src/mscorlib/shared/System/Double.cs#L266-L270

Repo:
```csharp
 ReadOnlySpan&lt;char&gt; value = "123.45".AsSpan();
  var fp = float.Parse(value provider: CultureInfo.InvariantCulture); // breaks
  var dp = double.Parse(value provider: CultureInfo.InvariantCulture); // breaks
```
This appears to be the case even in the original PR from @stephentoub  in #13389 and looks to be a copy/paste error from the integer types.</Title_Description>
    <Label>area-System.Runtime</Label>
    <Assignee>stephentoub</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17552</IssueLabelID>
    <Title>[Perf] SIMD/RayTracerBench regression of ~7% on x86</Title>
    <Description>**[Perf] SIMD/RayTracerBench regression of ~7% on x86**

Regression can be seen in Benchview - CoreCLR/Master branch between [commits](https://github.com/dotnet/coreclr/compare/0c9e96e1c2c484e7c80bf7f7a7765e6650cbdf73...dotnet:bd7493440cefe9cdfb3648de99178e208f8df5df). Orange dotted line is the Release v2.0 baseline.

![image](https://user-images.githubusercontent.com/19602715/38752109-e943cca6-3f0e-11e8-9f64-f5ee1acd9e90.png)
</Description>
    <Title_Description>[Perf] SIMD/RayTracerBench regression of ~7% on x86 **[Perf] SIMD/RayTracerBench regression of ~7% on x86**

Regression can be seen in Benchview - CoreCLR/Master branch between [commits](https://github.com/dotnet/coreclr/compare/0c9e96e1c2c484e7c80bf7f7a7765e6650cbdf73...dotnet:bd7493440cefe9cdfb3648de99178e208f8df5df). Orange dotted line is the Release v2.0 baseline.

![image](https://user-images.githubusercontent.com/19602715/38752109-e943cca6-3f0e-11e8-9f64-f5ee1acd9e90.png)
</Title_Description>
    <Label>arch-x86</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17551</IssueLabelID>
    <Title>Fix OpenVirtualProcess on Linux issue.</Title>
    <Description>Fix DataTargetReader::GetRemotePointerSize to work on Linux/MacOS platforms so VS's new Linux core dump support works.</Description>
    <Title_Description>Fix OpenVirtualProcess on Linux issue. Fix DataTargetReader::GetRemotePointerSize to work on Linux/MacOS platforms so VS's new Linux core dump support works.</Title_Description>
    <Label>
    </Label>
    <Assignee>mikem8361</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17550</IssueLabelID>
    <Title>[Perf] ByteMark/BenchLUDecomp regression of ~67% on x86</Title>
    <Description>**[Perf] ByteMark/BenchLUDecomp regression of ~67% on x86**

A regression of ~19% can be seen in Benchview - CoreCLR/Master branch between [commits](https://github.com/dotnet/coreclr/compare/367d9b1dd1b542f3d391d0b9111d5914602db2d9...dotnet:312e4486adc4eb8062caa67d4aa9be5411524996) and a regression of ~27% between [commits](https://github.com/dotnet/coreclr/compare/3657a8cab68cdbf9990d98ba4e078f444f5fee82...dotnet:bb36f051ca1dd5be7c998f9c26fa010c3b8c4051).

![image](https://user-images.githubusercontent.com/19602715/38751230-43d0e396-3f0c-11e8-9d9a-3fb9dbb294c2.png)


category:cq
theme:benchmarks
skill-level:expert
cost:small</Description>
    <Title_Description>[Perf] ByteMark/BenchLUDecomp regression of ~67% on x86 **[Perf] ByteMark/BenchLUDecomp regression of ~67% on x86**

A regression of ~19% can be seen in Benchview - CoreCLR/Master branch between [commits](https://github.com/dotnet/coreclr/compare/367d9b1dd1b542f3d391d0b9111d5914602db2d9...dotnet:312e4486adc4eb8062caa67d4aa9be5411524996) and a regression of ~27% between [commits](https://github.com/dotnet/coreclr/compare/3657a8cab68cdbf9990d98ba4e078f444f5fee82...dotnet:bb36f051ca1dd5be7c998f9c26fa010c3b8c4051).

![image](https://user-images.githubusercontent.com/19602715/38751230-43d0e396-3f0c-11e8-9d9a-3fb9dbb294c2.png)


category:cq
theme:benchmarks
skill-level:expert
cost:small</Title_Description>
    <Label>arch-x86</Label>
    <Assignee>AndyAyersMS</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17549</IssueLabelID>
    <Title>WIP Test tiered compilation in CI</Title>
    <Description>
    </Description>
    <Title_Description>WIP Test tiered compilation in CI </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>kouvel</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17548</IssueLabelID>
    <Title>[Perf] ByteMark/BenchEmFloatClass improvement of ~3% on x86</Title>
    <Description>**[Perf] ByteMark/BenchEmFloatClass improvement of ~3% on x86**

Improvement can be seen in Benchview - CoreCLR/Master branch between [commits](https://github.com/dotnet/coreclr/compare/89e85cfff719bc743ad53fdc702b0379c5286087...dotnet:e45a895df6b4cc50347daafed05cefa59af511a2). Orange dotted line is the Release v2.0 baseline.

![image](https://user-images.githubusercontent.com/19602715/38750595-4892d6a2-3f0a-11e8-9bcb-33e8ccc8cb88.png)
</Description>
    <Title_Description>[Perf] ByteMark/BenchEmFloatClass improvement of ~3% on x86 **[Perf] ByteMark/BenchEmFloatClass improvement of ~3% on x86**

Improvement can be seen in Benchview - CoreCLR/Master branch between [commits](https://github.com/dotnet/coreclr/compare/89e85cfff719bc743ad53fdc702b0379c5286087...dotnet:e45a895df6b4cc50347daafed05cefa59af511a2). Orange dotted line is the Release v2.0 baseline.

![image](https://user-images.githubusercontent.com/19602715/38750595-4892d6a2-3f0a-11e8-9bcb-33e8ccc8cb88.png)
</Title_Description>
    <Label>arch-x86</Label>
    <Assignee>AndyAyersMS</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17547</IssueLabelID>
    <Title>[Perf] Benchstone/BenchI/BenchE improvement of ~5% on x86</Title>
    <Description>**[Perf] Benchstone/BenchI/AddArray improvement of ~5% on x86**

Improvement can be seen in Benchview - CoreCLR/Master branch between [commits](https://github.com/dotnet/coreclr/compare/367d9b1dd1b542f3d391d0b9111d5914602db2d9...dotnet:312e4486adc4eb8062caa67d4aa9be5411524996). Orange dotted line is the Release v2.0 baseline.

![image](https://user-images.githubusercontent.com/19602715/38750257-42b12438-3f09-11e8-802e-f46787a6c8fb.png)
</Description>
    <Title_Description>[Perf] Benchstone/BenchI/BenchE improvement of ~5% on x86 **[Perf] Benchstone/BenchI/AddArray improvement of ~5% on x86**

Improvement can be seen in Benchview - CoreCLR/Master branch between [commits](https://github.com/dotnet/coreclr/compare/367d9b1dd1b542f3d391d0b9111d5914602db2d9...dotnet:312e4486adc4eb8062caa67d4aa9be5411524996). Orange dotted line is the Release v2.0 baseline.

![image](https://user-images.githubusercontent.com/19602715/38750257-42b12438-3f09-11e8-802e-f46787a6c8fb.png)
</Title_Description>
    <Label>arch-x86</Label>
    <Assignee>erozenfeld</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17545</IssueLabelID>
    <Title>[Perf] Benchstone/BenchI/AddArray improvement of ~8% on x86</Title>
    <Description>**[Perf] Benchstone/BenchI/AddArray improvement of ~8% on x86**

Improvement can be seen in Benchview - CoreCLR/Master branch between [commits](https://github.com/dotnet/coreclr/compare/099e24486977ef4930692aa2c122f572e3d09d01...dotnet:52be8c187c9edbaaa2c8a775800bedad112bc6c6). Orange dotted line is the Release v2.0 baseline.

![image](https://user-images.githubusercontent.com/19602715/38749963-3b46b538-3f08-11e8-8bc2-c4ce538a2d2b.png)
</Description>
    <Title_Description>[Perf] Benchstone/BenchI/AddArray improvement of ~8% on x86 **[Perf] Benchstone/BenchI/AddArray improvement of ~8% on x86**

Improvement can be seen in Benchview - CoreCLR/Master branch between [commits](https://github.com/dotnet/coreclr/compare/099e24486977ef4930692aa2c122f572e3d09d01...dotnet:52be8c187c9edbaaa2c8a775800bedad112bc6c6). Orange dotted line is the Release v2.0 baseline.

![image](https://user-images.githubusercontent.com/19602715/38749963-3b46b538-3f08-11e8-8bc2-c4ce538a2d2b.png)
</Title_Description>
    <Label>arch-x86</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17544</IssueLabelID>
    <Title>[Perf] Benchstone/BenchF/BenchMrk regression of ~15% on x86</Title>
    <Description>**[Perf] Benchstone/BenchF/BenchMrk regression of ~15% on x86**

Regression can be seen in Benchview - CoreCLR/Master branch between [commits](https://github.com/dotnet/coreclr/compare/0c9e96e1c2c484e7c80bf7f7a7765e6650cbdf73...dotnet:bd7493440cefe9cdfb3648de99178e208f8df5df). Orange dotted line is the Release v2.0 baseline.

![image](https://user-images.githubusercontent.com/19602715/38749646-392b7320-3f07-11e8-963c-882cb035d3be.png)




</Description>
    <Title_Description>[Perf] Benchstone/BenchF/BenchMrk regression of ~15% on x86 **[Perf] Benchstone/BenchF/BenchMrk regression of ~15% on x86**

Regression can be seen in Benchview - CoreCLR/Master branch between [commits](https://github.com/dotnet/coreclr/compare/0c9e96e1c2c484e7c80bf7f7a7765e6650cbdf73...dotnet:bd7493440cefe9cdfb3648de99178e208f8df5df). Orange dotted line is the Release v2.0 baseline.

![image](https://user-images.githubusercontent.com/19602715/38749646-392b7320-3f07-11e8-963c-882cb035d3be.png)




</Title_Description>
    <Label>arch-x86</Label>
    <Assignee>CarolEidt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17543</IssueLabelID>
    <Title>Allow TYP_SIMD normalization for GT_IND in importer (#16542)</Title>
    <Description>
Fix for #16542

Increasing the scope of the assertion to include TYP_SIMD allows the test to pass.

PTAL @sdmaclea @CarolEidt </Description>
    <Title_Description>Allow TYP_SIMD normalization for GT_IND in importer (#16542) 
Fix for #16542

Increasing the scope of the assertion to include TYP_SIMD allows the test to pass.

PTAL @sdmaclea @CarolEidt </Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>sdmaclea</Assignee>
    <CreatedAt>13/04/2018 12:29:12 PM +00:00</CreatedAt>
    <ClosedAt>15/04/2018 4:44:14 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17542</IssueLabelID>
    <Title>Update KoreanLunisolarCalendar.cs</Title>
    <Description>Corrects two issues with the conversion table for Gregorian to Korean lunisolar dates.
See: https://github.com/dotnet/coreclr/issues/17510.

**Issue 1: tables use Julian month/day instead of Gregorian month/day for entries prior to 1583.**
Lmon and Lday have been converted from Julian month and day to Gregorian month and day for years prior to 1583.  This also required a new value for MIN_GREGORIAN_DAY (now 19) so the minimum date now supported by this class is 19 Feb 0918 Gregorian. 

**Issue 2: data discrepancy in years 1586 1587 1648 1659 1692 1753 and 1754.**
Table entries for 1586 1587 1648 1659 1692 1753 and 1754 have been corrected to match [Korea Astronomy and Space Science Institute (KASI)](https://astro.kasi.re.kr:444/life/pageView/5) data.  Specifically:

- for years 1587 1648 and 1754 the first day of year has been corrected
- for years 1586 1587 1659 1692 1753 and 1754 the lengths of each month have been corrected

**Notes**
The DaysPerMonth flag uses the binary literal for ease of readability.</Description>
    <Title_Description>Update KoreanLunisolarCalendar.cs Corrects two issues with the conversion table for Gregorian to Korean lunisolar dates.
See: https://github.com/dotnet/coreclr/issues/17510.

**Issue 1: tables use Julian month/day instead of Gregorian month/day for entries prior to 1583.**
Lmon and Lday have been converted from Julian month and day to Gregorian month and day for years prior to 1583.  This also required a new value for MIN_GREGORIAN_DAY (now 19) so the minimum date now supported by this class is 19 Feb 0918 Gregorian. 

**Issue 2: data discrepancy in years 1586 1587 1648 1659 1692 1753 and 1754.**
Table entries for 1586 1587 1648 1659 1692 1753 and 1754 have been corrected to match [Korea Astronomy and Space Science Institute (KASI)](https://astro.kasi.re.kr:444/life/pageView/5) data.  Specifically:

- for years 1587 1648 and 1754 the first day of year has been corrected
- for years 1586 1587 1659 1692 1753 and 1754 the lengths of each month have been corrected

**Notes**
The DaysPerMonth flag uses the binary literal for ease of readability.</Title_Description>
    <Label>area-System.Globalization</Label>
    <Assignee>tarekgh</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17541</IssueLabelID>
    <Title>[Jit] Recognize FMA pattern and Emit Fused Multiply Add (when available)</Title>
    <Description>e.g.

```csharp
float r =  a * b + c;
      r =  a * b - c;
      r =  c + a * b;
      r = -c + a * b;
Vector3 vR3 = v0 * v1 + v2;
// etc
Vector4 vR4 = v3 * v4 + v5;
// etc
```

Its a bit of a mine field on x86 https://en.wikipedia.org/wiki/FMA_instruction_set

&gt; The incompatibility between Intel's FMA3 and AMD's FMA4 is due to both companies changing plans without coordinating coding details with each other. AMD changed their plans from FMA3 to FMA4 while Intel changed their plans from FMA4 to FMA3 almost at the same time. The history can be summarized as follows:
&gt;
&gt; * August 2007: AMD announces the SSE5 instruction set which includes 3-operand FMA instructions. A new coding scheme (DREX) is introduced for allowing instructions to have three operands.[11]
&gt; * April 2008: Intel announces their AVX and FMA instruction sets including 4-operand FMA instructions. The coding of these instructions uses the new VEX coding scheme[12] which is more flexible than AMD's DREX scheme.
&gt; * December 2008: Intel changes the specification for their FMA instructions from 4-operand to 3-operand instructions. The VEX coding scheme is still used.[13]
&gt; * May 2009: AMD changes the specification of their FMA instructions from the 3-operand DREX form to the 4-operand VEX form compatible with the April 2008 Intel specification rather than the December 2008 Intel specification.[14]
&gt; * October 2011: AMD Bulldozer processor supports FMA4.[15]
&gt; * January 2012: AMD announces FMA3 support in future processors codenamed Trinity and Vishera; they are based on the Piledriver architecture.[16]
&gt; * May 2012: AMD Piledriver processor supports both FMA3 and FMA4.[15]
&gt; * June 2013: Intel Haswell processor supports FMA3.[17]
&gt; * February 2017 The first generation of AMD Ryzen processors officially supports FMA3 but not FMA4 according to the CPUID instruction.[18] There has been confusion regarding whether FMA4 was implemented or not on this processor due to errata in the initial patch to the GNU Binutils package that has since been rectified.[19][20] While the FMA4 instructions seem to work according to some tests they can also give wrong results.[7] Additionally the initial Ryzen CPUs could be crashed by a particular sequence of FMA3 instructions. It has since been resolved by an updated CPU microcode.[21]

category:cq
theme:basic-cq
skill-level:expert
cost:medium</Description>
    <Title_Description>[Jit] Recognize FMA pattern and Emit Fused Multiply Add (when available) e.g.

```csharp
float r =  a * b + c;
      r =  a * b - c;
      r =  c + a * b;
      r = -c + a * b;
Vector3 vR3 = v0 * v1 + v2;
// etc
Vector4 vR4 = v3 * v4 + v5;
// etc
```

Its a bit of a mine field on x86 https://en.wikipedia.org/wiki/FMA_instruction_set

&gt; The incompatibility between Intel's FMA3 and AMD's FMA4 is due to both companies changing plans without coordinating coding details with each other. AMD changed their plans from FMA3 to FMA4 while Intel changed their plans from FMA4 to FMA3 almost at the same time. The history can be summarized as follows:
&gt;
&gt; * August 2007: AMD announces the SSE5 instruction set which includes 3-operand FMA instructions. A new coding scheme (DREX) is introduced for allowing instructions to have three operands.[11]
&gt; * April 2008: Intel announces their AVX and FMA instruction sets including 4-operand FMA instructions. The coding of these instructions uses the new VEX coding scheme[12] which is more flexible than AMD's DREX scheme.
&gt; * December 2008: Intel changes the specification for their FMA instructions from 4-operand to 3-operand instructions. The VEX coding scheme is still used.[13]
&gt; * May 2009: AMD changes the specification of their FMA instructions from the 3-operand DREX form to the 4-operand VEX form compatible with the April 2008 Intel specification rather than the December 2008 Intel specification.[14]
&gt; * October 2011: AMD Bulldozer processor supports FMA4.[15]
&gt; * January 2012: AMD announces FMA3 support in future processors codenamed Trinity and Vishera; they are based on the Piledriver architecture.[16]
&gt; * May 2012: AMD Piledriver processor supports both FMA3 and FMA4.[15]
&gt; * June 2013: Intel Haswell processor supports FMA3.[17]
&gt; * February 2017 The first generation of AMD Ryzen processors officially supports FMA3 but not FMA4 according to the CPUID instruction.[18] There has been confusion regarding whether FMA4 was implemented or not on this processor due to errata in the initial patch to the GNU Binutils package that has since been rectified.[19][20] While the FMA4 instructions seem to work according to some tests they can also give wrong results.[7] Additionally the initial Ryzen CPUs could be crashed by a particular sequence of FMA3 instructions. It has since been resolved by an updated CPU microcode.[21]

category:cq
theme:basic-cq
skill-level:expert
cost:medium</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>13/04/2018 8:57:42 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17540</IssueLabelID>
    <Title>Update CoreClr CoreFx PgoData to preview3-26416-01 preview3-26416-01 master-20180415-0051 respectively (master)</Title>
    <Description>/cc @dotnet/coreclr-auto-update-notify</Description>
    <Title_Description>Update CoreClr, CoreFx, PgoData to preview3-26416-01, preview3-26416-01, master-20180415-0051, respectively (master) /cc @dotnet/coreclr-auto-update-notify</Title_Description>
    <Label>area-Meta</Label>
    <Assignee>AlexGhiondea</Assignee>
    <CreatedAt>13/04/2018 8:07:31 AM +00:00</CreatedAt>
    <ClosedAt>16/04/2018 6:43:05 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17539</IssueLabelID>
    <Title>Mirror changes from dotnet/corefx</Title>
    <Description>This PR contains mirrored changes from dotnet/corefx


**Please REBASE this PR when merging**</Description>
    <Title_Description>Mirror changes from dotnet/corefx This PR contains mirrored changes from dotnet/corefx


**Please REBASE this PR when merging**</Title_Description>
    <Label>
    </Label>
    <Assignee>ahsonkhan</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17537</IssueLabelID>
    <Title>[Arm64/Windows] Simplify JIT_MemSet &amp; JIT_MemCpy</Title>
    <Description>JIT_Memset alignment code was definitly broken for some
unaligned cases

JIT_MemCpy likely had the same issue

Simplify implementation to reduce maintenance burden

@janvorli @jkotas PTAL
@dotnet/arm64-contrib FYI

This is the Windows equivalent of #17536 

Should be required to fix probable issues on windows like #17167 #17168 &amp; #17169 
</Description>
    <Title_Description>[Arm64/Windows] Simplify JIT_MemSet &amp; JIT_MemCpy JIT_Memset alignment code was definitly broken for some
unaligned cases

JIT_MemCpy likely had the same issue

Simplify implementation to reduce maintenance burden

@janvorli @jkotas PTAL
@dotnet/arm64-contrib FYI

This is the Windows equivalent of #17536 

Should be required to fix probable issues on windows like #17167 #17168 &amp; #17169 
</Title_Description>
    <Label>area-VM</Label>
    <Assignee>janvorli</Assignee>
    <CreatedAt>13/04/2018 1:31:23 AM +00:00</CreatedAt>
    <ClosedAt>13/04/2018 4:46:20 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17535</IssueLabelID>
    <Title>Insert int3 after non-returning calls at the end of basic blocks.</Title>
    <Description>This is a follow-up to #17501 that fixed #17398.

#17398 was caused by a break in implicit contract between codegen and
gc pointer reporting in fully-interruptible mode: the latter assumed that
register gc pointer liveness doesn't change across calls while #6103 introduced
codegen where it wasn't true.

#17501 changed gc pointer reporting not to expect that register gc pointer liveness
doesn't change across calls.

This change inserts int3 after non-returning calls at the end of basic blocks
so that gc pointer liveness doesn't change across calls. This is additional
insurance in case any other place in runtime is dependent on that contract.</Description>
    <Title_Description>Insert int3 after non-returning calls at the end of basic blocks. This is a follow-up to #17501 that fixed #17398.

#17398 was caused by a break in implicit contract between codegen and
gc pointer reporting in fully-interruptible mode: the latter assumed that
register gc pointer liveness doesn't change across calls while #6103 introduced
codegen where it wasn't true.

#17501 changed gc pointer reporting not to expect that register gc pointer liveness
doesn't change across calls.

This change inserts int3 after non-returning calls at the end of basic blocks
so that gc pointer liveness doesn't change across calls. This is additional
insurance in case any other place in runtime is dependent on that contract.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>dotnet-bot</Assignee>
    <CreatedAt>13/04/2018 1:08:59 AM +00:00</CreatedAt>
    <ClosedAt>13/04/2018 11:29:12 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17534</IssueLabelID>
    <Title>The crossgen tool should accept Portable PDBs as input</Title>
    <Description>On Windows crossgen only accepts Windows PDBs as input when creating the crossgen PDB (/CreatePDB option).</Description>
    <Title_Description>The crossgen tool should accept Portable PDBs as input On Windows crossgen only accepts Windows PDBs as input when creating the crossgen PDB (/CreatePDB option).</Title_Description>
    <Label>area-CrossGen/NGEN</Label>
    <Assignee>mikem8361</Assignee>
    <CreatedAt>12/04/2018 11:30:42 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17533</IssueLabelID>
    <Title>Make Windows builds always portable</Title>
    <Description>Apparently there is little or no need for a non-portable Windows build so
rather than trying to figure out which version of Windows we are building
on just ignore -PortableBuild=false.  We can add a warning or refuse to
accept the switch later if necessary but for now we need to continue
accepting it to avoid build breaks.

Fixes #14291</Description>
    <Title_Description>Make Windows builds always portable Apparently there is little or no need for a non-portable Windows build so
rather than trying to figure out which version of Windows we are building
on just ignore -PortableBuild=false.  We can add a warning or refuse to
accept the switch later if necessary but for now we need to continue
accepting it to avoid build breaks.

Fixes #14291</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>RussKeldorph</Assignee>
    <CreatedAt>12/04/2018 11:18:37 PM +00:00</CreatedAt>
    <ClosedAt>14/04/2018 2:21:04 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17532</IssueLabelID>
    <Title>Remove CreateFromPinnedArray from Memory (moved to MemoryMarshal)</Title>
    <Description>Part of https://github.com/dotnet/corefx/issues/28954

Corefx side (remove from ref): https://github.com/dotnet/corefx/pull/29077

Related PR: https://github.com/dotnet/coreclr/pull/17500</Description>
    <Title_Description>Remove CreateFromPinnedArray from Memory (moved to MemoryMarshal) Part of https://github.com/dotnet/corefx/issues/28954

Corefx side (remove from ref): https://github.com/dotnet/corefx/pull/29077

Related PR: https://github.com/dotnet/coreclr/pull/17500</Title_Description>
    <Label>area-System.Memory</Label>
    <Assignee>ahsonkhan</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17531</IssueLabelID>
    <Title>Protect SuperPMI from crashes calling jitStartup</Title>
    <Description>When we call jitStartup we pass a JitHost interface that the JIT
calls to query for data. These queries look up in the recorded
MCH data and could fail (and throw an exception) if data is
missing which it can be for running non-matching altjit against
a collection. Protect these calls with exception handling.</Description>
    <Title_Description>Protect SuperPMI from crashes calling jitStartup When we call jitStartup we pass a JitHost interface that the JIT
calls to query for data. These queries look up in the recorded
MCH data and could fail (and throw an exception) if data is
missing which it can be for running non-matching altjit against
a collection. Protect these calls with exception handling.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>dotnet-bot</Assignee>
    <CreatedAt>12/04/2018 8:57:36 PM +00:00</CreatedAt>
    <ClosedAt>13/04/2018 9:02:10 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17530</IssueLabelID>
    <Title>Adding GetChunks which allow efficient scanning of a StringBuilder</Title>
    <Description>This change is the start of addressing the issue  CoreFX issue 

https://github.com/dotnet/corefx/issues/21248

which wants to have an efficient way of reading the characters of a StringBuilder.      However it has morphed alot since then (from a callback to an iterator model).   The API review part of this is the following issue. 

https://github.com/dotnet/corefx/issues/29770

This PR is an implementation of that spec.  In particular we implement the following new method on StringBuilder. 
```
class StringBuilder { 
      ChunkEnumerator GetChunks();
}
```
ChunkEnumerator is a struct that follows the IEnumerable&lt;ReadOnlyMemory&lt;char&gt;&gt; pattern and thus works with the C# foreach statement.   Here is an example for efficiently implementing 'IndexOf' using GetChunks
```
        static int IndexOf(StringBuilder sb char c)
        {
            int pos = 0;
            foreach (ReadOnlyMemory&lt;char&gt; chunk in sb.GetChunks())
            {
                var span = chunk.Span;  // We create a local variable because it is more efficient
                for (int i = 0; i &lt; span .Length; i++)
                    if (span [i] == c)
                        return pos + i;
                pos += span.Length;
            }
            return -1;
        }
```
The PR contains the actual implementation.    Note that ChunkEnumerable does not actually implement IEnumerable&lt;ReadOnlyMemory&lt;char&gt;&gt;.  

We considered having it return ReadOnlySpan but decided that it was too fragile in that Span can't be used across 'await' calls and can't be passed to methods that MAY be async.   ReadOnlyMemory does not have this problem (but is a bit less efficient) but does require you to convert it to a Span before accessing the characters (and notice you need to cache the span in a local variable to keep span creation out of the inner loop).    

This is not ideal but is this issue will resurface other places (whenever we want to return chunks) and so it is likely we will invest in JIT optimization to optimize away any inefficiency of using ReadOnlyMemory and converting immediately to Span (which is what would happen in the synchronous case).  
 
At this point it is ready for API review.    This amounts to signing off on using ReadOnlyMemory instead of ReadOnlySpan and the names (is 'Chunks' the right suffix?) and the fact that ChunkEnumerable does not actually implement IEnumerable&lt;ReadOnlyMemory&lt;char&gt;&gt; (It could it is just more code (which we can add later)).  

I have tests however there seems to be a chicken and egg problem in that you need to have an implementation before CoreFX can expose it (and have tests for it).    I have tested the code (all code paths are covered) but I will need to check in tests as a separate PR.  </Description>
    <Title_Description>Adding GetChunks which allow efficient scanning of a StringBuilder This change is the start of addressing the issue  CoreFX issue 

https://github.com/dotnet/corefx/issues/21248

which wants to have an efficient way of reading the characters of a StringBuilder.      However it has morphed alot since then (from a callback to an iterator model).   The API review part of this is the following issue. 

https://github.com/dotnet/corefx/issues/29770

This PR is an implementation of that spec.  In particular we implement the following new method on StringBuilder. 
```
class StringBuilder { 
      ChunkEnumerator GetChunks();
}
```
ChunkEnumerator is a struct that follows the IEnumerable&lt;ReadOnlyMemory&lt;char&gt;&gt; pattern and thus works with the C# foreach statement.   Here is an example for efficiently implementing 'IndexOf' using GetChunks
```
        static int IndexOf(StringBuilder sb char c)
        {
            int pos = 0;
            foreach (ReadOnlyMemory&lt;char&gt; chunk in sb.GetChunks())
            {
                var span = chunk.Span;  // We create a local variable because it is more efficient
                for (int i = 0; i &lt; span .Length; i++)
                    if (span [i] == c)
                        return pos + i;
                pos += span.Length;
            }
            return -1;
        }
```
The PR contains the actual implementation.    Note that ChunkEnumerable does not actually implement IEnumerable&lt;ReadOnlyMemory&lt;char&gt;&gt;.  

We considered having it return ReadOnlySpan but decided that it was too fragile in that Span can't be used across 'await' calls and can't be passed to methods that MAY be async.   ReadOnlyMemory does not have this problem (but is a bit less efficient) but does require you to convert it to a Span before accessing the characters (and notice you need to cache the span in a local variable to keep span creation out of the inner loop).    

This is not ideal but is this issue will resurface other places (whenever we want to return chunks) and so it is likely we will invest in JIT optimization to optimize away any inefficiency of using ReadOnlyMemory and converting immediately to Span (which is what would happen in the synchronous case).  
 
At this point it is ready for API review.    This amounts to signing off on using ReadOnlyMemory instead of ReadOnlySpan and the names (is 'Chunks' the right suffix?) and the fact that ChunkEnumerable does not actually implement IEnumerable&lt;ReadOnlyMemory&lt;char&gt;&gt; (It could it is just more code (which we can add later)).  

I have tests however there seems to be a chicken and egg problem in that you need to have an implementation before CoreFX can expose it (and have tests for it).    I have tested the code (all code paths are covered) but I will need to check in tests as a separate PR.  </Title_Description>
    <Label>area-System.Runtime</Label>
    <Assignee>vancem</Assignee>
    <CreatedAt>12/04/2018 3:00:40 PM +00:00</CreatedAt>
    <ClosedAt>22/05/2018 11:07:46 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17529</IssueLabelID>
    <Title>unable to run after upgrading to .net 2.0 =&gt; 2.1 [terminating with uncaught exception of type EEFileLoadException*]</Title>
    <Description># terminating with uncaught exception of type EEFileLoadException*

when in ( visual studio code [mac os x] ) I go debug --&gt;  run
It never runs everything fails with:  terminating with uncaught exception of type EEFileLoadException*

All I have done is upgraded 2.0 -&gt; 2.1   changed launch.json  to the following:

"program": "${workspaceFolder}/bin/Debug/netcoreapp2.1/NetSo.dll"

Update nuget

removed DotNetCliToolReference  as they are no longer needed   ( now part of SDK )

Run  dotnet build  ( success )

and then run  

# General

dotnet --version
2.1.300-preview2-008530


I get no other output as this seems to be more of a fail to launch issue than a code issue
especially as no code changes have taken place  and no code exceptions are thrown.   This seems more like that MACOS  wont run the new core framework.

I have attached the output from OSX  for clarity.  Any advice would be much appreciated.

[core-crash.mac.txt](https://github.com/dotnet/coreclr/files/1903405/core-crash.mac.txt)


</Description>
    <Title_Description>unable to run after upgrading to .net 2.0 =&gt; 2.1 [terminating with uncaught exception of type EEFileLoadException*] # terminating with uncaught exception of type EEFileLoadException*

when in ( visual studio code [mac os x] ) I go debug --&gt;  run
It never runs everything fails with:  terminating with uncaught exception of type EEFileLoadException*

All I have done is upgraded 2.0 -&gt; 2.1   changed launch.json  to the following:

"program": "${workspaceFolder}/bin/Debug/netcoreapp2.1/NetSo.dll"

Update nuget

removed DotNetCliToolReference  as they are no longer needed   ( now part of SDK )

Run  dotnet build  ( success )

and then run  

# General

dotnet --version
2.1.300-preview2-008530


I get no other output as this seems to be more of a fail to launch issue than a code issue
especially as no code changes have taken place  and no code exceptions are thrown.   This seems more like that MACOS  wont run the new core framework.

I have attached the output from OSX  for clarity.  Any advice would be much appreciated.

[core-crash.mac.txt](https://github.com/dotnet/coreclr/files/1903405/core-crash.mac.txt)


</Title_Description>
    <Label>area-ExceptionHandling</Label>
    <Assignee>janvorli</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17528</IssueLabelID>
    <Title>Add Path.TryGetRandomFileName()</Title>
    <Description>clr part of  https://github.com/dotnet/corefx/issues/28256
test for corefx are [ready](https://github.com/dotnet/corefx/compare/master...MarcoRossignoli:trygetrandomfilename)
cc: @JeremyKuhne @jkotas  @Anipik </Description>
    <Title_Description>Add Path.TryGetRandomFileName() clr part of  https://github.com/dotnet/corefx/issues/28256
test for corefx are [ready](https://github.com/dotnet/corefx/compare/master...MarcoRossignoli:trygetrandomfilename)
cc: @JeremyKuhne @jkotas  @Anipik </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>JeremyKuhne</Assignee>
    <CreatedAt>12/04/2018 11:19:19 AM +00:00</CreatedAt>
    <ClosedAt>19/06/2018 6:15:16 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17524</IssueLabelID>
    <Title>Avoid creating illegal byref pointers</Title>
    <Description>Byref pointers need to point within their "host" object -- thus
the alternate name "interior pointers". If the JIT creates and
reports a pointer as a "byref" but it points outside the host
object and a GC occurs that moves the host object the byref
pointer will not be updated. If a subsequent calculation puts
the byref "back" into the host object it will actually be pointing
to garbage since the host object has moved.

This occurred on ARM with array index calculations in particular
because ARM doesn't have a single-instruction "base + scale*index + offset"
addressing mode. Thus we were generating for the jaggedarr_cs_do
test case `ProcessJagged3DArray()` function:
```
// r0 = array object r6 = computed index offset. We mark r4 as a byref.
add r4 r0 r6

// r4 - 32 is the offset of the object we care about. Then we load the array element.
// In this case the loaded element is a gcref so r4 becomes a gcref.
ldr r4 [r4-32]
```
We get this math because the user code uses `a[i - 10]` which is
essentially `a + (i - 10) * 4 + 8` for element size 4. This is optimized
to `a + i * 4 - 32`. In the above code `r6` is `i * 4`. In this case
after the first instruction `r4` can point beyond the array.
If a GC happens `r4` isn't updated and the second instruction loads garbage.

There are two fixes:
1. Change array morphing in `fgMorphArrayIndex()` to rearrange the array index
IR node creation to only create a byref pointer that is precise and no "intermediate"
byref pointers that don't represent the actual array element address being
computed.
2. Change `fgMoveOpsLeft()` to prevent the left-weighted reassociation optimization
`[byref]+ (ref [int]+ (int int)) =&gt; [byref]+ ([byref]+ (ref int) int)`. This
optimization creates "incorrect" byrefs that don't necessarily point within
the host object.

These fixes are all-platform.

Fixes #17517.

There are many many diffs. They perhaps surprisingly overwhelmingly positive.

For AMD64 SuperPMI the diffs are a 7.6% size win for 5194 functions! This
appears to be due to less code cloning and sometimes better optimization.

For ARM32 ngen-based desktop asm diffs it is a 0.30% improvement across all
framework assemblies. A lot of the diffs seem to be because we CSE the entire
array address offset expression not just the index expression.</Description>
    <Title_Description>Avoid creating illegal byref pointers Byref pointers need to point within their "host" object -- thus
the alternate name "interior pointers". If the JIT creates and
reports a pointer as a "byref" but it points outside the host
object and a GC occurs that moves the host object the byref
pointer will not be updated. If a subsequent calculation puts
the byref "back" into the host object it will actually be pointing
to garbage since the host object has moved.

This occurred on ARM with array index calculations in particular
because ARM doesn't have a single-instruction "base + scale*index + offset"
addressing mode. Thus we were generating for the jaggedarr_cs_do
test case `ProcessJagged3DArray()` function:
```
// r0 = array object r6 = computed index offset. We mark r4 as a byref.
add r4 r0 r6

// r4 - 32 is the offset of the object we care about. Then we load the array element.
// In this case the loaded element is a gcref so r4 becomes a gcref.
ldr r4 [r4-32]
```
We get this math because the user code uses `a[i - 10]` which is
essentially `a + (i - 10) * 4 + 8` for element size 4. This is optimized
to `a + i * 4 - 32`. In the above code `r6` is `i * 4`. In this case
after the first instruction `r4` can point beyond the array.
If a GC happens `r4` isn't updated and the second instruction loads garbage.

There are two fixes:
1. Change array morphing in `fgMorphArrayIndex()` to rearrange the array index
IR node creation to only create a byref pointer that is precise and no "intermediate"
byref pointers that don't represent the actual array element address being
computed.
2. Change `fgMoveOpsLeft()` to prevent the left-weighted reassociation optimization
`[byref]+ (ref [int]+ (int int)) =&gt; [byref]+ ([byref]+ (ref int) int)`. This
optimization creates "incorrect" byrefs that don't necessarily point within
the host object.

These fixes are all-platform.

Fixes #17517.

There are many many diffs. They perhaps surprisingly overwhelmingly positive.

For AMD64 SuperPMI the diffs are a 7.6% size win for 5194 functions! This
appears to be due to less code cloning and sometimes better optimization.

For ARM32 ngen-based desktop asm diffs it is a 0.30% improvement across all
framework assemblies. A lot of the diffs seem to be because we CSE the entire
array address offset expression not just the index expression.</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>dotnet-bot</Assignee>
    <CreatedAt>12/04/2018 3:59:00 AM +00:00</CreatedAt>
    <ClosedAt>14/04/2018 6:11:29 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17523</IssueLabelID>
    <Title>Fix random Segfaults on Ubuntu arm</Title>
    <Description>Fixes #17449 #16963

/cc @sandreenko</Description>
    <Title_Description>Fix random Segfaults on Ubuntu arm Fixes #17449 #16963

/cc @sandreenko</Title_Description>
    <Label>area-PAL</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>12/04/2018 1:33:47 AM +00:00</CreatedAt>
    <ClosedAt>14/04/2018 7:24:59 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17522</IssueLabelID>
    <Title>[WIP] test Egor's arm fix</Title>
    <Description>
    </Description>
    <Title_Description>[WIP] test Egor's arm fix </Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>12/04/2018 12:43:35 AM +00:00</CreatedAt>
    <ClosedAt>16/04/2018 8:12:14 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17521</IssueLabelID>
    <Title>Preserve VASigCookieReg across PInvokeStubWorker call</Title>
    <Description>I noticed something risky in this stub. We don't ensure that VASigCookieReg is preserved (if it's a temporary register we don't know what may happen to it in the call to the PInvokeStubWorker). Let's save it in a callee-saved register so that when we come back after stub generation we still have the correct value for the VASigCookie.

@janvorli PTAL</Description>
    <Title_Description>Preserve VASigCookieReg across PInvokeStubWorker call I noticed something risky in this stub. We don't ensure that VASigCookieReg is preserved (if it's a temporary register we don't know what may happen to it in the call to the PInvokeStubWorker). Let's save it in a callee-saved register so that when we come back after stub generation we still have the correct value for the VASigCookie.

@janvorli PTAL</Title_Description>
    <Label>arch-arm64</Label>
    <Assignee>janvorli</Assignee>
    <CreatedAt>11/04/2018 10:35:01 PM +00:00</CreatedAt>
    <ClosedAt>13/04/2018 12:25:40 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17519</IssueLabelID>
    <Title>[RyuJit] Allow TYP_BYREF folding.</Title>
    <Description>Right now `ValueNumStore::VNForFunc` has such code:
https://github.com/dotnet/coreclr/blob/b800f37c504d30c25bda3bdf148966fa91d17381/src/jit/valuenum.cpp#L1100-L1105

but there are no reasons why we can't support it it looks like we should just change this part:
https://github.com/dotnet/coreclr/blob/b800f37c504d30c25bda3bdf148966fa91d17381/src/jit/valuenum.cpp#L1812

From discussion in #17506 .



category:cq
theme:value-numbering
skill-level:intermediate
cost:small</Description>
    <Title_Description>[RyuJit] Allow TYP_BYREF folding. Right now `ValueNumStore::VNForFunc` has such code:
https://github.com/dotnet/coreclr/blob/b800f37c504d30c25bda3bdf148966fa91d17381/src/jit/valuenum.cpp#L1100-L1105

but there are no reasons why we can't support it it looks like we should just change this part:
https://github.com/dotnet/coreclr/blob/b800f37c504d30c25bda3bdf148966fa91d17381/src/jit/valuenum.cpp#L1812

From discussion in #17506 .



category:cq
theme:value-numbering
skill-level:intermediate
cost:small</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>11/04/2018 8:59:14 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17517</IssueLabelID>
    <Title>[RyuJIT/arm32][GCStress=C] jaggedarr_cs_do.cmd failure</Title>
    <Description>https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_windows_nt_gcstress0xc_tst/18/artifact/bin/tests/Windows_NT.arm.Checked/Smarty.run.0/Smarty.0.fail.smrt/*view*/
https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_windows_nt_gcstress0xc_jitstress1_tst/16/artifact/bin/tests/Windows_NT.arm.Checked/Smarty.run.0/Smarty.0.fail.smrt/*view*/

This failure is fairly consistent. I can reproduce it locally most of the time. Note that the test is seeded with a random number which doesn't help reproducibility.
</Description>
    <Title_Description>[RyuJIT/arm32][GCStress=C] jaggedarr_cs_do.cmd failure https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_windows_nt_gcstress0xc_tst/18/artifact/bin/tests/Windows_NT.arm.Checked/Smarty.run.0/Smarty.0.fail.smrt/*view*/
https://ci.dot.net/job/dotnet_coreclr/job/master/job/jitstress/job/arm_cross_checked_windows_nt_gcstress0xc_jitstress1_tst/16/artifact/bin/tests/Windows_NT.arm.Checked/Smarty.run.0/Smarty.0.fail.smrt/*view*/

This failure is fairly consistent. I can reproduce it locally most of the time. Note that the test is seeded with a random number which doesn't help reproducibility.
</Title_Description>
    <Label>arch-arm32</Label>
    <Assignee>BruceForstall</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17516</IssueLabelID>
    <Title>[1.1] Add packaging for Fedora28 and Debian9</Title>
    <Description>cc: @weshaggard @janvorli </Description>
    <Title_Description>[1.1] Add packaging for Fedora28 and Debian9 cc: @weshaggard @janvorli </Title_Description>
    <Label>
    </Label>
    <Assignee>ianhays</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17515</IssueLabelID>
    <Title>Mirror changes from dotnet/corert</Title>
    <Description>This PR contains mirrored changes from dotnet/corert


**Please REBASE this PR when merging**</Description>
    <Title_Description>Mirror changes from dotnet/corert This PR contains mirrored changes from dotnet/corert


**Please REBASE this PR when merging**</Title_Description>
    <Label>
    </Label>
    <Assignee>jkotas</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17513</IssueLabelID>
    <Title>[X86] Fix cross toolchain library paths</Title>
    <Description>	- fix internal tests building

@dotnet/arm32-contrib please review</Description>
    <Title_Description>[X86] Fix cross toolchain library paths 	- fix internal tests building

@dotnet/arm32-contrib please review</Title_Description>
    <Label>area-Infrastructure-coreclr</Label>
    <Assignee>sergign60</Assignee>
    <CreatedAt>11/04/2018 1:11:56 PM +00:00</CreatedAt>
    <ClosedAt>17/04/2018 1:14:22 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17512</IssueLabelID>
    <Title>Use string.IsNullOrEmpty to eliminate bounds check to first char</Title>
    <Description>```
Total bytes of diff: -649 (-0.02% of base)
    diff is an improvement.

Total byte diff includes 0 bytes from reconciling methods
        Base had    0 unique methods        0 unique bytes
        Diff had    0 unique methods        0 unique bytes

Top file improvements by size (bytes):
        -649 : System.Private.CoreLib.dasm (-0.02% of base)

1 total files with size differences (1 improved 0 regressed) 0 unchanged.

Top method improvements by size (bytes):
         -64 : System.Private.CoreLib.dasm - Win32Marshal:GetExceptionForWin32Error(intref):ref
         -57 : System.Private.CoreLib.dasm - TimeZoneInfo:GetLocalizedNamesByRegistryKey(refbyrefbyrefbyref)
         -32 : System.Private.CoreLib.dasm - String:Concat(refrefrefref):ref
         -32 : System.Private.CoreLib.dasm - Path:CombineInternal(refrefrefref):ref
         -24 : System.Private.CoreLib.dasm - String:Concat(refref):ref (2 methods)
         -24 : System.Private.CoreLib.dasm - String:Concat(refrefref):ref (2 methods)
         -24 : System.Private.CoreLib.dasm - Path:CombineInternal(refrefref):ref
         -24 : System.Private.CoreLib.dasm - CalendarData:.ctor(refushortbool):this
         -23 : System.Private.CoreLib.dasm - Environment:SetEnvironmentVariableCore(refref)
         -22 : System.Private.CoreLib.dasm - String:MakeSeparatorList(refbyrefbyref):this
         -17 : System.Private.CoreLib.dasm - PathInternal:NormalizeDirectorySeparators(ref):ref
         -16 : System.Private.CoreLib.dasm - Path:CombineInternal(refref):ref
         -16 : System.Private.CoreLib.dasm - PathInternal:EqualStartingCharacterCount(refrefbool):int
         -16 : System.Private.CoreLib.dasm - CalendarData:InitializeEraNames(refushort):this
         -16 : System.Private.CoreLib.dasm - CalendarData:InitializeAbbreviatedEraNames(refushort):this
         -16 : System.Private.CoreLib.dasm - ContractHelper:GetDisplayMessage(intrefref):ref
         -11 : System.Private.CoreLib.dasm - CoreLib:FixupCoreLibName(ref):ref
         -11 : System.Private.CoreLib.dasm - String:Concat(ref):ref (5 methods)
         -11 : System.Private.CoreLib.dasm - CultureData:get_SENGDISPLAYNAME():ref:this
         -11 : System.Private.CoreLib.dasm - CultureData:get_SNATIVEDISPLAYNAME():ref:this
          -8 : System.Private.CoreLib.dasm - AppContextDefaultValues:TryParseFrameworkName(refbyrefbyrefbyref):bool
          -8 : System.Private.CoreLib.dasm - Environment:ValidateVariableAndValue(refbyref)
          -8 : System.Private.CoreLib.dasm - ArgumentException:get_Message():ref:this
          -8 : System.Private.CoreLib.dasm - Contract:AssertMustUseRewriter(intref)
          -8 : System.Private.CoreLib.dasm - Contract:ReportFailure(intrefrefref)
          -8 : System.Private.CoreLib.dasm - EventPipeProviderConfiguration:.ctor(reflongint):this
          -8 : System.Private.CoreLib.dasm - EventPipeConfiguration:.ctor(refint):this
          -8 : System.Private.CoreLib.dasm - Path:GetRelativePath(refrefint):ref
          -8 : System.Private.CoreLib.dasm - PathInternal:EndsWithPeriodOrSpace(ref):bool
          -8 : System.Private.CoreLib.dasm - CultureInfo:get_Parent():ref:this
          -8 : System.Private.CoreLib.dasm - CultureData:GetCultureData(intbool):ref
          -8 : System.Private.CoreLib.dasm - CultureData:get_TimeSeparator():ref:this
          -8 : System.Private.CoreLib.dasm - CultureData:GetNFIValues(ref):this
          -8 : System.Private.CoreLib.dasm - NumberFormatInfo:.ctor(ref):this
          -8 : System.Private.CoreLib.dasm - SystemTypeMarshaler:ConvertToManaged(longbyref)
          -8 : System.Private.CoreLib.dasm - StringBuilder:Insert(intrefint):ref:this
          -8 : System.Private.CoreLib.dasm - AssemblyLoadContext:ValidateAssemblyNameWithSimpleName(refref):ref:this
          -8 : System.Private.CoreLib.dasm - ExternalException:ToString():ref:this
          -8 : System.Private.CoreLib.dasm - ContractHelper:TriggerFailure(intrefrefrefref)
          -8 : System.Private.CoreLib.dasm - TypeForwardedFromAttribute:.ctor(ref):this
          -4 : System.Private.CoreLib.dasm - ResourceManager:GetStringFromPRI(refrefref):ref:this
          -2 : System.Private.CoreLib.dasm - String:IsNullOrEmpty(ref):bool
          -2 : System.Private.CoreLib.dasm - Environment:SetEnvironmentVariableCore(refrefint)
          -2 : System.Private.CoreLib.dasm - TimeZoneInfo:TryGetLocalizedNameByMuiNativeResource(ref):ref
          -2 : System.Private.CoreLib.dasm - CultureData:GetCultureDataForRegion(refbool):ref
          -2 : System.Private.CoreLib.dasm - CultureData:GetCultureData(refbool):ref
          -2 : System.Private.CoreLib.dasm - CultureData:get_SLOCALIZEDDISPLAYNAME():ref:this
          -2 : System.Private.CoreLib.dasm - CultureData:get_IsInvariantCulture():bool:this
          -2 : System.Private.CoreLib.dasm - Assembly:LoadFromResolveHandler(refref):ref
          -2 : System.Private.CoreLib.dasm - WindowsRuntimeMetadata:OnDesignerNamespaceResolveEvent(refref):ref

50 total methods with size differences (50 improved 0 regressed) 17247 unchanged.
```

From https://github.com/aspnet/KestrelHttpServer/pull/2347#discussion_r180545535

```
public static bool StartsWithBracket(string hostText)
{
    if (hostText == null || 0u &gt;= (uint)hostText.Length)
    {
        return false;
    }

    var firstChar = hostText[0];
    if (firstChar == '[')
    {
        return true;
    }
    
    return false;
}

; Desktop CLR v4.7.2563.00 (clr.dll) on amd64.

Program.StartsWithBracket(System.String)
    L0000: test rcx rcx
    L0003: jz L000c
    L0005: mov eax [rcx+0x8]
    L0008: test eax eax
    L000a: jnz L000f
    L000c: xor eax eax
    L000e: ret
    L000f: cmp word [rcx+0xc] 0x5b
    L0014: jnz L001c
    L0016: mov eax 0x1
    L001b: ret
    L001c: xor eax eax
    L001e: ret
```
vs
```
public static bool StartsWithBracket(string hostText)
{
    if (hostText == null || hostText.Length == 0)
    {
        return false;
    }

    var firstChar = hostText[0];
    if (firstChar == '[')
    {
        return true;
    }
    
    return false;
}

; Desktop CLR v4.7.2563.00 (clr.dll) on amd64.

Program.StartsWithBracket(System.String)
    L0000: sub rsp 0x28
    L0004: test rcx rcx
    L0007: jz L0010
    L0009: mov edx [rcx+0x8]
    L000c: test edx edx
    L000e: jnz L0017
    L0010: xor eax eax
    L0012: add rsp 0x28
    L0016: ret
    L0017: cmp edx 0x0
    L001a: jbe L0034
    L001c: cmp word [rcx+0xc] 0x5b
    L0021: jnz L002d
    L0023: mov eax 0x1
    L0028: add rsp 0x28
    L002c: ret
    L002d: xor eax eax
    L002f: add rsp 0x28
    L0033: ret
    L0034: call 0x7ffaff4223c0
    L0039: int3
```</Description>
    <Title_Description>Use string.IsNullOrEmpty to eliminate bounds check to first char ```
Total bytes of diff: -649 (-0.02% of base)
    diff is an improvement.

Total byte diff includes 0 bytes from reconciling methods
        Base had    0 unique methods        0 unique bytes
        Diff had    0 unique methods        0 unique bytes

Top file improvements by size (bytes):
        -649 : System.Private.CoreLib.dasm (-0.02% of base)

1 total files with size differences (1 improved 0 regressed) 0 unchanged.

Top method improvements by size (bytes):
         -64 : System.Private.CoreLib.dasm - Win32Marshal:GetExceptionForWin32Error(intref):ref
         -57 : System.Private.CoreLib.dasm - TimeZoneInfo:GetLocalizedNamesByRegistryKey(refbyrefbyrefbyref)
         -32 : System.Private.CoreLib.dasm - String:Concat(refrefrefref):ref
         -32 : System.Private.CoreLib.dasm - Path:CombineInternal(refrefrefref):ref
         -24 : System.Private.CoreLib.dasm - String:Concat(refref):ref (2 methods)
         -24 : System.Private.CoreLib.dasm - String:Concat(refrefref):ref (2 methods)
         -24 : System.Private.CoreLib.dasm - Path:CombineInternal(refrefref):ref
         -24 : System.Private.CoreLib.dasm - CalendarData:.ctor(refushortbool):this
         -23 : System.Private.CoreLib.dasm - Environment:SetEnvironmentVariableCore(refref)
         -22 : System.Private.CoreLib.dasm - String:MakeSeparatorList(refbyrefbyref):this
         -17 : System.Private.CoreLib.dasm - PathInternal:NormalizeDirectorySeparators(ref):ref
         -16 : System.Private.CoreLib.dasm - Path:CombineInternal(refref):ref
         -16 : System.Private.CoreLib.dasm - PathInternal:EqualStartingCharacterCount(refrefbool):int
         -16 : System.Private.CoreLib.dasm - CalendarData:InitializeEraNames(refushort):this
         -16 : System.Private.CoreLib.dasm - CalendarData:InitializeAbbreviatedEraNames(refushort):this
         -16 : System.Private.CoreLib.dasm - ContractHelper:GetDisplayMessage(intrefref):ref
         -11 : System.Private.CoreLib.dasm - CoreLib:FixupCoreLibName(ref):ref
         -11 : System.Private.CoreLib.dasm - String:Concat(ref):ref (5 methods)
         -11 : System.Private.CoreLib.dasm - CultureData:get_SENGDISPLAYNAME():ref:this
         -11 : System.Private.CoreLib.dasm - CultureData:get_SNATIVEDISPLAYNAME():ref:this
          -8 : System.Private.CoreLib.dasm - AppContextDefaultValues:TryParseFrameworkName(refbyrefbyrefbyref):bool
          -8 : System.Private.CoreLib.dasm - Environment:ValidateVariableAndValue(refbyref)
          -8 : System.Private.CoreLib.dasm - ArgumentException:get_Message():ref:this
          -8 : System.Private.CoreLib.dasm - Contract:AssertMustUseRewriter(intref)
          -8 : System.Private.CoreLib.dasm - Contract:ReportFailure(intrefrefref)
          -8 : System.Private.CoreLib.dasm - EventPipeProviderConfiguration:.ctor(reflongint):this
          -8 : System.Private.CoreLib.dasm - EventPipeConfiguration:.ctor(refint):this
          -8 : System.Private.CoreLib.dasm - Path:GetRelativePath(refrefint):ref
          -8 : System.Private.CoreLib.dasm - PathInternal:EndsWithPeriodOrSpace(ref):bool
          -8 : System.Private.CoreLib.dasm - CultureInfo:get_Parent():ref:this
          -8 : System.Private.CoreLib.dasm - CultureData:GetCultureData(intbool):ref
          -8 : System.Private.CoreLib.dasm - CultureData:get_TimeSeparator():ref:this
          -8 : System.Private.CoreLib.dasm - CultureData:GetNFIValues(ref):this
          -8 : System.Private.CoreLib.dasm - NumberFormatInfo:.ctor(ref):this
          -8 : System.Private.CoreLib.dasm - SystemTypeMarshaler:ConvertToManaged(longbyref)
          -8 : System.Private.CoreLib.dasm - StringBuilder:Insert(intrefint):ref:this
          -8 : System.Private.CoreLib.dasm - AssemblyLoadContext:ValidateAssemblyNameWithSimpleName(refref):ref:this
          -8 : System.Private.CoreLib.dasm - ExternalException:ToString():ref:this
          -8 : System.Private.CoreLib.dasm - ContractHelper:TriggerFailure(intrefrefrefref)
          -8 : System.Private.CoreLib.dasm - TypeForwardedFromAttribute:.ctor(ref):this
          -4 : System.Private.CoreLib.dasm - ResourceManager:GetStringFromPRI(refrefref):ref:this
          -2 : System.Private.CoreLib.dasm - String:IsNullOrEmpty(ref):bool
          -2 : System.Private.CoreLib.dasm - Environment:SetEnvironmentVariableCore(refrefint)
          -2 : System.Private.CoreLib.dasm - TimeZoneInfo:TryGetLocalizedNameByMuiNativeResource(ref):ref
          -2 : System.Private.CoreLib.dasm - CultureData:GetCultureDataForRegion(refbool):ref
          -2 : System.Private.CoreLib.dasm - CultureData:GetCultureData(refbool):ref
          -2 : System.Private.CoreLib.dasm - CultureData:get_SLOCALIZEDDISPLAYNAME():ref:this
          -2 : System.Private.CoreLib.dasm - CultureData:get_IsInvariantCulture():bool:this
          -2 : System.Private.CoreLib.dasm - Assembly:LoadFromResolveHandler(refref):ref
          -2 : System.Private.CoreLib.dasm - WindowsRuntimeMetadata:OnDesignerNamespaceResolveEvent(refref):ref

50 total methods with size differences (50 improved 0 regressed) 17247 unchanged.
```

From https://github.com/aspnet/KestrelHttpServer/pull/2347#discussion_r180545535

```
public static bool StartsWithBracket(string hostText)
{
    if (hostText == null || 0u &gt;= (uint)hostText.Length)
    {
        return false;
    }

    var firstChar = hostText[0];
    if (firstChar == '[')
    {
        return true;
    }
    
    return false;
}

; Desktop CLR v4.7.2563.00 (clr.dll) on amd64.

Program.StartsWithBracket(System.String)
    L0000: test rcx rcx
    L0003: jz L000c
    L0005: mov eax [rcx+0x8]
    L0008: test eax eax
    L000a: jnz L000f
    L000c: xor eax eax
    L000e: ret
    L000f: cmp word [rcx+0xc] 0x5b
    L0014: jnz L001c
    L0016: mov eax 0x1
    L001b: ret
    L001c: xor eax eax
    L001e: ret
```
vs
```
public static bool StartsWithBracket(string hostText)
{
    if (hostText == null || hostText.Length == 0)
    {
        return false;
    }

    var firstChar = hostText[0];
    if (firstChar == '[')
    {
        return true;
    }
    
    return false;
}

; Desktop CLR v4.7.2563.00 (clr.dll) on amd64.

Program.StartsWithBracket(System.String)
    L0000: sub rsp 0x28
    L0004: test rcx rcx
    L0007: jz L0010
    L0009: mov edx [rcx+0x8]
    L000c: test edx edx
    L000e: jnz L0017
    L0010: xor eax eax
    L0012: add rsp 0x28
    L0016: ret
    L0017: cmp edx 0x0
    L001a: jbe L0034
    L001c: cmp word [rcx+0xc] 0x5b
    L0021: jnz L002d
    L0023: mov eax 0x1
    L0028: add rsp 0x28
    L002c: ret
    L002d: xor eax eax
    L002f: add rsp 0x28
    L0033: ret
    L0034: call 0x7ffaff4223c0
    L0039: int3
```</Title_Description>
    <Label>area-System.Runtime</Label>
    <Assignee>AndyAyersMS</Assignee>
    <CreatedAt>11/04/2018 11:35:35 AM +00:00</CreatedAt>
    <ClosedAt>12/04/2018 9:08:05 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17510</IssueLabelID>
    <Title>Korean Lunisolar Calendar conversion table incorrectly mixes Julian and Gregorian date information</Title>
    <Description>The [Korean Lunisolar Calendar](https://github.com/dotnet/coreclr/blob/da8b7181dbe362fbfe64c7ef72ff3a4a7db68f24/src/mscorlib/shared/System/Globalization/KoreanLunisolarCalendar.cs) uses a table of data for conversion between Korean lunisolar dates and Gregorian dates.  The table contains a mixture of Julian and Gregorian date information but should only contain Gregorian date information.

On such entry is:
`1391    */{    0        2        5        25904    }/*    29    30    30    29    29    30    29    30    29    29    30    30    0    354`

This is interpreted by the code as:
Y1391-M1-D1 of Korean lunisolar calendar began on 5 Feb 1391 (Gregorian).

However Y1391-M1-D1 (lunisolar) began on 13 Feb 1391 (**Gregorian**) or 05 Feb 1391 (Julian).  The entry incorrectly uses the day and month from the Julian date and it should use day and month from the Gregorian one.

Further analysis shows that all lines in the table prior to 1582 incorrectly give the first day of the lunisolar year in the **Julian** calendar _rather than the Gregorian calendar_.  Since the conversion routine takes a Gregorian day month and year for conversion into the lunisolar day month and year any conversions to dates with a solar year before 1583 are incorrect.

The discrepancy likely arises due to the fact that many reference tables switch from using the Julian calendar to the Gregorian calendar in year 1582 (04 Oct 1582 (Julian) was followed by 15 Oct 1582 (Gregorian)).  One such table is provided by the [Korea Astronomy and Space Science In-
stitute (KASI)](https://astro.kasi.re.kr:444/life/pageView/5).  Here dates prior to Y1582-M09-D18 (lunisolar) are indexed using the Julian calendar and those after Y1582-M09-D19 (lunisolar) are indexed using the Gregorian calendar.

There are also anomalous entries in the .NET table when compared to KASI.
The first day of the year is incorrect for 1587 1648 and 1754.  Most notably the entry for 1587 gives 09 Mar 1587 (Gregorian) as the start date of lunisolar year (this is the first day Y1587-M02-D01 (lunisolar) instead of Y1587-M01-D01 (lunisolar)).  The individual month lengths differ from KASI in 1586 1587 1659 1692 1753 and 1754.

The table used in the .NET class has been corrected here:
[correct Korean lunisolar .NET table.txt](https://github.com/dotnet/coreclr/files/1898816/correct.Korean.lunisolar.NET.table.txt)

Reference data: 
[Korea Astronomy and Space Science In-
stitute (KASI)](https://astro.kasi.re.kr:444/life/pageView/5).
[VERIFICATION OF THE CALENDAR DAYS OF THE JOSEON DYNASTY](http://dx.doi.org/10.5303/JKAS.2012.45.4.85)
[KoreanLunisolarCalendar.cs](https://github.com/dotnet/coreclr/blob/da8b7181dbe362fbfe64c7ef72ff3a4a7db68f24/src/mscorlib/shared/System/Globalization/KoreanLunisolarCalendar.cs)</Description>
    <Title_Description>Korean Lunisolar Calendar conversion table incorrectly mixes Julian and Gregorian date information The [Korean Lunisolar Calendar](https://github.com/dotnet/coreclr/blob/da8b7181dbe362fbfe64c7ef72ff3a4a7db68f24/src/mscorlib/shared/System/Globalization/KoreanLunisolarCalendar.cs) uses a table of data for conversion between Korean lunisolar dates and Gregorian dates.  The table contains a mixture of Julian and Gregorian date information but should only contain Gregorian date information.

On such entry is:
`1391    */{    0        2        5        25904    }/*    29    30    30    29    29    30    29    30    29    29    30    30    0    354`

This is interpreted by the code as:
Y1391-M1-D1 of Korean lunisolar calendar began on 5 Feb 1391 (Gregorian).

However Y1391-M1-D1 (lunisolar) began on 13 Feb 1391 (**Gregorian**) or 05 Feb 1391 (Julian).  The entry incorrectly uses the day and month from the Julian date and it should use day and month from the Gregorian one.

Further analysis shows that all lines in the table prior to 1582 incorrectly give the first day of the lunisolar year in the **Julian** calendar _rather than the Gregorian calendar_.  Since the conversion routine takes a Gregorian day month and year for conversion into the lunisolar day month and year any conversions to dates with a solar year before 1583 are incorrect.

The discrepancy likely arises due to the fact that many reference tables switch from using the Julian calendar to the Gregorian calendar in year 1582 (04 Oct 1582 (Julian) was followed by 15 Oct 1582 (Gregorian)).  One such table is provided by the [Korea Astronomy and Space Science In-
stitute (KASI)](https://astro.kasi.re.kr:444/life/pageView/5).  Here dates prior to Y1582-M09-D18 (lunisolar) are indexed using the Julian calendar and those after Y1582-M09-D19 (lunisolar) are indexed using the Gregorian calendar.

There are also anomalous entries in the .NET table when compared to KASI.
The first day of the year is incorrect for 1587 1648 and 1754.  Most notably the entry for 1587 gives 09 Mar 1587 (Gregorian) as the start date of lunisolar year (this is the first day Y1587-M02-D01 (lunisolar) instead of Y1587-M01-D01 (lunisolar)).  The individual month lengths differ from KASI in 1586 1587 1659 1692 1753 and 1754.

The table used in the .NET class has been corrected here:
[correct Korean lunisolar .NET table.txt](https://github.com/dotnet/coreclr/files/1898816/correct.Korean.lunisolar.NET.table.txt)

Reference data: 
[Korea Astronomy and Space Science In-
stitute (KASI)](https://astro.kasi.re.kr:444/life/pageView/5).
[VERIFICATION OF THE CALENDAR DAYS OF THE JOSEON DYNASTY](http://dx.doi.org/10.5303/JKAS.2012.45.4.85)
[KoreanLunisolarCalendar.cs](https://github.com/dotnet/coreclr/blob/da8b7181dbe362fbfe64c7ef72ff3a4a7db68f24/src/mscorlib/shared/System/Globalization/KoreanLunisolarCalendar.cs)</Title_Description>
    <Label>area-System.Globalization</Label>
    <Assignee>tarekgh</Assignee>
    <CreatedAt>11/04/2018 10:05:42 AM +00:00</CreatedAt>
    <ClosedAt>16/04/2018 6:06:08 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17508</IssueLabelID>
    <Title>[Arm64] Fix WorkStealingQueue memory ordering</Title>
    <Description>Fixes #17178

Audited and reworked WorkStealingQueue to take into account multi-threaded memory ordering issues encountered on high core count arm64 testing.

This fixes easily reproducible errors in `System.Threading.Tasks.Tests` `System.Threading.Channel.Tests` and `System.Threading.Tasks.Dataflow.Tests`.  The same issue was making the linux-arm64 SDK unusable.

This is very important for linux-arm64 for the 2.1 release.  I am very happy to put the patch inside a `#if ARM64` if this is deemed too risky for other platforms.  (I suspect arm32 needs a similar/identical patch).

@BruceForstall FYI</Description>
    <Title_Description>[Arm64] Fix WorkStealingQueue memory ordering Fixes #17178

Audited and reworked WorkStealingQueue to take into account multi-threaded memory ordering issues encountered on high core count arm64 testing.

This fixes easily reproducible errors in `System.Threading.Tasks.Tests` `System.Threading.Channel.Tests` and `System.Threading.Tasks.Dataflow.Tests`.  The same issue was making the linux-arm64 SDK unusable.

This is very important for linux-arm64 for the 2.1 release.  I am very happy to put the patch inside a `#if ARM64` if this is deemed too risky for other platforms.  (I suspect arm32 needs a similar/identical patch).

@BruceForstall FYI</Title_Description>
    <Label>* NO MERGE *</Label>
    <Assignee>dotnet-bot</Assignee>
    <CreatedAt>11/04/2018 3:11:20 AM +00:00</CreatedAt>
    <ClosedAt>15/04/2018 11:28:30 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17506</IssueLabelID>
    <Title>Fix Valuenum:EvalFuncForConstantArgs</Title>
    <Description>For such tree:
```
N009 (  1  1) [008525] ------------              |        /--*  CNS_INT   long   12 field offset Fseq[_firstChar]
N010 (  5  4) [008526] ------------              |     /--*  ADD       byref
N008 (  3  2) [008524] ------------              |     |  \--*  LCL_VAR   ref    V43 tmp35        u:4 (last use)
```
where `LCL_VAR   ref    V43` is known to be a constant RyuJit calculated Vn as Null:
`N010 [008526]   ADD       =&gt; $VN.Null`
 and merged it with other expressions with Null VN. Because constants were different in each case it caused bugs:

```
N003 (  1  1) [008534] ------------              |  |  /--*  CNS_INT   long   8 field offset Fseq[_stringLength]
N004 (  4 11) [008535] -------N----              |  \--*  ADD       byref
N002 (  3 10) [008537] ------------              |     \--*  NOP       ref
N001 (  3 10) [008536] ------------              |        \--*  CNS_INT(h) ref    0x421150 [ICON_STR_HDL]
N004 [008535]   ADD       =&gt; $VN.Null
```
`VN  [008535] == VN  [008526] == Null` so all these constants were replaced with the first tree that had `VN == Null`:
```
VN based copy assertion for [004523] V16 @00000000 by [008560] V24 @00000000.
VN based copy assertion for [008648] V41 @00000000 by [008560] V24 @00000000
etc.
```

The original code was added in CS 946058 with other assert fixes and looks like we were lucky not to hit this issue for several years because CoreCLR doesn't produce constants with 'TYP_BYREF' (I think).

&gt; // We don't want to fold expressions that produce TYP_BYREF 

I do not see any reasons why we should not fold them but right now this code:
https://github.com/dotnet/coreclr/blob/master/src/jit/valuenum.cpp#L1813-L1817

doesn't not expect LONG add that produces BYREF and because our VN is very fragile we do not want to change it before the release **do we want to have an issue to fix that later?**

The change will fix (some text to prevent closing this issue right after the merge) dotnet/corert#5661 after RyuJit version update.
</Description>
    <Title_Description>Fix Valuenum:EvalFuncForConstantArgs For such tree:
```
N009 (  1  1) [008525] ------------              |        /--*  CNS_INT   long   12 field offset Fseq[_firstChar]
N010 (  5  4) [008526] ------------              |     /--*  ADD       byref
N008 (  3  2) [008524] ------------              |     |  \--*  LCL_VAR   ref    V43 tmp35        u:4 (last use)
```
where `LCL_VAR   ref    V43` is known to be a constant RyuJit calculated Vn as Null:
`N010 [008526]   ADD       =&gt; $VN.Null`
 and merged it with other expressions with Null VN. Because constants were different in each case it caused bugs:

```
N003 (  1  1) [008534] ------------              |  |  /--*  CNS_INT   long   8 field offset Fseq[_stringLength]
N004 (  4 11) [008535] -------N----              |  \--*  ADD       byref
N002 (  3 10) [008537] ------------              |     \--*  NOP       ref
N001 (  3 10) [008536] ------------              |        \--*  CNS_INT(h) ref    0x421150 [ICON_STR_HDL]
N004 [008535]   ADD       =&gt; $VN.Null
```
`VN  [008535] == VN  [008526] == Null` so all these constants were replaced with the first tree that had `VN == Null`:
```
VN based copy assertion for [004523] V16 @00000000 by [008560] V24 @00000000.
VN based copy assertion for [008648] V41 @00000000 by [008560] V24 @00000000
etc.
```

The original code was added in CS 946058 with other assert fixes and looks like we were lucky not to hit this issue for several years because CoreCLR doesn't produce constants with 'TYP_BYREF' (I think).

&gt; // We don't want to fold expressions that produce TYP_BYREF 

I do not see any reasons why we should not fold them but right now this code:
https://github.com/dotnet/coreclr/blob/master/src/jit/valuenum.cpp#L1813-L1817

doesn't not expect LONG add that produces BYREF and because our VN is very fragile we do not want to change it before the release **do we want to have an issue to fix that later?**

The change will fix (some text to prevent closing this issue right after the merge) dotnet/corert#5661 after RyuJit version update.
</Title_Description>
    <Label>area-CodeGen</Label>
    <Assignee>sandreenko</Assignee>
    <CreatedAt>10/04/2018 11:34:42 PM +00:00</CreatedAt>
    <ClosedAt>11/04/2018 8:16:23 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17505</IssueLabelID>
    <Title>Enable support DllImport a native assembly whose name contains '.'</Title>
    <Description>Currently In Windows if the name your native dll specified in DllImport contains '.' such as Test.Foo DllImport will only search for file Test.Foo and it won't search for file Test.Foo.dll

The fix is to append ".dll" if the native dll name specified in DllImport doesn't contain ".dll" .

Fix #17150</Description>
    <Title_Description>Enable support DllImport a native assembly whose name contains '.' Currently In Windows if the name your native dll specified in DllImport contains '.' such as Test.Foo DllImport will only search for file Test.Foo and it won't search for file Test.Foo.dll

The fix is to append ".dll" if the native dll name specified in DllImport doesn't contain ".dll" .

Fix #17150</Title_Description>
    <Label>area-Interop</Label>
    <Assignee>dotnet-bot</Assignee>
    <CreatedAt>10/04/2018 11:33:55 PM +00:00</CreatedAt>
    <ClosedAt>17/04/2018 5:10:30 AM +00:00</ClosedAt>
  </IssueDetail>
</IssueDetails>