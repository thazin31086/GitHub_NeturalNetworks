<IssueDetails>
  <IssueDetail>
    <IssueLabelID>153</IssueLabelID>
    <Title>Assertion failed: `it!=PAGNodeToActualParmMap.end() &amp;&amp; "acutal parameter VFG node can not be found??"'</Title>
    <Description>While performing a flow-sensitive analysis of the attached C program SVF-1.7 (commit# 878c3b1eca06f569760ee312996b623986d3525d) fails with the following assertion:

```
$ wpa -fspta -print-pts svf_crash.bc

wpa: svf/include/Util/VFG.h:186: ActualParmVFGNode* VFG::getActualParmVFGNode(const PAGNode* CallSite) const: Assertion `it!=PAGNodeToActualParmMap.end() &amp;&amp; "acutal parameter VFG node can not be found??"' failed.
```



[svf_crash.zip](https://github.com/SVF-tools/SVF/files/3699920/svf_crash.zip)
</Description>
    <Title_Description>Assertion failed: `it!=PAGNodeToActualParmMap.end() &amp;&amp; "acutal parameter VFG node can not be found??"' While performing a flow-sensitive analysis of the attached C program SVF-1.7 (commit# 878c3b1eca06f569760ee312996b623986d3525d) fails with the following assertion:

```
$ wpa -fspta -print-pts svf_crash.bc

wpa: svf/include/Util/VFG.h:186: ActualParmVFGNode* VFG::getActualParmVFGNode(const PAGNode* CallSite) const: Assertion `it!=PAGNodeToActualParmMap.end() &amp;&amp; "acutal parameter VFG node can not be found??"' failed.
```



[svf_crash.zip](https://github.com/SVF-tools/SVF/files/3699920/svf_crash.zip)
</Title_Description>
    <Label>bug</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>7/10/2019 10:43:06 PM +00:00</CreatedAt>
    <ClosedAt>8/10/2019 3:25:17 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>150</IssueLabelID>
    <Title>SVF crashes while writing results of Andersen analysis</Title>
    <Description>While writing Andersen analysis result to a file SVF hits the assertion and crashes.

```
$ ./wpa -ander -write-ander=write_ander.txt test.bc

Storing pointer analysis results to 'write_ander.txt'...wpa: svf/include/MemoryModel/GenericGraph.h:338: GenericGraph&lt;NodeTy EdgeTy&gt;::NodeType* GenericGraph&lt;NodeTy EdgeTy&gt;::getGNode(NodeID) const [with NodeTy = PAGNode; EdgeTy = PAGEdge; GenericGraph&lt;NodeTy EdgeTy&gt;::NodeType = PAGNode; NodeID = unsigned int]: Assertion `it != IDToNodeMap.end() &amp;&amp; "Node not found!"' failed.
Aborted (core dumped)
```

In `PointerAnalysis.cpp:writeToFile()` when SVF tries to write PAG offset nodes to the file there are 163 total nodes in the test case (attached). However the last one has a large `nodeID` (`720000`) which looks like a junk value. Further down in `GepObjPN *gepObjPN = SVFUtil::dyn_cast&lt;GepObjPN&gt;(pag-&gt;getPAGNode(i))` it fails to find the node when the index (`162`) is used to retrieve the node instead of the `nodeID` (`720000`). Upon further investigation I noticed the node in question is inserted in the PAG during `WPASolver.h:solve()` call.

The source code and the bitcode of the offending test case are attached.

[test.zip](https://github.com/SVF-tools/SVF/files/3636738/test.zip)
</Description>
    <Title_Description>SVF crashes while writing results of Andersen analysis While writing Andersen analysis result to a file SVF hits the assertion and crashes.

```
$ ./wpa -ander -write-ander=write_ander.txt test.bc

Storing pointer analysis results to 'write_ander.txt'...wpa: svf/include/MemoryModel/GenericGraph.h:338: GenericGraph&lt;NodeTy EdgeTy&gt;::NodeType* GenericGraph&lt;NodeTy EdgeTy&gt;::getGNode(NodeID) const [with NodeTy = PAGNode; EdgeTy = PAGEdge; GenericGraph&lt;NodeTy EdgeTy&gt;::NodeType = PAGNode; NodeID = unsigned int]: Assertion `it != IDToNodeMap.end() &amp;&amp; "Node not found!"' failed.
Aborted (core dumped)
```

In `PointerAnalysis.cpp:writeToFile()` when SVF tries to write PAG offset nodes to the file there are 163 total nodes in the test case (attached). However the last one has a large `nodeID` (`720000`) which looks like a junk value. Further down in `GepObjPN *gepObjPN = SVFUtil::dyn_cast&lt;GepObjPN&gt;(pag-&gt;getPAGNode(i))` it fails to find the node when the index (`162`) is used to retrieve the node instead of the `nodeID` (`720000`). Upon further investigation I noticed the node in question is inserted in the PAG during `WPASolver.h:solve()` call.

The source code and the bitcode of the offending test case are attached.

[test.zip](https://github.com/SVF-tools/SVF/files/3636738/test.zip)
</Title_Description>
    <Label>bug</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>20/09/2019 4:00:19 PM +00:00</CreatedAt>
    <ClosedAt>4/10/2019 6:50:46 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>148</IssueLabelID>
    <Title>Question on usage of pointer analysis</Title>
    <Description>Hi!

Thanks for sharing and maintaining such a great project!

I'm trying to use Andersen's analysis (DiffWave) in order to find aliases between pointer operands. Now there are obvious aliases that I cannot be able to detect and I highly suspect that I'm just using the analysis in a wrong way. I've read related issues and have been debugging but I didn't get to the correct alias info yet so I figured it might be faster to ask you directly.

This is an excerpt of the piece of code I'm currently analyzing:

```
  %76 = load %"class.soplex::SVector"** %"class.soplex::SVector"*** %data.i109 align 8 !dbg !4458
  %arrayidx.i111 = getelementptr inbounds %"class.soplex::SVector"* %"class.soplex::SVector"** %76 i64 %idxprom.i149 !dbg !4458
  store %"class.soplex::SVector"* %cond-lvalue.i141 %"class.soplex::SVector"** %arrayidx.i111 align 8 !dbg !4459
// .. some irrelevant code (debug info and ++i) ..
  %77 = load %"class.soplex::SVector"** %"class.soplex::SVector"*** %data.i109 align 8 !dbg !4464
  %arrayidx.i108 = getelementptr inbounds %"class.soplex::SVector"* %"class.soplex::SVector"** %77 i64 %idxprom.i149 !dbg !4464
  %78 = load %"class.soplex::SVector"* %"class.soplex::SVector"** %arrayidx.i108 align 8 !dbg !4465
```

The store and the load to %78 should clearly alias since the store is updating the value that is loaded afterwards. However I always get NoAlias.

I'm using Andersen in the following way using it with opt and the -ander flag on my LLVM IR:
```c++
WPAPass *wpa = new WPAPass();
wpa-&gt;runOnModule(&amp;M);
Value *LPointer = Load-&gt;getPointerOperand();
Value *SPointer = Store-&gt;getPointerOperand();
wpa-&gt;alias(LPointer SPointer) // always gives me NoAlias
```
I plotted the PAG and it is reflected there that they are linked to each other (see [pag](https://gofile.io/?c=qnuE8J) here). Looking at their (LPointer SPointer) points-to-set (given the node ids in the pag) they are completely empty. 

What am I doing wrong?

I'm currently using the latest version of SVF on LLVM 8.0 (I made a few *syntactical* changes to be updated to the latest LLVM not anything more than that). I saw that the DominanceFrontier is used in some tools which doesn't exist in the latest LLVM anymore but I'm only using the PointerAnalysis itself which shouldn't be affected.

Best

Kim

</Description>
    <Title_Description>Question on usage of pointer analysis Hi!

Thanks for sharing and maintaining such a great project!

I'm trying to use Andersen's analysis (DiffWave) in order to find aliases between pointer operands. Now there are obvious aliases that I cannot be able to detect and I highly suspect that I'm just using the analysis in a wrong way. I've read related issues and have been debugging but I didn't get to the correct alias info yet so I figured it might be faster to ask you directly.

This is an excerpt of the piece of code I'm currently analyzing:

```
  %76 = load %"class.soplex::SVector"** %"class.soplex::SVector"*** %data.i109 align 8 !dbg !4458
  %arrayidx.i111 = getelementptr inbounds %"class.soplex::SVector"* %"class.soplex::SVector"** %76 i64 %idxprom.i149 !dbg !4458
  store %"class.soplex::SVector"* %cond-lvalue.i141 %"class.soplex::SVector"** %arrayidx.i111 align 8 !dbg !4459
// .. some irrelevant code (debug info and ++i) ..
  %77 = load %"class.soplex::SVector"** %"class.soplex::SVector"*** %data.i109 align 8 !dbg !4464
  %arrayidx.i108 = getelementptr inbounds %"class.soplex::SVector"* %"class.soplex::SVector"** %77 i64 %idxprom.i149 !dbg !4464
  %78 = load %"class.soplex::SVector"* %"class.soplex::SVector"** %arrayidx.i108 align 8 !dbg !4465
```

The store and the load to %78 should clearly alias since the store is updating the value that is loaded afterwards. However I always get NoAlias.

I'm using Andersen in the following way using it with opt and the -ander flag on my LLVM IR:
```c++
WPAPass *wpa = new WPAPass();
wpa-&gt;runOnModule(&amp;M);
Value *LPointer = Load-&gt;getPointerOperand();
Value *SPointer = Store-&gt;getPointerOperand();
wpa-&gt;alias(LPointer SPointer) // always gives me NoAlias
```
I plotted the PAG and it is reflected there that they are linked to each other (see [pag](https://gofile.io/?c=qnuE8J) here). Looking at their (LPointer SPointer) points-to-set (given the node ids in the pag) they are completely empty. 

What am I doing wrong?

I'm currently using the latest version of SVF on LLVM 8.0 (I made a few *syntactical* changes to be updated to the latest LLVM not anything more than that). I saw that the DominanceFrontier is used in some tools which doesn't exist in the latest LLVM anymore but I'm only using the PointerAnalysis itself which shouldn't be affected.

Best

Kim

</Title_Description>
    <Label>question</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>5/09/2019 7:42:31 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>147</IssueLabelID>
    <Title>Unable to build getting error: llvm/IR/Attributes.inc: No such file or directory</Title>
    <Description>Getting this below error while trying build SVF from source by following the instruction from [Setup-Guide-(CMake)](https://github.com/SVF-tools/SVF/wiki/Setup-Guide-(CMake)).

using gcc 9.1.0
cmake 3.15.2
Also  built LLVM-7.0.0 clang-7.0.0 and added the paths for it.

```
In file included from /llvm-7.0.0.src/include/llvm/IR/Instructions.h:27
                 from /SVF/include/Util/BasicTypes.h:39
                 from /SVF/include/Util/SVFModule.h:33
                 from /SVF/include/Util/SVFUtil.h:33
                 from /SVF/lib/Util/SVFUtil.cpp:30:
/llvm-7.0.0.src/include/llvm/IR/Attributes.h:74:14: fatal error: llvm/IR/Attributes.inc: No such file or directory
   74 |     #include "llvm/IR/Attributes.inc"
      |              ^~~~~~~~~~~~~~~~~~~~~~~~
compilation terminated.
```
</Description>
    <Title_Description>Unable to build getting error: llvm/IR/Attributes.inc: No such file or directory Getting this below error while trying build SVF from source by following the instruction from [Setup-Guide-(CMake)](https://github.com/SVF-tools/SVF/wiki/Setup-Guide-(CMake)).

using gcc 9.1.0
cmake 3.15.2
Also  built LLVM-7.0.0 clang-7.0.0 and added the paths for it.

```
In file included from /llvm-7.0.0.src/include/llvm/IR/Instructions.h:27
                 from /SVF/include/Util/BasicTypes.h:39
                 from /SVF/include/Util/SVFModule.h:33
                 from /SVF/include/Util/SVFUtil.h:33
                 from /SVF/lib/Util/SVFUtil.cpp:30:
/llvm-7.0.0.src/include/llvm/IR/Attributes.h:74:14: fatal error: llvm/IR/Attributes.inc: No such file or directory
   74 |     #include "llvm/IR/Attributes.inc"
      |              ^~~~~~~~~~~~~~~~~~~~~~~~
compilation terminated.
```
</Title_Description>
    <Label>question</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>30/08/2019 3:15:54 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>146</IssueLabelID>
    <Title>Unknown command line arguement</Title>
    <Description>Hi When I follow the simple C program example and type `wpa -type -dump-icfg swap.opt` it shows unkonwn command line arguement '-dump-icfg'. And I continue to search by wpa -help there seems no "-dump-icfg' command. Please help. Thank you very much.</Description>
    <Title_Description>Unknown command line arguement Hi When I follow the simple C program example and type `wpa -type -dump-icfg swap.opt` it shows unkonwn command line arguement '-dump-icfg'. And I continue to search by wpa -help there seems no "-dump-icfg' command. Please help. Thank you very much.</Title_Description>
    <Label>invalid</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>30/08/2019 6:39:28 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>144</IssueLabelID>
    <Title>Partial alias. Question.</Title>
    <Description>Hello

I have a question about partial aliasing. Does svf (for LLVM version 3.8.1) support it? In case it does not how does it treat partial aliasing (as may or no alias)? </Description>
    <Title_Description>Partial alias. Question. Hello

I have a question about partial aliasing. Does svf (for LLVM version 3.8.1) support it? In case it does not how does it treat partial aliasing (as may or no alias)? </Title_Description>
    <Label>question</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>15/08/2019 12:47:06 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>143</IssueLabelID>
    <Title>Andersen Analysis on Small program </Title>
    <Description>We ran a small test program using (-ander) the Andersen implementation
int **p*x*ya;
   p=&amp;x;
   p=&amp;y;
   *p=&amp;a;
  NOALIAS(xy);  // It is giving Success
Is it  not flow-insensitive method should consider x and y as MAYALIAS
</Description>
    <Title_Description>Andersen Analysis on Small program  We ran a small test program using (-ander) the Andersen implementation
int **p*x*ya;
   p=&amp;x;
   p=&amp;y;
   *p=&amp;a;
  NOALIAS(xy);  // It is giving Success
Is it  not flow-insensitive method should consider x and y as MAYALIAS
</Title_Description>
    <Label>question</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>2/08/2019 10:43:05 AM +00:00</CreatedAt>
    <ClosedAt>3/08/2019 8:42:28 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>142</IssueLabelID>
    <Title>Moving to LLVM 9.0.0</Title>
    <Description>Hello

I've prepared the patch for LLVM 9.0.0 (this seems to build the Linux kernel):
https://github.com/lifeasageek/SVF/commit/b7c0922ade78da2e13340e25fb5a405ba80b5033

I haven't fully worked through if this is right so please let me know if something's wrong.
</Description>
    <Title_Description>Moving to LLVM 9.0.0 Hello

I've prepared the patch for LLVM 9.0.0 (this seems to build the Linux kernel):
https://github.com/lifeasageek/SVF/commit/b7c0922ade78da2e13340e25fb5a405ba80b5033

I haven't fully worked through if this is right so please let me know if something's wrong.
</Title_Description>
    <Label>enhancement</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>25/07/2019 4:11:19 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>139</IssueLabelID>
    <Title>ModRef Analysis and Context sensitivity</Title>
    <Description>I was trying the following example
#include "aliascheck.h"
int **p**q**r;
int *x*y*z*w*v;
int abc;
void f(){
 *p=y;
}
void g() {
   p=&amp;w;
   y=&amp;c;
    f();
   v=w;
 MUSTALIAS(vy);
}
main() {
  p=&amp;x;
  y=&amp;b;
   f();
  z=x;
MUSTALIAS(zy);
}

modified SVF code to get the points-to Info at MUSTALIAS call 
main
z points to {cb} 
y points to {b}
g
v points to {cb} 
y points to {c}
why the result is context insensitive?ran wpa with fspta option.
May I know the portion of code containing CFL reachability?</Description>
    <Title_Description>ModRef Analysis and Context sensitivity I was trying the following example
#include "aliascheck.h"
int **p**q**r;
int *x*y*z*w*v;
int abc;
void f(){
 *p=y;
}
void g() {
   p=&amp;w;
   y=&amp;c;
    f();
   v=w;
 MUSTALIAS(vy);
}
main() {
  p=&amp;x;
  y=&amp;b;
   f();
  z=x;
MUSTALIAS(zy);
}

modified SVF code to get the points-to Info at MUSTALIAS call 
main
z points to {cb} 
y points to {b}
g
v points to {cb} 
y points to {c}
why the result is context insensitive?ran wpa with fspta option.
May I know the portion of code containing CFL reachability?</Title_Description>
    <Label>question</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>15/07/2019 7:11:25 AM +00:00</CreatedAt>
    <ClosedAt>25/07/2019 11:13:00 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>137</IssueLabelID>
    <Title>SVF Tool Integration Interface</Title>
    <Description>I'm trying to use SVF in a Static Thread Sharing Analysis project of mine and I'd like to use the data without having SVF output and then reinterpret it. I mainly looked for something quite simple (getThreads() getMethods() getStatements() etc.) so I may have missed something built-in. 

In the event that this functionality is not built-in however I assume that an interface must have been made already. Rather than have everyone individually re-code or have to create a custom version of SVF for each project that uses something similar is there a public version I should know about?

For reference my project is fairly general and requires data of all Threads Methods 
Memory Allocation Statements and Method Call Statements. It would use this information along with the PAG generated by the SVF tool.</Description>
    <Title_Description>SVF Tool Integration Interface I'm trying to use SVF in a Static Thread Sharing Analysis project of mine and I'd like to use the data without having SVF output and then reinterpret it. I mainly looked for something quite simple (getThreads() getMethods() getStatements() etc.) so I may have missed something built-in. 

In the event that this functionality is not built-in however I assume that an interface must have been made already. Rather than have everyone individually re-code or have to create a custom version of SVF for each project that uses something similar is there a public version I should know about?

For reference my project is fairly general and requires data of all Threads Methods 
Memory Allocation Statements and Method Call Statements. It would use this information along with the PAG generated by the SVF tool.</Title_Description>
    <Label>enhancement|question</Label>
    <Assignee>davis-matthew|yuleisui</Assignee>
    <CreatedAt>10/07/2019 5:19:02 PM +00:00</CreatedAt>
    <ClosedAt>11/08/2019 3:25:18 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>136</IssueLabelID>
    <Title>Broken Link in License</Title>
    <Description>SVF/LICENSE.TXT refers to https://github.com/unsw-corg/SVF/blob/gh-pages/Contributors.txt as the place to find contributors to the SVF project however this link seems to be outdated (the website no longer works). Perhaps linking to https://github.com/SVF-tools/SVF/graphs/contributors instead would be good although this includes all contributors instead of just main contributors.</Description>
    <Title_Description>Broken Link in License SVF/LICENSE.TXT refers to https://github.com/unsw-corg/SVF/blob/gh-pages/Contributors.txt as the place to find contributors to the SVF project however this link seems to be outdated (the website no longer works). Perhaps linking to https://github.com/SVF-tools/SVF/graphs/contributors instead would be good although this includes all contributors instead of just main contributors.</Title_Description>
    <Label>enhancement</Label>
    <Assignee>davis-matthew|yuleisui</Assignee>
    <CreatedAt>9/07/2019 10:57:18 PM +00:00</CreatedAt>
    <ClosedAt>16/07/2019 5:13:14 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>133</IssueLabelID>
    <Title>Function name typo in SVF</Title>
    <Description>Hi developers.

I just realized that there is a function named "vefityCallGraph".
I guess you may want to name it "ve'r'ifyCallGraph".
If what I said is correct you may want to modify it..?</Description>
    <Title_Description>Function name typo in SVF Hi developers.

I just realized that there is a function named "vefityCallGraph".
I guess you may want to name it "ve'r'ifyCallGraph".
If what I said is correct you may want to modify it..?</Title_Description>
    <Label>enhancement</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>28/06/2019 2:47:52 AM +00:00</CreatedAt>
    <ClosedAt>18/10/2019 11:18:01 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>132</IssueLabelID>
    <Title>Imprecise analysis results</Title>
    <Description>Hi

Thanks a lot for providing such a useful tool. 
I am trying to generate a fine-grained call graph for a (large) kernel. For this problem I am using SVF to generate points-to sets for pointer operands of indirect call Instructions.  I have used the Diff wave propagation inclusion-based analysis.
After going through the results one issue that I see is that for 900 of these call sites the target set is exactly the same and contains more than 6500 functions (which is one third of the total number of functions in my IR). Most of these functions seem completely unrelated to the call sites. 

Can you help me in figuring out what is going on?
Is it possible that you guys are using a conservative approach (e.g. signature matching) to overestimate the points-to set that is leading to this result?

Thanks.</Description>
    <Title_Description>Imprecise analysis results Hi

Thanks a lot for providing such a useful tool. 
I am trying to generate a fine-grained call graph for a (large) kernel. For this problem I am using SVF to generate points-to sets for pointer operands of indirect call Instructions.  I have used the Diff wave propagation inclusion-based analysis.
After going through the results one issue that I see is that for 900 of these call sites the target set is exactly the same and contains more than 6500 functions (which is one third of the total number of functions in my IR). Most of these functions seem completely unrelated to the call sites. 

Can you help me in figuring out what is going on?
Is it possible that you guys are using a conservative approach (e.g. signature matching) to overestimate the points-to set that is leading to this result?

Thanks.</Title_Description>
    <Label>question</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>19/06/2019 8:51:54 PM +00:00</CreatedAt>
    <ClosedAt>21/06/2019 8:34:22 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>131</IssueLabelID>
    <Title>make SVF failed</Title>
    <Description>my environment is：
llvm 6.0.0
clang 6.0.0
when i go to step 6 to make SVF 
```
[ 69%] Built target LLVMCudd
[ 69%] Building CXX object lib/CMakeFiles/LLVMSvf.dir/Util/Conditions.cpp.o
[ 70%] Building CXX object lib/CMakeFiles/Svf.dir/Util/ThreadCallGraph.cpp.o
[ 70%] Building CXX object lib/CMakeFiles/LLVMSvf.dir/Util/ExtAPI.cpp.o
[ 71%] Building CXX object lib/CMakeFiles/LLVMSvf.dir/Util/PathCondAllocator.cpp.o
[ 71%] Building CXX object lib/CMakeFiles/LLVMSvf.dir/Util/PTAStat.cpp.o
[ 71%] Building CXX object lib/CMakeFiles/Svf.dir/Util/BreakConstantExpr.cpp.o
[ 71%] Building CXX object lib/CMakeFiles/LLVMSvf.dir/Util/ThreadAPI.cpp.o
[ 72%] Building CXX object lib/CMakeFiles/LLVMSvf.dir/Util/SVFModule.cpp.o
[ 72%] Building CXX object lib/CMakeFiles/Svf.dir/Util/Conditions.cpp.o
[ 72%] Building CXX object lib/CMakeFiles/LLVMSvf.dir/MemoryModel/ConsG.cpp.o
/home/wcc/Downloads/SVF/lib/Util/SVFModule.cpp:371:9: error: no matching
      function for call to 'WriteBitcodeToFile'
        WriteBitcodeToFile(*mod OS);
        ^~~~~~~~~~~~~~~~~~
/home/wcc/Downloads/llvm-6.0.0.src/include/llvm/Bitcode/BitcodeWriter.h:129:8: note: 
      candidate function not viable: no known conversion from 'llvm::Module' to
      'const llvm::Module *' for 1st argument; remove *
  void WriteBitcodeToFile(const Module *M raw_ostream &amp;Out
       ^
[ 73%] Building CXX object lib/CMakeFiles/Svf.dir/Util/ExtAPI.cpp.o
1 error generated.
lib/CMakeFiles/LLVMSvf.dir/build.make:218: recipe for target 'lib/CMakeFiles/LLVMSvf.dir/Util/SVFModule.cpp.o' failed
make[2]: *** [lib/CMakeFiles/LLVMSvf.dir/Util/SVFModule.cpp.o] Error 1
make[2]: *** Waiting for unfinished jobs....
[ 73%] Building CXX object lib/CMakeFiles/Svf.dir/Util/PathCondAllocator.cpp.o
[ 74%] Building CXX object lib/CMakeFiles/Svf.dir/Util/PTAStat.cpp.o
[ 74%] Building CXX object lib/CMakeFiles/Svf.dir/Util/ThreadAPI.cpp.o
CMakeFiles/Makefile2:165: recipe for target 'lib/CMakeFiles/LLVMSvf.dir/all' failed
make[1]: *** [lib/CMakeFiles/LLVMSvf.dir/all] Error 2
make[1]: *** Waiting for unfinished jobs....
[ 74%] Building CXX object lib/CMakeFiles/Svf.dir/Util/SVFModule.cpp.o
[ 75%] Building CXX object lib/CMakeFiles/Svf.dir/MemoryModel/ConsG.cpp.o
[ 75%] Building CXX object lib/CMakeFiles/Svf.dir/MemoryModel/LocationSet.cpp.o
/home/wcc/Downloads/SVF/lib/Util/SVFModule.cpp:371:9: error: no matching
      function for call to 'WriteBitcodeToFile'
        WriteBitcodeToFile(*mod OS);
        ^~~~~~~~~~~~~~~~~~
/home/wcc/Downloads/llvm-6.0.0.src/include/llvm/Bitcode/BitcodeWriter.h:129:8: note: 
      candidate function not viable: no known conversion from 'llvm::Module' to
      'const llvm::Module *' for 1st argument; remove *
  void WriteBitcodeToFile(const Module *M raw_ostream &amp;Out
       ^
[ 75%] Building CXX object lib/CMakeFiles/Svf.dir/MemoryModel/LocMemModel.cpp.o
1 error generated.
lib/CMakeFiles/Svf.dir/build.make:218: recipe for target 'lib/CMakeFiles/Svf.dir/Util/SVFModule.cpp.o' failed
make[2]: *** [lib/CMakeFiles/Svf.dir/Util/SVFModule.cpp.o] Error 1
make[2]: *** Waiting for unfinished jobs....
CMakeFiles/Makefile2:128: recipe for target 'lib/CMakeFiles/Svf.dir/all' failed
make[1]: *** [lib/CMakeFiles/Svf.dir/all] Error 2
Makefile:129: recipe for target 'all' failed
make: *** [all] Error 2
```
I successed making SVF by using llvm7.0.0+clang7.0.0 but failed in using llvm6.0.0+clang6.0.0
thanks for your help!
</Description>
    <Title_Description>make SVF failed my environment is：
llvm 6.0.0
clang 6.0.0
when i go to step 6 to make SVF 
```
[ 69%] Built target LLVMCudd
[ 69%] Building CXX object lib/CMakeFiles/LLVMSvf.dir/Util/Conditions.cpp.o
[ 70%] Building CXX object lib/CMakeFiles/Svf.dir/Util/ThreadCallGraph.cpp.o
[ 70%] Building CXX object lib/CMakeFiles/LLVMSvf.dir/Util/ExtAPI.cpp.o
[ 71%] Building CXX object lib/CMakeFiles/LLVMSvf.dir/Util/PathCondAllocator.cpp.o
[ 71%] Building CXX object lib/CMakeFiles/LLVMSvf.dir/Util/PTAStat.cpp.o
[ 71%] Building CXX object lib/CMakeFiles/Svf.dir/Util/BreakConstantExpr.cpp.o
[ 71%] Building CXX object lib/CMakeFiles/LLVMSvf.dir/Util/ThreadAPI.cpp.o
[ 72%] Building CXX object lib/CMakeFiles/LLVMSvf.dir/Util/SVFModule.cpp.o
[ 72%] Building CXX object lib/CMakeFiles/Svf.dir/Util/Conditions.cpp.o
[ 72%] Building CXX object lib/CMakeFiles/LLVMSvf.dir/MemoryModel/ConsG.cpp.o
/home/wcc/Downloads/SVF/lib/Util/SVFModule.cpp:371:9: error: no matching
      function for call to 'WriteBitcodeToFile'
        WriteBitcodeToFile(*mod OS);
        ^~~~~~~~~~~~~~~~~~
/home/wcc/Downloads/llvm-6.0.0.src/include/llvm/Bitcode/BitcodeWriter.h:129:8: note: 
      candidate function not viable: no known conversion from 'llvm::Module' to
      'const llvm::Module *' for 1st argument; remove *
  void WriteBitcodeToFile(const Module *M raw_ostream &amp;Out
       ^
[ 73%] Building CXX object lib/CMakeFiles/Svf.dir/Util/ExtAPI.cpp.o
1 error generated.
lib/CMakeFiles/LLVMSvf.dir/build.make:218: recipe for target 'lib/CMakeFiles/LLVMSvf.dir/Util/SVFModule.cpp.o' failed
make[2]: *** [lib/CMakeFiles/LLVMSvf.dir/Util/SVFModule.cpp.o] Error 1
make[2]: *** Waiting for unfinished jobs....
[ 73%] Building CXX object lib/CMakeFiles/Svf.dir/Util/PathCondAllocator.cpp.o
[ 74%] Building CXX object lib/CMakeFiles/Svf.dir/Util/PTAStat.cpp.o
[ 74%] Building CXX object lib/CMakeFiles/Svf.dir/Util/ThreadAPI.cpp.o
CMakeFiles/Makefile2:165: recipe for target 'lib/CMakeFiles/LLVMSvf.dir/all' failed
make[1]: *** [lib/CMakeFiles/LLVMSvf.dir/all] Error 2
make[1]: *** Waiting for unfinished jobs....
[ 74%] Building CXX object lib/CMakeFiles/Svf.dir/Util/SVFModule.cpp.o
[ 75%] Building CXX object lib/CMakeFiles/Svf.dir/MemoryModel/ConsG.cpp.o
[ 75%] Building CXX object lib/CMakeFiles/Svf.dir/MemoryModel/LocationSet.cpp.o
/home/wcc/Downloads/SVF/lib/Util/SVFModule.cpp:371:9: error: no matching
      function for call to 'WriteBitcodeToFile'
        WriteBitcodeToFile(*mod OS);
        ^~~~~~~~~~~~~~~~~~
/home/wcc/Downloads/llvm-6.0.0.src/include/llvm/Bitcode/BitcodeWriter.h:129:8: note: 
      candidate function not viable: no known conversion from 'llvm::Module' to
      'const llvm::Module *' for 1st argument; remove *
  void WriteBitcodeToFile(const Module *M raw_ostream &amp;Out
       ^
[ 75%] Building CXX object lib/CMakeFiles/Svf.dir/MemoryModel/LocMemModel.cpp.o
1 error generated.
lib/CMakeFiles/Svf.dir/build.make:218: recipe for target 'lib/CMakeFiles/Svf.dir/Util/SVFModule.cpp.o' failed
make[2]: *** [lib/CMakeFiles/Svf.dir/Util/SVFModule.cpp.o] Error 1
make[2]: *** Waiting for unfinished jobs....
CMakeFiles/Makefile2:128: recipe for target 'lib/CMakeFiles/Svf.dir/all' failed
make[1]: *** [lib/CMakeFiles/Svf.dir/all] Error 2
Makefile:129: recipe for target 'all' failed
make: *** [all] Error 2
```
I successed making SVF by using llvm7.0.0+clang7.0.0 but failed in using llvm6.0.0+clang6.0.0
thanks for your help!
</Title_Description>
    <Label>question</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>12/06/2019 6:35:57 AM +00:00</CreatedAt>
    <ClosedAt>12/06/2019 11:06:24 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>130</IssueLabelID>
    <Title>Built target LLVMCudd  failed</Title>
    <Description>When I went to 6th step there is an error.
```
[ 63%] Building C object lib/CUDD/CMakeFiles/LLVMCudd.dir/cuddHarwell.c.o
[ 64%] Building C object lib/CUDD/CMakeFiles/LLVMCudd.dir/cuddPriority.c.o
[ 64%] Linking C shared module Cudd.so
[ 64%] Building C object lib/CUDD/CMakeFiles/LLVMCudd.dir/cuddSubsetHB.c.o
[ 64%] Built target Cudd
[ 64%] Building C object lib/CUDD/CMakeFiles/LLVMCudd.dir/cuddZddGroup.c.o
[ 65%] Building C object lib/CUDD/CMakeFiles/LLVMCudd.dir/cuddZddUtil.c.o
[ 65%] Building C object lib/CUDD/CMakeFiles/LLVMCudd.dir/dddmpNodeAdd.c.o
[ 66%] Building C object lib/CUDD/CMakeFiles/LLVMCudd.dir/epd.c.o
[ 66%] Building C object lib/CUDD/CMakeFiles/LLVMCudd.dir/restart.c.o
[ 66%] Linking C static library libLLVMCudd.a
[ 66%] Built target LLVMCudd
Makefile:127: recipe for target 'all' failed
make: *** [all] Error 2
```
I am confused.</Description>
    <Title_Description>Built target LLVMCudd  failed When I went to 6th step there is an error.
```
[ 63%] Building C object lib/CUDD/CMakeFiles/LLVMCudd.dir/cuddHarwell.c.o
[ 64%] Building C object lib/CUDD/CMakeFiles/LLVMCudd.dir/cuddPriority.c.o
[ 64%] Linking C shared module Cudd.so
[ 64%] Building C object lib/CUDD/CMakeFiles/LLVMCudd.dir/cuddSubsetHB.c.o
[ 64%] Built target Cudd
[ 64%] Building C object lib/CUDD/CMakeFiles/LLVMCudd.dir/cuddZddGroup.c.o
[ 65%] Building C object lib/CUDD/CMakeFiles/LLVMCudd.dir/cuddZddUtil.c.o
[ 65%] Building C object lib/CUDD/CMakeFiles/LLVMCudd.dir/dddmpNodeAdd.c.o
[ 66%] Building C object lib/CUDD/CMakeFiles/LLVMCudd.dir/epd.c.o
[ 66%] Building C object lib/CUDD/CMakeFiles/LLVMCudd.dir/restart.c.o
[ 66%] Linking C static library libLLVMCudd.a
[ 66%] Built target LLVMCudd
Makefile:127: recipe for target 'all' failed
make: *** [all] Error 2
```
I am confused.</Title_Description>
    <Label>invalid</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>30/05/2019 3:13:32 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>129</IssueLabelID>
    <Title>debug  info problem</Title>
    <Description>Hello I'm new in LLVM  and I want to use svf to do some static analysis. I want to find where a struct is defined Loc and source file.
just like function's dbginfo.
```c
&lt;func1&gt; Source Loc: in line: 24 file: test.c 
```
but I cannot find any interface to get such information. 
How can I get such information with svf ?
Apologize for my little stupid problem. ?</Description>
    <Title_Description>debug  info problem Hello I'm new in LLVM  and I want to use svf to do some static analysis. I want to find where a struct is defined Loc and source file.
just like function's dbginfo.
```c
&lt;func1&gt; Source Loc: in line: 24 file: test.c 
```
but I cannot find any interface to get such information. 
How can I get such information with svf ?
Apologize for my little stupid problem. ?</Title_Description>
    <Label>question</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>14/05/2019 8:22:37 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>128</IssueLabelID>
    <Title>How do I use SVF for LLVM MIR level?</Title>
    <Description>Hi all
I am working on our research project and plan to use svf to perform memory dependence analysis on the LLVM MIR level. But I spot svf operating on the IR level. So can I use svf for LLVM MIR instruction?

Thanks.</Description>
    <Title_Description>How do I use SVF for LLVM MIR level? Hi all
I am working on our research project and plan to use svf to perform memory dependence analysis on the LLVM MIR level. But I spot svf operating on the IR level. So can I use svf for LLVM MIR instruction?

Thanks.</Title_Description>
    <Label>question</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>10/05/2019 3:19:37 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>126</IssueLabelID>
    <Title>How to handle extractvalue</Title>
    <Description>I'm working on adapting Saber's leak detection to a similar Source-Sink analysis and have come across some problems resulting from the `extractvalue` instruction. To make this a bit more concrete we have some LLVM-IR that basically looks like this:

```llvm
%1 = call { [0 x i32]* i64 } @get_fat_pointer(i64* nonnull %array.0 i64 %array.1)
%2 = extractvalue { [0xi32]* i64 } %1 0
%3 = extractvalue { [0xi32]* i64 } %1 1
```

Depending on the inliner &amp; optimization passes this may end up becoming a GEP instruction that then uses `insertvalue` to operate on a struct in an LLVM register(very similar to the above situation) but will sometimes still stay in this form.

After the SVFG is constructed I can track the arguments to `get_fat_pointer()` through to the return value but this connection is lost at the callsite since the return value is not a pointer but an in register struct. I think part of the problem is also that the "origin" of the `extractvalue` instruction is the BlackHole but I am tracking a value that does not point back to the BlackHole so there is no connection in the PAG or resulting SVFG.

Ideally we would like to track this pointer through such a call regardless of how it is transformed.  In the comments in the PAGBuilder.cpp for[ visitExtractValueInst()](https://github.com/SVF-tools/SVF/blob/206493694931caa8ff3133191e7a4dbb7832fd89/lib/MemoryModel/PAGBuilder.cpp#L560) there are some notes about how to handle `extractvalue` in a way similar to GEP but I am unsure of how this should be represented in the PAG since there is no actual pointer.

Do you have any advice for how to handle this? How can the in-register struct be modeled in the PAG or SVFG to support this type of operation?






</Description>
    <Title_Description>How to handle extractvalue I'm working on adapting Saber's leak detection to a similar Source-Sink analysis and have come across some problems resulting from the `extractvalue` instruction. To make this a bit more concrete we have some LLVM-IR that basically looks like this:

```llvm
%1 = call { [0 x i32]* i64 } @get_fat_pointer(i64* nonnull %array.0 i64 %array.1)
%2 = extractvalue { [0xi32]* i64 } %1 0
%3 = extractvalue { [0xi32]* i64 } %1 1
```

Depending on the inliner &amp; optimization passes this may end up becoming a GEP instruction that then uses `insertvalue` to operate on a struct in an LLVM register(very similar to the above situation) but will sometimes still stay in this form.

After the SVFG is constructed I can track the arguments to `get_fat_pointer()` through to the return value but this connection is lost at the callsite since the return value is not a pointer but an in register struct. I think part of the problem is also that the "origin" of the `extractvalue` instruction is the BlackHole but I am tracking a value that does not point back to the BlackHole so there is no connection in the PAG or resulting SVFG.

Ideally we would like to track this pointer through such a call regardless of how it is transformed.  In the comments in the PAGBuilder.cpp for[ visitExtractValueInst()](https://github.com/SVF-tools/SVF/blob/206493694931caa8ff3133191e7a4dbb7832fd89/lib/MemoryModel/PAGBuilder.cpp#L560) there are some notes about how to handle `extractvalue` in a way similar to GEP but I am unsure of how this should be represented in the PAG since there is no actual pointer.

Do you have any advice for how to handle this? How can the in-register struct be modeled in the PAG or SVFG to support this type of operation?






</Title_Description>
    <Label>help wanted</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>29/04/2019 7:13:25 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>124</IssueLabelID>
    <Title>Does MTA work?</Title>
    <Description>Hi developers.

MTA does not work and it is not even compilable with the current version.
Also even after I succeeded in compilation by changing CMake files it does not work correctly with the simple code described in the bottom. 

Possibly I incorrectly modify the code to make MTA work. But what I can tell is that MTA with the current version is not compilable.

---------------------------------------------------------
Here is the crash log first.
#0  0x00007ffff6d6a428 in __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:54
#1  0x00007ffff6d6c02a in __GI_abort () at abort.c:89
#2  0x00007ffff6d62bd7 in __assert_fail_base (fmt=&lt;optimized out&gt; 
    assertion=assertion@entry=0x943e78 "Resolver &amp;&amp;\"Pass has not been inserted into a PassManager object!\"" 
    file=file@entry=0x943e30 "~/llvm/llvm-7.0.0.src/include/llvm/PassAnalysisSupport.h" line=line@entry=250 
    function=function@entry=0x947940 &lt;llvm::ScalarEvolutionWrapperPass&amp; llvm::Pass::getAnalysis&lt;llvm::ScalarEvolutionWrapperPass&gt;(llvm::Function&amp;)::__PRETTY_FUNCTION__&gt; "AnalysisType&amp; llvm::Pass::getAnalysis(llvm::Function&amp;) [with AnalysisType = llvm::ScalarEvolutionWrapperPass]") at assert.c:92
#3  0x00007ffff6d62c82 in __GI___assert_fail (
    assertion=0x943e78 "Resolver &amp;&amp;\"Pass has not been inserted into a PassManager object!\"" 
    file=0x943e30 "~/llvm/llvm-7.0.0.src/include/llvm/PassAnalysisSupport.h" line=250 
    function=0x947940 &lt;llvm::ScalarEvolutionWrapperPass&amp; llvm::Pass::getAnalysis&lt;llvm::ScalarEvolutionWrapperPass&gt;(llvm::Function&amp;)::__PRETTY_FUNCTION__&gt; "AnalysisType&amp; llvm::Pass::getAnalysis(llvm::Function&amp;) [with AnalysisType = llvm::ScalarEvolutionWrapperPass]") at assert.c:101
#4  0x00000000004b3470 in llvm::Pass::getAnalysis&lt;llvm::ScalarEvolutionWrapperPass&gt; (this=0xe822e0 F=...)
    at ~/llvm/llvm-7.0.0.src/include/llvm/PassAnalysisSupport.h:250
#5  0x00000000004b1a5e in MTA::getSE (F=0xe85a88) at ~/svf/include/MTA/MTA.h:115
#6  0x0000000000558906 in ForkJoinAnalysis::collectSCEVInfo (this=0xf1e9a0) at ~/svf/lib/MTA/MHP.cpp:630
#7  0x000000000055c397 in ForkJoinAnalysis::ForkJoinAnalysis (this=0xf1e9a0 t=0xf1cf50)
    at ~/svf/include/MTA/MHP.h:259
#8  0x0000000000554ed6 in MHP::MHP (this=0xf1c3e0 t=0xf1cf50) at ~/svf/lib/MTA/MHP.cpp:77
#9  0x000000000049720c in MTA::computeMHP (this=0xe822e0 module=...) at ~/svf/lib/MTA/MTA.cpp:129 -&gt; it was slightly modified but it may not contribute errors
#10 0x0000000000496b46 in MTA::runOnModule (this=0xe822e0 module=...) at ~/svf/lib/MTA/MTA.cpp:45 -&gt; it was slightly modified but it may not contribute errors
#11 0x000000000041ccc9 in main (argc=2 argv=0x7fffffffe348) at ~/svf/tools/MTA/mta.cpp:69 -&gt; it was slightly modified but it may not contribute errors

----------------------------------------------
My test code
#include &lt;pthread.h&gt;
#include &lt;stdio.h&gt;

int Global;

void *Thread1(void *x) {
  Global++;
  return NULL;
}

void *Thread2(void *x) {
  Global--;
  return NULL;
}

int main() {
  pthread_t t[2];
  pthread_create(&amp;t[0] NULL Thread1 NULL);
  pthread_create(&amp;t[1] NULL Thread2 NULL);
  pthread_join(t[0] NULL);
  pthread_join(t[1] NULL);
}
-----------------------
Thank you</Description>
    <Title_Description>Does MTA work? Hi developers.

MTA does not work and it is not even compilable with the current version.
Also even after I succeeded in compilation by changing CMake files it does not work correctly with the simple code described in the bottom. 

Possibly I incorrectly modify the code to make MTA work. But what I can tell is that MTA with the current version is not compilable.

---------------------------------------------------------
Here is the crash log first.
#0  0x00007ffff6d6a428 in __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:54
#1  0x00007ffff6d6c02a in __GI_abort () at abort.c:89
#2  0x00007ffff6d62bd7 in __assert_fail_base (fmt=&lt;optimized out&gt; 
    assertion=assertion@entry=0x943e78 "Resolver &amp;&amp;\"Pass has not been inserted into a PassManager object!\"" 
    file=file@entry=0x943e30 "~/llvm/llvm-7.0.0.src/include/llvm/PassAnalysisSupport.h" line=line@entry=250 
    function=function@entry=0x947940 &lt;llvm::ScalarEvolutionWrapperPass&amp; llvm::Pass::getAnalysis&lt;llvm::ScalarEvolutionWrapperPass&gt;(llvm::Function&amp;)::__PRETTY_FUNCTION__&gt; "AnalysisType&amp; llvm::Pass::getAnalysis(llvm::Function&amp;) [with AnalysisType = llvm::ScalarEvolutionWrapperPass]") at assert.c:92
#3  0x00007ffff6d62c82 in __GI___assert_fail (
    assertion=0x943e78 "Resolver &amp;&amp;\"Pass has not been inserted into a PassManager object!\"" 
    file=0x943e30 "~/llvm/llvm-7.0.0.src/include/llvm/PassAnalysisSupport.h" line=250 
    function=0x947940 &lt;llvm::ScalarEvolutionWrapperPass&amp; llvm::Pass::getAnalysis&lt;llvm::ScalarEvolutionWrapperPass&gt;(llvm::Function&amp;)::__PRETTY_FUNCTION__&gt; "AnalysisType&amp; llvm::Pass::getAnalysis(llvm::Function&amp;) [with AnalysisType = llvm::ScalarEvolutionWrapperPass]") at assert.c:101
#4  0x00000000004b3470 in llvm::Pass::getAnalysis&lt;llvm::ScalarEvolutionWrapperPass&gt; (this=0xe822e0 F=...)
    at ~/llvm/llvm-7.0.0.src/include/llvm/PassAnalysisSupport.h:250
#5  0x00000000004b1a5e in MTA::getSE (F=0xe85a88) at ~/svf/include/MTA/MTA.h:115
#6  0x0000000000558906 in ForkJoinAnalysis::collectSCEVInfo (this=0xf1e9a0) at ~/svf/lib/MTA/MHP.cpp:630
#7  0x000000000055c397 in ForkJoinAnalysis::ForkJoinAnalysis (this=0xf1e9a0 t=0xf1cf50)
    at ~/svf/include/MTA/MHP.h:259
#8  0x0000000000554ed6 in MHP::MHP (this=0xf1c3e0 t=0xf1cf50) at ~/svf/lib/MTA/MHP.cpp:77
#9  0x000000000049720c in MTA::computeMHP (this=0xe822e0 module=...) at ~/svf/lib/MTA/MTA.cpp:129 -&gt; it was slightly modified but it may not contribute errors
#10 0x0000000000496b46 in MTA::runOnModule (this=0xe822e0 module=...) at ~/svf/lib/MTA/MTA.cpp:45 -&gt; it was slightly modified but it may not contribute errors
#11 0x000000000041ccc9 in main (argc=2 argv=0x7fffffffe348) at ~/svf/tools/MTA/mta.cpp:69 -&gt; it was slightly modified but it may not contribute errors

----------------------------------------------
My test code
#include &lt;pthread.h&gt;
#include &lt;stdio.h&gt;

int Global;

void *Thread1(void *x) {
  Global++;
  return NULL;
}

void *Thread2(void *x) {
  Global--;
  return NULL;
}

int main() {
  pthread_t t[2];
  pthread_create(&amp;t[0] NULL Thread1 NULL);
  pthread_create(&amp;t[1] NULL Thread2 NULL);
  pthread_join(t[0] NULL);
  pthread_join(t[1] NULL);
}
-----------------------
Thank you</Title_Description>
    <Label>bug|question</Label>
    <Assignee>HongxuChen|yuleisui</Assignee>
    <CreatedAt>20/03/2019 12:33:07 AM +00:00</CreatedAt>
    <ClosedAt>24/03/2019 8:34:06 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>120</IssueLabelID>
    <Title>deleting PAG?</Title>
    <Description>Is deleting PAG supported?

I tried `delete _pta-&gt;getPAG()` and `PAG::releasePAG()` both of which cause my program to terminate with a segfault. Valgrind gives this stack trace:

```
==18846==  Bad permissions for mapped region at address 0x40B8B10
==18846==    at 0x40B8B10: ???
==18846==    by 0x7D197D: PAGNode::~PAGNode() (PAGNode.h:75)
==18846==    by 0x7D1E55: ValPN::~ValPN() (in /data/klee/build7.0/bin/klee)
==18846==    by 0x7D1E85: ValPN::~ValPN() (PAGNode.h:255)
==18846==    by 0x79B2DA: destroy (GenericGraph.h:313)
==18846==    by 0x79B2DA: ~GenericGraph (GenericGraph.h:307)
==18846==    by 0x79B2DA: PAG::~PAG() (PAG.h:139)
==18846==    by 0x79A59D: ~PAG (PAG.h:141)
==18846==    by 0x79A59D: releasePAG (PAG.h:133)
```

From what I can tell the problem is the delete on [this line](https://github.com/SVF-tools/SVF/blob/85e2f882680541b3f585328b4c1b5e02723b4000/include/MemoryModel/GenericGraph.h#L147). The address of the destructor seems to be something random. My solution was just to disable the GenericNode destructor for PAGNodes which seems to free almost all of the memory but it feels odd. 

I also noticed that deleting pag is commneted out in `PointerAnalysis.h` so I'm wondering if this is something that is simply not supported? </Description>
    <Title_Description>deleting PAG? Is deleting PAG supported?

I tried `delete _pta-&gt;getPAG()` and `PAG::releasePAG()` both of which cause my program to terminate with a segfault. Valgrind gives this stack trace:

```
==18846==  Bad permissions for mapped region at address 0x40B8B10
==18846==    at 0x40B8B10: ???
==18846==    by 0x7D197D: PAGNode::~PAGNode() (PAGNode.h:75)
==18846==    by 0x7D1E55: ValPN::~ValPN() (in /data/klee/build7.0/bin/klee)
==18846==    by 0x7D1E85: ValPN::~ValPN() (PAGNode.h:255)
==18846==    by 0x79B2DA: destroy (GenericGraph.h:313)
==18846==    by 0x79B2DA: ~GenericGraph (GenericGraph.h:307)
==18846==    by 0x79B2DA: PAG::~PAG() (PAG.h:139)
==18846==    by 0x79A59D: ~PAG (PAG.h:141)
==18846==    by 0x79A59D: releasePAG (PAG.h:133)
```

From what I can tell the problem is the delete on [this line](https://github.com/SVF-tools/SVF/blob/85e2f882680541b3f585328b4c1b5e02723b4000/include/MemoryModel/GenericGraph.h#L147). The address of the destructor seems to be something random. My solution was just to disable the GenericNode destructor for PAGNodes which seems to free almost all of the memory but it feels odd. 

I also noticed that deleting pag is commneted out in `PointerAnalysis.h` so I'm wondering if this is something that is simply not supported? </Title_Description>
    <Label>help wanted|question</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>9/01/2019 5:08:36 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>119</IssueLabelID>
    <Title>Steensgaard analysis</Title>
    <Description>Hi

Can you please provide some direction I should take to implement Steensgaard analysis using the pointer analysis framework provided?

Thanks</Description>
    <Title_Description>Steensgaard analysis Hi

Can you please provide some direction I should take to implement Steensgaard analysis using the pointer analysis framework provided?

Thanks</Title_Description>
    <Label>question</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>27/12/2018 1:43:28 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>116</IssueLabelID>
    <Title>taint analysis</Title>
    <Description>Hi

I have some questions about using your tool for taint analysis. I want to annotate all function arguments (user inputs) as sources and annotate left operands of add/sub/mul operations in LLVM as sinks. Then I need to check the reachability from sources to sinks.


1. How can I get names or nodeIDs of function arguments from symbol table?
2. How can I filter out add/sub/mul operations (LLVM statements) and get the names or nodeIDs of the left operands?
3. If reachable from source to sink can I solve the value of the source to reach sink based on constraint graph?

For example in the following LLVM assembly code `%"assign_value.1"` is the left operand of add operation and `%".15"` propogates data flow to it. We can see that `%".15"` loads from `%"_value_transfer1Function"` which gets value from `%".1"` (user input). So we annotate `%".1"` as source and `%"assign_value.1"` as sink. Apparently the reachability is yes. Next we want to solve the value of `%".1"` because we need the code flows into "endRequire" block instesd of "sanityCheckUnsatisfied". So we want to know what value should users feed to `%".1"` when this statement 

`br i1 %"notNull" label %"endRequire" label %"sanityCheckUnsatisfied"`

satisfies the `%"notNull"` condition and branch to label %"endRequire".

Here is the LLVM code example
```
define i32 @"transfer1Function"(i32 %".1") 

{

entry:

  %"_value_transfer1Function" = alloca i32

  store i32 %".1" i32* %"_value_transfer1Function"

  %"binary_result" = alloca i32

  br label %"requireStart"

requireStart:

  %".5" = load i32 i32* @"balanceOfSender_global"

  %".6" = load i32 i32* %"_value_transfer1Function"

  %"cmpOP" = icmp uge i32 %".5" %".6"

  %".7" = zext i1 %"cmpOP" to i32

  store i32 %".7" i32* %"binary_result"

  %".9" = load i32 i32* %"binary_result"

  %"notNull" = icmp ne i32 %".9" 0

  br i1 %"notNull" label %"endRequire" label %"sanityCheckUnsatisfied"

sanityCheckUnsatisfied:

  ret i32 -1

endRequire:

  %".12" = load i32 i32* %"_value_transfer1Function"

  %".13" = load i32 i32* @"balanceOfSender_global"

  %"assign_value" = sub i32 %".13" %".12"

  store i32 %"assign_value" i32* @"balanceOfSender_global"

  %".15" = load i32 i32* %"_value_transfer1Function"

  %".16" = load i32 i32* @"balanceOfReceiver_global"

  %"assign_value.1" = add i32 %".16" %".15"

  store i32 %"assign_value.1" i32* @"balanceOfReceiver_global"

  ret i32 0

}
```

Thanks</Description>
    <Title_Description>taint analysis Hi

I have some questions about using your tool for taint analysis. I want to annotate all function arguments (user inputs) as sources and annotate left operands of add/sub/mul operations in LLVM as sinks. Then I need to check the reachability from sources to sinks.


1. How can I get names or nodeIDs of function arguments from symbol table?
2. How can I filter out add/sub/mul operations (LLVM statements) and get the names or nodeIDs of the left operands?
3. If reachable from source to sink can I solve the value of the source to reach sink based on constraint graph?

For example in the following LLVM assembly code `%"assign_value.1"` is the left operand of add operation and `%".15"` propogates data flow to it. We can see that `%".15"` loads from `%"_value_transfer1Function"` which gets value from `%".1"` (user input). So we annotate `%".1"` as source and `%"assign_value.1"` as sink. Apparently the reachability is yes. Next we want to solve the value of `%".1"` because we need the code flows into "endRequire" block instesd of "sanityCheckUnsatisfied". So we want to know what value should users feed to `%".1"` when this statement 

`br i1 %"notNull" label %"endRequire" label %"sanityCheckUnsatisfied"`

satisfies the `%"notNull"` condition and branch to label %"endRequire".

Here is the LLVM code example
```
define i32 @"transfer1Function"(i32 %".1") 

{

entry:

  %"_value_transfer1Function" = alloca i32

  store i32 %".1" i32* %"_value_transfer1Function"

  %"binary_result" = alloca i32

  br label %"requireStart"

requireStart:

  %".5" = load i32 i32* @"balanceOfSender_global"

  %".6" = load i32 i32* %"_value_transfer1Function"

  %"cmpOP" = icmp uge i32 %".5" %".6"

  %".7" = zext i1 %"cmpOP" to i32

  store i32 %".7" i32* %"binary_result"

  %".9" = load i32 i32* %"binary_result"

  %"notNull" = icmp ne i32 %".9" 0

  br i1 %"notNull" label %"endRequire" label %"sanityCheckUnsatisfied"

sanityCheckUnsatisfied:

  ret i32 -1

endRequire:

  %".12" = load i32 i32* %"_value_transfer1Function"

  %".13" = load i32 i32* @"balanceOfSender_global"

  %"assign_value" = sub i32 %".13" %".12"

  store i32 %"assign_value" i32* @"balanceOfSender_global"

  %".15" = load i32 i32* %"_value_transfer1Function"

  %".16" = load i32 i32* @"balanceOfReceiver_global"

  %"assign_value.1" = add i32 %".16" %".15"

  store i32 %"assign_value.1" i32* @"balanceOfReceiver_global"

  ret i32 0

}
```

Thanks</Title_Description>
    <Label>question</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>6/12/2018 10:25:35 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>115</IssueLabelID>
    <Title>SPEC CPUINT 2006 benchmarks call graph stats for gobmk</Title>
    <Description>We ran SVF on speccpu2006 benchmarks
GOBMK benchmark program has
Number of call sites are 10030
Number of Indirect call sites are 44
If we ran SVF with flow sensitive version to get the number of edges in the call garph we are getting 46353.  why so many choices?. Help us to resolve the issue
</Description>
    <Title_Description>SPEC CPUINT 2006 benchmarks call graph stats for gobmk We ran SVF on speccpu2006 benchmarks
GOBMK benchmark program has
Number of call sites are 10030
Number of Indirect call sites are 44
If we ran SVF with flow sensitive version to get the number of edges in the call garph we are getting 46353.  why so many choices?. Help us to resolve the issue
</Title_Description>
    <Label>question</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>3/12/2018 8:51:26 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>114</IssueLabelID>
    <Title>Points-To Representation</Title>
    <Description>I have some questions regarding the points-to representation in the _PointsToDS_.
If the points-to for some node is empty what does it mean:
- the node points to null?
- there is no points-to information available for the node?

I see that _getPts_ always creates a an empty points-to set (when _getPts_ is called) since it does the following:
```
return ptsMap[var];
```

It seems that this way the points-to map is a bit polluted with many pointers with empty sets
and is probably not so memory-efficient.
</Description>
    <Title_Description>Points-To Representation I have some questions regarding the points-to representation in the _PointsToDS_.
If the points-to for some node is empty what does it mean:
- the node points to null?
- there is no points-to information available for the node?

I see that _getPts_ always creates a an empty points-to set (when _getPts_ is called) since it does the following:
```
return ptsMap[var];
```

It seems that this way the points-to map is a bit polluted with many pointers with empty sets
and is probably not so memory-efficient.
</Title_Description>
    <Label>enhancement|question</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>15/11/2018 6:55:06 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>109</IssueLabelID>
    <Title>Tell the different objects from custom alloc functions</Title>
    <Description>Hi Yulei

I have a question using SVF with sample code below:

`#include &lt;stdlib.h&gt;

void my_malloc(char ** punsigned size){
    *p = malloc(size);
}

void f(void){
    char *p1*p2*p3*p4;
    p1 = malloc(1);
    p2 = malloc(2);
    my_malloc(&amp;p33);
    my_malloc(&amp;p44);
}`

So p1p2p3p4 should point to different objects right?

By using 'wpa -nander -dump-consG test.bc' I got the following constraint graph:
![image](https://user-images.githubusercontent.com/5728515/47898611-937fbd00-deb1-11e8-8869-20b26cf2cfaf.png)

Here unlike p1 separating from p2 p3 is connecting with p4 in the graph which makes them alias to each other.

Is that supposed to be right? How can I tell p3 from p4 with SVF?</Description>
    <Title_Description>Tell the different objects from custom alloc functions Hi Yulei

I have a question using SVF with sample code below:

`#include &lt;stdlib.h&gt;

void my_malloc(char ** punsigned size){
    *p = malloc(size);
}

void f(void){
    char *p1*p2*p3*p4;
    p1 = malloc(1);
    p2 = malloc(2);
    my_malloc(&amp;p33);
    my_malloc(&amp;p44);
}`

So p1p2p3p4 should point to different objects right?

By using 'wpa -nander -dump-consG test.bc' I got the following constraint graph:
![image](https://user-images.githubusercontent.com/5728515/47898611-937fbd00-deb1-11e8-8869-20b26cf2cfaf.png)

Here unlike p1 separating from p2 p3 is connecting with p4 in the graph which makes them alias to each other.

Is that supposed to be right? How can I tell p3 from p4 with SVF?</Title_Description>
    <Label>question</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>2/11/2018 7:51:36 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>104</IssueLabelID>
    <Title>How to perform a slicing on top of SVFG</Title>
    <Description>Hi Yulei
From your previous response in [issue #81](https://github.com/SVF-tools/SVF/issues/81) is it correct to say that the SVFG provided by this tool does not include the value dependency of scalars? For example
```c
#include &lt;stdio.h&gt;


int func_first(int zeta int gamma)
{
	zeta = zeta * gamma * 2;
	return (zeta + 1);
}

int func_second(int gamma)
{
	return (gamma + 2);
}

int main()
{
	int number = 5;
	int zeta = 0;
	int gamma = 0;
	int *ptr = &amp;zeta;
	int iter = 1;
	while (iter &lt; number) {
		if (iter &lt; 3)
			zeta = func_first(*ptr gamma); // slicing criterion
		else 
			zeta = func_first(iter gamma);
		gamma = func_second(zeta);
		iter++;
	}

	return gamma;
}
```
In this program I also want to capture the value that flows into `func_first` and flows back to `main` but the SVFG does not seem to provide that result:
![fs_svfg](https://user-images.githubusercontent.com/11516654/47526144-e41d6780-d86c-11e8-9813-144d583b212d.png)

So for example if I want to do both a backward and forward slicing with criterion `zeta = func_first(*ptr gamma);` I need to combine your SVFG and the LLVM def-use chains to create a new graph and do the slicing on top of the new graph. Is that correct?

 I am looking forward for your response. Thank you very much!
</Description>
    <Title_Description>How to perform a slicing on top of SVFG Hi Yulei
From your previous response in [issue #81](https://github.com/SVF-tools/SVF/issues/81) is it correct to say that the SVFG provided by this tool does not include the value dependency of scalars? For example
```c
#include &lt;stdio.h&gt;


int func_first(int zeta int gamma)
{
	zeta = zeta * gamma * 2;
	return (zeta + 1);
}

int func_second(int gamma)
{
	return (gamma + 2);
}

int main()
{
	int number = 5;
	int zeta = 0;
	int gamma = 0;
	int *ptr = &amp;zeta;
	int iter = 1;
	while (iter &lt; number) {
		if (iter &lt; 3)
			zeta = func_first(*ptr gamma); // slicing criterion
		else 
			zeta = func_first(iter gamma);
		gamma = func_second(zeta);
		iter++;
	}

	return gamma;
}
```
In this program I also want to capture the value that flows into `func_first` and flows back to `main` but the SVFG does not seem to provide that result:
![fs_svfg](https://user-images.githubusercontent.com/11516654/47526144-e41d6780-d86c-11e8-9813-144d583b212d.png)

So for example if I want to do both a backward and forward slicing with criterion `zeta = func_first(*ptr gamma);` I need to combine your SVFG and the LLVM def-use chains to create a new graph and do the slicing on top of the new graph. Is that correct?

 I am looking forward for your response. Thank you very much!
</Title_Description>
    <Label>enhancement|question</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>25/10/2018 7:51:27 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>101</IssueLabelID>
    <Title>crash dumping svfg</Title>
    <Description>Maybe related to issue of same name ( #98 ) but creating a new one because this issue is mostly an attempt to prevent another instance where I'm sitting on a patch (recent UAF fixes #100 and sibling commit) that might be useful to folks.  Any lack of sharing was because I haven't had time to do due diligence in terms of investigating things more completely....

Anyway I would feel bad if this was the cause of something like #98 and I didn't at least forward it :).

This patch has been part of my build for a good while in order to stop crashing when dumping the SVFG in my usage:

https://github.com/dtzWill/nur-packages/blob/master/pkgs/svf/svfg-crash-fix.patch

Hope this helps close or modify the change as you see fit! Thanks again for SVF!</Description>
    <Title_Description>crash dumping svfg Maybe related to issue of same name ( #98 ) but creating a new one because this issue is mostly an attempt to prevent another instance where I'm sitting on a patch (recent UAF fixes #100 and sibling commit) that might be useful to folks.  Any lack of sharing was because I haven't had time to do due diligence in terms of investigating things more completely....

Anyway I would feel bad if this was the cause of something like #98 and I didn't at least forward it :).

This patch has been part of my build for a good while in order to stop crashing when dumping the SVFG in my usage:

https://github.com/dtzWill/nur-packages/blob/master/pkgs/svf/svfg-crash-fix.patch

Hope this helps close or modify the change as you see fit! Thanks again for SVF!</Title_Description>
    <Label>bug</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>18/10/2018 11:15:19 PM +00:00</CreatedAt>
    <ClosedAt>24/10/2018 1:31:52 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>99</IssueLabelID>
    <Title>Use After Free in moveInEdgesToRepNode</Title>
    <Description>The following code inside _moveInEdgesToRepNode_ references an edge after it's deletion:
```
else if (isa&lt;GepCGEdge&gt;(edge)) {
    removeDirectEdge(edge); // free
    // If the GEP is critical (i.e. may have a non-zero offset)
    // then it brings impact on field-sensitivity.
    if (!isZeroOffsettedGepCGEdge(edge)) { // use
        criticalGepInsideSCC = true;
    }
}
```</Description>
    <Title_Description>Use After Free in moveInEdgesToRepNode The following code inside _moveInEdgesToRepNode_ references an edge after it's deletion:
```
else if (isa&lt;GepCGEdge&gt;(edge)) {
    removeDirectEdge(edge); // free
    // If the GEP is critical (i.e. may have a non-zero offset)
    // then it brings impact on field-sensitivity.
    if (!isZeroOffsettedGepCGEdge(edge)) { // use
        criticalGepInsideSCC = true;
    }
}
```</Title_Description>
    <Label>bug</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>18/10/2018 12:54:06 PM +00:00</CreatedAt>
    <ClosedAt>24/10/2018 1:31:59 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>98</IssueLabelID>
    <Title>Segfault when dumping svfg</Title>
    <Description>Got a segmentation fault when trying to -dump-svfg with saber. 

Attached are the results of the following commands and the LLVM bitcode
wpa -ander -svfg  ex.bc  
saber -dfree ex.bc
[svf_bug.zip](https://github.com/SVF-tools/SVF/files/2469947/svf_bug.zip)


Segfault command is
saber -dump-svfg ex.bc

</Description>
    <Title_Description>Segfault when dumping svfg Got a segmentation fault when trying to -dump-svfg with saber. 

Attached are the results of the following commands and the LLVM bitcode
wpa -ander -svfg  ex.bc  
saber -dfree ex.bc
[svf_bug.zip](https://github.com/SVF-tools/SVF/files/2469947/svf_bug.zip)


Segfault command is
saber -dump-svfg ex.bc

</Title_Description>
    <Label>duplicate</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>11/10/2018 5:18:02 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>95</IssueLabelID>
    <Title>Value Flow of an address Taken variable</Title>
    <Description>Hi

I hope this is the right place to ask this question.

I am hoping to capture the uses of an address taken variable throughout a program in terms of LLVM values and then any corresponding Allocations in case of any stores. What I am doing right now is to get the SVFGNode of the variable and traverse over all outgoing edges. If it's an StmtSVFGNode I can get the corresponding LLVM value/instruction easily and I have done that already. However I'm unable to follow the value inter-procedurally. I'm not sure how to get CallSites where there is a use for this address taken variable as a parameter. Can you please guide me about how to follow the value inter-procedurally?

Thanks</Description>
    <Title_Description>Value Flow of an address Taken variable Hi

I hope this is the right place to ask this question.

I am hoping to capture the uses of an address taken variable throughout a program in terms of LLVM values and then any corresponding Allocations in case of any stores. What I am doing right now is to get the SVFGNode of the variable and traverse over all outgoing edges. If it's an StmtSVFGNode I can get the corresponding LLVM value/instruction easily and I have done that already. However I'm unable to follow the value inter-procedurally. I'm not sure how to get CallSites where there is a use for this address taken variable as a parameter. Can you please guide me about how to follow the value inter-procedurally?

Thanks</Title_Description>
    <Label>invalid</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>31/08/2018 1:31:03 PM +00:00</CreatedAt>
    <ClosedAt>31/08/2018 1:42:12 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>94</IssueLabelID>
    <Title>Why is HANDBLACKHOLE by default false?</Title>
    <Description>Hi @yuleisui 
Is this a sound choice?
This causes the `pointsTo` of `argv` of `main` function to be empty. IMO this is not correct. We should add a dummy or a black hole node. 
I know that this flag could be turned on but was wondering whether the value should be by default `true`?
</Description>
    <Title_Description>Why is HANDBLACKHOLE by default false? Hi @yuleisui 
Is this a sound choice?
This causes the `pointsTo` of `argv` of `main` function to be empty. IMO this is not correct. We should add a dummy or a black hole node. 
I know that this flag could be turned on but was wondering whether the value should be by default `true`?
</Title_Description>
    <Label>question</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>24/08/2018 9:54:29 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>93</IssueLabelID>
    <Title>Disabling dynamic call-graph update in FlowSensitive analysis.</Title>
    <Description>Hi @yuleisui 

I was evaluating something and want to know..if there is some way to disable dynamic call-graph update in `FlowSensitive` analysis? Basically I want the `FlowSensitive` analysis to use a prebuild call-graph. </Description>
    <Title_Description>Disabling dynamic call-graph update in FlowSensitive analysis. Hi @yuleisui 

I was evaluating something and want to know..if there is some way to disable dynamic call-graph update in `FlowSensitive` analysis? Basically I want the `FlowSensitive` analysis to use a prebuild call-graph. </Title_Description>
    <Label>enhancement|question</Label>
    <Assignee>yuleisui|Machiry</Assignee>
    <CreatedAt>19/08/2018 10:49:13 PM +00:00</CreatedAt>
    <ClosedAt>20/08/2018 5:44:05 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>92</IssueLabelID>
    <Title>Def site of a PAGNode</Title>
    <Description>Hi
I’m trying to find a definition site (defining SVFGNode) for a given llvm instruction. What I’m doing is first find PAGNode corresponding to given llvm::Instruction* then call SVFG’s getDefSVFGNode function for it. However it doesn’t seem to return definition node. For example for load instruction the returned svfg node is a StmtSVFGNode corresponding to the same load instruction. Here is the code snippet and part of it's IR I'm using
```
void test(int* b)
{
    int a = 0;
    if (b) {
        a = *b + 42;
    }
    int c = a;
    c++;
}
```
```
define void @test(i32* %b) #0 {
entry:
  %b.addr = alloca i32* align 8
  %a = alloca i32 align 4
  %c = alloca i32 align 4
  store i32* %b i32** %b.addr align 8
  store i32 0 i32* %a align 4
  **%0 = load i32* i32** %b.addr align 8**
  %tobool = icmp ne i32* %0 null
  br i1 %tobool label %if.then label %if.end
.....
}
```
The load instruction is _%0 = load i32* i32** %b.addr align 8_ getDefSVFGNode returns StmtSVFGNode which instruction is the same load. 

My question is how should I get definition node of a pointer use from SVFG? And is it even the correct approach or should I use MemSSA instead of SVFG to get this information?

Thanks.</Description>
    <Title_Description>Def site of a PAGNode Hi
I’m trying to find a definition site (defining SVFGNode) for a given llvm instruction. What I’m doing is first find PAGNode corresponding to given llvm::Instruction* then call SVFG’s getDefSVFGNode function for it. However it doesn’t seem to return definition node. For example for load instruction the returned svfg node is a StmtSVFGNode corresponding to the same load instruction. Here is the code snippet and part of it's IR I'm using
```
void test(int* b)
{
    int a = 0;
    if (b) {
        a = *b + 42;
    }
    int c = a;
    c++;
}
```
```
define void @test(i32* %b) #0 {
entry:
  %b.addr = alloca i32* align 8
  %a = alloca i32 align 4
  %c = alloca i32 align 4
  store i32* %b i32** %b.addr align 8
  store i32 0 i32* %a align 4
  **%0 = load i32* i32** %b.addr align 8**
  %tobool = icmp ne i32* %0 null
  br i1 %tobool label %if.then label %if.end
.....
}
```
The load instruction is _%0 = load i32* i32** %b.addr align 8_ getDefSVFGNode returns StmtSVFGNode which instruction is the same load. 

My question is how should I get definition node of a pointer use from SVFG? And is it even the correct approach or should I use MemSSA instead of SVFG to get this information?

Thanks.</Title_Description>
    <Label>question</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>16/08/2018 9:37:43 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>88</IssueLabelID>
    <Title>Are all the tests in PTABench expected to pass?</Title>
    <Description>Hi @yuleisui

I am seeing that few tests in PTABench https://github.com/SVF-tools/PTABen are failing with existing pointer analysis techniques. 
Is this expected?

Do we have some whitelist/blacklist of tests that are obsolete?</Description>
    <Title_Description>Are all the tests in PTABench expected to pass? Hi @yuleisui

I am seeing that few tests in PTABench https://github.com/SVF-tools/PTABen are failing with existing pointer analysis techniques. 
Is this expected?

Do we have some whitelist/blacklist of tests that are obsolete?</Title_Description>
    <Label>enhancement|question</Label>
    <Assignee>yuleisui|yiyuaner|Machiry</Assignee>
    <CreatedAt>15/08/2018 12:28:53 AM +00:00</CreatedAt>
    <ClosedAt>16/08/2018 5:24:59 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>86</IssueLabelID>
    <Title>Can I run multiple instances of the same Pointer analysis in a single run?</Title>
    <Description>Hi @yuleisui

I was trying to run multiple instances of same pointer analysis on the same `svfModule` in a single program. 

I am seeing some inconsistencies w.r.t to field sensitivity of certain objects.
Before trying to debug I want to know if this is supported or there is certain mutable global state maintained that could affect multiple instances of the same pointer analysis?</Description>
    <Title_Description>Can I run multiple instances of the same Pointer analysis in a single run? Hi @yuleisui

I was trying to run multiple instances of same pointer analysis on the same `svfModule` in a single program. 

I am seeing some inconsistencies w.r.t to field sensitivity of certain objects.
Before trying to debug I want to know if this is supported or there is certain mutable global state maintained that could affect multiple instances of the same pointer analysis?</Title_Description>
    <Label>enhancement|help wanted|question</Label>
    <Assignee>yuleisui|Machiry</Assignee>
    <CreatedAt>12/08/2018 6:52:56 AM +00:00</CreatedAt>
    <ClosedAt>14/08/2018 4:09:32 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>83</IssueLabelID>
    <Title>Can IntraDirSVFGEdge having srcNode and dstNode from different functions?</Title>
    <Description>Hi @yuleisui

I am facing an issue where an `IntraDirSVFGEdge` has the src node (`getSrcNode` ) and dst node (`getDstNode` ) belong to **different functions**. 

However by definition *Intra* edges should only connect nodes that belong to the same function.

Can this happen? If yes could you please describe what does this mean? Why do we need to make it an IntraDir edge?</Description>
    <Title_Description>Can IntraDirSVFGEdge having srcNode and dstNode from different functions? Hi @yuleisui

I am facing an issue where an `IntraDirSVFGEdge` has the src node (`getSrcNode` ) and dst node (`getDstNode` ) belong to **different functions**. 

However by definition *Intra* edges should only connect nodes that belong to the same function.

Can this happen? If yes could you please describe what does this mean? Why do we need to make it an IntraDir edge?</Title_Description>
    <Label>bug</Label>
    <Assignee>yuleisui|Machiry</Assignee>
    <CreatedAt>9/08/2018 11:48:07 PM +00:00</CreatedAt>
    <ClosedAt>12/08/2018 6:46:55 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>82</IssueLabelID>
    <Title>Path Dependence Analysis</Title>
    <Description>Hello amazing project.

I have a question it's possible to make  _Path Dependence Analysis_ based on _SVF_? If yes what's the direction one should take.

Thanks</Description>
    <Title_Description>Path Dependence Analysis Hello amazing project.

I have a question it's possible to make  _Path Dependence Analysis_ based on _SVF_? If yes what's the direction one should take.

Thanks</Title_Description>
    <Label>help wanted|question</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>28/07/2018 7:10:13 AM +00:00</CreatedAt>
    <ClosedAt>28/07/2018 8:35:28 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>81</IssueLabelID>
    <Title>Question about using this tool</Title>
    <Description>Hi

This is an interesting work and I want to use it for some interesting analysis.
However I have no idea where to start.
My goal is to find the value flow dependency between two variables:

example:

foo() {
int a = 1;
bar(a);
}

bar(int a) {
int b = a + 1;
}

If I want to find the data dependency between a and b how should I do?
Which file should I refer to for more information?

Thanks</Description>
    <Title_Description>Question about using this tool Hi

This is an interesting work and I want to use it for some interesting analysis.
However I have no idea where to start.
My goal is to find the value flow dependency between two variables:

example:

foo() {
int a = 1;
bar(a);
}

bar(int a) {
int b = a + 1;
}

If I want to find the data dependency between a and b how should I do?
Which file should I refer to for more information?

Thanks</Title_Description>
    <Label>question</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>24/07/2018 12:37:30 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>80</IssueLabelID>
    <Title>Implementing a flow and context-sensitive pointer analysis</Title>
    <Description>Hi @yuleisui

Let's say I want to add context-sensitivity to the flow-analysis.
Precisely I want context-sensitive heap and stack objects.

I am thinking of the following implementation plan Could you please let me know if this looks okay?

1) Modify `MemModel.h` to add context information to all the PAGNodes. Basically build a context-sensitive PAG: This will take care of creating the correct constraint graph.

2) Add new pointer analysis to use `CondPTAImpl` that uses context.

Does this plan look valid? Or there is a better way to implement this?</Description>
    <Title_Description>Implementing a flow and context-sensitive pointer analysis Hi @yuleisui

Let's say I want to add context-sensitivity to the flow-analysis.
Precisely I want context-sensitive heap and stack objects.

I am thinking of the following implementation plan Could you please let me know if this looks okay?

1) Modify `MemModel.h` to add context information to all the PAGNodes. Basically build a context-sensitive PAG: This will take care of creating the correct constraint graph.

2) Add new pointer analysis to use `CondPTAImpl` that uses context.

Does this plan look valid? Or there is a better way to implement this?</Title_Description>
    <Label>enhancement</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>23/07/2018 9:40:59 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>79</IssueLabelID>
    <Title>Regression test cases?</Title>
    <Description>I noticed there is repo (https://github.com/SVF-tools/PTABen) containing a micro-benchmark suite 

Is it possible to provide a set of real-world projects (maybe just bitcode files) for regression testing?
For example the cclyzer project (https://github.com/plast-lab/cclyzer) includes some bitcodes from coreutils  and postgresql (https://github.com/plast-lab/cclyzer/tree/master/tests/)</Description>
    <Title_Description>Regression test cases? I noticed there is repo (https://github.com/SVF-tools/PTABen) containing a micro-benchmark suite 

Is it possible to provide a set of real-world projects (maybe just bitcode files) for regression testing?
For example the cclyzer project (https://github.com/plast-lab/cclyzer) includes some bitcodes from coreutils  and postgresql (https://github.com/plast-lab/cclyzer/tree/master/tests/)</Title_Description>
    <Label>question</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>23/07/2018 2:55:34 PM +00:00</CreatedAt>
    <ClosedAt>13/09/2018 4:44:38 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>78</IssueLabelID>
    <Title>Path-sensitive points-to analysis?</Title>
    <Description>In `MemoryModel/PointerAnalysis.h`  there are several path-sensitive points-to analyses. 
Are they implemented in current version? If so does SVF provide command-line interface for choosing them? Thank you!
~~~~
    /// Pointer analysis type list
    enum PTATY {
       // ...
        FSCSPS_WPA		///&lt; Flow- context- path- sensitive WPA
        ADAPTFSCS_WPA		///&lt; Adaptive Flow- context- sensitive WPA
        ADAPTFSCSPS_WPA	///&lt; Adaptive Flow- context- path- sensitive WPA
       //..
    };
~~~~</Description>
    <Title_Description>Path-sensitive points-to analysis? In `MemoryModel/PointerAnalysis.h`  there are several path-sensitive points-to analyses. 
Are they implemented in current version? If so does SVF provide command-line interface for choosing them? Thank you!
~~~~
    /// Pointer analysis type list
    enum PTATY {
       // ...
        FSCSPS_WPA		///&lt; Flow- context- path- sensitive WPA
        ADAPTFSCS_WPA		///&lt; Adaptive Flow- context- sensitive WPA
        ADAPTFSCSPS_WPA	///&lt; Adaptive Flow- context- path- sensitive WPA
       //..
    };
~~~~</Title_Description>
    <Label>question</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>20/07/2018 6:09:22 AM +00:00</CreatedAt>
    <ClosedAt>20/07/2018 2:08:31 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>77</IssueLabelID>
    <Title>Multiple NodeIDs for a single instruction?</Title>
    <Description>I am looking at a PAG where 2 **different** NodeIDs map to the same Value*.
I have never seen this case. Can this happen?</Description>
    <Title_Description>Multiple NodeIDs for a single instruction? I am looking at a PAG where 2 **different** NodeIDs map to the same Value*.
I have never seen this case. Can this happen?</Title_Description>
    <Label>question</Label>
    <Assignee>Machiry|yuleisui</Assignee>
    <CreatedAt>19/07/2018 6:35:16 AM +00:00</CreatedAt>
    <ClosedAt>21/07/2018 9:16:27 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>76</IssueLabelID>
    <Title>Point-to results inconsistencies</Title>
    <Description>I have following points to information at the following load instruction:
```
%7 = load i8* i8** @auth_check2.authpath align 8 !dbg !1478 !tbaa !1470
##&lt;&gt; Source Loc: ln: 1047 fl: libhttpd.c
Ptr 12954         PointsTo: { 11314 11334 }

!!Target NodeID 11314     [&lt;call&gt; Source Loc: ln: 716 fl: libhttpd.c] 
!!Target NodeID 11334     [&lt;call19&gt; Source Loc: ln: 724 fl: libhttpd.c] 
```
This implies that `@auth_check2.authpath` is a top level pointer that points to some objects which in turn should **atleast** point to the nodes `11314` and  `11334` am I right?

So I checked the points to of the pointer operand I get the following:
```
##&lt;auth_check2.authpath&gt; Source Loc: Glob 
Ptr 1474         PointsTo: { 1475 }

!!Target NodeID 1475     [&lt;auth_check2.authpath&gt; Source Loc: Glob ] 
```
Ok this is the first level object seems to be valid.

Now when I check the points to objects of the node `1475` I get:

```
##&lt;auth_check2.authpath&gt; Source Loc: Glob 
Ptr 1475         PointsTo: {empty}
```
I expect to see `11314` and  `11334`. 

How is this possible that the points to are empty whereas the `load` instruction points to is not? I am baffled.</Description>
    <Title_Description>Point-to results inconsistencies I have following points to information at the following load instruction:
```
%7 = load i8* i8** @auth_check2.authpath align 8 !dbg !1478 !tbaa !1470
##&lt;&gt; Source Loc: ln: 1047 fl: libhttpd.c
Ptr 12954         PointsTo: { 11314 11334 }

!!Target NodeID 11314     [&lt;call&gt; Source Loc: ln: 716 fl: libhttpd.c] 
!!Target NodeID 11334     [&lt;call19&gt; Source Loc: ln: 724 fl: libhttpd.c] 
```
This implies that `@auth_check2.authpath` is a top level pointer that points to some objects which in turn should **atleast** point to the nodes `11314` and  `11334` am I right?

So I checked the points to of the pointer operand I get the following:
```
##&lt;auth_check2.authpath&gt; Source Loc: Glob 
Ptr 1474         PointsTo: { 1475 }

!!Target NodeID 1475     [&lt;auth_check2.authpath&gt; Source Loc: Glob ] 
```
Ok this is the first level object seems to be valid.

Now when I check the points to objects of the node `1475` I get:

```
##&lt;auth_check2.authpath&gt; Source Loc: Glob 
Ptr 1475         PointsTo: {empty}
```
I expect to see `11314` and  `11334`. 

How is this possible that the points to are empty whereas the `load` instruction points to is not? I am baffled.</Title_Description>
    <Label>question</Label>
    <Assignee>Machiry|yuleisui</Assignee>
    <CreatedAt>9/07/2018 6:54:30 PM +00:00</CreatedAt>
    <ClosedAt>23/07/2018 9:04:54 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>75</IssueLabelID>
    <Title>Is SVFG flow-sensitive?</Title>
    <Description>First question: Is SVFG flow-sensitive? It uses memory SSA but doesn't respect the control-flow.  
For example: If a `store` and `load` define and use the same region they will be connected **irrespective** of whether there is a path from the store to load in the CFG.

If SVFG is not flow-sensitive How is the `FlowSensitive` pointer analysis (type: `FSSPARSE_WPA`) flow sensitive? As it solves the constraints over the SVFG.</Description>
    <Title_Description>Is SVFG flow-sensitive? First question: Is SVFG flow-sensitive? It uses memory SSA but doesn't respect the control-flow.  
For example: If a `store` and `load` define and use the same region they will be connected **irrespective** of whether there is a path from the store to load in the CFG.

If SVFG is not flow-sensitive How is the `FlowSensitive` pointer analysis (type: `FSSPARSE_WPA`) flow sensitive? As it solves the constraints over the SVFG.</Title_Description>
    <Label>question</Label>
    <Assignee>Machiry|yuleisui</Assignee>
    <CreatedAt>8/07/2018 2:58:10 AM +00:00</CreatedAt>
    <ClosedAt>9/07/2018 6:52:46 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>70</IssueLabelID>
    <Title>Unsound points-to results?</Title>
    <Description>I am trying to find aliases for a pointer specifically `netibuf`.

Target (simplified) source of the program (`telnet`):
```
Ring netiring;
unsigned char  netibuf[BUFSIZ];
void init_network (void)
{
 ..
  if (ring_init (&amp;netiring netibuf sizeof netibuf) != 1)
    {
      exit (EXIT_FAILURE);
    }
  ..
}

int ring_init (Ring * ring unsigned char *buffer int count)
{
  memset ((char *) ring 0 sizeof *ring);

  ring-&gt;size = count;

  ring-&gt;supply = ring-&gt;consume = ring-&gt;bottom = buffer;
  ...
}
```

I use the following code:

```
PointerAnalysis* currPta = new AndersenWaveDiffWithType();
currPta-&gt;analyze(svfModule);
// get the PAG
PAG *currentPAG = currPta-&gt;getPAG();
// Get the top-level variable
GlobalVariable *targetGlobVar = targetModule-&gt;getGlobalVariable("netibuf" true);

// get node id
NodeID targetNode = currentPAG-&gt;getValueNode(targetGlobVar);

// then I search for aliases
for (NodeBS::iterator nIter = currPta-&gt;getAllValidPtrs().begin();
                 nIter != currPta-&gt;getAllValidPtrs().end();
                 ++nIter) {
                if (currPta-&gt;alias(*nIter targetNode) != NoAlias) {
                    if (targetAliases.find(*nIter) == targetAliases.end()) {
                       dbgs() &lt;&lt; "[+] Alias found:" &lt;&lt; *nIter &lt;&lt; "\n";
                    }
                }
  }
```

The above doesn't print any aliases however as we can see in the program source above `netibuf` has aliases. These results are not sound Am I missing something here?

Attached is the bc file [telnet.0.4.opt.mem2reg.bc.zip](https://github.com/SVF-tools/SVF/files/2157717/telnet.0.4.opt.mem2reg.bc.zip) of the `telnet` that I am using. The target source code is of `telnet` is available here: https://ftp.gnu.org/gnu/inetutils/inetutils-1.9.4.tar.gz
</Description>
    <Title_Description>Unsound points-to results? I am trying to find aliases for a pointer specifically `netibuf`.

Target (simplified) source of the program (`telnet`):
```
Ring netiring;
unsigned char  netibuf[BUFSIZ];
void init_network (void)
{
 ..
  if (ring_init (&amp;netiring netibuf sizeof netibuf) != 1)
    {
      exit (EXIT_FAILURE);
    }
  ..
}

int ring_init (Ring * ring unsigned char *buffer int count)
{
  memset ((char *) ring 0 sizeof *ring);

  ring-&gt;size = count;

  ring-&gt;supply = ring-&gt;consume = ring-&gt;bottom = buffer;
  ...
}
```

I use the following code:

```
PointerAnalysis* currPta = new AndersenWaveDiffWithType();
currPta-&gt;analyze(svfModule);
// get the PAG
PAG *currentPAG = currPta-&gt;getPAG();
// Get the top-level variable
GlobalVariable *targetGlobVar = targetModule-&gt;getGlobalVariable("netibuf" true);

// get node id
NodeID targetNode = currentPAG-&gt;getValueNode(targetGlobVar);

// then I search for aliases
for (NodeBS::iterator nIter = currPta-&gt;getAllValidPtrs().begin();
                 nIter != currPta-&gt;getAllValidPtrs().end();
                 ++nIter) {
                if (currPta-&gt;alias(*nIter targetNode) != NoAlias) {
                    if (targetAliases.find(*nIter) == targetAliases.end()) {
                       dbgs() &lt;&lt; "[+] Alias found:" &lt;&lt; *nIter &lt;&lt; "\n";
                    }
                }
  }
```

The above doesn't print any aliases however as we can see in the program source above `netibuf` has aliases. These results are not sound Am I missing something here?

Attached is the bc file [telnet.0.4.opt.mem2reg.bc.zip](https://github.com/SVF-tools/SVF/files/2157717/telnet.0.4.opt.mem2reg.bc.zip) of the `telnet` that I am using. The target source code is of `telnet` is available here: https://ftp.gnu.org/gnu/inetutils/inetutils-1.9.4.tar.gz
</Title_Description>
    <Label>enhancement</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>3/07/2018 5:12:41 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>69</IssueLabelID>
    <Title>Inconsistencies in Points to information</Title>
    <Description>I am trying to get points to information of a dynamically created object.

Source code:

```
void indirect_allocator(char **ptr int s) {
    if(*ptr == NULL) {
        *ptr = malloc(s);
    }
}
int main() {
    int h;
    static char *global_ptr;
    scanf("%d" &amp;h);
    if(h &lt; 4) {
        indirect_allocator(&amp;global_ptr h*3);
    } else {
        indirect_allocator(&amp;global_ptr h*5);
    }
    
    global_ptr[0] = 'f';
    global_ptr[1] = 'q';
    global_ptr[2] = 'a' + h;
    global_ptr[3] = '\0';
    printf("%s" global_ptr);
} 
```
Here the goal is to identify that `global_ptr[*]` instructions in the `main` function are aliases to the object allocated by the `malloc` call of `indirect_allocator` function.

I am using the following code:
```
PointerAnalysis* currPta = new AndersenWaveDiffWithType();
currPta-&gt;analyze(svfModule);
// get the PAG
PAG *currentPAG = currPta-&gt;getPAG();
// Get the top-level variable
GlobalVariable *targetGlobVar = targetModule-&gt;getGlobalVariable("main.global_ptr" true);

// get points_to
NodeID targetNode = currentPAG-&gt;getValueNode(targetGlobVar);
PointsTo&amp; objs = currPta-&gt;getPts(targetNode);
// here objs contains only one node which is right i.e. @main.global_ptr = internal global i8* null align 8

// Now let's get objects pointed by this node.
PointsTo&amp; objs2 = currPta-&gt;getPts(objs.find_first());
// here objs2 contains only one node which is correct i.e. %call = call i8* @malloc(i64 %conv)

// Now when I try to get all aliases to the malloced object i.e. (the above %call..)
std::set&lt;NodeID&gt; targetAliases;
targetAliases.clear();
for (NodeBS::iterator nIter = currPta-&gt;getAllValidPtrs().begin();
                nIter != currPta-&gt;getAllValidPtrs().end();
                ++nIter) {
            if(currPta-&gt;alias(*nIter objs2.find_first()) != NoAlias) {
                if(targetAliases.find(*nIter) == targetAliases.end()) {
                    targetAliases.insert(*nIter);
                }
            }
        }

// I get NO aliases..
```

I expect to see the `load` and `getelementptr` instructions of the main function..but I do not see anything.

Am I missing something here?

Attached is the source file `global_ptr_head_obj.c` and the corresponding bitcode file (`global_ptr_head_obj.mem2reg.bc`) on which I am trying to run the analysis.

[global_ptr_example.zip](https://github.com/SVF-tools/SVF/files/2154145/global_ptr_example.zip)
</Description>
    <Title_Description>Inconsistencies in Points to information I am trying to get points to information of a dynamically created object.

Source code:

```
void indirect_allocator(char **ptr int s) {
    if(*ptr == NULL) {
        *ptr = malloc(s);
    }
}
int main() {
    int h;
    static char *global_ptr;
    scanf("%d" &amp;h);
    if(h &lt; 4) {
        indirect_allocator(&amp;global_ptr h*3);
    } else {
        indirect_allocator(&amp;global_ptr h*5);
    }
    
    global_ptr[0] = 'f';
    global_ptr[1] = 'q';
    global_ptr[2] = 'a' + h;
    global_ptr[3] = '\0';
    printf("%s" global_ptr);
} 
```
Here the goal is to identify that `global_ptr[*]` instructions in the `main` function are aliases to the object allocated by the `malloc` call of `indirect_allocator` function.

I am using the following code:
```
PointerAnalysis* currPta = new AndersenWaveDiffWithType();
currPta-&gt;analyze(svfModule);
// get the PAG
PAG *currentPAG = currPta-&gt;getPAG();
// Get the top-level variable
GlobalVariable *targetGlobVar = targetModule-&gt;getGlobalVariable("main.global_ptr" true);

// get points_to
NodeID targetNode = currentPAG-&gt;getValueNode(targetGlobVar);
PointsTo&amp; objs = currPta-&gt;getPts(targetNode);
// here objs contains only one node which is right i.e. @main.global_ptr = internal global i8* null align 8

// Now let's get objects pointed by this node.
PointsTo&amp; objs2 = currPta-&gt;getPts(objs.find_first());
// here objs2 contains only one node which is correct i.e. %call = call i8* @malloc(i64 %conv)

// Now when I try to get all aliases to the malloced object i.e. (the above %call..)
std::set&lt;NodeID&gt; targetAliases;
targetAliases.clear();
for (NodeBS::iterator nIter = currPta-&gt;getAllValidPtrs().begin();
                nIter != currPta-&gt;getAllValidPtrs().end();
                ++nIter) {
            if(currPta-&gt;alias(*nIter objs2.find_first()) != NoAlias) {
                if(targetAliases.find(*nIter) == targetAliases.end()) {
                    targetAliases.insert(*nIter);
                }
            }
        }

// I get NO aliases..
```

I expect to see the `load` and `getelementptr` instructions of the main function..but I do not see anything.

Am I missing something here?

Attached is the source file `global_ptr_head_obj.c` and the corresponding bitcode file (`global_ptr_head_obj.mem2reg.bc`) on which I am trying to run the analysis.

[global_ptr_example.zip](https://github.com/SVF-tools/SVF/files/2154145/global_ptr_example.zip)
</Title_Description>
    <Label>question</Label>
    <Assignee>yuleisui|Machiry</Assignee>
    <CreatedAt>2/07/2018 7:19:35 AM +00:00</CreatedAt>
    <ClosedAt>23/07/2018 9:03:33 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>68</IssueLabelID>
    <Title>Instructions reachable from function arguments</Title>
    <Description>Hello

I want to use PAG and SVFG graphs to collect instructions reachability information. Particularly for every function I need to find instructions reachable by each of function arguments. Do I understand it correctly that first I’ll need to extend PAG to include all the instructions as now PAGBuilder doesn’t process all types of instructions. Then traverse extended PAG to find instructions reachable from function arguments. Will PAG reflect aliasing information for pointers or do I need to use SVFG for it?

Thanks!</Description>
    <Title_Description>Instructions reachable from function arguments Hello

I want to use PAG and SVFG graphs to collect instructions reachability information. Particularly for every function I need to find instructions reachable by each of function arguments. Do I understand it correctly that first I’ll need to extend PAG to include all the instructions as now PAGBuilder doesn’t process all types of instructions. Then traverse extended PAG to find instructions reachable from function arguments. Will PAG reflect aliasing information for pointers or do I need to use SVFG for it?

Thanks!</Title_Description>
    <Label>question</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>1/07/2018 9:01:02 PM +00:00</CreatedAt>
    <ClosedAt>3/07/2018 9:52:00 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>67</IssueLabelID>
    <Title>Which alloc can reach callsite parameters</Title>
    <Description>Hello 

I am interested in figuring out which instance of a memory allocation function (such as _malloc_) in a program could have allocated memory pointed to by pointers that are passed as arguments to certain functions. Is is possible to extract this information at the source code level with SVF?  I understand that SVF is implemented to use the LLVM IR but curious to know if there is anyway to extract the underlying source code/AST information. </Description>
    <Title_Description>Which alloc can reach callsite parameters Hello 

I am interested in figuring out which instance of a memory allocation function (such as _malloc_) in a program could have allocated memory pointed to by pointers that are passed as arguments to certain functions. Is is possible to extract this information at the source code level with SVF?  I understand that SVF is implemented to use the LLVM IR but curious to know if there is anyway to extract the underlying source code/AST information. </Title_Description>
    <Label>question</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>29/06/2018 10:59:50 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>66</IssueLabelID>
    <Title>SPEC cpu2000</Title>
    <Description>can you tell me how can I get the spec cpu2000? what's the website?</Description>
    <Title_Description>SPEC cpu2000 can you tell me how can I get the spec cpu2000? what's the website?</Title_Description>
    <Label>invalid</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>28/06/2018 5:19:04 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>65</IssueLabelID>
    <Title>Pointer analysis query!</Title>
    <Description>Is there any way to get all the pointers that are aliases to a given pointer or object (ex: alloca).

The way I can think of is..get all the pointers in the IR do `getPts` and compute the intersection.

Is there any other easier or recommended way?
</Description>
    <Title_Description>Pointer analysis query! Is there any way to get all the pointers that are aliases to a given pointer or object (ex: alloca).

The way I can think of is..get all the pointers in the IR do `getPts` and compute the intersection.

Is there any other easier or recommended way?
</Title_Description>
    <Label>question</Label>
    <Assignee>Machiry|yuleisui</Assignee>
    <CreatedAt>28/06/2018 12:58:20 AM +00:00</CreatedAt>
    <ClosedAt>28/06/2018 5:01:44 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>64</IssueLabelID>
    <Title>Program Dependence Graph</Title>
    <Description>Is it possible to dump Program Dependence Graph (PDG) of an entrypoint (a method in a bitcode file) to a DOT file?

Thanks!</Description>
    <Title_Description>Program Dependence Graph Is it possible to dump Program Dependence Graph (PDG) of an entrypoint (a method in a bitcode file) to a DOT file?

Thanks!</Title_Description>
    <Label>question</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>16/06/2018 12:23:08 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>62</IssueLabelID>
    <Title>SVF in VirtualBox</Title>
    <Description>you say we can get the image SVF.ova and we can test the spec2000 and other benchmarks  but i can't connect the image SVF.ova so I want to know the reason .

Thank you!  </Description>
    <Title_Description>SVF in VirtualBox you say we can get the image SVF.ova and we can test the spec2000 and other benchmarks  but i can't connect the image SVF.ova so I want to know the reason .

Thank you!  </Title_Description>
    <Label>enhancement</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>12/06/2018 7:46:49 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>61</IssueLabelID>
    <Title>Call run on module from an other pass</Title>
    <Description>Hello again

I create a pass to use your tool so i integrate your tools in llvm and i can't figure out how to call WPAPass::runOnModule().

I want to call this function to get PTDataTy for flow sensitive pointer analysis.

But this function requires an svfModule and i have no idea how to instanciate it.

Any ideas?..</Description>
    <Title_Description>Call run on module from an other pass Hello again

I create a pass to use your tool so i integrate your tools in llvm and i can't figure out how to call WPAPass::runOnModule().

I want to call this function to get PTDataTy for flow sensitive pointer analysis.

But this function requires an svfModule and i have no idea how to instanciate it.

Any ideas?..</Title_Description>
    <Label>question</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>5/06/2018 3:24:57 PM +00:00</CreatedAt>
    <ClosedAt>7/06/2018 8:25:24 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>60</IssueLabelID>
    <Title>Can we avoid node from collapsing to field-insensitive</Title>
    <Description>Hi I'm using the default AndersonWaveDiff solver to run pointer analysis for c program. But I found the result is not precise since a lot of nodes collapse to field-insensitive. By checking the code it seems to be related to PWC Node. Could you give me more information about PWC Node  e.g. when it would be created? Besides can we avoid node from collapsing to field-insensitive or any other ways to make the result more precise? Thanks!</Description>
    <Title_Description>Can we avoid node from collapsing to field-insensitive Hi I'm using the default AndersonWaveDiff solver to run pointer analysis for c program. But I found the result is not precise since a lot of nodes collapse to field-insensitive. By checking the code it seems to be related to PWC Node. Could you give me more information about PWC Node  e.g. when it would be created? Besides can we avoid node from collapsing to field-insensitive or any other ways to make the result more precise? Thanks!</Title_Description>
    <Label>help wanted</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>4/06/2018 10:00:18 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>59</IssueLabelID>
    <Title>Is it possible to have pointsTo set for a value for a given line/block?</Title>
    <Description>Hello
I wrote a pass in LLVM that required yours so i have theorically access to every object that i want in your tool. Do you know if there is a way to have information about the pointsTo set for a value at a given instruction (or a block) of an LLVM program?
Thanks!</Description>
    <Title_Description>Is it possible to have pointsTo set for a value for a given line/block? Hello
I wrote a pass in LLVM that required yours so i have theorically access to every object that i want in your tool. Do you know if there is a way to have information about the pointsTo set for a value at a given instruction (or a block) of an LLVM program?
Thanks!</Title_Description>
    <Label>invalid</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>4/06/2018 3:42:17 PM +00:00</CreatedAt>
    <ClosedAt>4/06/2018 3:52:49 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>58</IssueLabelID>
    <Title>Wrong number of templates arguments</Title>
    <Description>Hello i'm trying to integrate your work as an LLVM pass to reuse the result for an other pass.
I try to build it with llvm 6 but during the build i have severals errors like:

`llvm-6.0.0.src/include/llvm/Util/DataFlowUtil.h:210:85: error: wrong number of template arguments (1 should be 2)
 class IteratedDominanceFrontier: public llvm::DominanceFrontierBase&lt;llvm::BasicBlock&gt; {`

OR

`error: ‘iterator’ does not name a type
     iterator getIDFSet(llvm::BasicBlock *B) {`

Any ideas?</Description>
    <Title_Description>Wrong number of templates arguments Hello i'm trying to integrate your work as an LLVM pass to reuse the result for an other pass.
I try to build it with llvm 6 but during the build i have severals errors like:

`llvm-6.0.0.src/include/llvm/Util/DataFlowUtil.h:210:85: error: wrong number of template arguments (1 should be 2)
 class IteratedDominanceFrontier: public llvm::DominanceFrontierBase&lt;llvm::BasicBlock&gt; {`

OR

`error: ‘iterator’ does not name a type
     iterator getIDFSet(llvm::BasicBlock *B) {`

Any ideas?</Title_Description>
    <Label>question</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>3/06/2018 1:00:53 PM +00:00</CreatedAt>
    <ClosedAt>4/06/2018 3:38:36 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>57</IssueLabelID>
    <Title>How to know the heap object is a struct or array or element of struct or array</Title>
    <Description>eg. 
typedef struct NODE{
	int data;
	int *c;
	struct NODE* next;
}NODE;
void swap(){
	NODE ni;
	ni.c = (int *)malloc(sizeof(int));
	ni.data = 1;
}
I can get the IR like this 
define void @swap() #0 !dbg !10 {
  %1 = alloca %struct.NODE align 8
  call void @llvm.dbg.declare(metadata %struct.NODE* %1 metadata !13 metadata !DIExpression()) !dbg !21
  %2 = call noalias i8* @malloc(i64 4) #3 !dbg !22
  %3 = bitcast i8* %2 to i32* !dbg !23
  %4 = getelementptr inbounds %struct.NODE %struct.NODE* %1 i32 0 i32 1 !dbg !24
  store i32* %3 i32** %4 align 8 !dbg !25
  %5 = getelementptr inbounds %struct.NODE %struct.NODE* %1 i32 0 i32 0 !dbg !26
  store i32 1 i32* %5 align 8 !dbg !27
  ret void !dbg !28
}
the instruction is  %2 = call noalias i8* @malloc(i64 4) #3 !dbg !22  how to judge the malloc the heap is a struct ? can you give me the code thank you !</Description>
    <Title_Description>How to know the heap object is a struct or array or element of struct or array eg. 
typedef struct NODE{
	int data;
	int *c;
	struct NODE* next;
}NODE;
void swap(){
	NODE ni;
	ni.c = (int *)malloc(sizeof(int));
	ni.data = 1;
}
I can get the IR like this 
define void @swap() #0 !dbg !10 {
  %1 = alloca %struct.NODE align 8
  call void @llvm.dbg.declare(metadata %struct.NODE* %1 metadata !13 metadata !DIExpression()) !dbg !21
  %2 = call noalias i8* @malloc(i64 4) #3 !dbg !22
  %3 = bitcast i8* %2 to i32* !dbg !23
  %4 = getelementptr inbounds %struct.NODE %struct.NODE* %1 i32 0 i32 1 !dbg !24
  store i32* %3 i32** %4 align 8 !dbg !25
  %5 = getelementptr inbounds %struct.NODE %struct.NODE* %1 i32 0 i32 0 !dbg !26
  store i32 1 i32* %5 align 8 !dbg !27
  ret void !dbg !28
}
the instruction is  %2 = call noalias i8* @malloc(i64 4) #3 !dbg !22  how to judge the malloc the heap is a struct ? can you give me the code thank you !</Title_Description>
    <Label>question</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>3/06/2018 12:29:25 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>54</IssueLabelID>
    <Title>data flow between used pointers</Title>
    <Description>Hi
I have seen the data flow from defined pointer to used pointer.
Do you have any API in SVF to get the data flow between used pointer?
For example in Use-after free I wantto  know the flow from the memory malloc to free and its use.
I do not know whether can we derive the flow from memory free to its use?

Thanks! </Description>
    <Title_Description>data flow between used pointers Hi
I have seen the data flow from defined pointer to used pointer.
Do you have any API in SVF to get the data flow between used pointer?
For example in Use-after free I wantto  know the flow from the memory malloc to free and its use.
I do not know whether can we derive the flow from memory free to its use?

Thanks! </Title_Description>
    <Label>question</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>29/05/2018 1:33:26 PM +00:00</CreatedAt>
    <ClosedAt>30/05/2018 5:19:14 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>53</IssueLabelID>
    <Title>Link issues when writing my own pass using SVF</Title>
    <Description>I wrote a pass that leverages SVF but I got some problems when running this pass.

Initially have the following line in my CMAKE file:
target_link_libraries(${PROJECT_NAME} LLVMSvf LLVMCudd ${llvm_libs})

This is similar to what I saw in the WPA tool of SVF. But this has the following linking issues. The reason is that WPA is an executable and LLVMSvf and LLVMCudd are static libraries.
/usr/bin/ld: error: /mnt/data/Research/Library/SVF/build/lib/CUDD/libLLVMCudd.a(cuddExact.c.o): requires dynamic R_X86_64_PC32 reloc against 'free' which may overflow at runtime; recompile with -fPIC
/usr/bin/ld: error: /mnt/data/Research/Library/SVF/build/lib/CUDD/libLLVMCudd.a(cuddAnneal.c.o): requires dynamic R_X86_64_PC32 reloc against 'cuddNextLow' which may overflow at runtime; recompile with -fPIC
/usr/bin/ld: error: /mnt/data/Research/Library/SVF/build/lib/CUDD/libLLVMCudd.a(cuddLinear.c.o): requires dynamic R_X86_64_32 reloc which may overflow at runtime; recompile with -fPIC
/usr/bin/ld: error: /mnt/data/Research/Library/SVF/build/lib/CUDD/libLLVMCudd.a(cuddWindow.c.o): requires dynamic R_X86_64_PC32 reloc against 'cuddSwapInPlace' which may overflow at runtime; recompile with -fPIC
/usr/bin/ld: error: /mnt/data/Research/Library/SVF/build/lib/CUDD/libLLVMCudd.a(cuddGenetic.c.o): requires dynamic R_X86_64_PC32 reloc against 'st_lookup_int' which may overflow at runtime; recompile with -fPIC
...


So I changed the CMAKE file to:
target_link_libraries(${PROJECT_LIB_NAME} Svf Cudd ${llvm_libs})

This can successfully generate the .so file for my pass. However when I ran the pass using opt I got another error:
opt: CommandLine Error: Option 'bitcode-mdindex-threshold' registered more than once!
LLVM ERROR: inconsistency in registered CommandLine options.

Is anybody encounter the same problem?</Description>
    <Title_Description>Link issues when writing my own pass using SVF I wrote a pass that leverages SVF but I got some problems when running this pass.

Initially have the following line in my CMAKE file:
target_link_libraries(${PROJECT_NAME} LLVMSvf LLVMCudd ${llvm_libs})

This is similar to what I saw in the WPA tool of SVF. But this has the following linking issues. The reason is that WPA is an executable and LLVMSvf and LLVMCudd are static libraries.
/usr/bin/ld: error: /mnt/data/Research/Library/SVF/build/lib/CUDD/libLLVMCudd.a(cuddExact.c.o): requires dynamic R_X86_64_PC32 reloc against 'free' which may overflow at runtime; recompile with -fPIC
/usr/bin/ld: error: /mnt/data/Research/Library/SVF/build/lib/CUDD/libLLVMCudd.a(cuddAnneal.c.o): requires dynamic R_X86_64_PC32 reloc against 'cuddNextLow' which may overflow at runtime; recompile with -fPIC
/usr/bin/ld: error: /mnt/data/Research/Library/SVF/build/lib/CUDD/libLLVMCudd.a(cuddLinear.c.o): requires dynamic R_X86_64_32 reloc which may overflow at runtime; recompile with -fPIC
/usr/bin/ld: error: /mnt/data/Research/Library/SVF/build/lib/CUDD/libLLVMCudd.a(cuddWindow.c.o): requires dynamic R_X86_64_PC32 reloc against 'cuddSwapInPlace' which may overflow at runtime; recompile with -fPIC
/usr/bin/ld: error: /mnt/data/Research/Library/SVF/build/lib/CUDD/libLLVMCudd.a(cuddGenetic.c.o): requires dynamic R_X86_64_PC32 reloc against 'st_lookup_int' which may overflow at runtime; recompile with -fPIC
...


So I changed the CMAKE file to:
target_link_libraries(${PROJECT_LIB_NAME} Svf Cudd ${llvm_libs})

This can successfully generate the .so file for my pass. However when I ran the pass using opt I got another error:
opt: CommandLine Error: Option 'bitcode-mdindex-threshold' registered more than once!
LLVM ERROR: inconsistency in registered CommandLine options.

Is anybody encounter the same problem?</Title_Description>
    <Label>enhancement|question</Label>
    <Assignee>yuleisui|HongxuChen</Assignee>
    <CreatedAt>22/05/2018 12:08:47 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>52</IssueLabelID>
    <Title>svfgNode or PagNode to llvm instruction</Title>
    <Description>Hi 
Do you have any map from svfgnode or pagnode to llvm instruction  or its verse.

I'd like to use the result in SVF to other task.

Thanks</Description>
    <Title_Description>svfgNode or PagNode to llvm instruction Hi 
Do you have any map from svfgnode or pagnode to llvm instruction  or its verse.

I'd like to use the result in SVF to other task.

Thanks</Title_Description>
    <Label>question</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>21/05/2018 6:51:02 AM +00:00</CreatedAt>
    <ClosedAt>29/05/2018 1:34:22 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>51</IssueLabelID>
    <Title>isInAWrapper in LeakChecker.cpp</Title>
    <Description>Hi
I check your -leak function in Saber.
I find the function "isInAWrapper" but I don't know what situation it handles.
For example the following is not your case. 
char * malloc_wrap(int n){
	char* ptr = malloc(n);
	return ptr;
}

Can you give me an example to illustrate its application?
Thanks!</Description>
    <Title_Description>isInAWrapper in LeakChecker.cpp Hi
I check your -leak function in Saber.
I find the function "isInAWrapper" but I don't know what situation it handles.
For example the following is not your case. 
char * malloc_wrap(int n){
	char* ptr = malloc(n);
	return ptr;
}

Can you give me an example to illustrate its application?
Thanks!</Title_Description>
    <Label>invalid</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>17/05/2018 2:33:44 AM +00:00</CreatedAt>
    <ClosedAt>21/05/2018 6:45:53 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>50</IssueLabelID>
    <Title>SABER</Title>
    <Description>your saber is flow-sensitive and field-sensitive and Context-Sensitive Interprocedural pointer analysis or not ?</Description>
    <Title_Description>SABER your saber is flow-sensitive and field-sensitive and Context-Sensitive Interprocedural pointer analysis or not ?</Title_Description>
    <Label>question</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>16/05/2018 1:00:25 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>48</IssueLabelID>
    <Title>pointer analysis</Title>
    <Description>how can I get the results of pointer analysis? I want to analysis something from the results (eg. a struct to store the information) I didn't need the .dot file.

if I want to write a flow and field insensitive pointer analysis  can you tell me the detail I don't know how to   make and run the file that I write.</Description>
    <Title_Description>pointer analysis how can I get the results of pointer analysis? I want to analysis something from the results (eg. a struct to store the information) I didn't need the .dot file.

if I want to write a flow and field insensitive pointer analysis  can you tell me the detail I don't know how to   make and run the file that I write.</Title_Description>
    <Label>question</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>14/05/2018 3:18:34 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>47</IssueLabelID>
    <Title>Segmentation fault on Saber</Title>
    <Description>Hi
When I use saber to try the use after free detection but I get the segmantation fault.
The command is : ./saber -uaf $file.bc
I guess that i need use other options together but I don't know which options should I use?

Do you have any documnets about this?</Description>
    <Title_Description>Segmentation fault on Saber Hi
When I use saber to try the use after free detection but I get the segmantation fault.
The command is : ./saber -uaf $file.bc
I guess that i need use other options together but I don't know which options should I use?

Do you have any documnets about this?</Title_Description>
    <Label>bug|help wanted</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>13/05/2018 5:14:02 AM +00:00</CreatedAt>
    <ClosedAt>14/05/2018 1:01:40 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>46</IssueLabelID>
    <Title>Aborted in cudddTable.c:343</Title>
    <Description>Hello
After I have installed SVF as https://github.com/SVF-tools/SVF/wiki/Setup-Guide-(CMake)
I run the example in https://github.com/SVF-tools/SVF/wiki/Analyze-a-Simple-C-Program .

When we run wpa -ander -svfg swap.bc
the program outputs some information but at last it reported the abort as follows:
wpa: $SVF_Home/lib/CUDD/cuddTable.c:343: cuddAllocNode: Assertion `((ptruint) mem &amp; (sizeof(DdNode) - 1)) == 0' failed.

How to solve this problem? thanks</Description>
    <Title_Description>Aborted in cudddTable.c:343 Hello
After I have installed SVF as https://github.com/SVF-tools/SVF/wiki/Setup-Guide-(CMake)
I run the example in https://github.com/SVF-tools/SVF/wiki/Analyze-a-Simple-C-Program .

When we run wpa -ander -svfg swap.bc
the program outputs some information but at last it reported the abort as follows:
wpa: $SVF_Home/lib/CUDD/cuddTable.c:343: cuddAllocNode: Assertion `((ptruint) mem &amp; (sizeof(DdNode) - 1)) == 0' failed.

How to solve this problem? thanks</Title_Description>
    <Label>enhancement|question</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>10/05/2018 6:20:18 AM +00:00</CreatedAt>
    <ClosedAt>13/05/2018 5:11:11 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>45</IssueLabelID>
    <Title>Def/Use chains</Title>
    <Description>Hello

Maybe this is a silly question. After constructing the SVFG how to get all the Defs for each value in IR?

I only found getDefSVFGNode. But this only returns one node. But as a conservative static analysis there should be several instructions that can possibly write to the same memory location. So how can I get all these instructions? 

Thanks!</Description>
    <Title_Description>Def/Use chains Hello

Maybe this is a silly question. After constructing the SVFG how to get all the Defs for each value in IR?

I only found getDefSVFGNode. But this only returns one node. But as a conservative static analysis there should be several instructions that can possibly write to the same memory location. So how can I get all these instructions? 

Thanks!</Title_Description>
    <Label>question</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>27/04/2018 2:40:25 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>44</IssueLabelID>
    <Title>DummyValPN &amp; DummyObjPN</Title>
    <Description>Hello when reading the source code of PointAnalysis I don't quite understand the meaning of DummyValPN &amp; DummyObjPN. The technical documentation said that 

&gt; ... represents an introduced dummy node to achieve field sensitivity when handling external library calls (e.g. memcpy where pointers (LLVM Values) that point to the fields of an struct do not explicitly appear at an instruction)

So in field-insensitive analysis we can entirely ignore these two nodes when trying to get the pts for each node?</Description>
    <Title_Description>DummyValPN &amp; DummyObjPN Hello when reading the source code of PointAnalysis I don't quite understand the meaning of DummyValPN &amp; DummyObjPN. The technical documentation said that 

&gt; ... represents an introduced dummy node to achieve field sensitivity when handling external library calls (e.g. memcpy where pointers (LLVM Values) that point to the fields of an struct do not explicitly appear at an instruction)

So in field-insensitive analysis we can entirely ignore these two nodes when trying to get the pts for each node?</Title_Description>
    <Label>invalid</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>15/04/2018 9:19:11 PM +00:00</CreatedAt>
    <ClosedAt>15/04/2018 9:50:50 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>43</IssueLabelID>
    <Title>Pointer Analysis Types</Title>
    <Description>Hi

Firstly Awesome project! Reading through the source code I had a question about this enum: https://github.com/SVF-tools/SVF/blob/3038078e90eb037ea43aa28ff3a28c05d631be5d/include/MemoryModel/PointerAnalysis.h#L58

A number of analysis I'm interested are listed. However it seems like these are yet to be implemented? Or is there source code available somewhere else that hasn't been merged?</Description>
    <Title_Description>Pointer Analysis Types Hi

Firstly Awesome project! Reading through the source code I had a question about this enum: https://github.com/SVF-tools/SVF/blob/3038078e90eb037ea43aa28ff3a28c05d631be5d/include/MemoryModel/PointerAnalysis.h#L58

A number of analysis I'm interested are listed. However it seems like these are yet to be implemented? Or is there source code available somewhere else that hasn't been merged?</Title_Description>
    <Label>enhancement|question</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>12/04/2018 4:37:58 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>42</IssueLabelID>
    <Title>Flow sensitive intra-procedural analysis and flow-insensitive context in-sensitive inter-procedural analysis</Title>
    <Description>Hi I just got to know this library. I am in need of flow sensitive intra-procedural analysis and flow-insensitive context in-sensitive inter-procedural analysis. Can any one give some tips about how to implement these two analyses based on this tool. This may save a lot of time. Thanks!</Description>
    <Title_Description>Flow sensitive intra-procedural analysis and flow-insensitive context in-sensitive inter-procedural analysis Hi I just got to know this library. I am in need of flow sensitive intra-procedural analysis and flow-insensitive context in-sensitive inter-procedural analysis. Can any one give some tips about how to implement these two analyses based on this tool. This may save a lot of time. Thanks!</Title_Description>
    <Label>question</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>9/04/2018 4:08:03 PM +00:00</CreatedAt>
    <ClosedAt>27/05/2018 8:27:10 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>37</IssueLabelID>
    <Title>Question about Points-to Analysis to statically detect all indirect function calls</Title>
    <Description>Hi 

I am trying to detect all indirect function calls via points-to analysis.
However some of them are missing from my observation.
I have tried it with Andersen AndersenWave AndersenWaveDiff AndersenWaveDiffWithType AndersenLCD with LLVM 4.0. 

When I tried it with Andersen I used the following codes.
&gt; Andersen* pt = new Andersen();
&gt; pt-&gt;analyze(*module);

Then when I get callsite I used the following set of codes.
&gt; if(pt-&gt;hasIndCSCallees((CallInst*)cinst)){   // indirect
&gt;      set &lt;const llvm::Function*&gt; indFuncSet = pt-&gt;getIndCSCallees((CallInst*)cinst);
&gt;      for(auto ifs = indFuncSet.begin(); ifs != indFuncSet.end(); ++ifs){
&gt;             calleeFunc = *ifs;           //This is an indirect callee candidate
&gt;             ......
&gt;      }
&gt; }

Am I doing something wrong?
If so could you tell me what is the most accurate way to detect all indirect callee?</Description>
    <Title_Description>Question about Points-to Analysis to statically detect all indirect function calls Hi 

I am trying to detect all indirect function calls via points-to analysis.
However some of them are missing from my observation.
I have tried it with Andersen AndersenWave AndersenWaveDiff AndersenWaveDiffWithType AndersenLCD with LLVM 4.0. 

When I tried it with Andersen I used the following codes.
&gt; Andersen* pt = new Andersen();
&gt; pt-&gt;analyze(*module);

Then when I get callsite I used the following set of codes.
&gt; if(pt-&gt;hasIndCSCallees((CallInst*)cinst)){   // indirect
&gt;      set &lt;const llvm::Function*&gt; indFuncSet = pt-&gt;getIndCSCallees((CallInst*)cinst);
&gt;      for(auto ifs = indFuncSet.begin(); ifs != indFuncSet.end(); ++ifs){
&gt;             calleeFunc = *ifs;           //This is an indirect callee candidate
&gt;             ......
&gt;      }
&gt; }

Am I doing something wrong?
If so could you tell me what is the most accurate way to detect all indirect callee?</Title_Description>
    <Label>question</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>15/03/2018 10:20:16 PM +00:00</CreatedAt>
    <ClosedAt>20/03/2018 6:08:37 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>36</IssueLabelID>
    <Title>Why are all constant objects treated as the same object?</Title>
    <Description>I'm trying to use the SVF pointer alias analysis to partition the  all abstract memory objects into disjoint sets. So I'm doing something like:

```C++
for(auto&amp; idToType : *pag) {
        if(ObjPN* opn = dyn_cast&lt;ObjPN&gt;(idToType.second)) {
          unsigned nodeId = idToType.first;
          PointsTo&amp; ptsToOrIsPointedTo = _pta-&gt;getPts(nodeId);
          ptsToOrIsPointedTo |= _pta-&gt;getRevPts(nodeId);
          ptsToOrIsPointedTo &amp;= memObjects;
          if(!ptsToOrIsPointedTo.empty()) {
            ptsToOrIsPointedTo.set(nodeId);
            auto foundElem = std::find_if(disjointObjects.begin() disjointObjects.end()
              [&amp;ptsToOrIsPointedTo](const PointsTo&amp; e)
                  {return e.intersects(ptsToOrIsPointedTo);});
            if( foundElem == disjointObjects.end()) {
                disjointObjects.push_front(ptsToOrIsPointedTo);
            } else {
                *foundElem |= ptsToOrIsPointedTo;
            }
          }
        }
    }
```

However when considering something like:

```C
  char* p = cond ? "hello" : "world";
  char* q = "some other string"
```

I get disjoint set like: `[ 1(constObjId)  idOfP ifOfQ]` which makes sense because SVF considers all constants as a single object. So I tried hacking a bit and changed `isConstantObjSym` to always return false. Which kind of gave me the right result in producing 2 disjoint sets: `[idOfP idOfhello idOfWorld]` and `[idOfQ idOfsomeotherstring]`. But it seems that it has assigned multiple ids to the constant string.

I don't understand SVF very well so I'm wondering if there is a deeper reason (aside performance?) as to why constants are all a single object? 

Thanks!



</Description>
    <Title_Description>Why are all constant objects treated as the same object? I'm trying to use the SVF pointer alias analysis to partition the  all abstract memory objects into disjoint sets. So I'm doing something like:

```C++
for(auto&amp; idToType : *pag) {
        if(ObjPN* opn = dyn_cast&lt;ObjPN&gt;(idToType.second)) {
          unsigned nodeId = idToType.first;
          PointsTo&amp; ptsToOrIsPointedTo = _pta-&gt;getPts(nodeId);
          ptsToOrIsPointedTo |= _pta-&gt;getRevPts(nodeId);
          ptsToOrIsPointedTo &amp;= memObjects;
          if(!ptsToOrIsPointedTo.empty()) {
            ptsToOrIsPointedTo.set(nodeId);
            auto foundElem = std::find_if(disjointObjects.begin() disjointObjects.end()
              [&amp;ptsToOrIsPointedTo](const PointsTo&amp; e)
                  {return e.intersects(ptsToOrIsPointedTo);});
            if( foundElem == disjointObjects.end()) {
                disjointObjects.push_front(ptsToOrIsPointedTo);
            } else {
                *foundElem |= ptsToOrIsPointedTo;
            }
          }
        }
    }
```

However when considering something like:

```C
  char* p = cond ? "hello" : "world";
  char* q = "some other string"
```

I get disjoint set like: `[ 1(constObjId)  idOfP ifOfQ]` which makes sense because SVF considers all constants as a single object. So I tried hacking a bit and changed `isConstantObjSym` to always return false. Which kind of gave me the right result in producing 2 disjoint sets: `[idOfP idOfhello idOfWorld]` and `[idOfQ idOfsomeotherstring]`. But it seems that it has assigned multiple ids to the constant string.

I don't understand SVF very well so I'm wondering if there is a deeper reason (aside performance?) as to why constants are all a single object? 

Thanks!



</Title_Description>
    <Label>enhancement|help wanted|question</Label>
    <Assignee>kren1|yuleisui</Assignee>
    <CreatedAt>25/02/2018 4:27:47 PM +00:00</CreatedAt>
    <ClosedAt>27/02/2018 2:45:59 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>35</IssueLabelID>
    <Title>Error with running LLVM gold plugin to generate whole-program bc file </Title>
    <Description>Dear SVF authors 

I followed your [tutorial](https://github.com/SVF-tools/SVF/wiki/Install-LLVM-Gold-Plugin-on-Ubuntu) to build and install LLVM gold plugin on Ubuntu 14.04 (one difference from yours is that I built the plugin under LLVM 3.4 since my LLVM pass is based on 3.4). I successfully built binutils and LLVMgold.so and installed them to /usr/bin and /usr/lib respectively. However when I tried with the example code on the [official site](https://llvm.org/docs/GoldPlugin.html#example-of-link-time-optimization) an error “ar: /usr/lib/bfd-plugins/libLTO.a: invalid ELF header” occurred when `ar q a.a a.o` is run.

I checked the ELF header of libLTO.a using _readelf_ and it seems nothing abnormal with it. I would much appreciate if you could provide some clue on the error. Thanks very much!
```
$ readelf -h /usr/lib/bfd-plugins/libLTO.a
File: /usr/lib/bfd-plugins/libLTO.a(LTODisassembler.cpp.o)
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF64
  Data:                              2's complement little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              REL (Relocatable file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x0
  Start of program headers:          0 (bytes into file)
  Start of section headers:          856 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           0 (bytes)
  Number of program headers:         0
  Size of section headers:           64 (bytes)
  Number of section headers:         24
  Section header string table index: 21

File: /usr/lib/bfd-plugins/libLTO.a(lto.cpp.o)
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF64
  Data:                              2's complement little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              REL (Relocatable file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x0
  Start of program headers:          0 (bytes into file)
  Start of section headers:          174848 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           0 (bytes)
  Number of program headers:         0
  Size of section headers:           64 (bytes)
  Number of section headers:         2561
  Section header string table index: 2558
```
</Description>
    <Title_Description>Error with running LLVM gold plugin to generate whole-program bc file  Dear SVF authors 

I followed your [tutorial](https://github.com/SVF-tools/SVF/wiki/Install-LLVM-Gold-Plugin-on-Ubuntu) to build and install LLVM gold plugin on Ubuntu 14.04 (one difference from yours is that I built the plugin under LLVM 3.4 since my LLVM pass is based on 3.4). I successfully built binutils and LLVMgold.so and installed them to /usr/bin and /usr/lib respectively. However when I tried with the example code on the [official site](https://llvm.org/docs/GoldPlugin.html#example-of-link-time-optimization) an error “ar: /usr/lib/bfd-plugins/libLTO.a: invalid ELF header” occurred when `ar q a.a a.o` is run.

I checked the ELF header of libLTO.a using _readelf_ and it seems nothing abnormal with it. I would much appreciate if you could provide some clue on the error. Thanks very much!
```
$ readelf -h /usr/lib/bfd-plugins/libLTO.a
File: /usr/lib/bfd-plugins/libLTO.a(LTODisassembler.cpp.o)
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF64
  Data:                              2's complement little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              REL (Relocatable file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x0
  Start of program headers:          0 (bytes into file)
  Start of section headers:          856 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           0 (bytes)
  Number of program headers:         0
  Size of section headers:           64 (bytes)
  Number of section headers:         24
  Section header string table index: 21

File: /usr/lib/bfd-plugins/libLTO.a(lto.cpp.o)
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF64
  Data:                              2's complement little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              REL (Relocatable file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x0
  Start of program headers:          0 (bytes into file)
  Start of section headers:          174848 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           0 (bytes)
  Number of program headers:         0
  Size of section headers:           64 (bytes)
  Number of section headers:         2561
  Section header string table index: 2558
```
</Title_Description>
    <Label>question|wontfix</Label>
    <Assignee>dtzWill|kren1|yuleisui</Assignee>
    <CreatedAt>23/02/2018 6:09:44 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>33</IssueLabelID>
    <Title>Output format</Title>
    <Description>When I conducted PTA some of the source location is duplicated like
```
!!Target NodeID 16735	 [&lt;__cleanup_mnt&gt; Source Loc: in line: 1072 file:
/home/workspace/llvmlinux/targets/x86_64/src/linux/fs/namespace.cin line: 1072 file:
/home/workspace/llvmlinux/targets/x86_64/src/linux/fs/namespace.cin line: 1072 file:
...
...
/home/workspace/llvmlinux/targets/x86_64/src/linux/fs/namespace.cin line: 1072 file:
/home/workspace/llvmlinux/targets/x86_64/src/linux/fs/namespace.c]
```

Is this a bug? Please can you check this?</Description>
    <Title_Description>Output format When I conducted PTA some of the source location is duplicated like
```
!!Target NodeID 16735	 [&lt;__cleanup_mnt&gt; Source Loc: in line: 1072 file:
/home/workspace/llvmlinux/targets/x86_64/src/linux/fs/namespace.cin line: 1072 file:
/home/workspace/llvmlinux/targets/x86_64/src/linux/fs/namespace.cin line: 1072 file:
...
...
/home/workspace/llvmlinux/targets/x86_64/src/linux/fs/namespace.cin line: 1072 file:
/home/workspace/llvmlinux/targets/x86_64/src/linux/fs/namespace.c]
```

Is this a bug? Please can you check this?</Title_Description>
    <Label>question</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>2/10/2017 3:46:25 AM +00:00</CreatedAt>
    <ClosedAt>2/10/2017 4:08:58 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>32</IssueLabelID>
    <Title>object-c</Title>
    <Description>hi
   sirdoes this tool support object-c?is there a plan for  it?</Description>
    <Title_Description>object-c hi
   sirdoes this tool support object-c?is there a plan for  it?</Title_Description>
    <Label>question</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>26/09/2017 2:48:43 PM +00:00</CreatedAt>
    <ClosedAt>27/09/2017 12:15:09 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>30</IssueLabelID>
    <Title>Wiki documentation seems out of sync</Title>
    <Description>The two wiki pages that describe using SVF to write
- flow and field insensitive analysis and
- a source/sink analyzer

seem to be out of sync with some of the code. I am guessing there will be no further updates is this the case? If I could figure out what's what I would be glad to contribute back.</Description>
    <Title_Description>Wiki documentation seems out of sync The two wiki pages that describe using SVF to write
- flow and field insensitive analysis and
- a source/sink analyzer

seem to be out of sync with some of the code. I am guessing there will be no further updates is this the case? If I could figure out what's what I would be glad to contribute back.</Title_Description>
    <Label>question</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>4/08/2017 6:49:27 PM +00:00</CreatedAt>
    <ClosedAt>5/08/2017 4:03:49 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>29</IssueLabelID>
    <Title>Minor nit: change souce to source</Title>
    <Description>A few functions and strings are using "Souce" instead of "Source". Guessing this is a typo so made a page and a pull req.

https://github.com/unsw-corg/SVF/pull/28

</Description>
    <Title_Description>Minor nit: change souce to source A few functions and strings are using "Souce" instead of "Source". Guessing this is a typo so made a page and a pull req.

https://github.com/unsw-corg/SVF/pull/28

</Title_Description>
    <Label>enhancement</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>31/07/2017 9:18:49 PM +00:00</CreatedAt>
    <ClosedAt>1/08/2017 2:04:57 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>27</IssueLabelID>
    <Title>Some questions related to a LLVM-gold plugin and Linux kernel.</Title>
    <Description>I have read some documents related to the gold plugin and LTO but still not clear for me.
As far as I understood the reason why we use llvm-gold plugin is becuase
- the linker needs all available bitcode/object files (without any missing functions/files) in order to do the link time optimization and
- Successful linking (or LTO) guarantees there is no missing part.
- and in order to link all bitcodes/objects together using `clang -flto` I should give all bitcodes/objects as arguments altogether.

Am I right?


Based on what I guess I tried to follow your suggestion.
But it looks building Linux kernel is not a trivial. I tried a few things as follows and all fails.

I first tried to build a vmlinux bitcode file with [llvmlinux](http://llvm.linuxfoundation.org/index.php/Main_Page) project.
I used a script as a CC instead of clang or gcc.
It emits both bitcode files and object files for all clang command.
I think it was successful so far. So I was able to generate bitcode files for individual C codes.
And then I ran ``clang -flto $(find . -name '*.bc') -o $OUTPUT``.
I knew there might be some missing files but I wanted to see what would happen.

It generated a lot of multiple definition errors as follows.
```
...
/usr/bin/ld: error: /tmp/intel_audio-5ce78a.o: multiple definition of 'intel_audio_codec_disable'
/usr/bin/ld: /tmp/built-in-02b6ce.o: previous definition here
/usr/bin/ld: error: /tmp/intel_audio-5ce78a.o: multiple definition of 'intel_init_audio'
/usr/bin/ld: /tmp/built-in-02b6ce.o: previous definition here
/usr/bin/ld: error: /tmp/intel_audio-5ce78a.o: multiple definition of 'i915_audio_component_init'
/usr/bin/ld: /tmp/built-in-02b6ce.o: previous definition here
/usr/bin/ld: error: /tmp/intel_audio-5ce78a.o: multiple definition of 'i915_audio_component_cleanup'
/usr/bin/ld: /tmp/built-in-02b6ce.o: previous definition here
...
```

I also tried to build it in the way suggested in [quickstart-for-using-lto-with-autotooled-projects](http://llvm.org/docs/GoldPlugin.html#quickstart-for-using-lto-with-autotooled-projects) without using another project.
It generated following errors.
```
...
In file included from arch/x86/kernel/asm-offsets.c:8:
In file included from include/linux/crypto.h:24:
In file included from include/linux/slab.h:14:
In file included from include/linux/gfp.h:5:
include/linux/mmzone.h:345:22: error: use of undeclared identifier 'MAX_NR_ZONES'; did you mean
      '__MAX_NR_ZONES'?
        long lowmem_reserve[MAX_NR_ZONES];
                            ^~~~~~~~~~~~
                            __MAX_NR_ZONES
...
```

I found the other project [linux-misc](https://github.com/andikleen/linux-misc) whose a purpose is building LTO-applied Linux kernel (based on gcc).
But combining this project and llvmlinux is a little bit confusing me and I think it will not work properly.

If you have the experience analyzing Linux kernel please give me an advice how I can link Linux kernel in a proper way.
Thanks!</Description>
    <Title_Description>Some questions related to a LLVM-gold plugin and Linux kernel. I have read some documents related to the gold plugin and LTO but still not clear for me.
As far as I understood the reason why we use llvm-gold plugin is becuase
- the linker needs all available bitcode/object files (without any missing functions/files) in order to do the link time optimization and
- Successful linking (or LTO) guarantees there is no missing part.
- and in order to link all bitcodes/objects together using `clang -flto` I should give all bitcodes/objects as arguments altogether.

Am I right?


Based on what I guess I tried to follow your suggestion.
But it looks building Linux kernel is not a trivial. I tried a few things as follows and all fails.

I first tried to build a vmlinux bitcode file with [llvmlinux](http://llvm.linuxfoundation.org/index.php/Main_Page) project.
I used a script as a CC instead of clang or gcc.
It emits both bitcode files and object files for all clang command.
I think it was successful so far. So I was able to generate bitcode files for individual C codes.
And then I ran ``clang -flto $(find . -name '*.bc') -o $OUTPUT``.
I knew there might be some missing files but I wanted to see what would happen.

It generated a lot of multiple definition errors as follows.
```
...
/usr/bin/ld: error: /tmp/intel_audio-5ce78a.o: multiple definition of 'intel_audio_codec_disable'
/usr/bin/ld: /tmp/built-in-02b6ce.o: previous definition here
/usr/bin/ld: error: /tmp/intel_audio-5ce78a.o: multiple definition of 'intel_init_audio'
/usr/bin/ld: /tmp/built-in-02b6ce.o: previous definition here
/usr/bin/ld: error: /tmp/intel_audio-5ce78a.o: multiple definition of 'i915_audio_component_init'
/usr/bin/ld: /tmp/built-in-02b6ce.o: previous definition here
/usr/bin/ld: error: /tmp/intel_audio-5ce78a.o: multiple definition of 'i915_audio_component_cleanup'
/usr/bin/ld: /tmp/built-in-02b6ce.o: previous definition here
...
```

I also tried to build it in the way suggested in [quickstart-for-using-lto-with-autotooled-projects](http://llvm.org/docs/GoldPlugin.html#quickstart-for-using-lto-with-autotooled-projects) without using another project.
It generated following errors.
```
...
In file included from arch/x86/kernel/asm-offsets.c:8:
In file included from include/linux/crypto.h:24:
In file included from include/linux/slab.h:14:
In file included from include/linux/gfp.h:5:
include/linux/mmzone.h:345:22: error: use of undeclared identifier 'MAX_NR_ZONES'; did you mean
      '__MAX_NR_ZONES'?
        long lowmem_reserve[MAX_NR_ZONES];
                            ^~~~~~~~~~~~
                            __MAX_NR_ZONES
...
```

I found the other project [linux-misc](https://github.com/andikleen/linux-misc) whose a purpose is building LTO-applied Linux kernel (based on gcc).
But combining this project and llvmlinux is a little bit confusing me and I think it will not work properly.

If you have the experience analyzing Linux kernel please give me an advice how I can link Linux kernel in a proper way.
Thanks!</Title_Description>
    <Label>invalid|question</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>30/07/2017 11:43:14 AM +00:00</CreatedAt>
    <ClosedAt>2/10/2017 3:33:59 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>26</IssueLabelID>
    <Title>Points-to analysis on Linux kernel</Title>
    <Description>Hi.

I'm trying to do points-to analysis on the Linux kernel with llvmlinux and your SVF tool.
I built vmlinux.bc and run wpa tool. but the wpa is terminated abnormally and it prints only the 'Killed' message.
I think the problem is caused by out-of-memory.

Have you tried to do analysis on the Linux kernel? and do you have any tips for me?

I built vmlinux.bc by
- using make tinyconfig to generate the smallest kernel configuration.
- adding -emit-llvm flags to all clang commands in order to generate individual bitcodes.
- change the output expansion from .o to .bc.
- using llvm-link to link all .bc files and omitting ld's flags which is not compatible with llvm-link
- and ignore some corner cases.
(I'm not sure this procedure makes sense but I'm just trying)

My wpa command is
- wpa vmlinux.bc -nander -print-pts -print-type

Thank you for great tools and it will be very helpful if you give me comments.</Description>
    <Title_Description>Points-to analysis on Linux kernel Hi.

I'm trying to do points-to analysis on the Linux kernel with llvmlinux and your SVF tool.
I built vmlinux.bc and run wpa tool. but the wpa is terminated abnormally and it prints only the 'Killed' message.
I think the problem is caused by out-of-memory.

Have you tried to do analysis on the Linux kernel? and do you have any tips for me?

I built vmlinux.bc by
- using make tinyconfig to generate the smallest kernel configuration.
- adding -emit-llvm flags to all clang commands in order to generate individual bitcodes.
- change the output expansion from .o to .bc.
- using llvm-link to link all .bc files and omitting ld's flags which is not compatible with llvm-link
- and ignore some corner cases.
(I'm not sure this procedure makes sense but I'm just trying)

My wpa command is
- wpa vmlinux.bc -nander -print-pts -print-type

Thank you for great tools and it will be very helpful if you give me comments.</Title_Description>
    <Label>question</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>7/07/2017 4:46:04 AM +00:00</CreatedAt>
    <ClosedAt>22/07/2017 7:12:21 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>21</IssueLabelID>
    <Title>valgrind errors with "wpa -anders" and PTABen</Title>
    <Description>Using latest master (0800cd1ce7c6799f228f4be9426e075d1a9dbd79) I just added 'valgrind' before the invocation of 'wpa' in PTABen's `run.sh` and am seeing the following:

http://dtz.so/docs/ladeg.log

In particular:

```
fi_tests/spec_tests/gap.c
@@@analyzing fi_tests/spec_tests/gap.c with testwpa.sh
==331== Memcheck a memory error detector
==331== Copyright (C) 2002-2015 and GNU GPL'd by Julian Seward et al.
==331== Using Valgrind-3.12.0 and LibVEX; rerun with -h for copyright info
==331== Command: /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa -ander -vgep=true -stat=false fi_tests/spec_tests/gap.opt
==331== 
==331== Invalid read of size 4
==331==    at 0x4B477B: ConstraintGraph::moveInEdgesToRepNode(ConstraintNode* ConstraintNode*) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x471E33: Andersen::mergeNodeToRep(unsigned int unsigned int) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x483098: AndersenWaveDiff::mergeNodeToRep(unsigned int unsigned int) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x47061B: Andersen::mergeSccNodes(unsigned int llvm::SparseBitVector&lt;128u&gt;&amp;) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x47344B: Andersen::mergeSccCycle() (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x4755A0: Andersen::SCCDetect() (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x47083C: Andersen::analyze(llvm::Module&amp;) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x42CF22: WPAPass::runPointerAnalysis(llvm::Module&amp; unsigned int) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x42D565: WPAPass::runOnModule(llvm::Module&amp;) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x61302E: llvm::legacy::PassManagerImpl::run(llvm::Module&amp;) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x417D6D: main (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==  Address 0x66eaa58 is 24 bytes inside a block of size 72 free'd
==331==    at 0x4C2C2EB: operator delete(void*) (in /nix/store/cl1jd45s910gq4jzsd0irnis14p2vmj4-valgrind-3.12.0/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==331==    by 0x4B40E7: ConstraintGraph::removeDirectEdge(ConstraintEdge*) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x4B477A: ConstraintGraph::moveInEdgesToRepNode(ConstraintNode* ConstraintNode*) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x471E33: Andersen::mergeNodeToRep(unsigned int unsigned int) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x483098: AndersenWaveDiff::mergeNodeToRep(unsigned int unsigned int) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x47061B: Andersen::mergeSccNodes(unsigned int llvm::SparseBitVector&lt;128u&gt;&amp;) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x47344B: Andersen::mergeSccCycle() (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x4755A0: Andersen::SCCDetect() (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x47083C: Andersen::analyze(llvm::Module&amp;) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x42CF22: WPAPass::runPointerAnalysis(llvm::Module&amp; unsigned int) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x42D565: WPAPass::runOnModule(llvm::Module&amp;) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x61302E: llvm::legacy::PassManagerImpl::run(llvm::Module&amp;) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==  Block was alloc'd at
==331==    at 0x4C2B22F: operator new(unsigned long) (in /nix/store/cl1jd45s910gq4jzsd0irnis14p2vmj4-valgrind-3.12.0/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==331==    by 0x4AF478: ConstraintGraph::addNormalGepCGEdge(unsigned int unsigned int LocationSet const&amp;) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x4B06C5: ConstraintGraph::buildCG() (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x4771DC: Andersen::initialize(llvm::Module&amp;) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x4707C6: Andersen::analyze(llvm::Module&amp;) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x42CF22: WPAPass::runPointerAnalysis(llvm::Module&amp; unsigned int) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x42D565: WPAPass::runOnModule(llvm::Module&amp;) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x61302E: llvm::legacy::PassManagerImpl::run(llvm::Module&amp;) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x417D6D: main (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
```

(apologies for lack of debug info in those traces)

If you could confirm whether this matches in your build/version that would be useful.

Let me know if you need any more information!</Description>
    <Title_Description>valgrind errors with "wpa -anders" and PTABen Using latest master (0800cd1ce7c6799f228f4be9426e075d1a9dbd79) I just added 'valgrind' before the invocation of 'wpa' in PTABen's `run.sh` and am seeing the following:

http://dtz.so/docs/ladeg.log

In particular:

```
fi_tests/spec_tests/gap.c
@@@analyzing fi_tests/spec_tests/gap.c with testwpa.sh
==331== Memcheck a memory error detector
==331== Copyright (C) 2002-2015 and GNU GPL'd by Julian Seward et al.
==331== Using Valgrind-3.12.0 and LibVEX; rerun with -h for copyright info
==331== Command: /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa -ander -vgep=true -stat=false fi_tests/spec_tests/gap.opt
==331== 
==331== Invalid read of size 4
==331==    at 0x4B477B: ConstraintGraph::moveInEdgesToRepNode(ConstraintNode* ConstraintNode*) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x471E33: Andersen::mergeNodeToRep(unsigned int unsigned int) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x483098: AndersenWaveDiff::mergeNodeToRep(unsigned int unsigned int) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x47061B: Andersen::mergeSccNodes(unsigned int llvm::SparseBitVector&lt;128u&gt;&amp;) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x47344B: Andersen::mergeSccCycle() (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x4755A0: Andersen::SCCDetect() (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x47083C: Andersen::analyze(llvm::Module&amp;) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x42CF22: WPAPass::runPointerAnalysis(llvm::Module&amp; unsigned int) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x42D565: WPAPass::runOnModule(llvm::Module&amp;) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x61302E: llvm::legacy::PassManagerImpl::run(llvm::Module&amp;) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x417D6D: main (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==  Address 0x66eaa58 is 24 bytes inside a block of size 72 free'd
==331==    at 0x4C2C2EB: operator delete(void*) (in /nix/store/cl1jd45s910gq4jzsd0irnis14p2vmj4-valgrind-3.12.0/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==331==    by 0x4B40E7: ConstraintGraph::removeDirectEdge(ConstraintEdge*) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x4B477A: ConstraintGraph::moveInEdgesToRepNode(ConstraintNode* ConstraintNode*) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x471E33: Andersen::mergeNodeToRep(unsigned int unsigned int) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x483098: AndersenWaveDiff::mergeNodeToRep(unsigned int unsigned int) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x47061B: Andersen::mergeSccNodes(unsigned int llvm::SparseBitVector&lt;128u&gt;&amp;) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x47344B: Andersen::mergeSccCycle() (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x4755A0: Andersen::SCCDetect() (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x47083C: Andersen::analyze(llvm::Module&amp;) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x42CF22: WPAPass::runPointerAnalysis(llvm::Module&amp; unsigned int) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x42D565: WPAPass::runOnModule(llvm::Module&amp;) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x61302E: llvm::legacy::PassManagerImpl::run(llvm::Module&amp;) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==  Block was alloc'd at
==331==    at 0x4C2B22F: operator new(unsigned long) (in /nix/store/cl1jd45s910gq4jzsd0irnis14p2vmj4-valgrind-3.12.0/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==331==    by 0x4AF478: ConstraintGraph::addNormalGepCGEdge(unsigned int unsigned int LocationSet const&amp;) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x4B06C5: ConstraintGraph::buildCG() (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x4771DC: Andersen::initialize(llvm::Module&amp;) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x4707C6: Andersen::analyze(llvm::Module&amp;) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x42CF22: WPAPass::runPointerAnalysis(llvm::Module&amp; unsigned int) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x42D565: WPAPass::runOnModule(llvm::Module&amp;) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x61302E: llvm::legacy::PassManagerImpl::run(llvm::Module&amp;) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x417D6D: main (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
```

(apologies for lack of debug info in those traces)

If you could confirm whether this matches in your build/version that would be useful.

Let me know if you need any more information!</Title_Description>
    <Label>bug|help wanted</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>4/05/2017 4:15:27 PM +00:00</CreatedAt>
    <ClosedAt>13/06/2017 12:56:43 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>20</IssueLabelID>
    <Title>Merging in SUPA implementation?</Title>
    <Description>Don't mean to nag but just a reminder that merging in SUPA implementation would be great and much appreciated! :+1:

The [SUPA website](http://www.cse.unsw.edu.au/~corg/supa/) suggests it's on your TODO and idea when that will happen? Or is there anything blocking the effort that perhaps folks (such as myself) could help with?

Thanks!</Description>
    <Title_Description>Merging in SUPA implementation? Don't mean to nag but just a reminder that merging in SUPA implementation would be great and much appreciated! :+1:

The [SUPA website](http://www.cse.unsw.edu.au/~corg/supa/) suggests it's on your TODO and idea when that will happen? Or is there anything blocking the effort that perhaps folks (such as myself) could help with?

Thanks!</Title_Description>
    <Label>question</Label>
    <Assignee>dtzWill|yuleisui</Assignee>
    <CreatedAt>4/05/2017 2:16:05 PM +00:00</CreatedAt>
    <ClosedAt>4/05/2017 2:22:57 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>19</IssueLabelID>
    <Title>cppUtil::DemangledName cppUtil::demangle does not work in some case</Title>
    <Description>For example if its argument is "_Z8printtttPj". (Original name "printttt(unsigned int*)")
"cppUtil::DemangledName cppUtil::demangle " cannot demangle it.</Description>
    <Title_Description>cppUtil::DemangledName cppUtil::demangle does not work in some case For example if its argument is "_Z8printtttPj". (Original name "printttt(unsigned int*)")
"cppUtil::DemangledName cppUtil::demangle " cannot demangle it.</Title_Description>
    <Label>question</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>1/05/2017 1:24:57 AM +00:00</CreatedAt>
    <ClosedAt>1/05/2017 5:02:40 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>17</IssueLabelID>
    <Title>Error on wpa -ander -svfg -dump-svfg example.bc </Title>
    <Description>Hi I am trying to understand and check SVF capabilities.

However I found some error with a toy code.
I also attached error messages.
---------------------------  Code     ------------------------------------------------
#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

class Profile
{
    public:
        void printProfile()
        {
            cout &lt;&lt; "Name : " &lt;&lt; _name.c_str() &lt;&lt; endl;
            cout &lt;&lt; "Phone Number : " &lt;&lt; _phoneNumber.c_str() &lt;&lt;endl;
        }
        void setName(string name)
        {
            _name = name;
        }
        void setPhoneNumber(string phoneNumber)
        {
            _phoneNumber = phoneNumber;
        }
    private:
        string _name;
        string _phoneNumber;
};


int main()
{
    Profile myProfile;
    myProfile.setName("Hong");
    myProfile.setPhoneNumber("012319562");
    myProfile.printProfile();
    return 0;
}
------------------------ Error message --------------------------------------

Writing 'ander_svfg.dot'...#0 0x0000000000e7870b llvm::sys::PrintStackTrace(llvm::raw_ostream&amp;) (~/SVF/build/bin/wpa+0xe7870b)
#1 0x0000000000e78a20 PrintStackTraceSignalHandler(void*) (~/SVF/build/bin/wpa+0xe78a20)
#2 0x0000000000e7706d llvm::sys::RunSignalHandlers() (~/SVF/build/bin/wpa+0xe7706d)
#3 0x0000000000e78181 SignalHandler(int) (~/SVF/build/bin/wpa+0xe78181)
#4 0x00007fe76b13b330 __restore_rt (/lib/x86_64-linux-gnu/libpthread.so.0+0x10330)
#5 0x000000000045ed78 MRVer::getSSAVersion() const (~/SVF/build/bin/wpa+0x45ed78)
#6 0x0000000000463d4f llvm::DOTGraphTraits&lt;SVFG*&gt;::getCompleteNodeLabel(SVFGNode* SVFG*) (~/SVF/build/bin/wpa+0x463d4f)
#7 0x0000000000462e08 llvm::DOTGraphTraits&lt;SVFG*&gt;::getNodeLabel(SVFGNode* SVFG*) (~/SVF/build/bin/wpa+0x462e08)
#8 0x000000000047bec9 llvm::GraphWriter&lt;SVFG*&gt;::writeNode(SVFGNode*) (~/SVF/build/bin/wpa+0x47bec9)
#9 0x0000000000479fe7 llvm::GraphWriter&lt;SVFG*&gt;::writeNodes() (~/SVF/build/bin/wpa+0x479fe7)
#10 0x00000000004769a3 llvm::GraphWriter&lt;SVFG*&gt;::writeGraph(std::string const&amp;) (~/SVF/build/bin/wpa+0x4769a3)
#11 0x000000000047095d llvm::raw_ostream&amp; llvm::WriteGraph&lt;SVFG*&gt;(llvm::raw_ostream&amp; SVFG* const&amp; bool llvm::Twine const&amp;) (~/SVF/build/bin/wpa+0x47095d)
#12 0x000000000046a10b void llvm::GraphPrinter::WriteGraphToFile&lt;SVFG*&gt;(llvm::raw_ostream&amp; std::string const&amp; SVFG* const&amp; bool) (~/SVF/build/bin/wpa+0x46a10b)
#13 0x000000000045c593 SVFG::dump(std::string const&amp; bool) (~/SVF/build/bin/wpa+0x45c593)
#14 0x0000000000409bc6 WPAPass::runPointerAnalysis(llvm::Module&amp; unsigned int) (~/SVF/build/bin/wpa+0x409bc6)
#15 0x0000000000409964 WPAPass::runOnModule(llvm::Module&amp;) (~/SVF/build/bin/wpa+0x409964)
#16 0x00000000007b92b6 (anonymous namespace)::MPPassManager::runOnModule(llvm::Module&amp;) (~/SVF/build/bin/wpa+0x7b92b6)
#17 0x00000000007b9a20 llvm::legacy::PassManagerImpl::run(llvm::Module&amp;) (~/SVF/build/bin/wpa+0x7b9a20)
#18 0x00000000007b9c61 llvm::legacy::PassManager::run(llvm::Module&amp;) (~/SVF/build/bin/wpa+0x7b9c61)
#19 0x000000000040772b main (~/SVF/build/bin/wpa+0x40772b)
#20 0x00007fe76a34ef45 __libc_start_main /build/eglibc-oGUzwX/eglibc-2.19/csu/libc-start.c:321:0
#21 0x0000000000407289 _start (~/SVF/build/bin/wpa+0x407289)
Stack dump:
0.	Program arguments: wpa -ander -svfg -dump-svfg c++.bc 
1.	Running pass 'WPAPass' on module 'c++.bc'.
#0 0x0000000000e7870b llvm::sys::PrintStackTrace(llvm::raw_ostream&amp;) (~/SVF/build/bin/wpa+0xe7870b)
#1 0x0000000000e78a20 PrintStackTraceSignalHandler(void*) (~/SVF/build/bin/wpa+0xe78a20)
#2 0x0000000000e7706d llvm::sys::RunSignalHandlers() (~/SVF/build/bin/wpa+0xe7706d)
#3 0x0000000000e78181 SignalHandler(int) (~/SVF/build/bin/wpa+0xe78181)
#4 0x00007fe76b13b330 __restore_rt (/lib/x86_64-linux-gnu/libpthread.so.0+0x10330)
#5 0x000000000045ed78 MRVer::getSSAVersion() const (~/SVF/build/bin/wpa+0x45ed78)
#6 0x0000000000463d4f llvm::DOTGraphTraits&lt;SVFG*&gt;::getCompleteNodeLabel(SVFGNode* SVFG*) (~/SVF/build/bin/wpa+0x463d4f)
#7 0x0000000000462e08 llvm::DOTGraphTraits&lt;SVFG*&gt;::getNodeLabel(SVFGNode* SVFG*) (~/SVF/build/bin/wpa+0x462e08)
#8 0x000000000047bec9 llvm::GraphWriter&lt;SVFG*&gt;::writeNode(SVFGNode*) (~/SVF/build/bin/wpa+0x47bec9)
#9 0x0000000000479fe7 llvm::GraphWriter&lt;SVFG*&gt;::writeNodes() (~/SVF/build/bin/wpa+0x479fe7)
#10 0x00000000004769a3 llvm::GraphWriter&lt;SVFG*&gt;::writeGraph(std::string const&amp;) (~/SVF/build/bin/wpa+0x4769a3)
#11 0x000000000047095d llvm::raw_ostream&amp; llvm::WriteGraph&lt;SVFG*&gt;(llvm::raw_ostream&amp; SVFG* const&amp; bool llvm::Twine const&amp;) (~/SVF/build/bin/wpa+0x47095d)
#12 0x000000000046a10b void llvm::GraphPrinter::WriteGraphToFile&lt;SVFG*&gt;(llvm::raw_ostream&amp; std::string const&amp; SVFG* const&amp; bool) (~/SVF/build/bin/wpa+0x46a10b)
#13 0x000000000045c593 SVFG::dump(std::string const&amp; bool) (~/SVF/build/bin/wpa+0x45c593)
#14 0x0000000000409bc6 WPAPass::runPointerAnalysis(llvm::Module&amp; unsigned int) (~/SVF/build/bin/wpa+0x409bc6)
#15 0x0000000000409964 WPAPass::runOnModule(llvm::Module&amp;) (~/SVF/build/bin/wpa+0x409964)
#16 0x00000000007b92b6 (anonymous namespace)::MPPassManager::runOnModule(llvm::Module&amp;) (~/SVF/build/bin/wpa+0x7b92b6)
#17 0x00000000007b9a20 llvm::legacy::PassManagerImpl::run(llvm::Module&amp;) (~/SVF/build/bin/wpa+0x7b9a20)
#18 0x00000000007b9c61 llvm::legacy::PassManager::run(llvm::Module&amp;) (~/SVF/build/bin/wpa+0x7b9c61)
#19 0x000000000040772b main (~/SVF/build/bin/wpa+0x40772b)
#20 0x00007fe76a34ef45 __libc_start_main /build/eglibc-oGUzwX/eglibc-2.19/csu/libc-start.c:321:0
#21 0x0000000000407289 _start (~/SVF/build/bin/wpa+0x407289)
llvmhelper.sh: line 26: 26518 Segmentation fault      (core dumped) wpa -ander -svfg -dump-svfg $1.bc</Description>
    <Title_Description>Error on wpa -ander -svfg -dump-svfg example.bc  Hi I am trying to understand and check SVF capabilities.

However I found some error with a toy code.
I also attached error messages.
---------------------------  Code     ------------------------------------------------
#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

class Profile
{
    public:
        void printProfile()
        {
            cout &lt;&lt; "Name : " &lt;&lt; _name.c_str() &lt;&lt; endl;
            cout &lt;&lt; "Phone Number : " &lt;&lt; _phoneNumber.c_str() &lt;&lt;endl;
        }
        void setName(string name)
        {
            _name = name;
        }
        void setPhoneNumber(string phoneNumber)
        {
            _phoneNumber = phoneNumber;
        }
    private:
        string _name;
        string _phoneNumber;
};


int main()
{
    Profile myProfile;
    myProfile.setName("Hong");
    myProfile.setPhoneNumber("012319562");
    myProfile.printProfile();
    return 0;
}
------------------------ Error message --------------------------------------

Writing 'ander_svfg.dot'...#0 0x0000000000e7870b llvm::sys::PrintStackTrace(llvm::raw_ostream&amp;) (~/SVF/build/bin/wpa+0xe7870b)
#1 0x0000000000e78a20 PrintStackTraceSignalHandler(void*) (~/SVF/build/bin/wpa+0xe78a20)
#2 0x0000000000e7706d llvm::sys::RunSignalHandlers() (~/SVF/build/bin/wpa+0xe7706d)
#3 0x0000000000e78181 SignalHandler(int) (~/SVF/build/bin/wpa+0xe78181)
#4 0x00007fe76b13b330 __restore_rt (/lib/x86_64-linux-gnu/libpthread.so.0+0x10330)
#5 0x000000000045ed78 MRVer::getSSAVersion() const (~/SVF/build/bin/wpa+0x45ed78)
#6 0x0000000000463d4f llvm::DOTGraphTraits&lt;SVFG*&gt;::getCompleteNodeLabel(SVFGNode* SVFG*) (~/SVF/build/bin/wpa+0x463d4f)
#7 0x0000000000462e08 llvm::DOTGraphTraits&lt;SVFG*&gt;::getNodeLabel(SVFGNode* SVFG*) (~/SVF/build/bin/wpa+0x462e08)
#8 0x000000000047bec9 llvm::GraphWriter&lt;SVFG*&gt;::writeNode(SVFGNode*) (~/SVF/build/bin/wpa+0x47bec9)
#9 0x0000000000479fe7 llvm::GraphWriter&lt;SVFG*&gt;::writeNodes() (~/SVF/build/bin/wpa+0x479fe7)
#10 0x00000000004769a3 llvm::GraphWriter&lt;SVFG*&gt;::writeGraph(std::string const&amp;) (~/SVF/build/bin/wpa+0x4769a3)
#11 0x000000000047095d llvm::raw_ostream&amp; llvm::WriteGraph&lt;SVFG*&gt;(llvm::raw_ostream&amp; SVFG* const&amp; bool llvm::Twine const&amp;) (~/SVF/build/bin/wpa+0x47095d)
#12 0x000000000046a10b void llvm::GraphPrinter::WriteGraphToFile&lt;SVFG*&gt;(llvm::raw_ostream&amp; std::string const&amp; SVFG* const&amp; bool) (~/SVF/build/bin/wpa+0x46a10b)
#13 0x000000000045c593 SVFG::dump(std::string const&amp; bool) (~/SVF/build/bin/wpa+0x45c593)
#14 0x0000000000409bc6 WPAPass::runPointerAnalysis(llvm::Module&amp; unsigned int) (~/SVF/build/bin/wpa+0x409bc6)
#15 0x0000000000409964 WPAPass::runOnModule(llvm::Module&amp;) (~/SVF/build/bin/wpa+0x409964)
#16 0x00000000007b92b6 (anonymous namespace)::MPPassManager::runOnModule(llvm::Module&amp;) (~/SVF/build/bin/wpa+0x7b92b6)
#17 0x00000000007b9a20 llvm::legacy::PassManagerImpl::run(llvm::Module&amp;) (~/SVF/build/bin/wpa+0x7b9a20)
#18 0x00000000007b9c61 llvm::legacy::PassManager::run(llvm::Module&amp;) (~/SVF/build/bin/wpa+0x7b9c61)
#19 0x000000000040772b main (~/SVF/build/bin/wpa+0x40772b)
#20 0x00007fe76a34ef45 __libc_start_main /build/eglibc-oGUzwX/eglibc-2.19/csu/libc-start.c:321:0
#21 0x0000000000407289 _start (~/SVF/build/bin/wpa+0x407289)
Stack dump:
0.	Program arguments: wpa -ander -svfg -dump-svfg c++.bc 
1.	Running pass 'WPAPass' on module 'c++.bc'.
#0 0x0000000000e7870b llvm::sys::PrintStackTrace(llvm::raw_ostream&amp;) (~/SVF/build/bin/wpa+0xe7870b)
#1 0x0000000000e78a20 PrintStackTraceSignalHandler(void*) (~/SVF/build/bin/wpa+0xe78a20)
#2 0x0000000000e7706d llvm::sys::RunSignalHandlers() (~/SVF/build/bin/wpa+0xe7706d)
#3 0x0000000000e78181 SignalHandler(int) (~/SVF/build/bin/wpa+0xe78181)
#4 0x00007fe76b13b330 __restore_rt (/lib/x86_64-linux-gnu/libpthread.so.0+0x10330)
#5 0x000000000045ed78 MRVer::getSSAVersion() const (~/SVF/build/bin/wpa+0x45ed78)
#6 0x0000000000463d4f llvm::DOTGraphTraits&lt;SVFG*&gt;::getCompleteNodeLabel(SVFGNode* SVFG*) (~/SVF/build/bin/wpa+0x463d4f)
#7 0x0000000000462e08 llvm::DOTGraphTraits&lt;SVFG*&gt;::getNodeLabel(SVFGNode* SVFG*) (~/SVF/build/bin/wpa+0x462e08)
#8 0x000000000047bec9 llvm::GraphWriter&lt;SVFG*&gt;::writeNode(SVFGNode*) (~/SVF/build/bin/wpa+0x47bec9)
#9 0x0000000000479fe7 llvm::GraphWriter&lt;SVFG*&gt;::writeNodes() (~/SVF/build/bin/wpa+0x479fe7)
#10 0x00000000004769a3 llvm::GraphWriter&lt;SVFG*&gt;::writeGraph(std::string const&amp;) (~/SVF/build/bin/wpa+0x4769a3)
#11 0x000000000047095d llvm::raw_ostream&amp; llvm::WriteGraph&lt;SVFG*&gt;(llvm::raw_ostream&amp; SVFG* const&amp; bool llvm::Twine const&amp;) (~/SVF/build/bin/wpa+0x47095d)
#12 0x000000000046a10b void llvm::GraphPrinter::WriteGraphToFile&lt;SVFG*&gt;(llvm::raw_ostream&amp; std::string const&amp; SVFG* const&amp; bool) (~/SVF/build/bin/wpa+0x46a10b)
#13 0x000000000045c593 SVFG::dump(std::string const&amp; bool) (~/SVF/build/bin/wpa+0x45c593)
#14 0x0000000000409bc6 WPAPass::runPointerAnalysis(llvm::Module&amp; unsigned int) (~/SVF/build/bin/wpa+0x409bc6)
#15 0x0000000000409964 WPAPass::runOnModule(llvm::Module&amp;) (~/SVF/build/bin/wpa+0x409964)
#16 0x00000000007b92b6 (anonymous namespace)::MPPassManager::runOnModule(llvm::Module&amp;) (~/SVF/build/bin/wpa+0x7b92b6)
#17 0x00000000007b9a20 llvm::legacy::PassManagerImpl::run(llvm::Module&amp;) (~/SVF/build/bin/wpa+0x7b9a20)
#18 0x00000000007b9c61 llvm::legacy::PassManager::run(llvm::Module&amp;) (~/SVF/build/bin/wpa+0x7b9c61)
#19 0x000000000040772b main (~/SVF/build/bin/wpa+0x40772b)
#20 0x00007fe76a34ef45 __libc_start_main /build/eglibc-oGUzwX/eglibc-2.19/csu/libc-start.c:321:0
#21 0x0000000000407289 _start (~/SVF/build/bin/wpa+0x407289)
llvmhelper.sh: line 26: 26518 Segmentation fault      (core dumped) wpa -ander -svfg -dump-svfg $1.bc</Title_Description>
    <Label>bug</Label>
    <Assignee>yuleisui|jcarlson23</Assignee>
    <CreatedAt>17/04/2017 12:08:57 AM +00:00</CreatedAt>
    <ClosedAt>7/05/2017 2:00:39 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>16</IssueLabelID>
    <Title>Question for source sink analysis</Title>
    <Description>Hi I referred to https://github.com/unsw-corg/SVF/wiki/Write-a-source-sink-analyzer
In my case I have two types of sources.
1) Typical source from some functions.
2) Some variables in "class". (=class variable )

My target program runs in a loop and class variable will go out via sinks.
This class variable is computed with class variable arithmetic operations and source (external source).

In this case is there a way to designate "class variable" as sources?
From my observation some node contains variable names. So if I could get such node in some way there may be some way to do. But I am not sure.

Note that class variable can be changed directly via arithmetic operations (e.g. classA.a = classA.a + 30)</Description>
    <Title_Description>Question for source sink analysis Hi I referred to https://github.com/unsw-corg/SVF/wiki/Write-a-source-sink-analyzer
In my case I have two types of sources.
1) Typical source from some functions.
2) Some variables in "class". (=class variable )

My target program runs in a loop and class variable will go out via sinks.
This class variable is computed with class variable arithmetic operations and source (external source).

In this case is there a way to designate "class variable" as sources?
From my observation some node contains variable names. So if I could get such node in some way there may be some way to do. But I am not sure.

Note that class variable can be changed directly via arithmetic operations (e.g. classA.a = classA.a + 30)</Title_Description>
    <Label>question</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>16/04/2017 1:44:52 AM +00:00</CreatedAt>
    <ClosedAt>23/04/2017 10:41:59 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>14</IssueLabelID>
    <Title>Migrating SVF to LLVM 4</Title>
    <Description>Hello

I am very new to SVF and somewhat naively I took a quick spin in the 3.8 LLVM code base (as shipped so to speak) and liking the code base and capabilities I then started towards migrating SVF towards the LLVM 4.0 release.  Perhaps not unsurprisingly I ran into a few problems but primarily and this was one of the things that attracted me to SVF the GraphTraits in 4.0 looks like it has some changes that are marked as a fixme:

  typedef typename GTraits::NodeRef           NodeRef;
  typedef typename GTraits::nodes_iterator    node_iterator;
  typedef typename GTraits::ChildIteratorType child_iterator;
  DOTTraits DTraits;

  static_assert(std::is_pointer&lt;NodeRef&gt;::value
                "FIXME: Currently GraphWriter requires the NodeRef type to be "
                "a pointer.\nThe pointer usage should be moved to "
                "DOTGraphTraits and removed from GraphWriter itself.”);


(that’s in the GraphWriter.h from LLVM 4.0 release).

So is there anywhere a paper perhaps that you could refer me towards for understanding some of the details as well as the high level implementation of the graphing algorithms being used?  I come from a numerical background so I’m used to sparse solvers such as GMRES etc but the LLVM implementation (while I’m somewhat familiar with a few parts of LLVM) is somewhat new to me - I’ve generally re-used the SCC and other graph related algorithms without needing to dive in headfirst - that said that looks like it’s on tap for my weekend :)


Another question I had was in the Memory separation capabilities does this require disjoint regions?  It seems to read as if “no”?  But then that does limit any typical Formal Methods applications where analysis (that I’ve seen at least) typically requires disjoint regions.  For example I’ve seen several FM related LLVM papers replacing PHI nodes with simplifications.

Thanks!
</Description>
    <Title_Description>Migrating SVF to LLVM 4 Hello

I am very new to SVF and somewhat naively I took a quick spin in the 3.8 LLVM code base (as shipped so to speak) and liking the code base and capabilities I then started towards migrating SVF towards the LLVM 4.0 release.  Perhaps not unsurprisingly I ran into a few problems but primarily and this was one of the things that attracted me to SVF the GraphTraits in 4.0 looks like it has some changes that are marked as a fixme:

  typedef typename GTraits::NodeRef           NodeRef;
  typedef typename GTraits::nodes_iterator    node_iterator;
  typedef typename GTraits::ChildIteratorType child_iterator;
  DOTTraits DTraits;

  static_assert(std::is_pointer&lt;NodeRef&gt;::value
                "FIXME: Currently GraphWriter requires the NodeRef type to be "
                "a pointer.\nThe pointer usage should be moved to "
                "DOTGraphTraits and removed from GraphWriter itself.”);


(that’s in the GraphWriter.h from LLVM 4.0 release).

So is there anywhere a paper perhaps that you could refer me towards for understanding some of the details as well as the high level implementation of the graphing algorithms being used?  I come from a numerical background so I’m used to sparse solvers such as GMRES etc but the LLVM implementation (while I’m somewhat familiar with a few parts of LLVM) is somewhat new to me - I’ve generally re-used the SCC and other graph related algorithms without needing to dive in headfirst - that said that looks like it’s on tap for my weekend :)


Another question I had was in the Memory separation capabilities does this require disjoint regions?  It seems to read as if “no”?  But then that does limit any typical Formal Methods applications where analysis (that I’ve seen at least) typically requires disjoint regions.  For example I’ve seen several FM related LLVM papers replacing PHI nodes with simplifications.

Thanks!
</Title_Description>
    <Label>enhancement</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>1/04/2017 12:38:33 PM +00:00</CreatedAt>
    <ClosedAt>7/05/2017 2:01:01 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>13</IssueLabelID>
    <Title>SVFG: Obtain SVFGNode corresponding to argument of CallSite</Title>
    <Description>Hi

I recently tested SVF (commit 5355fc2e). Great piece of work from my point of view!
Unfortunatly I have problems using the API correctly and I would be pleased if you could guide me a little.
I initialize SVF with the following Instuctions:

```
bool runOnModule(Module &amp;m) override {
        FlowSensitive* fspa = FlowSensitive::createFSWPA(m);
        SVFG* svfg = fspa-&gt;getSVFG();
        PAG* pag = fspa-&gt;getPAG();
        PTACallGraph* ptaCallGraph = fspa-&gt;getPTACallGraph();
```

Later I obtain a llvm::CallSite and want to access the SVFGNodes corresponding to the arguments of that CallSite with


```
if (svfg-&gt;hasActualINSVFGNodes(callSite)) {  // why never true?
    auto set = svfg-&gt;getActualINSVFGNodes(callSite);
    int i = 0;
    for(auto it = set.begin(); it!=set.end(); ++it) {
       errs() &lt;&lt; "param No. " &lt;&lt; i++;
       errs() &lt;&lt; "node id: " &lt;&lt; *it &lt;&lt; "\n";
    }
} else {
    errs() &lt;&lt; "no actual INSVFGNodes\n";
}
```


But the SVFG::callSiteToActualINMap (include/MSSA/SVFG.h:100) is empty everytime. What am I missing here? Do I have wrong initialization steps?
I attached the code of my LLVM Pass as well as source code and LLVM IR of the module under test.
[Logger.zip](https://github.com/unsw-corg/SVF/files/865482/Logger.zip)
See LoggerOO.cpp:  my ultimate goal is to track back the value of parameter 1 of Logger::log2() [line 75] so that SVF reports its value either originates as return value of Encryptor::encrypt() [line 69] or as output parameter of assign() [line 71]

It would be nice if you could help me with this.
Thank you.</Description>
    <Title_Description>SVFG: Obtain SVFGNode corresponding to argument of CallSite Hi

I recently tested SVF (commit 5355fc2e). Great piece of work from my point of view!
Unfortunatly I have problems using the API correctly and I would be pleased if you could guide me a little.
I initialize SVF with the following Instuctions:

```
bool runOnModule(Module &amp;m) override {
        FlowSensitive* fspa = FlowSensitive::createFSWPA(m);
        SVFG* svfg = fspa-&gt;getSVFG();
        PAG* pag = fspa-&gt;getPAG();
        PTACallGraph* ptaCallGraph = fspa-&gt;getPTACallGraph();
```

Later I obtain a llvm::CallSite and want to access the SVFGNodes corresponding to the arguments of that CallSite with


```
if (svfg-&gt;hasActualINSVFGNodes(callSite)) {  // why never true?
    auto set = svfg-&gt;getActualINSVFGNodes(callSite);
    int i = 0;
    for(auto it = set.begin(); it!=set.end(); ++it) {
       errs() &lt;&lt; "param No. " &lt;&lt; i++;
       errs() &lt;&lt; "node id: " &lt;&lt; *it &lt;&lt; "\n";
    }
} else {
    errs() &lt;&lt; "no actual INSVFGNodes\n";
}
```


But the SVFG::callSiteToActualINMap (include/MSSA/SVFG.h:100) is empty everytime. What am I missing here? Do I have wrong initialization steps?
I attached the code of my LLVM Pass as well as source code and LLVM IR of the module under test.
[Logger.zip](https://github.com/unsw-corg/SVF/files/865482/Logger.zip)
See LoggerOO.cpp:  my ultimate goal is to track back the value of parameter 1 of Logger::log2() [line 75] so that SVF reports its value either originates as return value of Encryptor::encrypt() [line 69] or as output parameter of assign() [line 71]

It would be nice if you could help me with this.
Thank you.</Title_Description>
    <Label>question</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>23/03/2017 5:01:24 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>12</IssueLabelID>
    <Title>Assertion triggered after modifying code</Title>
    <Description>Hello!

I'm currently using the SVF analysis for a project and I run into an issue using the analysis
for newly inserted instructions. In short I get the following error whenever I try to check
whether the newly inserted instruction (AllocaInst) aliases with another value :

SVF/include/MemoryModel/MemModel.h:554:
SymID SymbolTableInfo::getValSym(const llvm::Value*): Assertion `iter!=valSymMap.end() &amp;&amp;"value sym not found"' failed.

Below is a test pass that should throw this error for any loop containing a load.
Weirdly this **only** happens if I compile Svf &amp; the pass in Debug mode but not if I build it in
MinSizeRel mode.

In general I believe that I need to update the pointer analysis after having modified the code however I'm not sure how to properly update the analysis. The test pass below contains some of my failed trials of naively re-running it (see commented lines).

What I am doing wrong? How do I properly update/re-run the analysis? And do you know why this is
only happening if compiled in Debug mode?

```c++
#include "llvm/Analysis/LoopPass.h"
#include "llvm/Support/raw_ostream.h"
#include "llvm/IR/IRBuilder.h"

#include "MemoryModel/PointerAnalysis.h"
#include "WPA/Andersen.h"

using namespace llvm;

namespace {
  struct TestSvf : public LoopPass {
    static char ID;

    TestSvf() : LoopPass(ID) {}

    virtual void getAnalysisUsage(AnalysisUsage &amp;AU) const {
      AU.addRequired&lt;LoopInfoWrapperPass&gt;();
    }
    virtual bool runOnLoop(Loop *L LPPassManager &amp;LPM);
  };
}

bool TestSvf::runOnLoop(Loop *L LPPassManager &amp;LPM) {
  // Create AA before changing loop
  Module &amp;M = *L-&gt;getHeader()-&gt;getParent()-&gt;getParent();
  AndersenWaveDiff *AA = AndersenWaveDiff::createAndersenWaveDiff(M);

  // Change loop: add an alloca instruction
  BasicBlock *H = L-&gt;getHeader();
  IRBuilder&lt;&gt; Builder(&amp;*(H-&gt;getFirstInsertionPt()));
  AllocaInst *Alloca = Builder.CreateAlloca(Type::getInt1Ty(getGlobalContext()) 0 "test_alloca");

  // Try to recalculate AA
  // 1st try: AA-&gt;analyze(M);

  // 2nd try:
  // AndersenWaveDiff::releaseAndersenWaveDiff();
  // AA = AndersenWaveDiff::createAndersenWaveDiff(M);

  // 3rd try: 
  // delete(AA);
  // AA = AndersenWaveDiff::createAndersenWaveDiff(M);

  
  // Find first load in loop
  for (BasicBlock *BB : L-&gt;getBlocks()) {
    for (Instruction &amp;I : *BB) {
      if (LoadInst *Load = dyn_cast&lt;LoadInst&gt;(&amp;I)) {
	Value *LoadedVal = Load-&gt;getPointerOperand();

	// Check AA information between loaded value &amp; alloca instruction
	// throws error
	errs() &lt;&lt; AA-&gt;alias(Alloca LoadedVal) &lt;&lt; "\n";
      }
    }
  }
    
  return false;
}

char TestSvf::ID = 0;
static RegisterPass&lt;TestSvf&gt; X("test-svf" "TestSvf_pass" false true);
```</Description>
    <Title_Description>Assertion triggered after modifying code Hello!

I'm currently using the SVF analysis for a project and I run into an issue using the analysis
for newly inserted instructions. In short I get the following error whenever I try to check
whether the newly inserted instruction (AllocaInst) aliases with another value :

SVF/include/MemoryModel/MemModel.h:554:
SymID SymbolTableInfo::getValSym(const llvm::Value*): Assertion `iter!=valSymMap.end() &amp;&amp;"value sym not found"' failed.

Below is a test pass that should throw this error for any loop containing a load.
Weirdly this **only** happens if I compile Svf &amp; the pass in Debug mode but not if I build it in
MinSizeRel mode.

In general I believe that I need to update the pointer analysis after having modified the code however I'm not sure how to properly update the analysis. The test pass below contains some of my failed trials of naively re-running it (see commented lines).

What I am doing wrong? How do I properly update/re-run the analysis? And do you know why this is
only happening if compiled in Debug mode?

```c++
#include "llvm/Analysis/LoopPass.h"
#include "llvm/Support/raw_ostream.h"
#include "llvm/IR/IRBuilder.h"

#include "MemoryModel/PointerAnalysis.h"
#include "WPA/Andersen.h"

using namespace llvm;

namespace {
  struct TestSvf : public LoopPass {
    static char ID;

    TestSvf() : LoopPass(ID) {}

    virtual void getAnalysisUsage(AnalysisUsage &amp;AU) const {
      AU.addRequired&lt;LoopInfoWrapperPass&gt;();
    }
    virtual bool runOnLoop(Loop *L LPPassManager &amp;LPM);
  };
}

bool TestSvf::runOnLoop(Loop *L LPPassManager &amp;LPM) {
  // Create AA before changing loop
  Module &amp;M = *L-&gt;getHeader()-&gt;getParent()-&gt;getParent();
  AndersenWaveDiff *AA = AndersenWaveDiff::createAndersenWaveDiff(M);

  // Change loop: add an alloca instruction
  BasicBlock *H = L-&gt;getHeader();
  IRBuilder&lt;&gt; Builder(&amp;*(H-&gt;getFirstInsertionPt()));
  AllocaInst *Alloca = Builder.CreateAlloca(Type::getInt1Ty(getGlobalContext()) 0 "test_alloca");

  // Try to recalculate AA
  // 1st try: AA-&gt;analyze(M);

  // 2nd try:
  // AndersenWaveDiff::releaseAndersenWaveDiff();
  // AA = AndersenWaveDiff::createAndersenWaveDiff(M);

  // 3rd try: 
  // delete(AA);
  // AA = AndersenWaveDiff::createAndersenWaveDiff(M);

  
  // Find first load in loop
  for (BasicBlock *BB : L-&gt;getBlocks()) {
    for (Instruction &amp;I : *BB) {
      if (LoadInst *Load = dyn_cast&lt;LoadInst&gt;(&amp;I)) {
	Value *LoadedVal = Load-&gt;getPointerOperand();

	// Check AA information between loaded value &amp; alloca instruction
	// throws error
	errs() &lt;&lt; AA-&gt;alias(Alloca LoadedVal) &lt;&lt; "\n";
      }
    }
  }
    
  return false;
}

char TestSvf::ID = 0;
static RegisterPass&lt;TestSvf&gt; X("test-svf" "TestSvf_pass" false true);
```</Title_Description>
    <Label>question</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>20/03/2017 10:38:56 PM +00:00</CreatedAt>
    <ClosedAt>21/03/2017 8:02:10 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>11</IssueLabelID>
    <Title>Buffer index sensitivity with non variant GEP instructions</Title>
    <Description>In the following code:
`
int f() {
  char buf[10] = {0};
  int x = buf[0];
  int y = buf[1];
  return x + y;
}
`
The GEP instructions which correspond to x and y are both constant
but when we check aliasing we get MayAlias.
Actually in both cases the LocationSet of the GepObjPN is constant and equal to 0.
Is this a bug or SVF handles buffers always in an index insensitive way?
</Description>
    <Title_Description>Buffer index sensitivity with non variant GEP instructions In the following code:
`
int f() {
  char buf[10] = {0};
  int x = buf[0];
  int y = buf[1];
  return x + y;
}
`
The GEP instructions which correspond to x and y are both constant
but when we check aliasing we get MayAlias.
Actually in both cases the LocationSet of the GepObjPN is constant and equal to 0.
Is this a bug or SVF handles buffers always in an index insensitive way?
</Title_Description>
    <Label>enhancement|help wanted</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>27/02/2017 8:48:34 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>10</IssueLabelID>
    <Title>SVFG: Calling a function twice with global pointers as a parameter</Title>
    <Description>Hi
I'm currently working with your awesome SVF analysis. During some tests with the SVFG I found a simple test-case that doesn't make sense to me. 

Why does the SVFG in Test1 has a path from "local_x" into the second "init" call?

```
int *global_p1; // NodeID= 1
int *global_p2; // NodeID= 2

void init(int **pp int *x) {
	*pp = x;
}

void delete(int **pp) {
	*pp = NULL;
}

void test1() {
	int local_x = 1; // NodeID= 10 
	int local_y = 2; // NodeID= 11

	init(&amp;global_p1 &amp;local_x);
	init(&amp;global_p2 &amp;local_y);
	delete(&amp;global_p2);
}

void test2() {
	int local_x = 1;// NodeID= 10
	int local_y = 2;// NodeID= 11
	int *local_p1;  // NodeID= 12
	int *local_p2;  // NodeID= 13

	init(&amp;local_p1 &amp;local_x);
	init(&amp;local_p2 &amp;local_y);
	delete(&amp;local_p2);
}

int main() {

	/*** Test 1:
	 * There will be a path from the "local_x" into the second call of "init"
        * (10 -&gt; 60 -&gt; 20 -&gt; 16 -&gt; 21 -&gt; 53 -&gt; 21 -&gt; ...)
	 * but "local_x" was only written into "global_p1" and not into "global_p2".
	 */ 
	//test1();

	/*** Test 2:
	 * Writing "local_x" into "local_p1" creates the SVFG which I would
	 * have expected also in Test1.
	 */ 
	//test2();
	return 0;
}
```

These are the result I get with: _saber -leak -dump-svfg main.bc_
SVFG of Test1:
![saber_svfg_test1](https://cloud.githubusercontent.com/assets/15213455/21852134/2f520b32-d812-11e6-8451-09bdf625a71e.png)

SVFG of Test2:
![saber_svfg_test2](https://cloud.githubusercontent.com/assets/15213455/21852145/3b108d18-d812-11e6-88ed-4579ad8a18b5.png)</Description>
    <Title_Description>SVFG: Calling a function twice with global pointers as a parameter Hi
I'm currently working with your awesome SVF analysis. During some tests with the SVFG I found a simple test-case that doesn't make sense to me. 

Why does the SVFG in Test1 has a path from "local_x" into the second "init" call?

```
int *global_p1; // NodeID= 1
int *global_p2; // NodeID= 2

void init(int **pp int *x) {
	*pp = x;
}

void delete(int **pp) {
	*pp = NULL;
}

void test1() {
	int local_x = 1; // NodeID= 10 
	int local_y = 2; // NodeID= 11

	init(&amp;global_p1 &amp;local_x);
	init(&amp;global_p2 &amp;local_y);
	delete(&amp;global_p2);
}

void test2() {
	int local_x = 1;// NodeID= 10
	int local_y = 2;// NodeID= 11
	int *local_p1;  // NodeID= 12
	int *local_p2;  // NodeID= 13

	init(&amp;local_p1 &amp;local_x);
	init(&amp;local_p2 &amp;local_y);
	delete(&amp;local_p2);
}

int main() {

	/*** Test 1:
	 * There will be a path from the "local_x" into the second call of "init"
        * (10 -&gt; 60 -&gt; 20 -&gt; 16 -&gt; 21 -&gt; 53 -&gt; 21 -&gt; ...)
	 * but "local_x" was only written into "global_p1" and not into "global_p2".
	 */ 
	//test1();

	/*** Test 2:
	 * Writing "local_x" into "local_p1" creates the SVFG which I would
	 * have expected also in Test1.
	 */ 
	//test2();
	return 0;
}
```

These are the result I get with: _saber -leak -dump-svfg main.bc_
SVFG of Test1:
![saber_svfg_test1](https://cloud.githubusercontent.com/assets/15213455/21852134/2f520b32-d812-11e6-8451-09bdf625a71e.png)

SVFG of Test2:
![saber_svfg_test2](https://cloud.githubusercontent.com/assets/15213455/21852145/3b108d18-d812-11e6-88ed-4579ad8a18b5.png)</Title_Description>
    <Label>enhancement|help wanted</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>11/01/2017 3:10:37 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>7</IssueLabelID>
    <Title>PAG: "black hole" and "variant GEP" edges?</Title>
    <Description>Hi

What are "black hole" and "variant GEP" edges (black hole especially) and what roles do they play in the precision/performance of the various analyses?
</Description>
    <Title_Description>PAG: "black hole" and "variant GEP" edges? Hi

What are "black hole" and "variant GEP" edges (black hole especially) and what roles do they play in the precision/performance of the various analyses?
</Title_Description>
    <Label>help wanted|question</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>11/05/2016 11:33:27 PM +00:00</CreatedAt>
    <ClosedAt>12/05/2016 12:41:36 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>6</IssueLabelID>
    <Title>AndersenLCD implementation "incomplete": documentation and efficiency</Title>
    <Description>The implementation of lazy cycle detection is [described as 'incomplete' in Andersen.h](https://github.com/unsw-corg/SVF/blob/8ef26adf7d500bec03d241030fc1157c7757a85f/include/WPA/Andersen.h#L389)
is the implemented approach documented somewhere?

If not could this be documented?

I suppose I'm unsure in what way what's implemented is "lazy cycle detection" is it?
</Description>
    <Title_Description>AndersenLCD implementation "incomplete": documentation and efficiency The implementation of lazy cycle detection is [described as 'incomplete' in Andersen.h](https://github.com/unsw-corg/SVF/blob/8ef26adf7d500bec03d241030fc1157c7757a85f/include/WPA/Andersen.h#L389)
is the implemented approach documented somewhere?

If not could this be documented?

I suppose I'm unsure in what way what's implemented is "lazy cycle detection" is it?
</Title_Description>
    <Label>help wanted|question</Label>
    <Assignee>yuleisui</Assignee>
    <CreatedAt>11/05/2016 11:19:39 PM +00:00</CreatedAt>
    <ClosedAt>12/05/2016 12:42:04 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5</IssueLabelID>
    <Title>cmake build support (required for use with LLVM newer than 3.8 release)</Title>
    <Description>LLVM deprecated autoconf in favor of CMake around the 3.8 release which means projects must move to CMake in order to be used with newer versions of LLVM.

Mostly filing issue to track the status of CMake support in SVF :).

Any plans on adding it in order to support continued use with LLVM?
</Description>
    <Title_Description>cmake build support (required for use with LLVM newer than 3.8 release) LLVM deprecated autoconf in favor of CMake around the 3.8 release which means projects must move to CMake in order to be used with newer versions of LLVM.

Mostly filing issue to track the status of CMake support in SVF :).

Any plans on adding it in order to support continued use with LLVM?
</Title_Description>
    <Label>help wanted|invalid</Label>
    <Assignee>unsw-corg|yuleisui</Assignee>
    <CreatedAt>11/05/2016 11:01:22 PM +00:00</CreatedAt>
    <ClosedAt>7/07/2016 3:38:26 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>2</IssueLabelID>
    <Title>singleton instances unclear memory ownership</Title>
    <Description>- Data-structures not created by not destroyed
  - unable to run same analysis on different modules (in sequence) due to persisting datastructures (like SymbolInfo).
- Singletons are expected to be initialized for current module/analysis
  - can't analyze modules in parallel.
- Unclear ownership/sharing patterns especially regarding PAG and SymbolInfo.
- Non-static instances using singletons fail in unexpected ways if singletons already existed for another reason.
  - complicates use of analysis in a PassManager

The current code is remarkably close to being free of these singletons but requires some careful work to remove them while preserving the overall architecture.  I tried locally but it was a bit of a mess O:).

Is this something you could look at?
</Description>
    <Title_Description>singleton instances, unclear memory ownership - Data-structures not created by not destroyed
  - unable to run same analysis on different modules (in sequence) due to persisting datastructures (like SymbolInfo).
- Singletons are expected to be initialized for current module/analysis
  - can't analyze modules in parallel.
- Unclear ownership/sharing patterns especially regarding PAG and SymbolInfo.
- Non-static instances using singletons fail in unexpected ways if singletons already existed for another reason.
  - complicates use of analysis in a PassManager

The current code is remarkably close to being free of these singletons but requires some careful work to remove them while preserving the overall architecture.  I tried locally but it was a bit of a mess O:).

Is this something you could look at?
</Title_Description>
    <Label>question</Label>
    <Assignee>unsw-corg|yuleisui</Assignee>
    <CreatedAt>11/05/2016 10:46:51 PM +00:00</CreatedAt>
    <ClosedAt>13/05/2016 11:33:26 PM +00:00</ClosedAt>
  </IssueDetail>
</IssueDetails>